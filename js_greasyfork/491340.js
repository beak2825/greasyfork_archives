// ==UserScript==
// @name         Bossç›´è˜åŠ©æ‰‹
// @namespace    https://github.com/Ocyss/boos-helper
// @version      0.3.2
// @author       Ocyss
// @description  ä¼˜åŒ–UIåŽ»é™¤å¹¿å‘Š,æ‰¹é‡æŠ•é€’ç®€åŽ†,é«˜çº§ç­›é€‰,GPTè‡ªåŠ¨æ‰“æ‹›å‘¼,å¤šè´¦å·ç®¡ç†...
// @license      MIT
// @icon         https://img.bosszhipin.com/beijin/mcs/banner/3e9d37e9effaa2b6daf43f3f03f7cb15cfcd208495d565ef66e7dff9f98764da.jpg
// @homepage     https://github.com/Ocyss/boos-helper
// @match        https://*.zhipin.com/*
// @require      https://cdn.jsdelivr.net/npm/vue@3.5.13/dist/vue.global.prod.js
// @require      data:application/javascript,%3Bwindow.Vue%3DVue%3B
// @require      https://cdn.jsdelivr.net/npm/element-plus@2.9.6/dist/index.full.min.js
// @require      https://cdn.jsdelivr.net/npm/protobufjs@7.4.0/dist/light/protobuf.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/system.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/extras/named-register.min.js
// @require      data:application/javascript,%3B(typeof%20System!%3D'undefined')%26%26(System%3Dnew%20System.constructor())%3B
// @resource     element-plus/dist/index.css                 https://cdn.jsdelivr.net/npm/element-plus@2.9.6/dist/index.css
// @resource     element-plus/theme-chalk/dark/css-vars.css  https://cdn.jsdelivr.net/npm/element-plus@2.9.6/theme-chalk/dark/css-vars.css
// @connect      api.chatanywhere.com.cn
// @connect      api.moonshot.cn
// @connect      aliyuncs.com
// @connect      baidubce.com
// @grant        GM_addStyle
// @grant        GM_cookie
// @grant        GM_getResourceText
// @grant        GM_getValue
// @grant        GM_notification
// @grant        GM_setValue
// @grant        GM_xmlhttpRequest
// @grant        unsafeWindow
// @run-at       document-start
// @downloadURL https://update.greasyfork.org/scripts/491340/Boss%E7%9B%B4%E8%81%98%E5%8A%A9%E6%89%8B.user.js
// @updateURL https://update.greasyfork.org/scripts/491340/Boss%E7%9B%B4%E8%81%98%E5%8A%A9%E6%89%8B.meta.js
// ==/UserScript==
// æ›´æ–°æ—¥å¿—[åªæ˜¾ç¤ºæœ€æ–°çš„10æ¡,ðŸŒŸðŸ¤¡ åˆ†åˆ«ä»£è¡¨æ–°åŠŸèƒ½å’Œbugä¿®å¤]
// v0.2.7 æ·»åŠ æ‰©å±•é€šçŸ¥
// v0.2.6 ðŸŒŸ æ·»åŠ æŠ•é€’ä¸Šé™é…ç½®
// v0.2.5 ðŸŒŸ æ·»åŠ æ‰£å­æ¨¡åž‹(æµ‹è¯•)ï¼Œç¦ç”¨stream, æ–‡å¿ƒä¸€è¨€, é€šä¹‰åƒé—®
// v0.2.4-fix2 ðŸ¤¡ ä¿®å¤æŠ•é€’é™åˆ¶é€»è¾‘ï¼ŒæˆåŠŸæŠ•é€’è¾¾åˆ°100æ—¶è‡ªåŠ¨æš‚åœ
// v0.2.4-fix ðŸŒŸðŸ¤¡ æ”¯æŒå®Œæ•´urlè°ƒç”¨gptï¼Œä¿®å¤promptåœ¨gptè¯·æ±‚æ—¶å’Œç¼–è¾‘æ—¶ä¿®æ”¹åˆ°formä¸­
// v0.2.4 ðŸŒŸ HrèŒä½ç­›é€‰, UIä¼˜åŒ–, åˆå§‹å¸®åŠ©
// v0.2.3 ðŸŒŸðŸ¤¡ é…ç½®çš„å¯¼å…¥å¯¼å‡º, stream ç¦ç”¨, äº¤é›†è–ªèµ„èŒƒå›´, ä¼˜åŒ–tabå, å¤šè¡Œè¾“å…¥æ¡†
// v0.2.2 ðŸ¤¡ðŸŒŸ æ·»åŠ äº‘é€šçŸ¥ï¼Œä¿®å¤chatéƒ¨åˆ†é”™è¯¯ï¼Œç¦ç”¨ä¸€äº›åŠŸèƒ½(è§£å†³ä¸äº†é—®é¢˜å°±å…ˆè§£å†³å‡ºé—®é¢˜çš„åŠŸèƒ½ðŸ˜…)
// v0.2.1 ðŸ¤¡ðŸŒŸ ä¿®å¤æ— æ³•èŽ·å–åˆ°tokençš„é—®é¢˜, æ·»åŠ å¥½å‹çŠ¶æ€è¿‡æ»¤(æœªæµ‹è¯•)
// v0.2.0-2 ðŸŒŸ é€‚é…æ›´å¤šGPT,å¤šç§ä¸åŒçš„è¯·æ±‚æ–¹å¼,æ›´å¤šçš„å‚æ•°,æ›´å¤šçš„ç­›é€‰,å»¶è¿Ÿé…ç½®,å¢žåŠ èŠå¤©æ°”æ³¡(åŽç»­ä¼šå®Œå–„)
// v0.2.0-1 ðŸŒŸ ä½¿ç”¨partial-jsonæ¥ä¿®å¤jsoné”™è¯¯ã€‚æ¨¡åž‹å­˜å‚¨ä½¿ç”¨æ•°ç»„ï¼Œæ›´æ–°ç‰ˆæœ¬åŽè¯·é‡æ–°é…ç½®æ¨¡åž‹
// v0.2.0 ðŸ¤¡ ä¿®å¤æ‰€æœ‰å·²çŸ¥çš„BUG
// v0.1.6-fix2 ðŸ¤¡ ä¿®å¤å…¬å¸åç­›é€‰æŠ¥é”™,ä¿®å¤éƒ¨åˆ†åŠŸèƒ½æ— æ³•æ­£ç¡®ç­›é€‰
// v0.1.6-fix ðŸ¤¡ ä¿®å¤è‡ªå®šä¹‰æ‹›å‘¼è¯­ä¸å‘é€ï¼Œä¿®å¤é…ç½®å¼€å…³æ²¡æ–‡å­—ï¼Œéšè—æ²¡æ‰¾åˆ°vueçš„æç¤º
// v0.1.6-2 ðŸŒŸ æ›´å¤šä¼˜åŒ–å’Œæé†’ï¼Œå®Œå–„è®°å½•å†…å®¹ï¼Œç­›é€‰é—®é¢˜ä¸­åŠ å…¥å…¬å¸ç¦åˆ©å†…å®¹æ›´å‡†
// v0.1.6-1 ðŸŒŸðŸ¤¡ æ›´æ”¹å…ƒç´ æŸ¥æ‰¾é€»è¾‘æ›´å¿«æ›´å‡†ï¼Œè°ƒæ•´è¿è¡Œæ—¶æœŸè¿‡æ¸¡æ›´åŠ æµç•…ï¼Œä½¿ç”¨CDNä¼˜åŒ–å¤§å°ï¼Œä¿®å¤éƒ¨åˆ†æ ·å¼é—®é¢˜
// v0.1.5 ðŸ¤¡ ä¿®å¤ç¼–è¯‘åŽæ‹¿ä¸åˆ°windowæ•°æ®å¯¼è‡´æŠ¥é”™çš„ä¸¥é‡Bug
// v0.1.4 ðŸŒŸðŸ¤¡ å¡ç‰‡çŠ¶æ€é€‚é…ç™½å¤©ï¼Œä¿®å¤å°†gptæç¤ºå‘é€ç»™boos

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const r=document.createElement("style");r.textContent=e,document.head.append(r)})(' @charset "UTF-8";#boos-helper{position:fixed;top:55px;right:10px;z-index:999}.el-dropdown .el-avatar{border:2px solid #fff}.el-dropdown .el-avatar:hover{border:3px solid #c413e7}.el-dropdown-menu__item{justify-content:center}::-webkit-scrollbar{width:11px;height:11px}::-webkit-scrollbar-thumb{border-radius:10px;background-color:#4b5563;border:2px solid transparent;background-clip:padding-box}#loader{width:0;height:4.8px;display:inline-block;position:relative;background:#54f98d;box-shadow:0 0 10px #ffffff80;box-sizing:border-box;top:-14px}#loader:after,#loader:before{content:"";width:10px;height:1px;background:#fff;position:absolute;top:9px;right:-2px;opacity:0;transform:rotate(-45deg) translate(0);box-sizing:border-box;animation:coli1 .3s linear infinite}#loader:before{top:-4px;transform:rotate(45deg);animation:coli2 .3s linear infinite}@keyframes coli1{0%{transform:rotate(-45deg) translate(0);opacity:.7}to{transform:rotate(-45deg) translate(-45px);opacity:0}}@keyframes coli2{0%{transform:rotate(45deg) translate(0);opacity:1}to{transform:rotate(45deg) translate(-45px);opacity:.7}}:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645,.045,.355,1);--el-transition-function-fast-bezier:cubic-bezier(.23,1,.32,1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px;color-scheme:light;--el-color-primary:#409eff;--el-color-primary-light-3:rgb(121.3,187.1,255);--el-color-primary-light-5:rgb(159.5,206.5,255);--el-color-primary-light-7:rgb(197.7,225.9,255);--el-color-primary-light-8:rgb(216.8,235.6,255);--el-color-primary-light-9:rgb(235.9,245.3,255);--el-color-primary-dark-2:rgb(51.2,126.4,204);--el-color-success:#67c23a;--el-color-success-light-3:rgb(148.6,212.3,117.1);--el-color-success-light-5:rgb(179,224.5,156.5);--el-color-success-light-7:rgb(209.4,236.7,195.9);--el-color-success-light-8:rgb(224.6,242.8,215.6);--el-color-success-light-9:rgb(239.8,248.9,235.3);--el-color-success-dark-2:rgb(82.4,155.2,46.4);--el-color-warning:#e6a23c;--el-color-warning-light-3:rgb(237.5,189.9,118.5);--el-color-warning-light-5:rgb(242.5,208.5,157.5);--el-color-warning-light-7:rgb(247.5,227.1,196.5);--el-color-warning-light-8:rgb(250,236.4,216);--el-color-warning-light-9:rgb(252.5,245.7,235.5);--el-color-warning-dark-2:rgb(184,129.6,48);--el-color-danger:#f56c6c;--el-color-danger-light-3:rgb(248,152.1,152.1);--el-color-danger-light-5:rgb(250,181.5,181.5);--el-color-danger-light-7:rgb(252,210.9,210.9);--el-color-danger-light-8:rgb(253,225.6,225.6);--el-color-danger-light-9:rgb(254,240.3,240.3);--el-color-danger-dark-2:rgb(196,86.4,86.4);--el-color-error:#f56c6c;--el-color-error-light-3:rgb(248,152.1,152.1);--el-color-error-light-5:rgb(250,181.5,181.5);--el-color-error-light-7:rgb(252,210.9,210.9);--el-color-error-light-8:rgb(253,225.6,225.6);--el-color-error-light-9:rgb(254,240.3,240.3);--el-color-error-dark-2:rgb(196,86.4,86.4);--el-color-info:#909399;--el-color-info-light-3:rgb(177.3,179.4,183.6);--el-color-info-light-5:rgb(199.5,201,204);--el-color-info-light-7:rgb(221.7,222.6,224.4);--el-color-info-light-8:rgb(232.8,233.4,234.6);--el-color-info-light-9:rgb(243.9,244.2,244.8);--el-color-info-dark-2:rgb(115.2,117.6,122.4);--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0,0,0,.04),0px 8px 20px rgba(0,0,0,.08);--el-box-shadow-light:0px 0px 12px rgba(0,0,0,.12);--el-box-shadow-lighter:0px 0px 6px rgba(0,0,0,.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0,0,0,.08),0px 12px 32px rgba(0,0,0,.12),0px 8px 16px -8px rgba(0,0,0,.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0,0,0,.8);--el-overlay-color-light:rgba(0,0,0,.7);--el-overlay-color-lighter:rgba(0,0,0,.5);--el-mask-color:rgba(255,255,255,.9);--el-mask-color-extra-light:rgba(255,255,255,.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.el-icon-loading{animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.el-icon{--color:inherit;align-items:center;display:inline-flex;height:1em;justify-content:center;line-height:1em;position:relative;width:1em;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255,255,255,.5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-text-color-secondary);--el-button-active-color:var(--el-text-color-primary);align-items:center;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);box-sizing:border-box;color:var(--el-button-text-color);cursor:pointer;display:inline-flex;font-weight:var(--el-button-font-weight);height:32px;justify-content:center;line-height:1;outline:none;text-align:center;transition:.1s;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-button:hover{background-color:var(--el-button-hover-bg-color);border-color:var(--el-button-hover-border-color);color:var(--el-button-hover-text-color);outline:none}.el-button:active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button>span{align-items:center;display:inline-flex}.el-button+.el-button{margin-left:12px}.el-button{border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base)}.el-button,.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button.is-disabled,.el-button.is-disabled:hover{background-color:var(--el-button-disabled-bg-color);background-image:none;border-color:var(--el-button-disabled-border-color);color:var(--el-button-disabled-text-color);cursor:not-allowed}.el-button.is-loading{pointer-events:none;position:relative}.el-button.is-loading:before{background-color:var(--el-mask-color-extra-light);border-radius:inherit;bottom:-1px;content:"";left:-1px;pointer-events:none;position:absolute;right:-1px;top:-1px;z-index:1}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px;width:32px}.el-button.is-text{background-color:transparent;border:0 solid transparent;color:var(--el-button-text-color)}.el-button.is-text.is-disabled{background-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{background:transparent;border-color:transparent;color:var(--el-button-text-color);height:auto;padding:2px}.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-link:not(.is-disabled):active,.el-button.is-link:not(.is-disabled):hover{background-color:transparent;border-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color)}.el-button--text{background:transparent;border-color:transparent;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button--text:not(.is-disabled):hover{background-color:transparent;border-color:transparent;color:var(--el-color-primary-light-3)}.el-button--text:not(.is-disabled):active{background-color:transparent;border-color:transparent;color:var(--el-color-primary-dark-2)}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8);color:var(--el-color-primary-light-5)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8);color:var(--el-color-success-light-5)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8);color:var(--el-color-warning-light-5)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8);color:var(--el-color-danger-light-5)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8);color:var(--el-color-info-light-5)}.el-button--large{--el-button-size:40px;height:var(--el-button-size)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large{border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base);padding:12px 19px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{padding:12px;width:var(--el-button-size)}.el-button--small{--el-button-size:24px;height:var(--el-button-size)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small{border-radius:calc(var(--el-border-radius-base) - 1px);font-size:12px;padding:5px 11px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{padding:5px;width:var(--el-button-size)}.el-link{--el-link-font-size:var(--el-font-size-base);--el-link-font-weight:var(--el-font-weight-primary);--el-link-text-color:var(--el-text-color-regular);--el-link-hover-text-color:var(--el-color-primary);--el-link-disabled-text-color:var(--el-text-color-placeholder);align-items:center;color:var(--el-link-text-color);cursor:pointer;display:inline-flex;flex-direction:row;font-size:var(--el-link-font-size);font-weight:var(--el-link-font-weight);justify-content:center;outline:none;padding:0;position:relative;text-decoration:none;vertical-align:middle}.el-link:hover{color:var(--el-link-hover-text-color)}.el-link.is-underline:hover:after{border-bottom:1px solid var(--el-link-hover-text-color);bottom:0;content:"";height:0;left:0;position:absolute;right:0}.el-link.is-disabled{color:var(--el-link-disabled-text-color);cursor:not-allowed}.el-link [class*=el-icon-]+span{margin-left:5px}.el-link.el-link--default:after{border-color:var(--el-link-hover-text-color)}.el-link__inner{align-items:center;display:inline-flex;justify-content:center}.el-link.el-link--primary{--el-link-text-color:var(--el-color-primary);--el-link-hover-text-color:var(--el-color-primary-light-3);--el-link-disabled-text-color:var(--el-color-primary-light-5)}.el-link.el-link--primary.is-underline:hover:after,.el-link.el-link--primary:after{border-color:var(--el-link-text-color)}.el-link.el-link--success{--el-link-text-color:var(--el-color-success);--el-link-hover-text-color:var(--el-color-success-light-3);--el-link-disabled-text-color:var(--el-color-success-light-5)}.el-link.el-link--success.is-underline:hover:after,.el-link.el-link--success:after{border-color:var(--el-link-text-color)}.el-link.el-link--warning{--el-link-text-color:var(--el-color-warning);--el-link-hover-text-color:var(--el-color-warning-light-3);--el-link-disabled-text-color:var(--el-color-warning-light-5)}.el-link.el-link--warning.is-underline:hover:after,.el-link.el-link--warning:after{border-color:var(--el-link-text-color)}.el-link.el-link--danger{--el-link-text-color:var(--el-color-danger);--el-link-hover-text-color:var(--el-color-danger-light-3);--el-link-disabled-text-color:var(--el-color-danger-light-5)}.el-link.el-link--danger.is-underline:hover:after,.el-link.el-link--danger:after{border-color:var(--el-link-text-color)}.el-link.el-link--error{--el-link-text-color:var(--el-color-error);--el-link-hover-text-color:var(--el-color-error-light-3);--el-link-disabled-text-color:var(--el-color-error-light-5)}.el-link.el-link--error.is-underline:hover:after,.el-link.el-link--error:after{border-color:var(--el-link-text-color)}.el-link.el-link--info{--el-link-text-color:var(--el-color-info);--el-link-hover-text-color:var(--el-color-info-light-3);--el-link-disabled-text-color:var(--el-color-info-light-5)}.el-link.el-link--info.is-underline:hover:after,.el-link.el-link--info:after{border-color:var(--el-link-text-color)}.el-alert{--el-alert-padding:8px 16px;--el-alert-border-radius-base:var(--el-border-radius-base);--el-alert-title-font-size:14px;--el-alert-title-with-description-font-size:16px;--el-alert-description-font-size:14px;--el-alert-close-font-size:16px;--el-alert-close-customed-font-size:14px;--el-alert-icon-size:16px;--el-alert-icon-large-size:28px;align-items:center;background-color:var(--el-color-white);border-radius:var(--el-alert-border-radius-base);box-sizing:border-box;display:flex;margin:0;opacity:1;overflow:hidden;padding:var(--el-alert-padding);position:relative;transition:opacity var(--el-transition-duration-fast);width:100%}.el-alert.is-light .el-alert__close-btn{color:var(--el-text-color-placeholder)}.el-alert.is-dark .el-alert__close-btn,.el-alert.is-dark .el-alert__description{color:var(--el-color-white)}.el-alert.is-center{justify-content:center}.el-alert--success{--el-alert-bg-color:var(--el-color-success-light-9)}.el-alert--success.is-light{background-color:var(--el-alert-bg-color)}.el-alert--success.is-light,.el-alert--success.is-light .el-alert__description{color:var(--el-color-success)}.el-alert--success.is-dark{background-color:var(--el-color-success);color:var(--el-color-white)}.el-alert--info{--el-alert-bg-color:var(--el-color-info-light-9)}.el-alert--info.is-light{background-color:var(--el-alert-bg-color)}.el-alert--info.is-light,.el-alert--info.is-light .el-alert__description{color:var(--el-color-info)}.el-alert--info.is-dark{background-color:var(--el-color-info);color:var(--el-color-white)}.el-alert--warning{--el-alert-bg-color:var(--el-color-warning-light-9)}.el-alert--warning.is-light{background-color:var(--el-alert-bg-color)}.el-alert--warning.is-light,.el-alert--warning.is-light .el-alert__description{color:var(--el-color-warning)}.el-alert--warning.is-dark{background-color:var(--el-color-warning);color:var(--el-color-white)}.el-alert--error{--el-alert-bg-color:var(--el-color-error-light-9)}.el-alert--error.is-light{background-color:var(--el-alert-bg-color)}.el-alert--error.is-light,.el-alert--error.is-light .el-alert__description{color:var(--el-color-error)}.el-alert--error.is-dark{background-color:var(--el-color-error);color:var(--el-color-white)}.el-alert__content{display:flex;flex-direction:column;gap:4px}.el-alert .el-alert__icon{font-size:var(--el-alert-icon-size);margin-right:8px;width:var(--el-alert-icon-size)}.el-alert .el-alert__icon.is-big{font-size:var(--el-alert-icon-large-size);margin-right:12px;width:var(--el-alert-icon-large-size)}.el-alert__title{font-size:var(--el-alert-title-font-size);line-height:24px}.el-alert__title.with-description{font-size:var(--el-alert-title-with-description-font-size)}.el-alert .el-alert__description{font-size:var(--el-alert-description-font-size);margin:0}.el-alert .el-alert__close-btn{cursor:pointer;font-size:var(--el-alert-close-font-size);opacity:1;position:absolute;right:16px;top:12px}.el-alert .el-alert__close-btn.is-customed{font-size:var(--el-alert-close-customed-font-size);font-style:normal;line-height:24px;top:8px}.el-alert-fade-enter-from,.el-alert-fade-leave-active{opacity:0}.el-badge{--el-badge-bg-color:var(--el-color-danger);--el-badge-radius:10px;--el-badge-font-size:12px;--el-badge-padding:6px;--el-badge-size:18px;display:inline-block;position:relative;vertical-align:middle;width:-moz-fit-content;width:fit-content}.el-badge__content{align-items:center;background-color:var(--el-badge-bg-color);border:1px solid var(--el-bg-color);border-radius:var(--el-badge-radius);color:var(--el-color-white);display:inline-flex;font-size:var(--el-badge-font-size);height:var(--el-badge-size);justify-content:center;padding:0 var(--el-badge-padding);white-space:nowrap}.el-badge__content.is-fixed{position:absolute;right:calc(1px + var(--el-badge-size)/2);top:0;transform:translateY(-50%) translate(100%);z-index:var(--el-index-normal)}.el-badge__content.is-fixed.is-dot{right:5px}.el-badge__content.is-dot{border-radius:50%;height:8px;padding:0;right:0;width:8px}.el-badge__content.is-hide-zero{display:none}.el-badge__content--primary{background-color:var(--el-color-primary)}.el-badge__content--success{background-color:var(--el-color-success)}.el-badge__content--warning{background-color:var(--el-color-warning)}.el-badge__content--info{background-color:var(--el-color-info)}.el-badge__content--danger{background-color:var(--el-color-danger)}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px;align-items:center;background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);border-radius:var(--el-tag-border-radius);border-style:solid;border-width:1px;box-sizing:border-box;color:var(--el-tag-text-color);display:inline-flex;font-size:var(--el-tag-font-size);height:24px;justify-content:center;line-height:1;padding:0 9px;vertical-align:middle;white-space:nowrap;--el-icon-size:14px}.el-tag,.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color);flex-shrink:0}.el-tag .el-tag__close:hover{background-color:var(--el-tag-hover-color);color:var(--el-color-white)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-text-color:var(--el-color-white)}.el-tag--dark,.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info,.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning{--el-tag-text-color:var(--el-color-white)}.el-tag--plain,.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{height:32px;padding:0 11px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{height:20px;padding:0 7px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.card-grid[data-v-d2ec6d12]{display:grid;gap:1rem;grid-template-columns:repeat(auto-fill,minmax(250px,1fr));margin:0 0 1.5rem;position:relative;overflow-x:scroll;scrollbar-color:#c6c6c6 #e9e9e9;scrollbar-gutter:always;padding:3rem 0 3rem 2rem;margin:0;display:flex;color:#000;-webkit-overflow-scrolling:touch}.card-grid[data-v-d2ec6d12]::-webkit-scrollbar{width:10px;height:10px}.card-grid[data-v-d2ec6d12]::-webkit-scrollbar-thumb{background:#434343;border-radius:10px;box-shadow:inset 2px 2px 2px #ffffff40,inset -2px -2px 2px #00000040}.card-grid[data-v-d2ec6d12]::-webkit-scrollbar-track{background:linear-gradient(90deg,#434343,#434343 1px,#262626 0,#262626)}.card[data-v-d2ec6d12]{--state-color: #f00;--state-show: block;padding:1.5rem;border-radius:16px;background:linear-gradient(85deg,#f2eeee,#eff0f6);color:#000;display:flex;flex-direction:column;transition:.2s;margin:0;position:relative;min-width:300px;min-height:350px;box-shadow:-2rem 0 1rem -2rem #cdb9b9}.card[data-v-d2ec6d12] *{-webkit-user-select:none;user-select:none}.card .card-status[data-v-d2ec6d12]{position:absolute;display:var(--state-show);border-radius:0 30px 30px 0;background-color:var(--state-color);color:#fff;padding:7px 17px;text-wrap:nowrap;font-size:12px;font-weight:700;letter-spacing:5px;left:-6px;bottom:-14px;transition:all .25s ease;box-shadow:1px -7px 12px -2px #a7a7a766}.card[data-v-d2ec6d12]:after{position:absolute;content:"";display:var(--state-show);left:-6px;bottom:18px;width:0;height:0;border-left:6px solid transparent;border-right:0px solid transparent;border-bottom:10px solid oklch(from var(--state-color) calc(l*.75) c h)}.card .card-tag[data-v-d2ec6d12]{display:block;margin:0 0 .25rem;color:#6a6868;font-size:.7rem}.card .card-title[data-v-d2ec6d12]{font-size:1.3rem;margin:0 0 8px}.card .card-salary[data-v-d2ec6d12]{font-size:1.1rem;margin:0 0 1rem;color:#ff442e}.card .card-footer[data-v-d2ec6d12]{-webkit-margin-before:auto;margin-block-start:auto;padding:5px 0}.card .avatar[data-v-d2ec6d12]{width:40px;height:40px;border-radius:50%;margin-right:.5rem}.card .author-row[data-v-d2ec6d12]{display:grid;grid-template-columns:40px 1fr;gap:.5rem;align-items:center;color:#a09f9f;line-height:1.3;padding-top:.5rem}.card .author-row .company-name[data-v-d2ec6d12]{color:#000}.card[data-v-d2ec6d12]:focus-within,.card[data-v-d2ec6d12]:hover{transform:translateY(-1rem) rotate(3deg)}.card:focus-within~.card[data-v-d2ec6d12],.card:hover~.card[data-v-d2ec6d12]{transform:translate(130px)}.card[data-v-d2ec6d12]:first-child:focus-within,.card[data-v-d2ec6d12]:first-child:hover{transform:translate(-.5rem,-1rem) rotate(3deg)}.card[data-v-d2ec6d12]:not(:first-child){margin-left:-130px;box-shadow:-3rem 0 3rem -3rem #b4adad}@media (max-width: 1200px){.card[data-v-d2ec6d12]{min-width:250px}.card[data-v-d2ec6d12]:not(:first-child){margin-left:-30px}.card[data-v-d2ec6d12]:hover{transform:translateY(-1rem)}.card:hover~.card[data-v-d2ec6d12]{transform:translate(30px)}}html.dark .card-grid[data-v-d2ec6d12]{scrollbar-color:#666 #201c29;color:#fff}html.dark .card-grid[data-v-d2ec6d12]::-webkit-scrollbar-thumb{background:#434343;box-shadow:inset 2px 2px 2px #ffffff40,inset -2px -2px 2px #00000040}html.dark .card-grid[data-v-d2ec6d12]::-webkit-scrollbar-track{background:linear-gradient(90deg,#434343,#434343 1px,#262626 0,#262626)}html.dark .card[data-v-d2ec6d12]{background:linear-gradient(85deg,#434343,#262626);color:#fff;box-shadow:-2rem 0 1rem -2rem #000}html.dark .card .card-status[data-v-d2ec6d12]{color:#fff;box-shadow:1px -7px 12px -2px #a7a7a766}html.dark .card .card-tag[data-v-d2ec6d12]{color:#b4b4b4}html.dark .card .card-salary[data-v-d2ec6d12]{color:#ff442e}html.dark .card .author-row[data-v-d2ec6d12]{color:#a09f9f}html.dark .card .author-row .company-name[data-v-d2ec6d12]{color:#fff}html.dark .card[data-v-d2ec6d12]:not(:first-child){box-shadow:-3rem 0 3rem -3rem #000}.el-avatar{--el-avatar-text-color:var(--el-color-white);--el-avatar-bg-color:var(--el-text-color-disabled);--el-avatar-text-size:14px;--el-avatar-icon-size:18px;--el-avatar-border-radius:var(--el-border-radius-base);--el-avatar-size-large:56px;--el-avatar-size-small:24px;--el-avatar-size:40px;align-items:center;background:var(--el-avatar-bg-color);box-sizing:border-box;color:var(--el-avatar-text-color);display:inline-flex;font-size:var(--el-avatar-text-size);height:var(--el-avatar-size);justify-content:center;outline:none;overflow:hidden;text-align:center;width:var(--el-avatar-size)}.el-avatar>img{display:block;height:100%;width:100%}.el-avatar--circle{border-radius:50%}.el-avatar--square{border-radius:var(--el-avatar-border-radius)}.el-avatar--icon{font-size:var(--el-avatar-icon-size)}.el-avatar--small{--el-avatar-size:24px}.el-avatar--large{--el-avatar-size:56px}.vue-recycle-scroller{position:relative}.vue-recycle-scroller.direction-vertical:not(.page-mode){overflow-y:auto}.vue-recycle-scroller.direction-horizontal:not(.page-mode){overflow-x:auto}.vue-recycle-scroller.direction-horizontal{display:flex}.vue-recycle-scroller__slot{flex:auto 0 0}.vue-recycle-scroller__item-wrapper{flex:1;box-sizing:border-box;overflow:hidden;position:relative}.vue-recycle-scroller.ready .vue-recycle-scroller__item-view{position:absolute;top:0;left:0;will-change:transform}.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper{width:100%}.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper{height:100%}.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view{width:100%}.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view{height:100%}.resize-observer[data-v-b329ee4c]{position:absolute;top:0;left:0;z-index:-1;width:100%;height:100%;border:none;background-color:transparent;pointer-events:none;display:block;overflow:hidden;opacity:0}.resize-observer[data-v-b329ee4c] object{display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;display:inline-block;font-size:var(--el-font-size-base);position:relative;vertical-align:bottom;width:100%}.el-textarea__inner{-webkit-appearance:none;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));display:block;font-family:inherit;font-size:inherit;line-height:1.5;padding:5px 11px;position:relative;resize:vertical;transition:var(--el-transition-box-shadow);width:100%}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset;outline:none}.el-textarea .el-input__count{background:var(--el-fill-color-blank);bottom:5px;color:var(--el-color-info);font-size:12px;line-height:14px;position:absolute;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;--el-input-height:var(--el-component-size);box-sizing:border-box;display:inline-flex;font-size:var(--el-font-size-base);line-height:var(--el-input-height);position:relative;vertical-align:middle;width:var(--el-input-width)}.el-input::-webkit-scrollbar{width:6px;z-index:11}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{background:var(--el-text-color-disabled);border-radius:5px;width:6px}.el-input::-webkit-scrollbar-corner,.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);cursor:pointer;font-size:14px}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{align-items:center;color:var(--el-color-info);display:inline-flex;font-size:12px;height:100%}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);display:inline-block;line-height:normal;padding-left:8px}.el-input__wrapper{align-items:center;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;cursor:text;display:inline-flex;flex-grow:1;justify-content:center;padding:1px 11px;transform:translateZ(0);transition:var(--el-transition-box-shadow)}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px)}.el-input__inner{-webkit-appearance:none;background:none;border:none;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));flex-grow:1;font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);outline:none;padding:0;width:100%}.el-input__inner:focus{outline:none}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;line-height:var(--el-input-inner-height);pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__prefix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;line-height:var(--el-input-inner-height);pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__suffix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{align-items:center;display:flex;height:inherit;justify-content:center;line-height:inherit;margin-left:8px;transition:all var(--el-transition-duration)}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color, ) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;cursor:not-allowed;pointer-events:none}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{align-items:stretch;display:inline-flex;width:100%}.el-input-group__append,.el-input-group__prepend{align-items:center;background-color:var(--el-fill-color-light);border-radius:var(--el-input-border-radius);color:var(--el-color-info);display:inline-flex;justify-content:center;min-height:100%;padding:0 20px;position:relative;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:none}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{background-color:transparent;border-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-bottom-right-radius:0;border-right:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper,.el-input-group__append{border-bottom-left-radius:0;border-top-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-bottom-right-radius:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-bottom-right-radius:0;border-top-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-bottom-left-radius:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-hidden{display:none!important}.chat-message[data-v-356813ac]{flex:1}.chat-message[data-v-356813ac]::-webkit-scrollbar{display:none}.message[data-v-356813ac]{font-size:.875rem}.message .message-content[data-v-356813ac]{padding:1rem;background-color:#fff;color:#2a2a2a;margin-right:1.25rem;margin-left:1.25rem;border-radius:1.25rem;text-align:left;display:inline-block;max-width:25rem}html.dark .message .message-content[data-v-356813ac]{background-color:#33393f;color:#dedee1}html.dark .message .message-content h6[data-v-356813ac]{color:#fff}.message .message-content h6[data-v-356813ac]{font-size:.975rem;color:#000}.message .message-content span[data-v-356813ac]{word-break:break-all;white-space:break-spaces}.message .message-options[data-v-356813ac]{display:inline-flex;align-items:center;font-size:.75rem;color:#adb5bd;margin-top:.3125rem}.message .message-options[data-v-356813ac]>*{margin-left:.3125rem;margin-right:.3125rem}.message .message-options .el-avatar[data-v-356813ac]{margin-top:-1.25rem;height:2.25rem;width:2.25rem;min-width:2.25rem;overflow:unset;box-shadow:0 0 1px 1px #0000001a;box-shadow:0 0 0 .5rem var(--body-bg-color)}.message .message-options .el-avatar[data-v-356813ac] img{width:100%;height:100%;border-radius:50%;-o-object-fit:cover;object-fit:cover;display:flex;align-items:center;justify-content:center;vertical-align:middle;border-style:none}.message .message-options .message-date[data-v-356813ac]{height:1.125rem;line-height:1.125rem;display:inline-block;vertical-align:middle}.message .message-options .message-date .date[data-v-356813ac]{display:none}.message .message-options .message-date:hover .date[data-v-356813ac]{display:inline-block}.message.self[data-v-356813ac]{text-align:right}.message.self h6[data-v-356813ac]{display:none}.message.self .message-content[data-v-356813ac]{background-color:#b4e9e8}html.dark .message.self .message-content[data-v-356813ac]{background-color:#236e69}.message.self .message-options[data-v-356813ac]{flex-direction:row-reverse}.chat-footer[data-v-356813ac]{display:flex;justify-content:space-between;align-items:flex-end;margin-top:10px;position:relative}.chat-footer .el-textarea[data-v-356813ac] .el-textarea__inner{padding-right:70px}.chat-footer .footer-right[data-v-356813ac]{display:flex;height:100%;margin:0 10px;flex-direction:column;align-items:center;position:absolute;right:0;justify-content:space-between;padding:11px 0}.el-space{display:inline-flex;vertical-align:top}.el-space__item{display:flex;flex-wrap:wrap}.el-space__item>*{flex:1}.el-space--vertical{flex-direction:column}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--inline .el-form-item{display:inline-flex;margin-right:32px;vertical-align:middle}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item--label-left .el-form-item__label{justify-content:flex-start}.el-form-item--label-top{display:block}.el-form-item--label-top .el-form-item__label{display:inline-block;height:auto;line-height:22px;margin-bottom:8px;text-align:left;vertical-align:middle}.el-form-item__label-wrap{display:flex}.el-form-item__label{align-items:flex-start;box-sizing:border-box;color:var(--el-text-color-regular);display:inline-flex;flex:0 0 auto;font-size:var(--el-form-label-font-size);height:32px;justify-content:flex-end;line-height:32px;padding:0 12px 0 0}.el-form-item__content{align-items:center;display:flex;flex:1;flex-wrap:wrap;font-size:var(--font-size);line-height:32px;min-width:0;position:relative}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;left:0;line-height:1;padding-top:2px;position:absolute;top:100%}.el-form-item__error--inline{display:inline-block;left:auto;margin-left:10px;position:relative;top:auto}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{color:var(--el-color-danger);content:"*";margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{color:var(--el-color-danger);content:"*";margin-left:4px}.el-form-item.is-error .el-input-tag__wrapper,.el-form-item.is-error .el-input-tag__wrapper.is-focus,.el-form-item.is-error .el-input-tag__wrapper:focus,.el-form-item.is-error .el-input-tag__wrapper:hover,.el-form-item.is-error .el-input__wrapper,.el-form-item.is-error .el-input__wrapper.is-focus,.el-form-item.is-error .el-input__wrapper:focus,.el-form-item.is-error .el-input__wrapper:hover,.el-form-item.is-error .el-select__wrapper,.el-form-item.is-error .el-select__wrapper.is-focus,.el-form-item.is-error .el-select__wrapper:focus,.el-form-item.is-error .el-select__wrapper:hover,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner.is-focus,.el-form-item.is-error .el-textarea__inner:focus,.el-form-item.is-error .el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:inset 0 0 0 1px transparent}.el-form-item.is-error .el-input-group__append .el-input__validateIcon,.el-form-item.is-error .el-input-group__prepend .el-input__validateIcon{display:none}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-radio-group{align-items:center;display:inline-flex;flex-wrap:wrap;font-size:0}.el-radio-button{--el-radio-button-checked-bg-color:var(--el-color-primary);--el-radio-button-checked-text-color:var(--el-color-white);--el-radio-button-checked-border-color:var(--el-color-primary);--el-radio-button-disabled-checked-fill:var(--el-border-color-extra-light)}.el-radio-button,.el-radio-button__inner{display:inline-block;outline:none;position:relative}.el-radio-button__inner{-webkit-appearance:none;background:var(--el-button-bg-color,var(--el-fill-color-blank));border:var(--el-border);border-left:0;border-radius:0;box-sizing:border-box;color:var(--el-button-text-color,var(--el-text-color-regular));cursor:pointer;font-size:var(--el-font-size-base);font-weight:var(--el-button-font-weight,var(--el-font-weight-primary));line-height:1;margin:0;padding:8px 15px;text-align:center;transition:var(--el-transition-all);-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-radio-button__inner.is-round{padding:8px 15px}.el-radio-button__inner:hover{color:var(--el-color-primary)}.el-radio-button__inner [class*=el-icon-]{line-height:.9}.el-radio-button__inner [class*=el-icon-]+span{margin-left:5px}.el-radio-button:first-child .el-radio-button__inner{border-left:var(--el-border);border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);box-shadow:none!important}.el-radio-button.is-active .el-radio-button__original-radio:not(:disabled)+.el-radio-button__inner{background-color:var(--el-radio-button-checked-bg-color,var(--el-color-primary));border-color:var(--el-radio-button-checked-border-color,var(--el-color-primary));box-shadow:-1px 0 0 0 var(--el-radio-button-checked-border-color,var(--el-color-primary));color:var(--el-radio-button-checked-text-color,var(--el-color-white))}.el-radio-button__original-radio{opacity:0;outline:none;position:absolute;z-index:-1}.el-radio-button__original-radio:focus-visible+.el-radio-button__inner{border-left:var(--el-border);border-left-color:var(--el-radio-button-checked-border-color,var(--el-color-primary));border-radius:var(--el-border-radius-base);box-shadow:none;outline:2px solid var(--el-radio-button-checked-border-color);outline-offset:1px;z-index:2}.el-radio-button__original-radio:disabled+.el-radio-button__inner{background-color:var(--el-button-disabled-bg-color,var(--el-fill-color-blank));background-image:none;border-color:var(--el-button-disabled-border-color,var(--el-border-color-light));box-shadow:none;color:var(--el-disabled-text-color);cursor:not-allowed}.el-radio-button__original-radio:disabled:checked+.el-radio-button__inner{background-color:var(--el-radio-button-disabled-checked-fill)}.el-radio-button:last-child .el-radio-button__inner{border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0}.el-radio-button:first-child:last-child .el-radio-button__inner{border-radius:var(--el-border-radius-base)}.el-radio-button--large .el-radio-button__inner{border-radius:0;font-size:var(--el-font-size-base);padding:12px 19px}.el-radio-button--large .el-radio-button__inner.is-round{padding:12px 19px}.el-radio-button--small .el-radio-button__inner{border-radius:0;font-size:12px;padding:5px 11px}.el-radio-button--small .el-radio-button__inner.is-round{padding:5px 11px}.el-alert--info.is-light,.el-alert--info.is-light .el-alert__description{white-space:pre-line}.select-form-box{display:flex;align-items:center;justify-content:space-between}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{background:var(--el-popup-modal-bg-color);height:100%;left:0;opacity:var(--el-popup-modal-opacity);position:fixed;top:0;width:100%}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:16px;--el-dialog-border-radius:var(--el-border-radius-base);background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;margin:var(--el-dialog-margin-top,15vh) auto 50px;overflow-wrap:break-word;padding:var(--el-dialog-padding-primary);position:relative;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:none!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;border-radius:0;height:100%;margin-bottom:0;overflow:auto}.el-dialog__wrapper{bottom:0;left:0;margin:0;overflow:auto;position:fixed;right:0;top:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-dialog__header{padding-bottom:var(--el-dialog-padding-primary)}.el-dialog__header.show-close{padding-right:calc(var(--el-dialog-padding-primary) + var(--el-message-close-size, 16px))}.el-dialog__headerbtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:48px;outline:none;padding:0;position:absolute;right:0;top:0;width:48px}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{color:var(--el-text-color-primary);font-size:var(--el-dialog-title-font-size);line-height:var(--el-dialog-font-line-height)}.el-dialog__body{color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{box-sizing:border-box;padding-top:var(--el-dialog-padding-primary);text-align:right}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{bottom:0;left:0;overflow:auto;position:fixed;right:0;top:0}.dialog-fade-enter-active{animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{animation:dialog-fade-out var(--el-transition-duration)}@keyframes dialog-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes dialog-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-overlay{background-color:var(--el-overlay-color-lighter);bottom:0;height:100%;left:0;overflow:auto;position:fixed;right:0;top:0;z-index:2000}.el-overlay .el-overlay-root{height:0}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary);height:100%;overflow:hidden;position:relative}.el-scrollbar__wrap{height:100%;overflow:auto}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));border-radius:inherit;cursor:pointer;display:block;height:0;opacity:var(--el-scrollbar-opacity,.3);position:relative;transition:var(--el-transition-duration) background-color;width:0}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{border-radius:4px;bottom:2px;position:absolute;right:2px;z-index:1}.el-scrollbar__bar.is-vertical{top:2px;width:6px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius,4px);border-radius:var(--el-popper-border-radius);font-size:12px;line-height:20px;min-width:10px;overflow-wrap:break-word;padding:5px 11px;position:absolute;visibility:visible;z-index:2000}.el-popper.is-dark{color:var(--el-bg-color)}.el-popper.is-dark,.el-popper.is-dark>.el-popper__arrow:before{background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark>.el-popper__arrow:before{right:0}.el-popper.is-light,.el-popper.is-light>.el-popper__arrow:before{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light>.el-popper__arrow:before{right:0}.el-popper.is-pure{padding:0}.el-popper__arrow,.el-popper__arrow:before{height:10px;position:absolute;width:10px;z-index:-1}.el-popper__arrow:before{background:var(--el-text-color-primary);box-sizing:border-box;content:" ";transform:rotate(45deg)}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-left-color:transparent!important;border-top-color:transparent!important}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-bottom-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-text{--el-text-font-size:var(--el-font-size-base);--el-text-color:var(--el-text-color-regular);align-self:center;color:var(--el-text-color);font-size:var(--el-text-font-size);margin:0;overflow-wrap:break-word;padding:0}.el-text.is-truncated{display:inline-block;max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-text.is-line-clamp{display:-webkit-inline-box;-webkit-box-orient:vertical;overflow:hidden}.el-text--large{--el-text-font-size:var(--el-font-size-medium)}.el-text--default{--el-text-font-size:var(--el-font-size-base)}.el-text--small{--el-text-font-size:var(--el-font-size-extra-small)}.el-text.el-text--primary{--el-text-color:var(--el-color-primary)}.el-text.el-text--success{--el-text-color:var(--el-color-success)}.el-text.el-text--warning{--el-text-color:var(--el-color-warning)}.el-text.el-text--danger{--el-text-color:var(--el-color-danger)}.el-text.el-text--error{--el-text-color:var(--el-color-error)}.el-text.el-text--info{--el-text-color:var(--el-color-info)}.el-text>.el-icon{vertical-align:-2px}.el-segmented--vertical{flex-direction:column}.el-segmented--vertical .el-segmented__item{padding:11px}.el-segmented{--el-segmented-color:var(--el-text-color-regular);--el-segmented-bg-color:var(--el-fill-color-light);--el-segmented-padding:2px;--el-segmented-item-selected-color:var(--el-color-white);--el-segmented-item-selected-bg-color:var(--el-color-primary);--el-segmented-item-selected-disabled-bg-color:var(--el-color-primary-light-5);--el-segmented-item-hover-color:var(--el-text-color-primary);--el-segmented-item-hover-bg-color:var(--el-fill-color-dark);--el-segmented-item-active-bg-color:var(--el-fill-color-darker);--el-segmented-item-disabled-color:var(--el-text-color-placeholder);align-items:stretch;background:var(--el-segmented-bg-color);border-radius:var(--el-border-radius-base);box-sizing:border-box;color:var(--el-segmented-color);display:inline-flex;font-size:14px;min-height:32px;padding:var(--el-segmented-padding)}.el-segmented__group{align-items:stretch;display:flex;position:relative;width:100%}.el-segmented__item-selected{background:var(--el-segmented-item-selected-bg-color);border-radius:calc(var(--el-border-radius-base) - 2px);height:100%;left:0;pointer-events:none;position:absolute;top:0;transition:all .3s;width:10px}.el-segmented__item-selected.is-disabled{background:var(--el-segmented-item-selected-disabled-bg-color)}.el-segmented__item-selected.is-focus-visible:before{border-radius:inherit;content:"";top:0;right:0;bottom:0;left:0;outline:2px solid var(--el-segmented-item-selected-bg-color);outline-offset:1px;position:absolute}.el-segmented__item{align-items:center;border-radius:calc(var(--el-border-radius-base) - 2px);cursor:pointer;display:flex;flex:1;padding:0 11px}.el-segmented__item:not(.is-disabled):not(.is-selected):hover{background:var(--el-segmented-item-hover-bg-color);color:var(--el-segmented-item-hover-color)}.el-segmented__item:not(.is-disabled):not(.is-selected):active{background:var(--el-segmented-item-active-bg-color)}.el-segmented__item.is-selected,.el-segmented__item.is-selected.is-disabled{color:var(--el-segmented-item-selected-color)}.el-segmented__item.is-disabled{color:var(--el-segmented-item-disabled-color);cursor:not-allowed}.el-segmented__item-input{height:0;margin:0;opacity:0;pointer-events:none;position:absolute;width:0}.el-segmented__item-label{flex:1;line-height:normal;overflow:hidden;text-align:center;text-overflow:ellipsis;transition:color .3s;white-space:nowrap;z-index:1}.el-segmented.is-block{display:flex}.el-segmented.is-block .el-segmented__item{min-width:0}.el-segmented--large{border-radius:var(--el-border-radius-base);font-size:16px;min-height:40px}.el-segmented--large .el-segmented__item-selected{border-radius:calc(var(--el-border-radius-base) - 2px)}.el-segmented--large .el-segmented--vertical .el-segmented__item{padding:11px}.el-segmented--large .el-segmented__item{border-radius:calc(var(--el-border-radius-base) - 2px);padding:0 11px}.el-segmented--small{border-radius:calc(var(--el-border-radius-base) - 1px);font-size:14px;min-height:24px}.el-segmented--small .el-segmented__item-selected{border-radius:calc(var(--el-border-radius-base) - 3px)}.el-segmented--small .el-segmented--vertical .el-segmented__item{padding:7px}.el-segmented--small .el-segmented__item{border-radius:calc(var(--el-border-radius-base) - 3px);padding:0 7px}.el-color-predefine{display:flex;font-size:12px;margin-top:8px;width:280px}.el-color-predefine__colors{display:flex;flex:1;flex-wrap:wrap}.el-color-predefine__color-selector{border-radius:4px;cursor:pointer;height:20px;margin:0 0 8px 8px;width:20px}.el-color-predefine__color-selector:nth-child(10n+1){margin-left:0}.el-color-predefine__color-selector.selected{box-shadow:0 0 3px 2px var(--el-color-primary)}.el-color-predefine__color-selector>div{border-radius:3px;display:flex;height:100%}.el-color-predefine__color-selector.is-alpha{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==)}.el-color-hue-slider{background-color:red;box-sizing:border-box;float:right;height:12px;padding:0 2px;position:relative;width:280px}.el-color-hue-slider__bar{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff,#00f 67%,#f0f 83%,red);height:100%;position:relative}.el-color-hue-slider__thumb{background:#fff;border:1px solid var(--el-border-color-lighter);border-radius:1px;box-shadow:0 0 2px #0009;box-sizing:border-box;cursor:pointer;height:100%;left:0;position:absolute;top:0;width:4px;z-index:1}.el-color-hue-slider__thumb:focus-visible{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-hue-slider.is-vertical{height:180px;padding:2px 0;width:12px}.el-color-hue-slider.is-vertical .el-color-hue-slider__bar{background:linear-gradient(180deg,red 0,#ff0 17%,#0f0 33%,#0ff,#00f 67%,#f0f 83%,red)}.el-color-hue-slider.is-vertical .el-color-hue-slider__thumb{height:4px;left:0;top:0;width:100%}.el-color-svpanel{height:180px;position:relative;width:280px}.el-color-svpanel__black,.el-color-svpanel__white{bottom:0;left:0;position:absolute;right:0;top:0}.el-color-svpanel__white{background:linear-gradient(90deg,#fff,#fff0)}.el-color-svpanel__black{background:linear-gradient(0deg,#000,#0000)}.el-color-svpanel__cursor{position:absolute}.el-color-svpanel__cursor>div{border-radius:50%;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px #0000004d,0 0 1px 2px #0006;cursor:head;height:4px;transform:translate(-2px,-2px);width:4px}.el-color-alpha-slider{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-position:0 0,6px 0,6px -6px,0 6px;background-size:12px 12px;box-sizing:border-box;height:12px;position:relative;width:280px}.el-color-alpha-slider__bar{background:linear-gradient(to right,rgba(255,255,255,0) 0,var(--el-bg-color) 100%);height:100%;position:relative}.el-color-alpha-slider__thumb{background:#fff;border:1px solid var(--el-border-color-lighter);border-radius:1px;box-shadow:0 0 2px #0009;box-sizing:border-box;cursor:pointer;height:100%;left:0;position:absolute;top:0;width:4px;z-index:1}.el-color-alpha-slider__thumb:focus-visible{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-alpha-slider.is-vertical{height:180px;width:20px}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__bar{background:linear-gradient(180deg,#fff0 0,#fff)}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__thumb{height:4px;left:0;top:0;width:100%}.el-color-dropdown{width:300px}.el-color-dropdown__main-wrapper{margin-bottom:6px}.el-color-dropdown__main-wrapper:after{clear:both;content:"";display:table}.el-color-dropdown__btns{margin-top:12px;text-align:right}.el-color-dropdown__value{color:#000;float:left;font-size:12px;line-height:26px;width:160px}.el-color-picker{display:inline-block;line-height:normal;outline:none;position:relative}.el-color-picker:hover:not(.is-disabled,.is-focused) .el-color-picker__trigger{border-color:var(--el-border-color-hover)}.el-color-picker:focus-visible:not(.is-disabled) .el-color-picker__trigger{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-picker.is-focused .el-color-picker__trigger{border-color:var(--el-color-primary)}.el-color-picker.is-disabled{pointer-events:none}.el-color-picker.is-disabled .el-color-picker__trigger{cursor:not-allowed}.el-color-picker--large{height:40px}.el-color-picker--large .el-color-picker__trigger{height:40px;width:40px}.el-color-picker--large .el-color-picker__mask{height:38px;width:38px}.el-color-picker--small{height:24px}.el-color-picker--small .el-color-picker__trigger{height:24px;width:24px}.el-color-picker--small .el-color-picker__mask{height:22px;width:22px}.el-color-picker--small .el-color-picker__empty,.el-color-picker--small .el-color-picker__icon{transform:scale(.8)}.el-color-picker__mask{background-color:#ffffffb3;border-radius:4px;cursor:not-allowed;height:30px;left:1px;position:absolute;top:1px;width:30px;z-index:1}.el-color-picker__trigger{align-items:center;border:1px solid var(--el-border-color);border-radius:4px;box-sizing:border-box;cursor:pointer;display:inline-flex;font-size:0;height:32px;justify-content:center;padding:4px;position:relative;width:32px}.el-color-picker__color{border:1px solid var(--el-text-color-secondary);border-radius:var(--el-border-radius-small);box-sizing:border-box;display:block;height:100%;position:relative;text-align:center;width:100%}.el-color-picker__color.is-alpha{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-position:0 0,6px 0,6px -6px,0 6px;background-size:12px 12px}.el-color-picker__color-inner{align-items:center;display:inline-flex;height:100%;justify-content:center;width:100%}.el-color-picker .el-color-picker__empty{color:var(--el-text-color-secondary);font-size:12px}.el-color-picker .el-color-picker__icon{align-items:center;color:#fff;display:inline-flex;font-size:12px;justify-content:center}.el-color-picker__panel{background-color:#fff;border-radius:var(--el-border-radius-base);box-shadow:var(--el-box-shadow-light);box-sizing:content-box;padding:6px;position:absolute;z-index:10}.el-color-picker__panel.el-popper{border:1px solid var(--el-border-color-lighter)}.el-color-picker,.el-color-picker__panel{--el-color-picker-alpha-bg-a:#ccc;--el-color-picker-alpha-bg-b:transparent}.dark .el-color-picker,.dark .el-color-picker__panel{--el-color-picker-alpha-bg-a:#333333}.llms-select{display:flex;align-items:center;flex-direction:column;grid-gap:.5rem;gap:.5rem;padding:.5rem}.test-box>div{margin-bottom:20px}.el-table{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-bg-color);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0,0,0,.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0,0,0,.15);--el-table-index:var(--el-index-normal);background-color:var(--el-table-bg-color);box-sizing:border-box;color:var(--el-table-text-color);font-size:var(--el-font-size-base);height:-moz-fit-content;height:fit-content;max-width:100%;overflow:hidden;position:relative;width:100%}.el-table__inner-wrapper{display:flex;flex-direction:column;height:100%;position:relative}.el-table__inner-wrapper:before{bottom:0;height:1px;left:0}.el-table tbody:focus-visible{outline:none}.el-table.has-footer.el-table--fluid-height tr:last-child td.el-table__cell,.el-table.has-footer.el-table--scrollable-y tr:last-child td.el-table__cell{border-bottom-color:transparent}.el-table__empty-block{align-items:center;display:flex;justify-content:center;left:0;min-height:60px;position:sticky;text-align:center;width:100%}.el-table__empty-text{color:var(--el-text-color-secondary);line-height:60px;width:50%}.el-table__expand-column .cell{padding:0;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-table__expand-icon{color:var(--el-text-color-regular);cursor:pointer;font-size:12px;height:20px;position:relative;transition:transform var(--el-transition-duration-fast) ease-in-out}.el-table__expand-icon--expanded{transform:rotate(90deg)}.el-table__expand-icon>.el-icon{font-size:12px}.el-table__expanded-cell{background-color:var(--el-table-expanded-cell-bg-color)}.el-table__expanded-cell[class*=cell]{padding:20px 50px}.el-table__expanded-cell:hover{background-color:transparent!important}.el-table__placeholder{display:inline-block;width:20px}.el-table__append-wrapper{overflow:hidden}.el-table--fit{border-bottom:0;border-right:0}.el-table--fit .el-table__cell.gutter{border-right-width:1px}.el-table--fit .el-table__inner-wrapper:before{width:100%}.el-table thead{color:var(--el-table-header-text-color)}.el-table thead th{font-weight:600}.el-table thead.is-group th.el-table__cell{background:var(--el-fill-color-light)}.el-table .el-table__cell{box-sizing:border-box;min-width:0;padding:8px 0;position:relative;text-align:left;text-overflow:ellipsis;vertical-align:middle;z-index:var(--el-table-index)}.el-table .el-table__cell.is-center{text-align:center}.el-table .el-table__cell.is-right{text-align:right}.el-table .el-table__cell.gutter{border-bottom-width:0;border-right-width:0;padding:0;width:15px}.el-table .el-table__cell.is-hidden>*{visibility:hidden}.el-table .cell{box-sizing:border-box;line-height:23px;overflow:hidden;overflow-wrap:break-word;padding:0 12px;text-overflow:ellipsis;white-space:normal}.el-table .cell.el-tooltip{min-width:50px;white-space:nowrap}.el-table--large{font-size:var(--el-font-size-base)}.el-table--large .el-table__cell{padding:12px 0}.el-table--large .cell{padding:0 16px}.el-table--default{font-size:var(--el-font-size-base)}.el-table--default .el-table__cell{padding:8px 0}.el-table--default .cell{padding:0 12px}.el-table--small{font-size:var(--el-font-size-extra-small)}.el-table--small .el-table__cell{padding:4px 0}.el-table--small .cell{padding:0 8px}.el-table tr{background-color:var(--el-table-tr-bg-color)}.el-table tr input[type=checkbox]{margin:0}.el-table td.el-table__cell,.el-table th.el-table__cell.is-leaf{border-bottom:var(--el-table-border)}.el-table th.el-table__cell.is-sortable{cursor:pointer}.el-table th.el-table__cell{background-color:var(--el-table-header-bg-color)}.el-table th.el-table__cell>.cell.highlight{color:var(--el-color-primary)}.el-table th.el-table__cell.required>div:before{background:#ff4d51;border-radius:50%;content:"";display:inline-block;height:8px;margin-right:5px;vertical-align:middle;width:8px}.el-table td.el-table__cell div{box-sizing:border-box}.el-table td.el-table__cell.gutter{width:0}.el-table--border .el-table__inner-wrapper:after,.el-table--border:after,.el-table--border:before,.el-table__inner-wrapper:before{background-color:var(--el-table-border-color);content:"";position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table--border .el-table__inner-wrapper:after{height:1px;left:0;top:0;width:100%;z-index:calc(var(--el-table-index) + 2)}.el-table--border:before{height:100%;left:0;top:-1px;width:1px}.el-table--border:after{height:100%;right:0;top:-1px;width:1px}.el-table--border .el-table__inner-wrapper{border-bottom:none;border-right:none}.el-table--border .el-table__footer-wrapper{flex-shrink:0;position:relative}.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table--border th.el-table__cell.gutter:last-of-type{border-bottom:var(--el-table-border);border-bottom-width:1px}.el-table--border th.el-table__cell{border-bottom:var(--el-table-border)}.el-table--hidden{visibility:hidden}.el-table__body-wrapper,.el-table__footer-wrapper,.el-table__header-wrapper{width:100%}.el-table__body-wrapper tr td.el-table-fixed-column--left,.el-table__body-wrapper tr td.el-table-fixed-column--right,.el-table__body-wrapper tr th.el-table-fixed-column--left,.el-table__body-wrapper tr th.el-table-fixed-column--right,.el-table__footer-wrapper tr td.el-table-fixed-column--left,.el-table__footer-wrapper tr td.el-table-fixed-column--right,.el-table__footer-wrapper tr th.el-table-fixed-column--left,.el-table__footer-wrapper tr th.el-table-fixed-column--right,.el-table__header-wrapper tr td.el-table-fixed-column--left,.el-table__header-wrapper tr td.el-table-fixed-column--right,.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background:inherit;position:sticky!important;z-index:calc(var(--el-table-index) + 1)}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{bottom:-1px;box-shadow:none;content:"";overflow-x:hidden;overflow-y:hidden;pointer-events:none;position:absolute;top:0;touch-action:none;width:10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before{left:-10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{box-shadow:none;right:-10px}.el-table__body-wrapper tr td.el-table__fixed-right-patch,.el-table__body-wrapper tr th.el-table__fixed-right-patch,.el-table__footer-wrapper tr td.el-table__fixed-right-patch,.el-table__footer-wrapper tr th.el-table__fixed-right-patch,.el-table__header-wrapper tr td.el-table__fixed-right-patch,.el-table__header-wrapper tr th.el-table__fixed-right-patch{background:#fff;position:sticky!important;right:0;z-index:calc(var(--el-table-index) + 1)}.el-table__header-wrapper{flex-shrink:0}.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body,.el-table__footer,.el-table__header{border-collapse:separate;table-layout:fixed}.el-table__header-wrapper{overflow:hidden}.el-table__header-wrapper tbody td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__footer-wrapper{flex-shrink:0;overflow:hidden}.el-table__footer-wrapper tfoot td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__body-wrapper .el-table-column--selection>.cell,.el-table__header-wrapper .el-table-column--selection>.cell{align-items:center;display:inline-flex;height:23px}.el-table__body-wrapper .el-table-column--selection .el-checkbox,.el-table__header-wrapper .el-table-column--selection .el-checkbox{height:unset}.el-table.is-scrolling-left .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-left.el-table--border .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:var(--el-table-border)}.el-table.is-scrolling-left th.el-table-fixed-column--left{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-right th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-middle .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-none .el-table-fixed-column--left.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--left.is-last-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-last-column:before{box-shadow:none}.el-table.is-scrolling-none th.el-table-fixed-column--left,.el-table.is-scrolling-none th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body-wrapper{flex:1;overflow:hidden;position:relative}.el-table__body-wrapper .el-scrollbar__bar{z-index:calc(var(--el-table-index) + 2)}.el-table .caret-wrapper{align-items:center;cursor:pointer;display:inline-flex;flex-direction:column;height:14px;overflow:initial;position:relative;vertical-align:middle;width:24px}.el-table .sort-caret{border:5px solid transparent;height:0;left:7px;position:absolute;width:0}.el-table .sort-caret.ascending{border-bottom-color:var(--el-text-color-placeholder);top:-5px}.el-table .sort-caret.descending{border-top-color:var(--el-text-color-placeholder);bottom:-3px}.el-table .ascending .sort-caret.ascending{border-bottom-color:var(--el-color-primary)}.el-table .descending .sort-caret.descending{border-top-color:var(--el-color-primary)}.el-table .hidden-columns{position:absolute;visibility:hidden;z-index:-1}.el-table--striped .el-table__body tr.el-table__row--striped td.el-table__cell{background:var(--el-fill-color-lighter)}.el-table--striped .el-table__body tr.el-table__row--striped.current-row td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__body tr.hover-row.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped>td.el-table__cell,.el-table__body tr.hover-row>td.el-table__cell,.el-table__body tr>td.hover-cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr.current-row>td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table.el-table--scrollable-y .el-table__body-header{position:sticky;top:0;z-index:calc(var(--el-table-index) + 2)}.el-table.el-table--scrollable-y .el-table__body-footer{bottom:0;position:sticky;z-index:calc(var(--el-table-index) + 2)}.el-table__column-resize-proxy{border-left:var(--el-table-border);bottom:0;left:200px;position:absolute;top:0;width:0;z-index:calc(var(--el-table-index) + 9)}.el-table__column-filter-trigger{cursor:pointer;display:inline-block}.el-table__column-filter-trigger i{color:var(--el-color-info);font-size:14px;vertical-align:middle}.el-table__border-left-patch{height:100%;top:0;width:1px}.el-table__border-bottom-patch,.el-table__border-left-patch{background-color:var(--el-table-border-color);left:0;position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table__border-bottom-patch{height:1px}.el-table__border-right-patch{background-color:var(--el-table-border-color);height:100%;position:absolute;top:0;width:1px;z-index:calc(var(--el-table-index) + 2)}.el-table--enable-row-transition .el-table__body td.el-table__cell{transition:background-color .25s ease}.el-table--enable-row-hover .el-table__body tr:hover>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table [class*=el-table__row--level] .el-table__expand-icon{display:inline-block;height:12px;line-height:12px;margin-right:8px;text-align:center;width:12px}.el-table .el-table.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table:not(.el-table--border) .el-table__cell{border-right:none}.el-table:not(.el-table--border)>.el-table__inner-wrapper:after{content:none}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary);align-items:center;color:var(--el-checkbox-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-checkbox-font-weight);height:var(--el-checkbox-height,32px);margin-right:30px;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap}.el-checkbox.is-disabled{cursor:not-allowed}.el-checkbox.is-bordered{border:var(--el-border);border-radius:var(--el-border-radius-base);box-sizing:border-box;padding:0 15px 0 9px}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter)}.el-checkbox.is-bordered.el-checkbox--large{border-radius:var(--el-border-radius-base);padding:0 19px 0 11px}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{border-radius:calc(var(--el-border-radius-base) - 1px);padding:0 11px 0 7px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{border-radius:var(--el-checkbox-border-radius);outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px}.el-checkbox__input{cursor:pointer;display:inline-flex;outline:none;position:relative;white-space:nowrap}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-icon-color);cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-checked-icon-color);transform:rotate(45deg) scaleY(1)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-checked-icon-color);content:"";display:block;height:2px;left:0;position:absolute;right:0;top:5px;transform:scale(.5)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{background-color:var(--el-checkbox-bg-color);border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;display:inline-block;height:var(--el-checkbox-input-height);position:relative;transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46);width:var(--el-checkbox-input-width);z-index:var(--el-index-normal)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{border:1px solid transparent;border-left:0;border-top:0;box-sizing:content-box;content:"";height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);transform-origin:center;transition:transform .15s ease-in .05s;width:3px}.el-checkbox__original{height:0;margin:0;opacity:0;outline:none;position:absolute;width:0;z-index:-1}.el-checkbox__label{display:inline-block;font-size:var(--el-checkbox-font-size);line-height:1;padding-left:8px}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox:last-of-type{margin-right:0}.el-table-column--selection .cell{padding-left:14px;padding-right:14px}.el-table-filter{background-color:#fff;border:1px solid var(--el-border-color-lighter);border-radius:2px;box-shadow:var(--el-box-shadow-light);box-sizing:border-box}.el-table-filter__list{list-style:none;margin:0;min-width:100px;padding:5px 0}.el-table-filter__list-item{cursor:pointer;font-size:var(--el-font-size-base);line-height:36px;padding:0 10px}.el-table-filter__list-item:hover{background-color:var(--el-color-primary-light-9);color:var(--el-color-primary)}.el-table-filter__list-item.is-active{background-color:var(--el-color-primary);color:#fff}.el-table-filter__content{min-width:100px}.el-table-filter__bottom{border-top:1px solid var(--el-border-color-lighter);padding:8px}.el-table-filter__bottom button{background:transparent;border:none;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-small);padding:0 3px}.el-table-filter__bottom button:hover{color:var(--el-color-primary)}.el-table-filter__bottom button:focus{outline:none}.el-table-filter__bottom button.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-table-filter__wrap{max-height:280px}.el-table-filter__checkbox-group{padding:10px}.el-table-filter__checkbox-group label.el-checkbox{align-items:center;display:flex;height:unset;margin-bottom:12px;margin-left:5px;margin-right:5px}.el-table-filter__checkbox-group .el-checkbox:last-child{margin-bottom:0}.el-space .el-button-group{display:flex}.el-space .el-button-group .el-button:first-child{flex:1}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transform-origin:center top;transition:var(--el-transition-md-fade)}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transform-origin:center bottom;transition:var(--el-transition-md-fade)}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transform-origin:top left;transition:var(--el-transition-md-fade)}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-collapse{--el-collapse-border-color:var(--el-border-color-lighter);--el-collapse-header-height:48px;--el-collapse-header-bg-color:var(--el-fill-color-blank);--el-collapse-header-text-color:var(--el-text-color-primary);--el-collapse-header-font-size:13px;--el-collapse-content-bg-color:var(--el-fill-color-blank);--el-collapse-content-font-size:13px;--el-collapse-content-text-color:var(--el-text-color-primary);border-bottom:1px solid var(--el-collapse-border-color);border-top:1px solid var(--el-collapse-border-color)}.el-collapse-item.is-disabled .el-collapse-item__header{color:var(--el-text-color-disabled);cursor:not-allowed}.el-collapse-item__header{align-items:center;background-color:var(--el-collapse-header-bg-color);border:none;border-bottom:1px solid var(--el-collapse-border-color);color:var(--el-collapse-header-text-color);cursor:pointer;display:flex;font-size:var(--el-collapse-header-font-size);font-weight:500;height:var(--el-collapse-header-height);line-height:var(--el-collapse-header-height);outline:none;padding:0;transition:border-bottom-color var(--el-transition-duration);width:100%}.el-collapse-item__arrow{font-weight:300;margin:0 8px 0 auto;transition:transform var(--el-transition-duration)}.el-collapse-item__arrow.is-active{transform:rotate(90deg)}.el-collapse-item__header.focusing:focus:not(:hover){color:var(--el-color-primary)}.el-collapse-item__header.is-active{border-bottom-color:transparent}.el-collapse-item__wrap{background-color:var(--el-collapse-content-bg-color);border-bottom:1px solid var(--el-collapse-border-color);box-sizing:border-box;overflow:hidden;will-change:height}.el-collapse-item__content{color:var(--el-collapse-content-text-color);font-size:var(--el-collapse-content-font-size);line-height:1.7692307692;padding-bottom:25px}.el-collapse-item:last-child{margin-bottom:-1px}.el-input-number{display:inline-flex;line-height:30px;position:relative;vertical-align:middle;width:150px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;line-height:1;text-align:center}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-input-number__decrease,.el-input-number__increase{align-items:center;background:var(--el-fill-color-light);bottom:1px;color:var(--el-text-color-regular);cursor:pointer;display:flex;font-size:13px;height:auto;justify-content:center;position:absolute;top:1px;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:32px;z-index:1}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input__wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{border-left:var(--el-border);border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;right:1px}.el-input-number__decrease{border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border);left:1px}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{line-height:38px;width:180px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{font-size:14px;width:40px}.el-input-number--large.is-controls-right .el-input--large .el-input__wrapper{padding-right:47px}.el-input-number--large .el-input--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{line-height:22px;width:120px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{font-size:12px;width:24px}.el-input-number--small.is-controls-right .el-input--small .el-input__wrapper{padding-right:31px}.el-input-number--small .el-input--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{border-bottom:var(--el-border);border-radius:0 var(--el-border-radius-base) 0 0;bottom:auto;left:auto}.el-input-number.is-controls-right .el-input-number__decrease{border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0;border-right:none;left:auto;right:1px;top:auto}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-space[data-v-2be472b2] .el-space__item{width:48%}.el-table-v2__row-depth-0{height:50px}.el-table-v2__cell-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}#boos-helper-job{margin-bottom:8px}#boos-helper-job *{-webkit-user-select:none;user-select:none}.hp-about-box{display:flex}.hp-about-box .hp-about{display:flex;flex-direction:column}html.dark .hp-about-box{color:#cfd3dc}.el-checkbox{color:#5e5e5e}.el-checkbox.is-checked .el-checkbox__label{color:#000!important}.dark .el-checkbox.is-checked .el-checkbox__label{color:#cfd3dc!important}.el-form .el-link{font-size:12px}.el-form .el-form-item__label{display:flex;align-items:center}.el-form .el-checkbox__label{padding-left:4px}.el-tabs__content{overflow:unset!important}#wrap{min-width:unset}#wrap .inner{width:unset}#wrap .page-job-wrapper{padding-top:0!important;width:100%;position:relative}#wrap .page-job-wrapper .page-job-inner,#wrap .page-job-wrapper .job-search-wrapper{width:65%;max-width:870px;min-width:320px;margin:20px auto 20px 30%}#wrap .page-job-wrapper .page-job-inner.fix-top,#wrap .page-job-wrapper .job-search-wrapper.fix-top{position:unset;margin-top:unset;box-shadow:unset}#wrap .page-job-content,#wrap .job-list-wrapper,#wrap .job-card-wrapper{width:100%!important}#wrap .page-job-inner .page-job-content{display:flex;flex-direction:column;order:2}#wrap .job-card-wrapper{border:3px solid transparent}#wrap .job-card-wrapper .job-card-footer,#wrap .job-card-wrapper .job-card-right,#wrap .job-card-wrapper .job-card-body{display:flex}#wrap .job-card-wrapper .job-card-body{border-radius:12px 12px 0 0}#wrap .job-card-wrapper .job-card-left .job-title,#wrap .job-card-wrapper .salary,#wrap .job-card-wrapper .job-card-right .company-name{font-size:clamp(.625rem,.407rem + 1.09vw,1rem)!important}#wrap .job-card-wrapper .tag-list li,#wrap .job-card-wrapper .company-tag-list li,#wrap .job-card-wrapper .info-desc{font-size:clamp(.531rem,.368rem + .82vw,.813rem)!important}#wrap .job-card-wrapper .job-card-left{height:unset;padding:16px 24px 12px}#wrap .job-card-wrapper .job-card-left .job-name{margin-right:12px}#wrap .job-card-wrapper .job-card-left .job-area-wrapper{margin-left:0!important}#wrap .job-card-wrapper .job-card-left .start-chat-btn,#wrap .job-card-wrapper .job-card-left .info-public{display:inline-block}#wrap .job-card-wrapper .job-card-left .job-info{height:unset;overflow:unset}#wrap .job-card-wrapper .job-card-left .job-info>*{margin:3px}#wrap .job-card-wrapper .job-card-right{flex-wrap:wrap}#wrap .job-card-wrapper .job-card-right .company-logo{margin-right:12px;width:unset;height:unset;border:unset;border-radius:15px}#wrap .job-card-wrapper .job-card-right .company-logo img{object-fit:contain;width:clamp(4.063rem,3.699rem + 1.82vw,4.688rem)}#wrap .job-card-wrapper .job-card-right .company-info{margin-left:0}#wrap .job-card-wrapper .job-card-footer{padding:8px 12px 14px}#wrap .job-card-wrapper .job-card-left .tag-list,#wrap .job-card-wrapper .company-tag-list{height:unset;border:unset}#wrap .search-job-result .job-list-box{display:flex;flex-direction:column}#wrap .search-job-result .job-list-box .job-card-wrapper{margin:16px auto}#wrap .job-search-box .job-search-form{width:100%!important;display:flex}#wrap .job-search-box .job-search-form .city-label,#wrap .job-search-box .job-search-form .search-input-box{width:unset}#wrap .job-search-box .job-search-form .search-input-box{flex:1}#wrap .job-search-box .job-search-form .search-btn{margin:0 15px}html{--body-bg-color: #f6f6f8}html body{background-color:var(--body-bg-color)}html .page-job:before{background:unset}.el-input .el-input__inner{background-color:unset!important;border:unset!important}html.dark{--el-bg-color: #212020;--body-bg-color: #212121}html.dark #header .inner:before,html.dark .page-job:before{background:unset}html.dark .job-search-wrapper,html.dark .job-card-wrapper,html.dark .satisfaction-feedback-wrapper,html.dark .job-search-box .city-label,html.dark .job-search-box .search-input-box,html.dark .job-search-box .search-input-box input,html.dark .hot-link-wrapper,html.dark .filter-select-dropdown li{background-color:#292929!important}html.dark .filter-select-dropdown,html.dark .filter-select-dropdown ul,html.dark .filter-select-dropdown .condition-position-detail{background-color:#292929!important;border:1px solid #5a5a5a!important}html.dark .filter-select-dropdown *{color:#cfd3dc!important}html.dark .filter-select-dropdown .active{color:#00a6a7!important}html.dark .job-title,html.dark .info-desc,html.dark .tag-list li,html.dark .company-name a,html.dark .satisfaction-feedback-wrapper h3,html.dark .fast-next-btn,html.dark .search-map-btn,html.dark .city-label,html.dark .city-area-select .area-dropdown-item li,html.dark .city-area-select .city-area-tab li,html.dark .subway-select-wrapper .subway-line-list li,html.dark .condition-filter-select .current-select,html.dark .el-vl__wrapper,html.dark .el-checkbox__label,html.dark .placeholder-text,html.dark #boos-helper-job h2{color:#cfd3dc!important}html.dark .city-area-select .area-select-wrapper,html.dark .condition-filter-select,html.dark .condition-position-select.is-select .current-select,html.dark .job-card-body,html.dark .condition-industry-select{background-color:#434141}html.dark .job-card-wrapper{transition:all .3s ease;position:relative}html.dark .job-card-wrapper .job-card-footer{background:linear-gradient(90deg,#373737,#4d4b4b)}html.dark .job-card-wrapper .job-card-left .start-chat-btn{background:#00bebdb3}html.dark .job-card-wrapper .job-info .tag-list li,html.dark .job-card-wrapper .info-public,html.dark .job-card-wrapper .company-tag-list li{color:#cfd3dc!important;background:#44e1e326!important;border:.5px solid rgba(229,230,230,.4705882353)!important}html.dark .job-card-wrapper .info-public em:before{height:70%}html.dark .job-loading-wrapper .job-loading-list li{filter:invert(83%)} ');

System.addImportMap({ imports: {"vue":"user:vue","element-plus":"user:element-plus","protobufjs":"user:protobufjs"} });
System.set("user:vue", (()=>{const _=Vue;('default' in _)||(_.default=_);return _})());
System.set("user:element-plus", (()=>{const _=ElementPlus;('default' in _)||(_.default=_);return _})());
System.set("user:protobufjs", (()=>{const _=protobuf;('default' in _)||(_.default=_);return _})());

System.register("./__entry.js", ['./__monkey.entry-DHxVDBEP.js'], (function (exports, module) {
	'use strict';
	return {
		setters: [null],
		execute: (function () {



		})
	};
}));

System.register("./__monkey.entry-DHxVDBEP.js", ['vue', 'element-plus'], (function (exports, module) {
  'use strict';
  var reactive, ref, defineComponent, computed, createElementBlock, openBlock, mergeProps, unref, renderSlot, createBlock, resolveDynamicComponent, withCtx, createCommentVNode, Fragment, normalizeClass, provide, toRef, inject, useSlots, Text, watch, isRef, warn, getCurrentInstance, createElementVNode, createApp, onMounted, createVNode, createTextVNode, renderList, toDisplayString, Teleport, useModel, toRaw, getCurrentScope, onScopeDispose, onUnmounted, shallowRef, watchEffect, readonly, customRef, nextTick, ElMessage, ElMessageBox, ElDropdown, ElAvatar, ElDropdownMenu, ElDropdownItem, ElDialog, ElAlert, ElTable, ElTableColumn, ElTag, ElButton$1, ElPopconfirm;
  return {
    setters: [module => {
      reactive = module.reactive;
      ref = module.ref;
      defineComponent = module.defineComponent;
      computed = module.computed;
      createElementBlock = module.createElementBlock;
      openBlock = module.openBlock;
      mergeProps = module.mergeProps;
      unref = module.unref;
      renderSlot = module.renderSlot;
      createBlock = module.createBlock;
      resolveDynamicComponent = module.resolveDynamicComponent;
      withCtx = module.withCtx;
      createCommentVNode = module.createCommentVNode;
      Fragment = module.Fragment;
      normalizeClass = module.normalizeClass;
      provide = module.provide;
      toRef = module.toRef;
      inject = module.inject;
      useSlots = module.useSlots;
      Text = module.Text;
      watch = module.watch;
      isRef = module.isRef;
      warn = module.warn;
      getCurrentInstance = module.getCurrentInstance;
      createElementVNode = module.createElementVNode;
      createApp = module.createApp;
      onMounted = module.onMounted;
      createVNode = module.createVNode;
      createTextVNode = module.createTextVNode;
      renderList = module.renderList;
      toDisplayString = module.toDisplayString;
      Teleport = module.Teleport;
      useModel = module.useModel;
      toRaw = module.toRaw;
      getCurrentScope = module.getCurrentScope;
      onScopeDispose = module.onScopeDispose;
      onUnmounted = module.onUnmounted;
      shallowRef = module.shallowRef;
      watchEffect = module.watchEffect;
      readonly = module.readonly;
      customRef = module.customRef;
      nextTick = module.nextTick;
    }, module => {
      ElMessage = module.ElMessage;
      ElMessageBox = module.ElMessageBox;
      ElDropdown = module.ElDropdown;
      ElAvatar = module.ElAvatar;
      ElDropdownMenu = module.ElDropdownMenu;
      ElDropdownItem = module.ElDropdownItem;
      ElDialog = module.ElDialog;
      ElAlert = module.ElAlert;
      ElTable = module.ElTable;
      ElTableColumn = module.ElTableColumn;
      ElTag = module.ElTag;
      ElButton$1 = module.ElButton;
      ElPopconfirm = module.ElPopconfirm;
    }],
    execute: (function () {

      exports({
        $: useGlobalConfig,
        F: reactiveComputed,
        G: deepmerge,
        K: getCurDay,
        L: getCurTime,
        Z: refDebounced,
        a6: loader,
        aC: identity,
        ab: isNil,
        ah: useTimeoutFn,
        ao: resolveUnref,
        ap: tryOnScopeDispose,
        aq: fromPairs,
        ar: computedWithControl,
        au: tryOnMounted,
        j: tryOnScopeDispose$1,
        k: notification,
        m: delay,
        q: watchIgnorable,
        t: toValue,
        x: addUnit
      });

      const scriptRel = function detectScriptRel() {
        const relList = typeof document !== "undefined" && document.createElement("link").relList;
        return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
      }();
      const assetsURL = function(dep) {
        return "/" + dep;
      };
      const seen = {};
      const __vitePreload = function preload(baseModule, deps, importerUrl) {
        let promise = Promise.resolve();
        if (deps && deps.length > 0) {
          document.getElementsByTagName("link");
          const cspNonceMeta = document.querySelector(
            "meta[property=csp-nonce]"
          );
          const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
          promise = Promise.allSettled(
            deps.map((dep) => {
              dep = assetsURL(dep);
              if (dep in seen) return;
              seen[dep] = true;
              const isCss = dep.endsWith(".css");
              const cssSelector = isCss ? '[rel="stylesheet"]' : "";
              if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
                return;
              }
              const link = document.createElement("link");
              link.rel = isCss ? "stylesheet" : scriptRel;
              if (!isCss) {
                link.as = "script";
              }
              link.crossOrigin = "";
              link.href = dep;
              if (cspNonce) {
                link.setAttribute("nonce", cspNonce);
              }
              document.head.appendChild(link);
              if (isCss) {
                return new Promise((res, rej) => {
                  link.addEventListener("load", res);
                  link.addEventListener(
                    "error",
                    () => rej(new Error(`Unable to preload CSS for ${dep}`))
                  );
                });
              }
            })
          );
        }
        function handlePreloadError(err) {
          const e = new Event("vite:preloadError", {
            cancelable: true
          });
          e.payload = err;
          window.dispatchEvent(e);
          if (!e.defaultPrevented) {
            throw err;
          }
        }
        return promise.then((res) => {
          for (const item of res || []) {
            if (item.status !== "rejected") continue;
            handlePreloadError(item.reason);
          }
          return baseModule().catch(handlePreloadError);
        });
      };
      const cssLoader = (e) => {
        const t = GM_getResourceText(e);
        return GM_addStyle(t), t;
      };
      cssLoader("element-plus/dist/index.css");
      cssLoader("element-plus/theme-chalk/dark/css-vars.css");
      const icons = { debug: "ðŸž", info: "â„¹ï¸", warn: "âš ", error: "âŒï¸" };
      const Color = {
        debug: "#42CA8C;",
        info: "#37C5D6;",
        warn: "#EFC441;",
        error: "#FF6257;"
      };
      const logger = exports("l", {
        debug: console.log.bind(
          console,
          `%c${icons.debug} debug > `,
          `color:${Color.debug}; padding-left:1.2em; line-height:1.5em;`
        ),
        info: console.info.bind(
          console,
          `%c${icons.info} info > `,
          `color:${Color.info}; padding-left:1.2em; line-height:1.5em;`
        ),
        warn: console.warn.bind(
          console,
          `%c${icons.warn} warn > `,
          `color:${Color.warn}; padding-left:1.2em; line-height:1.5em;`
        ),
        error: console.error.bind(
          console,
          `%c${icons.error} error > `,
          `color:${Color.error}; padding-left:1.2em; line-height:1.5em;`
        ),
        group: console.groupCollapsed,
        groupEnd: console.groupEnd
      });
      var _GM_cookie = /* @__PURE__ */ (() => typeof GM_cookie != "undefined" ? GM_cookie : void 0)();
      var _GM_getValue = exports("_", /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)());
      var _GM_notification = /* @__PURE__ */ (() => typeof GM_notification != "undefined" ? GM_notification : void 0)();
      var _GM_setValue = exports("a", /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)());
      var _GM_xmlhttpRequest = exports("a5", /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)());
      var _unsafeWindow = exports("A", /* @__PURE__ */ (() => typeof unsafeWindow != "undefined" ? unsafeWindow : void 0)());
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        __name: "store",
        props: {
          "modelValue": { type: Boolean, ...{ required: true } },
          "modelModifiers": {}
        },
        emits: ["update:modelValue"],
        setup(__props) {
          const show = useModel(__props, "modelValue");
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElDialog), {
              modelValue: show.value,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => show.value = $event),
              title: "å­˜å‚¨é…ç½®",
              width: "500",
              "align-center": "",
              "destroy-on-close": "",
              "z-index": 20
            }, {
              footer: withCtx(() => [
                createElementVNode("div", null, [
                  createVNode(unref(ElButton$1), {
                    onClick: _cache[0] || (_cache[0] = ($event) => show.value = false)
                  }, {
                    default: withCtx(() => _cache[3] || (_cache[3] = [
                      createTextVNode("Cancel")
                    ])),
                    _: 1
                  }),
                  createVNode(unref(ElButton$1), {
                    type: "primary",
                    onClick: _cache[1] || (_cache[1] = ($event) => show.value = false)
                  }, {
                    default: withCtx(() => _cache[4] || (_cache[4] = [
                      createTextVNode("Confirm")
                    ])),
                    _: 1
                  })
                ])
              ]),
              default: withCtx(() => [
                _cache[5] || (_cache[5] = createElementVNode("span", null, " å½“ä½¿ç”¨å¤šè´¦æˆ·æ—¶å€™,è¯¥é…ç½®å†…å«æœ‰æ•æ„Ÿä¿¡æ¯,å¯¼å…¥å¯¼å‡ºä¸€å®šè¦æ³¨æ„,é¿å…æ³„éœ² ", -1))
              ]),
              _: 1
            }, 8, ["modelValue"]);
          };
        }
      });
      function tryOnScopeDispose$1(fn) {
        if (getCurrentScope()) {
          onScopeDispose(fn);
          return true;
        }
        return false;
      }
      function toValue(r) {
        return typeof r === "function" ? r() : unref(r);
      }
      function toReactive(objectRef) {
        if (!isRef(objectRef))
          return reactive(objectRef);
        const proxy = new Proxy({}, {
          get(_, p, receiver) {
            return unref(Reflect.get(objectRef.value, p, receiver));
          },
          set(_, p, value) {
            if (isRef(objectRef.value[p]) && !isRef(value))
              objectRef.value[p].value = value;
            else
              objectRef.value[p] = value;
            return true;
          },
          deleteProperty(_, p) {
            return Reflect.deleteProperty(objectRef.value, p);
          },
          has(_, p) {
            return Reflect.has(objectRef.value, p);
          },
          ownKeys() {
            return Object.keys(objectRef.value);
          },
          getOwnPropertyDescriptor() {
            return {
              enumerable: true,
              configurable: true
            };
          }
        });
        return reactive(proxy);
      }
      function reactiveComputed(fn) {
        return toReactive(computed(fn));
      }
      const isClient$1 = exports("i", typeof window !== "undefined" && typeof document !== "undefined");
      typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
      const toString$1 = Object.prototype.toString;
      const isObject$2 = exports("h", (val) => toString$1.call(val) === "[object Object]");
      const noop$2 = exports("n", () => {
      });
      function createFilterWrapper$1(filter2, fn) {
        function wrapper(...args) {
          return new Promise((resolve, reject) => {
            Promise.resolve(filter2(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
          });
        }
        return wrapper;
      }
      const bypassFilter = (invoke2) => {
        return invoke2();
      };
      function throttleFilter(...args) {
        let lastExec = 0;
        let timer;
        let isLeading = true;
        let lastRejector = noop$2;
        let lastValue;
        let ms;
        let trailing;
        let leading;
        let rejectOnCancel;
        if (!isRef(args[0]) && typeof args[0] === "object")
          ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);
        else
          [ms, trailing = true, leading = true, rejectOnCancel = false] = args;
        const clear = () => {
          if (timer) {
            clearTimeout(timer);
            timer = void 0;
            lastRejector();
            lastRejector = noop$2;
          }
        };
        const filter2 = (_invoke) => {
          const duration = toValue(ms);
          const elapsed = Date.now() - lastExec;
          const invoke2 = () => {
            return lastValue = _invoke();
          };
          clear();
          if (duration <= 0) {
            lastExec = Date.now();
            return invoke2();
          }
          if (elapsed > duration && (leading || !isLeading)) {
            lastExec = Date.now();
            invoke2();
          } else if (trailing) {
            lastValue = new Promise((resolve, reject) => {
              lastRejector = rejectOnCancel ? reject : resolve;
              timer = setTimeout(() => {
                lastExec = Date.now();
                isLeading = true;
                resolve(invoke2());
                clear();
              }, Math.max(0, duration - elapsed));
            });
          }
          if (!leading && !timer)
            timer = setTimeout(() => isLeading = true, duration);
          isLeading = false;
          return lastValue;
        };
        return filter2;
      }
      function watchWithFilter(source, cb, options = {}) {
        const {
          eventFilter = bypassFilter,
          ...watchOptions
        } = options;
        return watch(
          source,
          createFilterWrapper$1(
            eventFilter,
            cb
          ),
          watchOptions
        );
      }
      function watchIgnorable(source, cb, options = {}) {
        const {
          eventFilter = bypassFilter,
          ...watchOptions
        } = options;
        const filteredCb = createFilterWrapper$1(
          eventFilter,
          cb
        );
        let ignoreUpdates;
        let ignorePrevAsyncUpdates;
        let stop;
        if (watchOptions.flush === "sync") {
          const ignore = ref(false);
          ignorePrevAsyncUpdates = () => {
          };
          ignoreUpdates = (updater) => {
            ignore.value = true;
            updater();
            ignore.value = false;
          };
          stop = watch(
            source,
            (...args) => {
              if (!ignore.value)
                filteredCb(...args);
            },
            watchOptions
          );
        } else {
          const disposables = [];
          const ignoreCounter = ref(0);
          const syncCounter = ref(0);
          ignorePrevAsyncUpdates = () => {
            ignoreCounter.value = syncCounter.value;
          };
          disposables.push(
            watch(
              source,
              () => {
                syncCounter.value++;
              },
              { ...watchOptions, flush: "sync" }
            )
          );
          ignoreUpdates = (updater) => {
            const syncCounterPrev = syncCounter.value;
            updater();
            ignoreCounter.value += syncCounter.value - syncCounterPrev;
          };
          disposables.push(
            watch(
              source,
              (...args) => {
                const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
                ignoreCounter.value = 0;
                syncCounter.value = 0;
                if (ignore)
                  return;
                filteredCb(...args);
              },
              watchOptions
            )
          );
          stop = () => {
            disposables.forEach((fn) => fn());
          };
        }
        return { stop, ignoreUpdates, ignorePrevAsyncUpdates };
      }
      function watchThrottled(source, cb, options = {}) {
        const {
          throttle: throttle2 = 0,
          trailing = true,
          leading = true,
          ...watchOptions
        } = options;
        return watchWithFilter(
          source,
          cb,
          {
            ...watchOptions,
            eventFilter: throttleFilter(throttle2, trailing, leading)
          }
        );
      }
      function isPlainObject$1(item) {
        if (typeof item !== "object" || item === null) {
          return false;
        }
        const prototype2 = Object.getPrototypeOf(item);
        return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
      }
      function deepClone(source) {
        if (!isPlainObject$1(source)) {
          return source;
        }
        const output = {};
        Object.keys(source).forEach((key) => {
          output[key] = deepClone(source[key]);
        });
        return output;
      }
      function deepmerge(target, source, options = { clone: true }) {
        const output = options.clone ? { ...target } : target;
        if (isPlainObject$1(target) && isPlainObject$1(source)) {
          Object.keys(source).forEach((key) => {
            if (key === "__proto__") {
              return;
            }
            if (isPlainObject$1(source[key]) && key in target && isPlainObject$1(target[key])) {
              output[key] = deepmerge(
                target[key],
                source[key],
                options
              );
            } else if (options.clone) {
              output[key] = isPlainObject$1(source[key]) ? deepClone(source[key]) : source[key];
            } else {
              output[key] = source[key];
            }
          });
        }
        return output;
      }
      const formDataKey = "web-geek-job-FormData";
      const todayKey = "web-geek-job-Today";
      const statisticsKey = "web-geek-job-Statistics";
      const formInfoData = exports("g", {
        company: {
          label: "å…¬å¸å",
          help: "å…¬å¸åæŽ’é™¤æˆ–åŒ…å«åœ¨é›†åˆä¸­ï¼Œæ¨¡ç³ŠåŒ¹é…ï¼Œå¯ç”¨äºŽåªæŠ•æˆ–ä¸æŠ•æŸä¸ªå…¬å¸/å­å…¬å¸ã€‚"
        },
        jobTitle: {
          label: "å²—ä½å",
          help: "å²—ä½åæŽ’é™¤æˆ–åŒ…å«åœ¨é›†åˆä¸­ï¼Œæ¨¡ç³ŠåŒ¹é…ï¼Œå¯ç”¨äºŽåªæŠ•æˆ–ä¸æŠ•æŸä¸ªå²—ä½åã€‚"
        },
        jobContent: {
          label: "å·¥ä½œå†…å®¹",
          help: "ä¼šè‡ªåŠ¨æ£€æµ‹ä¸Šæ–‡(ä¸æ˜¯,ä¸,æ— éœ€),ä¸‹æ–‡(ç³»ç»Ÿ,å·¥å…·),ä¾‹å­ï¼š[å¤–åŒ…,ä¸Šé—¨,é”€å”®,é©¾ç…§], æŽ’é™¤: 'å¤–åŒ…å²—ä½', ä¸æŽ’é™¤: 'ä¸æ˜¯å¤–åŒ…'|'é”€å”®ç³»ç»Ÿ'"
        },
        hrPosition: {
          label: "HrèŒä½",
          help: "HrèŒä½ä¸€å®šåŒ…å«/æŽ’é™¤åœ¨é›†åˆä¸­ï¼Œç²¾ç¡®åŒ¹é…, ä¸åœ¨å†…ç½®ä¸­å¯æ‰‹åŠ¨è¾“å…¥,èƒ½å®žçŽ°åªå‘ç»ç†ç­‰è¿›è¡ŒæŠ•é€’ï¼Œæ¯•ç«Ÿäººäº‹å¹²çš„ä¸ä¸€å®šæ˜¯äººäº‹"
        },
        salaryRange: {
          label: "è–ªèµ„èŒƒå›´",
          help: "æŠ•é€’å·¥ä½œçš„è–ªèµ„èŒƒå›´, äº¤é›†åŒ¹é…, ä½¿ç”¨-è¿žæŽ¥èŒƒå›´, å•ä½: kã€‚ä¾‹å¦‚ï¼šã€12-20ã€‘"
        },
        companySizeRange: {
          label: "å…¬å¸è§„æ¨¡èŒƒå›´",
          help: "æŠ•é€’å·¥ä½œçš„å…¬å¸è§„æ¨¡, å­é›†åŒ¹é…, ä½¿ç”¨-è¿žæŽ¥èŒƒå›´ã€‚ä¾‹å¦‚ï¼šã€500-20000000ã€‘"
        },
        customGreeting: {
          label: "è‡ªå®šä¹‰æ‹›å‘¼è¯­",
          help: "å› ä¸ºbossä¸æ”¯æŒå°†è‡ªå®šä¹‰çš„æ‹›å‘¼è¯­è®¾ç½®ä¸ºé»˜è®¤æ‹›å‘¼è¯­ã€‚å¼€å¯è¡¨ç¤ºå‘é€bossé»˜è®¤çš„æ‹›å‘¼è¯­åŽè¿˜ä¼šå‘é€è‡ªå®šä¹‰æ‹›å‘¼è¯­"
        },
        greetingVariable: {
          label: "æ‹›å‘¼è¯­å˜é‡",
          help: "ä½¿ç”¨mitemæ¨¡æ¿å¼•æ“Žæ¥å¯¹æ‹›å‘¼è¯­è¿›è¡Œæ¸²æŸ“;"
        },
        activityFilter: {
          label: "æ´»è·ƒåº¦è¿‡æ»¤",
          help: "æ‰“å¼€åŽä¼šè‡ªåŠ¨è¿‡æ»¤æŽ‰æœ€è¿‘æœªæ´»è·ƒçš„Bosså‘å¸ƒçš„å·¥ä½œã€‚ä»¥å…æµªè´¹æ¯å¤©çš„100æ¬¡æœºä¼šã€‚"
        },
        goldHunterFilter: {
          label: "çŒŽå¤´è¿‡æ»¤",
          help: "Bossä¸­æœ‰ä¸€äº›çŒŽå¤´å‘å¸ƒçš„å·¥ä½œï¼Œä½†æ˜¯ä¸€èˆ¬è€Œè¨€è¿™ç§å·¥ä½œä¸å¤ªè¡Œï¼Œç‚¹å‡»å¯ä»¥è¿‡æ»¤çŒŽå¤´å‘å¸ƒçš„èŒä½"
        },
        friendStatus: {
          label: "å¥½å‹è¿‡æ»¤(å·²èŠ)",
          help: "åˆ¤æ–­å’Œhræ˜¯å¦å»ºç«‹è¿‡èŠå¤©ï¼Œç†è®ºä¸Šèƒ½è¿‡æ»¤çš„åŒhrï¼Œä½†æ˜¯ä¸åŒå²—ä½çš„å·¥ä½œ"
        },
        notification: {
          label: "å‘é€é€šçŸ¥",
          help: "å¯ä»¥åœ¨ç½‘ç«™ç®¡ç†ä¸­æ‰“å¼€é€šçŸ¥æƒé™,å½“åœæ­¢æ—¶ä¼šè‡ªåŠ¨å‘é€æ¡Œé¢ç«¯é€šçŸ¥æé†’ã€‚"
        },
        deliveryLimit: {
          label: "æŠ•é€’ä¸Šé™",
          help: "è¾¾åˆ°ä¸Šé™åŽä¼šè‡ªåŠ¨æš‚åœï¼Œé»˜è®¤100æ¬¡"
        },
        aiGreeting: {
          label: "AIæ‹›å‘¼è¯­",
          help: "å³ä½¿å‰é¢æ‹›å‘¼è¯­å¼€äº†ä¹Ÿä¸ä¼šå‘é€ï¼Œåªä¼šå‘é€AIç”Ÿæˆçš„æ‹›å‘¼è¯­ï¼Œè®©gptæ¥æ‰“æ‹›å‘¼çœŸæ˜¯å¤ªæ£’äº†ï¼Œæ¯•ç«Ÿå¼€åœºç™½å¾ˆé‡è¦ã€‚",
          example: [
            `æˆ‘çŽ°åœ¨éœ€è¦æ±‚èŒï¼Œæ‰€ä»¥è¯·ä½ æ¥å†™æ±‚èŒæ‹›å‘¼è¯­æ¥å‘boosæˆ–hræ‰“æ‹›å‘¼ï¼Œä½ éœ€è¦ä»£å…¥æˆ‘çš„èº«ä»½ä¹Ÿå°±æ˜¯ä¸€åæ±‚èŒè€….
## èƒ½åŠ›:
"æˆ‘å«Ocyss,æ˜¯ä¸€å19å²çš„å…¨æ ˆå·¥ç¨‹å¸ˆï¼Œæ‹¥æœ‰ä¸°å¯Œçš„å‰åŽç«¯å®¢æˆ·ç«¯å¼€å‘ç»éªŒï¼Œå¹¶ä¸”æˆ‘ä¹Ÿèƒ½å¤Ÿè¿›è¡ŒæœåŠ¡å™¨è¿ç»´ã€‚æˆ‘æ˜¯ä¸€ä¸ªå®Œç¾Žä¸»ä¹‰è€…ï¼Œè¿½æ±‚æ•ˆçŽ‡è‡³ä¸Šï¼Œæˆ‘ä¼šæŠŠæ‰€æœ‰éº»çƒ¦é‡å¤çš„äº‹æƒ…éƒ½ç¼–å†™æˆè„šæœ¬ã€‚æˆ‘æ“…é•¿ä½¿ç”¨Golang, Kitex, Hertz, Gin, Gorm, Cobraç­‰åŽç«¯æŠ€æœ¯ï¼ŒRustå’ŒIced, Slintç­‰å®¢æˆ·ç«¯æŠ€æœ¯ï¼Œä»¥åŠVue3, Vite, scss, Nuxt, naiveui, element-plusç­‰å‰ç«¯æŠ€æœ¯ã€‚æˆ‘è¿˜ç†Ÿæ‚‰Mysql, Redis, PostgreSQL, Python, Docker, Linuxç­‰è¿ç»´å’Œå…¶ä»–æŠ€æœ¯ã€‚æˆ‘æ›¾ç»å‚ä¸Žè¿‡å¤šä¸ªé¡¹ç›®çš„å¼€å‘ï¼Œå¦‚å…¨æ ˆåšå®¢ç³»ç»Ÿï¼Œé£žä¹¦å¤šç»´è¡¨æ ¼æ’ä»¶ï¼Œå­—èŠ‚é’è®­è¥é¡¹ç›®ç­‰ã€‚æˆ‘ç›¸ä¿¡æˆ‘çš„æŠ€èƒ½å’Œç»éªŒå¯ä»¥ä¸ºæ‚¨çš„å…¬å¸å¸¦æ¥ä»·å€¼ã€‚"
## è¦æ±‚:
1. æˆ‘ä¼šå‘Šè¯‰ä½ å²—ä½ä¿¡æ¯,ä½ åªéœ€è¦å›žç­”æ‹›å‘¼è¯­ï¼Œè¯·ä¼˜å…ˆç¤¼è²Œä¸ºä¸»ä¸è¦è¿‡äºŽä½¿ç”¨ä¹¦ä¿¡æ ¼å¼è€Œæ˜¯èŠå¤©ä¸€æ ·çš„æ‹›å‘¼è¯­ï¼Œæœ€å¥½èƒ½æ ¹æ®å²—ä½ä¿¡æ¯æ¥æ”¹å˜è¯­æ°”ã€‚
2. ä¸€å®šä¸å¯ä»¥ç¼–é€ èƒ½åŠ›,æˆ‘ä¼šå•¥ä¸Šé¢å†™çš„å¾ˆæ¸…æ¥šäº†,å¦‚æžœæœ‰æˆ‘æ²¡è¯´çš„æŠ€æœ¯æ ˆé‚£å°±æ˜¯ä¸ä¼š,å¯ä»¥å±•ç¤ºå…¶ä»–ä¼˜åŠ¿.ä¸è¦ä¹±å†™
3. æˆ‘éœ€è¦ä½ åœ¨ç»“æŸçš„æ—¶å€™å‘Šè¯‰ä»–è¿™æ˜¯aiç”Ÿæˆçš„å†…å®¹ä»…ä¾›å‚è€ƒ
## å²—ä½ä¿¡æ¯:
\`\`\`
å²—ä½å:{{ card.jobName }}
å²—ä½æè¿°:{{ card.postDescription }}
ç»éªŒè¦æ±‚:{{ card.experienceName }}
ç›¸å…³æ ‡ç­¾:{{ card.jobLabels }}
\`\`\`
`,
            [
              {
                role: "user",
                content: `# Role: æ±‚èŒå°èƒ½æ‰‹
# Author: Ocyss_04
## Definition
æ±‚èŒå°èƒ½æ‰‹æ˜¯ä¸€ç§ä¸“ä¸šè§’è‰²ï¼Œèƒ½å¸®æ ¹æ®æ±‚èŒè€…çš„ç®€åŽ†ç»“åˆå²—ä½çš„ä¿¡æ¯ç”Ÿæˆé«˜è´¨é‡çš„æ‹›å‘¼è¯­ã€‚è¿™ä¸ªè§’è‰²å¾ˆèªæ˜Žèƒ½æ ¹æ®å²—ä½ä¿¡æ¯é¿é‡å°±è½»ï¼Œå°†æ±‚èŒè€…çš„æŠ€èƒ½åˆç†çš„åˆ’åˆ†ï¼Œèƒ½ç”Ÿæˆå¯¹è¿™ä¸ªå²—ä½çš„å¸®åŠ©å’Œæ±‚èŒè€…çš„ä¼˜åŠ¿ï¼Œä¸ä¼šå°†å…¶ä»–æŠ€èƒ½ä¹Ÿå¸¦å…¥æ‹›å‘¼è¯­ä¸­ï¼Œçš†åœ¨å¿«é€Ÿæœ‰æ•ˆçš„è®©Hräº†è§£åˆ°æ±‚èŒè€…çš„èƒ½åŠ›ä¸Žä¼˜åŠ¿ï¼Œä»Žè€Œå¸®åŠ©è¿™äº›æ‰¾ä¸åˆ°å·¥ä½œçš„ç¤¾ç•œèƒ½æ‹¿åˆ°ä¸€ä»½åˆé€‚çš„offer

## Goals
1. **ç®€æ´æ˜Žäº†** - ä¸å•°å—¦ä¸åºŸè¯åªè®²å’Œå²—ä½ä¿¡æ¯æœ‰å…³çš„å†…å®¹
2. **æŠ“ä½é‡ç‚¹** - å½“æ±‚èŒè€…æœ‰å¤šä¸ªæ–¹å‘çš„æŠ€æœ¯æ ˆæ—¶ï¼Œèƒ½æ ¹æ®å²—ä½éœ€æ±‚çªå‡ºè¿™æ–¹é¢çš„ä¼˜åŠ¿å’Œèƒ½åŠ›
3. **çªå‡ºä¼˜åŠ¿** - å²—ä½çš„æŠ€æœ¯æ ˆæ±‚èŒè€…ä¸ä¼šï¼Œä¼šç”¨å…¶ä»–æŠ€èƒ½æ¥çªå‡ºæ±‚èŒè€…çš„èƒ½åŠ›

## Constrains
1. **ä¸¥è°¨å¿ƒç»†** - ä¸å°†æ±‚èŒè€…ä¸ä¼šçš„æŠ€èƒ½å†™è¿›æ‹›å‘¼è¯­ä¸­ï¼Œä¸èƒ½ç¯¡æ”¹æ±‚èŒè€…çš„æŠ€èƒ½ç†Ÿç»ƒåº¦ä¸Žå¹´é™
2. **å’Œè”¼å¯äº²** - ä¸éœ€è¦ä¹¦ä¿¡ç­‰æ ¼å¼åƒèŠå¤©å¼€åœºç™½ä¸€æ ·æ‰“æ‹›å‘¼
3. **é¿å…é£Žé™©** - æœ€åŽè¯´æ˜Žè¿™æ˜¯aiç”Ÿæˆçš„å†…å®¹ä»…ä¾›å‚è€ƒ

## skill
1. **å…¨æ ˆé«˜æ‰‹** - ç²¾é€šç¼–ç¨‹çš„å„ç§æŠ€æœ¯æ ˆï¼ŒçŸ¥é“ä¸åŒçš„æ¡†æž¶ï¼Œæœ‰æ•ˆçš„çªå‡ºæ±‚èŒè€…çš„æŠ€èƒ½
2. **èŒåœºè€ç‚®** - å¤šå¹´èŒåœºç»éªŒä»…ä»Žå²—ä½ä¿¡æ¯å°±èƒ½æ˜Žç™½è€æ¿æ„æ€ï¼Œä»Žè€Œç”Ÿæˆå¹½é»˜é£Žè¶£ç¬¦åˆè€æ¿èƒƒå£çš„æ‹›å‘¼è¯­

## Workflow
1. æ­¥éª¤ä¸€ï¼šå…ˆæ ¹æ®\`input\`çš„æ±‚èŒè€…ä¿¡æ¯è¿›ä¸€æ­¥æ€è€ƒç†è§£å¹¶æ¶ˆåŒ–ï¼Œç„¶åŽæ‰§è¡Œ\`Initialization\` å‘ŠçŸ¥ç”¨æˆ·å·²å‡†å¤‡å®Œæ¯•ã€‚
2. æ­¥éª¤äºŒï¼šå¼€å§‹ç”¨æˆ·è¾“å…¥çš„\`å²—ä½ä¿¡æ¯\`è¿›è¡Œæ€è€ƒç†è§£ï¼Œåˆ†æžå‡ºå²—ä½éœ€è¦çš„æŠ€æœ¯æ ˆå’Œä¸šåŠ¡çš„éœ€æ±‚
3. æ­¥éª¤ä¸‰ï¼šç»“åˆæ±‚èŒè€…çš„èƒ½åŠ›å’Œç»åŽ†ç”Ÿæˆåˆé€‚çš„æ‹›å‘¼è¯­ï¼Œå¹¶ç¡®ä¿å†…å®¹ä¸­æ— è™šæž„æ±‚èŒè€…çš„èƒ½åŠ›å’Œå¹´é™ç­‰ä¿¡æ¯ï¼Œç„¶åŽæŒ‰\`outputformat\`è¾“å‡º

## inputï¼š
1 **æ±‚èŒè€…ä¿¡æ¯**
\`\`\`
æˆ‘æ˜¯ä¸€å19å²çš„å…¨æ ˆå·¥ç¨‹å¸ˆï¼Œæ‹¥æœ‰ä¸°å¯Œçš„å‰åŽç«¯å®¢æˆ·ç«¯å¼€å‘ç»éªŒï¼Œå¹¶ä¸”æˆ‘ä¹Ÿèƒ½å¤Ÿè¿›è¡ŒæœåŠ¡å™¨è¿ç»´ã€‚æˆ‘æ˜¯ä¸€ä¸ªå®Œç¾Žä¸»ä¹‰è€…ï¼Œè¿½æ±‚æ•ˆçŽ‡è‡³ä¸Šï¼Œæˆ‘ä¼šæŠŠæ‰€æœ‰éº»çƒ¦é‡å¤çš„äº‹æƒ…éƒ½ç¼–å†™æˆè„šæœ¬ã€‚æˆ‘æ“…é•¿ä½¿ç”¨Golang, Kitex, Hertz, Gin, Gorm, Cobraç­‰åŽç«¯æŠ€æœ¯ï¼ŒRustå’ŒIced, Slintç­‰å®¢æˆ·ç«¯æŠ€æœ¯ï¼Œä»¥åŠVue3, Vite, scss, Nuxt, naiveui, element-plusç­‰å‰ç«¯æŠ€æœ¯ã€‚æˆ‘è¿˜ç†Ÿæ‚‰Mysql, Redis, PostgreSQL, Python, Docker, Linuxç­‰è¿ç»´å’Œå…¶ä»–æŠ€æœ¯ã€‚æˆ‘æ›¾ç»å‚ä¸Žè¿‡å¤šä¸ªé¡¹ç›®çš„å¼€å‘ï¼Œå¦‚å…¨æ ˆåšå®¢ç³»ç»Ÿï¼Œé£žä¹¦å¤šç»´è¡¨æ ¼æ’ä»¶ï¼Œå­—èŠ‚é’è®­è¥é¡¹ç›®ç­‰ã€‚æˆ‘ç›¸ä¿¡æˆ‘çš„æŠ€èƒ½å’Œç»éªŒå¯ä»¥ä¸ºæ‚¨çš„å…¬å¸å¸¦æ¥ä»·å€¼ã€‚
#### é¡¹ç›®è¯¦ç»†
1. ....
2. ....
3. ....
\`\`\`

## outputformat
æ‹›å‘¼è¯­å­—ç¬¦ä¸²ï¼Œæ— ä¹¦ä¿¡æ ¼å¼å’Œå‰ç¼€ï¼Œå’ŒèŠå¤©å¼€åœºç™½ä¸€æ ·çš„ä»‹ç»æ±‚èŒè€…

## Initialization:
"ä½ å¥½ï¼Œæˆ‘æ˜¯æ±‚èŒå°èƒ½æ‰‹ï¼Œæˆ‘å·²ç»æŽŒæ¡äº†æ‚¨çš„èƒ½åŠ›ã€‚æˆ‘å°†åˆ©ç”¨æˆ‘çš„ä¸“ä¸šæŠ€èƒ½å’Œä¸¥è°¨è®¤çœŸçš„æ€åº¦ä¸ºæ‚¨ç”Ÿæˆç‹¬ä¸€æ— äºŒä¸”çš„æ±‚èŒæ‹›å‘¼è¯­ã€‚çŽ°åœ¨è¯·æä¾›å²—ä½ä¿¡æ¯ï¼Œæˆ‘å°†å¼€å§‹ä¸ºæ‚¨ç”Ÿæˆæ±‚èŒæ‹›å‘¼è¯­"
`
              },
              {
                role: "assistant",
                content: "ä½ å¥½ï¼Œæˆ‘æ˜¯æ±‚èŒå°èƒ½æ‰‹ï¼Œæˆ‘å·²ç»æŽŒæ¡äº†æ‚¨çš„èƒ½åŠ›ã€‚æˆ‘å°†åˆ©ç”¨æˆ‘çš„ä¸“ä¸šæŠ€èƒ½å’Œä¸¥è°¨è®¤çœŸçš„æ€åº¦ä¸ºæ‚¨ç”Ÿæˆç‹¬ä¸€æ— äºŒä¸”çš„æ±‚èŒæ‹›å‘¼è¯­ã€‚çŽ°åœ¨è¯·æä¾›å²—ä½ä¿¡æ¯ï¼Œæˆ‘å°†å¼€å§‹ä¸ºæ‚¨ç”Ÿæˆæ±‚èŒæ‹›å‘¼è¯­"
              },
              {
                role: "user",
                content: `### å¾…å¤„ç†çš„å²—ä½ä¿¡æ¯:\`\`\`
å²—ä½å:{{ card.jobName }}
å²—ä½æè¿°:{{ card.postDescription }}
ç»éªŒè¦æ±‚:{{ card.experienceName }}
ç›¸å…³æ ‡ç­¾:{{ card.jobLabels }}
\`\`\``
              }
            ]
          ]
        },
        aiFiltering: {
          label: "AIè¿‡æ»¤",
          help: "æ ¹æ®å·¥ä½œå†…å®¹è®©gptåˆ†æžè¿‡æ»¤ï¼ŒçœŸæ˜¯å¤ªç¨³å¥äº†ï¼Œä¸æ”¾è¿‡ä»»ä½•ä¸€ä¸ªåžƒåœ¾",
          example: [
            `æˆ‘çŽ°åœ¨éœ€è¦æ±‚èŒï¼Œè®©ä½ æ ¹æ®æˆ‘çš„éœ€è¦å¯¹å²—ä½è¿›è¡Œè¯„åˆ†ï¼Œæ–¹ä¾¿æˆ‘ç­›é€‰å²—ä½ã€‚
## è¦æ±‚:
- åŠ åˆ†: åŒä¼‘,æ—©ä¹æ™šäº”,æ–°æŠ€æœ¯,æœºä¼šå¤š,å¹´è½»äººå¤š
- æ‰£åˆ†: éœ€è¦ä¸Šé—¨,ç¦åˆ©å°‘,éœ€è¦å’Œå®¢æˆ·äº¤æµ,éœ€è¦æŽ¨é”€
## æ˜¯å²—ä½ç›¸å…³ä¿¡æ¯:
\`\`\`
å²—ä½æè¿°:{{ card.postDescription}}
è–ªé…¬:{{card.salaryDesc}}
ç»éªŒè¦æ±‚:{{card.experienceName}},å­¦åŽ†è¦æ±‚:{{card.degreeName}}
ç›¸å…³æ ‡ç­¾:{{card.jobLabels}},å…¬å¸ç¦åˆ©ï¼š{{data.welfareList}}
\`\`\`
## è¾“å‡º
interface aiFiltering {
  rating: number; // åˆ†æ•°ï¼Œ0-100åˆ†ï¼Œä½ŽäºŽ40çš„æˆ‘ä¼šç­›é€‰æŽ‰
  negative: string[] | string; // æ‰£åˆ†é¡¹
  positive: string[] | string; // åŠ åˆ†é¡¹
}`,
            [
              {
                role: "user",
                content: `# Role: æ±‚èŒè¯„å§”
# Author: Ocyss_04
## Profile
- Language: ä¸­æ–‡
- Description: æ‹¥æœ‰ä¸°å¯Œçš„èŒåœºç»éªŒèƒ½ä»Žå²—ä½ä¿¡æ¯ä¸­çœ‹å‡ºè¿™ä¸ªå²—ä½çš„ä»·å€¼å’Œé£Žé™©,ä¹Ÿæ˜Žç™½æ±‚èŒè€…çœŸæ­£éœ€è¦çš„å²—ä½æ˜¯å•¥,ä»Žå¤šæ–¹é¢è€ƒè™‘è¿›è€Œè¯„åˆ†

### æ“…é•¿äººæƒ…ä¸–æ•…:
1. çŸ¥é“è¿™ä¸ªè€æ¿æ˜¯åŽ‹æ¦¨å‘˜å·¥çš„èµ„æœ¬å®¶è¿˜æ˜¯æ›´çœ‹é‡å‘˜å·¥èƒ½åŠ›çš„ä¼ä¸šå®¶
2.å…¬å¸ç¦åˆ©èƒ½çœ‹å‡ºè€æ¿çœŸæ­£çš„å¿ƒæ€
3.çŸ¥é“æ±‚èŒè€…çš„éœ€æ±‚,æ˜¯æƒ³è¦çš„ç¦åˆ©è¿˜æ˜¯å¿…è¦çš„ç¦åˆ©ä»Žè€ŒåŠ åˆ†æˆ–å‡åˆ†

## Rules
1. å®¢è§‚è¯„ä»·æœ‰ç†æœ‰æ®
2. ä¸èƒ½æŠŠç”¨æˆ·æƒ³è¦çš„ç¦åˆ©å½“æˆæ‰£åˆ†é¡¹

## Workflow
1. å²—ä½åˆå§‹æœ‰70åˆ†,è¾“å…¥å²—ä½ä¿¡æ¯ç»“åˆä¸‹é¢çš„æ±‚èŒè€…éœ€æ±‚æ¥è¿›è¡Œæ‰“åˆ†,æœ€ç»ˆè¿”å›žä¸‹é¢æ ¼å¼çš„JSONå­—ç¬¦ä¸²,ä¸è¦æœ‰ä»»ä½•å…¶ä»–å­—ç¬¦
interface aiFiltering {
  rating: number; // åˆ†æ•°, ä½ŽäºŽ40çš„æˆ‘ä¼šç­›é€‰æŽ‰
  negative: string[] | string; // æ‰£åˆ†é¡¹
  positive: string[] | string; // åŠ åˆ†é¡¹
}

## æ±‚èŒè€…éœ€æ±‚
- åŠ åˆ†: åŒä¼‘,æ—©ä¹æ™šäº”,æ–°æŠ€æœ¯,æœºä¼šå¤š,å¹´è½»äººå¤š
- æ‰£åˆ†: éœ€è¦ä¸Šé—¨,ç¦åˆ©å°‘,éœ€è¦å’Œå®¢æˆ·äº¤æµ,éœ€è¦æŽ¨é”€

## Initialization
ä½ å¥½,æˆ‘æ˜¯æ±‚èŒè¯„ä¸º,æˆ‘å·²ç»æŽŒæ¡äº†æ‚¨çš„èƒ½åŠ›ã€‚æˆ‘å°†åˆ©ç”¨æˆ‘çš„ä¸“ä¸šæŠ€èƒ½å’Œä¸¥è°¨è®¤çœŸçš„æ€åº¦å¯¹ä½ è¾“å…¥çš„å²—ä½ä¿¡æ¯è¿›è¡Œæ‰“åˆ†,å¹¶è¿”å›žç¬¦åˆæ ¼å¼çš„Jsonæ ¼å¼å­—ç¬¦ä¸²
`
              },
              {
                role: "assistant",
                content: "ä½ å¥½,æˆ‘æ˜¯æ±‚èŒè¯„ä¸º,æˆ‘å·²ç»æŽŒæ¡äº†æ‚¨çš„èƒ½åŠ›ã€‚æˆ‘å°†åˆ©ç”¨æˆ‘çš„ä¸“ä¸šæŠ€èƒ½å’Œä¸¥è°¨è®¤çœŸçš„æ€åº¦å¯¹ä½ è¾“å…¥çš„å²—ä½ä¿¡æ¯è¿›è¡Œæ‰“åˆ†,å¹¶è¿”å›žç¬¦åˆæ ¼å¼çš„Jsonæ ¼å¼å­—ç¬¦ä¸²"
              },
              {
                role: "user",
                content: `### å¾…å¤„ç†çš„å²—ä½ä¿¡æ¯:\`\`\`
å²—ä½æè¿°:{{ card.postDescription}}
ç›¸å…³æ ‡ç­¾:{{card.jobLabels}}
å…¬å¸ç¦åˆ©ï¼š{{data.welfareList}}
\`\`\``
              }
            ]
          ]
        },
        aiReply: {
          label: "AIå›žå¤",
          help: "ä¸‡ä¸€æ¶ˆæ¯å¤ªå¤šï¼Œå›žä¸è¿‡æ¥äº†å‘¢ï¼Œä¹Ÿè®¸èƒ½å’ŒAiHRèŠåˆ°åœ°çƒçˆ†ç‚¸ï¼Ÿé­”æ³•å‡»è´¥é­”æ³•"
        },
        record: {
          label: "å†…å®¹è®°å½•",
          help: "æ‹¿è¿™äº›æ•°æ®åŽ»è®­ç»ƒä¸ªAiå²‚ä¸æ˜¯ç¾Žæ»‹æ»‹å’¯ï¼Ÿ"
        },
        delay: {
          deliveryStarts: {
            label: "æŠ•é€’å¼€å§‹",
            help: "ç‚¹å‡»æŠ•é€’æŒ‰é’®ä¼šç­‰å¾…ä¸€æ®µæ—¶é—´,é»˜è®¤å€¼10s"
          },
          deliveryInterval: {
            label: "æŠ•é€’é—´éš”",
            help: "æ¯ä¸ªæŠ•é€’çš„é—´éš”,å¤ªå¿«æ˜“é£ŽæŽ§,é»˜è®¤å€¼2s"
          },
          deliveryPageNext: {
            label: "æŠ•é€’ç¿»é¡µ",
            help: "æŠ•é€’å®Œä¸‹ä¸€é¡µä¹‹åŽç­‰å¾…çš„é—´éš”,å¤ªå¿«æ˜“é£ŽæŽ§,é»˜è®¤å€¼60s"
          },
          messageSending: {
            label: "æ¶ˆæ¯å‘é€",
            help: "æš‚æœªå®žçŽ° ,åœ¨å‘é€æ¶ˆæ¯å‰å…è®¸ç­‰å¾…ä¸€å®šçš„æ—¶é—´è®©ç”¨æˆ·æ¥ä¿®æ”¹æˆ–æ‰‹åŠ¨å‘é€,é»˜è®¤å€¼5s",
            disable: true
          }
        }
      });
      const defaultFormData = {
        company: {
          include: false,
          value: [],
          options: [],
          enable: false
        },
        jobTitle: {
          include: true,
          value: [],
          options: [],
          enable: false
        },
        jobContent: {
          include: false,
          value: [],
          options: [],
          enable: false
        },
        hrPosition: {
          include: true,
          value: [],
          options: ["ç»ç†", "ä¸»ç®¡", "æ³•äºº", "äººåŠ›èµ„æºä¸»ç®¡", "hr", "æ‹›è˜ä¸“å‘˜"],
          enable: false
        },
        salaryRange: {
          value: "8-13",
          enable: false
        },
        companySizeRange: {
          value: "",
          enable: false
        },
        customGreeting: {
          value: "",
          enable: false
        },
        deliveryLimit: {
          value: 100
        },
        greetingVariable: {
          value: true
        },
        activityFilter: {
          value: true
        },
        friendStatus: {
          value: true
        },
        goldHunterFilter: {
          value: false
        },
        notification: {
          value: true
        },
        aiGreeting: {
          enable: false,
          prompt: ""
        },
        aiFiltering: {
          enable: false,
          prompt: ""
        },
        aiReply: {
          enable: false,
          prompt: ""
        },
        record: {
          enable: false
        },
        delay: {
          deliveryStarts: 10,
          deliveryInterval: 2,
          deliveryPageNext: 60,
          messageSending: 5
        }
      };
      const formData = reactive(
        deepmerge(defaultFormData, _GM_getValue(formDataKey, {}))
      );
      watchThrottled(
        formData,
        (v) => {
          logger.debug("formDataæ”¹å˜", toRaw(v));
        },
        { throttle: 2e3 }
      );
      function confSaving() {
        const v = toRaw(formData);
        _GM_setValue(formDataKey, v);
        logger.debug("formDataä¿å­˜", toRaw(v));
      }
      function confReload() {
        const v = deepmerge(defaultFormData, _GM_getValue(formDataKey, {}));
        deepmerge(formData, v, { clone: false });
        logger.debug("formDataå·²é‡ç½®");
      }
      function confExport() {
        const data = deepmerge(
          defaultFormData,
          _GM_getValue(formDataKey, {})
        );
        const blob = new Blob([JSON.stringify(data)], {
          type: "application/json"
        });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "æ‰“æ‹›å‘¼é…ç½®.json";
        link.click();
      }
      function confImport() {
        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.addEventListener("change", function(e) {
          var _a2;
          const file = (_a2 = e.target.files) == null ? void 0 : _a2[0];
          if (!file || !file.name.endsWith(".json")) {
            return alert("ä¸æ˜¯ JSON æ–‡ä»¶");
          }
          const reader = new FileReader();
          reader.onload = function(e2) {
            try {
              const jsonData = JSON.parse(e2.target.result);
              let type = Object.prototype.toString.call(jsonData).slice(8, -1);
              if (!["Array", "Object"].includes(type)) {
                return alert("å†…å®¹éžåˆæ³• JSON");
              }
              _GM_setValue(formDataKey, jsonData);
              deepmerge(formData, jsonData, { clone: false });
            } catch (error) {
              return alert("å†…å®¹éžåˆæ³• JSON");
            }
          };
          reader.readAsText(file);
        });
        fileInput.click();
      }
      function confDelete() {
        deepmerge(formData, defaultFormData, { clone: false });
        logger.debug("formDataå·²æ¸…ç©º");
      }
      const useConfFormData = exports("f", () => {
        return {
          confSaving,
          confReload,
          confExport,
          confImport,
          confDelete,
          formDataKey,
          defaultFormData,
          formData
        };
      });
      function notification(content) {
        _GM_notification({
          title: "Bossç›´è˜æ‰¹é‡æŠ•ç®€åŽ†",
          image: "https://img.bosszhipin.com/beijin/mcs/banner/3e9d37e9effaa2b6daf43f3f03f7cb15cfcd208495d565ef66e7dff9f98764da.jpg",
          text: content,
          highlight: true,
          // å¸ƒå°”å€¼ï¼Œæ˜¯å¦çªå‡ºæ˜¾ç¤ºå‘é€é€šçŸ¥çš„é€‰é¡¹å¡
          silent: true,
          // å¸ƒå°”å€¼ï¼Œæ˜¯å¦æ’­æ”¾å£°éŸ³
          timeout: 1e4,
          // è®¾ç½®é€šçŸ¥éšè—æ—¶é—´
          onclick: function() {
            logger.info("ç‚¹å‡»äº†é€šçŸ¥");
          },
          ondone() {
          }
          // åœ¨é€šçŸ¥å…³é—­ï¼ˆæ— è®ºè¿™æ˜¯ç”±è¶…æ—¶è¿˜æ˜¯å•å‡»è§¦å‘ï¼‰æˆ–çªå‡ºæ˜¾ç¤ºé€‰é¡¹å¡æ—¶è°ƒç”¨
        });
      }
      function animate({
        duration,
        draw,
        timing,
        end,
        callId
      }) {
        let start2 = performance.now();
        callId(
          requestAnimationFrame(function animate2(time) {
            let timeFraction = (time - start2) / duration;
            if (timeFraction > 1) timeFraction = 1;
            let progress = timing(timeFraction);
            draw(progress);
            if (timeFraction < 1) {
              callId(requestAnimationFrame(animate2));
            } else if (end) {
              end();
            }
          })
        );
      }
      let delayLoadId = void 0;
      function delay(s) {
        loader({ ms: s * 1e3 });
        return new Promise((resolve) => setTimeout(resolve, s * 1e3));
      }
      function loader({ ms = 1e4, color = "#54f98d", onDone = () => {
      } }) {
        var _a2;
        let load = document.querySelector("#loader");
        if (!load) {
          const l = document.createElement("div");
          l.id = "loader";
          (_a2 = document.querySelector("#header")) == null ? void 0 : _a2.appendChild(l);
          load = l;
        }
        load.style.background = color;
        if (delayLoadId) {
          cancelAnimationFrame(delayLoadId);
          delayLoadId = void 0;
        }
        if (load)
          animate({
            duration: ms,
            callId(id) {
              delayLoadId = id;
            },
            timing(timeFraction) {
              return timeFraction;
            },
            draw(progress) {
              if (load) load.style.width = progress * 100 + "%";
            },
            end() {
              if (load) load.style.width = "0%";
              onDone();
            }
          });
        return () => {
          if (delayLoadId) cancelAnimationFrame(delayLoadId);
          delayLoadId = void 0;
          const load2 = document.querySelector("#loader");
          if (load2) load2.style.width = "0%";
        };
      }
      function getCurDay(currentDate = /* @__PURE__ */ new Date()) {
        const year = currentDate.getFullYear();
        const month = String(currentDate.getMonth() + 1).padStart(2, "0");
        const day = String(currentDate.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      }
      function getCurTime(currentDate = /* @__PURE__ */ new Date()) {
        const hours = String(currentDate.getHours() + 1).padStart(2, "0");
        const minutes = String(currentDate.getMinutes() + 1).padStart(2, "0");
        const seconds = String(currentDate.getSeconds()).padStart(2, "0");
        return `${hours}:${minutes}:${seconds}`;
      }
      const todayData = reactiveComputed(() => {
        const date = getCurDay();
        const current = {
          date,
          success: 0,
          total: 0,
          company: 0,
          jobTitle: 0,
          jobContent: 0,
          hrPosition: 0,
          salaryRange: 0,
          companySizeRange: 0,
          activityFilter: 0,
          goldHunterFilter: 0,
          repeat: 0
        };
        const g = _GM_getValue(todayKey, current);
        logger.debug("ç»Ÿè®¡æ•°æ®:", g);
        if (g.date === date) {
          return g;
        }
        const statistics = _GM_getValue(statisticsKey, []);
        _GM_setValue(statisticsKey, [g, ...statistics]);
        _GM_setValue(todayKey, current);
        return current;
      });
      const statisticsData = _GM_getValue(statisticsKey, []);
      watchThrottled(
        todayData,
        (v) => {
          _GM_setValue(todayKey, v);
        },
        { throttle: 200 }
      );
      const useStatistics = exports("d", () => {
        return {
          todayData,
          statisticsData
        };
      });
      const win = _unsafeWindow || document.defaultView || window;
      const doc = win.document;
      const listeners = /* @__PURE__ */ new WeakMap();
      const elProto = win.Element.prototype;
      const matches = elProto.matches || elProto.matchesSelector || elProto.webkitMatchesSelector || elProto.mozMatchesSelector || elProto.oMatchesSelector;
      const MutationObs = win.MutationObserver || win.WebkitMutationObserver || win.MozMutationObserver;
      function addObserver(target, callback) {
        const observer = new MutationObs((mutations) => {
          for (const mutation of mutations) {
            if (mutation.type === "attributes") {
              callback(mutation.target);
              if (observer.canceled) return;
            }
            for (const node of mutation.addedNodes) {
              if (node instanceof Element) callback(node);
              if (observer.canceled) return;
            }
          }
        });
        observer.canceled = false;
        observer.observe(target, {
          childList: true,
          subtree: true,
          attributes: true
        });
        return () => {
          observer.canceled = true;
          observer.disconnect();
        };
      }
      function addFilter(target, filter2) {
        let listener = listeners.get(target);
        if (!listener) {
          listener = {
            filters: /* @__PURE__ */ new Set(),
            remove: addObserver(
              target,
              (el) => listener.filters.forEach((f) => f(el))
            )
          };
          listeners.set(target, listener);
        }
        listener.filters.add(filter2);
      }
      function removeFilter(target, filter2) {
        const listener = listeners.get(target);
        if (!listener) return;
        listener.filters.delete(filter2);
        if (!listener.filters.size) {
          listener.remove();
          listeners.delete(target);
        }
      }
      function query(all3, selector, parent, includeParent) {
        const checkParent = includeParent && matches.call(parent, selector);
        if (all3) {
          const queryAll = parent.querySelectorAll(selector);
          return checkParent ? [parent, ...queryAll] : [...queryAll];
        }
        return checkParent ? parent : parent.querySelector(selector);
      }
      function getOne(selector, parent, timeout) {
        return new Promise((resolve) => {
          const node = query(false, selector, parent, false);
          if (node) return resolve(node);
          let timer;
          const filter2 = (el) => {
            const node2 = query(false, selector, el, true);
            if (node2) {
              removeFilter(parent, filter2);
              timer && clearTimeout(timer);
              resolve(node2);
            }
          };
          addFilter(parent, filter2);
          if (timeout > 0) {
            timer = setTimeout(() => {
              removeFilter(parent, filter2);
              resolve(null);
            }, timeout);
          }
        });
      }
      function get(selector, ...args) {
        let parent = typeof args[0] !== "number" && args.shift() || doc;
        const timeout = args[0] || 0;
        if (Array.isArray(selector)) {
          return Promise.all(
            selector.map((s) => getOne(s, parent, timeout))
          );
        }
        return getOne(selector, parent, timeout);
      }
      function each(selector, ...args) {
        let parent = typeof args[0] !== "function" && args.shift() || doc;
        const callback = args[0];
        const refs = /* @__PURE__ */ new WeakSet();
        for (const node of query(true, selector, parent, false)) {
          refs.add(node);
          if (callback(node, false) === false) return;
        }
        const filter2 = (el) => {
          for (const node of query(true, selector, el, true)) {
            const _el = node;
            if (refs.has(_el)) break;
            refs.add(_el);
            if (callback(node, true) === false) {
              return removeFilter(parent, filter2);
            }
          }
        };
        addFilter(parent, filter2);
      }
      async function rm(selector, ...args) {
        if (Array.isArray(selector)) {
          await Promise.all(
            selector.map((s) => {
              get(s, ...args).then((e) => e.remove());
            })
          );
        } else {
          await get(selector, ...args).then((e) => e.remove());
        }
      }
      const elmGetter = exports("e", {
        get,
        each,
        rm
      });
      const rootVue = ref();
      const getRootVue = async () => {
        if (rootVue.value) return rootVue.value;
        let wrap = await elmGetter.get("#wrap");
        if (wrap.__vue__) rootVue.value = wrap.__vue__;
        else {
          throw new Error("æœªæ‰¾åˆ°vueæ ¹ç»„ä»¶");
        }
        return rootVue.value;
      };
      const useHookVueData = exports("u", (selectors, key, data) => {
        return () => {
          const jobVue = document.querySelector(selectors).__vue__;
          data.value = jobVue[key];
          let originalSet = jobVue.__lookupSetter__(key);
          Object.defineProperty(jobVue, key, {
            set(val) {
              data.value = val;
              originalSet.call(this, val);
            }
          });
        };
      });
      const useHookVueFn = exports("b", (selectors, key) => {
        return () => {
          const jobVue = document.querySelector(selectors).__vue__;
          return jobVue[key];
        };
      });
      const userInfo = ref();
      const storeInit = async () => {
        var _a2;
        const v = await getRootVue();
        const store = (_a2 = v == null ? void 0 : v.$store) == null ? void 0 : _a2.state;
        userInfo.value = store == null ? void 0 : store.userInfo;
        logger.debug("userInfo: ", userInfo.value);
      };
      const useStore = () => {
        return {
          storeInit,
          userInfo
        };
      };
      const useUserId = exports("C", () => {
        var _a2, _b, _c;
        return ((_a2 = userInfo.value) == null ? void 0 : _a2.userId) || ((_b = _unsafeWindow == null ? void 0 : _unsafeWindow._PAGE) == null ? void 0 : _b.uid) || ((_c = _unsafeWindow == null ? void 0 : _unsafeWindow._PAGE) == null ? void 0 : _c.userId);
      });
      const _hoisted_1 = { style: { "align-items": "center", "display": "flex" } };
      const _hoisted_2 = { style: { "margin-left": "8px" } };
      const confUserKey = "conf-user";
      const _sfc_main$5 = /* @__PURE__ */ defineComponent({
        __name: "user",
        props: {
          "modelValue": { type: Boolean, ...{ required: true } },
          "modelModifiers": {}
        },
        emits: ["update:modelValue"],
        setup(__props) {
          const { formData: formData2 } = useConfFormData();
          const { todayData: todayData2 } = useStatistics();
          const { userInfo: userInfo2 } = useStore();
          const show = useModel(__props, "modelValue");
          const data = reactive(_GM_getValue(confUserKey, {}));
          const tableData = computed(() => Object.values(data));
          logger.debug("è´¦æˆ·æ•°æ®", toRaw(data));
          const currentRow = ref();
          const handleCurrentChange = (val) => {
            currentRow.value = val;
          };
          async function create(flag = true) {
            var _a2, _b, _c, _d, _e, _f;
            logger.debug("å¼€å§‹åˆ›å»ºè´¦æˆ·");
            try {
              const list = await new Promise((resolve, reject) => {
                _GM_cookie.list({}, (cookies2, error) => {
                  if (error) {
                    reject(error);
                  } else {
                    resolve(cookies2);
                  }
                });
              });
              logger.debug(list);
              let uid = useUserId();
              if (!uid) {
                throw new Error("æ‰¾ä¸åˆ°uid");
              }
              uid = String(uid);
              data[uid] = {
                uid,
                user: ((_a2 = userInfo2.value) == null ? void 0 : _a2.showName) || ((_b = userInfo2.value) == null ? void 0 : _b.name) || "nil",
                avatar: ((_c = userInfo2.value) == null ? void 0 : _c.tinyAvatar) || ((_d = userInfo2.value) == null ? void 0 : _d.largeAvatar) || "",
                remark: "",
                gender: ((_e = userInfo2.value) == null ? void 0 : _e.gender) === 0 ? "man" : "woman",
                flag: ((_f = userInfo2.value) == null ? void 0 : _f.studentFlag) ? "student" : "staff",
                date: (/* @__PURE__ */ new Date()).toLocaleString(),
                cookie: JSON.stringify(list),
                form: toRaw(formData2),
                statistics: toRaw(todayData2)
              };
              _GM_setValue(confUserKey, data);
              await Promise.all(
                list.map((item) => _GM_cookie.delete({ name: item.name }))
              );
              if (flag) {
                ElMessage.success("åˆ›å»ºæˆåŠŸ,å¼€å§‹æ¸…ç©ºckå¹¶åˆ·æ–°");
                window.location.reload();
              }
            } catch (e) {
              ElMessage.error("é‡åˆ°é”™è¯¯,è¯·é‡è¯•," + e);
              throw new Error("err", { cause: e });
            }
          }
          async function change() {
            try {
              const data2 = currentRow.value;
              if (!data2) {
                ElMessage.error("é”™è¯¯,ç©ºçŠ¶æ€");
                return;
              }
              currentRow.value = void 0;
              await create(false);
              if (data2.form) _GM_setValue(formDataKey, data2.form);
              if (data2.statistics) _GM_setValue(todayKey, data2.statistics);
              const ck = JSON.parse(data2.cookie);
              await Promise.all(ck.map((c) => _GM_cookie.set(c)));
              ElMessage.success("åˆ‡æ¢å®Œæˆ,å³å°†åˆ·æ–°");
              window.location.reload();
            } catch (e) {
              logger.error("é”™è¯¯,åˆ‡æ¢å¤±è´¥", e);
              if (e.name !== "err" || !e.name) ElMessage.error("é”™è¯¯,åˆ‡æ¢å¤±è´¥");
            }
          }
          function del(d) {
            delete data[d.uid];
            logger.debug(data);
            _GM_setValue(confUserKey, toRaw(data));
            ElMessage.success("åˆ é™¤æˆåŠŸ");
          }
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElDialog), {
              modelValue: show.value,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => show.value = $event),
              title: "è´¦æˆ·é…ç½®",
              width: "70%",
              "align-center": "",
              "destroy-on-close": "",
              "z-index": 20
            }, {
              footer: withCtx(() => [
                createElementVNode("div", null, [
                  createVNode(unref(ElButton$1), {
                    onClick: _cache[0] || (_cache[0] = ($event) => show.value = false)
                  }, {
                    default: withCtx(() => _cache[5] || (_cache[5] = [
                      createTextVNode("å–æ¶ˆ")
                    ])),
                    _: 1
                  }),
                  createVNode(unref(ElPopconfirm), {
                    title: "ç¡®è®¤åŽå°†ä¿å­˜æ•°æ®é€€å‡ºè´¦æˆ·å¹¶è‡ªåŠ¨åˆ·æ–°",
                    onConfirm: _cache[1] || (_cache[1] = () => create())
                  }, {
                    reference: withCtx(() => [
                      createVNode(unref(ElButton$1), { type: "primary" }, {
                        default: withCtx(() => _cache[6] || (_cache[6] = [
                          createTextVNode("æ–°å»º&ç™»å‡º")
                        ])),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  createVNode(unref(ElButton$1), {
                    type: "primary",
                    onClick: change,
                    disabled: !currentRow.value
                  }, {
                    default: withCtx(() => _cache[7] || (_cache[7] = [
                      createTextVNode(" åˆ‡æ¢ ")
                    ])),
                    _: 1
                  }, 8, ["disabled"])
                ])
              ]),
              default: withCtx(() => [
                createVNode(unref(ElAlert), {
                  title: "ä½¿ç”¨è¯¥åŠŸèƒ½å°†ä¼šæ˜Žæ–‡å­˜å‚¨cookieä¿¡æ¯,å¯èƒ½åŒ…å«éšç§ä¿¡æ¯",
                  type: "warning",
                  style: { "margin": "6px 0" }
                }),
                createVNode(unref(ElAlert), {
                  title: "æ¯ä¸ªç”¨æˆ·éƒ½æœ‰è‡ªå·±çš„ç›¸å…³é…ç½®ä½†åŽ†å²æŠ•é€’ç­‰ä¿¡æ¯å°†å…¨å±€å…±äº«,å¦‚æžœåˆ‡æ¢åŽæ˜¯æœªç™»é™†çŠ¶æ€å¯èƒ½ckä¸å®Œæ•´æˆ–è¿‡æœŸå†æ¬¡ç™»é™†å³å¯(ä¸è¦åˆ é™¤,ä¸ç„¶é…ç½®ä¼šä¸¢å¤±)",
                  type: "info",
                  style: { "margin": "6px 0" }
                }),
                createVNode(unref(ElTable), {
                  data: tableData.value,
                  style: { "width": "100%" },
                  "highlight-current-row": "",
                  "table-layout": "auto",
                  onCurrentChange: handleCurrentChange
                }, {
                  default: withCtx(() => [
                    createVNode(unref(ElTableColumn), {
                      type: "index",
                      width: "40"
                    }),
                    createVNode(unref(ElTableColumn), { label: "è´¦æˆ·" }, {
                      default: withCtx((scope) => [
                        createElementVNode("div", _hoisted_1, [
                          createVNode(unref(ElAvatar), {
                            src: scope.row.avatar,
                            size: 30
                          }, null, 8, ["src"]),
                          createElementVNode("span", _hoisted_2, toDisplayString(scope.row.user), 1)
                        ])
                      ]),
                      _: 1
                    }),
                    createVNode(unref(ElTableColumn), {
                      label: "æ€§åˆ«",
                      align: "center"
                    }, {
                      default: withCtx((scope) => [
                        createVNode(unref(ElTag), {
                          round: "",
                          effect: "dark",
                          style: { "border-style": "none" },
                          color: scope.row.gender === "man" ? "#9BC1FE" : "#FFBDEB"
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(scope.row.gender === "man" ? "å¯çˆ±ç”·å­©" : "æ¸©æŸ”å¥³å­©"), 1)
                          ]),
                          _: 2
                        }, 1032, ["color"])
                      ]),
                      _: 1
                    }),
                    createVNode(unref(ElTableColumn), {
                      label: "èº«ä»½",
                      align: "center"
                    }, {
                      default: withCtx((scope) => [
                        createVNode(unref(ElTag), {
                          effect: "dark",
                          round: "",
                          style: { "border-style": "none" },
                          type: scope.row.flag === "student" ? "success" : "warning"
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(scope.row.flag === "student" ? "å“ˆå·´å­¦ç”Ÿ" : "æ— æƒ…ç¤¾ç•œ"), 1)
                          ]),
                          _: 2
                        }, 1032, ["type"])
                      ]),
                      _: 1
                    }),
                    createVNode(unref(ElTableColumn), {
                      prop: "date",
                      label: "ä¸Šæ¬¡ç™»å½•"
                    }),
                    createVNode(unref(ElTableColumn), {
                      fixed: "right",
                      label: "æ“ä½œ"
                    }, {
                      default: withCtx((scope) => [
                        createVNode(unref(ElButton$1), {
                          link: "",
                          type: "primary",
                          size: "small",
                          disabled: ""
                        }, {
                          default: withCtx(() => _cache[3] || (_cache[3] = [
                            createTextVNode("å¯¼å‡º")
                          ])),
                          _: 1
                        }),
                        createVNode(unref(ElButton$1), {
                          link: "",
                          type: "primary",
                          size: "small",
                          onClick: () => del(scope.row)
                        }, {
                          default: withCtx(() => _cache[4] || (_cache[4] = [
                            createTextVNode(" åˆ é™¤ ")
                          ])),
                          _: 2
                        }, 1032, ["onClick"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["data"])
              ]),
              _: 1
            }, 8, ["modelValue"]);
          };
        }
      });
      const configProviderContextKey = Symbol();
      const defaultNamespace = exports("a0", "el");
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = Symbol("namespaceContextKey");
      const useGetDerivedNamespace = exports("aw", (namespaceOverrides) => {
        const derivedNamespace = getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace);
        const namespace = computed(() => {
          return unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      });
      const useNamespace = exports("s", (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace();
        const b = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b,
          e,
          m,
          be,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      });
      /**
      * @vue/shared v3.5.13
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      const NOOP = exports("a1", () => {
      });
      const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
      const hasOwn = exports("R", (val, key) => hasOwnProperty$1.call(val, key));
      const isArray$1 = exports("H", Array.isArray);
      const isFunction$2 = exports("ak", (val) => typeof val === "function");
      const isString$2 = exports("M", (val) => typeof val === "string");
      const isObject$1 = exports("al", (val) => val !== null && typeof val === "object");
      const cacheStringFunction = (fn) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction(
        (str) => {
          return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
        }
      );
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      function isNil(value) {
        return value == null;
      }
      const isUndefined$1 = exports("N", (val) => val === void 0);
      const isBoolean$1 = exports("P", (val) => typeof val === "boolean");
      const isNumber$1 = exports("v", (val) => typeof val === "number");
      const isElement = exports("as", (e) => {
        if (typeof Element === "undefined")
          return false;
        return e instanceof Element;
      });
      const isPropAbsent = exports("ae", (prop) => isNil(prop));
      const isStringNumber = (val) => {
        if (!isString$2(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      var __defProp$9 = Object.defineProperty;
      var __defProps$6 = Object.defineProperties;
      var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
      var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
      var __hasOwnProp$b = Object.prototype.hasOwnProperty;
      var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
      var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues$9 = (a, b) => {
        for (var prop in b || (b = {}))
          if (__hasOwnProp$b.call(b, prop))
            __defNormalProp$9(a, prop, b[prop]);
        if (__getOwnPropSymbols$b)
          for (var prop of __getOwnPropSymbols$b(b)) {
            if (__propIsEnum$b.call(b, prop))
              __defNormalProp$9(a, prop, b[prop]);
          }
        return a;
      };
      var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
      function computedEager(fn, options) {
        var _a2;
        const result = shallowRef();
        watchEffect(() => {
          result.value = fn();
        }, __spreadProps$6(__spreadValues$9({}, options), {
          flush: (_a2 = void 0) != null ? _a2 : "sync"
        }));
        return readonly(result);
      }
      var _a;
      const isClient = exports("a4", typeof window !== "undefined");
      const isFunction$1 = (val) => typeof val === "function";
      const isString$1 = exports("am", (val) => typeof val === "string");
      const noop$1 = exports("an", () => {
      });
      const isIOS = exports("ay", isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent));
      function resolveUnref(r) {
        return typeof r === "function" ? r() : unref(r);
      }
      function createFilterWrapper(filter2, fn) {
        function wrapper(...args) {
          return new Promise((resolve, reject) => {
            Promise.resolve(filter2(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
          });
        }
        return wrapper;
      }
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop$1;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop$1;
        };
        const filter2 = (invoke) => {
          const duration = resolveUnref(ms);
          const maxDuration = resolveUnref(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke());
          }
          return new Promise((resolve, reject) => {
            lastRejector = options.rejectOnCancel ? reject : resolve;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve(invoke());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve(invoke());
            }, duration);
          });
        };
        return filter2;
      }
      function identity(arg) {
        return arg;
      }
      function computedWithControl(source, fn) {
        let v = void 0;
        let track;
        let trigger;
        const dirty = ref(true);
        const update = () => {
          dirty.value = true;
          trigger();
        };
        watch(source, update, { flush: "sync" });
        const get2 = isFunction$1(fn) ? fn : fn.get;
        const set = isFunction$1(fn) ? void 0 : fn.set;
        const result = customRef((_track, _trigger) => {
          track = _track;
          trigger = _trigger;
          return {
            get() {
              if (dirty.value) {
                v = get2();
                dirty.value = false;
              }
              track();
              return v;
            },
            set(v2) {
              set == null ? void 0 : set(v2);
            }
          };
        });
        if (Object.isExtensible(result))
          result.trigger = update;
        return result;
      }
      function tryOnScopeDispose(fn) {
        if (getCurrentScope()) {
          onScopeDispose(fn);
          return true;
        }
        return false;
      }
      function useDebounceFn(fn, ms = 200, options = {}) {
        return createFilterWrapper(debounceFilter(ms, options), fn);
      }
      function refDebounced(value, ms = 200, options = {}) {
        const debounced = ref(value.value);
        const updater = useDebounceFn(() => {
          debounced.value = value.value;
        }, ms, options);
        watch(value, () => updater());
        return debounced;
      }
      function tryOnMounted(fn, sync = true) {
        if (getCurrentInstance())
          onMounted(fn);
        else if (sync)
          fn();
        else
          nextTick(fn);
      }
      function useTimeoutFn(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear();
        }
        function start2(...args) {
          clear();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, resolveUnref(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient)
            start2();
        }
        tryOnScopeDispose(stop);
        return {
          isPending: readonly(isPending),
          start: start2,
          stop
        };
      }
      const epPropKey = "__epPropKey";
      const definePropType = exports("I", (val) => val);
      const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
      const buildProp = exports("av", (prop, key) => {
        if (!isObject$1(prop) || isEpProp(prop))
          return prop;
        const { values, required, default: defaultValue, type, validator: validator2 } = prop;
        const _validator = values || validator2 ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values) {
            allowedValues = Array.from(values);
            if (hasOwn(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator2)
            valid || (valid = validator2(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type,
          required: !!required,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      });
      const buildProps = exports("r", (props) => fromPairs(Object.entries(props).map(([key, option]) => [
        key,
        buildProp(option, key)
      ])));
      const componentSizes = exports("J", ["", "default", "small", "large"]);
      const useSizeProp = exports("S", buildProp({
        type: String,
        values: componentSizes,
        required: false
      }));
      const SIZE_INJECTION_KEY = Symbol("size");
      const useGlobalSize = () => {
        const injectedSize = inject(SIZE_INJECTION_KEY, {});
        return computed(() => {
          return unref(injectedSize.size) || "";
        });
      };
      const globalConfig = ref();
      function useGlobalConfig(key, defaultValue = void 0) {
        const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
        if (key) {
          return computed(() => {
            var _a2, _b;
            return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
          });
        } else {
          return config;
        }
      }
      var _export_sfc = exports("c", (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      });
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = exports("af", (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      });
      const addClass = exports("a2", (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      });
      const removeClass = exports("a3", (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      });
      const getStyle = exports("ag", (element, styleName) => {
        var _a2;
        if (!isClient || !element || false)
          return "";
        let key = camelize(styleName);
        if (key === "float")
          key = "cssFloat";
        try {
          const style = element.style[key];
          if (style)
            return style;
          const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
          return computed2 ? computed2[key] : "";
        } catch (e) {
          return element.style[key];
        }
      });
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber$1(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString$2(value)) {
          return value;
        }
      }
      const withInstall = exports("w", (main2, extra) => {
        main2.install = (app) => {
          for (const comp of [main2, ...Object.values(extra != null ? extra : {})]) {
            app.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main2[key] = comp;
          }
        }
        return main2;
      });
      const withNoopInstall = exports("o", (component) => {
        component.install = NOOP;
        return component;
      });
      const iconProps = buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      });
      const __default__$2 = defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: iconProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("icon");
          const style = computed(() => {
            const { size, color } = props;
            if (!size && !color)
              return {};
            return {
              fontSize: isUndefined$1(size) ? void 0 : addUnit(size),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("i", mergeProps({
              class: unref(ns).b(),
              style: unref(style)
            }, _ctx.$attrs), [
              renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__file", "icon.vue"]]);
      const ElIcon = exports("E", withInstall(Icon));
      /*! Element Plus Icons Vue v2.3.1 */
      var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowDown",
        __name: "arrow-down",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
            })
          ]));
        }
      });
      var arrow_down_default = exports("ad", arrow_down_vue_vue_type_script_setup_true_lang_default);
      var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowRight",
        __name: "arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_right_default = exports("aj", arrow_right_vue_vue_type_script_setup_true_lang_default);
      var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowUp",
        __name: "arrow-up",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
            })
          ]));
        }
      });
      var arrow_up_default = exports("at", arrow_up_vue_vue_type_script_setup_true_lang_default);
      var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCheck",
        __name: "circle-check",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
            })
          ]));
        }
      });
      var circle_check_default = circle_check_vue_vue_type_script_setup_true_lang_default;
      var circle_close_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCloseFilled",
        __name: "circle-close-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
            })
          ]));
        }
      });
      var circle_close_filled_default = circle_close_filled_vue_vue_type_script_setup_true_lang_default;
      var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleClose",
        __name: "circle-close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      });
      var circle_close_default = exports("ac", circle_close_vue_vue_type_script_setup_true_lang_default);
      var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Close",
        __name: "close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
            })
          ]));
        }
      });
      var close_default = exports("z", close_vue_vue_type_script_setup_true_lang_default);
      var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Hide",
        __name: "hide",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
            })
          ]));
        }
      });
      var hide_default = exports("aa", hide_vue_vue_type_script_setup_true_lang_default);
      var info_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "InfoFilled",
        __name: "info-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
            })
          ]));
        }
      });
      var info_filled_default = info_filled_vue_vue_type_script_setup_true_lang_default;
      var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Loading",
        __name: "loading",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
            })
          ]));
        }
      });
      var loading_default = exports("aB", loading_vue_vue_type_script_setup_true_lang_default);
      var minus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Minus",
        __name: "minus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
            })
          ]));
        }
      });
      var minus_default = exports("az", minus_vue_vue_type_script_setup_true_lang_default);
      var plus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Plus",
        __name: "plus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
            })
          ]));
        }
      });
      var plus_default = exports("aA", plus_vue_vue_type_script_setup_true_lang_default);
      var success_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "SuccessFilled",
        __name: "success-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
            })
          ]));
        }
      });
      var success_filled_default = success_filled_vue_vue_type_script_setup_true_lang_default;
      var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "View",
        __name: "view",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
            })
          ]));
        }
      });
      var view_default = exports("a9", view_vue_vue_type_script_setup_true_lang_default);
      var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "WarningFilled",
        __name: "warning-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
            })
          ]));
        }
      });
      var warning_filled_default = warning_filled_vue_vue_type_script_setup_true_lang_default;
      const iconPropType = exports("O", definePropType([
        String,
        Object,
        Function
      ]));
      const CloseComponents = exports("ai", {
        Close: close_default
      });
      const TypeComponents = exports("D", {
        Close: close_default
      });
      const TypeComponentsMap = exports("T", {
        success: success_filled_default,
        warning: warning_filled_default,
        error: circle_close_filled_default,
        info: info_filled_default
      });
      const ValidateComponentsMap = exports("a8", {
        validating: loading_default,
        success: circle_check_default,
        error: circle_close_default
      });
      const formContextKey = exports("X", Symbol("formContextKey"));
      const formItemContextKey = exports("Y", Symbol("formItemContextKey"));
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = Symbol("elIdInjection");
      const useIdInjection = exports("ax", () => {
        return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      });
      const useId = exports("U", (deterministicId) => {
        const idInjection = useIdInjection();
        const namespace = useGetDerivedNamespace();
        const idRef = computedEager(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      });
      const useFormItem = exports("V", () => {
        const form = inject(formContextKey, void 0);
        const formItem = inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      });
      const useFormItemInputId = exports("W", (props, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = ref(false);
        }
        const inputId = ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = computed(() => {
          var _a2;
          return !!(!(props.label || props.ariaLabel) && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
        });
        onMounted(() => {
          idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
            const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      });
      const useProp = (name) => {
        const vm = getCurrentInstance();
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
        });
      };
      const useFormSize = exports("y", (fallback, ignore = {}) => {
        const emptyRef = ref(void 0);
        const size = ignore.prop ? emptyRef : useProp("size");
        const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
        return computed(() => size.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
      });
      const useFormDisabled = exports("a7", (fallback) => {
        const disabled = useProp("disabled");
        const form = inject(formContextKey, void 0);
        return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      });
      const buttonGroupContextKey = Symbol("buttonGroupContextKey");
      const useDeprecated = exports("Q", ({ from, replacement, scope, version, ref: ref2, type = "API" }, condition) => {
        watch(() => unref(condition), (val) => {
        }, {
          immediate: true
        });
      });
      const useButton = (props, emit) => {
        useDeprecated({
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, computed(() => props.type === "text"));
        const buttonGroupContext = inject(buttonGroupContextKey, void 0);
        const globalConfig2 = useGlobalConfig("button");
        const { form } = useFormItem();
        const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
        const _disabled = useFormDisabled();
        const _ref = ref();
        const slots = useSlots();
        const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
        const autoInsertSpace = computed(() => {
          var _a2, _b, _c;
          return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
        });
        const _props = computed(() => {
          if (props.tag === "button") {
            return {
              ariaDisabled: _disabled.value || props.loading,
              disabled: _disabled.value || props.loading,
              autofocus: props.autofocus,
              type: props.nativeType
            };
          }
          return {};
        });
        const shouldAddSpace = computed(() => {
          var _a2;
          const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
            const slot = defaultSlot[0];
            if ((slot == null ? void 0 : slot.type) === Text) {
              const text = slot.children;
              return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(text.trim());
            }
          }
          return false;
        });
        const handleClick = (evt) => {
          if (_disabled.value || props.loading) {
            evt.stopPropagation();
            return;
          }
          if (props.nativeType === "reset") {
            form == null ? void 0 : form.resetFields();
          }
          emit("click", evt);
        };
        return {
          _disabled,
          _size,
          _type,
          _ref,
          _props,
          shouldAddSpace,
          handleClick
        };
      };
      const buttonTypes = [
        "default",
        "primary",
        "success",
        "warning",
        "info",
        "danger",
        "text",
        ""
      ];
      const buttonNativeTypes = ["button", "submit", "reset"];
      const buttonProps = buildProps({
        size: useSizeProp,
        disabled: Boolean,
        type: {
          type: String,
          values: buttonTypes,
          default: ""
        },
        icon: {
          type: iconPropType
        },
        nativeType: {
          type: String,
          values: buttonNativeTypes,
          default: "button"
        },
        loading: Boolean,
        loadingIcon: {
          type: iconPropType,
          default: () => loading_default
        },
        plain: Boolean,
        text: Boolean,
        link: Boolean,
        bg: Boolean,
        autofocus: Boolean,
        round: Boolean,
        circle: Boolean,
        color: String,
        dark: Boolean,
        autoInsertSpace: {
          type: Boolean,
          default: void 0
        },
        tag: {
          type: definePropType([String, Object]),
          default: "button"
        }
      });
      const buttonEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      function bound01(n, max) {
        if (isOnePointZero(n)) {
          n = "100%";
        }
        var isPercent = isPercentage(n);
        n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
        if (isPercent) {
          n = parseInt(String(n * max), 10) / 100;
        }
        if (Math.abs(n - max) < 1e-6) {
          return 1;
        }
        if (max === 360) {
          n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
        } else {
          n = n % max / parseFloat(String(max));
        }
        return n;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero(n) {
        return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n === "string" && n.indexOf("%") !== -1;
      }
      function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
        }
        return a;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          return "".concat(Number(n) * 100, "%");
        }
        return n;
      }
      function pad2(c) {
        return c.length === 1 ? "0" + c : String(c);
      }
      function rgbToRgb(r, g, b) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b, 255) * 255
        };
      }
      function rgbToHsl(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h = 0;
        var s = 0;
        var l = (max + min) / 2;
        if (max === min) {
          s = 0;
          h = 0;
        } else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return { h, s, l };
      }
      function hue2rgb(p, q, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q - p) * (6 * t);
        }
        if (t < 1 / 2) {
          return q;
        }
        if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
      }
      function hslToRgb(h, s, l) {
        var r;
        var g;
        var b;
        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);
        if (s === 0) {
          g = l;
          b = l;
          r = l;
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHsv(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h = 0;
        var v = max;
        var d = max - min;
        var s = max === 0 ? 0 : d / max;
        if (max === min) {
          h = 0;
        } else {
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return { h, s, v };
      }
      function hsvToRgb(h, s, v) {
        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);
        var i = Math.floor(h);
        var f = h - i;
        var p = v * (1 - s);
        var q = v * (1 - f * s);
        var t = v * (1 - (1 - f) * s);
        var mod = i % 6;
        var r = [v, q, p, p, t, v][mod];
        var g = [t, v, v, q, p, p][mod];
        var b = [p, p, t, v, v, q][mod];
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHex(r, g, b, allow3Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r, g, b, a, allow4Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b).toString(16)),
          pad2(convertDecimalToHex(a))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
      }
      function convertHexToDecimal(h) {
        return parseIntFromHex(h) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a = color.a;
          }
        }
        a = boundAlpha(a);
        return {
          ok,
          format: color.format || format,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match = matchers.rgb.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        match = matchers.rgba.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        match = matchers.hsl.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        match = matchers.hsla.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        match = matchers.hsv.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        match = matchers.hsva.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        match = matchers.hex8.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex6.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        match = matchers.hex4.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            a: convertHexToDecimal(match[4] + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex3.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = (
        /** @class */
        function() {
          function TinyColor2(color, opts) {
            if (color === void 0) {
              color = "";
            }
            if (opts === void 0) {
              opts = {};
            }
            var _a2;
            if (color instanceof TinyColor2) {
              return color;
            }
            if (typeof color === "number") {
              color = numberInputToObject(color);
            }
            this.originalInput = color;
            var rgb = inputToRGB(color);
            this.originalInput = color;
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
            this.a = rgb.a;
            this.roundA = Math.round(100 * this.a) / 100;
            this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
            this.gradientType = opts.gradientType;
            if (this.r < 1) {
              this.r = Math.round(this.r);
            }
            if (this.g < 1) {
              this.g = Math.round(this.g);
            }
            if (this.b < 1) {
              this.b = Math.round(this.b);
            }
            this.isValid = rgb.ok;
          }
          TinyColor2.prototype.isDark = function() {
            return this.getBrightness() < 128;
          };
          TinyColor2.prototype.isLight = function() {
            return !this.isDark();
          };
          TinyColor2.prototype.getBrightness = function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          };
          TinyColor2.prototype.getLuminance = function() {
            var rgb = this.toRgb();
            var R;
            var G;
            var B;
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R = RsRGB / 12.92;
            } else {
              R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G = GsRGB / 12.92;
            } else {
              G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B = BsRGB / 12.92;
            } else {
              B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R + 0.7152 * G + 0.0722 * B;
          };
          TinyColor2.prototype.getAlpha = function() {
            return this.a;
          };
          TinyColor2.prototype.setAlpha = function(alpha) {
            this.a = boundAlpha(alpha);
            this.roundA = Math.round(100 * this.a) / 100;
            return this;
          };
          TinyColor2.prototype.isMonochrome = function() {
            var s = this.toHsl().s;
            return s === 0;
          };
          TinyColor2.prototype.toHsv = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
          };
          TinyColor2.prototype.toHsvString = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            var h = Math.round(hsv.h * 360);
            var s = Math.round(hsv.s * 100);
            var v = Math.round(hsv.v * 100);
            return this.a === 1 ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHsl = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
          };
          TinyColor2.prototype.toHslString = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            var h = Math.round(hsl.h * 360);
            var s = Math.round(hsl.s * 100);
            var l = Math.round(hsl.l * 100);
            return this.a === 1 ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHex = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return rgbToHex(this.r, this.g, this.b, allow3Char);
          };
          TinyColor2.prototype.toHexString = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return "#" + this.toHex(allow3Char);
          };
          TinyColor2.prototype.toHex8 = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
          };
          TinyColor2.prototype.toHex8String = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return "#" + this.toHex8(allow4Char);
          };
          TinyColor2.prototype.toHexShortString = function(allowShortChar) {
            if (allowShortChar === void 0) {
              allowShortChar = false;
            }
            return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
          };
          TinyColor2.prototype.toRgb = function() {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toRgbString = function() {
            var r = Math.round(this.r);
            var g = Math.round(this.g);
            var b = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toPercentageRgb = function() {
            var fmt = function(x) {
              return "".concat(Math.round(bound01(x, 255) * 100), "%");
            };
            return {
              r: fmt(this.r),
              g: fmt(this.g),
              b: fmt(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toPercentageRgbString = function() {
            var rnd = function(x) {
              return Math.round(bound01(x, 255) * 100);
            };
            return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toName = function() {
            if (this.a === 0) {
              return "transparent";
            }
            if (this.a < 1) {
              return false;
            }
            var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
            for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
              var _b = _a2[_i], key = _b[0], value = _b[1];
              if (hex === value) {
                return key;
              }
            }
            return false;
          };
          TinyColor2.prototype.toString = function(format) {
            var formatSet = Boolean(format);
            format = format !== null && format !== void 0 ? format : this.format;
            var formattedString = false;
            var hasAlpha = this.a < 1 && this.a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
            if (needsAlphaFormat) {
              if (format === "name" && this.a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
            }
            if (format === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format === "name") {
              formattedString = this.toName();
            }
            if (format === "hsl") {
              formattedString = this.toHslString();
            }
            if (format === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          };
          TinyColor2.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          };
          TinyColor2.prototype.clone = function() {
            return new TinyColor2(this.toString());
          };
          TinyColor2.prototype.lighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.brighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var rgb = this.toRgb();
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
            return new TinyColor2(rgb);
          };
          TinyColor2.prototype.darken = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.tint = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("white", amount);
          };
          TinyColor2.prototype.shade = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("black", amount);
          };
          TinyColor2.prototype.desaturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.saturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.greyscale = function() {
            return this.desaturate(100);
          };
          TinyColor2.prototype.spin = function(amount) {
            var hsl = this.toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.mix = function(color, amount) {
            if (amount === void 0) {
              amount = 50;
            }
            var rgb1 = this.toRgb();
            var rgb2 = new TinyColor2(color).toRgb();
            var p = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p + rgb1.r,
              g: (rgb2.g - rgb1.g) * p + rgb1.g,
              b: (rgb2.b - rgb1.b) * p + rgb1.b,
              a: (rgb2.a - rgb1.a) * p + rgb1.a
            };
            return new TinyColor2(rgba);
          };
          TinyColor2.prototype.analogous = function(results, slices) {
            if (results === void 0) {
              results = 6;
            }
            if (slices === void 0) {
              slices = 30;
            }
            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(new TinyColor2(hsl));
            }
            return ret;
          };
          TinyColor2.prototype.complement = function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.monochromatic = function(results) {
            if (results === void 0) {
              results = 6;
            }
            var hsv = this.toHsv();
            var h = hsv.h;
            var s = hsv.s;
            var v = hsv.v;
            var res = [];
            var modification = 1 / results;
            while (results--) {
              res.push(new TinyColor2({ h, s, v }));
              v = (v + modification) % 1;
            }
            return res;
          };
          TinyColor2.prototype.splitcomplement = function() {
            var hsl = this.toHsl();
            var h = hsl.h;
            return [
              this,
              new TinyColor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
              new TinyColor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          };
          TinyColor2.prototype.onBackground = function(background) {
            var fg = this.toRgb();
            var bg = new TinyColor2(background).toRgb();
            var alpha = fg.a + bg.a * (1 - fg.a);
            return new TinyColor2({
              r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
              g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
              b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
              a: alpha
            });
          };
          TinyColor2.prototype.triad = function() {
            return this.polyad(3);
          };
          TinyColor2.prototype.tetrad = function() {
            return this.polyad(4);
          };
          TinyColor2.prototype.polyad = function(n) {
            var hsl = this.toHsl();
            var h = hsl.h;
            var result = [this];
            var increment = 360 / n;
            for (var i = 1; i < n; i++) {
              result.push(new TinyColor2({ h: (h + i * increment) % 360, s: hsl.s, l: hsl.l }));
            }
            return result;
          };
          TinyColor2.prototype.equals = function(color) {
            return this.toRgbString() === new TinyColor2(color).toRgbString();
          };
          return TinyColor2;
        }()
      );
      function darken(color, amount = 20) {
        return color.mix("#141414", amount).toString();
      }
      function useButtonCustomStyle(props) {
        const _disabled = useFormDisabled();
        const ns = useNamespace("button");
        return computed(() => {
          let styles = {};
          let buttonColor = props.color;
          if (buttonColor) {
            const match = buttonColor.match(/var\((.*?)\)/);
            if (match) {
              buttonColor = window.getComputedStyle(window.document.documentElement).getPropertyValue(match[1]);
            }
            const color = new TinyColor(buttonColor);
            const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
            if (props.plain) {
              styles = ns.cssVarBlock({
                "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
                "text-color": buttonColor,
                "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
                "hover-text-color": `var(${ns.cssVarName("color-white")})`,
                "hover-bg-color": buttonColor,
                "hover-border-color": buttonColor,
                "active-bg-color": activeBgColor,
                "active-text-color": `var(${ns.cssVarName("color-white")})`,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
              }
            } else {
              const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
              const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
              styles = ns.cssVarBlock({
                "bg-color": buttonColor,
                "text-color": textColor,
                "border-color": buttonColor,
                "hover-bg-color": hoverBgColor,
                "hover-text-color": textColor,
                "hover-border-color": hoverBgColor,
                "active-bg-color": activeBgColor,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
                styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
              }
            }
          }
          return styles;
        });
      }
      const __default__$1 = defineComponent({
        name: "ElButton"
      });
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: buttonProps,
        emits: buttonEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const buttonStyle = useButtonCustomStyle(props);
          const ns = useNamespace("button");
          const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit);
          const buttonKls = computed(() => [
            ns.b(),
            ns.m(_type.value),
            ns.m(_size.value),
            ns.is("disabled", _disabled.value),
            ns.is("loading", props.loading),
            ns.is("plain", props.plain),
            ns.is("round", props.round),
            ns.is("circle", props.circle),
            ns.is("text", props.text),
            ns.is("link", props.link),
            ns.is("has-bg", props.bg)
          ]);
          expose({
            ref: _ref,
            size: _size,
            type: _type,
            disabled: _disabled,
            shouldAddSpace
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
              ref_key: "_ref",
              ref: _ref
            }, unref(_props), {
              class: unref(buttonKls),
              style: unref(buttonStyle),
              onClick: unref(handleClick)
            }), {
              default: withCtx(() => [
                _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"]))
                ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                  ]),
                  _: 3
                })) : createCommentVNode("v-if", true),
                _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                  key: 2,
                  class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["class", "style", "onClick"]);
          };
        }
      });
      var Button = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__file", "button.vue"]]);
      const buttonGroupProps = {
        size: buttonProps.size,
        type: buttonProps.type
      };
      const __default__ = defineComponent({
        name: "ElButtonGroup"
      });
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: buttonGroupProps,
        setup(__props) {
          const props = __props;
          provide(buttonGroupContextKey, reactive({
            size: toRef(props, "size"),
            type: toRef(props, "type")
          }));
          const ns = useNamespace("button");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b("group"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__file", "button-group.vue"]]);
      const ElButton = exports("p", withInstall(Button, {
        ButtonGroup
      }));
      withNoopInstall(ButtonGroup);
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        __name: "log",
        props: {
          "modelValue": { type: Boolean, ...{ required: true } },
          "modelModifiers": {}
        },
        emits: ["update:modelValue"],
        setup(__props) {
          const show = useModel(__props, "modelValue");
          return (_ctx, _cache) => {
            const _component_el_button = ElButton;
            return openBlock(), createBlock(unref(ElDialog), {
              modelValue: show.value,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => show.value = $event),
              title: "æ—¥å¿—æŸ¥çœ‹",
              width: "500",
              "align-center": "",
              "destroy-on-close": "",
              "z-index": 20
            }, {
              footer: withCtx(() => [
                createElementVNode("div", null, [
                  createVNode(_component_el_button, {
                    onClick: _cache[0] || (_cache[0] = ($event) => show.value = false)
                  }, {
                    default: withCtx(() => _cache[3] || (_cache[3] = [
                      createTextVNode("Cancel")
                    ])),
                    _: 1
                  }),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: _cache[1] || (_cache[1] = ($event) => show.value = false)
                  }, {
                    default: withCtx(() => _cache[4] || (_cache[4] = [
                      createTextVNode("Confirm")
                    ])),
                    _: 1
                  })
                ])
              ]),
              default: withCtx(() => [
                _cache[5] || (_cache[5] = createElementVNode("span", null, "Log", -1))
              ]),
              _: 1
            }, 8, ["modelValue"]);
          };
        }
      });
      const _sfc_main = /* @__PURE__ */ defineComponent({
        __name: "App",
        setup(__props) {
          logger.info("BoosHelperæŒ‚è½½æˆåŠŸ");
          ElMessage("BoosHelperæŒ‚è½½æˆåŠŸ!");
          const { storeInit: storeInit2 } = useStore();
          const confBox = ref(false);
          const confs = {
            store: { name: "å­˜å‚¨é…ç½®", component: _sfc_main$6, disabled: false },
            user: { name: "è´¦å·é…ç½®", component: _sfc_main$5, disabled: true },
            log: { name: "æ—¥å¿—é…ç½®", component: _sfc_main$1, disabled: false }
          };
          const confKey = ref("store");
          const dark = ref(_GM_getValue("theme-dark", false));
          function themeChange() {
            dark.value = !dark.value;
            if (dark.value) {
              ElMessage({
                message: "å·²åˆ‡æ¢åˆ°æš—é»‘æ¨¡å¼ï¼Œå¦‚æœ‰æ ·å¼æ²¡é€‚é…ä¸”ä¸¥é‡å½±å“ä½¿ç”¨ï¼Œè¯·åé¦ˆ",
                duration: 5e3,
                showClose: true
              });
            }
            document.documentElement.classList.toggle("dark", dark.value);
            _GM_setValue("theme-dark", dark.value);
          }
          onMounted(async () => {
            await storeInit2();
            const protocol = "boos-protocol";
            const protocol_val = "2025/02/21";
            const protocol_date = _GM_getValue(protocol);
            if (protocol_date !== protocol_val) {
              ElMessageBox.alert(
                `æœ¬é¡¹ç›®å®Œå…¨é‡æž„æˆæµè§ˆå™¨æ‰©å±•ï¼ŒåŽŸåŠŸèƒ½ä¸Žé¡µé¢ä¿æŒä¸å˜ä¸ºå‰æï¼Œè¿›è¡Œå¤§é‡çš„bugä¿®å¤å’Œé¡µé¢ä¼˜åŒ–
é¢„è®¡2025å¹´3æœˆåœ¨chromeï¼Œedgeç­‰æ‰©å±•å•†åº—ä¸Šæž¶ï¼Œå®Œå…¨å…è´¹ï¼Œæ¬¢è¿Žæ‰“èµæ”¯æŒä¸‹

æå‰å‚ä¸Žæµ‹è¯•ï¼š
é€‰æ‹©æœ€æ–°çš„ Pre-release ç‰ˆæœ¬
https://github.com/Ocyss/boos-helper/releases

1. é‡åˆ°bugå³æ—¶åé¦ˆï¼Œä¸ä¼šä½¿ç”¨è¯·åŠ ç¾¤ï¼Œä½¿ç”¨å‰å…ˆå¥½å¥½äº†è§£é¡¹ç›®ï¼Œé˜…è¯»æ¯ä¸€ä¸ªæ ‡ç­¾å’Œå¸®åŠ©
2. å¸®åŠ©å¤é€‰æ¡† èƒ½éšæ—¶è¿›å…¥å’Œé€€å‡ºå¸®åŠ©æ¨¡å¼, é…ç½®å†…å®¹è¾ƒå¤š, å¥½å¥½è§‚çœ‹
3. é…ç½®æœ€å‰é¢éœ€è¦æ‰“é’©å¯ç”¨ï¼Œå¯ç”¨åŽéœ€è¦ä¿å­˜é…ç½®
4. é…ç½®é¡¹ åŒ…å«/æŽ’é™¤ èƒ½ç‚¹å‡»åˆ‡æ¢æ¨¡å¼
5. ç¾¤å·²æ»¡ï¼Œæš‚ä¸åˆ›å»ºï¼Œè¯·å‹¿ç§åŠ å¼€å‘è€…ï¼Œæˆ‘çš„æ—¶é—´ä¹Ÿå¾ˆå®è´µ, è¯·åœ¨githubåé¦ˆï¼Œæˆ–è€…é£žä¹¦é—®å·

æœ¬é¡¹ç›®ä»…ä¾›å­¦ä¹ äº¤æµï¼Œç¦æ­¢ç”¨äºŽå•†ä¸šç”¨é€”
ä½¿ç”¨è¯¥è„šæœ¬æœ‰ä¸€å®šé£Žé™©(å¦‚é»‘å·,å°å·,æƒé‡é™ä½Žç­‰)ï¼Œæœ¬é¡¹ç›®ä¸æ‰¿æ‹…ä»»ä½•è´£ä»»
<img style="width: 200px; height: 200px;" src="https://qiu-config.oss-cn-beijing.aliyuncs.com/reward.png" style="object-fit: cover;"/>
Githubå¼€æºåœ°å€: <a href="https://github.com/ocyss/boos-helper" target="_blank">https://github.com/ocyss/boos-helper</a>
greasyforkåœ°å€: <a href="https://greasyfork.org/zh-CN/scripts/491340" target="_blank">https://greasyfork.org/zh-CN/scripts/491340</a>
é£žä¹¦åé¦ˆé—®å·(åŒ¿å): <a href="https://gai06vrtbc0.feishu.cn/share/base/form/shrcnmEq2fxH9hM44hqEnoeaj8g" target="_blank">https://gai06vrtbc0.feishu.cn/share/base/form/shrcnmEq2fxH9hM44hqEnoeaj8g</a>
é£žä¹¦é—®å·ç»“æžœ: <a href="https://gai06vrtbc0.feishu.cn/share/base/view/shrcnrg8D0cbLQc89d7Jj7AZgMc" target="_blank">https://gai06vrtbc0.feishu.cn/share/base/view/shrcnrg8D0cbLQc89d7Jj7AZgMc</a>
é£žä¹¦äº¤æµç¾¤: <a href="https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=410v5499-7193-411f-8258-94ae0cac4fc0" target="_blank">https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=410v5499-7193-411f-8258-94ae0cac4fc0</a>`,
                "æ³¨æ„äº‹é¡¹",
                {
                  autofocus: true,
                  confirmButtonText: "äº†è§£å¹¶åŒæ„!",
                  customStyle: "--el-messagebox-width: unset; white-space: pre-wrap; width: unset;",
                  callback: (action) => {
                    if (action === "confirm") {
                      _GM_setValue(protocol, protocol_val);
                    }
                  }
                }
              );
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(unref(ElDropdown), { trigger: "click" }, {
                dropdown: withCtx(() => [
                  createVNode(unref(ElDropdownMenu), null, {
                    default: withCtx(() => [
                      createVNode(unref(ElDropdownItem), { disabled: "" }, {
                        default: withCtx(() => _cache[2] || (_cache[2] = [
                          createTextVNode("BossHelpé…ç½®é¡¹")
                        ])),
                        _: 1
                      }),
                      createVNode(unref(ElDropdownItem), {
                        divided: "",
                        disabled: ""
                      }),
                      (openBlock(), createElementBlock(Fragment, null, renderList(confs, (v, k) => {
                        return createVNode(unref(ElDropdownItem), {
                          key: k,
                          onClick: ($event) => {
                            confKey.value = k;
                            confBox.value = true;
                          },
                          disabled: v.disabled
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(v.name), 1)
                          ]),
                          _: 2
                        }, 1032, ["onClick", "disabled"]);
                      }), 64)),
                      createVNode(unref(ElDropdownItem), { onClick: themeChange }, {
                        default: withCtx(() => [
                          createTextVNode(" æš—é»‘æ¨¡å¼ï¼ˆ" + toDisplayString(dark.value ? "å¼€" : "å…³") + "ï¼‰ ", 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createVNode(unref(ElAvatar), {
                    size: 30,
                    src: "https://avatars.githubusercontent.com/u/68412205?v=4"
                  }, {
                    default: withCtx(() => _cache[1] || (_cache[1] = [
                      createTextVNode(" H ")
                    ])),
                    _: 1
                  })
                ]),
                _: 1
              }),
              (openBlock(), createBlock(Teleport, { to: "body" }, [
                (openBlock(), createBlock(resolveDynamicComponent(confs[confKey.value].component), {
                  modelValue: confBox.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => confBox.value = $event)
                }, null, 8, ["modelValue"]))
              ]))
            ], 64);
          };
        }
      });
      function bind(fn, thisArg) {
        return function wrap() {
          return fn.apply(thisArg, arguments);
        };
      }
      const { toString } = Object.prototype;
      const { getPrototypeOf } = Object;
      const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
        const str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
      })(/* @__PURE__ */ Object.create(null));
      const kindOfTest = (type) => {
        type = type.toLowerCase();
        return (thing) => kindOf(thing) === type;
      };
      const typeOfTest = (type) => (thing) => typeof thing === type;
      const { isArray } = Array;
      const isUndefined = typeOfTest("undefined");
      function isBuffer(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
      }
      const isArrayBuffer = kindOfTest("ArrayBuffer");
      function isArrayBufferView(val) {
        let result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && isArrayBuffer(val.buffer);
        }
        return result;
      }
      const isString = typeOfTest("string");
      const isFunction = typeOfTest("function");
      const isNumber = typeOfTest("number");
      const isObject = (thing) => thing !== null && typeof thing === "object";
      const isBoolean = (thing) => thing === true || thing === false;
      const isPlainObject = (val) => {
        if (kindOf(val) !== "object") {
          return false;
        }
        const prototype2 = getPrototypeOf(val);
        return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
      };
      const isDate = kindOfTest("Date");
      const isFile = kindOfTest("File");
      const isBlob = kindOfTest("Blob");
      const isFileList = kindOfTest("FileList");
      const isStream = (val) => isObject(val) && isFunction(val.pipe);
      const isFormData = (thing) => {
        let kind;
        return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
        kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
      };
      const isURLSearchParams = kindOfTest("URLSearchParams");
      const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
      const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      function forEach(obj, fn, { allOwnKeys = false } = {}) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        let i;
        let l;
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray(obj)) {
          for (i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
          const len = keys.length;
          let key;
          for (i = 0; i < len; i++) {
            key = keys[i];
            fn.call(null, obj[key], key, obj);
          }
        }
      }
      function findKey(obj, key) {
        key = key.toLowerCase();
        const keys = Object.keys(obj);
        let i = keys.length;
        let _key;
        while (i-- > 0) {
          _key = keys[i];
          if (key === _key.toLowerCase()) {
            return _key;
          }
        }
        return null;
      }
      const _global = (() => {
        if (typeof globalThis !== "undefined") return globalThis;
        return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
      })();
      const isContextDefined = (context) => !isUndefined(context) && context !== _global;
      function merge() {
        const { caseless } = isContextDefined(this) && this || {};
        const result = {};
        const assignValue = (val, key) => {
          const targetKey = caseless && findKey(result, key) || key;
          if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
            result[targetKey] = merge(result[targetKey], val);
          } else if (isPlainObject(val)) {
            result[targetKey] = merge({}, val);
          } else if (isArray(val)) {
            result[targetKey] = val.slice();
          } else {
            result[targetKey] = val;
          }
        };
        for (let i = 0, l = arguments.length; i < l; i++) {
          arguments[i] && forEach(arguments[i], assignValue);
        }
        return result;
      }
      const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
        forEach(b, (val, key) => {
          if (thisArg && isFunction(val)) {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        }, { allOwnKeys });
        return a;
      };
      const stripBOM = (content) => {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      };
      const inherits = (constructor, superConstructor, props, descriptors2) => {
        constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
        constructor.prototype.constructor = constructor;
        Object.defineProperty(constructor, "super", {
          value: superConstructor.prototype
        });
        props && Object.assign(constructor.prototype, props);
      };
      const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
        let props;
        let i;
        let prop;
        const merged = {};
        destObj = destObj || {};
        if (sourceObj == null) return destObj;
        do {
          props = Object.getOwnPropertyNames(sourceObj);
          i = props.length;
          while (i-- > 0) {
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
              destObj[prop] = sourceObj[prop];
              merged[prop] = true;
            }
          }
          sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
        } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
        return destObj;
      };
      const endsWith = (str, searchString, position) => {
        str = String(str);
        if (position === void 0 || position > str.length) {
          position = str.length;
        }
        position -= searchString.length;
        const lastIndex = str.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      };
      const toArray = (thing) => {
        if (!thing) return null;
        if (isArray(thing)) return thing;
        let i = thing.length;
        if (!isNumber(i)) return null;
        const arr = new Array(i);
        while (i-- > 0) {
          arr[i] = thing[i];
        }
        return arr;
      };
      const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
        return (thing) => {
          return TypedArray && thing instanceof TypedArray;
        };
      })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
      const forEachEntry = (obj, fn) => {
        const generator = obj && obj[Symbol.iterator];
        const iterator = generator.call(obj);
        let result;
        while ((result = iterator.next()) && !result.done) {
          const pair = result.value;
          fn.call(obj, pair[0], pair[1]);
        }
      };
      const matchAll = (regExp, str) => {
        let matches2;
        const arr = [];
        while ((matches2 = regExp.exec(str)) !== null) {
          arr.push(matches2);
        }
        return arr;
      };
      const isHTMLForm = kindOfTest("HTMLFormElement");
      const toCamelCase = (str) => {
        return str.toLowerCase().replace(
          /[-_\s]([a-z\d])(\w*)/g,
          function replacer(m, p1, p2) {
            return p1.toUpperCase() + p2;
          }
        );
      };
      const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
      const isRegExp = kindOfTest("RegExp");
      const reduceDescriptors = (obj, reducer) => {
        const descriptors2 = Object.getOwnPropertyDescriptors(obj);
        const reducedDescriptors = {};
        forEach(descriptors2, (descriptor, name) => {
          let ret;
          if ((ret = reducer(descriptor, name, obj)) !== false) {
            reducedDescriptors[name] = ret || descriptor;
          }
        });
        Object.defineProperties(obj, reducedDescriptors);
      };
      const freezeMethods = (obj) => {
        reduceDescriptors(obj, (descriptor, name) => {
          if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
            return false;
          }
          const value = obj[name];
          if (!isFunction(value)) return;
          descriptor.enumerable = false;
          if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
          }
          if (!descriptor.set) {
            descriptor.set = () => {
              throw Error("Can not rewrite read-only method '" + name + "'");
            };
          }
        });
      };
      const toObjectSet = (arrayOrString, delimiter) => {
        const obj = {};
        const define = (arr) => {
          arr.forEach((value) => {
            obj[value] = true;
          });
        };
        isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
        return obj;
      };
      const noop = () => {
      };
      const toFiniteNumber = (value, defaultValue) => {
        return value != null && Number.isFinite(value = +value) ? value : defaultValue;
      };
      function isSpecCompliantForm(thing) {
        return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
      }
      const toJSONObject = (obj) => {
        const stack = new Array(10);
        const visit = (source, i) => {
          if (isObject(source)) {
            if (stack.indexOf(source) >= 0) {
              return;
            }
            if (!("toJSON" in source)) {
              stack[i] = source;
              const target = isArray(source) ? [] : {};
              forEach(source, (value, key) => {
                const reducedValue = visit(value, i + 1);
                !isUndefined(reducedValue) && (target[key] = reducedValue);
              });
              stack[i] = void 0;
              return target;
            }
          }
          return source;
        };
        return visit(obj, 0);
      };
      const isAsyncFn = kindOfTest("AsyncFunction");
      const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
      const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
        if (setImmediateSupported) {
          return setImmediate;
        }
        return postMessageSupported ? ((token, callbacks) => {
          _global.addEventListener("message", ({ source, data }) => {
            if (source === _global && data === token) {
              callbacks.length && callbacks.shift()();
            }
          }, false);
          return (cb) => {
            callbacks.push(cb);
            _global.postMessage(token, "*");
          };
        })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
      })(
        typeof setImmediate === "function",
        isFunction(_global.postMessage)
      );
      const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
      const utils$1 = {
        isArray,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber,
        isBoolean,
        isObject,
        isPlainObject,
        isReadableStream,
        isRequest,
        isResponse,
        isHeaders,
        isUndefined,
        isDate,
        isFile,
        isBlob,
        isRegExp,
        isFunction,
        isStream,
        isURLSearchParams,
        isTypedArray,
        isFileList,
        forEach,
        merge,
        extend,
        trim,
        stripBOM,
        inherits,
        toFlatObject,
        kindOf,
        kindOfTest,
        endsWith,
        toArray,
        forEachEntry,
        matchAll,
        isHTMLForm,
        hasOwnProperty,
        hasOwnProp: hasOwnProperty,
        // an alias to avoid ESLint no-prototype-builtins detection
        reduceDescriptors,
        freezeMethods,
        toObjectSet,
        toCamelCase,
        noop,
        toFiniteNumber,
        findKey,
        global: _global,
        isContextDefined,
        isSpecCompliantForm,
        toJSONObject,
        isAsyncFn,
        isThenable,
        setImmediate: _setImmediate,
        asap
      };
      function AxiosError$1(message, code, config, request, response) {
        Error.call(this);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error().stack;
        }
        this.message = message;
        this.name = "AxiosError";
        code && (this.code = code);
        config && (this.config = config);
        request && (this.request = request);
        if (response) {
          this.response = response;
          this.status = response.status ? response.status : null;
        }
      }
      utils$1.inherits(AxiosError$1, Error, {
        toJSON: function toJSON() {
          return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: utils$1.toJSONObject(this.config),
            code: this.code,
            status: this.status
          };
        }
      });
      const prototype$1 = AxiosError$1.prototype;
      const descriptors = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        "ERR_NOT_SUPPORT",
        "ERR_INVALID_URL"
        // eslint-disable-next-line func-names
      ].forEach((code) => {
        descriptors[code] = { value: code };
      });
      Object.defineProperties(AxiosError$1, descriptors);
      Object.defineProperty(prototype$1, "isAxiosError", { value: true });
      AxiosError$1.from = (error, code, config, request, response, customProps) => {
        const axiosError = Object.create(prototype$1);
        utils$1.toFlatObject(error, axiosError, function filter2(obj) {
          return obj !== Error.prototype;
        }, (prop) => {
          return prop !== "isAxiosError";
        });
        AxiosError$1.call(axiosError, error.message, code, config, request, response);
        axiosError.cause = error;
        axiosError.name = error.name;
        customProps && Object.assign(axiosError, customProps);
        return axiosError;
      };
      const httpAdapter = null;
      function isVisitable(thing) {
        return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
      }
      function removeBrackets(key) {
        return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
      }
      function renderKey(path, key, dots) {
        if (!path) return key;
        return path.concat(key).map(function each2(token, i) {
          token = removeBrackets(token);
          return !dots && i ? "[" + token + "]" : token;
        }).join(dots ? "." : "");
      }
      function isFlatArray(arr) {
        return utils$1.isArray(arr) && !arr.some(isVisitable);
      }
      const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
        return /^is[A-Z]/.test(prop);
      });
      function toFormData$1(obj, formData2, options) {
        if (!utils$1.isObject(obj)) {
          throw new TypeError("target must be an object");
        }
        formData2 = formData2 || new FormData();
        options = utils$1.toFlatObject(options, {
          metaTokens: true,
          dots: false,
          indexes: false
        }, false, function defined(option, source) {
          return !utils$1.isUndefined(source[option]);
        });
        const metaTokens = options.metaTokens;
        const visitor = options.visitor || defaultVisitor;
        const dots = options.dots;
        const indexes = options.indexes;
        const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
        const useBlob = _Blob && utils$1.isSpecCompliantForm(formData2);
        if (!utils$1.isFunction(visitor)) {
          throw new TypeError("visitor must be a function");
        }
        function convertValue(value) {
          if (value === null) return "";
          if (utils$1.isDate(value)) {
            return value.toISOString();
          }
          if (!useBlob && utils$1.isBlob(value)) {
            throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
          }
          if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
            return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
          }
          return value;
        }
        function defaultVisitor(value, key, path) {
          let arr = value;
          if (value && !path && typeof value === "object") {
            if (utils$1.endsWith(key, "{}")) {
              key = metaTokens ? key : key.slice(0, -2);
              value = JSON.stringify(value);
            } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
              key = removeBrackets(key);
              arr.forEach(function each2(el, index) {
                !(utils$1.isUndefined(el) || el === null) && formData2.append(
                  // eslint-disable-next-line no-nested-ternary
                  indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                  convertValue(el)
                );
              });
              return false;
            }
          }
          if (isVisitable(value)) {
            return true;
          }
          formData2.append(renderKey(path, key, dots), convertValue(value));
          return false;
        }
        const stack = [];
        const exposedHelpers = Object.assign(predicates, {
          defaultVisitor,
          convertValue,
          isVisitable
        });
        function build(value, path) {
          if (utils$1.isUndefined(value)) return;
          if (stack.indexOf(value) !== -1) {
            throw Error("Circular reference detected in " + path.join("."));
          }
          stack.push(value);
          utils$1.forEach(value, function each2(el, key) {
            const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
              formData2,
              el,
              utils$1.isString(key) ? key.trim() : key,
              path,
              exposedHelpers
            );
            if (result === true) {
              build(el, path ? path.concat(key) : [key]);
            }
          });
          stack.pop();
        }
        if (!utils$1.isObject(obj)) {
          throw new TypeError("data must be an object");
        }
        build(obj);
        return formData2;
      }
      function encode$1(str) {
        const charMap = {
          "!": "%21",
          "'": "%27",
          "(": "%28",
          ")": "%29",
          "~": "%7E",
          "%20": "+",
          "%00": "\0"
        };
        return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
          return charMap[match];
        });
      }
      function AxiosURLSearchParams(params, options) {
        this._pairs = [];
        params && toFormData$1(params, this, options);
      }
      const prototype = AxiosURLSearchParams.prototype;
      prototype.append = function append(name, value) {
        this._pairs.push([name, value]);
      };
      prototype.toString = function toString2(encoder) {
        const _encode = encoder ? function(value) {
          return encoder.call(this, value, encode$1);
        } : encode$1;
        return this._pairs.map(function each2(pair) {
          return _encode(pair[0]) + "=" + _encode(pair[1]);
        }, "").join("&");
      };
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      function buildURL(url, params, options) {
        if (!params) {
          return url;
        }
        const _encode = options && options.encode || encode;
        if (utils$1.isFunction(options)) {
          options = {
            serialize: options
          };
        }
        const serializeFn = options && options.serialize;
        let serializedParams;
        if (serializeFn) {
          serializedParams = serializeFn(params, options);
        } else {
          serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
        }
        if (serializedParams) {
          const hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      }
      class InterceptorManager {
        constructor() {
          this.handlers = [];
        }
        /**
         * Add a new interceptor to the stack
         *
         * @param {Function} fulfilled The function to handle `then` for a `Promise`
         * @param {Function} rejected The function to handle `reject` for a `Promise`
         *
         * @return {Number} An ID used to remove interceptor later
         */
        use(fulfilled, rejected, options) {
          this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
          });
          return this.handlers.length - 1;
        }
        /**
         * Remove an interceptor from the stack
         *
         * @param {Number} id The ID that was returned by `use`
         *
         * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
         */
        eject(id) {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        }
        /**
         * Clear all interceptors from the stack
         *
         * @returns {void}
         */
        clear() {
          if (this.handlers) {
            this.handlers = [];
          }
        }
        /**
         * Iterate over all the registered interceptors
         *
         * This method is particularly useful for skipping over any
         * interceptors that may have become `null` calling `eject`.
         *
         * @param {Function} fn The function to call for each interceptor
         *
         * @returns {void}
         */
        forEach(fn) {
          utils$1.forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) {
              fn(h);
            }
          });
        }
      }
      const transitionalDefaults = {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      };
      const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
      const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
      const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
      const platform$1 = {
        isBrowser: true,
        classes: {
          URLSearchParams: URLSearchParams$1,
          FormData: FormData$1,
          Blob: Blob$1
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
      };
      const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
      const _navigator = typeof navigator === "object" && navigator || void 0;
      const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
      const hasStandardBrowserWebWorkerEnv = (() => {
        return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
        self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
      })();
      const origin = hasBrowserEnv && window.location.href || "http://localhost";
      const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        hasBrowserEnv,
        hasStandardBrowserEnv,
        hasStandardBrowserWebWorkerEnv,
        navigator: _navigator,
        origin
      }, Symbol.toStringTag, { value: "Module" }));
      const platform = {
        ...utils,
        ...platform$1
      };
      function toURLEncodedForm(data, options) {
        return toFormData$1(data, new platform.classes.URLSearchParams(), Object.assign({
          visitor: function(value, key, path, helpers) {
            if (platform.isNode && utils$1.isBuffer(value)) {
              this.append(key, value.toString("base64"));
              return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
          }
        }, options));
      }
      function parsePropPath(name) {
        return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
          return match[0] === "[]" ? "" : match[1] || match[0];
        });
      }
      function arrayToObject(arr) {
        const obj = {};
        const keys = Object.keys(arr);
        let i;
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          obj[key] = arr[key];
        }
        return obj;
      }
      function formDataToJSON(formData2) {
        function buildPath(path, value, target, index) {
          let name = path[index++];
          if (name === "__proto__") return true;
          const isNumericKey = Number.isFinite(+name);
          const isLast = index >= path.length;
          name = !name && utils$1.isArray(target) ? target.length : name;
          if (isLast) {
            if (utils$1.hasOwnProp(target, name)) {
              target[name] = [target[name], value];
            } else {
              target[name] = value;
            }
            return !isNumericKey;
          }
          if (!target[name] || !utils$1.isObject(target[name])) {
            target[name] = [];
          }
          const result = buildPath(path, value, target[name], index);
          if (result && utils$1.isArray(target[name])) {
            target[name] = arrayToObject(target[name]);
          }
          return !isNumericKey;
        }
        if (utils$1.isFormData(formData2) && utils$1.isFunction(formData2.entries)) {
          const obj = {};
          utils$1.forEachEntry(formData2, (name, value) => {
            buildPath(parsePropPath(name), value, obj, 0);
          });
          return obj;
        }
        return null;
      }
      function stringifySafely(rawValue, parser, encoder) {
        if (utils$1.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils$1.trim(rawValue);
          } catch (e) {
            if (e.name !== "SyntaxError") {
              throw e;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      const defaults = {
        transitional: transitionalDefaults,
        adapter: ["xhr", "http", "fetch"],
        transformRequest: [function transformRequest(data, headers) {
          const contentType = headers.getContentType() || "";
          const hasJSONContentType = contentType.indexOf("application/json") > -1;
          const isObjectPayload = utils$1.isObject(data);
          if (isObjectPayload && utils$1.isHTMLForm(data)) {
            data = new FormData(data);
          }
          const isFormData2 = utils$1.isFormData(data);
          if (isFormData2) {
            return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
          }
          if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
            return data;
          }
          if (utils$1.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils$1.isURLSearchParams(data)) {
            headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
            return data.toString();
          }
          let isFileList2;
          if (isObjectPayload) {
            if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
              return toURLEncodedForm(data, this.formSerializer).toString();
            }
            if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
              const _FormData = this.env && this.env.FormData;
              return toFormData$1(
                isFileList2 ? { "files[]": data } : data,
                _FormData && new _FormData(),
                this.formSerializer
              );
            }
          }
          if (isObjectPayload || hasJSONContentType) {
            headers.setContentType("application/json", false);
            return stringifySafely(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          const transitional2 = this.transitional || defaults.transitional;
          const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
          const JSONRequested = this.responseType === "json";
          if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
            return data;
          }
          if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
            const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
            const strictJSONParsing = !silentJSONParsing && JSONRequested;
            try {
              return JSON.parse(data);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === "SyntaxError") {
                  throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
                }
                throw e;
              }
            }
          }
          return data;
        }],
        /**
         * A timeout in milliseconds to abort a request. If set to 0 (default) a
         * timeout is not created.
         */
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
          FormData: platform.classes.FormData,
          Blob: platform.classes.Blob
        },
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": void 0
          }
        }
      };
      utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
        defaults.headers[method] = {};
      });
      const ignoreDuplicateOf = utils$1.toObjectSet([
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ]);
      const parseHeaders = (rawHeaders) => {
        const parsed = {};
        let key;
        let val;
        let i;
        rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
          i = line.indexOf(":");
          key = line.substring(0, i).trim().toLowerCase();
          val = line.substring(i + 1).trim();
          if (!key || parsed[key] && ignoreDuplicateOf[key]) {
            return;
          }
          if (key === "set-cookie") {
            if (parsed[key]) {
              parsed[key].push(val);
            } else {
              parsed[key] = [val];
            }
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        });
        return parsed;
      };
      const $internals = Symbol("internals");
      function normalizeHeader(header) {
        return header && String(header).trim().toLowerCase();
      }
      function normalizeValue(value) {
        if (value === false || value == null) {
          return value;
        }
        return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
      }
      function parseTokens(str) {
        const tokens = /* @__PURE__ */ Object.create(null);
        const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
        let match;
        while (match = tokensRE.exec(str)) {
          tokens[match[1]] = match[2];
        }
        return tokens;
      }
      const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
      function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
        if (utils$1.isFunction(filter2)) {
          return filter2.call(this, value, header);
        }
        if (isHeaderNameFilter) {
          value = header;
        }
        if (!utils$1.isString(value)) return;
        if (utils$1.isString(filter2)) {
          return value.indexOf(filter2) !== -1;
        }
        if (utils$1.isRegExp(filter2)) {
          return filter2.test(value);
        }
      }
      function formatHeader(header) {
        return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
          return char.toUpperCase() + str;
        });
      }
      function buildAccessors(obj, header) {
        const accessorName = utils$1.toCamelCase(" " + header);
        ["get", "set", "has"].forEach((methodName) => {
          Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
              return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
          });
        });
      }
      let AxiosHeaders$1 = class AxiosHeaders {
        constructor(headers) {
          headers && this.set(headers);
        }
        set(header, valueOrRewrite, rewrite) {
          const self2 = this;
          function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) {
              throw new Error("header name must be a non-empty string");
            }
            const key = utils$1.findKey(self2, lHeader);
            if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
              self2[key || _header] = normalizeValue(_value);
            }
          }
          const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
          if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
            setHeaders(header, valueOrRewrite);
          } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
            setHeaders(parseHeaders(header), valueOrRewrite);
          } else if (utils$1.isHeaders(header)) {
            for (const [key, value] of header.entries()) {
              setHeader(value, key, rewrite);
            }
          } else {
            header != null && setHeader(valueOrRewrite, header, rewrite);
          }
          return this;
        }
        get(header, parser) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils$1.findKey(this, header);
            if (key) {
              const value = this[key];
              if (!parser) {
                return value;
              }
              if (parser === true) {
                return parseTokens(value);
              }
              if (utils$1.isFunction(parser)) {
                return parser.call(this, value, key);
              }
              if (utils$1.isRegExp(parser)) {
                return parser.exec(value);
              }
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(header, matcher) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils$1.findKey(this, header);
            return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
          }
          return false;
        }
        delete(header, matcher) {
          const self2 = this;
          let deleted = false;
          function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
              const key = utils$1.findKey(self2, _header);
              if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
                delete self2[key];
                deleted = true;
              }
            }
          }
          if (utils$1.isArray(header)) {
            header.forEach(deleteHeader);
          } else {
            deleteHeader(header);
          }
          return deleted;
        }
        clear(matcher) {
          const keys = Object.keys(this);
          let i = keys.length;
          let deleted = false;
          while (i--) {
            const key = keys[i];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
              delete this[key];
              deleted = true;
            }
          }
          return deleted;
        }
        normalize(format) {
          const self2 = this;
          const headers = {};
          utils$1.forEach(this, (value, header) => {
            const key = utils$1.findKey(headers, header);
            if (key) {
              self2[key] = normalizeValue(value);
              delete self2[header];
              return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) {
              delete self2[header];
            }
            self2[normalized] = normalizeValue(value);
            headers[normalized] = true;
          });
          return this;
        }
        concat(...targets) {
          return this.constructor.concat(this, ...targets);
        }
        toJSON(asStrings) {
          const obj = /* @__PURE__ */ Object.create(null);
          utils$1.forEach(this, (value, header) => {
            value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
          });
          return obj;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(thing) {
          return thing instanceof this ? thing : new this(thing);
        }
        static concat(first, ...targets) {
          const computed2 = new this(first);
          targets.forEach((target) => computed2.set(target));
          return computed2;
        }
        static accessor(header) {
          const internals = this[$internals] = this[$internals] = {
            accessors: {}
          };
          const accessors = internals.accessors;
          const prototype2 = this.prototype;
          function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
              buildAccessors(prototype2, _header);
              accessors[lHeader] = true;
            }
          }
          utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
          return this;
        }
      };
      AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
      utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
        let mapped = key[0].toUpperCase() + key.slice(1);
        return {
          get: () => value,
          set(headerValue) {
            this[mapped] = headerValue;
          }
        };
      });
      utils$1.freezeMethods(AxiosHeaders$1);
      function transformData(fns, response) {
        const config = this || defaults;
        const context = response || config;
        const headers = AxiosHeaders$1.from(context.headers);
        let data = context.data;
        utils$1.forEach(fns, function transform(fn) {
          data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
        });
        headers.normalize();
        return data;
      }
      function isCancel$1(value) {
        return !!(value && value.__CANCEL__);
      }
      function CanceledError$1(message, config, request) {
        AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
        this.name = "CanceledError";
      }
      utils$1.inherits(CanceledError$1, AxiosError$1, {
        __CANCEL__: true
      });
      function settle(resolve, reject, response) {
        const validateStatus2 = response.config.validateStatus;
        if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
          resolve(response);
        } else {
          reject(new AxiosError$1(
            "Request failed with status code " + response.status,
            [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
            response.config,
            response.request,
            response
          ));
        }
      }
      function parseProtocol(url) {
        const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
        return match && match[1] || "";
      }
      function speedometer(samplesCount, min) {
        samplesCount = samplesCount || 10;
        const bytes = new Array(samplesCount);
        const timestamps = new Array(samplesCount);
        let head = 0;
        let tail = 0;
        let firstSampleTS;
        min = min !== void 0 ? min : 1e3;
        return function push(chunkLength) {
          const now = Date.now();
          const startedAt = timestamps[tail];
          if (!firstSampleTS) {
            firstSampleTS = now;
          }
          bytes[head] = chunkLength;
          timestamps[head] = now;
          let i = tail;
          let bytesCount = 0;
          while (i !== head) {
            bytesCount += bytes[i++];
            i = i % samplesCount;
          }
          head = (head + 1) % samplesCount;
          if (head === tail) {
            tail = (tail + 1) % samplesCount;
          }
          if (now - firstSampleTS < min) {
            return;
          }
          const passed = startedAt && now - startedAt;
          return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
        };
      }
      function throttle(fn, freq) {
        let timestamp = 0;
        let threshold = 1e3 / freq;
        let lastArgs;
        let timer;
        const invoke = (args, now = Date.now()) => {
          timestamp = now;
          lastArgs = null;
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          fn.apply(null, args);
        };
        const throttled = (...args) => {
          const now = Date.now();
          const passed = now - timestamp;
          if (passed >= threshold) {
            invoke(args, now);
          } else {
            lastArgs = args;
            if (!timer) {
              timer = setTimeout(() => {
                timer = null;
                invoke(lastArgs);
              }, threshold - passed);
            }
          }
        };
        const flush = () => lastArgs && invoke(lastArgs);
        return [throttled, flush];
      }
      const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
        let bytesNotified = 0;
        const _speedometer = speedometer(50, 250);
        return throttle((e) => {
          const loaded = e.loaded;
          const total = e.lengthComputable ? e.total : void 0;
          const progressBytes = loaded - bytesNotified;
          const rate = _speedometer(progressBytes);
          const inRange = loaded <= total;
          bytesNotified = loaded;
          const data = {
            loaded,
            total,
            progress: total ? loaded / total : void 0,
            bytes: progressBytes,
            rate: rate ? rate : void 0,
            estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
            event: e,
            lengthComputable: total != null,
            [isDownloadStream ? "download" : "upload"]: true
          };
          listener(data);
        }, freq);
      };
      const progressEventDecorator = (total, throttled) => {
        const lengthComputable = total != null;
        return [(loaded) => throttled[0]({
          lengthComputable,
          total,
          loaded
        }), throttled[1]];
      };
      const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
      const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
        url = new URL(url, platform.origin);
        return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
      })(
        new URL(platform.origin),
        platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
      ) : () => true;
      const cookies = platform.hasStandardBrowserEnv ? (
        // Standard browser envs support document.cookie
        {
          write(name, value, expires, path, domain, secure) {
            const cookie = [name + "=" + encodeURIComponent(value)];
            utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
            utils$1.isString(path) && cookie.push("path=" + path);
            utils$1.isString(domain) && cookie.push("domain=" + domain);
            secure === true && cookie.push("secure");
            document.cookie = cookie.join("; ");
          },
          read(name) {
            const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        }
      ) : (
        // Non-standard browser env (web workers, react-native) lack needed support.
        {
          write() {
          },
          read() {
            return null;
          },
          remove() {
          }
        }
      );
      function isAbsoluteURL(url) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      }
      function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      }
      function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
        let isRelativeUrl = !isAbsoluteURL(requestedURL);
        if (baseURL && isRelativeUrl || allowAbsoluteUrls == false) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      }
      const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
      function mergeConfig$1(config1, config2) {
        config2 = config2 || {};
        const config = {};
        function getMergedValue(target, source, prop, caseless) {
          if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
            return utils$1.merge.call({ caseless }, target, source);
          } else if (utils$1.isPlainObject(source)) {
            return utils$1.merge({}, source);
          } else if (utils$1.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(a, b, prop, caseless) {
          if (!utils$1.isUndefined(b)) {
            return getMergedValue(a, b, prop, caseless);
          } else if (!utils$1.isUndefined(a)) {
            return getMergedValue(void 0, a, prop, caseless);
          }
        }
        function valueFromConfig2(a, b) {
          if (!utils$1.isUndefined(b)) {
            return getMergedValue(void 0, b);
          }
        }
        function defaultToConfig2(a, b) {
          if (!utils$1.isUndefined(b)) {
            return getMergedValue(void 0, b);
          } else if (!utils$1.isUndefined(a)) {
            return getMergedValue(void 0, a);
          }
        }
        function mergeDirectKeys(a, b, prop) {
          if (prop in config2) {
            return getMergedValue(a, b);
          } else if (prop in config1) {
            return getMergedValue(void 0, a);
          }
        }
        const mergeMap = {
          url: valueFromConfig2,
          method: valueFromConfig2,
          data: valueFromConfig2,
          baseURL: defaultToConfig2,
          transformRequest: defaultToConfig2,
          transformResponse: defaultToConfig2,
          paramsSerializer: defaultToConfig2,
          timeout: defaultToConfig2,
          timeoutMessage: defaultToConfig2,
          withCredentials: defaultToConfig2,
          withXSRFToken: defaultToConfig2,
          adapter: defaultToConfig2,
          responseType: defaultToConfig2,
          xsrfCookieName: defaultToConfig2,
          xsrfHeaderName: defaultToConfig2,
          onUploadProgress: defaultToConfig2,
          onDownloadProgress: defaultToConfig2,
          decompress: defaultToConfig2,
          maxContentLength: defaultToConfig2,
          maxBodyLength: defaultToConfig2,
          beforeRedirect: defaultToConfig2,
          transport: defaultToConfig2,
          httpAgent: defaultToConfig2,
          httpsAgent: defaultToConfig2,
          cancelToken: defaultToConfig2,
          socketPath: defaultToConfig2,
          responseEncoding: defaultToConfig2,
          validateStatus: mergeDirectKeys,
          headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
        };
        utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
          const merge2 = mergeMap[prop] || mergeDeepProperties;
          const configValue = merge2(config1[prop], config2[prop], prop);
          utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
        });
        return config;
      }
      const resolveConfig = (config) => {
        const newConfig = mergeConfig$1({}, config);
        let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
        newConfig.headers = headers = AxiosHeaders$1.from(headers);
        newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
        if (auth) {
          headers.set(
            "Authorization",
            "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
          );
        }
        let contentType;
        if (utils$1.isFormData(data)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            headers.setContentType(void 0);
          } else if ((contentType = headers.getContentType()) !== false) {
            const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
            headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
          }
        }
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
            const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
            if (xsrfValue) {
              headers.set(xsrfHeaderName, xsrfValue);
            }
          }
        }
        return newConfig;
      };
      const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
      const xhrAdapter = isXHRAdapterSupported && function(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          const _config = resolveConfig(config);
          let requestData = _config.data;
          const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
          let { responseType, onUploadProgress, onDownloadProgress } = _config;
          let onCanceled;
          let uploadThrottled, downloadThrottled;
          let flushUpload, flushDownload;
          function done() {
            flushUpload && flushUpload();
            flushDownload && flushDownload();
            _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
            _config.signal && _config.signal.removeEventListener("abort", onCanceled);
          }
          let request = new XMLHttpRequest();
          request.open(_config.method.toUpperCase(), _config.url, true);
          request.timeout = _config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            const responseHeaders = AxiosHeaders$1.from(
              "getAllResponseHeaders" in request && request.getAllResponseHeaders()
            );
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            const response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional2 = _config.transitional || transitionalDefaults;
            if (_config.timeoutErrorMessage) {
              timeoutErrorMessage = _config.timeoutErrorMessage;
            }
            reject(new AxiosError$1(
              timeoutErrorMessage,
              transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
              config,
              request
            ));
            request = null;
          };
          requestData === void 0 && requestHeaders.setContentType(null);
          if ("setRequestHeader" in request) {
            utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
              request.setRequestHeader(key, val);
            });
          }
          if (!utils$1.isUndefined(_config.withCredentials)) {
            request.withCredentials = !!_config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = _config.responseType;
          }
          if (onDownloadProgress) {
            [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
            request.addEventListener("progress", downloadThrottled);
          }
          if (onUploadProgress && request.upload) {
            [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
            request.upload.addEventListener("progress", uploadThrottled);
            request.upload.addEventListener("loadend", flushUpload);
          }
          if (_config.cancelToken || _config.signal) {
            onCanceled = (cancel) => {
              if (!request) {
                return;
              }
              reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
              request.abort();
              request = null;
            };
            _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
            if (_config.signal) {
              _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
            }
          }
          const protocol = parseProtocol(_config.url);
          if (protocol && platform.protocols.indexOf(protocol) === -1) {
            reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
            return;
          }
          request.send(requestData || null);
        });
      };
      const composeSignals = (signals, timeout) => {
        const { length } = signals = signals ? signals.filter(Boolean) : [];
        if (timeout || length) {
          let controller = new AbortController();
          let aborted;
          const onabort = function(reason) {
            if (!aborted) {
              aborted = true;
              unsubscribe();
              const err = reason instanceof Error ? reason : this.reason;
              controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
            }
          };
          let timer = timeout && setTimeout(() => {
            timer = null;
            onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
          }, timeout);
          const unsubscribe = () => {
            if (signals) {
              timer && clearTimeout(timer);
              timer = null;
              signals.forEach((signal2) => {
                signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
              });
              signals = null;
            }
          };
          signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
          const { signal } = controller;
          signal.unsubscribe = () => utils$1.asap(unsubscribe);
          return signal;
        }
      };
      const streamChunk = function* (chunk, chunkSize) {
        let len = chunk.byteLength;
        if (len < chunkSize) {
          yield chunk;
          return;
        }
        let pos = 0;
        let end;
        while (pos < len) {
          end = pos + chunkSize;
          yield chunk.slice(pos, end);
          pos = end;
        }
      };
      const readBytes = async function* (iterable, chunkSize) {
        for await (const chunk of readStream(iterable)) {
          yield* streamChunk(chunk, chunkSize);
        }
      };
      const readStream = async function* (stream) {
        if (stream[Symbol.asyncIterator]) {
          yield* stream;
          return;
        }
        const reader = stream.getReader();
        try {
          for (; ; ) {
            const { done, value } = await reader.read();
            if (done) {
              break;
            }
            yield value;
          }
        } finally {
          await reader.cancel();
        }
      };
      const trackStream = (stream, chunkSize, onProgress, onFinish) => {
        const iterator = readBytes(stream, chunkSize);
        let bytes = 0;
        let done;
        let _onFinish = (e) => {
          if (!done) {
            done = true;
            onFinish && onFinish(e);
          }
        };
        return new ReadableStream({
          async pull(controller) {
            try {
              const { done: done2, value } = await iterator.next();
              if (done2) {
                _onFinish();
                controller.close();
                return;
              }
              let len = value.byteLength;
              if (onProgress) {
                let loadedBytes = bytes += len;
                onProgress(loadedBytes);
              }
              controller.enqueue(new Uint8Array(value));
            } catch (err) {
              _onFinish(err);
              throw err;
            }
          },
          cancel(reason) {
            _onFinish(reason);
            return iterator.return();
          }
        }, {
          highWaterMark: 2
        });
      };
      const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
      const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
      const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
      const test = (fn, ...args) => {
        try {
          return !!fn(...args);
        } catch (e) {
          return false;
        }
      };
      const supportsRequestStream = isReadableStreamSupported && test(() => {
        let duplexAccessed = false;
        const hasContentType = new Request(platform.origin, {
          body: new ReadableStream(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
      });
      const DEFAULT_CHUNK_SIZE = 64 * 1024;
      const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
      const resolvers = {
        stream: supportsResponseStream && ((res) => res.body)
      };
      isFetchSupported && ((res) => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
          !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
            throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
          });
        });
      })(new Response());
      const getBodyLength = async (body) => {
        if (body == null) {
          return 0;
        }
        if (utils$1.isBlob(body)) {
          return body.size;
        }
        if (utils$1.isSpecCompliantForm(body)) {
          const _request = new Request(platform.origin, {
            method: "POST",
            body
          });
          return (await _request.arrayBuffer()).byteLength;
        }
        if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
          return body.byteLength;
        }
        if (utils$1.isURLSearchParams(body)) {
          body = body + "";
        }
        if (utils$1.isString(body)) {
          return (await encodeText(body)).byteLength;
        }
      };
      const resolveBodyLength = async (headers, body) => {
        const length = utils$1.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body) : length;
      };
      const fetchAdapter = isFetchSupported && (async (config) => {
        let {
          url,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = "same-origin",
          fetchOptions
        } = resolveConfig(config);
        responseType = responseType ? (responseType + "").toLowerCase() : "text";
        let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
        let request;
        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });
        let requestContentLength;
        try {
          if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request(url, {
              method: "POST",
              body: data,
              duplex: "half"
            });
            let contentTypeHeader;
            if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils$1.isString(withCredentials)) {
            withCredentials = withCredentials ? "include" : "omit";
          }
          const isCredentialsSupported = "credentials" in Request.prototype;
          request = new Request(url, {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : void 0
          });
          let response = await fetch(request);
          const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            ["status", "statusText", "headers"].forEach((prop) => {
              options[prop] = response[prop];
            });
            const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];
            response = new Response(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || "text";
          let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
          !isStreamResponse && unsubscribe && unsubscribe();
          return await new Promise((resolve, reject) => {
            settle(resolve, reject, {
              data: responseData,
              headers: AxiosHeaders$1.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config,
              request
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
              {
                cause: err.cause || err
              }
            );
          }
          throw AxiosError$1.from(err, err && err.code, config, request);
        }
      });
      const knownAdapters = {
        http: httpAdapter,
        xhr: xhrAdapter,
        fetch: fetchAdapter
      };
      utils$1.forEach(knownAdapters, (fn, value) => {
        if (fn) {
          try {
            Object.defineProperty(fn, "name", { value });
          } catch (e) {
          }
          Object.defineProperty(fn, "adapterName", { value });
        }
      });
      const renderReason = (reason) => `- ${reason}`;
      const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
      const adapters = {
        getAdapter: (adapters2) => {
          adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
          const { length } = adapters2;
          let nameOrAdapter;
          let adapter;
          const rejectedReasons = {};
          for (let i = 0; i < length; i++) {
            nameOrAdapter = adapters2[i];
            let id;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
              adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
              if (adapter === void 0) {
                throw new AxiosError$1(`Unknown adapter '${id}'`);
              }
            }
            if (adapter) {
              break;
            }
            rejectedReasons[id || "#" + i] = adapter;
          }
          if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(
              ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
            );
            let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new AxiosError$1(
              `There is no suitable adapter to dispatch the request ` + s,
              "ERR_NOT_SUPPORT"
            );
          }
          return adapter;
        },
        adapters: knownAdapters
      };
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
        if (config.signal && config.signal.aborted) {
          throw new CanceledError$1(null, config);
        }
      }
      function dispatchRequest(config) {
        throwIfCancellationRequested(config);
        config.headers = AxiosHeaders$1.from(config.headers);
        config.data = transformData.call(
          config,
          config.transformRequest
        );
        if (["post", "put", "patch"].indexOf(config.method) !== -1) {
          config.headers.setContentType("application/x-www-form-urlencoded", false);
        }
        const adapter = adapters.getAdapter(config.adapter || defaults.adapter);
        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);
          response.data = transformData.call(
            config,
            config.transformResponse,
            response
          );
          response.headers = AxiosHeaders$1.from(response.headers);
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel$1(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
              reason.response.data = transformData.call(
                config,
                config.transformResponse,
                reason.response
              );
              reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
            }
          }
          return Promise.reject(reason);
        });
      }
      const VERSION$1 = "1.8.3";
      const validators$1 = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
        validators$1[type] = function validator2(thing) {
          return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
        };
      });
      const deprecatedWarnings = {};
      validators$1.transitional = function transitional(validator2, version, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return (value, opt, opts) => {
          if (validator2 === false) {
            throw new AxiosError$1(
              formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
              AxiosError$1.ERR_DEPRECATED
            );
          }
          if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(
              formatMessage(
                opt,
                " has been deprecated since v" + version + " and will be removed in the near future"
              )
            );
          }
          return validator2 ? validator2(value, opt, opts) : true;
        };
      };
      validators$1.spelling = function spelling(correctSpelling) {
        return (value, opt) => {
          console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
          return true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
        }
        const keys = Object.keys(options);
        let i = keys.length;
        while (i-- > 0) {
          const opt = keys[i];
          const validator2 = schema[opt];
          if (validator2) {
            const value = options[opt];
            const result = value === void 0 || validator2(value, opt, options);
            if (result !== true) {
              throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
          }
        }
      }
      const validator = {
        assertOptions,
        validators: validators$1
      };
      const validators = validator.validators;
      let Axios$1 = class Axios {
        constructor(instanceConfig) {
          this.defaults = instanceConfig;
          this.interceptors = {
            request: new InterceptorManager(),
            response: new InterceptorManager()
          };
        }
        /**
         * Dispatch a request
         *
         * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
         * @param {?Object} config
         *
         * @returns {Promise} The Promise to be fulfilled
         */
        async request(configOrUrl, config) {
          try {
            return await this._request(configOrUrl, config);
          } catch (err) {
            if (err instanceof Error) {
              let dummy = {};
              Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
              const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
              try {
                if (!err.stack) {
                  err.stack = stack;
                } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                  err.stack += "\n" + stack;
                }
              } catch (e) {
              }
            }
            throw err;
          }
        }
        _request(configOrUrl, config) {
          if (typeof configOrUrl === "string") {
            config = config || {};
            config.url = configOrUrl;
          } else {
            config = configOrUrl || {};
          }
          config = mergeConfig$1(this.defaults, config);
          const { transitional: transitional2, paramsSerializer, headers } = config;
          if (transitional2 !== void 0) {
            validator.assertOptions(transitional2, {
              silentJSONParsing: validators.transitional(validators.boolean),
              forcedJSONParsing: validators.transitional(validators.boolean),
              clarifyTimeoutError: validators.transitional(validators.boolean)
            }, false);
          }
          if (paramsSerializer != null) {
            if (utils$1.isFunction(paramsSerializer)) {
              config.paramsSerializer = {
                serialize: paramsSerializer
              };
            } else {
              validator.assertOptions(paramsSerializer, {
                encode: validators.function,
                serialize: validators.function
              }, true);
            }
          }
          if (config.allowAbsoluteUrls !== void 0) ;
          else if (this.defaults.allowAbsoluteUrls !== void 0) {
            config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
          } else {
            config.allowAbsoluteUrls = true;
          }
          validator.assertOptions(config, {
            baseUrl: validators.spelling("baseURL"),
            withXsrfToken: validators.spelling("withXSRFToken")
          }, true);
          config.method = (config.method || this.defaults.method || "get").toLowerCase();
          let contextHeaders = headers && utils$1.merge(
            headers.common,
            headers[config.method]
          );
          headers && utils$1.forEach(
            ["delete", "get", "head", "post", "put", "patch", "common"],
            (method) => {
              delete headers[method];
            }
          );
          config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
          const requestInterceptorChain = [];
          let synchronousRequestInterceptors = true;
          this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
              return;
            }
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
          });
          const responseInterceptorChain = [];
          this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
          });
          let promise;
          let i = 0;
          let len;
          if (!synchronousRequestInterceptors) {
            const chain = [dispatchRequest.bind(this), void 0];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config);
            while (i < len) {
              promise = promise.then(chain[i++], chain[i++]);
            }
            return promise;
          }
          len = requestInterceptorChain.length;
          let newConfig = config;
          i = 0;
          while (i < len) {
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
              newConfig = onFulfilled(newConfig);
            } catch (error) {
              onRejected.call(this, error);
              break;
            }
          }
          try {
            promise = dispatchRequest.call(this, newConfig);
          } catch (error) {
            return Promise.reject(error);
          }
          i = 0;
          len = responseInterceptorChain.length;
          while (i < len) {
            promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
          }
          return promise;
        }
        getUri(config) {
          config = mergeConfig$1(this.defaults, config);
          const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
          return buildURL(fullPath, config.params, config.paramsSerializer);
        }
      };
      utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios$1.prototype[method] = function(url, config) {
          return this.request(mergeConfig$1(config || {}, {
            method,
            url,
            data: (config || {}).data
          }));
        };
      });
      utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        function generateHTTPMethod(isForm) {
          return function httpMethod(url, data, config) {
            return this.request(mergeConfig$1(config || {}, {
              method,
              headers: isForm ? {
                "Content-Type": "multipart/form-data"
              } : {},
              url,
              data
            }));
          };
        }
        Axios$1.prototype[method] = generateHTTPMethod();
        Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
      });
      let CancelToken$1 = class CancelToken {
        constructor(executor) {
          if (typeof executor !== "function") {
            throw new TypeError("executor must be a function.");
          }
          let resolvePromise;
          this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
          });
          const token = this;
          this.promise.then((cancel) => {
            if (!token._listeners) return;
            let i = token._listeners.length;
            while (i-- > 0) {
              token._listeners[i](cancel);
            }
            token._listeners = null;
          });
          this.promise.then = (onfulfilled) => {
            let _resolve;
            const promise = new Promise((resolve) => {
              token.subscribe(resolve);
              _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
              token.unsubscribe(_resolve);
            };
            return promise;
          };
          executor(function cancel(message, config, request) {
            if (token.reason) {
              return;
            }
            token.reason = new CanceledError$1(message, config, request);
            resolvePromise(token.reason);
          });
        }
        /**
         * Throws a `CanceledError` if cancellation has been requested.
         */
        throwIfRequested() {
          if (this.reason) {
            throw this.reason;
          }
        }
        /**
         * Subscribe to the cancel signal
         */
        subscribe(listener) {
          if (this.reason) {
            listener(this.reason);
            return;
          }
          if (this._listeners) {
            this._listeners.push(listener);
          } else {
            this._listeners = [listener];
          }
        }
        /**
         * Unsubscribe from the cancel signal
         */
        unsubscribe(listener) {
          if (!this._listeners) {
            return;
          }
          const index = this._listeners.indexOf(listener);
          if (index !== -1) {
            this._listeners.splice(index, 1);
          }
        }
        toAbortSignal() {
          const controller = new AbortController();
          const abort = (err) => {
            controller.abort(err);
          };
          this.subscribe(abort);
          controller.signal.unsubscribe = () => this.unsubscribe(abort);
          return controller.signal;
        }
        /**
         * Returns an object that contains a new `CancelToken` and a function that, when called,
         * cancels the `CancelToken`.
         */
        static source() {
          let cancel;
          const token = new CancelToken(function executor(c) {
            cancel = c;
          });
          return {
            token,
            cancel
          };
        }
      };
      function spread$1(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      }
      function isAxiosError$1(payload) {
        return utils$1.isObject(payload) && payload.isAxiosError === true;
      }
      const HttpStatusCode$1 = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
      };
      Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
        HttpStatusCode$1[value] = key;
      });
      function createInstance(defaultConfig) {
        const context = new Axios$1(defaultConfig);
        const instance = bind(Axios$1.prototype.request, context);
        utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
        utils$1.extend(instance, context, null, { allOwnKeys: true });
        instance.create = function create(instanceConfig) {
          return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
        };
        return instance;
      }
      const axios = exports("B", createInstance(defaults));
      axios.Axios = Axios$1;
      axios.CanceledError = CanceledError$1;
      axios.CancelToken = CancelToken$1;
      axios.isCancel = isCancel$1;
      axios.VERSION = VERSION$1;
      axios.toFormData = toFormData$1;
      axios.AxiosError = AxiosError$1;
      axios.Cancel = axios.CanceledError;
      axios.all = function all(promises) {
        return Promise.all(promises);
      };
      axios.spread = spread$1;
      axios.isAxiosError = isAxiosError$1;
      axios.mergeConfig = mergeConfig$1;
      axios.AxiosHeaders = AxiosHeaders$1;
      axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
      axios.getAdapter = adapters.getAdapter;
      axios.HttpStatusCode = HttpStatusCode$1;
      axios.default = axios;
      const {
        Axios: Axios2,
        AxiosError,
        CanceledError,
        isCancel,
        CancelToken: CancelToken2,
        VERSION,
        all: all2,
        Cancel,
        isAxiosError,
        spread,
        toFormData,
        AxiosHeaders: AxiosHeaders2,
        HttpStatusCode,
        formToJSON,
        getAdapter,
        mergeConfig
      } = axios;
      logger.debug("åˆå§‹åŒ–");
      async function main(router) {
        let module$1 = {
          run() {
            logger.info("BoosHelperåŠ è½½æˆåŠŸ");
            logger.warn("å½“å‰é¡µé¢æ— å¯¹åº”hookè„šæœ¬", router.path);
          }
        };
        switch (router.path) {
          case "/web/geek/job":
            module$1 = await __vitePreload(() => module.import('./index-CNEn8kNx-CwvSG4su.js'), void 0 );
            break;
        }
        module$1.run();
        const helper = document.querySelector("#boos-helper");
        if (!helper) {
          const app = createApp(_sfc_main);
          const appEl = document.createElement("div");
          appEl.id = "boos-helper";
          document.body.append(appEl);
          app.mount(appEl);
        }
      }
      async function start() {
        document.documentElement.classList.toggle(
          "dark",
          _GM_getValue("theme-dark", false)
        );
        const v = await getRootVue();
        v.$router.afterHooks.push(main);
        main(v.$route);
        let axiosLoad;
        axios.interceptors.request.use(
          function(config) {
            if (config.timeout) {
              axiosLoad = loader({ ms: config.timeout, color: "#F79E63" });
            }
            return config;
          },
          function(error) {
            if (axiosLoad) axiosLoad();
            return Promise.reject(error);
          }
        );
        axios.interceptors.response.use(
          function(response) {
            if (axiosLoad) axiosLoad();
            return response;
          },
          function(error) {
            if (axiosLoad) axiosLoad();
            return Promise.reject(error);
          }
        );
      }
      logger.debug("å¼€å§‹è¿è¡Œ");
      start();

    })
  };
}));

System.register("./index-CNEn8kNx-CwvSG4su.js", ['./__monkey.entry-DHxVDBEP.js', 'vue', 'element-plus', 'protobufjs'], (function (exports, module) {
  'use strict';
  var logger, elmGetter, withInstall, _GM_getValue, _GM_setValue, useHookVueData, useHookVueFn, _export_sfc$1, useStatistics, useConfFormData, formInfoData, isClient$1, noop$2, toValue, isObject$2, tryOnScopeDispose$1, notification, delay, withNoopInstall, ElIcon$1, ElButton$1, watchIgnorable, buildProps, useNamespace, isNumber$1, addUnit, useFormSize, close_default, _unsafeWindow, axios, useUserId, TypeComponentsMap, TypeComponents, reactiveComputed, deepmerge, isArray$1, definePropType, componentSizes, getCurDay, getCurTime, isString$2, isUndefined$1, iconPropType, isBoolean$1, useDeprecated, hasOwn, useSizeProp, useId, useFormItem, useFormItemInputId, formContextKey, formItemContextKey, refDebounced, useGlobalConfig, defaultNamespace, NOOP, addClass, removeClass, isClient, _GM_xmlhttpRequest, loader, useFormDisabled, ValidateComponentsMap, view_default, hide_default, isNil, circle_close_default, arrow_down_default, isPropAbsent, hasClass, getStyle, useTimeoutFn, CloseComponents, arrow_right_default, isFunction$2, isObject$1, isString$1, noop$1, resolveUnref, tryOnScopeDispose, fromPairs, computedWithControl, isElement, arrow_up_default, tryOnMounted, buildProp, useGetDerivedNamespace, useIdInjection, isIOS, minus_default, plus_default, loading_default, identity$1, createApp, defineComponent, ref, computed, onMounted, createElementBlock, openBlock, Fragment, createElementVNode, createCommentVNode, createVNode, createBlock, createTextVNode, unref, withCtx, toDisplayString, normalizeStyle, renderList, mergeProps, withModifiers, Teleport$1, watch, resolveDirective, withDirectives, markRaw, useModel$1, mergeModels, h$1, watchEffect, normalizeClass, renderSlot, Transition, vShow, useSlots, resolveDynamicComponent, isRef, isVNode, reactive, shallowReactive, nextTick, getCurrentInstance, onBeforeMount, onBeforeUnmount, toRaw, provide, createSlots, resolveComponent, toRefs, vModelRadio, inject, TransitionGroup, Comment, onUnmounted, onActivated, onUpdated, useAttrs$1, shallowRef, toRef, withKeys, onScopeDispose, vModelCheckbox, readonly, onDeactivated, render$3, cloneVNode, Text$1, toHandlers, pushScopeId, popScopeId, withScopeId, normalizeProps, guardReactiveProps, ElTooltip$1, ElTabs, ElTabPane, ElCheckbox$1, ElRow, ElCol, ElStatistic, ElDropdown, ElIcon, ElDropdownMenu, ElDropdownItem, ElButtonGroup, ElButton, ElProgress, ElSpace$1, ElAutoResizer, ElTableV2, ElLink$1, ElImage, ElMessage, ElDialog$1, ElAlert$1, ElSelectV2, ElText$1, ElInput$1, ElTag$1, ElSwitch, ElSlider, ElInputNumber$1, ElMessageBox, ElNotification, ElForm$1, ElFormItem$1, ElSelect, ElOption, protobuf;
  return {
    setters: [module => {
      logger = module.l;
      elmGetter = module.e;
      withInstall = module.w;
      _GM_getValue = module._;
      _GM_setValue = module.a;
      useHookVueData = module.u;
      useHookVueFn = module.b;
      _export_sfc$1 = module.c;
      useStatistics = module.d;
      useConfFormData = module.f;
      formInfoData = module.g;
      isClient$1 = module.i;
      noop$2 = module.n;
      toValue = module.t;
      isObject$2 = module.h;
      tryOnScopeDispose$1 = module.j;
      notification = module.k;
      delay = module.m;
      withNoopInstall = module.o;
      ElIcon$1 = module.E;
      ElButton$1 = module.p;
      watchIgnorable = module.q;
      buildProps = module.r;
      useNamespace = module.s;
      isNumber$1 = module.v;
      addUnit = module.x;
      useFormSize = module.y;
      close_default = module.z;
      _unsafeWindow = module.A;
      axios = module.B;
      useUserId = module.C;
      TypeComponentsMap = module.T;
      TypeComponents = module.D;
      reactiveComputed = module.F;
      deepmerge = module.G;
      isArray$1 = module.H;
      definePropType = module.I;
      componentSizes = module.J;
      getCurDay = module.K;
      getCurTime = module.L;
      isString$2 = module.M;
      isUndefined$1 = module.N;
      iconPropType = module.O;
      isBoolean$1 = module.P;
      useDeprecated = module.Q;
      hasOwn = module.R;
      useSizeProp = module.S;
      useId = module.U;
      useFormItem = module.V;
      useFormItemInputId = module.W;
      formContextKey = module.X;
      formItemContextKey = module.Y;
      refDebounced = module.Z;
      useGlobalConfig = module.$;
      defaultNamespace = module.a0;
      NOOP = module.a1;
      addClass = module.a2;
      removeClass = module.a3;
      isClient = module.a4;
      _GM_xmlhttpRequest = module.a5;
      loader = module.a6;
      useFormDisabled = module.a7;
      ValidateComponentsMap = module.a8;
      view_default = module.a9;
      hide_default = module.aa;
      isNil = module.ab;
      circle_close_default = module.ac;
      arrow_down_default = module.ad;
      isPropAbsent = module.ae;
      hasClass = module.af;
      getStyle = module.ag;
      useTimeoutFn = module.ah;
      CloseComponents = module.ai;
      arrow_right_default = module.aj;
      isFunction$2 = module.ak;
      isObject$1 = module.al;
      isString$1 = module.am;
      noop$1 = module.an;
      resolveUnref = module.ao;
      tryOnScopeDispose = module.ap;
      fromPairs = module.aq;
      computedWithControl = module.ar;
      isElement = module.as;
      arrow_up_default = module.at;
      tryOnMounted = module.au;
      buildProp = module.av;
      useGetDerivedNamespace = module.aw;
      useIdInjection = module.ax;
      isIOS = module.ay;
      minus_default = module.az;
      plus_default = module.aA;
      loading_default = module.aB;
      identity$1 = module.aC;
    }, module => {
      createApp = module.createApp;
      defineComponent = module.defineComponent;
      ref = module.ref;
      computed = module.computed;
      onMounted = module.onMounted;
      createElementBlock = module.createElementBlock;
      openBlock = module.openBlock;
      Fragment = module.Fragment;
      createElementVNode = module.createElementVNode;
      createCommentVNode = module.createCommentVNode;
      createVNode = module.createVNode;
      createBlock = module.createBlock;
      createTextVNode = module.createTextVNode;
      unref = module.unref;
      withCtx = module.withCtx;
      toDisplayString = module.toDisplayString;
      normalizeStyle = module.normalizeStyle;
      renderList = module.renderList;
      mergeProps = module.mergeProps;
      withModifiers = module.withModifiers;
      Teleport$1 = module.Teleport;
      watch = module.watch;
      resolveDirective = module.resolveDirective;
      withDirectives = module.withDirectives;
      markRaw = module.markRaw;
      useModel$1 = module.useModel;
      mergeModels = module.mergeModels;
      h$1 = module.h;
      watchEffect = module.watchEffect;
      normalizeClass = module.normalizeClass;
      renderSlot = module.renderSlot;
      Transition = module.Transition;
      vShow = module.vShow;
      useSlots = module.useSlots;
      resolveDynamicComponent = module.resolveDynamicComponent;
      isRef = module.isRef;
      isVNode = module.isVNode;
      reactive = module.reactive;
      shallowReactive = module.shallowReactive;
      nextTick = module.nextTick;
      getCurrentInstance = module.getCurrentInstance;
      onBeforeMount = module.onBeforeMount;
      onBeforeUnmount = module.onBeforeUnmount;
      toRaw = module.toRaw;
      provide = module.provide;
      createSlots = module.createSlots;
      resolveComponent = module.resolveComponent;
      toRefs = module.toRefs;
      vModelRadio = module.vModelRadio;
      inject = module.inject;
      TransitionGroup = module.TransitionGroup;
      Comment = module.Comment;
      onUnmounted = module.onUnmounted;
      onActivated = module.onActivated;
      onUpdated = module.onUpdated;
      useAttrs$1 = module.useAttrs;
      shallowRef = module.shallowRef;
      toRef = module.toRef;
      withKeys = module.withKeys;
      onScopeDispose = module.onScopeDispose;
      vModelCheckbox = module.vModelCheckbox;
      readonly = module.readonly;
      onDeactivated = module.onDeactivated;
      render$3 = module.render;
      cloneVNode = module.cloneVNode;
      Text$1 = module.Text;
      toHandlers = module.toHandlers;
      pushScopeId = module.pushScopeId;
      popScopeId = module.popScopeId;
      withScopeId = module.withScopeId;
      normalizeProps = module.normalizeProps;
      guardReactiveProps = module.guardReactiveProps;
    }, module => {
      ElTooltip$1 = module.ElTooltip;
      ElTabs = module.ElTabs;
      ElTabPane = module.ElTabPane;
      ElCheckbox$1 = module.ElCheckbox;
      ElRow = module.ElRow;
      ElCol = module.ElCol;
      ElStatistic = module.ElStatistic;
      ElDropdown = module.ElDropdown;
      ElIcon = module.ElIcon;
      ElDropdownMenu = module.ElDropdownMenu;
      ElDropdownItem = module.ElDropdownItem;
      ElButtonGroup = module.ElButtonGroup;
      ElButton = module.ElButton;
      ElProgress = module.ElProgress;
      ElSpace$1 = module.ElSpace;
      ElAutoResizer = module.ElAutoResizer;
      ElTableV2 = module.ElTableV2;
      ElLink$1 = module.ElLink;
      ElImage = module.ElImage;
      ElMessage = module.ElMessage;
      ElDialog$1 = module.ElDialog;
      ElAlert$1 = module.ElAlert;
      ElSelectV2 = module.ElSelectV2;
      ElText$1 = module.ElText;
      ElInput$1 = module.ElInput;
      ElTag$1 = module.ElTag;
      ElSwitch = module.ElSwitch;
      ElSlider = module.ElSlider;
      ElInputNumber$1 = module.ElInputNumber;
      ElMessageBox = module.ElMessageBox;
      ElNotification = module.ElNotification;
      ElForm$1 = module.ElForm;
      ElFormItem$1 = module.ElFormItem;
      ElSelect = module.ElSelect;
      ElOption = module.ElOption;
    }, module => {
      protobuf = module.default;
    }],
    execute: (function () {

      exports("run", run);

      var __defProp = Object.defineProperty;
      var __typeError = (msg) => {
        throw TypeError(msg);
      };
      var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
      var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), member.get(obj));
      var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
      var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
      var _currentLine;
      function unrefElement$1(elRef) {
        var _a;
        const plain = toValue(elRef);
        return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
      }
      const defaultWindow$1 = isClient$1 ? window : void 0;
      function useEventListener$1(...args) {
        let target;
        let events2;
        let listeners;
        let options2;
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
          [events2, listeners, options2] = args;
          target = defaultWindow$1;
        } else {
          [target, events2, listeners, options2] = args;
        }
        if (!target)
          return noop$2;
        if (!Array.isArray(events2))
          events2 = [events2];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register2 = (el, event, listener, options22) => {
          el.addEventListener(event, listener, options22);
          return () => el.removeEventListener(event, listener, options22);
        };
        const stopWatch = watch(
          () => [unrefElement$1(target), toValue(options2)],
          ([el, options22]) => {
            cleanup();
            if (!el)
              return;
            const optionsClone = isObject$2(options22) ? { ...options22 } : options22;
            cleanups.push(
              ...events2.flatMap((event) => {
                return listeners.map((listener) => register2(el, event, listener, optionsClone));
              })
            );
          },
          { immediate: true, flush: "post" }
        );
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose$1(stop);
        return stop;
      }
      const UseMouseBuiltinExtractors = {
        page: (event) => [event.pageX, event.pageY],
        client: (event) => [event.clientX, event.clientY],
        screen: (event) => [event.screenX, event.screenY],
        movement: (event) => event instanceof Touch ? null : [event.movementX, event.movementY]
      };
      function useMouse(options2 = {}) {
        const {
          type: type4 = "page",
          touch = true,
          resetOnTouchEnds = false,
          initialValue = { x: 0, y: 0 },
          window: window2 = defaultWindow$1,
          target = window2,
          scroll: scroll3 = true,
          eventFilter
        } = options2;
        let _prevMouseEvent = null;
        const x2 = ref(initialValue.x);
        const y = ref(initialValue.y);
        const sourceType = ref(null);
        const extractor = typeof type4 === "function" ? type4 : UseMouseBuiltinExtractors[type4];
        const mouseHandler = (event) => {
          const result = extractor(event);
          _prevMouseEvent = event;
          if (result) {
            [x2.value, y.value] = result;
            sourceType.value = "mouse";
          }
        };
        const touchHandler = (event) => {
          if (event.touches.length > 0) {
            const result = extractor(event.touches[0]);
            if (result) {
              [x2.value, y.value] = result;
              sourceType.value = "touch";
            }
          }
        };
        const scrollHandler = () => {
          if (!_prevMouseEvent || !window2)
            return;
          const pos = extractor(_prevMouseEvent);
          if (_prevMouseEvent instanceof MouseEvent && pos) {
            x2.value = pos[0] + window2.scrollX;
            y.value = pos[1] + window2.scrollY;
          }
        };
        const reset = () => {
          x2.value = initialValue.x;
          y.value = initialValue.y;
        };
        const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);
        const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);
        const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();
        if (target) {
          const listenerOptions = { passive: true };
          useEventListener$1(target, ["mousemove", "dragover"], mouseHandlerWrapper, listenerOptions);
          if (touch && type4 !== "movement") {
            useEventListener$1(target, ["touchstart", "touchmove"], touchHandlerWrapper, listenerOptions);
            if (resetOnTouchEnds)
              useEventListener$1(target, "touchend", reset, listenerOptions);
          }
          if (scroll3 && type4 === "page")
            useEventListener$1(window2, "scroll", scrollHandlerWrapper, { passive: true });
        }
        return {
          x: x2,
          y,
          sourceType
        };
      }
      function useMouseInElement(target, options2 = {}) {
        const {
          handleOutside = true,
          window: window2 = defaultWindow$1
        } = options2;
        const type4 = options2.type || "page";
        const { x: x2, y, sourceType } = useMouse(options2);
        const targetRef = ref(target != null ? target : window2 == null ? void 0 : window2.document.body);
        const elementX = ref(0);
        const elementY = ref(0);
        const elementPositionX = ref(0);
        const elementPositionY = ref(0);
        const elementHeight = ref(0);
        const elementWidth = ref(0);
        const isOutside = ref(true);
        let stop = () => {
        };
        if (window2) {
          stop = watch(
            [targetRef, x2, y],
            () => {
              const el = unrefElement$1(targetRef);
              if (!el)
                return;
              const {
                left,
                top,
                width,
                height
              } = el.getBoundingClientRect();
              elementPositionX.value = left + (type4 === "page" ? window2.pageXOffset : 0);
              elementPositionY.value = top + (type4 === "page" ? window2.pageYOffset : 0);
              elementHeight.value = height;
              elementWidth.value = width;
              const elX = x2.value - elementPositionX.value;
              const elY = y.value - elementPositionY.value;
              isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;
              if (handleOutside || !isOutside.value) {
                elementX.value = elX;
                elementY.value = elY;
              }
            },
            { immediate: true }
          );
          useEventListener$1(document, "mouseleave", () => {
            isOutside.value = true;
          });
        }
        return {
          x: x2,
          y,
          sourceType,
          elementX,
          elementY,
          elementPositionX,
          elementPositionY,
          elementHeight,
          elementWidth,
          isOutside,
          stop
        };
      }
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root$1 = freeGlobal || freeSelf || Function("return this")();
      var Symbol$1 = root$1.Symbol;
      var objectProto$f = Object.prototype;
      var hasOwnProperty$c = objectProto$f.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$f.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$e = Object.prototype;
      var nativeObjectToString = objectProto$e.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$3 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
      }
      function arrayMap(array4, iteratee) {
        var index = -1, length = array4 == null ? 0 : array4.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array4[index], index, array4);
        }
        return result;
      }
      var isArray = Array.isArray;
      var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -Infinity ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string3) {
        var index = string3.length;
        while (index-- && reWhitespace.test(string3.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string3) {
        return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
      }
      function isObject(value) {
        var type4 = typeof value;
        return value != null && (type4 == "object" || type4 == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other2 = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other2) ? other2 + "" : other2;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root$1["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$2 = Function.prototype;
      var funcToString$2 = funcProto$2.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto$1 = Function.prototype, objectProto$d = Object.prototype;
      var funcToString$1 = funcProto$1.toString;
      var hasOwnProperty$b = objectProto$d.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern4 = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern4.test(toSource(value));
      }
      function getValue$1(object4, key) {
        return object4 == null ? void 0 : object4[key];
      }
      function getNative(object4, key) {
        var value = getValue$1(object4, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap$1 = getNative(root$1, "WeakMap");
      var objectCreate = Object.create;
      var baseCreate = /* @__PURE__ */ function() {
        function object4() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object4.prototype = proto;
          var result = new object4();
          object4.prototype = void 0;
          return result;
        };
      }();
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function copyArray(source, array4) {
        var index = -1, length = source.length;
        array4 || (array4 = Array(length));
        while (++index < length) {
          array4[index] = source[index];
        }
        return array4;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var baseSetToString = !defineProperty ? identity : function(func, string3) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string3),
          "writable": true
        });
      };
      var setToString = shortOut(baseSetToString);
      function arrayEach(array4, iteratee) {
        var index = -1, length = array4 == null ? 0 : array4.length;
        while (++index < length) {
          if (iteratee(array4[index], index, array4) === false) {
            break;
          }
        }
        return array4;
      }
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type4 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object4, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object4, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object4[key] = value;
        }
      }
      function eq(value, other2) {
        return value === other2 || value !== value && other2 !== other2;
      }
      var objectProto$c = Object.prototype;
      var hasOwnProperty$a = objectProto$c.hasOwnProperty;
      function assignValue(object4, key, value) {
        var objValue = object4[key];
        if (!(hasOwnProperty$a.call(object4, key) && eq(objValue, value)) || value === void 0 && !(key in object4)) {
          baseAssignValue(object4, key, value);
        }
      }
      function copyObject(source, props2, object4, customizer) {
        var isNew = !object4;
        object4 || (object4 = {});
        var index = -1, length = props2.length;
        while (++index < length) {
          var key = props2[index];
          var newValue = void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object4, key, newValue);
          } else {
            assignValue(object4, key, newValue);
          }
        }
        return object4;
      }
      var nativeMax$1 = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array4 = Array(length);
          while (++index < length) {
            array4[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array4);
          return apply(func, this, otherArgs);
        };
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isIterateeCall(value, index, object4) {
        if (!isObject(object4)) {
          return false;
        }
        var type4 = typeof index;
        if (type4 == "number" ? isArrayLike(object4) && isIndex(index, object4.length) : type4 == "string" && index in object4) {
          return eq(object4[index], value);
        }
        return false;
      }
      function createAssigner(assigner) {
        return baseRest(function(object4, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object4 = Object(object4);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object4, source, index, customizer);
            }
          }
          return object4;
        });
      }
      var objectProto$b = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$b;
        return value === proto;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      var argsTag$3 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$3;
      }
      var objectProto$a = Object.prototype;
      var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
      var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
      typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      function baseKeys(object4) {
        if (!isPrototype(object4)) {
          return nativeKeys(object4);
        }
        var result = [];
        for (var key in Object(object4)) {
          if (hasOwnProperty$7.call(object4, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object4) {
        return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
      }
      function nativeKeysIn(object4) {
        var result = [];
        if (object4 != null) {
          for (var key in Object(object4)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      function baseKeysIn(object4) {
        if (!isObject(object4)) {
          return nativeKeysIn(object4);
        }
        var isProto = isPrototype(object4), result = [];
        for (var key in object4) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object4, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object4) {
        return isArrayLike(object4) ? arrayLikeKeys(object4, true) : baseKeysIn(object4);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object4) {
        if (isArray(value)) {
          return false;
        }
        var type4 = typeof value;
        if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object(object4);
      }
      var nativeCreate = getNative(Object, "create");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
      function hashGet(key) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result = data2[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$5.call(data2, key) ? data2[key] : void 0;
      }
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
      function hashHas(key) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key] !== void 0 : hasOwnProperty$4.call(data2, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array4, key) {
        var length = array4.length;
        while (length--) {
          if (eq(array4[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        return index < 0 ? void 0 : data2[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root$1, "Map");
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$1 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type4 = typeof value;
        return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map2, key) {
        var data2 = map2.__data__;
        return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data2 = getMapData(this, key), size = data2.size;
        data2.set(key, value);
        this.size += data2.size == size ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string3) {
        var result = [];
        if (string3.charCodeAt(0) === 46) {
          result.push("");
        }
        string3.replace(rePropName, function(match, number4, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match);
        });
        return result;
      });
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object4) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object4) ? [value] : stringToPath(toString(value));
      }
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -Infinity ? "-0" : result;
      }
      function baseGet(object4, path) {
        path = castPath(path, object4);
        var index = 0, length = path.length;
        while (object4 != null && index < length) {
          object4 = object4[toKey(path[index++])];
        }
        return index && index == length ? object4 : void 0;
      }
      function get(object4, path, defaultValue) {
        var result = object4 == null ? void 0 : baseGet(object4, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array4, values) {
        var index = -1, length = values.length, offset = array4.length;
        while (++index < length) {
          array4[offset + index] = values[index];
        }
        return array4;
      }
      var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array4, depth, predicate, isStrict, result) {
        var index = -1, length = array4.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array4[index];
          if (predicate(value)) {
            {
              arrayPush(result, value);
            }
          } else {
            result[result.length] = value;
          }
        }
        return result;
      }
      function flatten(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseFlatten(array4) : [];
      }
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten), func + "");
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      var objectTag$3 = "[object Object]";
      var funcProto = Function.prototype, objectProto$4 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data2 = this.__data__, result = data2["delete"](key);
        this.size = data2.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs = data2.__data__;
          if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs);
        }
        data2.set(key, value);
        this.size = data2.size;
        return this;
      }
      function Stack(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function baseAssign(object4, source) {
        return object4 && copyObject(source, keys(source), object4);
      }
      function baseAssignIn(object4, source) {
        return object4 && copyObject(source, keysIn(source), object4);
      }
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      function arrayFilter(array4, predicate) {
        var index = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array4[index];
          if (predicate(value, index, array4)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$3 = Object.prototype;
      var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
      var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object4) {
        if (object4 == null) {
          return [];
        }
        object4 = Object(object4);
        return arrayFilter(nativeGetSymbols$1(object4), function(symbol) {
          return propertyIsEnumerable.call(object4, symbol);
        });
      };
      function copySymbols(source, object4) {
        return copyObject(source, getSymbols(source), object4);
      }
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object4) {
        var result = [];
        while (object4) {
          arrayPush(result, getSymbols(object4));
          object4 = getPrototype(object4);
        }
        return result;
      };
      function copySymbolsIn(source, object4) {
        return copyObject(source, getSymbolsIn(source), object4);
      }
      function baseGetAllKeys(object4, keysFunc, symbolsFunc) {
        var result = keysFunc(object4);
        return isArray(object4) ? result : arrayPush(result, symbolsFunc(object4));
      }
      function getAllKeys(object4) {
        return baseGetAllKeys(object4, keys, getSymbols);
      }
      var DataView = getNative(root$1, "DataView");
      var Promise$1 = getNative(root$1, "Promise");
      var Set$1 = getNative(root$1, "Set");
      var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
      var dataViewTag$3 = "[object DataView]";
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$3;
              case mapCtorString:
                return mapTag$4;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$4;
              case weakMapCtorString:
                return weakMapTag$1;
            }
          }
          return result;
        };
      }
      var objectProto$2 = Object.prototype;
      var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
      function initCloneArray(array4) {
        var length = array4.length, result = new array4.constructor(length);
        if (length && typeof array4[0] == "string" && hasOwnProperty$2.call(array4, "index")) {
          result.index = array4.index;
          result.input = array4.input;
        }
        return result;
      }
      var Uint8Array$1 = root$1.Uint8Array;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      var reFlags = /\w*$/;
      function cloneRegExp(regexp4) {
        var result = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
        result.lastIndex = regexp4.lastIndex;
        return result;
      }
      var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
      var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
      function initCloneByTag(object4, tag, isDeep) {
        var Ctor = object4.constructor;
        switch (tag) {
          case arrayBufferTag$2:
            return cloneArrayBuffer(object4);
          case boolTag$2:
          case dateTag$2:
            return new Ctor(+object4);
          case dataViewTag$2:
            return cloneDataView(object4);
          case float32Tag$1:
          case float64Tag$1:
          case int8Tag$1:
          case int16Tag$1:
          case int32Tag$1:
          case uint8Tag$1:
          case uint8ClampedTag$1:
          case uint16Tag$1:
          case uint32Tag$1:
            return cloneTypedArray(object4, isDeep);
          case mapTag$3:
            return new Ctor();
          case numberTag$2:
          case stringTag$2:
            return new Ctor(object4);
          case regexpTag$2:
            return cloneRegExp(object4);
          case setTag$3:
            return new Ctor();
          case symbolTag$2:
            return cloneSymbol(object4);
        }
      }
      function initCloneObject(object4) {
        return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate(getPrototype(object4)) : {};
      }
      var mapTag$2 = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag$2;
      }
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      var setTag$2 = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag$2;
      }
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object4, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG;
        if (result !== void 0) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object4) {
            result = isFunc ? {} : initCloneObject(value);
            {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object4 ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = getAllKeys;
        var props2 = isArr ? void 0 : keysFunc(value);
        arrayEach(props2 || value, function(subValue, key2) {
          if (props2) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      var CLONE_SYMBOLS_FLAG = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array4, predicate) {
        var index = -1, length = array4 == null ? 0 : array4.length;
        while (++index < length) {
          if (predicate(array4[index], index, array4)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays(array4, other2, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array4.length, othLength = other2.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array4);
        var othStacked = stack.get(other2);
        if (arrStacked && othStacked) {
          return arrStacked == other2 && othStacked == array4;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
        stack.set(array4, other2);
        stack.set(other2, array4);
        while (++index < arrLength) {
          var arrValue = array4[index], othValue = other2[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other2, array4, stack) : customizer(arrValue, othValue, index, array4, other2, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other2, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array4);
        stack["delete"](other2);
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object4, other2, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object4.byteLength != other2.byteLength || object4.byteOffset != other2.byteOffset) {
              return false;
            }
            object4 = object4.buffer;
            other2 = other2.buffer;
          case arrayBufferTag:
            if (object4.byteLength != other2.byteLength || !equalFunc(new Uint8Array$1(object4), new Uint8Array$1(other2))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object4, +other2);
          case errorTag:
            return object4.name == other2.name && object4.message == other2.message;
          case regexpTag:
          case stringTag:
            return object4 == other2 + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert || (convert = setToArray);
            if (object4.size != other2.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object4);
            if (stacked) {
              return stacked == other2;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack.set(object4, other2);
            var result = equalArrays(convert(object4), convert(other2), bitmask, customizer, equalFunc, stack);
            stack["delete"](object4);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object4) == symbolValueOf.call(other2);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function equalObjects(object4, other2, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other2), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other2 : hasOwnProperty$1.call(other2, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object4);
        var othStacked = stack.get(other2);
        if (objStacked && othStacked) {
          return objStacked == other2 && othStacked == object4;
        }
        var result = true;
        stack.set(object4, other2);
        stack.set(other2, object4);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object4[key], othValue = other2[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other2, object4, stack) : customizer(objValue, othValue, key, object4, other2, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object4.constructor, othCtor = other2.constructor;
          if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other2) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object4);
        stack["delete"](other2);
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object4, other2, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object4), othIsArr = isArray(other2), objTag = objIsArr ? arrayTag : getTag(object4), othTag = othIsArr ? arrayTag : getTag(other2);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object4)) {
          if (!isBuffer(other2)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object4) ? equalArrays(object4, other2, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other2, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other2, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other2.value() : other2;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object4, other2, bitmask, customizer, equalFunc, stack);
      }
      function baseIsEqual(value, other2, bitmask, customizer, stack) {
        if (value === other2) {
          return true;
        }
        if (value == null || other2 == null || !isObjectLike(value) && !isObjectLike(other2)) {
          return value !== value && other2 !== other2;
        }
        return baseIsEqualDeep(value, other2, bitmask, customizer, baseIsEqual, stack);
      }
      var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch(object4, source, matchData, customizer) {
        var index = matchData.length, length = index;
        if (object4 == null) {
          return !length;
        }
        object4 = Object(object4);
        while (index--) {
          var data2 = matchData[index];
          if (data2[2] ? data2[1] !== object4[data2[0]] : !(data2[0] in object4)) {
            return false;
          }
        }
        while (++index < length) {
          data2 = matchData[index];
          var key = data2[0], objValue = object4[key], srcValue = data2[1];
          if (data2[2]) {
            if (objValue === void 0 && !(key in object4)) {
              return false;
            }
          } else {
            var stack = new Stack();
            var result;
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function getMatchData(object4) {
        var result = keys(object4), length = result.length;
        while (length--) {
          var key = result[length], value = object4[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object4) {
          if (object4 == null) {
            return false;
          }
          return object4[key] === srcValue && (srcValue !== void 0 || key in Object(object4));
        };
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object4) {
          return object4 === source || baseIsMatch(object4, source, matchData);
        };
      }
      function baseHasIn(object4, key) {
        return object4 != null && key in Object(object4);
      }
      function hasPath(object4, path, hasFunc) {
        path = castPath(path, object4);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object4 != null && hasFunc(object4, key))) {
            break;
          }
          object4 = object4[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object4 == null ? 0 : object4.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object4) || isArguments(object4));
      }
      function hasIn(object4, path) {
        return object4 != null && hasPath(object4, path, baseHasIn);
      }
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object4) {
          var objValue = get(object4, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object4, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseProperty(key) {
        return function(object4) {
          return object4 == null ? void 0 : object4[key];
        };
      }
      function basePropertyDeep(path) {
        return function(object4) {
          return baseGet(object4, path);
        };
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function createBaseFor(fromRight) {
        return function(object4, iteratee, keysFunc) {
          var index = -1, iterable = Object(object4), props2 = keysFunc(object4), length = props2.length;
          while (length--) {
            var key = props2[++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object4;
        };
      }
      var baseFor = createBaseFor();
      function baseForOwn(object4, iteratee) {
        return object4 && baseFor(object4, iteratee, keys);
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = -1, iterable = Object(collection);
          while (++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      var baseEach = createBaseEach(baseForOwn);
      var now = function() {
        return root$1.Date.now();
      };
      var FUNC_ERROR_TEXT = "Expected a function";
      var nativeMax = Math.max, nativeMin = Math.min;
      function debounce(func, wait, options2) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options2)) {
          leading = !!options2.leading;
          maxing = "maxWait" in options2;
          maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options2 ? !!options2.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function assignMergeValue(object4, key, value) {
        if (value !== void 0 && !eq(object4[key], value) || value === void 0 && !(key in object4)) {
          baseAssignValue(object4, key, value);
        }
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function safeGet(object4, key) {
        if (key === "constructor" && typeof object4[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object4[key];
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function baseMergeDeep(object4, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object4, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object4, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object4, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object4, key, newValue);
      }
      function baseMerge(object4, source, srcIndex, customizer, stack) {
        if (object4 === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object4, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object4, key), srcValue, key + "", object4, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object4, key, newValue);
          }
        }, keysIn);
      }
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee));
      }
      function flatMap(collection, iteratee) {
        return baseFlatten(map(collection, iteratee));
      }
      function isEqual(value, other2) {
        return baseIsEqual(value, other2);
      }
      function isNull(value) {
        return value === null;
      }
      function isUndefined(value) {
        return value === void 0;
      }
      var merge = createAssigner(function(object4, source, srcIndex) {
        baseMerge(object4, source, srcIndex);
      });
      function baseSet(object4, path, value, customizer) {
        if (!isObject(object4)) {
          return object4;
        }
        path = castPath(path, object4);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object4;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object4;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object4;
      }
      function basePickBy(object4, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object4, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object4), value);
          }
        }
        return result;
      }
      function basePick(object4, paths) {
        return basePickBy(object4, paths, function(value, path) {
          return hasIn(object4, path);
        });
      }
      var pick = flatRest(function(object4, paths) {
        return object4 == null ? {} : basePick(object4, paths);
      });
      function set(object4, path, value) {
        return object4 == null ? object4 : baseSet(object4, path, value);
      }
      function unrefElement(elRef) {
        var _a;
        const plain = resolveUnref(elRef);
        return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      function useEventListener(...args) {
        let target;
        let events2;
        let listeners;
        let options2;
        if (isString$1(args[0]) || Array.isArray(args[0])) {
          [events2, listeners, options2] = args;
          target = defaultWindow;
        } else {
          [target, events2, listeners, options2] = args;
        }
        if (!target)
          return noop$1;
        if (!Array.isArray(events2))
          events2 = [events2];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register2 = (el, event, listener, options22) => {
          el.addEventListener(event, listener, options22);
          return () => el.removeEventListener(event, listener, options22);
        };
        const stopWatch = watch(() => [unrefElement(target), resolveUnref(options2)], ([el, options22]) => {
          cleanup();
          if (!el)
            return;
          cleanups.push(...events2.flatMap((event) => {
            return listeners.map((listener) => register2(el, event, listener, options22));
          }));
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options2 = {}) {
        const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options2;
        if (!window2)
          return;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$1));
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement(target);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup = [
          useEventListener(window2, "click", listener, { passive: true, capture }),
          useEventListener(window2, "pointerdown", (e) => {
            const el = unrefElement(target);
            if (el)
              shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
          }, { passive: true }),
          detectIframe && useEventListener(window2, "blur", (event) => {
            var _a;
            const el = unrefElement(target);
            if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event);
          })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn2) => fn2());
        return stop;
      }
      function useActiveElement(options2 = {}) {
        var _a;
        const { window: window2 = defaultWindow } = options2;
        const document2 = (_a = options2.document) != null ? _a : window2 == null ? void 0 : window2.document;
        const activeElement = computedWithControl(() => null, () => document2 == null ? void 0 : document2.activeElement);
        if (window2) {
          useEventListener(window2, "blur", (event) => {
            if (event.relatedTarget !== null)
              return;
            activeElement.trigger();
          }, true);
          useEventListener(window2, "focus", activeElement.trigger, true);
        }
        return activeElement;
      }
      function useSupported(callback, sync = false) {
        const isSupported = ref();
        const update = () => isSupported.value = Boolean(callback());
        update();
        tryOnMounted(update, sync);
        return isSupported;
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      _global[globalKey] = _global[globalKey] || {};
      var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
      var __hasOwnProp$g = Object.prototype.hasOwnProperty;
      var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
      var __objRest$2 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$g)
          for (var prop of __getOwnPropSymbols$g(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useResizeObserver(target, callback, options2 = {}) {
        const _a = options2, { window: window2 = defaultWindow } = _a, observerOptions = __objRest$2(_a, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new ResizeObserver(callback);
            observer.observe(el, observerOptions);
          }
        }, { immediate: true, flush: "post" });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var __defProp2 = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp.call(b2, prop))
            __defNormalProp2(a2, prop, b2[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b2)) {
            if (__propIsEnum.call(b2, prop))
              __defNormalProp2(a2, prop, b2[prop]);
          }
        return a2;
      };
      const _TransitionPresets = {
        easeInSine: [0.12, 0, 0.39, 0],
        easeOutSine: [0.61, 1, 0.88, 1],
        easeInOutSine: [0.37, 0, 0.63, 1],
        easeInQuad: [0.11, 0, 0.5, 0],
        easeOutQuad: [0.5, 1, 0.89, 1],
        easeInOutQuad: [0.45, 0, 0.55, 1],
        easeInCubic: [0.32, 0, 0.67, 0],
        easeOutCubic: [0.33, 1, 0.68, 1],
        easeInOutCubic: [0.65, 0, 0.35, 1],
        easeInQuart: [0.5, 0, 0.75, 0],
        easeOutQuart: [0.25, 1, 0.5, 1],
        easeInOutQuart: [0.76, 0, 0.24, 1],
        easeInQuint: [0.64, 0, 0.78, 0],
        easeOutQuint: [0.22, 1, 0.36, 1],
        easeInOutQuint: [0.83, 0, 0.17, 1],
        easeInExpo: [0.7, 0, 0.84, 0],
        easeOutExpo: [0.16, 1, 0.3, 1],
        easeInOutExpo: [0.87, 0, 0.13, 1],
        easeInCirc: [0.55, 0, 1, 0.45],
        easeOutCirc: [0, 0.55, 0.45, 1],
        easeInOutCirc: [0.85, 0, 0.15, 1],
        easeInBack: [0.36, 0, 0.66, -0.56],
        easeOutBack: [0.34, 1.56, 0.64, 1],
        easeInOutBack: [0.68, -0.6, 0.32, 1.6]
      };
      __spreadValues({
        linear: identity$1
      }, _TransitionPresets);
      class ElementPlusError extends Error {
        constructor(m2) {
          super(m2);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m2) {
        throw new ElementPlusError(`[${scope}] ${m2}`);
      }
      function debugWarn(scope, message) {
      }
      const initial = {
        current: 0
      };
      const zIndex = ref(0);
      const defaultInitialZIndex = 2e3;
      const ZINDEX_INJECTION_KEY = Symbol("elZIndexContextKey");
      const zIndexContextKey = Symbol("zIndexContextKey");
      const useZIndex = (zIndexOverrides) => {
        const increasingInjection = getCurrentInstance() ? inject(ZINDEX_INJECTION_KEY, initial) : initial;
        const zIndexInjection = getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0;
        const initialZIndex = computed(() => {
          const zIndexFromInjection = unref(zIndexInjection);
          return isNumber$1(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          increasingInjection.current++;
          zIndex.value = increasingInjection.current;
          return currentZIndex.value;
        };
        if (!isClient && !inject(ZINDEX_INJECTION_KEY)) ;
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      };
      var English = {
        name: "en",
        el: {
          breadcrumb: {
            label: "Breadcrumb"
          },
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color.",
            alphaLabel: "pick alpha value"
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          mention: {
            loading: "Loading"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tour: {
            next: "Next",
            previous: "Previous",
            finish: "Finish"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          },
          carousel: {
            leftArrow: "Carousel arrow left",
            rightArrow: "Carousel arrow right",
            indicator: "Carousel switch to index {index}"
          }
        }
      };
      const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
      const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
        var _a;
        return `${(_a = option == null ? void 0 : option[key]) != null ? _a : `{${key}}`}`;
      });
      const buildLocaleContext = (locale) => {
        const lang = computed(() => unref(locale).name);
        const localeRef = isRef(locale) ? locale : ref(locale);
        return {
          lang,
          locale: localeRef,
          t: buildTranslator(locale)
        };
      };
      const localeContextKey = Symbol("localeContextKey");
      const useLocale = (localeOverrides) => {
        const locale = inject(localeContextKey, ref());
        return buildLocaleContext(computed(() => locale.value || English));
      };
      const keysOf = (arr) => Object.keys(arr);
      const getProp = (obj, path, defaultValue) => {
        return {
          get value() {
            return get(obj, path, defaultValue);
          },
          set value(val) {
            set(obj, path, val);
          }
        };
      };
      const UPDATE_MODEL_EVENT = "update:modelValue";
      const CHANGE_EVENT = "change";
      const INPUT_EVENT = "input";
      const rAF = (fn2) => isClient ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
      let scrollBarWidth;
      const getScrollBarWidth = (namespace) => {
        var _a;
        if (!isClient)
          return 0;
        if (scrollBarWidth !== void 0)
          return scrollBarWidth;
        const outer = document.createElement("div");
        outer.className = `${namespace}-scrollbar__wrap`;
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.position = "absolute";
        outer.style.top = "-9999px";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        (_a = outer.parentNode) == null ? void 0 : _a.removeChild(outer);
        scrollBarWidth = widthNoScroll - widthWithScroll;
        return scrollBarWidth;
      };
      const alertEffects = ["light", "dark"];
      const alertProps = buildProps({
        title: {
          type: String,
          default: ""
        },
        description: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          values: keysOf(TypeComponentsMap),
          default: "info"
        },
        closable: {
          type: Boolean,
          default: true
        },
        closeText: {
          type: String,
          default: ""
        },
        showIcon: Boolean,
        center: Boolean,
        effect: {
          type: String,
          values: alertEffects,
          default: "light"
        }
      });
      const alertEmits = {
        close: (evt) => evt instanceof MouseEvent
      };
      const __default__$w = defineComponent({
        name: "ElAlert"
      });
      const _sfc_main$X = /* @__PURE__ */ defineComponent({
        ...__default__$w,
        props: alertProps,
        emits: alertEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const { Close } = TypeComponents;
          const slots = useSlots();
          const ns = useNamespace("alert");
          const visible = ref(true);
          const iconComponent = computed(() => TypeComponentsMap[props2.type]);
          const hasDesc = computed(() => !!(props2.description || slots.default));
          const close = (evt) => {
            visible.value = false;
            emit("close", evt);
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createElementVNode("div", {
                  class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.type), unref(ns).is("center", _ctx.center), unref(ns).is(_ctx.effect)]),
                  role: "alert"
                }, [
                  _ctx.showIcon && unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon$1), {
                    key: 0,
                    class: normalizeClass([unref(ns).e("icon"), { [unref(ns).is("big")]: unref(hasDesc) }])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      class: normalizeClass([unref(ns).e("title"), { "with-description": unref(hasDesc) }])
                    }, [
                      renderSlot(_ctx.$slots, "title", {}, () => [
                        createTextVNode(toDisplayString(_ctx.title), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true),
                    unref(hasDesc) ? (openBlock(), createElementBlock("p", {
                      key: 1,
                      class: normalizeClass(unref(ns).e("description"))
                    }, [
                      renderSlot(_ctx.$slots, "default", {}, () => [
                        createTextVNode(toDisplayString(_ctx.description), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true),
                    _ctx.closable ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                      _ctx.closeText ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        class: normalizeClass([unref(ns).e("close-btn"), unref(ns).is("customed")]),
                        onClick: close
                      }, toDisplayString(_ctx.closeText), 3)) : (openBlock(), createBlock(unref(ElIcon$1), {
                        key: 1,
                        class: normalizeClass(unref(ns).e("close-btn")),
                        onClick: close
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(Close))
                        ]),
                        _: 1
                      }, 8, ["class"]))
                    ], 64)) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name"]);
          };
        }
      });
      var Alert = /* @__PURE__ */ _export_sfc$1(_sfc_main$X, [["__file", "alert.vue"]]);
      const ElAlert = withInstall(Alert);
      const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = {
        height: "0",
        visibility: "hidden",
        overflow: isFirefox() ? "" : "hidden",
        position: "absolute",
        "z-index": "-1000",
        top: "0",
        right: "0"
      };
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style3 = window.getComputedStyle(targetElement);
        const boxSizing = style3.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style3.getPropertyValue("padding-bottom")) + Number.parseFloat(style3.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style3.getPropertyValue("border-bottom-width")) + Number.parseFloat(style3.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => [
          name,
          style3.getPropertyValue(name)
        ]);
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          document.body.appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        contextStyle.forEach(([key, value]) => hiddenTextarea == null ? void 0 : hiddenTextarea.style.setProperty(key, value));
        Object.entries(HIDDEN_STYLE).forEach(([key, value]) => hiddenTextarea == null ? void 0 : hiddenTextarea.style.setProperty(key, value, "important"));
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber$1(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result.minHeight = `${minHeight}px`;
        }
        if (isNumber$1(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result.height = `${height}px`;
        (_a = hiddenTextarea.parentNode) == null ? void 0 : _a.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result;
      }
      const mutable = (val) => val;
      const ariaProps = buildProps({
        ariaLabel: String,
        ariaOrientation: {
          type: String,
          values: ["horizontal", "vertical", "undefined"]
        },
        ariaControls: String
      });
      const useAriaProps = (arias) => {
        return pick(ariaProps, arias);
      };
      const inputProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        maxlength: {
          type: [String, Number]
        },
        minlength: {
          type: [String, Number]
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: Boolean,
        clearable: Boolean,
        showPassword: Boolean,
        showWordLimit: Boolean,
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        },
        autofocus: Boolean,
        rows: {
          type: Number,
          default: 2
        },
        ...useAriaProps(["ariaLabel"])
      });
      const inputEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isString$2(value),
        input: (value) => isString$2(value),
        change: (value) => isString$2(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      };
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = computed(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = getCurrentInstance();
        if (!instance) {
          return computed(() => ({}));
        }
        return computed(() => {
          var _a;
          return fromPairs(Object.entries((_a = instance.proxy) == null ? void 0 : _a.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      };
      function useFocusController(target, {
        beforeFocus,
        afterFocus,
        beforeBlur,
        afterBlur
      } = {}) {
        const instance = getCurrentInstance();
        const { emit } = instance;
        const wrapperRef = shallowRef();
        const isFocused = ref(false);
        const handleFocus = (event) => {
          const cancelFocus = isFunction$2(beforeFocus) ? beforeFocus(event) : false;
          if (cancelFocus || isFocused.value)
            return;
          isFocused.value = true;
          emit("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a;
          const cancelBlur = isFunction$2(beforeBlur) ? beforeBlur(event) : false;
          if (cancelBlur || event.relatedTarget && ((_a = wrapperRef.value) == null ? void 0 : _a.contains(event.relatedTarget)))
            return;
          isFocused.value = false;
          emit("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = () => {
          var _a, _b;
          if (((_a = wrapperRef.value) == null ? void 0 : _a.contains(document.activeElement)) && wrapperRef.value !== document.activeElement)
            return;
          (_b = target.value) == null ? void 0 : _b.focus();
        };
        watch(wrapperRef, (el) => {
          if (el) {
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener(wrapperRef, "focus", handleFocus, true);
        useEventListener(wrapperRef, "blur", handleBlur, true);
        useEventListener(wrapperRef, "click", handleClick, true);
        return {
          isFocused,
          wrapperRef,
          handleFocus,
          handleBlur
        };
      }
      const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
      function useComposition({
        afterComposition,
        emit
      }) {
        const isComposing = ref(false);
        const handleCompositionStart = (event) => {
          emit == null ? void 0 : emit("compositionstart", event);
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          var _a;
          emit == null ? void 0 : emit("compositionupdate", event);
          const text = (_a = event.target) == null ? void 0 : _a.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          emit == null ? void 0 : emit("compositionend", event);
          if (isComposing.value) {
            isComposing.value = false;
            nextTick(() => afterComposition(event));
          }
        };
        const handleComposition = (event) => {
          event.type === "compositionend" ? handleCompositionEnd(event) : handleCompositionUpdate(event);
        };
        return {
          isComposing,
          handleComposition,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      function useCursor(input) {
        let selectionInfo;
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionInfo = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionInfo == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionInfo;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      const __default__$v = defineComponent({
        name: "ElInput",
        inheritAttrs: false
      });
      const _sfc_main$W = /* @__PURE__ */ defineComponent({
        ...__default__$v,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const rawAttrs = useAttrs$1();
          const attrs = useAttrs();
          const slots = useSlots();
          const containerKls = computed(() => [
            props2.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.m("prefix")]: slots.prefix || props2.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props2.suffixIcon || props2.clearable || props2.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value,
              [nsInput.b("hidden")]: props2.type === "hidden"
            },
            rawAttrs.class
          ]);
          const wrapperKls = computed(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const { form: elForm, formItem: elFormItem } = useFormItem();
          const { inputId } = useFormItemInputId(props2, {
            formItemContext: elFormItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = shallowRef();
          const textarea = shallowRef();
          const hovering = ref(false);
          const passwordVisible = ref(false);
          const countStyle = ref();
          const textareaCalcStyle = shallowRef(props2.inputStyle);
          const _ref = computed(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            beforeFocus() {
              return inputDisabled.value;
            },
            afterBlur() {
              var _a;
              if (props2.validateEvent) {
                (_a = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "blur").catch((err) => debugWarn());
              }
            }
          });
          const needStatusIcon = computed(() => {
            var _a;
            return (_a = elForm == null ? void 0 : elForm.statusIcon) != null ? _a : false;
          });
          const validateState = computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
          const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
          const containerStyle = computed(() => [
            rawAttrs.style
          ]);
          const textareaStyle = computed(() => [
            props2.inputStyle,
            textareaCalcStyle.value,
            { resize: props2.resize }
          ]);
          const nativeInputValue = computed(() => isNil(props2.modelValue) ? "" : String(props2.modelValue));
          const showClear = computed(() => props2.clearable && !inputDisabled.value && !props2.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = computed(() => props2.showPassword && !inputDisabled.value && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
          const isWordLimitVisible = computed(() => props2.showWordLimit && !!props2.maxlength && (props2.type === "text" || props2.type === "textarea") && !inputDisabled.value && !props2.readonly && !props2.showPassword);
          const textLength = computed(() => nativeInputValue.value.length);
          const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(props2.maxlength));
          const suffixVisible = computed(() => !!slots.suffix || !!props2.suffixIcon || showClear.value || props2.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props2.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type: type4, autosize } = props2;
            if (!isClient || type4 !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a;
              if (isInit || !props2.autosize)
                return;
              const isElHidden = ((_a = textarea.value) == null ? void 0 : _a.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props2.formatter ? props2.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props2.formatter && props2.parser) {
              value = props2.parser(value);
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit(UPDATE_MODEL_EVENT, value);
            emit("input", value);
            await nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            let { value } = event.target;
            if (props2.formatter && props2.parser) {
              value = props2.parser(value);
            }
            emit("change", value);
          };
          const {
            isComposing,
            handleCompositionStart,
            handleCompositionUpdate,
            handleCompositionEnd
          } = useComposition({ emit, afterComposition: handleInput });
          const handlePasswordVisible = () => {
            recordCursor();
            passwordVisible.value = !passwordVisible.value;
            setTimeout(setCursor);
          };
          const focus = () => {
            var _a;
            return (_a = _ref.value) == null ? void 0 : _a.focus();
          };
          const blur = () => {
            var _a;
            return (_a = _ref.value) == null ? void 0 : _a.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit("keydown", evt);
          };
          const select = () => {
            var _a;
            (_a = _ref.value) == null ? void 0 : _a.select();
          };
          const clear = () => {
            emit(UPDATE_MODEL_EVENT, "");
            emit("change", "");
            emit("clear");
            emit("input", "");
          };
          watch(() => props2.modelValue, () => {
            var _a;
            nextTick(() => resizeTextarea());
            if (props2.validateEvent) {
              (_a = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change").catch((err) => debugWarn());
            }
          });
          watch(nativeInputValue, () => setNativeInputValue());
          watch(() => props2.type, async () => {
            await nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          onMounted(() => {
            if (!props2.formatter && props2.parser) ;
            setNativeInputValue();
            nextTick(resizeTextarea);
          });
          expose({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: toRef(props2, "autosize"),
            isComposing,
            focus,
            blur,
            select,
            clear,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(containerKls),
                {
                  [unref(nsInput).bm("group", "append")]: _ctx.$slots.append,
                  [unref(nsInput).bm("group", "prepend")]: _ctx.$slots.prepend
                }
              ]),
              style: normalizeStyle(unref(containerStyle)),
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }, [
              createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).be("group", "prepend"))
                }, [
                  renderSlot(_ctx.$slots, "prepend")
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: normalizeClass(unref(wrapperKls))
                }, [
                  createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("prefix"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(nsInput).e("prefix-inner"))
                    }, [
                      renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon$1), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createElementVNode("input", mergeProps({
                    id: unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: unref(nsInput).e("inner")
                  }, unref(attrs), {
                    minlength: _ctx.minlength,
                    maxlength: _ctx.maxlength,
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: unref(inputDisabled),
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.ariaLabel,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: _ctx.form,
                    autofocus: _ctx.autofocus,
                    role: _ctx.containerRole,
                    onCompositionstart: unref(handleCompositionStart),
                    onCompositionupdate: unref(handleCompositionUpdate),
                    onCompositionend: unref(handleCompositionEnd),
                    onInput: handleInput,
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus", "role", "onCompositionstart", "onCompositionupdate", "onCompositionend"]),
                  createCommentVNode(" suffix slot "),
                  unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(nsInput).e("suffix"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(nsInput).e("suffix-inner"))
                    }, [
                      !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon$1), {
                          key: 0,
                          class: normalizeClass(unref(nsInput).e("icon"))
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 64)) : createCommentVNode("v-if", true),
                      unref(showClear) ? (openBlock(), createBlock(unref(ElIcon$1), {
                        key: 1,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                        onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                        onClick: clear
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_close_default))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                      unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon$1), {
                        key: 2,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                        key: 3,
                        class: normalizeClass(unref(nsInput).e("count"))
                      }, [
                        createElementVNode("span", {
                          class: normalizeClass(unref(nsInput).e("count-inner"))
                        }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 3)
                      ], 2)) : createCommentVNode("v-if", true),
                      unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon$1), {
                        key: 4,
                        class: normalizeClass([
                          unref(nsInput).e("icon"),
                          unref(nsInput).e("validateIcon"),
                          unref(nsInput).is("loading", unref(validateState) === "validating")
                        ])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createCommentVNode(" append slot "),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).be("group", "append"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" textarea "),
                createElementVNode("textarea", mergeProps({
                  id: unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: [unref(nsTextarea).e("inner"), unref(nsInput).is("focus", unref(isFocused))]
                }, unref(attrs), {
                  minlength: _ctx.minlength,
                  maxlength: _ctx.maxlength,
                  tabindex: _ctx.tabindex,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: unref(textareaStyle),
                  "aria-label": _ctx.ariaLabel,
                  placeholder: _ctx.placeholder,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  rows: _ctx.rows,
                  role: _ctx.containerRole,
                  onCompositionstart: unref(handleCompositionStart),
                  onCompositionupdate: unref(handleCompositionUpdate),
                  onCompositionend: unref(handleCompositionEnd),
                  onInput: handleInput,
                  onFocus: unref(handleFocus),
                  onBlur: unref(handleBlur),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus", "rows", "role", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onFocus", "onBlur"]),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  style: normalizeStyle(countStyle.value),
                  class: normalizeClass(unref(nsInput).e("count"))
                }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 7)) : createCommentVNode("v-if", true)
              ], 64))
            ], 38);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$W, [["__file", "input.vue"]]);
      const ElInput = withInstall(Input);
      const GAP = 4;
      const BAR_MAP = {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      };
      const renderThumbStyle = ({
        move,
        size,
        bar
      }) => ({
        [bar.size]: size,
        transform: `translate${bar.axis}(${move}%)`
      });
      const scrollbarContextKey = Symbol("scrollbarContextKey");
      const thumbProps = buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      });
      const COMPONENT_NAME$4 = "Thumb";
      const _sfc_main$V = /* @__PURE__ */ defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props2 = __props;
          const scrollbar = inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$4, "can not inject scrollbar context");
          const instance = ref();
          const thumb = ref();
          const thumbState = ref({});
          const visible = ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let originalOnSelectStart = isClient ? document.onselectstart : null;
          const bar = computed(() => BAR_MAP[props2.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = computed(() => renderThumbStyle({
            size: props2.size,
            move: props2.move,
            bar: bar.value
          }));
          const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props2.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e) => {
            var _a;
            e.stopPropagation();
            if (e.ctrlKey || [1, 2].includes(e.button))
              return;
            (_a = window.getSelection()) == null ? void 0 : _a.removeAllRanges();
            startDrag(e);
            const el = e.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e) => {
            e.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props2.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createElementVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                  onMousedown: clickTrackHandler
                }, [
                  createElementVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: normalizeClass(unref(ns).e("thumb")),
                    style: normalizeStyle(unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 34), [
                  [vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc$1(_sfc_main$V, [["__file", "thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        minSize: {
          type: Number,
          required: true
        }
      });
      const _sfc_main$U = /* @__PURE__ */ defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const scrollbar = inject(scrollbarContextKey);
          const moveX = ref(0);
          const moveY = ref(0);
          const sizeWidth = ref("");
          const sizeHeight = ref("");
          const ratioY = ref(1);
          const ratioX = ref(1);
          const handleScroll = (wrap) => {
            if (wrap) {
              const offsetHeight = wrap.offsetHeight - GAP;
              const offsetWidth = wrap.offsetWidth - GAP;
              moveY.value = wrap.scrollTop * 100 / offsetHeight * ratioY.value;
              moveX.value = wrap.scrollLeft * 100 / offsetWidth * ratioX.value;
            }
          };
          const update = () => {
            const wrap = scrollbar == null ? void 0 : scrollbar.wrapElement;
            if (!wrap)
              return;
            const offsetHeight = wrap.offsetHeight - GAP;
            const offsetWidth = wrap.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrap.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrap.scrollWidth;
            const height = Math.max(originalHeight, props2.minSize);
            const width = Math.max(originalWidth, props2.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          expose({
            handleScroll,
            update
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(Thumb, {
                move: moveX.value,
                ratio: ratioX.value,
                size: sizeWidth.value,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              createVNode(Thumb, {
                move: moveY.value,
                ratio: ratioY.value,
                size: sizeHeight.value,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc$1(_sfc_main$U, [["__file", "bar.vue"]]);
      const scrollbarProps = buildProps({
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: {
          type: Boolean,
          default: false
        },
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        },
        tabindex: {
          type: [String, Number],
          default: void 0
        },
        id: String,
        role: String,
        ...useAriaProps(["ariaLabel", "ariaOrientation"])
      });
      const scrollbarEmits = {
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber$1)
      };
      const COMPONENT_NAME$3 = "ElScrollbar";
      const __default__$u = defineComponent({
        name: COMPONENT_NAME$3
      });
      const _sfc_main$T = /* @__PURE__ */ defineComponent({
        ...__default__$u,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopResizeListener = void 0;
          let wrapScrollTop = 0;
          let wrapScrollLeft = 0;
          const scrollbarRef = ref();
          const wrapRef = ref();
          const resizeRef = ref();
          const barRef = ref();
          const wrapStyle = computed(() => {
            const style3 = {};
            if (props2.height)
              style3.height = addUnit(props2.height);
            if (props2.maxHeight)
              style3.maxHeight = addUnit(props2.maxHeight);
            return [props2.wrapStyle, style3];
          });
          const wrapKls = computed(() => {
            return [
              props2.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props2.native }
            ];
          });
          const resizeKls = computed(() => {
            return [ns.e("view"), props2.viewClass];
          });
          const handleScroll = () => {
            var _a;
            if (wrapRef.value) {
              (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);
              wrapScrollTop = wrapRef.value.scrollTop;
              wrapScrollLeft = wrapRef.value.scrollLeft;
              emit("scroll", {
                scrollTop: wrapRef.value.scrollTop,
                scrollLeft: wrapRef.value.scrollLeft
              });
            }
          };
          function scrollTo(arg1, arg2) {
            if (isObject$1(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber$1(arg1) && isNumber$1(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber$1(value)) {
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber$1(value)) {
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update = () => {
            var _a;
            (_a = barRef.value) == null ? void 0 : _a.update();
          };
          watch(() => props2.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
              stopResizeListener = useEventListener("resize", update);
            }
          }, { immediate: true });
          watch(() => [props2.maxHeight, props2.height], () => {
            if (!props2.native)
              nextTick(() => {
                var _a;
                update();
                if (wrapRef.value) {
                  (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);
                }
              });
          });
          provide(scrollbarContextKey, reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          onActivated(() => {
            if (wrapRef.value) {
              wrapRef.value.scrollTop = wrapScrollTop;
              wrapRef.value.scrollLeft = wrapScrollLeft;
            }
          });
          onMounted(() => {
            if (!props2.native)
              nextTick(() => {
                update();
              });
          });
          onUpdated(() => update());
          expose({
            wrapRef,
            update,
            scrollTo,
            setScrollTop,
            setScrollLeft,
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: normalizeClass(unref(ns).b())
            }, [
              createElementVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: normalizeClass(unref(wrapKls)),
                style: normalizeStyle(unref(wrapStyle)),
                tabindex: _ctx.tabindex,
                onScroll: handleScroll
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                  id: _ctx.id,
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: normalizeClass(unref(resizeKls)),
                  style: normalizeStyle(_ctx.viewStyle),
                  role: _ctx.role,
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": _ctx.ariaOrientation
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
              ], 46, ["tabindex"]),
              !_ctx.native ? (openBlock(), createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                always: _ctx.always,
                "min-size": _ctx.minSize
              }, null, 8, ["always", "min-size"])) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["__file", "scrollbar.vue"]]);
      const ElScrollbar = withInstall(Scrollbar);
      const POPPER_INJECTION_KEY = Symbol("popper");
      const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
      const roleTypes = [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ];
      const popperProps = buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      });
      const __default__$t = defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$S = /* @__PURE__ */ defineComponent({
        ...__default__$t,
        props: popperProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const triggerRef = ref();
          const popperInstanceRef = ref();
          const contentRef = ref();
          const referenceRef = ref();
          const role = computed(() => props2.role);
          const popperProvides = {
            triggerRef,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose(popperProvides);
          provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc$1(_sfc_main$S, [["__file", "popper.vue"]]);
      const popperArrowProps = buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      });
      const __default__$s = defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$R = /* @__PURE__ */ defineComponent({
        ...__default__$s,
        props: popperArrowProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("popper");
          const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          watch(() => props2.arrowOffset, (val) => {
            arrowOffset.value = val;
          });
          onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose({
            arrowRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: normalizeClass(unref(ns).e("arrow")),
              style: normalizeStyle(unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = /* @__PURE__ */ _export_sfc$1(_sfc_main$R, [["__file", "arrow.vue"]]);
      const popperTriggerProps = buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      });
      const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
      const useForwardRef = (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      };
      const useForwardRefDirective = (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      };
      const isFocusable = (element) => {
        if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
          return true;
        }
        if (element.tabIndex < 0 || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true") {
          return false;
        }
        switch (element.nodeName) {
          case "A": {
            return !!element.href && element.rel !== "ignore";
          }
          case "INPUT": {
            return !(element.type === "hidden" || element.type === "file");
          }
          case "BUTTON":
          case "SELECT":
          case "TEXTAREA": {
            return true;
          }
          default: {
            return false;
          }
        }
      };
      const NAME = "ElOnlyChild";
      const OnlyChild = defineComponent({
        name: NAME,
        setup(_2, {
          slots,
          attrs
        }) {
          var _a;
          const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a : NOOP);
          return () => {
            var _a2;
            const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              return null;
            }
            return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node) {
        if (!node)
          return null;
        const children = node;
        for (const child of children) {
          if (isObject$1(child)) {
            switch (child.type) {
              case Comment:
                continue;
              case Text$1:
              case "svg":
                return wrapTextContent(child);
              case Fragment:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s2) {
        const ns = useNamespace("only-child");
        return createVNode("span", {
          "class": ns.e("content")
        }, [s2]);
      }
      const __default__$r = defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$Q = /* @__PURE__ */ defineComponent({
        ...__default__$r,
        props: popperTriggerProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const { role, triggerRef } = inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef);
          const ariaControls = computed(() => {
            return ariaHaspopup.value ? props2.id : void 0;
          });
          const ariaDescribedby = computed(() => {
            if (role && role.value === "tooltip") {
              return props2.open && props2.id ? props2.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = computed(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = computed(() => {
            return ariaHaspopup.value ? `${props2.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          const TRIGGER_ELE_EVENTS = [
            "onMouseenter",
            "onMouseleave",
            "onClick",
            "onKeydown",
            "onFocus",
            "onBlur",
            "onContextmenu"
          ];
          onMounted(() => {
            watch(() => props2.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef.value = unrefElement(virtualEl);
              }
            }, {
              immediate: true
            });
            watch(triggerRef, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement(el)) {
                TRIGGER_ELE_EVENTS.forEach((eventName) => {
                  var _a;
                  const handler = props2[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                if (isFocusable(el)) {
                  virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                    [
                      "aria-controls",
                      "aria-describedby",
                      "aria-haspopup",
                      "aria-expanded"
                    ].forEach((key, idx) => {
                      isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                    });
                  }, { immediate: true });
                }
              }
              if (isElement(prevEl) && isFocusable(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
            if (triggerRef.value && isElement(triggerRef.value)) {
              const el = triggerRef.value;
              TRIGGER_ELE_EVENTS.forEach((eventName) => {
                const handler = props2[eventName];
                if (handler) {
                  el.removeEventListener(eventName.slice(2).toLowerCase(), handler);
                }
              });
              triggerRef.value = void 0;
            }
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": unref(ariaControls),
              "aria-describedby": unref(ariaDescribedby),
              "aria-expanded": unref(ariaExpanded),
              "aria-haspopup": unref(ariaHaspopup)
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$Q, [["__file", "trigger.vue"]]);
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = ref();
      const lastUserFocusTimestamp = ref(0);
      const lastAutomatedFocusTimestamp = ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first = getVisibleElement(focusable, container);
        const last = getVisibleElement(focusable.reverse(), container);
        return [first, last];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          let cleanup = false;
          if (isElement(element) && !isFocusable(element) && !element.getAttribute("tabindex")) {
            element.setAttribute("tabindex", "-1");
            cleanup = true;
          }
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
          if (isElement(element) && cleanup) {
            element.removeAttribute("tabindex");
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack = [];
        const push = (layer) => {
          const currentLayer = stack[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack = removeFromStack(stack, layer);
          stack.unshift(layer);
        };
        const remove = (layer) => {
          var _a, _b;
          stack = removeFromStack(stack, layer);
          (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);
        };
        return {
          push,
          remove
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const EVENT_CODE = {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        left: "ArrowLeft",
        up: "ArrowUp",
        right: "ArrowRight",
        down: "ArrowDown",
        esc: "Escape",
        numpadEnter: "NumpadEnter"
      };
      let registeredEscapeHandlers = [];
      const cachedHandler = (event) => {
        if (event.code === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = (handler) => {
        onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient)
            registeredEscapeHandlers.push(handler);
        });
        onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      };
      const _sfc_main$P = defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props2, { emit }) {
          const forwardRef = ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props2.trapped && !focusLayer.paused) {
              emit("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e) => {
            if (!props2.loop && !props2.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { code, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
            const { loop } = props2;
            const isTabbing = code === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first, last] = getEdges(container);
              const isTabbable = first && last;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(first, true);
                  }
                } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(last, true);
                  }
                }
              }
            }
          };
          provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          watch(() => props2.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e) => {
            emit(ON_TRAP_FOCUS_EVT, e);
          };
          const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);
          const onFocusIn = (e) => {
            const trapContainer = unref(forwardRef);
            if (!trapContainer)
              return;
            const target = e.target;
            const relatedTarget = e.relatedTarget;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!props2.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit("focusin", e);
            if (focusLayer.paused)
              return;
            if (props2.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e) => {
            const trapContainer = unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props2.trapped) {
              const relatedTarget = e.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props2.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target = e.target;
              const isFocusedInTrap = target && trapContainer.contains(target);
              if (!isFocusedInTrap)
                emit("focusout", e);
            }
          };
          async function startTrap() {
            await nextTick();
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  nextTick(() => {
                    let focusStartEl = props2.focusStartEl;
                    if (!isString$2(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          onMounted(() => {
            if (props2.trapped) {
              startTrap();
            }
            watch(() => props2.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          onBeforeUnmount(() => {
            if (props2.trapped) {
              stopTrap();
            }
            if (forwardRef.value) {
              forwardRef.value.removeEventListener("keydown", onKeydown);
              forwardRef.value.removeEventListener("focusin", onFocusIn);
              forwardRef.value.removeEventListener("focusout", onFocusOut);
              forwardRef.value = void 0;
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["render", _sfc_render$7], ["__file", "focus-trap.vue"]]);
      var E$1 = "top", R = "bottom", W = "right", P$1 = "left", me = "auto", G = [E$1, R, W, P$1], U$1 = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
        return t.concat([e + "-" + U$1, e + "-" + J]);
      }, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
        return t.concat([e, e + "-" + U$1, e + "-" + J]);
      }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
      function C(t) {
        return t ? (t.nodeName || "").toLowerCase() : null;
      }
      function H(t) {
        if (t == null) return window;
        if (t.toString() !== "[object Window]") {
          var e = t.ownerDocument;
          return e && e.defaultView || window;
        }
        return t;
      }
      function Q(t) {
        var e = H(t).Element;
        return t instanceof e || t instanceof Element;
      }
      function B(t) {
        var e = H(t).HTMLElement;
        return t instanceof e || t instanceof HTMLElement;
      }
      function Pe(t) {
        if (typeof ShadowRoot == "undefined") return false;
        var e = H(t).ShadowRoot;
        return t instanceof e || t instanceof ShadowRoot;
      }
      function Mt(t) {
        var e = t.state;
        Object.keys(e.elements).forEach(function(n) {
          var r = e.styles[n] || {}, o2 = e.attributes[n] || {}, i = e.elements[n];
          !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o2).forEach(function(a2) {
            var s2 = o2[a2];
            s2 === false ? i.removeAttribute(a2) : i.setAttribute(a2, s2 === true ? "" : s2);
          }));
        });
      }
      function Rt(t) {
        var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
          Object.keys(e.elements).forEach(function(r) {
            var o2 = e.elements[r], i = e.attributes[r] || {}, a2 = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s2 = a2.reduce(function(f2, c2) {
              return f2[c2] = "", f2;
            }, {});
            !B(o2) || !C(o2) || (Object.assign(o2.style, s2), Object.keys(i).forEach(function(f2) {
              o2.removeAttribute(f2);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
      function q(t) {
        return t.split("-")[0];
      }
      var X$1 = Math.max, ve = Math.min, Z = Math.round;
      function ee(t, e) {
        e === void 0 && (e = false);
        var n = t.getBoundingClientRect(), r = 1, o2 = 1;
        if (B(t) && e) {
          var i = t.offsetHeight, a2 = t.offsetWidth;
          a2 > 0 && (r = Z(n.width) / a2 || 1), i > 0 && (o2 = Z(n.height) / i || 1);
        }
        return { width: n.width / r, height: n.height / o2, top: n.top / o2, right: n.right / r, bottom: n.bottom / o2, left: n.left / r, x: n.left / r, y: n.top / o2 };
      }
      function ke(t) {
        var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
        return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
      }
      function it(t, e) {
        var n = e.getRootNode && e.getRootNode();
        if (t.contains(e)) return true;
        if (n && Pe(n)) {
          var r = e;
          do {
            if (r && t.isSameNode(r)) return true;
            r = r.parentNode || r.host;
          } while (r);
        }
        return false;
      }
      function N$1(t) {
        return H(t).getComputedStyle(t);
      }
      function Wt(t) {
        return ["table", "td", "th"].indexOf(C(t)) >= 0;
      }
      function I$1(t) {
        return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
      }
      function ge(t) {
        return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I$1(t);
      }
      function at(t) {
        return !B(t) || N$1(t).position === "fixed" ? null : t.offsetParent;
      }
      function Bt(t) {
        var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
        if (n && B(t)) {
          var r = N$1(t);
          if (r.position === "fixed") return null;
        }
        var o2 = ge(t);
        for (Pe(o2) && (o2 = o2.host); B(o2) && ["html", "body"].indexOf(C(o2)) < 0; ) {
          var i = N$1(o2);
          if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none") return o2;
          o2 = o2.parentNode;
        }
        return null;
      }
      function se(t) {
        for (var e = H(t), n = at(t); n && Wt(n) && N$1(n).position === "static"; ) n = at(n);
        return n && (C(n) === "html" || C(n) === "body" && N$1(n).position === "static") ? e : n || Bt(t) || e;
      }
      function Le(t) {
        return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
      }
      function fe(t, e, n) {
        return X$1(t, ve(e, n));
      }
      function St(t, e, n) {
        var r = fe(t, e, n);
        return r > n ? n : r;
      }
      function st() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft(t) {
        return Object.assign({}, st(), t);
      }
      function ct(t, e) {
        return e.reduce(function(n, r) {
          return n[r] = t, n;
        }, {});
      }
      var Tt = function(t, e) {
        return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
      };
      function Ht(t) {
        var e, n = t.state, r = t.name, o2 = t.options, i = n.elements.arrow, a2 = n.modifiersData.popperOffsets, s2 = q(n.placement), f2 = Le(s2), c2 = [P$1, W].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
        if (!(!i || !a2)) {
          var m2 = Tt(o2.padding, n), v2 = ke(i), l2 = f2 === "y" ? E$1 : P$1, h2 = f2 === "y" ? R : W, p2 = n.rects.reference[u2] + n.rects.reference[f2] - a2[f2] - n.rects.popper[u2], g = a2[f2] - n.rects.reference[f2], x2 = se(i), y = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d2 = m2[l2], b2 = y - v2[u2] - m2[h2], w2 = y / 2 - v2[u2] / 2 + $, O2 = fe(d2, w2, b2), j = f2;
          n.modifiersData[r] = (e = {}, e[j] = O2, e.centerOffset = O2 - w2, e);
        }
      }
      function Ct(t) {
        var e = t.state, n = t.options, r = n.element, o2 = r === void 0 ? "[data-popper-arrow]" : r;
        o2 != null && (typeof o2 == "string" && (o2 = e.elements.popper.querySelector(o2), !o2) || !it(e.elements.popper, o2) || (e.elements.arrow = o2));
      }
      var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t) {
        return t.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t) {
        var e = t.x, n = t.y, r = window, o2 = r.devicePixelRatio || 1;
        return { x: Z(e * o2) / o2 || 0, y: Z(n * o2) / o2 || 0 };
      }
      function ut(t) {
        var e, n = t.popper, r = t.popperRect, o2 = t.placement, i = t.variation, a2 = t.offsets, s2 = t.position, f2 = t.gpuAcceleration, c2 = t.adaptive, u2 = t.roundOffsets, m2 = t.isFixed, v2 = a2.x, l2 = v2 === void 0 ? 0 : v2, h2 = a2.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u2 == "function" ? u2({ x: l2, y: p2 }) : { x: l2, y: p2 };
        l2 = g.x, p2 = g.y;
        var x2 = a2.hasOwnProperty("x"), y = a2.hasOwnProperty("y"), $ = P$1, d2 = E$1, b2 = window;
        if (c2) {
          var w2 = se(n), O2 = "clientHeight", j = "clientWidth";
          if (w2 === H(n) && (w2 = I$1(n), N$1(w2).position !== "static" && s2 === "absolute" && (O2 = "scrollHeight", j = "scrollWidth")), w2 = w2, o2 === E$1 || (o2 === P$1 || o2 === W) && i === J) {
            d2 = R;
            var A2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.height : w2[O2];
            p2 -= A2 - r.height, p2 *= f2 ? 1 : -1;
          }
          if (o2 === P$1 || (o2 === E$1 || o2 === R) && i === J) {
            $ = W;
            var k = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.width : w2[j];
            l2 -= k - r.width, l2 *= f2 ? 1 : -1;
          }
        }
        var D2 = Object.assign({ position: s2 }, c2 && qt), S2 = u2 === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
        if (l2 = S2.x, p2 = S2.y, f2) {
          var L;
          return Object.assign({}, D2, (L = {}, L[d2] = y ? "0" : "", L[$] = x2 ? "0" : "", L.transform = (b2.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L));
        }
        return Object.assign({}, D2, (e = {}, e[d2] = y ? p2 + "px" : "", e[$] = x2 ? l2 + "px" : "", e.transform = "", e));
      }
      function Nt(t) {
        var e = t.state, n = t.options, r = n.gpuAcceleration, o2 = r === void 0 ? true : r, i = n.adaptive, a2 = i === void 0 ? true : i, s2 = n.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o2, isFixed: e.options.strategy === "fixed" };
        e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c2, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a2, roundOffsets: f2 })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c2, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
      function It(t) {
        var e = t.state, n = t.instance, r = t.options, o2 = r.scroll, i = o2 === void 0 ? true : o2, a2 = r.resize, s2 = a2 === void 0 ? true : a2, f2 = H(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
        return i && c2.forEach(function(u2) {
          u2.addEventListener("scroll", n.update, ye);
        }), s2 && f2.addEventListener("resize", n.update, ye), function() {
          i && c2.forEach(function(u2) {
            u2.removeEventListener("scroll", n.update, ye);
          }), s2 && f2.removeEventListener("resize", n.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t) {
        return t.replace(/left|right|bottom|top/g, function(e) {
          return _t[e];
        });
      }
      var zt = { start: "end", end: "start" };
      function lt(t) {
        return t.replace(/start|end/g, function(e) {
          return zt[e];
        });
      }
      function We(t) {
        var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
        return { scrollLeft: n, scrollTop: r };
      }
      function Be(t) {
        return ee(I$1(t)).left + We(t).scrollLeft;
      }
      function Ft(t) {
        var e = H(t), n = I$1(t), r = e.visualViewport, o2 = n.clientWidth, i = n.clientHeight, a2 = 0, s2 = 0;
        return r && (o2 = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r.offsetLeft, s2 = r.offsetTop)), { width: o2, height: i, x: a2 + Be(t), y: s2 };
      }
      function Ut(t) {
        var e, n = I$1(t), r = We(t), o2 = (e = t.ownerDocument) == null ? void 0 : e.body, i = X$1(n.scrollWidth, n.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a2 = X$1(n.scrollHeight, n.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r.scrollLeft + Be(t), f2 = -r.scrollTop;
        return N$1(o2 || n).direction === "rtl" && (s2 += X$1(n.clientWidth, o2 ? o2.clientWidth : 0) - i), { width: i, height: a2, x: s2, y: f2 };
      }
      function Se(t) {
        var e = N$1(t), n = e.overflow, r = e.overflowX, o2 = e.overflowY;
        return /auto|scroll|overlay|hidden/.test(n + o2 + r);
      }
      function dt(t) {
        return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
      }
      function ce(t, e) {
        var n;
        e === void 0 && (e = []);
        var r = dt(t), o2 = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a2 = o2 ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s2 = e.concat(a2);
        return o2 ? s2 : s2.concat(ce(ge(a2)));
      }
      function Te(t) {
        return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
      }
      function Xt(t) {
        var e = ee(t);
        return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
      }
      function ht(t, e) {
        return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I$1(t)));
      }
      function Yt(t) {
        var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N$1(t).position) >= 0, r = n && B(t) ? se(t) : t;
        return Q(r) ? e.filter(function(o2) {
          return Q(o2) && it(o2, r) && C(o2) !== "body";
        }) : [];
      }
      function Gt(t, e, n) {
        var r = e === "clippingParents" ? Yt(t) : [].concat(e), o2 = [].concat(r, [n]), i = o2[0], a2 = o2.reduce(function(s2, f2) {
          var c2 = ht(t, f2);
          return s2.top = X$1(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X$1(c2.left, s2.left), s2;
        }, ht(t, i));
        return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
      }
      function mt(t) {
        var e = t.reference, n = t.element, r = t.placement, o2 = r ? q(r) : null, i = r ? te(r) : null, a2 = e.x + e.width / 2 - n.width / 2, s2 = e.y + e.height / 2 - n.height / 2, f2;
        switch (o2) {
          case E$1:
            f2 = { x: a2, y: e.y - n.height };
            break;
          case R:
            f2 = { x: a2, y: e.y + e.height };
            break;
          case W:
            f2 = { x: e.x + e.width, y: s2 };
            break;
          case P$1:
            f2 = { x: e.x - n.width, y: s2 };
            break;
          default:
            f2 = { x: e.x, y: e.y };
        }
        var c2 = o2 ? Le(o2) : null;
        if (c2 != null) {
          var u2 = c2 === "y" ? "height" : "width";
          switch (i) {
            case U$1:
              f2[c2] = f2[c2] - (e[u2] / 2 - n[u2] / 2);
              break;
            case J:
              f2[c2] = f2[c2] + (e[u2] / 2 - n[u2] / 2);
              break;
          }
        }
        return f2;
      }
      function ne(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = r === void 0 ? t.placement : r, i = n.boundary, a2 = i === void 0 ? Xe : i, s2 = n.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n.elementContext, u2 = c2 === void 0 ? K : c2, m2 = n.altBoundary, v2 = m2 === void 0 ? false : m2, l2 = n.padding, h2 = l2 === void 0 ? 0 : l2, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u2 === K ? Ye : K, x2 = t.rects.popper, y = t.elements[v2 ? g : u2], $ = Gt(Q(y) ? y : y.contextElement || I$1(t.elements.popper), a2, f2), d2 = ee(t.elements.reference), b2 = mt({ reference: d2, element: x2, placement: o2 }), w2 = Te(Object.assign({}, x2, b2)), O2 = u2 === K ? w2 : d2, j = { top: $.top - O2.top + p2.top, bottom: O2.bottom - $.bottom + p2.bottom, left: $.left - O2.left + p2.left, right: O2.right - $.right + p2.right }, A2 = t.modifiersData.offset;
        if (u2 === K && A2) {
          var k = A2[o2];
          Object.keys(j).forEach(function(D2) {
            var S2 = [W, R].indexOf(D2) >= 0 ? 1 : -1, L = [E$1, R].indexOf(D2) >= 0 ? "y" : "x";
            j[D2] += k[L] * S2;
          });
        }
        return j;
      }
      function Jt(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = n.boundary, i = n.rootBoundary, a2 = n.padding, s2 = n.flipVariations, f2 = n.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r), m2 = u2 ? s2 ? De : De.filter(function(h2) {
          return te(h2) === u2;
        }) : G, v2 = m2.filter(function(h2) {
          return c2.indexOf(h2) >= 0;
        });
        v2.length === 0 && (v2 = m2);
        var l2 = v2.reduce(function(h2, p2) {
          return h2[p2] = ne(t, { placement: p2, boundary: o2, rootBoundary: i, padding: a2 })[q(p2)], h2;
        }, {});
        return Object.keys(l2).sort(function(h2, p2) {
          return l2[h2] - l2[p2];
        });
      }
      function Kt(t) {
        if (q(t) === me) return [];
        var e = be(t);
        return [lt(t), e, lt(e)];
      }
      function Qt(t) {
        var e = t.state, n = t.options, r = t.name;
        if (!e.modifiersData[r]._skip) {
          for (var o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? true : a2, f2 = n.fallbackPlacements, c2 = n.padding, u2 = n.boundary, m2 = n.rootBoundary, v2 = n.altBoundary, l2 = n.flipVariations, h2 = l2 === void 0 ? true : l2, p2 = n.allowedAutoPlacements, g = e.options.placement, x2 = q(g), y = x2 === g, $ = f2 || (y || !h2 ? [be(g)] : Kt(g)), d2 = [g].concat($).reduce(function(z, V) {
            return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
          }, []), b2 = e.rects.reference, w2 = e.rects.popper, O2 = /* @__PURE__ */ new Map(), j = true, A2 = d2[0], k = 0; k < d2.length; k++) {
            var D2 = d2[k], S2 = q(D2), L = te(D2) === U$1, re = [E$1, R].indexOf(S2) >= 0, oe = re ? "width" : "height", M2 = ne(e, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v2, padding: c2 }), T2 = re ? L ? W : P$1 : L ? R : E$1;
            b2[oe] > w2[oe] && (T2 = be(T2));
            var pe = be(T2), _2 = [];
            if (i && _2.push(M2[S2] <= 0), s2 && _2.push(M2[T2] <= 0, M2[pe] <= 0), _2.every(function(z) {
              return z;
            })) {
              A2 = D2, j = false;
              break;
            }
            O2.set(D2, _2);
          }
          if (j) for (var ue = h2 ? 3 : 1, xe = function(z) {
            var V = d2.find(function(de) {
              var ae = O2.get(de);
              if (ae) return ae.slice(0, z).every(function(Y2) {
                return Y2;
              });
            });
            if (V) return A2 = V, "break";
          }, ie = ue; ie > 0; ie--) {
            var le = xe(ie);
            if (le === "break") break;
          }
          e.placement !== A2 && (e.modifiersData[r]._skip = true, e.placement = A2, e.reset = true);
        }
      }
      var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt(t, e, n) {
        return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
      }
      function yt(t) {
        return [E$1, W, R, P$1].some(function(e) {
          return t[e] >= 0;
        });
      }
      function Zt(t) {
        var e = t.state, n = t.name, r = e.rects.reference, o2 = e.rects.popper, i = e.modifiersData.preventOverflow, a2 = ne(e, { elementContext: "reference" }), s2 = ne(e, { altBoundary: true }), f2 = gt(a2, r), c2 = gt(s2, o2, i), u2 = yt(f2), m2 = yt(c2);
        e.modifiersData[n] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
      }
      var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t, e, n) {
        var r = q(t), o2 = [P$1, E$1].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a2 = i[0], s2 = i[1];
        return a2 = a2 || 0, s2 = (s2 || 0) * o2, [P$1, W].indexOf(r) >= 0 ? { x: s2, y: a2 } : { x: a2, y: s2 };
      }
      function tn(t) {
        var e = t.state, n = t.options, r = t.name, o2 = n.offset, i = o2 === void 0 ? [0, 0] : o2, a2 = Ee.reduce(function(u2, m2) {
          return u2[m2] = en(m2, e.rects, i), u2;
        }, {}), s2 = a2[e.placement], f2 = s2.x, c2 = s2.y;
        e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f2, e.modifiersData.popperOffsets.y += c2), e.modifiersData[r] = a2;
      }
      var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t) {
        var e = t.state, n = t.name;
        e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, placement: e.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t) {
        return t === "x" ? "y" : "x";
      }
      function on(t) {
        var e = t.state, n = t.options, r = t.name, o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? false : a2, f2 = n.boundary, c2 = n.rootBoundary, u2 = n.altBoundary, m2 = n.padding, v2 = n.tether, l2 = v2 === void 0 ? true : v2, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q(e.placement), y = te(e.placement), $ = !y, d2 = Le(x2), b2 = rn(d2), w2 = e.modifiersData.popperOffsets, O2 = e.rects.reference, j = e.rects.popper, A2 = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S2 = { x: 0, y: 0 };
        if (w2) {
          if (i) {
            var L, re = d2 === "y" ? E$1 : P$1, oe = d2 === "y" ? R : W, M2 = d2 === "y" ? "height" : "width", T2 = w2[d2], pe = T2 + g[re], _2 = T2 - g[oe], ue = l2 ? -j[M2] / 2 : 0, xe = y === U$1 ? O2[M2] : j[M2], ie = y === U$1 ? -j[M2] : -O2[M2], le = e.elements.arrow, z = l2 && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y2 = fe(0, O2[M2], z[M2]), jt = $ ? O2[M2] / 2 - ue - Y2 - de - k.mainAxis : xe - Y2 - de - k.mainAxis, Dt = $ ? -O2[M2] / 2 + ue + Y2 + ae + k.mainAxis : ie + Y2 + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D2 == null ? void 0 : D2[d2]) != null ? L : 0, Pt = T2 + jt - Ce - Et, At = T2 + Dt - Ce, qe = fe(l2 ? ve(pe, Pt) : pe, T2, l2 ? X$1(_2, At) : _2);
            w2[d2] = qe, S2[d2] = qe - T2;
          }
          if (s2) {
            var Ve, kt = d2 === "x" ? E$1 : P$1, Lt = d2 === "x" ? R : W, F2 = w2[b2], he = b2 === "y" ? "height" : "width", Ne = F2 + g[kt], Ie = F2 - g[Lt], $e = [E$1, P$1].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b2]) != null ? Ve : 0, ze = $e ? Ne : F2 - O2[he] - j[he] - _e + k.altAxis, Fe = $e ? F2 + O2[he] + j[he] - _e - k.altAxis : Ie, Ue = l2 && $e ? St(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
            w2[b2] = Ue, S2[b2] = Ue - F2;
          }
          e.modifiersData[r] = S2;
        }
      }
      var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t) {
        return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
      }
      function sn(t) {
        return t === H(t) || !B(t) ? We(t) : an(t);
      }
      function fn(t) {
        var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
        return n !== 1 || r !== 1;
      }
      function cn(t, e, n) {
        n === void 0 && (n = false);
        var r = B(e), o2 = B(e) && fn(e), i = I$1(e), a2 = ee(t, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
        return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s2 = sn(e)), B(e) ? (f2 = ee(e, true), f2.x += e.clientLeft, f2.y += e.clientTop) : i && (f2.x = Be(i))), { x: a2.left + s2.scrollLeft - f2.x, y: a2.top + s2.scrollTop - f2.y, width: a2.width, height: a2.height };
      }
      function pn(t) {
        var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
        t.forEach(function(i) {
          e.set(i.name, i);
        });
        function o2(i) {
          n.add(i.name);
          var a2 = [].concat(i.requires || [], i.requiresIfExists || []);
          a2.forEach(function(s2) {
            if (!n.has(s2)) {
              var f2 = e.get(s2);
              f2 && o2(f2);
            }
          }), r.push(i);
        }
        return t.forEach(function(i) {
          n.has(i.name) || o2(i);
        }), r;
      }
      function un(t) {
        var e = pn(t);
        return ot.reduce(function(n, r) {
          return n.concat(e.filter(function(o2) {
            return o2.phase === r;
          }));
        }, []);
      }
      function ln(t) {
        var e;
        return function() {
          return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
              e = void 0, n(t());
            });
          })), e;
        };
      }
      function dn(t) {
        var e = t.reduce(function(n, r) {
          var o2 = n[r.name];
          return n[r.name] = o2 ? Object.assign({}, o2, r, { options: Object.assign({}, o2.options, r.options), data: Object.assign({}, o2.data, r.data) }) : r, n;
        }, {});
        return Object.keys(e).map(function(n) {
          return e[n];
        });
      }
      var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
        return !e.some(function(r) {
          return !(r && typeof r.getBoundingClientRect == "function");
        });
      }
      function we(t) {
        t === void 0 && (t = {});
        var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o2 = e.defaultOptions, i = o2 === void 0 ? Ot : o2;
        return function(a2, s2, f2) {
          f2 === void 0 && (f2 = i);
          var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a2, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m2 = false, v2 = { state: c2, setOptions: function(p2) {
            var g = typeof p2 == "function" ? p2(c2.options) : p2;
            h2(), c2.options = Object.assign({}, i, c2.options, g), c2.scrollParents = { reference: Q(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s2) };
            var x2 = un(dn([].concat(r, c2.options.modifiers)));
            return c2.orderedModifiers = x2.filter(function(y) {
              return y.enabled;
            }), l2(), v2.update();
          }, forceUpdate: function() {
            if (!m2) {
              var p2 = c2.elements, g = p2.reference, x2 = p2.popper;
              if ($t(g, x2)) {
                c2.rects = { reference: cn(g, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j) {
                  return c2.modifiersData[j.name] = Object.assign({}, j.data);
                });
                for (var y = 0; y < c2.orderedModifiers.length; y++) {
                  if (c2.reset === true) {
                    c2.reset = false, y = -1;
                    continue;
                  }
                  var $ = c2.orderedModifiers[y], d2 = $.fn, b2 = $.options, w2 = b2 === void 0 ? {} : b2, O2 = $.name;
                  typeof d2 == "function" && (c2 = d2({ state: c2, options: w2, name: O2, instance: v2 }) || c2);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p2) {
              v2.forceUpdate(), p2(c2);
            });
          }), destroy: function() {
            h2(), m2 = true;
          } };
          if (!$t(a2, s2)) return v2;
          v2.setOptions(f2).then(function(p2) {
            !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
          });
          function l2() {
            c2.orderedModifiers.forEach(function(p2) {
              var g = p2.name, x2 = p2.options, y = x2 === void 0 ? {} : x2, $ = p2.effect;
              if (typeof $ == "function") {
                var d2 = $({ state: c2, name: g, instance: v2, options: y }), b2 = function() {
                };
                u2.push(d2 || b2);
              }
            });
          }
          function h2() {
            u2.forEach(function(p2) {
              return p2();
            }), u2 = [];
          }
          return v2;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      });
      const popperContentProps = buildProps({
        ...popperCoreConfigProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: definePropType(String),
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: {
          type: Boolean,
          default: false
        },
        trapping: {
          type: Boolean,
          default: false
        },
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        virtualTriggering: Boolean,
        zIndex: Number,
        ...useAriaProps(["ariaLabel"])
      });
      const popperContentEmits = {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      };
      const usePopperContentFocusTrap = (props2, emit) => {
        const trapped = ref(false);
        const focusStartRef = ref();
        const onFocusAfterTrapped = () => {
          emit("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a;
          if (((_a = event.detail) == null ? void 0 : _a.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props2.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props2.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const buildPopperOptions = (props2, modifiers = []) => {
        const { placement, strategy, popperOptions } = props2;
        const options2 = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props2), ...modifiers]
        };
        deriveExtraModifiers(options2, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options2;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient)
          return;
        return unrefElement($el);
      };
      function genModifiers(options2) {
        const { offset, gpuAcceleration, fallbackPlacements } = options2;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset != null ? offset : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options2, modifiers) {
        if (modifiers) {
          options2.modifiers = [...options2.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options2 = computed(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = shallowRef();
        const states = ref({
          styles: {
            popper: {
              position: unref(options2).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        watch(options2, (newOptions) => {
          const instance = unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, unref(options2));
        });
        onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: computed(() => {
            var _a;
            return { ...((_a = unref(instanceRef)) == null ? void 0 : _a.state) || {} };
          }),
          styles: computed(() => unref(states).styles),
          attributes: computed(() => unref(states).attributes),
          update: () => {
            var _a;
            return (_a = unref(instanceRef)) == null ? void 0 : _a.update();
          },
          forceUpdate: () => {
            var _a;
            return (_a = unref(instanceRef)) == null ? void 0 : _a.forceUpdate();
          },
          instanceRef: computed(() => unref(instanceRef))
        };
      };
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes
        };
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props2) => {
        const { popperInstanceRef, contentRef, triggerRef, role } = inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = ref();
        const arrowOffset = ref();
        const eventListenerModifier = computed(() => {
          return {
            name: "eventListeners",
            enabled: !!props2.visible
          };
        });
        const arrowModifier = computed(() => {
          var _a;
          const arrowEl = unref(arrowRef);
          const offset = (_a = unref(arrowOffset)) != null ? _a : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined(arrowEl),
            options: {
              element: arrowEl,
              padding: offset
            }
          };
        });
        const options2 = computed(() => {
          return {
            onFirstUpdate: () => {
              update();
            },
            ...buildPopperOptions(props2, [
              unref(arrowModifier),
              unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = computed(() => unwrapMeasurableEl(props2.referenceEl) || unref(triggerRef));
        const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options2);
        watch(instanceRef, (instance) => popperInstanceRef.value = instance);
        onMounted(() => {
          watch(() => {
            var _a;
            return (_a = unref(computedReference)) == null ? void 0 : _a.getBoundingClientRect();
          }, () => {
            update();
          });
        });
        return {
          attributes,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update
        };
      };
      const usePopperContentDOM = (props2, {
        attributes,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = computed(() => unref(attributes).popper);
        const contentZIndex = ref(isNumber$1(props2.zIndex) ? props2.zIndex : nextZIndex());
        const contentClass = computed(() => [
          ns.b(),
          ns.is("pure", props2.pure),
          ns.is(props2.effect),
          props2.popperClass
        ]);
        const contentStyle = computed(() => {
          return [
            { zIndex: unref(contentZIndex) },
            unref(styles).popper,
            props2.popperStyle || {}
          ];
        });
        const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = computed(() => unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = isNumber$1(props2.zIndex) ? props2.zIndex : nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const __default__$q = defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$O = /* @__PURE__ */ defineComponent({
        ...__default__$q,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props2, emit);
          const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props2);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props2, {
            styles,
            attributes,
            role
          });
          const formItemContext = inject(formItemContextKey, void 0);
          const arrowOffset = ref();
          provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef,
            arrowOffset
          });
          if (formItemContext) {
            provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props2.visible && props2.focusOnShow) {
              trapped.value = true;
            } else if (props2.visible === false) {
              trapped.value = false;
            }
          };
          onMounted(() => {
            watch(() => props2.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = unref(triggerTargetEl || contentRef.value);
              const prevEl = unref(prevTriggerTargetEl || contentRef.value);
              if (isElement(el)) {
                triggerTargetAriaStopWatch = watch([role, () => props2.ariaLabel, ariaModal, () => props2.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            watch(() => props2.visible, togglePopperAlive, { immediate: true });
          });
          onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, unref(contentAttrs), {
              style: unref(contentStyle),
              class: unref(contentClass),
              tabindex: "-1",
              onMouseenter: (e) => _ctx.$emit("mouseenter", e),
              onMouseleave: (e) => _ctx.$emit("mouseleave", e)
            }), [
              createVNode(unref(ElFocusTrap), {
                trapped: unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": unref(contentRef),
                "focus-start-el": unref(focusStartRef),
                onFocusAfterTrapped: unref(onFocusAfterTrapped),
                onFocusAfterReleased: unref(onFocusAfterReleased),
                onFocusin: unref(onFocusInTrap),
                onFocusoutPrevented: unref(onFocusoutPrevented),
                onReleaseRequested: unref(onReleaseRequested)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16, ["onMouseenter", "onMouseleave"]);
          };
        }
      });
      var ElPopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["__file", "content.vue"]]);
      const ElPopper = withInstall(Popper);
      const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay2) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay2);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      const useDelayedToggleProps = buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      });
      const useDelayedToggle = ({
        showAfter,
        hideAfter,
        autoClose,
        open,
        close
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open(event);
            const _autoClose = unref(autoClose);
            if (isNumber$1(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close(event);
              }, _autoClose);
            }
          }, unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close(event);
          }, unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      };
      const useTooltipContentProps = buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: definePropType([String, Object])
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: Boolean,
        persistent: Boolean,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean,
        ...useAriaProps(["ariaLabel"])
      });
      const useTooltipTriggerProps = buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space]
        }
      });
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = getCurrentInstance();
          const { emit } = instance;
          const props2 = instance.props;
          const hasUpdateHandler = computed(() => isFunction$2(props2[updateEventKeyRaw]));
          const isModelBindingAbsent = computed(() => props2[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$2(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$2(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props2.disabled === true || isFunction$2(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props2.disabled === true || !isClient)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean$1(val))
              return;
            if (props2.disabled && val) {
              if (hasUpdateHandler.value) {
                emit(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          watch(() => props2[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          onMounted(() => {
            onChange(props2[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      };
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      const useTooltipProps = buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      });
      const tooltipEmits = [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ];
      const isTriggerType = (trigger, type4) => {
        if (isArray$1(trigger)) {
          return trigger.includes(type4);
        }
        return trigger === type4;
      };
      const whenTrigger = (trigger, type4, handler) => {
        return (e) => {
          isTriggerType(unref(trigger), type4) && handler(e);
        };
      };
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      const __default__$p = defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$N = /* @__PURE__ */ defineComponent({
        ...__default__$p,
        props: useTooltipTriggerProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef = ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (unref(controlled) || props2.disabled) {
              return true;
            }
          };
          const trigger = toRef(props2, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "click", (e) => {
            if (e.button === 0) {
              onToggle(e);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "contextmenu", (e) => {
            e.preventDefault();
            onToggle(e);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
            const { code } = e;
            if (props2.triggerKeys.includes(code)) {
              e.preventDefault();
              onToggle(e);
            }
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopperTrigger), {
              id: unref(id),
              "virtual-ref": _ctx.virtualRef,
              open: unref(open),
              "virtual-triggering": _ctx.virtualTriggering,
              class: normalizeClass(unref(ns).e("trigger")),
              onBlur: unref(onBlur),
              onClick: unref(onClick),
              onContextmenu: unref(onContextMenu),
              onFocus: unref(onFocus),
              onMouseenter: unref(onMouseenter),
              onMouseleave: unref(onMouseleave),
              onKeydown: unref(onKeydown)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["__file", "trigger.vue"]]);
      const teleportProps = buildProps({
        to: {
          type: definePropType([String, Object]),
          required: true
        },
        disabled: Boolean
      });
      const _sfc_main$M = /* @__PURE__ */ defineComponent({
        __name: "teleport",
        props: teleportProps,
        setup(__props) {
          return (_ctx, _cache) => {
            return _ctx.disabled ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createBlock(Teleport$1, {
              key: 1,
              to: _ctx.to
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 8, ["to"]));
          };
        }
      });
      var Teleport = /* @__PURE__ */ _export_sfc$1(_sfc_main$M, [["__file", "teleport.vue"]]);
      const ElTeleport = withInstall(Teleport);
      const usePopperContainerId = () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id = computed(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = computed(() => `#${id.value}`);
        return {
          id,
          selector
        };
      };
      const createContainer = (id) => {
        const container = document.createElement("div");
        container.id = id;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = () => {
        const { id, selector } = usePopperContainerId();
        onBeforeMount(() => {
          if (!isClient)
            return;
          if (!document.body.querySelector(selector.value)) {
            createContainer(id.value);
          }
        });
        return {
          id,
          selector
        };
      };
      const __default__$o = defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$L = /* @__PURE__ */ defineComponent({
        ...__default__$o,
        props: useTooltipContentProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = ref();
          let stopHandle;
          const {
            controlled,
            id,
            open,
            trigger,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = computed(() => {
            return props2.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = computed(() => {
            return props2.persistent;
          });
          onBeforeUnmount(() => {
            stopHandle == null ? void 0 : stopHandle();
          });
          const shouldRender = computed(() => {
            return unref(persistentRef) ? true : unref(open);
          });
          const shouldShow = computed(() => {
            return props2.disabled ? false : unref(open);
          });
          const appendTo = computed(() => {
            return props2.appendTo || selector.value;
          });
          const contentStyle = computed(() => {
            var _a;
            return (_a = props2.style) != null ? _a : {};
          });
          const ariaHidden = ref(true);
          const onTransitionLeave = () => {
            onHide();
            isFocusInsideContent() && tryFocus(document.body);
            ariaHidden.value = true;
          };
          const stopWhenControlled = () => {
            if (unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props2.enterable && unref(trigger) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (unref(trigger) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a, _b;
            (_b = (_a = contentRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
            stopHandle = onClickOutside(computed(() => {
              var _a;
              return (_a = contentRef.value) == null ? void 0 : _a.popperContentRef;
            }), () => {
              if (unref(controlled))
                return;
              const $trigger = unref(trigger);
              if ($trigger !== "hover") {
                onClose();
              }
            });
          };
          const onBlur = () => {
            if (!props2.virtualTriggering) {
              onClose();
            }
          };
          const isFocusInsideContent = (event) => {
            var _a;
            const popperContent = (_a = contentRef.value) == null ? void 0 : _a.popperContentRef;
            const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
            return popperContent == null ? void 0 : popperContent.contains(activeElement);
          };
          watch(() => unref(open), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            } else {
              ariaHidden.value = false;
            }
          }, {
            flush: "post"
          });
          watch(() => props2.content, () => {
            var _a, _b;
            (_b = (_a = contentRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
          });
          expose({
            contentRef,
            isFocusInsideContent
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTeleport), {
              disabled: !_ctx.teleported,
              to: unref(appendTo)
            }, {
              default: withCtx(() => [
                createVNode(Transition, {
                  name: unref(transitionClass),
                  onAfterLeave: onTransitionLeave,
                  onBeforeEnter,
                  onAfterEnter: onAfterShow,
                  onBeforeLeave
                }, {
                  default: withCtx(() => [
                    unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                      key: 0,
                      id: unref(id),
                      ref_key: "contentRef",
                      ref: contentRef
                    }, _ctx.$attrs, {
                      "aria-label": _ctx.ariaLabel,
                      "aria-hidden": ariaHidden.value,
                      "boundaries-padding": _ctx.boundariesPadding,
                      "fallback-placements": _ctx.fallbackPlacements,
                      "gpu-acceleration": _ctx.gpuAcceleration,
                      offset: _ctx.offset,
                      placement: _ctx.placement,
                      "popper-options": _ctx.popperOptions,
                      strategy: _ctx.strategy,
                      effect: _ctx.effect,
                      enterable: _ctx.enterable,
                      pure: _ctx.pure,
                      "popper-class": _ctx.popperClass,
                      "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                      "reference-el": _ctx.referenceEl,
                      "trigger-target-el": _ctx.triggerTargetEl,
                      visible: unref(shouldShow),
                      "z-index": _ctx.zIndex,
                      onMouseenter: unref(onContentEnter),
                      onMouseleave: unref(onContentLeave),
                      onBlur,
                      onClose: unref(onClose)
                    }), {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "default")
                      ]),
                      _: 3
                    }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                      [vShow, unref(shouldShow)]
                    ]) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ]),
              _: 3
            }, 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["__file", "content.vue"]]);
      const __default__$n = defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$K = /* @__PURE__ */ defineComponent({
        ...__default__$n,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          usePopperContainer();
          const id = useId();
          const popperRef = ref();
          const contentRef = ref();
          const updatePopper = () => {
            var _a;
            const popperComponent = unref(popperRef);
            if (popperComponent) {
              (_a = popperComponent.popperInstanceRef) == null ? void 0 : _a.update();
            }
          };
          const open = ref(false);
          const toggleReason = ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: toRef(props2, "showAfter"),
            hideAfter: toRef(props2, "hideAfter"),
            autoClose: toRef(props2, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = computed(() => isBoolean$1(props2.visible) && !hasUpdateHandler.value);
          provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id,
            open: readonly(open),
            trigger: toRef(props2, "trigger"),
            onOpen: (event) => {
              onOpen(event);
            },
            onClose: (event) => {
              onClose(event);
            },
            onToggle: (event) => {
              if (unref(open)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit("show", toggleReason.value);
            },
            onHide: () => {
              emit("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit("before-hide", toggleReason.value);
            },
            updatePopper
          });
          watch(() => props2.disabled, (disabled) => {
            if (disabled && open.value) {
              open.value = false;
            }
          });
          const isFocusInsideContent = (event) => {
            var _a;
            return (_a = contentRef.value) == null ? void 0 : _a.isFocusInsideContent(event);
          };
          onDeactivated(() => open.value && hide());
          expose({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: withCtx(() => [
                createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": _ctx.popperClass,
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, ["innerHTML"])) : (openBlock(), createElementBlock("span", { key: 1 }, toDisplayString(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                      key: 0,
                      "arrow-offset": _ctx.arrowOffset
                    }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["__file", "tooltip.vue"]]);
      const ElTooltip = withInstall(Tooltip);
      const avatarProps = buildProps({
        size: {
          type: [Number, String],
          values: componentSizes,
          default: "",
          validator: (val) => isNumber$1(val)
        },
        shape: {
          type: String,
          values: ["circle", "square"],
          default: "circle"
        },
        icon: {
          type: iconPropType
        },
        src: {
          type: String,
          default: ""
        },
        alt: String,
        srcSet: String,
        fit: {
          type: definePropType(String),
          default: "cover"
        }
      });
      const avatarEmits = {
        error: (evt) => evt instanceof Event
      };
      const __default__$m = defineComponent({
        name: "ElAvatar"
      });
      const _sfc_main$J = /* @__PURE__ */ defineComponent({
        ...__default__$m,
        props: avatarProps,
        emits: avatarEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("avatar");
          const hasLoadError = ref(false);
          const avatarClass = computed(() => {
            const { size, icon, shape } = props2;
            const classList = [ns.b()];
            if (isString$2(size))
              classList.push(ns.m(size));
            if (icon)
              classList.push(ns.m("icon"));
            if (shape)
              classList.push(ns.m(shape));
            return classList;
          });
          const sizeStyle = computed(() => {
            const { size } = props2;
            return isNumber$1(size) ? ns.cssVarBlock({
              size: addUnit(size) || ""
            }) : void 0;
          });
          const fitStyle = computed(() => ({
            objectFit: props2.fit
          }));
          watch(() => props2.src, () => hasLoadError.value = false);
          function handleError(e) {
            hasLoadError.value = true;
            emit("error", e);
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(avatarClass)),
              style: normalizeStyle(unref(sizeStyle))
            }, [
              (_ctx.src || _ctx.srcSet) && !hasLoadError.value ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: _ctx.src,
                alt: _ctx.alt,
                srcset: _ctx.srcSet,
                style: normalizeStyle(unref(fitStyle)),
                onError: handleError
              }, null, 44, ["src", "alt", "srcset"])) : _ctx.icon ? (openBlock(), createBlock(unref(ElIcon$1), { key: 1 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                ]),
                _: 1
              })) : renderSlot(_ctx.$slots, "default", { key: 2 })
            ], 6);
          };
        }
      });
      var Avatar = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__file", "avatar.vue"]]);
      const ElAvatar = withInstall(Avatar);
      const badgeProps = buildProps({
        value: {
          type: [String, Number],
          default: ""
        },
        max: {
          type: Number,
          default: 99
        },
        isDot: Boolean,
        hidden: Boolean,
        type: {
          type: String,
          values: ["primary", "success", "warning", "info", "danger"],
          default: "danger"
        },
        showZero: {
          type: Boolean,
          default: true
        },
        color: String,
        badgeStyle: {
          type: definePropType([String, Object, Array])
        },
        offset: {
          type: definePropType(Array),
          default: [0, 0]
        },
        badgeClass: {
          type: String
        }
      });
      const __default__$l = defineComponent({
        name: "ElBadge"
      });
      const _sfc_main$I = /* @__PURE__ */ defineComponent({
        ...__default__$l,
        props: badgeProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("badge");
          const content = computed(() => {
            if (props2.isDot)
              return "";
            if (isNumber$1(props2.value) && isNumber$1(props2.max)) {
              return props2.max < props2.value ? `${props2.max}+` : `${props2.value}`;
            }
            return `${props2.value}`;
          });
          const style3 = computed(() => {
            var _a, _b, _c, _d, _e;
            return [
              {
                backgroundColor: props2.color,
                marginRight: addUnit(-((_b = (_a = props2.offset) == null ? void 0 : _a[0]) != null ? _b : 0)),
                marginTop: addUnit((_d = (_c = props2.offset) == null ? void 0 : _c[1]) != null ? _d : 0)
              },
              (_e = props2.badgeStyle) != null ? _e : {}
            ];
          });
          expose({
            content
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode(Transition, {
                name: `${unref(ns).namespace.value}-zoom-in-center`,
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createElementVNode("sup", {
                    class: normalizeClass([
                      unref(ns).e("content"),
                      unref(ns).em("content", _ctx.type),
                      unref(ns).is("fixed", !!_ctx.$slots.default),
                      unref(ns).is("dot", _ctx.isDot),
                      unref(ns).is("hide-zero", !_ctx.showZero && props2.value === 0),
                      _ctx.badgeClass
                    ]),
                    style: normalizeStyle(unref(style3))
                  }, [
                    renderSlot(_ctx.$slots, "content", { value: unref(content) }, () => [
                      createTextVNode(toDisplayString(unref(content)), 1)
                    ])
                  ], 6), [
                    [vShow, !_ctx.hidden && (unref(content) || _ctx.isDot || _ctx.$slots.content)]
                  ])
                ]),
                _: 3
              }, 8, ["name"])
            ], 2);
          };
        }
      });
      var Badge = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__file", "badge.vue"]]);
      const ElBadge = withInstall(Badge);
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
        PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
        PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
        PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
        PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
        PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
        PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
        PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
        PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
        PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
        PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
        PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
        return PatchFlags2;
      })(PatchFlags || {});
      function isFragment(node) {
        return isVNode(node) && node.type === Fragment;
      }
      function isComment(node) {
        return isVNode(node) && node.type === Comment;
      }
      function isValidElementNode(node) {
        return isVNode(node) && !isFragment(node) && !isComment(node);
      }
      const checkboxProps = {
        modelValue: {
          type: [Number, String, Boolean],
          default: void 0
        },
        label: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        value: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
          type: String,
          default: void 0
        },
        trueValue: {
          type: [String, Number],
          default: void 0
        },
        falseValue: {
          type: [String, Number],
          default: void 0
        },
        trueLabel: {
          type: [String, Number],
          default: void 0
        },
        falseLabel: {
          type: [String, Number],
          default: void 0
        },
        id: {
          type: String,
          default: void 0
        },
        border: Boolean,
        size: useSizeProp,
        tabindex: [String, Number],
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaControls"])
      };
      const checkboxEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString$2(val) || isNumber$1(val) || isBoolean$1(val),
        change: (val) => isString$2(val) || isNumber$1(val) || isBoolean$1(val)
      };
      const checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
      const useCheckboxDisabled = ({
        model,
        isChecked
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isLimitDisabled = computed(() => {
          var _a, _b;
          const max = (_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value;
          const min = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
          return !isUndefined$1(max) && model.value.length >= max && !isChecked.value || !isUndefined$1(min) && model.value.length <= min && isChecked.value;
        });
        const isDisabled = useFormDisabled(computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
        return {
          isDisabled,
          isLimitDisabled
        };
      };
      const useCheckboxEvent = (props2, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const { formItem } = useFormItem();
        const { emit } = getCurrentInstance();
        function getLabeledValue(value) {
          var _a, _b, _c, _d;
          return [true, props2.trueValue, props2.trueLabel].includes(value) ? (_b = (_a = props2.trueValue) != null ? _a : props2.trueLabel) != null ? _b : true : (_d = (_c = props2.falseValue) != null ? _c : props2.falseLabel) != null ? _d : false;
        }
        function emitChangeEvent(checked, e) {
          emit("change", getLabeledValue(checked), e);
        }
        function handleChange(e) {
          if (isLimitExceeded.value)
            return;
          const target = e.target;
          emit("change", getLabeledValue(target.checked), e);
        }
        async function onClickRoot(e) {
          if (isLimitExceeded.value)
            return;
          if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
            const eventTargets = e.composedPath();
            const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
            if (!hasLabel) {
              model.value = getLabeledValue([false, props2.falseValue, props2.falseLabel].includes(model.value));
              await nextTick();
              emitChangeEvent(model.value, e);
            }
          }
        }
        const validateEvent = computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props2.validateEvent);
        watch(() => props2.modelValue, () => {
          if (validateEvent.value) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return {
          handleChange,
          onClickRoot
        };
      };
      const useCheckboxModel = (props2) => {
        const selfModel = ref(false);
        const { emit } = getCurrentInstance();
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isGroup = computed(() => isUndefined$1(checkboxGroup) === false);
        const isLimitExceeded = ref(false);
        const model = computed({
          get() {
            var _a, _b;
            return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a.value : (_b = props2.modelValue) != null ? _b : selfModel.value;
          },
          set(val) {
            var _a, _b;
            if (isGroup.value && isArray$1(val)) {
              isLimitExceeded.value = ((_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value) && val.length > model.value.length;
              isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
            } else {
              emit(UPDATE_MODEL_EVENT, val);
              selfModel.value = val;
            }
          }
        });
        return {
          model,
          isGroup,
          isLimitExceeded
        };
      };
      const useCheckboxStatus = (props2, slots, { model }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isFocused = ref(false);
        const actualValue = computed(() => {
          if (!isPropAbsent(props2.value)) {
            return props2.value;
          }
          return props2.label;
        });
        const isChecked = computed(() => {
          const value = model.value;
          if (isBoolean$1(value)) {
            return value;
          } else if (isArray$1(value)) {
            if (isObject$1(actualValue.value)) {
              return value.map(toRaw).some((o2) => isEqual(o2, actualValue.value));
            } else {
              return value.map(toRaw).includes(actualValue.value);
            }
          } else if (value !== null && value !== void 0) {
            return value === props2.trueValue || value === props2.trueLabel;
          } else {
            return !!value;
          }
        });
        const checkboxButtonSize = useFormSize(computed(() => {
          var _a;
          return (_a = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a.value;
        }), {
          prop: true
        });
        const checkboxSize = useFormSize(computed(() => {
          var _a;
          return (_a = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a.value;
        }));
        const hasOwnLabel = computed(() => {
          return !!slots.default || !isPropAbsent(actualValue.value);
        });
        return {
          checkboxButtonSize,
          isChecked,
          isFocused,
          checkboxSize,
          hasOwnLabel,
          actualValue
        };
      };
      const useCheckbox = (props2, slots) => {
        const { formItem: elFormItem } = useFormItem();
        const { model, isGroup, isLimitExceeded } = useCheckboxModel(props2);
        const {
          isFocused,
          isChecked,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          actualValue
        } = useCheckboxStatus(props2, slots, { model });
        const { isDisabled } = useCheckboxDisabled({ model, isChecked });
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props2, {
          formItemContext: elFormItem,
          disableIdGeneration: hasOwnLabel,
          disableIdManagement: isGroup
        });
        const { handleChange, onClickRoot } = useCheckboxEvent(props2, {
          model,
          isLimitExceeded,
          hasOwnLabel,
          isDisabled,
          isLabeledByFormItem
        });
        const setStoreValue = () => {
          function addToStore() {
            var _a, _b;
            if (isArray$1(model.value) && !model.value.includes(actualValue.value)) {
              model.value.push(actualValue.value);
            } else {
              model.value = (_b = (_a = props2.trueValue) != null ? _a : props2.trueLabel) != null ? _b : true;
            }
          }
          props2.checked && addToStore();
        };
        setStoreValue();
        useDeprecated({
          from: "label act as value",
          replacement: "value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => isGroup.value && isPropAbsent(props2.value)));
        useDeprecated({
          from: "true-label",
          replacement: "true-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => !!props2.trueLabel));
        useDeprecated({
          from: "false-label",
          replacement: "false-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => !!props2.falseLabel));
        return {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          model,
          actualValue,
          handleChange,
          onClickRoot
        };
      };
      const __default__$k = defineComponent({
        name: "ElCheckbox"
      });
      const _sfc_main$H = /* @__PURE__ */ defineComponent({
        ...__default__$k,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props2 = __props;
          const slots = useSlots();
          const {
            inputId,
            isLabeledByFormItem,
            isChecked,
            isDisabled,
            isFocused,
            checkboxSize,
            hasOwnLabel,
            model,
            actualValue,
            handleChange,
            onClickRoot
          } = useCheckbox(props2, slots);
          const ns = useNamespace("checkbox");
          const compKls = computed(() => {
            return [
              ns.b(),
              ns.m(checkboxSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("bordered", props2.border),
              ns.is("checked", isChecked.value)
            ];
          });
          const spanKls = computed(() => {
            return [
              ns.e("input"),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("indeterminate", props2.indeterminate),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
              class: normalizeClass(unref(compKls)),
              "aria-controls": _ctx.indeterminate ? _ctx.ariaControls : null,
              onClick: unref(onClickRoot)
            }, {
              default: withCtx(() => {
                var _a, _b, _c, _d;
                return [
                  createElementVNode("span", {
                    class: normalizeClass(unref(spanKls))
                  }, [
                    _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                      key: 0,
                      id: unref(inputId),
                      "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      disabled: unref(isDisabled),
                      "true-value": (_b = (_a = _ctx.trueValue) != null ? _a : _ctx.trueLabel) != null ? _b : true,
                      "false-value": (_d = (_c = _ctx.falseValue) != null ? _c : _ctx.falseLabel) != null ? _d : false,
                      onChange: unref(handleChange),
                      onFocus: ($event) => isFocused.value = true,
                      onBlur: ($event) => isFocused.value = false,
                      onClick: withModifiers(() => {
                      }, ["stop"])
                    }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [
                      [vModelCheckbox, unref(model)]
                    ]) : withDirectives((openBlock(), createElementBlock("input", {
                      key: 1,
                      id: unref(inputId),
                      "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      disabled: unref(isDisabled),
                      value: unref(actualValue),
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      onChange: unref(handleChange),
                      onFocus: ($event) => isFocused.value = true,
                      onBlur: ($event) => isFocused.value = false,
                      onClick: withModifiers(() => {
                      }, ["stop"])
                    }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "disabled", "value", "name", "tabindex", "onChange", "onFocus", "onBlur", "onClick"])), [
                      [vModelCheckbox, unref(model)]
                    ]),
                    createElementVNode("span", {
                      class: normalizeClass(unref(ns).e("inner"))
                    }, null, 2)
                  ], 2),
                  unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(ns).e("label"))
                  }, [
                    renderSlot(_ctx.$slots, "default"),
                    !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createTextVNode(toDisplayString(_ctx.label), 1)
                    ], 64)) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true)
                ];
              }),
              _: 3
            }, 8, ["class", "aria-controls", "onClick"]);
          };
        }
      });
      var Checkbox = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["__file", "checkbox.vue"]]);
      const __default__$j = defineComponent({
        name: "ElCheckboxButton"
      });
      const _sfc_main$G = /* @__PURE__ */ defineComponent({
        ...__default__$j,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props2 = __props;
          const slots = useSlots();
          const {
            isFocused,
            isChecked,
            isDisabled,
            checkboxButtonSize,
            model,
            actualValue,
            handleChange
          } = useCheckbox(props2, slots);
          const checkboxGroup = inject(checkboxGroupContextKey, void 0);
          const ns = useNamespace("checkbox");
          const activeStyle = computed(() => {
            var _a, _b, _c, _d;
            const fillValue = (_b = (_a = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a.value) != null ? _b : "";
            return {
              backgroundColor: fillValue,
              borderColor: fillValue,
              color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
              boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
            };
          });
          const labelKls = computed(() => {
            return [
              ns.b("button"),
              ns.bm("button", checkboxButtonSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            var _a, _b, _c, _d;
            return openBlock(), createElementBlock("label", {
              class: normalizeClass(unref(labelKls))
            }, [
              _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                "true-value": (_b = (_a = _ctx.trueValue) != null ? _a : _ctx.trueLabel) != null ? _b : true,
                "false-value": (_d = (_c = _ctx.falseValue) != null ? _c : _ctx.falseLabel) != null ? _d : false,
                onChange: unref(handleChange),
                onFocus: ($event) => isFocused.value = true,
                onBlur: ($event) => isFocused.value = false,
                onClick: withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [
                [vModelCheckbox, unref(model)]
              ]) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                value: unref(actualValue),
                onChange: unref(handleChange),
                onFocus: ($event) => isFocused.value = true,
                onBlur: ($event) => isFocused.value = false,
                onClick: withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "value", "onChange", "onFocus", "onBlur", "onClick"])), [
                [vModelCheckbox, unref(model)]
              ]),
              _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass(unref(ns).be("button", "inner")),
                style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var CheckboxButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["__file", "checkbox-button.vue"]]);
      const checkboxGroupProps = buildProps({
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        disabled: Boolean,
        min: Number,
        max: Number,
        size: useSizeProp,
        fill: String,
        textColor: String,
        tag: {
          type: String,
          default: "div"
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      });
      const checkboxGroupEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isArray$1(val),
        change: (val) => isArray$1(val)
      };
      const __default__$i = defineComponent({
        name: "ElCheckboxGroup"
      });
      const _sfc_main$F = /* @__PURE__ */ defineComponent({
        ...__default__$i,
        props: checkboxGroupProps,
        emits: checkboxGroupEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("checkbox");
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext: formItem
          });
          const changeEvent = async (value) => {
            emit(UPDATE_MODEL_EVENT, value);
            await nextTick();
            emit("change", value);
          };
          const modelValue = computed({
            get() {
              return props2.modelValue;
            },
            set(val) {
              changeEvent(val);
            }
          });
          provide(checkboxGroupContextKey, {
            ...pick(toRefs(props2), [
              "size",
              "min",
              "max",
              "disabled",
              "validateEvent",
              "fill",
              "textColor"
            ]),
            modelValue,
            changeEvent
          });
          watch(() => props2.modelValue, () => {
            if (props2.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              id: unref(groupId),
              class: normalizeClass(unref(ns).b("group")),
              role: "group",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.ariaLabel || "checkbox-group" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? (_a = unref(formItem)) == null ? void 0 : _a.labelId : void 0
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var CheckboxGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__file", "checkbox-group.vue"]]);
      const ElCheckbox = withInstall(Checkbox, {
        CheckboxButton,
        CheckboxGroup
      });
      withNoopInstall(CheckboxButton);
      withNoopInstall(CheckboxGroup);
      const radioPropsBase = buildProps({
        modelValue: {
          type: [String, Number, Boolean],
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        label: {
          type: [String, Number, Boolean],
          default: void 0
        },
        value: {
          type: [String, Number, Boolean],
          default: void 0
        },
        name: {
          type: String,
          default: void 0
        }
      });
      const radioProps = buildProps({
        ...radioPropsBase,
        border: Boolean
      });
      const radioEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString$2(val) || isNumber$1(val) || isBoolean$1(val),
        [CHANGE_EVENT]: (val) => isString$2(val) || isNumber$1(val) || isBoolean$1(val)
      };
      const radioGroupKey = Symbol("radioGroupKey");
      const useRadio = (props2, emit) => {
        const radioRef = ref();
        const radioGroup = inject(radioGroupKey, void 0);
        const isGroup = computed(() => !!radioGroup);
        const actualValue = computed(() => {
          if (!isPropAbsent(props2.value)) {
            return props2.value;
          }
          return props2.label;
        });
        const modelValue = computed({
          get() {
            return isGroup.value ? radioGroup.modelValue : props2.modelValue;
          },
          set(val) {
            if (isGroup.value) {
              radioGroup.changeEvent(val);
            } else {
              emit && emit(UPDATE_MODEL_EVENT, val);
            }
            radioRef.value.checked = props2.modelValue === actualValue.value;
          }
        });
        const size = useFormSize(computed(() => radioGroup == null ? void 0 : radioGroup.size));
        const disabled = useFormDisabled(computed(() => radioGroup == null ? void 0 : radioGroup.disabled));
        const focus = ref(false);
        const tabIndex = computed(() => {
          return disabled.value || isGroup.value && modelValue.value !== actualValue.value ? -1 : 0;
        });
        useDeprecated({
          from: "label act as value",
          replacement: "value",
          version: "3.0.0",
          scope: "el-radio",
          ref: "https://element-plus.org/en-US/component/radio.html"
        }, computed(() => isGroup.value && isPropAbsent(props2.value)));
        return {
          radioRef,
          isGroup,
          radioGroup,
          focus,
          size,
          disabled,
          tabIndex,
          modelValue,
          actualValue
        };
      };
      const __default__$h = defineComponent({
        name: "ElRadio"
      });
      const _sfc_main$E = /* @__PURE__ */ defineComponent({
        ...__default__$h,
        props: radioProps,
        emits: radioEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("radio");
          const { radioRef, radioGroup, focus, size, disabled, modelValue, actualValue } = useRadio(props2, emit);
          function handleChange() {
            nextTick(() => emit("change", modelValue.value));
          }
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock("label", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).is("disabled", unref(disabled)),
                unref(ns).is("focus", unref(focus)),
                unref(ns).is("bordered", _ctx.border),
                unref(ns).is("checked", unref(modelValue) === unref(actualValue)),
                unref(ns).m(unref(size))
              ])
            }, [
              createElementVNode("span", {
                class: normalizeClass([
                  unref(ns).e("input"),
                  unref(ns).is("disabled", unref(disabled)),
                  unref(ns).is("checked", unref(modelValue) === unref(actualValue))
                ])
              }, [
                withDirectives(createElementVNode("input", {
                  ref_key: "radioRef",
                  ref: radioRef,
                  "onUpdate:modelValue": ($event) => isRef(modelValue) ? modelValue.value = $event : null,
                  class: normalizeClass(unref(ns).e("original")),
                  value: unref(actualValue),
                  name: _ctx.name || ((_a = unref(radioGroup)) == null ? void 0 : _a.name),
                  disabled: unref(disabled),
                  checked: unref(modelValue) === unref(actualValue),
                  type: "radio",
                  onFocus: ($event) => focus.value = true,
                  onBlur: ($event) => focus.value = false,
                  onChange: handleChange,
                  onClick: withModifiers(() => {
                  }, ["stop"])
                }, null, 42, ["onUpdate:modelValue", "value", "name", "disabled", "checked", "onFocus", "onBlur", "onClick"]), [
                  [vModelRadio, unref(modelValue)]
                ]),
                createElementVNode("span", {
                  class: normalizeClass(unref(ns).e("inner"))
                }, null, 2)
              ], 2),
              createElementVNode("span", {
                class: normalizeClass(unref(ns).e("label")),
                onKeydown: withModifiers(() => {
                }, ["stop"])
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 42, ["onKeydown"])
            ], 2);
          };
        }
      });
      var Radio = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["__file", "radio.vue"]]);
      const radioButtonProps = buildProps({
        ...radioPropsBase
      });
      const __default__$g = defineComponent({
        name: "ElRadioButton"
      });
      const _sfc_main$D = /* @__PURE__ */ defineComponent({
        ...__default__$g,
        props: radioButtonProps,
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("radio");
          const { radioRef, focus, size, disabled, modelValue, radioGroup, actualValue } = useRadio(props2);
          const activeStyle = computed(() => {
            return {
              backgroundColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
              borderColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
              boxShadow: (radioGroup == null ? void 0 : radioGroup.fill) ? `-1px 0 0 0 ${radioGroup.fill}` : "",
              color: (radioGroup == null ? void 0 : radioGroup.textColor) || ""
            };
          });
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock("label", {
              class: normalizeClass([
                unref(ns).b("button"),
                unref(ns).is("active", unref(modelValue) === unref(actualValue)),
                unref(ns).is("disabled", unref(disabled)),
                unref(ns).is("focus", unref(focus)),
                unref(ns).bm("button", unref(size))
              ])
            }, [
              withDirectives(createElementVNode("input", {
                ref_key: "radioRef",
                ref: radioRef,
                "onUpdate:modelValue": ($event) => isRef(modelValue) ? modelValue.value = $event : null,
                class: normalizeClass(unref(ns).be("button", "original-radio")),
                value: unref(actualValue),
                type: "radio",
                name: _ctx.name || ((_a = unref(radioGroup)) == null ? void 0 : _a.name),
                disabled: unref(disabled),
                onFocus: ($event) => focus.value = true,
                onBlur: ($event) => focus.value = false,
                onClick: withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["onUpdate:modelValue", "value", "name", "disabled", "onFocus", "onBlur", "onClick"]), [
                [vModelRadio, unref(modelValue)]
              ]),
              createElementVNode("span", {
                class: normalizeClass(unref(ns).be("button", "inner")),
                style: normalizeStyle(unref(modelValue) === unref(actualValue) ? unref(activeStyle) : {}),
                onKeydown: withModifiers(() => {
                }, ["stop"])
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 46, ["onKeydown"])
            ], 2);
          };
        }
      });
      var RadioButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["__file", "radio-button.vue"]]);
      const radioGroupProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: [String, Number, Boolean],
          default: void 0
        },
        fill: {
          type: String,
          default: ""
        },
        textColor: {
          type: String,
          default: ""
        },
        name: {
          type: String,
          default: void 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      });
      const radioGroupEmits = radioEmits;
      const __default__$f = defineComponent({
        name: "ElRadioGroup"
      });
      const _sfc_main$C = /* @__PURE__ */ defineComponent({
        ...__default__$f,
        props: radioGroupProps,
        emits: radioGroupEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("radio");
          const radioId = useId();
          const radioGroupRef = ref();
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext: formItem
          });
          const changeEvent = (value) => {
            emit(UPDATE_MODEL_EVENT, value);
            nextTick(() => emit("change", value));
          };
          onMounted(() => {
            const radios = radioGroupRef.value.querySelectorAll("[type=radio]");
            const firstLabel = radios[0];
            if (!Array.from(radios).some((radio) => radio.checked) && firstLabel) {
              firstLabel.tabIndex = 0;
            }
          });
          const name = computed(() => {
            return props2.name || radioId.value;
          });
          provide(radioGroupKey, reactive({
            ...toRefs(props2),
            changeEvent,
            name
          }));
          watch(() => props2.modelValue, () => {
            if (props2.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              id: unref(groupId),
              ref_key: "radioGroupRef",
              ref: radioGroupRef,
              class: normalizeClass(unref(ns).b("group")),
              role: "radiogroup",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.ariaLabel || "radio-group" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? unref(formItem).labelId : void 0
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 10, ["id", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var RadioGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["__file", "radio-group.vue"]]);
      withInstall(Radio, {
        RadioButton,
        RadioGroup
      });
      const ElRadioGroup = withNoopInstall(RadioGroup);
      const ElRadioButton = withNoopInstall(RadioButton);
      const tagProps = buildProps({
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger"],
          default: "primary"
        },
        closable: Boolean,
        disableTransitions: Boolean,
        hit: Boolean,
        color: String,
        size: {
          type: String,
          values: componentSizes
        },
        effect: {
          type: String,
          values: ["dark", "light", "plain"],
          default: "light"
        },
        round: Boolean
      });
      const tagEmits = {
        close: (evt) => evt instanceof MouseEvent,
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$e = defineComponent({
        name: "ElTag"
      });
      const _sfc_main$B = /* @__PURE__ */ defineComponent({
        ...__default__$e,
        props: tagProps,
        emits: tagEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const tagSize = useFormSize();
          const ns = useNamespace("tag");
          const containerKls = computed(() => {
            const { type: type4, hit, effect, closable, round } = props2;
            return [
              ns.b(),
              ns.is("closable", closable),
              ns.m(type4 || "primary"),
              ns.m(tagSize.value),
              ns.m(effect),
              ns.is("hit", hit),
              ns.is("round", round)
            ];
          });
          const handleClose = (event) => {
            emit("close", event);
          };
          const handleClick = (event) => {
            emit("click", event);
          };
          const handleVNodeMounted = (vnode) => {
            var _a, _b, _c;
            if ((_c = (_b = (_a = vnode == null ? void 0 : vnode.component) == null ? void 0 : _a.subTree) == null ? void 0 : _b.component) == null ? void 0 : _c.bum) {
              vnode.component.subTree.component.bum = null;
            }
          };
          return (_ctx, _cache) => {
            return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(containerKls)),
              style: normalizeStyle({ backgroundColor: _ctx.color }),
              onClick: handleClick
            }, [
              createElementVNode("span", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              _ctx.closable ? (openBlock(), createBlock(unref(ElIcon$1), {
                key: 0,
                class: normalizeClass(unref(ns).e("close")),
                onClick: withModifiers(handleClose, ["stop"])
              }, {
                default: withCtx(() => [
                  createVNode(unref(close_default))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
            ], 6)) : (openBlock(), createBlock(Transition, {
              key: 1,
              name: `${unref(ns).namespace.value}-zoom-in-center`,
              appear: "",
              onVnodeMounted: handleVNodeMounted
            }, {
              default: withCtx(() => [
                createElementVNode("span", {
                  class: normalizeClass(unref(containerKls)),
                  style: normalizeStyle({ backgroundColor: _ctx.color }),
                  onClick: handleClick
                }, [
                  createElementVNode("span", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.closable ? (openBlock(), createBlock(unref(ElIcon$1), {
                    key: 0,
                    class: normalizeClass(unref(ns).e("close")),
                    onClick: withModifiers(handleClose, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(close_default))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 6)
              ]),
              _: 3
            }, 8, ["name"]));
          };
        }
      });
      var Tag = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["__file", "tag.vue"]]);
      const ElTag = withInstall(Tag);
      const nodeList = /* @__PURE__ */ new Map();
      if (isClient) {
        let startClick;
        document.addEventListener("mousedown", (e) => startClick = e);
        document.addEventListener("mouseup", (e) => {
          if (startClick) {
            for (const handlers of nodeList.values()) {
              for (const { documentHandler } of handlers) {
                documentHandler(e, startClick);
              }
            }
            startClick = void 0;
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (isArray$1(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers = nodeList.get(el);
          const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      };
      const emitChangeFn = (value) => isNumber$1(value) || isString$2(value) || isArray$1(value);
      const collapseProps = buildProps({
        accordion: Boolean,
        modelValue: {
          type: definePropType([Array, String, Number]),
          default: () => mutable([])
        }
      });
      const collapseEmits = {
        [UPDATE_MODEL_EVENT]: emitChangeFn,
        [CHANGE_EVENT]: emitChangeFn
      };
      const collapseContextKey = Symbol("collapseContextKey");
      const useCollapse = (props2, emit) => {
        const activeNames = ref(castArray(props2.modelValue));
        const setActiveNames = (_activeNames) => {
          activeNames.value = _activeNames;
          const value = props2.accordion ? activeNames.value[0] : activeNames.value;
          emit(UPDATE_MODEL_EVENT, value);
          emit(CHANGE_EVENT, value);
        };
        const handleItemClick = (name) => {
          if (props2.accordion) {
            setActiveNames([activeNames.value[0] === name ? "" : name]);
          } else {
            const _activeNames = [...activeNames.value];
            const index = _activeNames.indexOf(name);
            if (index > -1) {
              _activeNames.splice(index, 1);
            } else {
              _activeNames.push(name);
            }
            setActiveNames(_activeNames);
          }
        };
        watch(() => props2.modelValue, () => activeNames.value = castArray(props2.modelValue), { deep: true });
        provide(collapseContextKey, {
          activeNames,
          handleItemClick
        });
        return {
          activeNames,
          setActiveNames
        };
      };
      const useCollapseDOM = () => {
        const ns = useNamespace("collapse");
        const rootKls = computed(() => ns.b());
        return {
          rootKls
        };
      };
      const __default__$d = defineComponent({
        name: "ElCollapse"
      });
      const _sfc_main$A = /* @__PURE__ */ defineComponent({
        ...__default__$d,
        props: collapseProps,
        emits: collapseEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const { activeNames, setActiveNames } = useCollapse(props2, emit);
          const { rootKls } = useCollapseDOM();
          expose({
            activeNames,
            setActiveNames
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(rootKls))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Collapse = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["__file", "collapse.vue"]]);
      const __default__$c = defineComponent({
        name: "ElCollapseTransition"
      });
      const _sfc_main$z = /* @__PURE__ */ defineComponent({
        ...__default__$c,
        setup(__props) {
          const ns = useNamespace("collapse-transition");
          const reset = (el) => {
            el.style.maxHeight = "";
            el.style.overflow = el.dataset.oldOverflow;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          };
          const on2 = {
            beforeEnter(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              if (el.style.height)
                el.dataset.elExistsHeight = el.style.height;
              el.style.maxHeight = 0;
              el.style.paddingTop = 0;
              el.style.paddingBottom = 0;
            },
            enter(el) {
              requestAnimationFrame(() => {
                el.dataset.oldOverflow = el.style.overflow;
                if (el.dataset.elExistsHeight) {
                  el.style.maxHeight = el.dataset.elExistsHeight;
                } else if (el.scrollHeight !== 0) {
                  el.style.maxHeight = `${el.scrollHeight}px`;
                } else {
                  el.style.maxHeight = 0;
                }
                el.style.paddingTop = el.dataset.oldPaddingTop;
                el.style.paddingBottom = el.dataset.oldPaddingBottom;
                el.style.overflow = "hidden";
              });
            },
            afterEnter(el) {
              el.style.maxHeight = "";
              el.style.overflow = el.dataset.oldOverflow;
            },
            enterCancelled(el) {
              reset(el);
            },
            beforeLeave(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              el.dataset.oldOverflow = el.style.overflow;
              el.style.maxHeight = `${el.scrollHeight}px`;
              el.style.overflow = "hidden";
            },
            leave(el) {
              if (el.scrollHeight !== 0) {
                el.style.maxHeight = 0;
                el.style.paddingTop = 0;
                el.style.paddingBottom = 0;
              }
            },
            afterLeave(el) {
              reset(el);
            },
            leaveCancelled(el) {
              reset(el);
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, mergeProps({
              name: unref(ns).b()
            }, toHandlers(on2)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["name"]);
          };
        }
      });
      var CollapseTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["__file", "collapse-transition.vue"]]);
      const ElCollapseTransition = withInstall(CollapseTransition);
      const collapseItemProps = buildProps({
        title: {
          type: String,
          default: ""
        },
        name: {
          type: definePropType([String, Number]),
          default: void 0
        },
        icon: {
          type: iconPropType,
          default: arrow_right_default
        },
        disabled: Boolean
      });
      const useCollapseItem = (props2) => {
        const collapse = inject(collapseContextKey);
        const { namespace } = useNamespace("collapse");
        const focusing = ref(false);
        const isClick = ref(false);
        const idInjection = useIdInjection();
        const id = computed(() => idInjection.current++);
        const name = computed(() => {
          var _a;
          return (_a = props2.name) != null ? _a : `${namespace.value}-id-${idInjection.prefix}-${unref(id)}`;
        });
        const isActive = computed(() => collapse == null ? void 0 : collapse.activeNames.value.includes(unref(name)));
        const handleFocus = () => {
          setTimeout(() => {
            if (!isClick.value) {
              focusing.value = true;
            } else {
              isClick.value = false;
            }
          }, 50);
        };
        const handleHeaderClick = () => {
          if (props2.disabled)
            return;
          collapse == null ? void 0 : collapse.handleItemClick(unref(name));
          focusing.value = false;
          isClick.value = true;
        };
        const handleEnterClick = () => {
          collapse == null ? void 0 : collapse.handleItemClick(unref(name));
        };
        return {
          focusing,
          id,
          isActive,
          handleFocus,
          handleHeaderClick,
          handleEnterClick
        };
      };
      const useCollapseItemDOM = (props2, { focusing, isActive, id }) => {
        const ns = useNamespace("collapse");
        const rootKls = computed(() => [
          ns.b("item"),
          ns.is("active", unref(isActive)),
          ns.is("disabled", props2.disabled)
        ]);
        const headKls = computed(() => [
          ns.be("item", "header"),
          ns.is("active", unref(isActive)),
          { focusing: unref(focusing) && !props2.disabled }
        ]);
        const arrowKls = computed(() => [
          ns.be("item", "arrow"),
          ns.is("active", unref(isActive))
        ]);
        const itemWrapperKls = computed(() => ns.be("item", "wrap"));
        const itemContentKls = computed(() => ns.be("item", "content"));
        const scopedContentId = computed(() => ns.b(`content-${unref(id)}`));
        const scopedHeadId = computed(() => ns.b(`head-${unref(id)}`));
        return {
          arrowKls,
          headKls,
          rootKls,
          itemWrapperKls,
          itemContentKls,
          scopedContentId,
          scopedHeadId
        };
      };
      const __default__$b = defineComponent({
        name: "ElCollapseItem"
      });
      const _sfc_main$y = /* @__PURE__ */ defineComponent({
        ...__default__$b,
        props: collapseItemProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const {
            focusing,
            id,
            isActive,
            handleFocus,
            handleHeaderClick,
            handleEnterClick
          } = useCollapseItem(props2);
          const {
            arrowKls,
            headKls,
            rootKls,
            itemWrapperKls,
            itemContentKls,
            scopedContentId,
            scopedHeadId
          } = useCollapseItemDOM(props2, { focusing, isActive, id });
          expose({
            isActive
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(rootKls))
            }, [
              createElementVNode("button", {
                id: unref(scopedHeadId),
                class: normalizeClass(unref(headKls)),
                "aria-expanded": unref(isActive),
                "aria-controls": unref(scopedContentId),
                "aria-describedby": unref(scopedContentId),
                tabindex: _ctx.disabled ? -1 : 0,
                type: "button",
                onClick: unref(handleHeaderClick),
                onKeydown: withKeys(withModifiers(unref(handleEnterClick), ["stop", "prevent"]), ["space", "enter"]),
                onFocus: unref(handleFocus),
                onBlur: ($event) => focusing.value = false
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(_ctx.title), 1)
                ]),
                renderSlot(_ctx.$slots, "icon", { isActive: unref(isActive) }, () => [
                  createVNode(unref(ElIcon$1), {
                    class: normalizeClass(unref(arrowKls))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ])
              ], 42, ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex", "onClick", "onKeydown", "onFocus", "onBlur"]),
              createVNode(unref(ElCollapseTransition), null, {
                default: withCtx(() => [
                  withDirectives(createElementVNode("div", {
                    id: unref(scopedContentId),
                    role: "region",
                    class: normalizeClass(unref(itemWrapperKls)),
                    "aria-hidden": !unref(isActive),
                    "aria-labelledby": unref(scopedHeadId)
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(unref(itemContentKls))
                    }, [
                      renderSlot(_ctx.$slots, "default")
                    ], 2)
                  ], 10, ["id", "aria-hidden", "aria-labelledby"]), [
                    [vShow, unref(isActive)]
                  ])
                ]),
                _: 3
              })
            ], 2);
          };
        }
      });
      var CollapseItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["__file", "collapse-item.vue"]]);
      const ElCollapse = withInstall(Collapse, {
        CollapseItem
      });
      const ElCollapseItem = withNoopInstall(CollapseItem);
      const alphaSliderProps = buildProps({
        color: {
          type: definePropType(Object),
          required: true
        },
        vertical: {
          type: Boolean,
          default: false
        }
      });
      let isDragging = false;
      function draggable(element, options2) {
        if (!isClient)
          return;
        const moveFn = function(event) {
          var _a;
          (_a = options2.drag) == null ? void 0 : _a.call(options2, event);
        };
        const upFn = function(event) {
          var _a;
          document.removeEventListener("mousemove", moveFn);
          document.removeEventListener("mouseup", upFn);
          document.removeEventListener("touchmove", moveFn);
          document.removeEventListener("touchend", upFn);
          document.onselectstart = null;
          document.ondragstart = null;
          isDragging = false;
          (_a = options2.end) == null ? void 0 : _a.call(options2, event);
        };
        const downFn = function(event) {
          var _a;
          if (isDragging)
            return;
          event.preventDefault();
          document.onselectstart = () => false;
          document.ondragstart = () => false;
          document.addEventListener("mousemove", moveFn);
          document.addEventListener("mouseup", upFn);
          document.addEventListener("touchmove", moveFn);
          document.addEventListener("touchend", upFn);
          isDragging = true;
          (_a = options2.start) == null ? void 0 : _a.call(options2, event);
        };
        element.addEventListener("mousedown", downFn);
        element.addEventListener("touchstart", downFn, { passive: false });
      }
      const getClientXY = (event) => {
        let clientX;
        let clientY;
        if (event.type === "touchend") {
          clientY = event.changedTouches[0].clientY;
          clientX = event.changedTouches[0].clientX;
        } else if (event.type.startsWith("touch")) {
          clientY = event.touches[0].clientY;
          clientX = event.touches[0].clientX;
        } else {
          clientY = event.clientY;
          clientX = event.clientX;
        }
        return {
          clientX,
          clientY
        };
      };
      const useAlphaSlider = (props2) => {
        const instance = getCurrentInstance();
        const { t } = useLocale();
        const thumb = shallowRef();
        const bar = shallowRef();
        const alpha = computed(() => props2.color.get("alpha"));
        const alphaLabel = computed(() => t("el.colorpicker.alphaLabel"));
        function handleClick(event) {
          var _a;
          const target = event.target;
          if (target !== thumb.value) {
            handleDrag(event);
          }
          (_a = thumb.value) == null ? void 0 : _a.focus();
        }
        function handleDrag(event) {
          if (!bar.value || !thumb.value)
            return;
          const el = instance.vnode.el;
          const rect = el.getBoundingClientRect();
          const { clientX, clientY } = getClientXY(event);
          if (!props2.vertical) {
            let left = clientX - rect.left;
            left = Math.max(thumb.value.offsetWidth / 2, left);
            left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
            props2.color.set("alpha", Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
          } else {
            let top = clientY - rect.top;
            top = Math.max(thumb.value.offsetHeight / 2, top);
            top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
            props2.color.set("alpha", Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
          }
        }
        function handleKeydown(event) {
          const { code, shiftKey } = event;
          const step = shiftKey ? 10 : 1;
          switch (code) {
            case EVENT_CODE.left:
            case EVENT_CODE.down:
              event.preventDefault();
              event.stopPropagation();
              incrementPosition(-step);
              break;
            case EVENT_CODE.right:
            case EVENT_CODE.up:
              event.preventDefault();
              event.stopPropagation();
              incrementPosition(step);
              break;
          }
        }
        function incrementPosition(step) {
          let next2 = alpha.value + step;
          next2 = next2 < 0 ? 0 : next2 > 100 ? 100 : next2;
          props2.color.set("alpha", next2);
        }
        return {
          thumb,
          bar,
          alpha,
          alphaLabel,
          handleDrag,
          handleClick,
          handleKeydown
        };
      };
      const useAlphaSliderDOM = (props2, {
        bar,
        thumb,
        handleDrag
      }) => {
        const instance = getCurrentInstance();
        const ns = useNamespace("color-alpha-slider");
        const thumbLeft = ref(0);
        const thumbTop = ref(0);
        const background = ref();
        function getThumbLeft() {
          if (!thumb.value)
            return 0;
          if (props2.vertical)
            return 0;
          const el = instance.vnode.el;
          const alpha = props2.color.get("alpha");
          if (!el)
            return 0;
          return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
        }
        function getThumbTop() {
          if (!thumb.value)
            return 0;
          const el = instance.vnode.el;
          if (!props2.vertical)
            return 0;
          const alpha = props2.color.get("alpha");
          if (!el)
            return 0;
          return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
        }
        function getBackground() {
          if (props2.color && props2.color.value) {
            const { r, g, b: b2 } = props2.color.toRgb();
            return `linear-gradient(to right, rgba(${r}, ${g}, ${b2}, 0) 0%, rgba(${r}, ${g}, ${b2}, 1) 100%)`;
          }
          return "";
        }
        function update() {
          thumbLeft.value = getThumbLeft();
          thumbTop.value = getThumbTop();
          background.value = getBackground();
        }
        onMounted(() => {
          if (!bar.value || !thumb.value)
            return;
          const dragConfig = {
            drag: (event) => {
              handleDrag(event);
            },
            end: (event) => {
              handleDrag(event);
            }
          };
          draggable(bar.value, dragConfig);
          draggable(thumb.value, dragConfig);
          update();
        });
        watch(() => props2.color.get("alpha"), () => update());
        watch(() => props2.color.value, () => update());
        const rootKls = computed(() => [ns.b(), ns.is("vertical", props2.vertical)]);
        const barKls = computed(() => ns.e("bar"));
        const thumbKls = computed(() => ns.e("thumb"));
        const barStyle = computed(() => ({ background: background.value }));
        const thumbStyle = computed(() => ({
          left: addUnit(thumbLeft.value),
          top: addUnit(thumbTop.value)
        }));
        return { rootKls, barKls, barStyle, thumbKls, thumbStyle, update };
      };
      const COMPONENT_NAME$2 = "ElColorAlphaSlider";
      const __default__$a = defineComponent({
        name: COMPONENT_NAME$2
      });
      const _sfc_main$x = /* @__PURE__ */ defineComponent({
        ...__default__$a,
        props: alphaSliderProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const {
            alpha,
            alphaLabel,
            bar,
            thumb,
            handleDrag,
            handleClick,
            handleKeydown
          } = useAlphaSlider(props2);
          const { rootKls, barKls, barStyle, thumbKls, thumbStyle, update } = useAlphaSliderDOM(props2, {
            bar,
            thumb,
            handleDrag
          });
          expose({
            update,
            bar,
            thumb
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(rootKls))
            }, [
              createElementVNode("div", {
                ref_key: "bar",
                ref: bar,
                class: normalizeClass(unref(barKls)),
                style: normalizeStyle(unref(barStyle)),
                onClick: unref(handleClick)
              }, null, 14, ["onClick"]),
              createElementVNode("div", {
                ref_key: "thumb",
                ref: thumb,
                class: normalizeClass(unref(thumbKls)),
                style: normalizeStyle(unref(thumbStyle)),
                "aria-label": unref(alphaLabel),
                "aria-valuenow": unref(alpha),
                "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                "aria-valuemin": "0",
                "aria-valuemax": "100",
                role: "slider",
                tabindex: "0",
                onKeydown: unref(handleKeydown)
              }, null, 46, ["aria-label", "aria-valuenow", "aria-orientation", "onKeydown"])
            ], 2);
          };
        }
      });
      var AlphaSlider = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["__file", "alpha-slider.vue"]]);
      const _sfc_main$w = defineComponent({
        name: "ElColorHueSlider",
        props: {
          color: {
            type: Object,
            required: true
          },
          vertical: Boolean
        },
        setup(props2) {
          const ns = useNamespace("color-hue-slider");
          const instance = getCurrentInstance();
          const thumb = ref();
          const bar = ref();
          const thumbLeft = ref(0);
          const thumbTop = ref(0);
          const hueValue = computed(() => {
            return props2.color.get("hue");
          });
          watch(() => hueValue.value, () => {
            update();
          });
          function handleClick(event) {
            const target = event.target;
            if (target !== thumb.value) {
              handleDrag(event);
            }
          }
          function handleDrag(event) {
            if (!bar.value || !thumb.value)
              return;
            const el = instance.vnode.el;
            const rect = el.getBoundingClientRect();
            const { clientX, clientY } = getClientXY(event);
            let hue;
            if (!props2.vertical) {
              let left = clientX - rect.left;
              left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
              left = Math.max(thumb.value.offsetWidth / 2, left);
              hue = Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
            } else {
              let top = clientY - rect.top;
              top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
              top = Math.max(thumb.value.offsetHeight / 2, top);
              hue = Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
            }
            props2.color.set("hue", hue);
          }
          function getThumbLeft() {
            if (!thumb.value)
              return 0;
            const el = instance.vnode.el;
            if (props2.vertical)
              return 0;
            const hue = props2.color.get("hue");
            if (!el)
              return 0;
            return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
          }
          function getThumbTop() {
            if (!thumb.value)
              return 0;
            const el = instance.vnode.el;
            if (!props2.vertical)
              return 0;
            const hue = props2.color.get("hue");
            if (!el)
              return 0;
            return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
          }
          function update() {
            thumbLeft.value = getThumbLeft();
            thumbTop.value = getThumbTop();
          }
          onMounted(() => {
            if (!bar.value || !thumb.value)
              return;
            const dragConfig = {
              drag: (event) => {
                handleDrag(event);
              },
              end: (event) => {
                handleDrag(event);
              }
            };
            draggable(bar.value, dragConfig);
            draggable(thumb.value, dragConfig);
            update();
          });
          return {
            bar,
            thumb,
            thumbLeft,
            thumbTop,
            hueValue,
            handleClick,
            update,
            ns
          };
        }
      });
      function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("vertical", _ctx.vertical)])
        }, [
          createElementVNode("div", {
            ref: "bar",
            class: normalizeClass(_ctx.ns.e("bar")),
            onClick: _ctx.handleClick
          }, null, 10, ["onClick"]),
          createElementVNode("div", {
            ref: "thumb",
            class: normalizeClass(_ctx.ns.e("thumb")),
            style: normalizeStyle({
              left: _ctx.thumbLeft + "px",
              top: _ctx.thumbTop + "px"
            })
          }, null, 6)
        ], 2);
      }
      var HueSlider = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["render", _sfc_render$6], ["__file", "hue-slider.vue"]]);
      const colorPickerProps = buildProps({
        modelValue: String,
        id: String,
        showAlpha: Boolean,
        colorFormat: String,
        disabled: Boolean,
        size: useSizeProp,
        popperClass: {
          type: String,
          default: ""
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        teleported: useTooltipContentProps.teleported,
        predefine: {
          type: definePropType(Array)
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      });
      const colorPickerEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString$2(val) || isNil(val),
        [CHANGE_EVENT]: (val) => isString$2(val) || isNil(val),
        activeChange: (val) => isString$2(val) || isNil(val),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent
      };
      const colorPickerContextKey = Symbol("colorPickerContextKey");
      const hsv2hsl = function(hue, sat, val) {
        return [
          hue,
          sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0,
          hue / 2
        ];
      };
      const isOnePointZero = function(n) {
        return isString$2(n) && n.includes(".") && Number.parseFloat(n) === 1;
      };
      const isPercentage = function(n) {
        return isString$2(n) && n.includes("%");
      };
      const bound01 = function(value, max) {
        if (isOnePointZero(value))
          value = "100%";
        const processPercent = isPercentage(value);
        value = Math.min(max, Math.max(0, Number.parseFloat(`${value}`)));
        if (processPercent) {
          value = Number.parseInt(`${value * max}`, 10) / 100;
        }
        if (Math.abs(value - max) < 1e-6) {
          return 1;
        }
        return value % max / Number.parseFloat(max);
      };
      const INT_HEX_MAP = {
        10: "A",
        11: "B",
        12: "C",
        13: "D",
        14: "E",
        15: "F"
      };
      const hexOne = (value) => {
        value = Math.min(Math.round(value), 255);
        const high = Math.floor(value / 16);
        const low = value % 16;
        return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`;
      };
      const toHex = function({ r, g, b: b2 }) {
        if (Number.isNaN(+r) || Number.isNaN(+g) || Number.isNaN(+b2))
          return "";
        return `#${hexOne(r)}${hexOne(g)}${hexOne(b2)}`;
      };
      const HEX_INT_MAP = {
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15
      };
      const parseHexChannel = function(hex2) {
        if (hex2.length === 2) {
          return (HEX_INT_MAP[hex2[0].toUpperCase()] || +hex2[0]) * 16 + (HEX_INT_MAP[hex2[1].toUpperCase()] || +hex2[1]);
        }
        return HEX_INT_MAP[hex2[1].toUpperCase()] || +hex2[1];
      };
      const hsl2hsv = function(hue, sat, light) {
        sat = sat / 100;
        light = light / 100;
        let smin = sat;
        const lmin = Math.max(light, 0.01);
        light *= 2;
        sat *= light <= 1 ? light : 2 - light;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v2 = (light + sat) / 2;
        const sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
        return {
          h: hue,
          s: sv * 100,
          v: v2 * 100
        };
      };
      const rgb2hsv = (r, g, b2) => {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b2 = bound01(b2, 255);
        const max = Math.max(r, g, b2);
        const min = Math.min(r, g, b2);
        let h2;
        const v2 = max;
        const d2 = max - min;
        const s2 = max === 0 ? 0 : d2 / max;
        if (max === min) {
          h2 = 0;
        } else {
          switch (max) {
            case r: {
              h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
              break;
            }
            case g: {
              h2 = (b2 - r) / d2 + 2;
              break;
            }
            case b2: {
              h2 = (r - g) / d2 + 4;
              break;
            }
          }
          h2 /= 6;
        }
        return { h: h2 * 360, s: s2 * 100, v: v2 * 100 };
      };
      const hsv2rgb = function(h2, s2, v2) {
        h2 = bound01(h2, 360) * 6;
        s2 = bound01(s2, 100);
        v2 = bound01(v2, 100);
        const i = Math.floor(h2);
        const f2 = h2 - i;
        const p2 = v2 * (1 - s2);
        const q2 = v2 * (1 - f2 * s2);
        const t = v2 * (1 - (1 - f2) * s2);
        const mod = i % 6;
        const r = [v2, q2, p2, p2, t, v2][mod];
        const g = [t, v2, v2, q2, p2, p2][mod];
        const b2 = [p2, p2, t, v2, v2, q2][mod];
        return {
          r: Math.round(r * 255),
          g: Math.round(g * 255),
          b: Math.round(b2 * 255)
        };
      };
      class Color {
        constructor(options2 = {}) {
          this._hue = 0;
          this._saturation = 100;
          this._value = 100;
          this._alpha = 100;
          this.enableAlpha = false;
          this.format = "hex";
          this.value = "";
          for (const option in options2) {
            if (hasOwn(options2, option)) {
              this[option] = options2[option];
            }
          }
          if (options2.value) {
            this.fromString(options2.value);
          } else {
            this.doOnChange();
          }
        }
        set(prop, value) {
          if (arguments.length === 1 && typeof prop === "object") {
            for (const p2 in prop) {
              if (hasOwn(prop, p2)) {
                this.set(p2, prop[p2]);
              }
            }
            return;
          }
          this[`_${prop}`] = value;
          this.doOnChange();
        }
        get(prop) {
          if (prop === "alpha") {
            return Math.floor(this[`_${prop}`]);
          }
          return this[`_${prop}`];
        }
        toRgb() {
          return hsv2rgb(this._hue, this._saturation, this._value);
        }
        fromString(value) {
          if (!value) {
            this._hue = 0;
            this._saturation = 100;
            this._value = 100;
            this.doOnChange();
            return;
          }
          const fromHSV = (h2, s2, v2) => {
            this._hue = Math.max(0, Math.min(360, h2));
            this._saturation = Math.max(0, Math.min(100, s2));
            this._value = Math.max(0, Math.min(100, v2));
            this.doOnChange();
          };
          if (value.includes("hsl")) {
            const parts = value.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index) => index > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
            if (parts.length === 4) {
              this._alpha = Number.parseFloat(parts[3]) * 100;
            } else if (parts.length === 3) {
              this._alpha = 100;
            }
            if (parts.length >= 3) {
              const { h: h2, s: s2, v: v2 } = hsl2hsv(parts[0], parts[1], parts[2]);
              fromHSV(h2, s2, v2);
            }
          } else if (value.includes("hsv")) {
            const parts = value.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index) => index > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
            if (parts.length === 4) {
              this._alpha = Number.parseFloat(parts[3]) * 100;
            } else if (parts.length === 3) {
              this._alpha = 100;
            }
            if (parts.length >= 3) {
              fromHSV(parts[0], parts[1], parts[2]);
            }
          } else if (value.includes("rgb")) {
            const parts = value.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index) => index > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
            if (parts.length === 4) {
              this._alpha = Number.parseFloat(parts[3]) * 100;
            } else if (parts.length === 3) {
              this._alpha = 100;
            }
            if (parts.length >= 3) {
              const { h: h2, s: s2, v: v2 } = rgb2hsv(parts[0], parts[1], parts[2]);
              fromHSV(h2, s2, v2);
            }
          } else if (value.includes("#")) {
            const hex2 = value.replace("#", "").trim();
            if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex2))
              return;
            let r, g, b2;
            if (hex2.length === 3) {
              r = parseHexChannel(hex2[0] + hex2[0]);
              g = parseHexChannel(hex2[1] + hex2[1]);
              b2 = parseHexChannel(hex2[2] + hex2[2]);
            } else if (hex2.length === 6 || hex2.length === 8) {
              r = parseHexChannel(hex2.slice(0, 2));
              g = parseHexChannel(hex2.slice(2, 4));
              b2 = parseHexChannel(hex2.slice(4, 6));
            }
            if (hex2.length === 8) {
              this._alpha = parseHexChannel(hex2.slice(6)) / 255 * 100;
            } else if (hex2.length === 3 || hex2.length === 6) {
              this._alpha = 100;
            }
            const { h: h2, s: s2, v: v2 } = rgb2hsv(r, g, b2);
            fromHSV(h2, s2, v2);
          }
        }
        compare(color) {
          return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
        }
        doOnChange() {
          const { _hue, _saturation, _value, _alpha, format: format2 } = this;
          if (this.enableAlpha) {
            switch (format2) {
              case "hsl": {
                const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
                this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${this.get("alpha") / 100})`;
                break;
              }
              case "hsv": {
                this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${this.get("alpha") / 100})`;
                break;
              }
              case "hex": {
                this.value = `${toHex(hsv2rgb(_hue, _saturation, _value))}${hexOne(_alpha * 255 / 100)}`;
                break;
              }
              default: {
                const { r, g, b: b2 } = hsv2rgb(_hue, _saturation, _value);
                this.value = `rgba(${r}, ${g}, ${b2}, ${this.get("alpha") / 100})`;
              }
            }
          } else {
            switch (format2) {
              case "hsl": {
                const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
                this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
                break;
              }
              case "hsv": {
                this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
                break;
              }
              case "rgb": {
                const { r, g, b: b2 } = hsv2rgb(_hue, _saturation, _value);
                this.value = `rgb(${r}, ${g}, ${b2})`;
                break;
              }
              default: {
                this.value = toHex(hsv2rgb(_hue, _saturation, _value));
              }
            }
          }
        }
      }
      const _sfc_main$v = defineComponent({
        props: {
          colors: {
            type: Array,
            required: true
          },
          color: {
            type: Object,
            required: true
          },
          enableAlpha: {
            type: Boolean,
            required: true
          }
        },
        setup(props2) {
          const ns = useNamespace("color-predefine");
          const { currentColor } = inject(colorPickerContextKey);
          const rgbaColors = ref(parseColors(props2.colors, props2.color));
          watch(() => currentColor.value, (val) => {
            const color = new Color();
            color.fromString(val);
            rgbaColors.value.forEach((item) => {
              item.selected = color.compare(item);
            });
          });
          watchEffect(() => {
            rgbaColors.value = parseColors(props2.colors, props2.color);
          });
          function handleSelect(index) {
            props2.color.fromString(props2.colors[index]);
          }
          function parseColors(colors, color) {
            return colors.map((value) => {
              const c2 = new Color();
              c2.enableAlpha = props2.enableAlpha;
              c2.format = "rgba";
              c2.fromString(value);
              c2.selected = c2.value === color.value;
              return c2;
            });
          }
          return {
            rgbaColors,
            handleSelect,
            ns
          };
        }
      });
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(_ctx.ns.b())
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("colors"))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rgbaColors, (item, index) => {
              return openBlock(), createElementBlock("div", {
                key: _ctx.colors[index],
                class: normalizeClass([
                  _ctx.ns.e("color-selector"),
                  _ctx.ns.is("alpha", item._alpha < 100),
                  { selected: item.selected }
                ]),
                onClick: ($event) => _ctx.handleSelect(index)
              }, [
                createElementVNode("div", {
                  style: normalizeStyle({ backgroundColor: item.value })
                }, null, 4)
              ], 10, ["onClick"]);
            }), 128))
          ], 2)
        ], 2);
      }
      var Predefine = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$5], ["__file", "predefine.vue"]]);
      const _sfc_main$u = defineComponent({
        name: "ElSlPanel",
        props: {
          color: {
            type: Object,
            required: true
          }
        },
        setup(props2) {
          const ns = useNamespace("color-svpanel");
          const instance = getCurrentInstance();
          const cursorTop = ref(0);
          const cursorLeft = ref(0);
          const background = ref("hsl(0, 100%, 50%)");
          const colorValue = computed(() => {
            const hue = props2.color.get("hue");
            const value = props2.color.get("value");
            return { hue, value };
          });
          function update() {
            const saturation = props2.color.get("saturation");
            const value = props2.color.get("value");
            const el = instance.vnode.el;
            const { clientWidth: width, clientHeight: height } = el;
            cursorLeft.value = saturation * width / 100;
            cursorTop.value = (100 - value) * height / 100;
            background.value = `hsl(${props2.color.get("hue")}, 100%, 50%)`;
          }
          function handleDrag(event) {
            const el = instance.vnode.el;
            const rect = el.getBoundingClientRect();
            const { clientX, clientY } = getClientXY(event);
            let left = clientX - rect.left;
            let top = clientY - rect.top;
            left = Math.max(0, left);
            left = Math.min(left, rect.width);
            top = Math.max(0, top);
            top = Math.min(top, rect.height);
            cursorLeft.value = left;
            cursorTop.value = top;
            props2.color.set({
              saturation: left / rect.width * 100,
              value: 100 - top / rect.height * 100
            });
          }
          watch(() => colorValue.value, () => {
            update();
          });
          onMounted(() => {
            draggable(instance.vnode.el, {
              drag: (event) => {
                handleDrag(event);
              },
              end: (event) => {
                handleDrag(event);
              }
            });
            update();
          });
          return {
            cursorTop,
            cursorLeft,
            background,
            colorValue,
            handleDrag,
            update,
            ns
          };
        }
      });
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(_ctx.ns.b()),
          style: normalizeStyle({
            backgroundColor: _ctx.background
          })
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("white"))
          }, null, 2),
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("black"))
          }, null, 2),
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("cursor")),
            style: normalizeStyle({
              top: _ctx.cursorTop + "px",
              left: _ctx.cursorLeft + "px"
            })
          }, [
            createElementVNode("div")
          ], 6)
        ], 6);
      }
      var SvPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$4], ["__file", "sv-panel.vue"]]);
      const __default__$9 = defineComponent({
        name: "ElColorPicker"
      });
      const _sfc_main$t = /* @__PURE__ */ defineComponent({
        ...__default__$9,
        props: colorPickerProps,
        emits: colorPickerEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const { t } = useLocale();
          const ns = useNamespace("color");
          const { formItem } = useFormItem();
          const colorSize = useFormSize();
          const colorDisabled = useFormDisabled();
          const { inputId: buttonId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext: formItem
          });
          const hue = ref();
          const sv = ref();
          const alpha = ref();
          const popper = ref();
          const triggerRef = ref();
          const inputRef = ref();
          const { isFocused, handleFocus, handleBlur } = useFocusController(triggerRef, {
            beforeFocus() {
              return colorDisabled.value;
            },
            beforeBlur(event) {
              var _a;
              return (_a = popper.value) == null ? void 0 : _a.isFocusInsideContent(event);
            },
            afterBlur() {
              setShowPicker(false);
              resetColor();
            }
          });
          let shouldActiveChange = true;
          const color = reactive(new Color({
            enableAlpha: props2.showAlpha,
            format: props2.colorFormat || "",
            value: props2.modelValue
          }));
          const showPicker = ref(false);
          const showPanelColor = ref(false);
          const customInput = ref("");
          const displayedColor = computed(() => {
            if (!props2.modelValue && !showPanelColor.value) {
              return "transparent";
            }
            return displayedRgb(color, props2.showAlpha);
          });
          const currentColor = computed(() => {
            return !props2.modelValue && !showPanelColor.value ? "" : color.value;
          });
          const buttonAriaLabel = computed(() => {
            return !isLabeledByFormItem.value ? props2.ariaLabel || t("el.colorpicker.defaultLabel") : void 0;
          });
          const buttonAriaLabelledby = computed(() => {
            return isLabeledByFormItem.value ? formItem == null ? void 0 : formItem.labelId : void 0;
          });
          const btnKls = computed(() => {
            return [
              ns.b("picker"),
              ns.is("disabled", colorDisabled.value),
              ns.bm("picker", colorSize.value),
              ns.is("focused", isFocused.value)
            ];
          });
          function displayedRgb(color2, showAlpha) {
            if (!(color2 instanceof Color)) {
              throw new TypeError("color should be instance of _color Class");
            }
            const { r, g, b: b2 } = color2.toRgb();
            return showAlpha ? `rgba(${r}, ${g}, ${b2}, ${color2.get("alpha") / 100})` : `rgb(${r}, ${g}, ${b2})`;
          }
          function setShowPicker(value) {
            showPicker.value = value;
          }
          const debounceSetShowPicker = debounce(setShowPicker, 100, { leading: true });
          function show() {
            if (colorDisabled.value)
              return;
            setShowPicker(true);
          }
          function hide() {
            debounceSetShowPicker(false);
            resetColor();
          }
          function resetColor() {
            nextTick(() => {
              if (props2.modelValue) {
                color.fromString(props2.modelValue);
              } else {
                color.value = "";
                nextTick(() => {
                  showPanelColor.value = false;
                });
              }
            });
          }
          function handleTrigger() {
            if (colorDisabled.value)
              return;
            if (showPicker.value) {
              resetColor();
            }
            debounceSetShowPicker(!showPicker.value);
          }
          function handleConfirm() {
            color.fromString(customInput.value);
          }
          function confirmValue() {
            const value = color.value;
            emit(UPDATE_MODEL_EVENT, value);
            emit("change", value);
            if (props2.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
            debounceSetShowPicker(false);
            nextTick(() => {
              const newColor = new Color({
                enableAlpha: props2.showAlpha,
                format: props2.colorFormat || "",
                value: props2.modelValue
              });
              if (!color.compare(newColor)) {
                resetColor();
              }
            });
          }
          function clear() {
            debounceSetShowPicker(false);
            emit(UPDATE_MODEL_EVENT, null);
            emit("change", null);
            if (props2.modelValue !== null && props2.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
            resetColor();
          }
          function handleClickOutside() {
            if (!showPicker.value)
              return;
            hide();
            isFocused.value && focus();
          }
          function handleEsc(event) {
            event.preventDefault();
            event.stopPropagation();
            setShowPicker(false);
            resetColor();
          }
          function handleKeyDown(event) {
            switch (event.code) {
              case EVENT_CODE.enter:
              case EVENT_CODE.numpadEnter:
              case EVENT_CODE.space:
                event.preventDefault();
                event.stopPropagation();
                show();
                inputRef.value.focus();
                break;
              case EVENT_CODE.esc:
                handleEsc(event);
                break;
            }
          }
          function focus() {
            triggerRef.value.focus();
          }
          function blur() {
            triggerRef.value.blur();
          }
          onMounted(() => {
            if (props2.modelValue) {
              customInput.value = currentColor.value;
            }
          });
          watch(() => props2.modelValue, (newVal) => {
            if (!newVal) {
              showPanelColor.value = false;
            } else if (newVal && newVal !== color.value) {
              shouldActiveChange = false;
              color.fromString(newVal);
            }
          });
          watch(() => [props2.colorFormat, props2.showAlpha], () => {
            color.enableAlpha = props2.showAlpha;
            color.format = props2.colorFormat || color.format;
            color.doOnChange();
            emit(UPDATE_MODEL_EVENT, color.value);
          });
          watch(() => currentColor.value, (val) => {
            customInput.value = val;
            shouldActiveChange && emit("activeChange", val);
            shouldActiveChange = true;
          });
          watch(() => color.value, () => {
            if (!props2.modelValue && !showPanelColor.value) {
              showPanelColor.value = true;
            }
          });
          watch(() => showPicker.value, () => {
            nextTick(() => {
              var _a, _b, _c;
              (_a = hue.value) == null ? void 0 : _a.update();
              (_b = sv.value) == null ? void 0 : _b.update();
              (_c = alpha.value) == null ? void 0 : _c.update();
            });
          });
          provide(colorPickerContextKey, {
            currentColor
          });
          expose({
            color,
            show,
            hide,
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), {
              ref_key: "popper",
              ref: popper,
              visible: showPicker.value,
              "show-arrow": false,
              "fallback-placements": ["bottom", "top", "right", "left"],
              offset: 0,
              "gpu-acceleration": false,
              "popper-class": [unref(ns).be("picker", "panel"), unref(ns).b("dropdown"), _ctx.popperClass],
              "stop-popper-mouse-event": false,
              effect: "light",
              trigger: "click",
              teleported: _ctx.teleported,
              transition: `${unref(ns).namespace.value}-zoom-in-top`,
              persistent: "",
              onHide: ($event) => setShowPicker(false)
            }, {
              content: withCtx(() => [
                withDirectives((openBlock(), createElementBlock("div", {
                  onKeydown: withKeys(handleEsc, ["esc"])
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).be("dropdown", "main-wrapper"))
                  }, [
                    createVNode(HueSlider, {
                      ref_key: "hue",
                      ref: hue,
                      class: "hue-slider",
                      color: unref(color),
                      vertical: ""
                    }, null, 8, ["color"]),
                    createVNode(SvPanel, {
                      ref_key: "sv",
                      ref: sv,
                      color: unref(color)
                    }, null, 8, ["color"])
                  ], 2),
                  _ctx.showAlpha ? (openBlock(), createBlock(AlphaSlider, {
                    key: 0,
                    ref_key: "alpha",
                    ref: alpha,
                    color: unref(color)
                  }, null, 8, ["color"])) : createCommentVNode("v-if", true),
                  _ctx.predefine ? (openBlock(), createBlock(Predefine, {
                    key: 1,
                    ref: "predefine",
                    "enable-alpha": _ctx.showAlpha,
                    color: unref(color),
                    colors: _ctx.predefine
                  }, null, 8, ["enable-alpha", "color", "colors"])) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).be("dropdown", "btns"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(ns).be("dropdown", "value"))
                    }, [
                      createVNode(unref(ElInput), {
                        ref_key: "inputRef",
                        ref: inputRef,
                        modelValue: customInput.value,
                        "onUpdate:modelValue": ($event) => customInput.value = $event,
                        "validate-event": false,
                        size: "small",
                        onKeyup: withKeys(handleConfirm, ["enter"]),
                        onBlur: handleConfirm
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "onKeyup"])
                    ], 2),
                    createVNode(unref(ElButton$1), {
                      class: normalizeClass(unref(ns).be("dropdown", "link-btn")),
                      text: "",
                      size: "small",
                      onClick: clear
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(unref(t)("el.colorpicker.clear")), 1)
                      ]),
                      _: 1
                    }, 8, ["class"]),
                    createVNode(unref(ElButton$1), {
                      plain: "",
                      size: "small",
                      class: normalizeClass(unref(ns).be("dropdown", "btn")),
                      onClick: confirmValue
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(unref(t)("el.colorpicker.confirm")), 1)
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ], 2)
                ], 40, ["onKeydown"])), [
                  [unref(ClickOutside), handleClickOutside, triggerRef.value]
                ])
              ]),
              default: withCtx(() => [
                createElementVNode("div", mergeProps({
                  id: unref(buttonId),
                  ref_key: "triggerRef",
                  ref: triggerRef
                }, _ctx.$attrs, {
                  class: unref(btnKls),
                  role: "button",
                  "aria-label": unref(buttonAriaLabel),
                  "aria-labelledby": unref(buttonAriaLabelledby),
                  "aria-description": unref(t)("el.colorpicker.description", { color: _ctx.modelValue || "" }),
                  "aria-disabled": unref(colorDisabled),
                  tabindex: unref(colorDisabled) ? -1 : _ctx.tabindex,
                  onKeydown: handleKeyDown,
                  onFocus: unref(handleFocus),
                  onBlur: unref(handleBlur)
                }), [
                  unref(colorDisabled) ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(ns).be("picker", "mask"))
                  }, null, 2)) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).be("picker", "trigger")),
                    onClick: handleTrigger
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass([unref(ns).be("picker", "color"), unref(ns).is("alpha", _ctx.showAlpha)])
                    }, [
                      createElementVNode("span", {
                        class: normalizeClass(unref(ns).be("picker", "color-inner")),
                        style: normalizeStyle({
                          backgroundColor: unref(displayedColor)
                        })
                      }, [
                        withDirectives(createVNode(unref(ElIcon$1), {
                          class: normalizeClass([unref(ns).be("picker", "icon"), unref(ns).is("icon-arrow-down")])
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_down_default))
                          ]),
                          _: 1
                        }, 8, ["class"]), [
                          [vShow, _ctx.modelValue || showPanelColor.value]
                        ]),
                        withDirectives(createVNode(unref(ElIcon$1), {
                          class: normalizeClass([unref(ns).be("picker", "empty"), unref(ns).is("icon-close")])
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(close_default))
                          ]),
                          _: 1
                        }, 8, ["class"]), [
                          [vShow, !_ctx.modelValue && !showPanelColor.value]
                        ])
                      ], 6)
                    ], 2)
                  ], 2)
                ], 16, ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex", "onFocus", "onBlur"])
              ]),
              _: 1
            }, 8, ["visible", "popper-class", "teleported", "transition", "onHide"]);
          };
        }
      });
      var ColorPicker = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["__file", "color-picker.vue"]]);
      const ElColorPicker = withInstall(ColorPicker);
      const REPEAT_INTERVAL = 100;
      const REPEAT_DELAY = 600;
      const vRepeatClick = {
        beforeMount(el, binding) {
          const value = binding.value;
          const { interval = REPEAT_INTERVAL, delay: delay2 = REPEAT_DELAY } = isFunction$2(value) ? {} : value;
          let intervalId;
          let delayId;
          const handler = () => isFunction$2(value) ? value() : value.handler();
          const clear = () => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = void 0;
            }
          };
          el.addEventListener("mousedown", (evt) => {
            if (evt.button !== 0)
              return;
            clear();
            handler();
            document.addEventListener("mouseup", () => clear(), {
              once: true
            });
            delayId = setTimeout(() => {
              intervalId = setInterval(() => {
                handler();
              }, interval);
            }, delay2);
          });
        }
      };
      const useSameTarget = (handleClick) => {
        if (!handleClick) {
          return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
        }
        let mousedownTarget = false;
        let mouseupTarget = false;
        const onClick = (e) => {
          if (mousedownTarget && mouseupTarget) {
            handleClick(e);
          }
          mousedownTarget = mouseupTarget = false;
        };
        const onMousedown = (e) => {
          mousedownTarget = e.target === e.currentTarget;
        };
        const onMouseup = (e) => {
          mouseupTarget = e.target === e.currentTarget;
        };
        return { onClick, onMousedown, onMouseup };
      };
      const overlayProps = buildProps({
        mask: {
          type: Boolean,
          default: true
        },
        customMaskEvent: Boolean,
        overlayClass: {
          type: definePropType([
            String,
            Array,
            Object
          ])
        },
        zIndex: {
          type: definePropType([String, Number])
        }
      });
      const overlayEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const BLOCK = "overlay";
      var Overlay = defineComponent({
        name: "ElOverlay",
        props: overlayProps,
        emits: overlayEmits,
        setup(props2, { slots, emit }) {
          const ns = useNamespace(BLOCK);
          const onMaskClick = (e) => {
            emit("click", e);
          };
          const { onClick, onMousedown, onMouseup } = useSameTarget(props2.customMaskEvent ? void 0 : onMaskClick);
          return () => {
            return props2.mask ? createVNode("div", {
              class: [ns.b(), props2.overlayClass],
              style: {
                zIndex: props2.zIndex
              },
              onClick,
              onMousedown,
              onMouseup
            }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h$1("div", {
              class: props2.overlayClass,
              style: {
                zIndex: props2.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
              }
            }, [renderSlot(slots, "default")]);
          };
        }
      });
      const ElOverlay = Overlay;
      const dialogInjectionKey = Symbol("dialogInjectionKey");
      const dialogContentProps = buildProps({
        center: Boolean,
        alignCenter: Boolean,
        closeIcon: {
          type: iconPropType
        },
        draggable: Boolean,
        overflow: Boolean,
        fullscreen: Boolean,
        headerClass: String,
        bodyClass: String,
        footerClass: String,
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        ariaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogContentEmits = {
        close: () => true
      };
      const useDraggable = (targetRef, dragRef, draggable2, overflow3) => {
        let transform = {
          offsetX: 0,
          offsetY: 0
        };
        const onMousedown = (e) => {
          const downX = e.clientX;
          const downY = e.clientY;
          const { offsetX, offsetY } = transform;
          const targetRect = targetRef.value.getBoundingClientRect();
          const targetLeft = targetRect.left;
          const targetTop = targetRect.top;
          const targetWidth = targetRect.width;
          const targetHeight = targetRect.height;
          const clientWidth = document.documentElement.clientWidth;
          const clientHeight = document.documentElement.clientHeight;
          const minLeft = -targetLeft + offsetX;
          const minTop = -targetTop + offsetY;
          const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
          const maxTop = clientHeight - targetTop - targetHeight + offsetY;
          const onMousemove = (e2) => {
            let moveX = offsetX + e2.clientX - downX;
            let moveY = offsetY + e2.clientY - downY;
            if (!(overflow3 == null ? void 0 : overflow3.value)) {
              moveX = Math.min(Math.max(moveX, minLeft), maxLeft);
              moveY = Math.min(Math.max(moveY, minTop), maxTop);
            }
            transform = {
              offsetX: moveX,
              offsetY: moveY
            };
            if (targetRef.value) {
              targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
            }
          };
          const onMouseup = () => {
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
          };
          document.addEventListener("mousemove", onMousemove);
          document.addEventListener("mouseup", onMouseup);
        };
        const onDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.addEventListener("mousedown", onMousedown);
          }
        };
        const offDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.removeEventListener("mousedown", onMousedown);
          }
        };
        const resetPosition = () => {
          transform = {
            offsetX: 0,
            offsetY: 0
          };
          if (targetRef.value) {
            targetRef.value.style.transform = "none";
          }
        };
        onMounted(() => {
          watchEffect(() => {
            if (draggable2.value) {
              onDraggable();
            } else {
              offDraggable();
            }
          });
        });
        onBeforeUnmount(() => {
          offDraggable();
        });
        return {
          resetPosition
        };
      };
      const composeRefs = (...refs) => {
        return (el) => {
          refs.forEach((ref2) => {
            if (isFunction$2(ref2)) {
              ref2(el);
            } else {
              ref2.value = el;
            }
          });
        };
      };
      const __default__$8 = defineComponent({ name: "ElDialogContent" });
      const _sfc_main$s = /* @__PURE__ */ defineComponent({
        ...__default__$8,
        props: dialogContentProps,
        emits: dialogContentEmits,
        setup(__props, { expose }) {
          const props2 = __props;
          const { t } = useLocale();
          const { Close } = CloseComponents;
          const { dialogRef, headerRef, bodyId, ns, style: style3 } = inject(dialogInjectionKey);
          const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
          const dialogKls = computed(() => [
            ns.b(),
            ns.is("fullscreen", props2.fullscreen),
            ns.is("draggable", props2.draggable),
            ns.is("align-center", props2.alignCenter),
            { [ns.m("center")]: props2.center }
          ]);
          const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
          const draggable2 = computed(() => props2.draggable);
          const overflow3 = computed(() => props2.overflow);
          const { resetPosition } = useDraggable(dialogRef, headerRef, draggable2, overflow3);
          expose({
            resetPosition
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref: unref(composedDialogRef),
              class: normalizeClass(unref(dialogKls)),
              style: normalizeStyle(unref(style3)),
              tabindex: "-1"
            }, [
              createElementVNode("header", {
                ref_key: "headerRef",
                ref: headerRef,
                class: normalizeClass([unref(ns).e("header"), _ctx.headerClass, { "show-close": _ctx.showClose }])
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createElementVNode("span", {
                    role: "heading",
                    "aria-level": _ctx.ariaLevel,
                    class: normalizeClass(unref(ns).e("title"))
                  }, toDisplayString(_ctx.title), 11, ["aria-level"])
                ]),
                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  "aria-label": unref(t)("el.dialog.close"),
                  class: normalizeClass(unref(ns).e("headerbtn")),
                  type: "button",
                  onClick: ($event) => _ctx.$emit("close")
                }, [
                  createVNode(unref(ElIcon$1), {
                    class: normalizeClass(unref(ns).e("close"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, ["aria-label", "onClick"])) : createCommentVNode("v-if", true)
              ], 2),
              createElementVNode("div", {
                id: unref(bodyId),
                class: normalizeClass([unref(ns).e("body"), _ctx.bodyClass])
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 10, ["id"]),
              _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
                key: 0,
                class: normalizeClass([unref(ns).e("footer"), _ctx.footerClass])
              }, [
                renderSlot(_ctx.$slots, "footer")
              ], 2)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var ElDialogContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["__file", "dialog-content.vue"]]);
      const dialogProps = buildProps({
        ...dialogContentProps,
        appendToBody: Boolean,
        appendTo: {
          type: definePropType([String, Object]),
          default: "body"
        },
        beforeClose: {
          type: definePropType(Function)
        },
        destroyOnClose: Boolean,
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        modal: {
          type: Boolean,
          default: true
        },
        openDelay: {
          type: Number,
          default: 0
        },
        closeDelay: {
          type: Number,
          default: 0
        },
        top: {
          type: String
        },
        modelValue: Boolean,
        modalClass: String,
        headerClass: String,
        bodyClass: String,
        footerClass: String,
        width: {
          type: [String, Number]
        },
        zIndex: {
          type: Number
        },
        trapFocus: Boolean,
        headerAriaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogEmits = {
        open: () => true,
        opened: () => true,
        close: () => true,
        closed: () => true,
        [UPDATE_MODEL_EVENT]: (value) => isBoolean$1(value),
        openAutoFocus: () => true,
        closeAutoFocus: () => true
      };
      const useLockscreen = (trigger, options2 = {}) => {
        if (!isRef(trigger)) {
          throwError("[useLockscreen]", "You need to pass a ref param to this function");
        }
        const ns = options2.ns || useNamespace("popup");
        const hiddenCls = computed(() => ns.bm("parent", "hidden"));
        if (!isClient || hasClass(document.body, hiddenCls.value)) {
          return;
        }
        let scrollBarWidth2 = 0;
        let withoutHiddenClass = false;
        let bodyWidth = "0";
        const cleanup = () => {
          setTimeout(() => {
            if (typeof document === "undefined")
              return;
            if (withoutHiddenClass && document) {
              document.body.style.width = bodyWidth;
              removeClass(document.body, hiddenCls.value);
            }
          }, 200);
        };
        watch(trigger, (val) => {
          if (!val) {
            cleanup();
            return;
          }
          withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            bodyWidth = document.body.style.width;
            addClass(document.body, hiddenCls.value);
          }
          scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle(document.body, "overflowY");
          if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
            document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
          }
        });
        onScopeDispose(() => cleanup());
      };
      const useDialog = (props2, targetRef) => {
        var _a;
        const instance = getCurrentInstance();
        const emit = instance.emit;
        const { nextZIndex } = useZIndex();
        let lastPosition = "";
        const titleId = useId();
        const bodyId = useId();
        const visible = ref(false);
        const closed = ref(false);
        const rendered = ref(false);
        const zIndex2 = ref((_a = props2.zIndex) != null ? _a : nextZIndex());
        let openTimer = void 0;
        let closeTimer = void 0;
        const namespace = useGlobalConfig("namespace", defaultNamespace);
        const style3 = computed(() => {
          const style22 = {};
          const varPrefix = `--${namespace.value}-dialog`;
          if (!props2.fullscreen) {
            if (props2.top) {
              style22[`${varPrefix}-margin-top`] = props2.top;
            }
            if (props2.width) {
              style22[`${varPrefix}-width`] = addUnit(props2.width);
            }
          }
          return style22;
        });
        const overlayDialogStyle = computed(() => {
          if (props2.alignCenter) {
            return { display: "flex" };
          }
          return {};
        });
        function afterEnter() {
          emit("opened");
        }
        function afterLeave() {
          emit("closed");
          emit(UPDATE_MODEL_EVENT, false);
          if (props2.destroyOnClose) {
            rendered.value = false;
          }
        }
        function beforeLeave() {
          emit("close");
        }
        function open() {
          closeTimer == null ? void 0 : closeTimer();
          openTimer == null ? void 0 : openTimer();
          if (props2.openDelay && props2.openDelay > 0) {
            ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props2.openDelay));
          } else {
            doOpen();
          }
        }
        function close() {
          openTimer == null ? void 0 : openTimer();
          closeTimer == null ? void 0 : closeTimer();
          if (props2.closeDelay && props2.closeDelay > 0) {
            ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props2.closeDelay));
          } else {
            doClose();
          }
        }
        function handleClose() {
          function hide(shouldCancel) {
            if (shouldCancel)
              return;
            closed.value = true;
            visible.value = false;
          }
          if (props2.beforeClose) {
            props2.beforeClose(hide);
          } else {
            close();
          }
        }
        function onModalClick() {
          if (props2.closeOnClickModal) {
            handleClose();
          }
        }
        function doOpen() {
          if (!isClient)
            return;
          visible.value = true;
        }
        function doClose() {
          visible.value = false;
        }
        function onOpenAutoFocus() {
          emit("openAutoFocus");
        }
        function onCloseAutoFocus() {
          emit("closeAutoFocus");
        }
        function onFocusoutPrevented(event) {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) === "pointer") {
            event.preventDefault();
          }
        }
        if (props2.lockScroll) {
          useLockscreen(visible);
        }
        function onCloseRequested() {
          if (props2.closeOnPressEscape) {
            handleClose();
          }
        }
        watch(() => props2.modelValue, (val) => {
          if (val) {
            closed.value = false;
            open();
            rendered.value = true;
            zIndex2.value = isUndefined(props2.zIndex) ? nextZIndex() : zIndex2.value++;
            nextTick(() => {
              emit("open");
              if (targetRef.value) {
                targetRef.value.parentElement.scrollTop = 0;
                targetRef.value.parentElement.scrollLeft = 0;
                targetRef.value.scrollTop = 0;
              }
            });
          } else {
            if (visible.value) {
              close();
            }
          }
        });
        watch(() => props2.fullscreen, (val) => {
          if (!targetRef.value)
            return;
          if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
          } else {
            targetRef.value.style.transform = lastPosition;
          }
        });
        onMounted(() => {
          if (props2.modelValue) {
            visible.value = true;
            rendered.value = true;
            open();
          }
        });
        return {
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          close,
          doClose,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented,
          titleId,
          bodyId,
          closed,
          style: style3,
          overlayDialogStyle,
          rendered,
          visible,
          zIndex: zIndex2
        };
      };
      const __default__$7 = defineComponent({
        name: "ElDialog",
        inheritAttrs: false
      });
      const _sfc_main$r = /* @__PURE__ */ defineComponent({
        ...__default__$7,
        props: dialogProps,
        emits: dialogEmits,
        setup(__props, { expose }) {
          const props2 = __props;
          const slots = useSlots();
          useDeprecated({
            scope: "el-dialog",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#slots"
          }, computed(() => !!slots.title));
          const ns = useNamespace("dialog");
          const dialogRef = ref();
          const headerRef = ref();
          const dialogContentRef = ref();
          const {
            visible,
            titleId,
            bodyId,
            style: style3,
            overlayDialogStyle,
            rendered,
            zIndex: zIndex2,
            afterEnter,
            afterLeave,
            beforeLeave,
            handleClose,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onCloseRequested,
            onFocusoutPrevented
          } = useDialog(props2, dialogRef);
          provide(dialogInjectionKey, {
            dialogRef,
            headerRef,
            bodyId,
            ns,
            rendered,
            style: style3
          });
          const overlayEvent = useSameTarget(onModalClick);
          const draggable2 = computed(() => props2.draggable && !props2.fullscreen);
          const resetPosition = () => {
            var _a;
            (_a = dialogContentRef.value) == null ? void 0 : _a.resetPosition();
          };
          expose({
            visible,
            dialogContentRef,
            resetPosition
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTeleport), {
              to: _ctx.appendTo,
              disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
            }, {
              default: withCtx(() => [
                createVNode(Transition, {
                  name: "dialog-fade",
                  onAfterEnter: unref(afterEnter),
                  onAfterLeave: unref(afterLeave),
                  onBeforeLeave: unref(beforeLeave),
                  persisted: ""
                }, {
                  default: withCtx(() => [
                    withDirectives(createVNode(unref(ElOverlay), {
                      "custom-mask-event": "",
                      mask: _ctx.modal,
                      "overlay-class": _ctx.modalClass,
                      "z-index": unref(zIndex2)
                    }, {
                      default: withCtx(() => [
                        createElementVNode("div", {
                          role: "dialog",
                          "aria-modal": "true",
                          "aria-label": _ctx.title || void 0,
                          "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                          "aria-describedby": unref(bodyId),
                          class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                          style: normalizeStyle(unref(overlayDialogStyle)),
                          onClick: unref(overlayEvent).onClick,
                          onMousedown: unref(overlayEvent).onMousedown,
                          onMouseup: unref(overlayEvent).onMouseup
                        }, [
                          createVNode(unref(ElFocusTrap), {
                            loop: "",
                            trapped: unref(visible),
                            "focus-start-el": "container",
                            onFocusAfterTrapped: unref(onOpenAutoFocus),
                            onFocusAfterReleased: unref(onCloseAutoFocus),
                            onFocusoutPrevented: unref(onFocusoutPrevented),
                            onReleaseRequested: unref(onCloseRequested)
                          }, {
                            default: withCtx(() => [
                              unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                                key: 0,
                                ref_key: "dialogContentRef",
                                ref: dialogContentRef
                              }, _ctx.$attrs, {
                                center: _ctx.center,
                                "align-center": _ctx.alignCenter,
                                "close-icon": _ctx.closeIcon,
                                draggable: unref(draggable2),
                                overflow: _ctx.overflow,
                                fullscreen: _ctx.fullscreen,
                                "header-class": _ctx.headerClass,
                                "body-class": _ctx.bodyClass,
                                "footer-class": _ctx.footerClass,
                                "show-close": _ctx.showClose,
                                title: _ctx.title,
                                "aria-level": _ctx.headerAriaLevel,
                                onClose: unref(handleClose)
                              }), createSlots({
                                header: withCtx(() => [
                                  !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                    key: 0,
                                    close: unref(handleClose),
                                    titleId: unref(titleId),
                                    titleClass: unref(ns).e("title")
                                  }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                                ]),
                                default: withCtx(() => [
                                  renderSlot(_ctx.$slots, "default")
                                ]),
                                _: 2
                              }, [
                                _ctx.$slots.footer ? {
                                  name: "footer",
                                  fn: withCtx(() => [
                                    renderSlot(_ctx.$slots, "footer")
                                  ])
                                } : void 0
                              ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "header-class", "body-class", "footer-class", "show-close", "title", "aria-level", "onClose"])) : createCommentVNode("v-if", true)
                            ]),
                            _: 3
                          }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                        ], 46, ["aria-label", "aria-labelledby", "aria-describedby", "onClick", "onMousedown", "onMouseup"])
                      ]),
                      _: 3
                    }, 8, ["mask", "overlay-class", "z-index"]), [
                      [vShow, unref(visible)]
                    ])
                  ]),
                  _: 3
                }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
              ]),
              _: 3
            }, 8, ["to", "disabled"]);
          };
        }
      });
      var Dialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["__file", "dialog.vue"]]);
      const ElDialog = withInstall(Dialog);
      const formMetaProps = buildProps({
        size: {
          type: String,
          values: componentSizes
        },
        disabled: Boolean
      });
      const formProps = buildProps({
        ...formMetaProps,
        model: Object,
        rules: {
          type: definePropType(Object)
        },
        labelPosition: {
          type: String,
          values: ["left", "right", "top"],
          default: "right"
        },
        requireAsteriskPosition: {
          type: String,
          values: ["left", "right"],
          default: "left"
        },
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        labelSuffix: {
          type: String,
          default: ""
        },
        inline: Boolean,
        inlineMessage: Boolean,
        statusIcon: Boolean,
        showMessage: {
          type: Boolean,
          default: true
        },
        validateOnRuleChange: {
          type: Boolean,
          default: true
        },
        hideRequiredAsterisk: Boolean,
        scrollToError: Boolean,
        scrollIntoViewOptions: {
          type: [Object, Boolean]
        }
      });
      const formEmits = {
        validate: (prop, isValid, message) => (isArray$1(prop) || isString$2(prop)) && isBoolean$1(isValid) && isString$2(message)
      };
      function useFormLabelWidth() {
        const potentialLabelWidthArr = ref([]);
        const autoLabelWidth = computed(() => {
          if (!potentialLabelWidthArr.value.length)
            return "0";
          const max = Math.max(...potentialLabelWidthArr.value);
          return max ? `${max}px` : "";
        });
        function getLabelWidthIndex(width) {
          const index = potentialLabelWidthArr.value.indexOf(width);
          if (index === -1 && autoLabelWidth.value === "0") ;
          return index;
        }
        function registerLabelWidth(val, oldVal) {
          if (val && oldVal) {
            const index = getLabelWidthIndex(oldVal);
            potentialLabelWidthArr.value.splice(index, 1, val);
          } else if (val) {
            potentialLabelWidthArr.value.push(val);
          }
        }
        function deregisterLabelWidth(val) {
          const index = getLabelWidthIndex(val);
          if (index > -1) {
            potentialLabelWidthArr.value.splice(index, 1);
          }
        }
        return {
          autoLabelWidth,
          registerLabelWidth,
          deregisterLabelWidth
        };
      }
      const filterFields = (fields, props2) => {
        const normalized = castArray(props2);
        return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
      };
      const COMPONENT_NAME$1 = "ElForm";
      const __default__$6 = defineComponent({
        name: COMPONENT_NAME$1
      });
      const _sfc_main$q = /* @__PURE__ */ defineComponent({
        ...__default__$6,
        props: formProps,
        emits: formEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const fields = [];
          const formSize = useFormSize();
          const ns = useNamespace("form");
          const formClasses = computed(() => {
            const { labelPosition, inline } = props2;
            return [
              ns.b(),
              ns.m(formSize.value || "default"),
              {
                [ns.m(`label-${labelPosition}`)]: labelPosition,
                [ns.m("inline")]: inline
              }
            ];
          });
          const getField = (prop) => {
            return fields.find((field) => field.prop === prop);
          };
          const addField = (field) => {
            fields.push(field);
          };
          const removeField = (field) => {
            if (field.prop) {
              fields.splice(fields.indexOf(field), 1);
            }
          };
          const resetFields = (properties = []) => {
            if (!props2.model) {
              return;
            }
            filterFields(fields, properties).forEach((field) => field.resetField());
          };
          const clearValidate = (props22 = []) => {
            filterFields(fields, props22).forEach((field) => field.clearValidate());
          };
          const isValidatable = computed(() => {
            const hasModel = !!props2.model;
            return hasModel;
          });
          const obtainValidateFields = (props22) => {
            if (fields.length === 0)
              return [];
            const filteredFields = filterFields(fields, props22);
            if (!filteredFields.length) {
              return [];
            }
            return filteredFields;
          };
          const validate = async (callback) => validateField(void 0, callback);
          const doValidateField = async (props22 = []) => {
            if (!isValidatable.value)
              return false;
            const fields2 = obtainValidateFields(props22);
            if (fields2.length === 0)
              return true;
            let validationErrors = {};
            for (const field of fields2) {
              try {
                await field.validate("");
                if (field.validateState === "error")
                  field.resetField();
              } catch (fields3) {
                validationErrors = {
                  ...validationErrors,
                  ...fields3
                };
              }
            }
            if (Object.keys(validationErrors).length === 0)
              return true;
            return Promise.reject(validationErrors);
          };
          const validateField = async (modelProps = [], callback) => {
            const shouldThrow = !isFunction$2(callback);
            try {
              const result = await doValidateField(modelProps);
              if (result === true) {
                await (callback == null ? void 0 : callback(result));
              }
              return result;
            } catch (e) {
              if (e instanceof Error)
                throw e;
              const invalidFields = e;
              if (props2.scrollToError) {
                scrollToField(Object.keys(invalidFields)[0]);
              }
              await (callback == null ? void 0 : callback(false, invalidFields));
              return shouldThrow && Promise.reject(invalidFields);
            }
          };
          const scrollToField = (prop) => {
            var _a;
            const field = filterFields(fields, prop)[0];
            if (field) {
              (_a = field.$el) == null ? void 0 : _a.scrollIntoView(props2.scrollIntoViewOptions);
            }
          };
          watch(() => props2.rules, () => {
            if (props2.validateOnRuleChange) {
              validate().catch((err) => debugWarn());
            }
          }, { deep: true, flush: "post" });
          provide(formContextKey, reactive({
            ...toRefs(props2),
            emit,
            resetFields,
            clearValidate,
            validateField,
            getField,
            addField,
            removeField,
            ...useFormLabelWidth()
          }));
          expose({
            validate,
            validateField,
            resetFields,
            clearValidate,
            scrollToField,
            fields
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("form", {
              class: normalizeClass(unref(formClasses))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Form = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["__file", "form.vue"]]);
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o2) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
          return o22.__proto__ || Object.getPrototypeOf(o22);
        };
        return _getPrototypeOf(o2);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
          o22.__proto__ = p22;
          return o22;
        };
        return _setPrototypeOf(o2, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor = Function.bind.apply(Parent2, a2);
            var instance = new Constructor();
            if (Class2) _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn2) {
        return Function.toString.call(fn2).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2)) return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning = function warning2() {
      };
      function convertFieldsError(errors) {
        if (!errors || !errors.length) return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format(template) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i = 0;
        var len = args.length;
        if (typeof template === "function") {
          return template.apply(null, args);
        }
        if (typeof template === "string") {
          var str = template.replace(formatRegExp, function(x2) {
            if (x2 === "%%") {
              return "%";
            }
            if (i >= len) {
              return x2;
            }
            switch (x2) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_2) {
                  return "[Circular]";
                }
                break;
              default:
                return x2;
            }
          });
          return str;
        }
        return template;
      }
      function isNativeStringType(type4) {
        return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
      }
      function isEmptyValue(value, type4) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type4 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type4) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func, callback) {
        var results = [];
        var total2 = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total2++;
          if (total2 === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a2) {
          func(a2, count);
        });
      }
      function asyncSerialArray(arr, func, callback) {
        var index = 0;
        var arrLength = arr.length;
        function next2(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index;
          index = index + 1;
          if (original < arrLength) {
            func(arr[original], next2);
          } else {
            callback([]);
          }
        }
        next2([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k) {
          ret.push.apply(ret, objArr[k] || []);
        });
        return ret;
      }
      var AsyncValidationError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve, reject) {
            var next2 = function next22(errors) {
              callback(errors);
              return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next2);
          });
          _pending["catch"](function(e) {
            return e;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total2 = 0;
        var results = [];
        var pending = new Promise(function(resolve, reject) {
          var next2 = function next22(errors) {
            results.push.apply(results, errors);
            total2++;
            if (total2 === objArrLength) {
              callback(results);
              return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve(source);
          }
          objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) {
              asyncSerialArray(arr, func, next2);
            } else {
              asyncParallelArray(arr, func, next2);
            }
          });
        });
        pending["catch"](function(e) {
          return e;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue(value, path) {
        var v2 = value;
        for (var i = 0; i < path.length; i++) {
          if (v2 == void 0) {
            return v2;
          }
          v2 = v2[path[i]];
        }
        return v2;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target, source) {
        if (source) {
          for (var s2 in source) {
            if (source.hasOwnProperty(s2)) {
              var value = source[s2];
              if (typeof value === "object" && typeof target[s2] === "object") {
                target[s2] = _extends({}, target[s2], value);
              } else {
                target[s2] = value;
              }
            }
          }
        }
        return target;
      }
      var required$1 = function required(rule, value, source, errors, options2, type4) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
          errors.push(format(options2.messages.required, rule.fullField));
        }
      };
      var whitespace = function whitespace2(rule, value, source, errors, options2) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format(options2.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b2 = function b22(options2) {
          return options2 && options2.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v4 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options2) {
          return options2 && options2.exact ? v46Exact : new RegExp("(?:" + b2(options2) + v4 + b2(options2) + ")|(?:" + b2(options2) + v6 + b2(options2) + ")", "g");
        };
        ip.v4 = function(options2) {
          return options2 && options2.exact ? v4exact : new RegExp("" + b2(options2) + v4 + b2(options2), "g");
        };
        ip.v6 = function(options2) {
          return options2 && options2.exact ? v6exact : new RegExp("" + b2(options2) + v6 + b2(options2), "g");
        };
        var protocol = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex2 = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex2 + "$)", "i");
        return urlReg;
      };
      var pattern$2 = {
        // http://emailregex.com/
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        // url: new RegExp(
        //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
        //   'i',
        // ),
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array(value) {
          return Array.isArray(value);
        },
        regexp: function regexp(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e) {
            return false;
          }
        },
        date: function date(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1 = function type(rule, value, source, errors, options2) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options2);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format(options2.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format(options2.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range = function range2(rule, value, source, errors, options2) {
        var len = typeof rule.len === "number";
        var min = typeof rule.min === "number";
        var max = typeof rule.max === "number";
        var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var val = value;
        var key = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key = "number";
        } else if (str) {
          key = "string";
        } else if (arr) {
          key = "array";
        }
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.replace(spRegexp, "_").length;
        }
        if (len) {
          if (val !== rule.len) {
            errors.push(format(options2.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min && !max && val < rule.min) {
          errors.push(format(options2.messages[key].min, rule.fullField, rule.min));
        } else if (max && !min && val > rule.max) {
          errors.push(format(options2.messages[key].max, rule.fullField, rule.max));
        } else if (min && max && (val < rule.min || val > rule.max)) {
          errors.push(format(options2.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable(rule, value, source, errors, options2) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format(options2.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern(rule, value, source, errors, options2) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format(options2.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format(options2.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace,
        type: type$1,
        range,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options2);
            rules.range(rule, value, source, errors, options2);
            rules.pattern(rule, value, source, errors, options2);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options2);
            }
          }
        }
        callback(errors);
      };
      var method2 = function method3(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options2);
          }
        }
        callback(errors);
      };
      var number2 = function number3(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options2);
            rules.range(rule, value, source, errors, options2);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options2);
          }
        }
        callback(errors);
      };
      var regexp2 = function regexp3(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options2);
          }
        }
        callback(errors);
      };
      var integer2 = function integer3(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options2);
            rules.range(rule, value, source, errors, options2);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options2);
            rules.range(rule, value, source, errors, options2);
          }
        }
        callback(errors);
      };
      var array2 = function array3(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options2);
            rules.range(rule, value, source, errors, options2);
          }
        }
        callback(errors);
      };
      var object2 = function object3(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options2);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable2 = function enumerable3(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options2);
          }
        }
        callback(errors);
      };
      var pattern2 = function pattern3(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options2);
          }
        }
        callback(errors);
      };
      var date2 = function date3(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options2);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options2);
            }
          }
        }
        callback(errors);
      };
      var required2 = function required3(rule, value, callback, source, options2) {
        var errors = [];
        var type4 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options2, type4);
        callback(errors);
      };
      var type2 = function type3(rule, value, callback, source, options2) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options2);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options2) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options2);
        }
        callback(errors);
      };
      var validators = {
        string,
        method: method2,
        number: number2,
        "boolean": _boolean,
        regexp: regexp2,
        integer: integer2,
        "float": floatFn,
        array: array2,
        object: object2,
        "enum": enumerable2,
        pattern: pattern2,
        date: date2,
        url: type2,
        hex: type2,
        email: type2,
        required: required2,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone2() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = /* @__PURE__ */ function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o2, oc) {
          var _this2 = this;
          if (o2 === void 0) {
            o2 = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options2 = o2;
          var callback = oc;
          if (typeof options2 === "function") {
            callback = options2;
            options2 = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add(e) {
              if (Array.isArray(e)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e);
              } else {
                errors.push(e);
              }
            }
            for (var i = 0; i < results.length; i++) {
              add(results[i]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options2.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options2.messages);
            options2.messages = messages$1;
          } else {
            options2.messages = this.messages();
          }
          var series = {};
          var keys2 = options2.keys || Object.keys(this.rules);
          keys2.forEach(function(z) {
            var arr = _this2.rules[z];
            var value = source[z];
            arr.forEach(function(r) {
              var rule = r;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends({}, source);
                }
                value = source[z] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z;
              rule.fullField = rule.fullField || z;
              rule.type = _this2.getType(rule);
              series[z] = series[z] || [];
              series[z].push({
                rule,
                value,
                source,
                field: z
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options2, function(data2, doIt) {
            var rule = data2.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data2.value);
            rule.field = data2.field;
            function addFullField(key, schema) {
              return _extends({}, schema, {
                fullField: rule.fullField + "." + key,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
              });
            }
            function cb(e) {
              if (e === void 0) {
                e = [];
              }
              var errorList = Array.isArray(e) ? e : [e];
              if (!options2.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options2.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data2.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options2.error) {
                    filledErrors = [options2.error(rule, format(options2.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data2.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends({}, fieldsSchema, data2.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options2.messages);
                if (data2.rule.options) {
                  data2.rule.options.messages = options2.messages;
                  data2.rule.options.error = options2.error;
                }
                schema.validate(data2.value, data2.rule.options || options2, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data2.value, cb, data2.source, options2);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data2.value, cb, data2.source, options2);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options2.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e) {
                return cb(e);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        };
        return Schema2;
      }();
      Schema.register = function register(type4, validator2) {
        if (typeof validator2 !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators[type4] = validator2;
      };
      Schema.warning = warning;
      Schema.messages = messages;
      Schema.validators = validators;
      const formItemValidateStates = [
        "",
        "error",
        "validating",
        "success"
      ];
      const formItemProps = buildProps({
        label: String,
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        labelPosition: {
          type: String,
          values: ["left", "right", "top", ""],
          default: ""
        },
        prop: {
          type: definePropType([String, Array])
        },
        required: {
          type: Boolean,
          default: void 0
        },
        rules: {
          type: definePropType([Object, Array])
        },
        error: String,
        validateStatus: {
          type: String,
          values: formItemValidateStates
        },
        for: String,
        inlineMessage: {
          type: [String, Boolean],
          default: ""
        },
        showMessage: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          values: componentSizes
        }
      });
      const COMPONENT_NAME = "ElLabelWrap";
      var FormLabelWrap = defineComponent({
        name: COMPONENT_NAME,
        props: {
          isAutoWidth: Boolean,
          updateAll: Boolean
        },
        setup(props2, {
          slots
        }) {
          const formContext = inject(formContextKey, void 0);
          const formItemContext = inject(formItemContextKey);
          if (!formItemContext)
            throwError(COMPONENT_NAME, "usage: <el-form-item><label-wrap /></el-form-item>");
          const ns = useNamespace("form");
          const el = ref();
          const computedWidth = ref(0);
          const getLabelWidth = () => {
            var _a;
            if ((_a = el.value) == null ? void 0 : _a.firstElementChild) {
              const width = window.getComputedStyle(el.value.firstElementChild).width;
              return Math.ceil(Number.parseFloat(width));
            } else {
              return 0;
            }
          };
          const updateLabelWidth = (action = "update") => {
            nextTick(() => {
              if (slots.default && props2.isAutoWidth) {
                if (action === "update") {
                  computedWidth.value = getLabelWidth();
                } else if (action === "remove") {
                  formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
                }
              }
            });
          };
          const updateLabelWidthFn = () => updateLabelWidth("update");
          onMounted(() => {
            updateLabelWidthFn();
          });
          onBeforeUnmount(() => {
            updateLabelWidth("remove");
          });
          onUpdated(() => updateLabelWidthFn());
          watch(computedWidth, (val, oldVal) => {
            if (props2.updateAll) {
              formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
            }
          });
          useResizeObserver(computed(() => {
            var _a, _b;
            return (_b = (_a = el.value) == null ? void 0 : _a.firstElementChild) != null ? _b : null;
          }), updateLabelWidthFn);
          return () => {
            var _a, _b;
            if (!slots)
              return null;
            const {
              isAutoWidth
            } = props2;
            if (isAutoWidth) {
              const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
              const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
              const style3 = {};
              if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
                const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
                const labelPosition = formItemContext.labelPosition || formContext.labelPosition;
                const marginPosition = labelPosition === "left" ? "marginRight" : "marginLeft";
                if (marginWidth) {
                  style3[marginPosition] = `${marginWidth}px`;
                }
              }
              return createVNode("div", {
                "ref": el,
                "class": [ns.be("item", "label-wrap")],
                "style": style3
              }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
            } else {
              return createVNode(Fragment, {
                "ref": el
              }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
            }
          };
        }
      });
      const __default__$5 = defineComponent({
        name: "ElFormItem"
      });
      const _sfc_main$p = /* @__PURE__ */ defineComponent({
        ...__default__$5,
        props: formItemProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const slots = useSlots();
          const formContext = inject(formContextKey, void 0);
          const parentFormItemContext = inject(formItemContextKey, void 0);
          const _size = useFormSize(void 0, { formItem: false });
          const ns = useNamespace("form-item");
          const labelId = useId().value;
          const inputIds = ref([]);
          const validateState = ref("");
          const validateStateDebounced = refDebounced(validateState, 100);
          const validateMessage = ref("");
          const formItemRef = ref();
          let initialValue = void 0;
          let isResettingField = false;
          const labelPosition = computed(() => props2.labelPosition || (formContext == null ? void 0 : formContext.labelPosition));
          const labelStyle = computed(() => {
            if (labelPosition.value === "top") {
              return {};
            }
            const labelWidth = addUnit(props2.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (labelWidth)
              return { width: labelWidth };
            return {};
          });
          const contentStyle = computed(() => {
            if (labelPosition.value === "top" || (formContext == null ? void 0 : formContext.inline)) {
              return {};
            }
            if (!props2.label && !props2.labelWidth && isNested) {
              return {};
            }
            const labelWidth = addUnit(props2.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (!props2.label && !slots.label) {
              return { marginLeft: labelWidth };
            }
            return {};
          });
          const formItemClasses = computed(() => [
            ns.b(),
            ns.m(_size.value),
            ns.is("error", validateState.value === "error"),
            ns.is("validating", validateState.value === "validating"),
            ns.is("success", validateState.value === "success"),
            ns.is("required", isRequired.value || props2.required),
            ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
            (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
            {
              [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon,
              [ns.m(`label-${labelPosition.value}`)]: labelPosition.value
            }
          ]);
          const _inlineMessage = computed(() => isBoolean$1(props2.inlineMessage) ? props2.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
          const validateClasses = computed(() => [
            ns.e("error"),
            { [ns.em("error", "inline")]: _inlineMessage.value }
          ]);
          const propString = computed(() => {
            if (!props2.prop)
              return "";
            return isString$2(props2.prop) ? props2.prop : props2.prop.join(".");
          });
          const hasLabel = computed(() => {
            return !!(props2.label || slots.label);
          });
          const labelFor = computed(() => {
            return props2.for || (inputIds.value.length === 1 ? inputIds.value[0] : void 0);
          });
          const isGroup = computed(() => {
            return !labelFor.value && hasLabel.value;
          });
          const isNested = !!parentFormItemContext;
          const fieldValue = computed(() => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props2.prop) {
              return;
            }
            return getProp(model, props2.prop).value;
          });
          const normalizedRules = computed(() => {
            const { required: required4 } = props2;
            const rules2 = [];
            if (props2.rules) {
              rules2.push(...castArray(props2.rules));
            }
            const formRules = formContext == null ? void 0 : formContext.rules;
            if (formRules && props2.prop) {
              const _rules = getProp(formRules, props2.prop).value;
              if (_rules) {
                rules2.push(...castArray(_rules));
              }
            }
            if (required4 !== void 0) {
              const requiredRules = rules2.map((rule, i) => [rule, i]).filter(([rule]) => Object.keys(rule).includes("required"));
              if (requiredRules.length > 0) {
                for (const [rule, i] of requiredRules) {
                  if (rule.required === required4)
                    continue;
                  rules2[i] = { ...rule, required: required4 };
                }
              } else {
                rules2.push({ required: required4 });
              }
            }
            return rules2;
          });
          const validateEnabled = computed(() => normalizedRules.value.length > 0);
          const getFilteredRule = (trigger) => {
            const rules2 = normalizedRules.value;
            return rules2.filter((rule) => {
              if (!rule.trigger || !trigger)
                return true;
              if (isArray$1(rule.trigger)) {
                return rule.trigger.includes(trigger);
              } else {
                return rule.trigger === trigger;
              }
            }).map(({ trigger: trigger2, ...rule }) => rule);
          };
          const isRequired = computed(() => normalizedRules.value.some((rule) => rule.required));
          const shouldShowError = computed(() => {
            var _a;
            return validateStateDebounced.value === "error" && props2.showMessage && ((_a = formContext == null ? void 0 : formContext.showMessage) != null ? _a : true);
          });
          const currentLabel = computed(() => `${props2.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
          const setValidationState = (state) => {
            validateState.value = state;
          };
          const onValidationFailed = (error) => {
            var _a, _b;
            const { errors, fields } = error;
            if (!errors || !fields) {
              console.error(error);
            }
            setValidationState("error");
            validateMessage.value = errors ? (_b = (_a = errors == null ? void 0 : errors[0]) == null ? void 0 : _a.message) != null ? _b : `${props2.prop} is required` : "";
            formContext == null ? void 0 : formContext.emit("validate", props2.prop, false, validateMessage.value);
          };
          const onValidationSucceeded = () => {
            setValidationState("success");
            formContext == null ? void 0 : formContext.emit("validate", props2.prop, true, "");
          };
          const doValidate = async (rules2) => {
            const modelName = propString.value;
            const validator2 = new Schema({
              [modelName]: rules2
            });
            return validator2.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
              onValidationSucceeded();
              return true;
            }).catch((err) => {
              onValidationFailed(err);
              return Promise.reject(err);
            });
          };
          const validate = async (trigger, callback) => {
            if (isResettingField || !props2.prop) {
              return false;
            }
            const hasCallback = isFunction$2(callback);
            if (!validateEnabled.value) {
              callback == null ? void 0 : callback(false);
              return false;
            }
            const rules2 = getFilteredRule(trigger);
            if (rules2.length === 0) {
              callback == null ? void 0 : callback(true);
              return true;
            }
            setValidationState("validating");
            return doValidate(rules2).then(() => {
              callback == null ? void 0 : callback(true);
              return true;
            }).catch((err) => {
              const { fields } = err;
              callback == null ? void 0 : callback(false, fields);
              return hasCallback ? false : Promise.reject(fields);
            });
          };
          const clearValidate = () => {
            setValidationState("");
            validateMessage.value = "";
            isResettingField = false;
          };
          const resetField = async () => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props2.prop)
              return;
            const computedValue = getProp(model, props2.prop);
            isResettingField = true;
            computedValue.value = clone(initialValue);
            await nextTick();
            clearValidate();
            isResettingField = false;
          };
          const addInputId = (id) => {
            if (!inputIds.value.includes(id)) {
              inputIds.value.push(id);
            }
          };
          const removeInputId = (id) => {
            inputIds.value = inputIds.value.filter((listId) => listId !== id);
          };
          watch(() => props2.error, (val) => {
            validateMessage.value = val || "";
            setValidationState(val ? "error" : "");
          }, { immediate: true });
          watch(() => props2.validateStatus, (val) => setValidationState(val || ""));
          const context = reactive({
            ...toRefs(props2),
            $el: formItemRef,
            size: _size,
            validateState,
            labelId,
            inputIds,
            isGroup,
            hasLabel,
            fieldValue,
            addInputId,
            removeInputId,
            resetField,
            clearValidate,
            validate
          });
          provide(formItemContextKey, context);
          onMounted(() => {
            if (props2.prop) {
              formContext == null ? void 0 : formContext.addField(context);
              initialValue = clone(fieldValue.value);
            }
          });
          onBeforeUnmount(() => {
            formContext == null ? void 0 : formContext.removeField(context);
          });
          expose({
            size: _size,
            validateMessage,
            validateState,
            validate,
            clearValidate,
            resetField
          });
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock("div", {
              ref_key: "formItemRef",
              ref: formItemRef,
              class: normalizeClass(unref(formItemClasses)),
              role: unref(isGroup) ? "group" : void 0,
              "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
            }, [
              createVNode(unref(FormLabelWrap), {
                "is-auto-width": unref(labelStyle).width === "auto",
                "update-all": ((_a = unref(formContext)) == null ? void 0 : _a.labelWidth) === "auto"
              }, {
                default: withCtx(() => [
                  unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                    key: 0,
                    id: unref(labelId),
                    for: unref(labelFor),
                    class: normalizeClass(unref(ns).e("label")),
                    style: normalizeStyle(unref(labelStyle))
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                        createTextVNode(toDisplayString(unref(currentLabel)), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["is-auto-width", "update-all"]),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("content")),
                style: normalizeStyle(unref(contentStyle))
              }, [
                renderSlot(_ctx.$slots, "default"),
                createVNode(TransitionGroup, {
                  name: `${unref(ns).namespace.value}-zoom-in-top`
                }, {
                  default: withCtx(() => [
                    unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                      key: 0,
                      error: validateMessage.value
                    }, () => [
                      createElementVNode("div", {
                        class: normalizeClass(unref(validateClasses))
                      }, toDisplayString(validateMessage.value), 3)
                    ]) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ], 6)
            ], 10, ["role", "aria-labelledby"]);
          };
        }
      });
      var FormItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["__file", "form-item.vue"]]);
      const ElForm = withInstall(Form, {
        FormItem
      });
      const ElFormItem = withNoopInstall(FormItem);
      const inputNumberProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        step: {
          type: Number,
          default: 1
        },
        stepStrictly: Boolean,
        max: {
          type: Number,
          default: Number.POSITIVE_INFINITY
        },
        min: {
          type: Number,
          default: Number.NEGATIVE_INFINITY
        },
        modelValue: Number,
        readonly: Boolean,
        disabled: Boolean,
        size: useSizeProp,
        controls: {
          type: Boolean,
          default: true
        },
        controlsPosition: {
          type: String,
          default: "",
          values: ["", "right"]
        },
        valueOnClear: {
          type: [String, Number, null],
          validator: (val) => val === null || isNumber$1(val) || ["min", "max"].includes(val),
          default: null
        },
        name: String,
        placeholder: String,
        precision: {
          type: Number,
          validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      });
      const inputNumberEmits = {
        [CHANGE_EVENT]: (cur, prev2) => prev2 !== cur,
        blur: (e) => e instanceof FocusEvent,
        focus: (e) => e instanceof FocusEvent,
        [INPUT_EVENT]: (val) => isNumber$1(val) || isNil(val),
        [UPDATE_MODEL_EVENT]: (val) => isNumber$1(val) || isNil(val)
      };
      const __default__$4 = defineComponent({
        name: "ElInputNumber"
      });
      const _sfc_main$o = /* @__PURE__ */ defineComponent({
        ...__default__$4,
        props: inputNumberProps,
        emits: inputNumberEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const { t } = useLocale();
          const ns = useNamespace("input-number");
          const input = ref();
          const data2 = reactive({
            currentValue: props2.modelValue,
            userInput: null
          });
          const { formItem } = useFormItem();
          const minDisabled = computed(() => isNumber$1(props2.modelValue) && props2.modelValue <= props2.min);
          const maxDisabled = computed(() => isNumber$1(props2.modelValue) && props2.modelValue >= props2.max);
          const numPrecision = computed(() => {
            const stepPrecision = getPrecision(props2.step);
            if (!isUndefined$1(props2.precision)) {
              if (stepPrecision > props2.precision) ;
              return props2.precision;
            } else {
              return Math.max(getPrecision(props2.modelValue), stepPrecision);
            }
          });
          const controlsAtRight = computed(() => {
            return props2.controls && props2.controlsPosition === "right";
          });
          const inputNumberSize = useFormSize();
          const inputNumberDisabled = useFormDisabled();
          const displayValue = computed(() => {
            if (data2.userInput !== null) {
              return data2.userInput;
            }
            let currentValue = data2.currentValue;
            if (isNil(currentValue))
              return "";
            if (isNumber$1(currentValue)) {
              if (Number.isNaN(currentValue))
                return "";
              if (!isUndefined$1(props2.precision)) {
                currentValue = currentValue.toFixed(props2.precision);
              }
            }
            return currentValue;
          });
          const toPrecision = (num, pre) => {
            if (isUndefined$1(pre))
              pre = numPrecision.value;
            if (pre === 0)
              return Math.round(num);
            let snum = String(num);
            const pointPos = snum.indexOf(".");
            if (pointPos === -1)
              return num;
            const nums = snum.replace(".", "").split("");
            const datum = nums[pointPos + pre];
            if (!datum)
              return num;
            const length = snum.length;
            if (snum.charAt(length - 1) === "5") {
              snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
            }
            return Number.parseFloat(Number(snum).toFixed(pre));
          };
          const getPrecision = (value) => {
            if (isNil(value))
              return 0;
            const valueString = value.toString();
            const dotPosition = valueString.indexOf(".");
            let precision = 0;
            if (dotPosition !== -1) {
              precision = valueString.length - dotPosition - 1;
            }
            return precision;
          };
          const ensurePrecision = (val, coefficient = 1) => {
            if (!isNumber$1(val))
              return data2.currentValue;
            return toPrecision(val + props2.step * coefficient);
          };
          const increase = () => {
            if (props2.readonly || inputNumberDisabled.value || maxDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value);
            setCurrentValue(newVal);
            emit(INPUT_EVENT, data2.currentValue);
            setCurrentValueToModelValue();
          };
          const decrease = () => {
            if (props2.readonly || inputNumberDisabled.value || minDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value, -1);
            setCurrentValue(newVal);
            emit(INPUT_EVENT, data2.currentValue);
            setCurrentValueToModelValue();
          };
          const verifyValue = (value, update) => {
            const { max, min, step, precision, stepStrictly, valueOnClear } = props2;
            if (max < min) {
              throwError("InputNumber", "min should not be greater than max.");
            }
            let newVal = Number(value);
            if (isNil(value) || Number.isNaN(newVal)) {
              return null;
            }
            if (value === "") {
              if (valueOnClear === null) {
                return null;
              }
              newVal = isString$2(valueOnClear) ? { min, max }[valueOnClear] : valueOnClear;
            }
            if (stepStrictly) {
              newVal = toPrecision(Math.round(newVal / step) * step, precision);
              if (newVal !== value) {
                update && emit(UPDATE_MODEL_EVENT, newVal);
              }
            }
            if (!isUndefined$1(precision)) {
              newVal = toPrecision(newVal, precision);
            }
            if (newVal > max || newVal < min) {
              newVal = newVal > max ? max : min;
              update && emit(UPDATE_MODEL_EVENT, newVal);
            }
            return newVal;
          };
          const setCurrentValue = (value, emitChange = true) => {
            var _a;
            const oldVal = data2.currentValue;
            const newVal = verifyValue(value);
            if (!emitChange) {
              emit(UPDATE_MODEL_EVENT, newVal);
              return;
            }
            if (oldVal === newVal && value)
              return;
            data2.userInput = null;
            emit(UPDATE_MODEL_EVENT, newVal);
            if (oldVal !== newVal) {
              emit(CHANGE_EVENT, newVal, oldVal);
            }
            if (props2.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change").catch((err) => debugWarn());
            }
            data2.currentValue = newVal;
          };
          const handleInput = (value) => {
            data2.userInput = value;
            const newVal = value === "" ? null : Number(value);
            emit(INPUT_EVENT, newVal);
            setCurrentValue(newVal, false);
          };
          const handleInputChange = (value) => {
            const newVal = value !== "" ? Number(value) : "";
            if (isNumber$1(newVal) && !Number.isNaN(newVal) || value === "") {
              setCurrentValue(newVal);
            }
            setCurrentValueToModelValue();
            data2.userInput = null;
          };
          const focus = () => {
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
          };
          const blur = () => {
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
          };
          const handleFocus = (event) => {
            emit("focus", event);
          };
          const handleBlur = (event) => {
            var _a, _b;
            data2.userInput = null;
            if (isFirefox() && data2.currentValue === null && ((_a = input.value) == null ? void 0 : _a.input)) {
              input.value.input.value = "";
            }
            emit("blur", event);
            if (props2.validateEvent) {
              (_b = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _b.call(formItem, "blur").catch((err) => debugWarn());
            }
          };
          const setCurrentValueToModelValue = () => {
            if (data2.currentValue !== props2.modelValue) {
              data2.currentValue = props2.modelValue;
            }
          };
          const handleWheel = (e) => {
            if (document.activeElement === e.target)
              e.preventDefault();
          };
          watch(() => props2.modelValue, (value, oldValue) => {
            const newValue = verifyValue(value, true);
            if (data2.userInput === null && newValue !== oldValue) {
              data2.currentValue = newValue;
            }
          }, { immediate: true });
          onMounted(() => {
            var _a;
            const { min, max, modelValue } = props2;
            const innerInput = (_a = input.value) == null ? void 0 : _a.input;
            innerInput.setAttribute("role", "spinbutton");
            if (Number.isFinite(max)) {
              innerInput.setAttribute("aria-valuemax", String(max));
            } else {
              innerInput.removeAttribute("aria-valuemax");
            }
            if (Number.isFinite(min)) {
              innerInput.setAttribute("aria-valuemin", String(min));
            } else {
              innerInput.removeAttribute("aria-valuemin");
            }
            innerInput.setAttribute("aria-valuenow", data2.currentValue || data2.currentValue === 0 ? String(data2.currentValue) : "");
            innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
            if (!isNumber$1(modelValue) && modelValue != null) {
              let val = Number(modelValue);
              if (Number.isNaN(val)) {
                val = null;
              }
              emit(UPDATE_MODEL_EVENT, val);
            }
            innerInput.addEventListener("wheel", handleWheel, { passive: false });
          });
          onUpdated(() => {
            var _a, _b;
            const innerInput = (_a = input.value) == null ? void 0 : _a.input;
            innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${(_b = data2.currentValue) != null ? _b : ""}`);
          });
          expose({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(unref(inputNumberSize)),
                unref(ns).is("disabled", unref(inputNumberDisabled)),
                unref(ns).is("without-controls", !_ctx.controls),
                unref(ns).is("controls-right", unref(controlsAtRight))
              ]),
              onDragstart: withModifiers(() => {
              }, ["prevent"])
            }, [
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 0,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.decrease"),
                class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
                onKeydown: withKeys(decrease, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "decrease-icon", {}, () => [
                  createVNode(unref(ElIcon$1), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, ["aria-label", "onKeydown"])), [
                [unref(vRepeatClick), decrease]
              ]) : createCommentVNode("v-if", true),
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 1,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.increase"),
                class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
                onKeydown: withKeys(increase, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "increase-icon", {}, () => [
                  createVNode(unref(ElIcon$1), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, ["aria-label", "onKeydown"])), [
                [unref(vRepeatClick), increase]
              ]) : createCommentVNode("v-if", true),
              createVNode(unref(ElInput), {
                id: _ctx.id,
                ref_key: "input",
                ref: input,
                type: "number",
                step: _ctx.step,
                "model-value": unref(displayValue),
                placeholder: _ctx.placeholder,
                readonly: _ctx.readonly,
                disabled: unref(inputNumberDisabled),
                size: unref(inputNumberSize),
                max: _ctx.max,
                min: _ctx.min,
                name: _ctx.name,
                "aria-label": _ctx.ariaLabel,
                "validate-event": false,
                onKeydown: [
                  withKeys(withModifiers(increase, ["prevent"]), ["up"]),
                  withKeys(withModifiers(decrease, ["prevent"]), ["down"])
                ],
                onBlur: handleBlur,
                onFocus: handleFocus,
                onInput: handleInput,
                onChange: handleInputChange
              }, createSlots({
                _: 2
              }, [
                _ctx.$slots.prefix ? {
                  name: "prefix",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "prefix")
                  ])
                } : void 0,
                _ctx.$slots.suffix ? {
                  name: "suffix",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "suffix")
                  ])
                } : void 0
              ]), 1032, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "aria-label", "onKeydown"])
            ], 42, ["onDragstart"]);
          };
        }
      });
      var InputNumber = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["__file", "input-number.vue"]]);
      const ElInputNumber = withInstall(InputNumber);
      const linkProps = buildProps({
        type: {
          type: String,
          values: ["primary", "success", "warning", "info", "danger", "default"],
          default: "default"
        },
        underline: {
          type: Boolean,
          default: true
        },
        disabled: Boolean,
        href: { type: String, default: "" },
        target: {
          type: String,
          default: "_self"
        },
        icon: {
          type: iconPropType
        }
      });
      const linkEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$3 = defineComponent({
        name: "ElLink"
      });
      const _sfc_main$n = /* @__PURE__ */ defineComponent({
        ...__default__$3,
        props: linkProps,
        emits: linkEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("link");
          const linkKls = computed(() => [
            ns.b(),
            ns.m(props2.type),
            ns.is("disabled", props2.disabled),
            ns.is("underline", props2.underline && !props2.disabled)
          ]);
          function handleClick(event) {
            if (!props2.disabled)
              emit("click", event);
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("a", {
              class: normalizeClass(unref(linkKls)),
              href: _ctx.disabled || !_ctx.href ? void 0 : _ctx.href,
              target: _ctx.disabled || !_ctx.href ? void 0 : _ctx.target,
              onClick: handleClick
            }, [
              _ctx.icon ? (openBlock(), createBlock(unref(ElIcon$1), { key: 0 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                key: 1,
                class: normalizeClass(unref(ns).e("inner"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true),
              _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", { key: 2 }) : createCommentVNode("v-if", true)
            ], 10, ["href", "target"]);
          };
        }
      });
      var Link = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__file", "link.vue"]]);
      const ElLink = withInstall(Link);
      const spaceItemProps = buildProps({
        prefixCls: {
          type: String
        }
      });
      const SpaceItem = defineComponent({
        name: "ElSpaceItem",
        props: spaceItemProps,
        setup(props2, { slots }) {
          const ns = useNamespace("space");
          const classes = computed(() => `${props2.prefixCls || ns.b()}__item`);
          return () => h$1("div", { class: classes.value }, renderSlot(slots, "default"));
        }
      });
      const SIZE_MAP = {
        small: 8,
        default: 12,
        large: 16
      };
      function useSpace(props2) {
        const ns = useNamespace("space");
        const classes = computed(() => [ns.b(), ns.m(props2.direction), props2.class]);
        const horizontalSize = ref(0);
        const verticalSize = ref(0);
        const containerStyle = computed(() => {
          const wrapKls = props2.wrap || props2.fill ? { flexWrap: "wrap" } : {};
          const alignment = {
            alignItems: props2.alignment
          };
          const gap = {
            rowGap: `${verticalSize.value}px`,
            columnGap: `${horizontalSize.value}px`
          };
          return [wrapKls, alignment, gap, props2.style];
        });
        const itemStyle = computed(() => {
          return props2.fill ? { flexGrow: 1, minWidth: `${props2.fillRatio}%` } : {};
        });
        watchEffect(() => {
          const { size = "small", wrap, direction: dir, fill } = props2;
          if (isArray$1(size)) {
            const [h2 = 0, v2 = 0] = size;
            horizontalSize.value = h2;
            verticalSize.value = v2;
          } else {
            let val;
            if (isNumber$1(size)) {
              val = size;
            } else {
              val = SIZE_MAP[size || "small"] || SIZE_MAP.small;
            }
            if ((wrap || fill) && dir === "horizontal") {
              horizontalSize.value = verticalSize.value = val;
            } else {
              if (dir === "horizontal") {
                horizontalSize.value = val;
                verticalSize.value = 0;
              } else {
                verticalSize.value = val;
                horizontalSize.value = 0;
              }
            }
          }
        });
        return {
          classes,
          containerStyle,
          itemStyle
        };
      }
      const spaceProps = buildProps({
        direction: {
          type: String,
          values: ["horizontal", "vertical"],
          default: "horizontal"
        },
        class: {
          type: definePropType([
            String,
            Object,
            Array
          ]),
          default: ""
        },
        style: {
          type: definePropType([String, Array, Object]),
          default: ""
        },
        alignment: {
          type: definePropType(String),
          default: "center"
        },
        prefixCls: {
          type: String
        },
        spacer: {
          type: definePropType([Object, String, Number, Array]),
          default: null,
          validator: (val) => isVNode(val) || isNumber$1(val) || isString$2(val)
        },
        wrap: Boolean,
        fill: Boolean,
        fillRatio: {
          type: Number,
          default: 100
        },
        size: {
          type: [String, Array, Number],
          values: componentSizes,
          validator: (val) => {
            return isNumber$1(val) || isArray$1(val) && val.length === 2 && val.every(isNumber$1);
          }
        }
      });
      const Space = defineComponent({
        name: "ElSpace",
        props: spaceProps,
        setup(props2, { slots }) {
          const { classes, containerStyle, itemStyle } = useSpace(props2);
          function extractChildren(children, parentKey = "", extractedChildren = []) {
            const { prefixCls } = props2;
            children.forEach((child, loopKey) => {
              if (isFragment(child)) {
                if (isArray$1(child.children)) {
                  child.children.forEach((nested, key) => {
                    if (isFragment(nested) && isArray$1(nested.children)) {
                      extractChildren(nested.children, `${parentKey + key}-`, extractedChildren);
                    } else {
                      extractedChildren.push(createVNode(SpaceItem, {
                        style: itemStyle.value,
                        prefixCls,
                        key: `nested-${parentKey + key}`
                      }, {
                        default: () => [nested]
                      }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
                    }
                  });
                }
              } else if (isValidElementNode(child)) {
                extractedChildren.push(createVNode(SpaceItem, {
                  style: itemStyle.value,
                  prefixCls,
                  key: `LoopKey${parentKey + loopKey}`
                }, {
                  default: () => [child]
                }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
              }
            });
            return extractedChildren;
          }
          return () => {
            var _a;
            const { spacer, direction } = props2;
            const children = renderSlot(slots, "default", { key: 0 }, () => []);
            if (((_a = children.children) != null ? _a : []).length === 0)
              return null;
            if (isArray$1(children.children)) {
              let extractedChildren = extractChildren(children.children);
              if (spacer) {
                const len = extractedChildren.length - 1;
                extractedChildren = extractedChildren.reduce((acc, child, idx) => {
                  const children2 = [...acc, child];
                  if (idx !== len) {
                    children2.push(createVNode("span", {
                      style: [
                        itemStyle.value,
                        direction === "vertical" ? "width: 100%" : null
                      ],
                      key: idx
                    }, [
                      isVNode(spacer) ? spacer : createTextVNode(spacer, PatchFlags.TEXT)
                    ], PatchFlags.STYLE));
                  }
                  return children2;
                }, []);
              }
              return createVNode("div", {
                class: classes.value,
                style: containerStyle.value
              }, extractedChildren, PatchFlags.STYLE | PatchFlags.CLASS);
            }
            return children.children;
          };
        }
      });
      const ElSpace = withInstall(Space);
      const getCell = function(event) {
        var _a;
        return (_a = event.target) == null ? void 0 : _a.closest("td");
      };
      const orderBy = function(array4, sortKey, reverse, sortMethod, sortBy) {
        if (!sortKey && !sortMethod && (!sortBy || isArray$1(sortBy) && !sortBy.length)) {
          return array4;
        }
        if (isString$2(reverse)) {
          reverse = reverse === "descending" ? -1 : 1;
        } else {
          reverse = reverse && reverse < 0 ? -1 : 1;
        }
        const getKey = sortMethod ? null : function(value, index) {
          if (sortBy) {
            if (!isArray$1(sortBy)) {
              sortBy = [sortBy];
            }
            return sortBy.map((by) => {
              if (isString$2(by)) {
                return get(value, by);
              } else {
                return by(value, index, array4);
              }
            });
          }
          if (sortKey !== "$key") {
            if (isObject$1(value) && "$value" in value)
              value = value.$value;
          }
          return [isObject$1(value) ? get(value, sortKey) : value];
        };
        const compare = function(a2, b2) {
          if (sortMethod) {
            return sortMethod(a2.value, b2.value);
          }
          for (let i = 0, len = a2.key.length; i < len; i++) {
            if (a2.key[i] < b2.key[i]) {
              return -1;
            }
            if (a2.key[i] > b2.key[i]) {
              return 1;
            }
          }
          return 0;
        };
        return array4.map((value, index) => {
          return {
            value,
            index,
            key: getKey ? getKey(value, index) : null
          };
        }).sort((a2, b2) => {
          let order = compare(a2, b2);
          if (!order) {
            order = a2.index - b2.index;
          }
          return order * +reverse;
        }).map((item) => item.value);
      };
      const getColumnById = function(table, columnId) {
        let column = null;
        table.columns.forEach((item) => {
          if (item.id === columnId) {
            column = item;
          }
        });
        return column;
      };
      const getColumnByKey = function(table, columnKey) {
        let column = null;
        for (let i = 0; i < table.columns.length; i++) {
          const item = table.columns[i];
          if (item.columnKey === columnKey) {
            column = item;
            break;
          }
        }
        if (!column)
          throwError("ElTable", `No column matching with column-key: ${columnKey}`);
        return column;
      };
      const getColumnByCell = function(table, cell, namespace) {
        const matches = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));
        if (matches) {
          return getColumnById(table, matches[0]);
        }
        return null;
      };
      const getRowIdentity = (row, rowKey) => {
        if (!row)
          throw new Error("Row is required when get row identity");
        if (isString$2(rowKey)) {
          if (!rowKey.includes(".")) {
            return `${row[rowKey]}`;
          }
          const key = rowKey.split(".");
          let current2 = row;
          for (const element of key) {
            current2 = current2[element];
          }
          return `${current2}`;
        } else if (isFunction$2(rowKey)) {
          return rowKey.call(null, row);
        }
      };
      const getKeysMap = function(array4, rowKey) {
        const arrayMap2 = {};
        (array4 || []).forEach((row, index) => {
          arrayMap2[getRowIdentity(row, rowKey)] = { row, index };
        });
        return arrayMap2;
      };
      function mergeOptions(defaults, config2) {
        const options2 = {};
        let key;
        for (key in defaults) {
          options2[key] = defaults[key];
        }
        for (key in config2) {
          if (hasOwn(config2, key)) {
            const value = config2[key];
            if (!isUndefined$1(value)) {
              options2[key] = value;
            }
          }
        }
        return options2;
      }
      function parseWidth(width) {
        if (width === "")
          return width;
        if (!isUndefined$1(width)) {
          width = Number.parseInt(width, 10);
          if (Number.isNaN(width)) {
            width = "";
          }
        }
        return width;
      }
      function parseMinWidth(minWidth) {
        if (minWidth === "")
          return minWidth;
        if (!isUndefined$1(minWidth)) {
          minWidth = parseWidth(minWidth);
          if (Number.isNaN(minWidth)) {
            minWidth = 80;
          }
        }
        return minWidth;
      }
      function parseHeight(height) {
        if (isNumber$1(height)) {
          return height;
        }
        if (isString$2(height)) {
          if (/^\d+(?:px)?$/.test(height)) {
            return Number.parseInt(height, 10);
          } else {
            return height;
          }
        }
        return null;
      }
      function compose(...funcs) {
        if (funcs.length === 0) {
          return (arg) => arg;
        }
        if (funcs.length === 1) {
          return funcs[0];
        }
        return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
      }
      function toggleRowStatus(statusArr, row, newVal, tableTreeProps, selectable, rowIndex) {
        let _rowIndex = rowIndex != null ? rowIndex : 0;
        let changed = false;
        const index = statusArr.indexOf(row);
        const included = index !== -1;
        const isRowSelectable = selectable == null ? void 0 : selectable.call(null, row, _rowIndex);
        const toggleStatus = (type4) => {
          if (type4 === "add") {
            statusArr.push(row);
          } else {
            statusArr.splice(index, 1);
          }
          changed = true;
        };
        const getChildrenCount = (row2) => {
          let count = 0;
          const children = (tableTreeProps == null ? void 0 : tableTreeProps.children) && row2[tableTreeProps.children];
          if (children && isArray$1(children)) {
            count += children.length;
            children.forEach((item) => {
              count += getChildrenCount(item);
            });
          }
          return count;
        };
        if (!selectable || isRowSelectable) {
          if (isBoolean$1(newVal)) {
            if (newVal && !included) {
              toggleStatus("add");
            } else if (!newVal && included) {
              toggleStatus("remove");
            }
          } else {
            included ? toggleStatus("remove") : toggleStatus("add");
          }
        }
        if (!(tableTreeProps == null ? void 0 : tableTreeProps.checkStrictly) && (tableTreeProps == null ? void 0 : tableTreeProps.children) && isArray$1(row[tableTreeProps.children])) {
          row[tableTreeProps.children].forEach((item) => {
            const childChanged = toggleRowStatus(statusArr, item, newVal != null ? newVal : !included, tableTreeProps, selectable, _rowIndex + 1);
            _rowIndex += getChildrenCount(item) + 1;
            if (childChanged) {
              changed = childChanged;
            }
          });
        }
        return changed;
      }
      function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
        const isNil2 = (array4) => !(isArray$1(array4) && array4.length);
        function _walker(parent, children, level) {
          cb(parent, children, level);
          children.forEach((item) => {
            if (item[lazyKey]) {
              cb(item, null, level + 1);
              return;
            }
            const children2 = item[childrenKey];
            if (!isNil2(children2)) {
              _walker(item, children2, level + 1);
            }
          });
        }
        root2.forEach((item) => {
          if (item[lazyKey]) {
            cb(item, null, 0);
            return;
          }
          const children = item[childrenKey];
          if (!isNil2(children)) {
            _walker(item, children, 0);
          }
        });
      }
      const getTableOverflowTooltipProps = (props2, innerText, row, column) => {
        const popperOptions = {
          strategy: "fixed",
          ...props2.popperOptions
        };
        const tooltipFormatterContent = isFunction$2(column.tooltipFormatter) ? column.tooltipFormatter({
          row,
          column,
          cellValue: getProp(row, column.property).value
        }) : void 0;
        if (isVNode(tooltipFormatterContent)) {
          return {
            slotContent: tooltipFormatterContent,
            content: null,
            ...props2,
            popperOptions
          };
        }
        return {
          slotContent: null,
          content: tooltipFormatterContent != null ? tooltipFormatterContent : innerText,
          ...props2,
          popperOptions
        };
      };
      let removePopper = null;
      function createTablePopper(props2, popperContent, row, column, trigger, table) {
        const tableOverflowTooltipProps = getTableOverflowTooltipProps(props2, popperContent, row, column);
        const mergedProps = {
          ...tableOverflowTooltipProps,
          slotContent: void 0
        };
        if ((removePopper == null ? void 0 : removePopper.trigger) === trigger) {
          const comp = removePopper.vm.component;
          merge(comp.props, mergedProps);
          if (tableOverflowTooltipProps.slotContent) {
            comp.slots.content = () => [tableOverflowTooltipProps.slotContent];
          }
          return;
        }
        removePopper == null ? void 0 : removePopper();
        const parentNode = table == null ? void 0 : table.refs.tableWrapper;
        const ns = parentNode == null ? void 0 : parentNode.dataset.prefix;
        const vm = createVNode(ElTooltip, {
          virtualTriggering: true,
          virtualRef: trigger,
          appendTo: parentNode,
          placement: "top",
          transition: "none",
          offset: 0,
          hideAfter: 0,
          ...mergedProps
        }, tableOverflowTooltipProps.slotContent ? {
          content: () => tableOverflowTooltipProps.slotContent
        } : void 0);
        vm.appContext = { ...table.appContext, ...table };
        const container = document.createElement("div");
        render$3(vm, container);
        vm.component.exposed.onOpen();
        const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns}-scrollbar__wrap`);
        removePopper = () => {
          render$3(null, container);
          scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", removePopper);
          removePopper = null;
        };
        removePopper.trigger = trigger;
        removePopper.vm = vm;
        scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", removePopper);
      }
      function getCurrentColumns(column) {
        if (column.children) {
          return flatMap(column.children, getCurrentColumns);
        } else {
          return [column];
        }
      }
      function getColSpan(colSpan, column) {
        return colSpan + column.colSpan;
      }
      const isFixedColumn = (index, fixed, store, realColumns) => {
        let start = 0;
        let after = index;
        const columns2 = store.states.columns.value;
        if (realColumns) {
          const curColumns = getCurrentColumns(realColumns[index]);
          const preColumns = columns2.slice(0, columns2.indexOf(curColumns[0]));
          start = preColumns.reduce(getColSpan, 0);
          after = start + curColumns.reduce(getColSpan, 0) - 1;
        } else {
          start = index;
        }
        let fixedLayout;
        switch (fixed) {
          case "left":
            if (after < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            }
            break;
          case "right":
            if (start >= columns2.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
            break;
          default:
            if (after < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            } else if (start >= columns2.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
        }
        return fixedLayout ? {
          direction: fixedLayout,
          start,
          after
        } : {};
      };
      const getFixedColumnsClass = (namespace, index, fixed, store, realColumns, offset = 0) => {
        const classes = [];
        const { direction, start, after } = isFixedColumn(index, fixed, store, realColumns);
        if (direction) {
          const isLeft = direction === "left";
          classes.push(`${namespace}-fixed-column--${direction}`);
          if (isLeft && after + offset === store.states.fixedLeafColumnsLength.value - 1) {
            classes.push("is-last-column");
          } else if (!isLeft && start - offset === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
            classes.push("is-first-column");
          }
        }
        return classes;
      };
      function getOffset(offset, column) {
        return offset + (isNull(column.realWidth) || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);
      }
      const getFixedColumnOffset = (index, fixed, store, realColumns) => {
        const {
          direction,
          start = 0,
          after = 0
        } = isFixedColumn(index, fixed, store, realColumns);
        if (!direction) {
          return;
        }
        const styles = {};
        const isLeft = direction === "left";
        const columns2 = store.states.columns.value;
        if (isLeft) {
          styles.left = columns2.slice(0, start).reduce(getOffset, 0);
        } else {
          styles.right = columns2.slice(after + 1).reverse().reduce(getOffset, 0);
        }
        return styles;
      };
      const ensurePosition = (style3, key) => {
        if (!style3)
          return;
        if (!Number.isNaN(style3[key])) {
          style3[key] = `${style3[key]}px`;
        }
      };
      function useExpand(watcherData) {
        const instance = getCurrentInstance();
        const defaultExpandAll = ref(false);
        const expandRows = ref([]);
        const updateExpandRows = () => {
          const data2 = watcherData.data.value || [];
          const rowKey = watcherData.rowKey.value;
          if (defaultExpandAll.value) {
            expandRows.value = data2.slice();
          } else if (rowKey) {
            const expandRowsMap = getKeysMap(expandRows.value, rowKey);
            expandRows.value = data2.reduce((prev2, row) => {
              const rowId = getRowIdentity(row, rowKey);
              const rowInfo = expandRowsMap[rowId];
              if (rowInfo) {
                prev2.push(row);
              }
              return prev2;
            }, []);
          } else {
            expandRows.value = [];
          }
        };
        const toggleRowExpansion = (row, expanded) => {
          const changed = toggleRowStatus(expandRows.value, row, expanded);
          if (changed) {
            instance.emit("expand-change", row, expandRows.value.slice());
          }
        };
        const setExpandRowKeys = (rowKeys) => {
          instance.store.assertRowKey();
          const data2 = watcherData.data.value || [];
          const rowKey = watcherData.rowKey.value;
          const keysMap = getKeysMap(data2, rowKey);
          expandRows.value = rowKeys.reduce((prev2, cur) => {
            const info2 = keysMap[cur];
            if (info2) {
              prev2.push(info2.row);
            }
            return prev2;
          }, []);
        };
        const isRowExpanded = (row) => {
          const rowKey = watcherData.rowKey.value;
          if (rowKey) {
            const expandMap = getKeysMap(expandRows.value, rowKey);
            return !!expandMap[getRowIdentity(row, rowKey)];
          }
          return expandRows.value.includes(row);
        };
        return {
          updateExpandRows,
          toggleRowExpansion,
          setExpandRowKeys,
          isRowExpanded,
          states: {
            expandRows,
            defaultExpandAll
          }
        };
      }
      function useCurrent(watcherData) {
        const instance = getCurrentInstance();
        const _currentRowKey = ref(null);
        const currentRow = ref(null);
        const setCurrentRowKey = (key) => {
          instance.store.assertRowKey();
          _currentRowKey.value = key;
          setCurrentRowByKey(key);
        };
        const restoreCurrentRowKey = () => {
          _currentRowKey.value = null;
        };
        const setCurrentRowByKey = (key) => {
          const { data: data2, rowKey } = watcherData;
          let _currentRow = null;
          if (rowKey.value) {
            _currentRow = (unref(data2) || []).find((item) => getRowIdentity(item, rowKey.value) === key);
          }
          currentRow.value = _currentRow;
          instance.emit("current-change", currentRow.value, null);
        };
        const updateCurrentRow = (_currentRow) => {
          const oldCurrentRow = currentRow.value;
          if (_currentRow && _currentRow !== oldCurrentRow) {
            currentRow.value = _currentRow;
            instance.emit("current-change", currentRow.value, oldCurrentRow);
            return;
          }
          if (!_currentRow && oldCurrentRow) {
            currentRow.value = null;
            instance.emit("current-change", null, oldCurrentRow);
          }
        };
        const updateCurrentRowData = () => {
          const rowKey = watcherData.rowKey.value;
          const data2 = watcherData.data.value || [];
          const oldCurrentRow = currentRow.value;
          if (!data2.includes(oldCurrentRow) && oldCurrentRow) {
            if (rowKey) {
              const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
              setCurrentRowByKey(currentRowKey);
            } else {
              currentRow.value = null;
            }
            if (isNull(currentRow.value)) {
              instance.emit("current-change", null, oldCurrentRow);
            }
          } else if (_currentRowKey.value) {
            setCurrentRowByKey(_currentRowKey.value);
            restoreCurrentRowKey();
          }
        };
        return {
          setCurrentRowKey,
          restoreCurrentRowKey,
          setCurrentRowByKey,
          updateCurrentRow,
          updateCurrentRowData,
          states: {
            _currentRowKey,
            currentRow
          }
        };
      }
      function useTree(watcherData) {
        const expandRowKeys = ref([]);
        const treeData = ref({});
        const indent = ref(16);
        const lazy = ref(false);
        const lazyTreeNodeMap = ref({});
        const lazyColumnIdentifier = ref("hasChildren");
        const childrenColumnName = ref("children");
        const checkStrictly = ref(false);
        const instance = getCurrentInstance();
        const normalizedData = computed(() => {
          if (!watcherData.rowKey.value)
            return {};
          const data2 = watcherData.data.value || [];
          return normalize(data2);
        });
        const normalizedLazyNode = computed(() => {
          const rowKey = watcherData.rowKey.value;
          const keys2 = Object.keys(lazyTreeNodeMap.value);
          const res = {};
          if (!keys2.length)
            return res;
          keys2.forEach((key) => {
            if (lazyTreeNodeMap.value[key].length) {
              const item = { children: [] };
              lazyTreeNodeMap.value[key].forEach((row) => {
                const currentRowKey = getRowIdentity(row, rowKey);
                item.children.push(currentRowKey);
                if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
                  res[currentRowKey] = { children: [] };
                }
              });
              res[key] = item;
            }
          });
          return res;
        });
        const normalize = (data2) => {
          const rowKey = watcherData.rowKey.value;
          const res = {};
          walkTreeNode(data2, (parent, children, level) => {
            const parentId = getRowIdentity(parent, rowKey);
            if (isArray$1(children)) {
              res[parentId] = {
                children: children.map((row) => getRowIdentity(row, rowKey)),
                level
              };
            } else if (lazy.value) {
              res[parentId] = {
                children: [],
                lazy: true,
                level
              };
            }
          }, childrenColumnName.value, lazyColumnIdentifier.value);
          return res;
        };
        const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = ((_a) => (_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value)()) => {
          var _a2;
          const nested = normalizedData.value;
          const normalizedLazyNode_ = normalizedLazyNode.value;
          const keys2 = Object.keys(nested);
          const newTreeData = {};
          if (keys2.length) {
            const oldTreeData = unref(treeData);
            const rootLazyRowKeys = [];
            const getExpanded = (oldValue, key) => {
              if (ifChangeExpandRowKeys) {
                if (expandRowKeys.value) {
                  return ifExpandAll || expandRowKeys.value.includes(key);
                } else {
                  return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
                }
              } else {
                const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);
                return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
              }
            };
            keys2.forEach((key) => {
              const oldValue = oldTreeData[key];
              const newValue = { ...nested[key] };
              newValue.expanded = getExpanded(oldValue, key);
              if (newValue.lazy) {
                const { loaded = false, loading = false } = oldValue || {};
                newValue.loaded = !!loaded;
                newValue.loading = !!loading;
                rootLazyRowKeys.push(key);
              }
              newTreeData[key] = newValue;
            });
            const lazyKeys = Object.keys(normalizedLazyNode_);
            if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
              lazyKeys.forEach((key) => {
                const oldValue = oldTreeData[key];
                const lazyNodeChildren = normalizedLazyNode_[key].children;
                if (rootLazyRowKeys.includes(key)) {
                  if (newTreeData[key].children.length !== 0) {
                    throw new Error("[ElTable]children must be an empty array.");
                  }
                  newTreeData[key].children = lazyNodeChildren;
                } else {
                  const { loaded = false, loading = false } = oldValue || {};
                  newTreeData[key] = {
                    lazy: true,
                    loaded: !!loaded,
                    loading: !!loading,
                    expanded: getExpanded(oldValue, key),
                    children: lazyNodeChildren,
                    level: ""
                  };
                }
              });
            }
          }
          treeData.value = newTreeData;
          (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
        };
        watch(() => expandRowKeys.value, () => {
          updateTreeData(true);
        });
        watch(() => normalizedData.value, () => {
          updateTreeData();
        });
        watch(() => normalizedLazyNode.value, () => {
          updateTreeData();
        });
        const updateTreeExpandKeys = (value) => {
          expandRowKeys.value = value;
          updateTreeData();
        };
        const isUseLazy = (data2) => {
          return lazy.value && data2 && "loaded" in data2 && !data2.loaded;
        };
        const toggleTreeExpansion = (row, expanded) => {
          instance.store.assertRowKey();
          const rowKey = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey);
          const data2 = id && treeData.value[id];
          if (id && data2 && "expanded" in data2) {
            const oldExpanded = data2.expanded;
            expanded = isUndefined$1(expanded) ? !data2.expanded : expanded;
            treeData.value[id].expanded = expanded;
            if (oldExpanded !== expanded) {
              instance.emit("expand-change", row, expanded);
            }
            isUseLazy(data2) && loadData(row, id, data2);
            instance.store.updateTableScrollY();
          }
        };
        const loadOrToggle = (row) => {
          instance.store.assertRowKey();
          const rowKey = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey);
          const data2 = treeData.value[id];
          if (isUseLazy(data2)) {
            loadData(row, id, data2);
          } else {
            toggleTreeExpansion(row, void 0);
          }
        };
        const loadData = (row, key, treeNode) => {
          const { load } = instance.props;
          if (load && !treeData.value[key].loaded) {
            treeData.value[key].loading = true;
            load(row, treeNode, (data2) => {
              if (!isArray$1(data2)) {
                throw new TypeError("[ElTable] data must be an array");
              }
              treeData.value[key].loading = false;
              treeData.value[key].loaded = true;
              treeData.value[key].expanded = true;
              if (data2.length) {
                lazyTreeNodeMap.value[key] = data2;
              }
              instance.emit("expand-change", row, true);
            });
          }
        };
        const updateKeyChildren = (key, data2) => {
          const { lazy: lazy2, rowKey } = instance.props;
          if (!lazy2)
            return;
          if (!rowKey)
            throw new Error("[Table] rowKey is required in updateKeyChild");
          if (lazyTreeNodeMap.value[key]) {
            lazyTreeNodeMap.value[key] = data2;
          }
        };
        return {
          loadData,
          loadOrToggle,
          toggleTreeExpansion,
          updateTreeExpandKeys,
          updateTreeData,
          updateKeyChildren,
          normalize,
          states: {
            expandRowKeys,
            treeData,
            indent,
            lazy,
            lazyTreeNodeMap,
            lazyColumnIdentifier,
            childrenColumnName,
            checkStrictly
          }
        };
      }
      const sortData = (data2, states) => {
        const sortingColumn = states.sortingColumn;
        if (!sortingColumn || isString$2(sortingColumn.sortable)) {
          return data2;
        }
        return orderBy(data2, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
      };
      const doFlattenColumns = (columns2) => {
        const result = [];
        columns2.forEach((column) => {
          if (column.children && column.children.length > 0) {
            result.push.apply(result, doFlattenColumns(column.children));
          } else {
            result.push(column);
          }
        });
        return result;
      };
      function useWatcher$1() {
        var _a;
        const instance = getCurrentInstance();
        const { size: tableSize } = toRefs((_a = instance.proxy) == null ? void 0 : _a.$props);
        const rowKey = ref(null);
        const data2 = ref([]);
        const _data = ref([]);
        const isComplex = ref(false);
        const _columns = ref([]);
        const originColumns = ref([]);
        const columns2 = ref([]);
        const fixedColumns = ref([]);
        const rightFixedColumns = ref([]);
        const leafColumns = ref([]);
        const fixedLeafColumns = ref([]);
        const rightFixedLeafColumns = ref([]);
        const updateOrderFns = [];
        const leafColumnsLength = ref(0);
        const fixedLeafColumnsLength = ref(0);
        const rightFixedLeafColumnsLength = ref(0);
        const isAllSelected = ref(false);
        const selection = ref([]);
        const reserveSelection = ref(false);
        const selectOnIndeterminate = ref(false);
        const selectable = ref(null);
        const filters = ref({});
        const filteredData = ref(null);
        const sortingColumn = ref(null);
        const sortProp = ref(null);
        const sortOrder = ref(null);
        const hoverRow = ref(null);
        const selectedMap = computed(() => {
          return rowKey.value ? getKeysMap(selection.value, rowKey.value) : void 0;
        });
        watch(data2, () => {
          var _a2;
          if (instance.state) {
            scheduleLayout(false);
            const needUpdateFixed = instance.props.tableLayout === "auto";
            if (needUpdateFixed) {
              (_a2 = instance.refs.tableHeaderRef) == null ? void 0 : _a2.updateFixedColumnStyle();
            }
          }
        }, {
          deep: true
        });
        const assertRowKey = () => {
          if (!rowKey.value)
            throw new Error("[ElTable] prop row-key is required");
        };
        const updateChildFixed = (column) => {
          var _a2;
          (_a2 = column.children) == null ? void 0 : _a2.forEach((childColumn) => {
            childColumn.fixed = column.fixed;
            updateChildFixed(childColumn);
          });
        };
        const updateColumns = () => {
          var _a2, _b;
          _columns.value.forEach((column) => {
            updateChildFixed(column);
          });
          fixedColumns.value = _columns.value.filter((column) => column.type !== "selection" && [true, "left"].includes(column.fixed));
          let selectColFixLeft;
          if (((_b = (_a2 = _columns.value) == null ? void 0 : _a2[0]) == null ? void 0 : _b.type) === "selection") {
            const selectColumn = _columns.value[0];
            selectColFixLeft = [true, "left"].includes(selectColumn.fixed) || fixedColumns.value.length && selectColumn.fixed !== "right";
            if (selectColFixLeft) {
              fixedColumns.value.unshift(selectColumn);
            }
          }
          rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
          const notFixedColumns = _columns.value.filter((column) => (selectColFixLeft ? column.type !== "selection" : true) && !column.fixed);
          originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
          const leafColumns2 = doFlattenColumns(notFixedColumns);
          const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
          const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
          leafColumnsLength.value = leafColumns2.length;
          fixedLeafColumnsLength.value = fixedLeafColumns2.length;
          rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
          columns2.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
          isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
        };
        const scheduleLayout = (needUpdateColumns, immediate = false) => {
          if (needUpdateColumns) {
            updateColumns();
          }
          if (immediate) {
            instance.state.doLayout();
          } else {
            instance.state.debouncedUpdateLayout();
          }
        };
        const isSelected = (row) => {
          if (selectedMap.value) {
            return !!selectedMap.value[getRowIdentity(row, rowKey.value)];
          } else {
            return selection.value.includes(row);
          }
        };
        const clearSelection = () => {
          isAllSelected.value = false;
          const oldSelection = selection.value;
          selection.value = [];
          if (oldSelection.length) {
            instance.emit("selection-change", []);
          }
        };
        const cleanSelection = () => {
          let deleted;
          if (rowKey.value) {
            deleted = [];
            const dataMap = getKeysMap(data2.value, rowKey.value);
            for (const key in selectedMap.value) {
              if (hasOwn(selectedMap.value, key) && !dataMap[key]) {
                deleted.push(selectedMap.value[key].row);
              }
            }
          } else {
            deleted = selection.value.filter((item) => !data2.value.includes(item));
          }
          if (deleted.length) {
            const newSelection = selection.value.filter((item) => !deleted.includes(item));
            selection.value = newSelection;
            instance.emit("selection-change", newSelection.slice());
          }
        };
        const getSelectionRows = () => {
          return (selection.value || []).slice();
        };
        const toggleRowSelection = (row, selected, emitChange = true, ignoreSelectable = false) => {
          var _a2, _b, _c, _d;
          const treeProps = {
            children: (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.childrenColumnName.value,
            checkStrictly: (_d = (_c = instance == null ? void 0 : instance.store) == null ? void 0 : _c.states) == null ? void 0 : _d.checkStrictly.value
          };
          const changed = toggleRowStatus(selection.value, row, selected, treeProps, ignoreSelectable ? void 0 : selectable.value, data2.value.indexOf(row));
          if (changed) {
            const newSelection = (selection.value || []).slice();
            if (emitChange) {
              instance.emit("select", newSelection, row);
            }
            instance.emit("selection-change", newSelection);
          }
        };
        const _toggleAllSelection = () => {
          var _a2, _b;
          const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
          isAllSelected.value = value;
          let selectionChanged = false;
          let childrenCount = 0;
          const rowKey2 = (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.rowKey.value;
          const { childrenColumnName } = instance.store.states;
          const treeProps = {
            children: childrenColumnName.value,
            checkStrictly: false
          };
          data2.value.forEach((row, index) => {
            const rowIndex = index + childrenCount;
            if (toggleRowStatus(selection.value, row, value, treeProps, selectable.value, rowIndex)) {
              selectionChanged = true;
            }
            childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));
          });
          if (selectionChanged) {
            instance.emit("selection-change", selection.value ? selection.value.slice() : []);
          }
          instance.emit("select-all", (selection.value || []).slice());
        };
        const updateSelectionByRowKey = () => {
          data2.value.forEach((row) => {
            const rowId = getRowIdentity(row, rowKey.value);
            const rowInfo = selectedMap.value[rowId];
            if (rowInfo) {
              selection.value[rowInfo.index] = row;
            }
          });
        };
        const updateAllSelected = () => {
          var _a2;
          if (((_a2 = data2.value) == null ? void 0 : _a2.length) === 0) {
            isAllSelected.value = false;
            return;
          }
          const { childrenColumnName } = instance.store.states;
          let rowIndex = 0;
          let selectedCount = 0;
          const checkSelectedStatus = (data22) => {
            var _a3;
            for (const row of data22) {
              const isRowSelectable = selectable.value && selectable.value.call(null, row, rowIndex);
              if (!isSelected(row)) {
                if (!selectable.value || isRowSelectable) {
                  return false;
                }
              } else {
                selectedCount++;
              }
              rowIndex++;
              if (((_a3 = row[childrenColumnName.value]) == null ? void 0 : _a3.length) && !checkSelectedStatus(row[childrenColumnName.value])) {
                return false;
              }
            }
            return true;
          };
          const isAllSelected_ = checkSelectedStatus(data2.value || []);
          isAllSelected.value = selectedCount === 0 ? false : isAllSelected_;
        };
        const getChildrenCount = (rowKey2) => {
          var _a2;
          if (!instance || !instance.store)
            return 0;
          const { treeData } = instance.store.states;
          let count = 0;
          const children = (_a2 = treeData.value[rowKey2]) == null ? void 0 : _a2.children;
          if (children) {
            count += children.length;
            children.forEach((childKey) => {
              count += getChildrenCount(childKey);
            });
          }
          return count;
        };
        const updateFilters = (columns22, values) => {
          if (!isArray$1(columns22)) {
            columns22 = [columns22];
          }
          const filters_ = {};
          columns22.forEach((col) => {
            filters.value[col.id] = values;
            filters_[col.columnKey || col.id] = values;
          });
          return filters_;
        };
        const updateSort = (column, prop, order) => {
          if (sortingColumn.value && sortingColumn.value !== column) {
            sortingColumn.value.order = null;
          }
          sortingColumn.value = column;
          sortProp.value = prop;
          sortOrder.value = order;
        };
        const execFilter = () => {
          let sourceData = unref(_data);
          Object.keys(filters.value).forEach((columnId) => {
            const values = filters.value[columnId];
            if (!values || values.length === 0)
              return;
            const column = getColumnById({
              columns: columns2.value
            }, columnId);
            if (column && column.filterMethod) {
              sourceData = sourceData.filter((row) => {
                return values.some((value) => column.filterMethod.call(null, value, row, column));
              });
            }
          });
          filteredData.value = sourceData;
        };
        const execSort = () => {
          data2.value = sortData(filteredData.value, {
            sortingColumn: sortingColumn.value,
            sortProp: sortProp.value,
            sortOrder: sortOrder.value
          });
        };
        const execQuery = (ignore = void 0) => {
          if (!(ignore && ignore.filter)) {
            execFilter();
          }
          execSort();
        };
        const clearFilter = (columnKeys) => {
          const { tableHeaderRef } = instance.refs;
          if (!tableHeaderRef)
            return;
          const panels = Object.assign({}, tableHeaderRef.filterPanels);
          const keys2 = Object.keys(panels);
          if (!keys2.length)
            return;
          if (isString$2(columnKeys)) {
            columnKeys = [columnKeys];
          }
          if (isArray$1(columnKeys)) {
            const columns_ = columnKeys.map((key) => getColumnByKey({
              columns: columns2.value
            }, key));
            keys2.forEach((key) => {
              const column = columns_.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            instance.store.commit("filterChange", {
              column: columns_,
              values: [],
              silent: true,
              multi: true
            });
          } else {
            keys2.forEach((key) => {
              const column = columns2.value.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            filters.value = {};
            instance.store.commit("filterChange", {
              column: {},
              values: [],
              silent: true
            });
          }
        };
        const clearSort = () => {
          if (!sortingColumn.value)
            return;
          updateSort(null, null, null);
          instance.store.commit("changeSortCondition", {
            silent: true
          });
        };
        const {
          setExpandRowKeys,
          toggleRowExpansion,
          updateExpandRows,
          states: expandStates,
          isRowExpanded
        } = useExpand({
          data: data2,
          rowKey
        });
        const {
          updateTreeExpandKeys,
          toggleTreeExpansion,
          updateTreeData,
          updateKeyChildren,
          loadOrToggle,
          states: treeStates
        } = useTree({
          data: data2,
          rowKey
        });
        const {
          updateCurrentRowData,
          updateCurrentRow,
          setCurrentRowKey,
          states: currentData
        } = useCurrent({
          data: data2,
          rowKey
        });
        const setExpandRowKeysAdapter = (val) => {
          setExpandRowKeys(val);
          updateTreeExpandKeys(val);
        };
        const toggleRowExpansionAdapter = (row, expanded) => {
          const hasExpandColumn = columns2.value.some(({ type: type4 }) => type4 === "expand");
          if (hasExpandColumn) {
            toggleRowExpansion(row, expanded);
          } else {
            toggleTreeExpansion(row, expanded);
          }
        };
        return {
          assertRowKey,
          updateColumns,
          scheduleLayout,
          isSelected,
          clearSelection,
          cleanSelection,
          getSelectionRows,
          toggleRowSelection,
          _toggleAllSelection,
          toggleAllSelection: null,
          updateSelectionByRowKey,
          updateAllSelected,
          updateFilters,
          updateCurrentRow,
          updateSort,
          execFilter,
          execSort,
          execQuery,
          clearFilter,
          clearSort,
          toggleRowExpansion,
          setExpandRowKeysAdapter,
          setCurrentRowKey,
          toggleRowExpansionAdapter,
          isRowExpanded,
          updateExpandRows,
          updateCurrentRowData,
          loadOrToggle,
          updateTreeData,
          updateKeyChildren,
          states: {
            tableSize,
            rowKey,
            data: data2,
            _data,
            isComplex,
            _columns,
            originColumns,
            columns: columns2,
            fixedColumns,
            rightFixedColumns,
            leafColumns,
            fixedLeafColumns,
            rightFixedLeafColumns,
            updateOrderFns,
            leafColumnsLength,
            fixedLeafColumnsLength,
            rightFixedLeafColumnsLength,
            isAllSelected,
            selection,
            reserveSelection,
            selectOnIndeterminate,
            selectable,
            filters,
            filteredData,
            sortingColumn,
            sortProp,
            sortOrder,
            hoverRow,
            ...expandStates,
            ...treeStates,
            ...currentData
          }
        };
      }
      function replaceColumn(array4, column) {
        return array4.map((item) => {
          var _a;
          if (item.id === column.id) {
            return column;
          } else if ((_a = item.children) == null ? void 0 : _a.length) {
            item.children = replaceColumn(item.children, column);
          }
          return item;
        });
      }
      function sortColumn(array4) {
        array4.forEach((item) => {
          var _a, _b;
          item.no = (_a = item.getColumnIndex) == null ? void 0 : _a.call(item);
          if ((_b = item.children) == null ? void 0 : _b.length) {
            sortColumn(item.children);
          }
        });
        array4.sort((cur, pre) => cur.no - pre.no);
      }
      function useStore() {
        const instance = getCurrentInstance();
        const watcher = useWatcher$1();
        const ns = useNamespace("table");
        const mutations = {
          setData(states, data2) {
            const dataInstanceChanged = unref(states._data) !== data2;
            states.data.value = data2;
            states._data.value = data2;
            instance.store.execQuery();
            instance.store.updateCurrentRowData();
            instance.store.updateExpandRows();
            instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
            if (unref(states.reserveSelection)) {
              instance.store.assertRowKey();
              instance.store.updateSelectionByRowKey();
            } else {
              if (dataInstanceChanged) {
                instance.store.clearSelection();
              } else {
                instance.store.cleanSelection();
              }
            }
            instance.store.updateAllSelected();
            if (instance.$ready) {
              instance.store.scheduleLayout();
            }
          },
          insertColumn(states, column, parent, updateColumnOrder) {
            const array4 = unref(states._columns);
            let newColumns = [];
            if (!parent) {
              array4.push(column);
              newColumns = array4;
            } else {
              if (parent && !parent.children) {
                parent.children = [];
              }
              parent.children.push(column);
              newColumns = replaceColumn(array4, parent);
            }
            sortColumn(newColumns);
            states._columns.value = newColumns;
            states.updateOrderFns.push(updateColumnOrder);
            if (column.type === "selection") {
              states.selectable.value = column.selectable;
              states.reserveSelection.value = column.reserveSelection;
            }
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          updateColumnOrder(states, column) {
            var _a;
            const newColumnIndex = (_a = column.getColumnIndex) == null ? void 0 : _a.call(column);
            if (newColumnIndex === column.no)
              return;
            sortColumn(states._columns.value);
            if (instance.$ready) {
              instance.store.updateColumns();
            }
          },
          removeColumn(states, column, parent, updateColumnOrder) {
            const array4 = unref(states._columns) || [];
            if (parent) {
              parent.children.splice(parent.children.findIndex((item) => item.id === column.id), 1);
              nextTick(() => {
                var _a;
                if (((_a = parent.children) == null ? void 0 : _a.length) === 0) {
                  delete parent.children;
                }
              });
              states._columns.value = replaceColumn(array4, parent);
            } else {
              const index = array4.indexOf(column);
              if (index > -1) {
                array4.splice(index, 1);
                states._columns.value = array4;
              }
            }
            const updateFnIndex = states.updateOrderFns.indexOf(updateColumnOrder);
            updateFnIndex > -1 && states.updateOrderFns.splice(updateFnIndex, 1);
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          sort(states, options2) {
            const { prop, order, init: init2 } = options2;
            if (prop) {
              const column = unref(states.columns).find((column2) => column2.property === prop);
              if (column) {
                column.order = order;
                instance.store.updateSort(column, prop, order);
                instance.store.commit("changeSortCondition", { init: init2 });
              }
            }
          },
          changeSortCondition(states, options2) {
            const { sortingColumn, sortProp, sortOrder } = states;
            const columnValue = unref(sortingColumn), propValue = unref(sortProp), orderValue = unref(sortOrder);
            if (isNull(orderValue)) {
              states.sortingColumn.value = null;
              states.sortProp.value = null;
            }
            const ignore = { filter: true };
            instance.store.execQuery(ignore);
            if (!options2 || !(options2.silent || options2.init)) {
              instance.emit("sort-change", {
                column: columnValue,
                prop: propValue,
                order: orderValue
              });
            }
            instance.store.updateTableScrollY();
          },
          filterChange(_states, options2) {
            const { column, values, silent } = options2;
            const newFilters = instance.store.updateFilters(column, values);
            instance.store.execQuery();
            if (!silent) {
              instance.emit("filter-change", newFilters);
            }
            instance.store.updateTableScrollY();
          },
          toggleAllSelection() {
            instance.store.toggleAllSelection();
          },
          rowSelectedChanged(_states, row) {
            instance.store.toggleRowSelection(row);
            instance.store.updateAllSelected();
          },
          setHoverRow(states, row) {
            states.hoverRow.value = row;
          },
          setCurrentRow(_states, row) {
            instance.store.updateCurrentRow(row);
          }
        };
        const commit = function(name, ...args) {
          const mutations2 = instance.store.mutations;
          if (mutations2[name]) {
            mutations2[name].apply(instance, [instance.store.states].concat(args));
          } else {
            throw new Error(`Action not found: ${name}`);
          }
        };
        const updateTableScrollY = function() {
          nextTick(() => instance.layout.updateScrollY.apply(instance.layout));
        };
        return {
          ns,
          ...watcher,
          mutations,
          commit,
          updateTableScrollY
        };
      }
      const InitialStateMap = {
        rowKey: "rowKey",
        defaultExpandAll: "defaultExpandAll",
        selectOnIndeterminate: "selectOnIndeterminate",
        indent: "indent",
        lazy: "lazy",
        data: "data",
        ["treeProps.hasChildren"]: {
          key: "lazyColumnIdentifier",
          default: "hasChildren"
        },
        ["treeProps.children"]: {
          key: "childrenColumnName",
          default: "children"
        },
        ["treeProps.checkStrictly"]: {
          key: "checkStrictly",
          default: false
        }
      };
      function createStore(table, props2) {
        if (!table) {
          throw new Error("Table is required.");
        }
        const store = useStore();
        store.toggleAllSelection = debounce(store._toggleAllSelection, 10);
        Object.keys(InitialStateMap).forEach((key) => {
          handleValue(getArrKeysValue(props2, key), key, store);
        });
        proxyTableProps(store, props2);
        return store;
      }
      function proxyTableProps(store, props2) {
        Object.keys(InitialStateMap).forEach((key) => {
          watch(() => getArrKeysValue(props2, key), (value) => {
            handleValue(value, key, store);
          });
        });
      }
      function handleValue(value, propsKey, store) {
        let newVal = value;
        let storeKey = InitialStateMap[propsKey];
        if (isObject$1(InitialStateMap[propsKey])) {
          storeKey = storeKey.key;
          newVal = newVal || InitialStateMap[propsKey].default;
        }
        store.states[storeKey].value = newVal;
      }
      function getArrKeysValue(props2, keys2) {
        if (keys2.includes(".")) {
          const keyList = keys2.split(".");
          let value = props2;
          keyList.forEach((key) => {
            value = value[key];
          });
          return value;
        } else {
          return props2[keys2];
        }
      }
      class TableLayout {
        constructor(options2) {
          this.observers = [];
          this.table = null;
          this.store = null;
          this.columns = [];
          this.fit = true;
          this.showHeader = true;
          this.height = ref(null);
          this.scrollX = ref(false);
          this.scrollY = ref(false);
          this.bodyWidth = ref(null);
          this.fixedWidth = ref(null);
          this.rightFixedWidth = ref(null);
          this.gutterWidth = 0;
          for (const name in options2) {
            if (hasOwn(options2, name)) {
              if (isRef(this[name])) {
                this[name].value = options2[name];
              } else {
                this[name] = options2[name];
              }
            }
          }
          if (!this.table) {
            throw new Error("Table is required for Table Layout");
          }
          if (!this.store) {
            throw new Error("Store is required for Table Layout");
          }
        }
        updateScrollY() {
          const height = this.height.value;
          if (isNull(height))
            return false;
          const scrollBarRef = this.table.refs.scrollBarRef;
          if (this.table.vnode.el && (scrollBarRef == null ? void 0 : scrollBarRef.wrapRef)) {
            let scrollY = true;
            const prevScrollY = this.scrollY.value;
            scrollY = scrollBarRef.wrapRef.scrollHeight > scrollBarRef.wrapRef.clientHeight;
            this.scrollY.value = scrollY;
            return prevScrollY !== scrollY;
          }
          return false;
        }
        setHeight(value, prop = "height") {
          if (!isClient)
            return;
          const el = this.table.vnode.el;
          value = parseHeight(value);
          this.height.value = Number(value);
          if (!el && (value || value === 0))
            return nextTick(() => this.setHeight(value, prop));
          if (isNumber$1(value)) {
            el.style[prop] = `${value}px`;
            this.updateElsHeight();
          } else if (isString$2(value)) {
            el.style[prop] = value;
            this.updateElsHeight();
          }
        }
        setMaxHeight(value) {
          this.setHeight(value, "max-height");
        }
        getFlattenColumns() {
          const flattenColumns = [];
          const columns2 = this.table.store.states.columns.value;
          columns2.forEach((column) => {
            if (column.isColumnGroup) {
              flattenColumns.push.apply(flattenColumns, column.columns);
            } else {
              flattenColumns.push(column);
            }
          });
          return flattenColumns;
        }
        updateElsHeight() {
          this.updateScrollY();
          this.notifyObservers("scrollable");
        }
        headerDisplayNone(elm) {
          if (!elm)
            return true;
          let headerChild = elm;
          while (headerChild.tagName !== "DIV") {
            if (getComputedStyle(headerChild).display === "none") {
              return true;
            }
            headerChild = headerChild.parentElement;
          }
          return false;
        }
        updateColumnsWidth() {
          if (!isClient)
            return;
          const fit = this.fit;
          const bodyWidth = this.table.vnode.el.clientWidth;
          let bodyMinWidth = 0;
          const flattenColumns = this.getFlattenColumns();
          const flexColumns = flattenColumns.filter((column) => !isNumber$1(column.width));
          flattenColumns.forEach((column) => {
            if (isNumber$1(column.width) && column.realWidth)
              column.realWidth = null;
          });
          if (flexColumns.length > 0 && fit) {
            flattenColumns.forEach((column) => {
              bodyMinWidth += Number(column.width || column.minWidth || 80);
            });
            if (bodyMinWidth <= bodyWidth) {
              this.scrollX.value = false;
              const totalFlexWidth = bodyWidth - bodyMinWidth;
              if (flexColumns.length === 1) {
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
              } else {
                const allColumnsWidth = flexColumns.reduce((prev2, column) => prev2 + Number(column.minWidth || 80), 0);
                const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
                let noneFirstWidth = 0;
                flexColumns.forEach((column, index) => {
                  if (index === 0)
                    return;
                  const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
                  noneFirstWidth += flexWidth;
                  column.realWidth = Number(column.minWidth || 80) + flexWidth;
                });
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
              }
            } else {
              this.scrollX.value = true;
              flexColumns.forEach((column) => {
                column.realWidth = Number(column.minWidth);
              });
            }
            this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
            this.table.state.resizeState.value.width = this.bodyWidth.value;
          } else {
            flattenColumns.forEach((column) => {
              if (!column.width && !column.minWidth) {
                column.realWidth = 80;
              } else {
                column.realWidth = Number(column.width || column.minWidth);
              }
              bodyMinWidth += column.realWidth;
            });
            this.scrollX.value = bodyMinWidth > bodyWidth;
            this.bodyWidth.value = bodyMinWidth;
          }
          const fixedColumns = this.store.states.fixedColumns.value;
          if (fixedColumns.length > 0) {
            let fixedWidth = 0;
            fixedColumns.forEach((column) => {
              fixedWidth += Number(column.realWidth || column.width);
            });
            this.fixedWidth.value = fixedWidth;
          }
          const rightFixedColumns = this.store.states.rightFixedColumns.value;
          if (rightFixedColumns.length > 0) {
            let rightFixedWidth = 0;
            rightFixedColumns.forEach((column) => {
              rightFixedWidth += Number(column.realWidth || column.width);
            });
            this.rightFixedWidth.value = rightFixedWidth;
          }
          this.notifyObservers("columns");
        }
        addObserver(observer) {
          this.observers.push(observer);
        }
        removeObserver(observer) {
          const index = this.observers.indexOf(observer);
          if (index !== -1) {
            this.observers.splice(index, 1);
          }
        }
        notifyObservers(event) {
          const observers = this.observers;
          observers.forEach((observer) => {
            var _a, _b;
            switch (event) {
              case "columns":
                (_a = observer.state) == null ? void 0 : _a.onColumnsChange(this);
                break;
              case "scrollable":
                (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
                break;
              default:
                throw new Error(`Table Layout don't have event ${event}.`);
            }
          });
        }
      }
      const { CheckboxGroup: ElCheckboxGroup } = ElCheckbox;
      const _sfc_main$m = defineComponent({
        name: "ElTableFilterPanel",
        components: {
          ElCheckbox,
          ElCheckboxGroup,
          ElScrollbar,
          ElTooltip,
          ElIcon: ElIcon$1,
          ArrowDown: arrow_down_default,
          ArrowUp: arrow_up_default
        },
        directives: { ClickOutside },
        props: {
          placement: {
            type: String,
            default: "bottom-start"
          },
          store: {
            type: Object
          },
          column: {
            type: Object
          },
          upDataColumn: {
            type: Function
          },
          appendTo: {
            type: String
          }
        },
        setup(props2) {
          const instance = getCurrentInstance();
          const { t } = useLocale();
          const ns = useNamespace("table-filter");
          const parent = instance == null ? void 0 : instance.parent;
          if (!parent.filterPanels.value[props2.column.id]) {
            parent.filterPanels.value[props2.column.id] = instance;
          }
          const tooltipVisible = ref(false);
          const tooltip = ref(null);
          const filters = computed(() => {
            return props2.column && props2.column.filters;
          });
          const filterClassName = computed(() => {
            if (props2.column.filterClassName) {
              return `${ns.b()} ${props2.column.filterClassName}`;
            }
            return ns.b();
          });
          const filterValue = computed({
            get: () => {
              var _a;
              return (((_a = props2.column) == null ? void 0 : _a.filteredValue) || [])[0];
            },
            set: (value) => {
              if (filteredValue.value) {
                if (!isPropAbsent(value)) {
                  filteredValue.value.splice(0, 1, value);
                } else {
                  filteredValue.value.splice(0, 1);
                }
              }
            }
          });
          const filteredValue = computed({
            get() {
              if (props2.column) {
                return props2.column.filteredValue || [];
              }
              return [];
            },
            set(value) {
              if (props2.column) {
                props2.upDataColumn("filteredValue", value);
              }
            }
          });
          const multiple = computed(() => {
            if (props2.column) {
              return props2.column.filterMultiple;
            }
            return true;
          });
          const isActive = (filter) => {
            return filter.value === filterValue.value;
          };
          const hidden = () => {
            tooltipVisible.value = false;
          };
          const showFilterPanel = (e) => {
            e.stopPropagation();
            tooltipVisible.value = !tooltipVisible.value;
          };
          const hideFilterPanel = () => {
            tooltipVisible.value = false;
          };
          const handleConfirm = () => {
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleReset = () => {
            filteredValue.value = [];
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleSelect = (_filterValue) => {
            filterValue.value = _filterValue;
            if (!isPropAbsent(_filterValue)) {
              confirmFilter(filteredValue.value);
            } else {
              confirmFilter([]);
            }
            hidden();
          };
          const confirmFilter = (filteredValue2) => {
            props2.store.commit("filterChange", {
              column: props2.column,
              values: filteredValue2
            });
            props2.store.updateAllSelected();
          };
          watch(tooltipVisible, (value) => {
            if (props2.column) {
              props2.upDataColumn("filterOpened", value);
            }
          }, {
            immediate: true
          });
          const popperPaneRef = computed(() => {
            var _a, _b;
            return (_b = (_a = tooltip.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
          });
          return {
            tooltipVisible,
            multiple,
            filterClassName,
            filteredValue,
            filterValue,
            filters,
            handleConfirm,
            handleReset,
            handleSelect,
            isPropAbsent,
            isActive,
            t,
            ns,
            showFilterPanel,
            hideFilterPanel,
            popperPaneRef,
            tooltip
          };
        }
      });
      function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_checkbox = resolveComponent("el-checkbox");
        const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_arrow_up = resolveComponent("arrow-up");
        const _component_arrow_down = resolveComponent("arrow-down");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _directive_click_outside = resolveDirective("click-outside");
        return openBlock(), createBlock(_component_el_tooltip, {
          ref: "tooltip",
          visible: _ctx.tooltipVisible,
          offset: 0,
          placement: _ctx.placement,
          "show-arrow": false,
          "stop-popper-mouse-event": false,
          teleported: "",
          effect: "light",
          pure: "",
          "popper-class": _ctx.filterClassName,
          persistent: "",
          "append-to": _ctx.appendTo
        }, {
          content: withCtx(() => [
            _ctx.multiple ? (openBlock(), createElementBlock("div", { key: 0 }, [
              createElementVNode("div", {
                class: normalizeClass(_ctx.ns.e("content"))
              }, [
                createVNode(_component_el_scrollbar, {
                  "wrap-class": _ctx.ns.e("wrap")
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_checkbox_group, {
                      modelValue: _ctx.filteredValue,
                      "onUpdate:modelValue": ($event) => _ctx.filteredValue = $event,
                      class: normalizeClass(_ctx.ns.e("checkbox-group"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
                          return openBlock(), createBlock(_component_el_checkbox, {
                            key: filter.value,
                            value: filter.value
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(filter.text), 1)
                            ]),
                            _: 2
                          }, 1032, ["value"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue", "onUpdate:modelValue", "class"])
                  ]),
                  _: 1
                }, 8, ["wrap-class"])
              ], 2),
              createElementVNode("div", {
                class: normalizeClass(_ctx.ns.e("bottom"))
              }, [
                createElementVNode("button", {
                  class: normalizeClass({ [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0 }),
                  disabled: _ctx.filteredValue.length === 0,
                  type: "button",
                  onClick: _ctx.handleConfirm
                }, toDisplayString(_ctx.t("el.table.confirmFilter")), 11, ["disabled", "onClick"]),
                createElementVNode("button", {
                  type: "button",
                  onClick: _ctx.handleReset
                }, toDisplayString(_ctx.t("el.table.resetFilter")), 9, ["onClick"])
              ], 2)
            ])) : (openBlock(), createElementBlock("ul", {
              key: 1,
              class: normalizeClass(_ctx.ns.e("list"))
            }, [
              createElementVNode("li", {
                class: normalizeClass([
                  _ctx.ns.e("list-item"),
                  {
                    [_ctx.ns.is("active")]: _ctx.isPropAbsent(_ctx.filterValue)
                  }
                ]),
                onClick: ($event) => _ctx.handleSelect(null)
              }, toDisplayString(_ctx.t("el.table.clearFilter")), 11, ["onClick"]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
                return openBlock(), createElementBlock("li", {
                  key: filter.value,
                  class: normalizeClass([_ctx.ns.e("list-item"), _ctx.ns.is("active", _ctx.isActive(filter))]),
                  label: filter.value,
                  onClick: ($event) => _ctx.handleSelect(filter.value)
                }, toDisplayString(filter.text), 11, ["label", "onClick"]);
              }), 128))
            ], 2))
          ]),
          default: withCtx(() => [
            withDirectives((openBlock(), createElementBlock("span", {
              class: normalizeClass([
                `${_ctx.ns.namespace.value}-table__column-filter-trigger`,
                `${_ctx.ns.namespace.value}-none-outline`
              ]),
              onClick: _ctx.showFilterPanel
            }, [
              createVNode(_component_el_icon, null, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "filter-icon", {}, () => [
                    _ctx.column.filterOpened ? (openBlock(), createBlock(_component_arrow_up, { key: 0 })) : (openBlock(), createBlock(_component_arrow_down, { key: 1 }))
                  ])
                ]),
                _: 3
              })
            ], 10, ["onClick"])), [
              [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
            ])
          ]),
          _: 3
        }, 8, ["visible", "placement", "popper-class", "append-to"]);
      }
      var FilterPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["render", _sfc_render$3], ["__file", "filter-panel.vue"]]);
      function useLayoutObserver(root2) {
        const instance = getCurrentInstance();
        onBeforeMount(() => {
          tableLayout.value.addObserver(instance);
        });
        onMounted(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUpdated(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUnmounted(() => {
          tableLayout.value.removeObserver(instance);
        });
        const tableLayout = computed(() => {
          const layout = root2.layout;
          if (!layout) {
            throw new Error("Can not find table layout.");
          }
          return layout;
        });
        const onColumnsChange = (layout) => {
          var _a;
          const cols = ((_a = root2.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col")) || [];
          if (!cols.length)
            return;
          const flattenColumns = layout.getFlattenColumns();
          const columnsMap = {};
          flattenColumns.forEach((column) => {
            columnsMap[column.id] = column;
          });
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            const name = col.getAttribute("name");
            const column = columnsMap[name];
            if (column) {
              col.setAttribute("width", column.realWidth || column.width);
            }
          }
        };
        const onScrollableChange = (layout) => {
          var _a, _b;
          const cols = ((_a = root2.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col[name=gutter]")) || [];
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            col.setAttribute("width", layout.scrollY.value ? layout.gutterWidth : "0");
          }
          const ths = ((_b = root2.vnode.el) == null ? void 0 : _b.querySelectorAll("th.gutter")) || [];
          for (let i = 0, j = ths.length; i < j; i++) {
            const th = ths[i];
            th.style.width = layout.scrollY.value ? `${layout.gutterWidth}px` : "0";
            th.style.display = layout.scrollY.value ? "" : "none";
          }
        };
        return {
          tableLayout: tableLayout.value,
          onColumnsChange,
          onScrollableChange
        };
      }
      const TABLE_INJECTION_KEY = Symbol("ElTable");
      function useEvent(props2, emit) {
        const instance = getCurrentInstance();
        const parent = inject(TABLE_INJECTION_KEY);
        const handleFilterClick = (event) => {
          event.stopPropagation();
          return;
        };
        const handleHeaderClick = (event, column) => {
          if (!column.filters && column.sortable) {
            handleSortClick(event, column, false);
          } else if (column.filterable && !column.sortable) {
            handleFilterClick(event);
          }
          parent == null ? void 0 : parent.emit("header-click", column, event);
        };
        const handleHeaderContextMenu = (event, column) => {
          parent == null ? void 0 : parent.emit("header-contextmenu", column, event);
        };
        const draggingColumn = ref(null);
        const dragging = ref(false);
        const dragState = ref({});
        const handleMouseDown = (event, column) => {
          if (!isClient)
            return;
          if (column.children && column.children.length > 0)
            return;
          if (draggingColumn.value && props2.border) {
            dragging.value = true;
            const table = parent;
            emit("set-drag-visible", true);
            const tableEl = table == null ? void 0 : table.vnode.el;
            const tableLeft = tableEl.getBoundingClientRect().left;
            const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
            const columnRect = columnEl.getBoundingClientRect();
            const minLeft = columnRect.left - tableLeft + 30;
            addClass(columnEl, "noclick");
            dragState.value = {
              startMouseLeft: event.clientX,
              startLeft: columnRect.right - tableLeft,
              startColumnLeft: columnRect.left - tableLeft,
              tableLeft
            };
            const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
            resizeProxy.style.left = `${dragState.value.startLeft}px`;
            document.onselectstart = function() {
              return false;
            };
            document.ondragstart = function() {
              return false;
            };
            const handleMouseMove2 = (event2) => {
              const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
              const proxyLeft = dragState.value.startLeft + deltaLeft;
              resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
            };
            const handleMouseUp = () => {
              if (dragging.value) {
                const { startColumnLeft, startLeft } = dragState.value;
                const finalLeft = Number.parseInt(resizeProxy.style.left, 10);
                const columnWidth = finalLeft - startColumnLeft;
                column.width = column.realWidth = columnWidth;
                table == null ? void 0 : table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
                requestAnimationFrame(() => {
                  props2.store.scheduleLayout(false, true);
                });
                document.body.style.cursor = "";
                dragging.value = false;
                draggingColumn.value = null;
                dragState.value = {};
                emit("set-drag-visible", false);
              }
              document.removeEventListener("mousemove", handleMouseMove2);
              document.removeEventListener("mouseup", handleMouseUp);
              document.onselectstart = null;
              document.ondragstart = null;
              setTimeout(() => {
                removeClass(columnEl, "noclick");
              }, 0);
            };
            document.addEventListener("mousemove", handleMouseMove2);
            document.addEventListener("mouseup", handleMouseUp);
          }
        };
        const handleMouseMove = (event, column) => {
          var _a;
          if (column.children && column.children.length > 0)
            return;
          const el = event.target;
          if (!isElement(el)) {
            return;
          }
          const target = el == null ? void 0 : el.closest("th");
          if (!column || !column.resizable || !target)
            return;
          if (!dragging.value && props2.border) {
            const rect = target.getBoundingClientRect();
            const bodyStyle = document.body.style;
            const isLastTh = ((_a = target.parentNode) == null ? void 0 : _a.lastElementChild) === target;
            const allowDarg = props2.allowDragLastColumn || !isLastTh;
            if (rect.width > 12 && rect.right - event.clientX < 8 && allowDarg) {
              bodyStyle.cursor = "col-resize";
              if (hasClass(target, "is-sortable")) {
                target.style.cursor = "col-resize";
              }
              draggingColumn.value = column;
            } else if (!dragging.value) {
              bodyStyle.cursor = "";
              if (hasClass(target, "is-sortable")) {
                target.style.cursor = "pointer";
              }
              draggingColumn.value = null;
            }
          }
        };
        const handleMouseOut = () => {
          if (!isClient)
            return;
          document.body.style.cursor = "";
        };
        const toggleOrder = ({ order, sortOrders }) => {
          if (order === "")
            return sortOrders[0];
          const index = sortOrders.indexOf(order || null);
          return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
        };
        const handleSortClick = (event, column, givenOrder) => {
          var _a;
          event.stopPropagation();
          const order = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
          const target = (_a = event.target) == null ? void 0 : _a.closest("th");
          if (target) {
            if (hasClass(target, "noclick")) {
              removeClass(target, "noclick");
              return;
            }
          }
          if (!column.sortable)
            return;
          const clickTarget = event.currentTarget;
          if (["ascending", "descending"].some((str) => hasClass(clickTarget, str) && !column.sortOrders.includes(str))) {
            return;
          }
          const states = props2.store.states;
          let sortProp = states.sortProp.value;
          let sortOrder;
          const sortingColumn = states.sortingColumn.value;
          if (sortingColumn !== column || sortingColumn === column && isNull(sortingColumn.order)) {
            if (sortingColumn) {
              sortingColumn.order = null;
            }
            states.sortingColumn.value = column;
            sortProp = column.property;
          }
          if (!order) {
            sortOrder = column.order = null;
          } else {
            sortOrder = column.order = order;
          }
          states.sortProp.value = sortProp;
          states.sortOrder.value = sortOrder;
          parent == null ? void 0 : parent.store.commit("changeSortCondition");
        };
        return {
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleMouseOut,
          handleSortClick,
          handleFilterClick
        };
      }
      function useStyle$2(props2) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getHeaderRowStyle = (rowIndex) => {
          const headerRowStyle = parent == null ? void 0 : parent.props.headerRowStyle;
          if (isFunction$2(headerRowStyle)) {
            return headerRowStyle.call(null, { rowIndex });
          }
          return headerRowStyle;
        };
        const getHeaderRowClass = (rowIndex) => {
          const classes = [];
          const headerRowClassName = parent == null ? void 0 : parent.props.headerRowClassName;
          if (isString$2(headerRowClassName)) {
            classes.push(headerRowClassName);
          } else if (isFunction$2(headerRowClassName)) {
            classes.push(headerRowClassName.call(null, { rowIndex }));
          }
          return classes.join(" ");
        };
        const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
          var _a;
          let headerCellStyles = (_a = parent == null ? void 0 : parent.props.headerCellStyle) != null ? _a : {};
          if (isFunction$2(headerCellStyles)) {
            headerCellStyles = headerCellStyles.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, column.fixed, props2.store, row);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, headerCellStyles, fixedStyle);
        };
        const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, column.fixed, props2.store, row);
          const classes = [
            column.id,
            column.order,
            column.headerAlign,
            column.className,
            column.labelClassName,
            ...fixedClasses
          ];
          if (!column.children) {
            classes.push("is-leaf");
          }
          if (column.sortable) {
            classes.push("is-sortable");
          }
          const headerCellClassName = parent == null ? void 0 : parent.props.headerCellClassName;
          if (isString$2(headerCellClassName)) {
            classes.push(headerCellClassName);
          } else if (isFunction$2(headerCellClassName)) {
            classes.push(headerCellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        return {
          getHeaderRowStyle,
          getHeaderRowClass,
          getHeaderCellStyle,
          getHeaderCellClass
        };
      }
      const getAllColumns = (columns2) => {
        const result = [];
        columns2.forEach((column) => {
          if (column.children) {
            result.push(column);
            result.push.apply(result, getAllColumns(column.children));
          } else {
            result.push(column);
          }
        });
        return result;
      };
      const convertToRows = (originColumns) => {
        let maxLevel = 1;
        const traverse = (column, parent) => {
          if (parent) {
            column.level = parent.level + 1;
            if (maxLevel < column.level) {
              maxLevel = column.level;
            }
          }
          if (column.children) {
            let colSpan = 0;
            column.children.forEach((subColumn) => {
              traverse(subColumn, column);
              colSpan += subColumn.colSpan;
            });
            column.colSpan = colSpan;
          } else {
            column.colSpan = 1;
          }
        };
        originColumns.forEach((column) => {
          column.level = 1;
          traverse(column, void 0);
        });
        const rows = [];
        for (let i = 0; i < maxLevel; i++) {
          rows.push([]);
        }
        const allColumns = getAllColumns(originColumns);
        allColumns.forEach((column) => {
          if (!column.children) {
            column.rowSpan = maxLevel - column.level + 1;
          } else {
            column.rowSpan = 1;
            column.children.forEach((col) => col.isSubColumn = true);
          }
          rows[column.level - 1].push(column);
        });
        return rows;
      };
      function useUtils$1(props2) {
        const parent = inject(TABLE_INJECTION_KEY);
        const columnRows = computed(() => {
          return convertToRows(props2.store.states.originColumns.value);
        });
        const isGroup = computed(() => {
          const result = columnRows.value.length > 1;
          if (result && parent) {
            parent.state.isGroup.value = true;
          }
          return result;
        });
        const toggleAllSelection = (event) => {
          event.stopPropagation();
          parent == null ? void 0 : parent.store.commit("toggleAllSelection");
        };
        return {
          isGroup,
          toggleAllSelection,
          columnRows
        };
      }
      var TableHeader = defineComponent({
        name: "ElTableHeader",
        components: {
          ElCheckbox
        },
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          },
          appendFilterPanelTo: {
            type: String
          },
          allowDragLastColumn: {
            type: Boolean
          }
        },
        setup(props2, { emit }) {
          const instance = getCurrentInstance();
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const filterPanels = ref({});
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
          const isTableLayoutAuto = (parent == null ? void 0 : parent.props.tableLayout) === "auto";
          const saveIndexSelection = reactive(/* @__PURE__ */ new Map());
          const theadRef = ref();
          const updateFixedColumnStyle = () => {
            setTimeout(() => {
              if (saveIndexSelection.size > 0) {
                saveIndexSelection.forEach((column, key) => {
                  const el = theadRef.value.querySelector(`.${key.replace(/\s/g, ".")}`);
                  if (el) {
                    const width = el.getBoundingClientRect().width;
                    column.width = width;
                  }
                });
                saveIndexSelection.clear();
              }
            });
          };
          watch(saveIndexSelection, updateFixedColumnStyle);
          onMounted(async () => {
            await nextTick();
            await nextTick();
            const { prop, order } = props2.defaultSort;
            parent == null ? void 0 : parent.store.commit("sort", { prop, order, init: true });
            updateFixedColumnStyle();
          });
          const {
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick
          } = useEvent(props2, emit);
          const {
            getHeaderRowStyle,
            getHeaderRowClass,
            getHeaderCellStyle,
            getHeaderCellClass
          } = useStyle$2(props2);
          const { isGroup, toggleAllSelection, columnRows } = useUtils$1(props2);
          instance.state = {
            onColumnsChange,
            onScrollableChange
          };
          instance.filterPanels = filterPanels;
          return {
            ns,
            filterPanels,
            onColumnsChange,
            onScrollableChange,
            columnRows,
            getHeaderRowClass,
            getHeaderRowStyle,
            getHeaderCellClass,
            getHeaderCellStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick,
            isGroup,
            toggleAllSelection,
            saveIndexSelection,
            isTableLayoutAuto,
            theadRef,
            updateFixedColumnStyle
          };
        },
        render() {
          const {
            ns,
            isGroup,
            columnRows,
            getHeaderCellStyle,
            getHeaderCellClass,
            getHeaderRowClass,
            getHeaderRowStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleSortClick,
            handleMouseOut,
            store,
            $parent,
            saveIndexSelection,
            isTableLayoutAuto
          } = this;
          let rowSpan = 1;
          return h$1("thead", {
            ref: "theadRef",
            class: { [ns.is("group")]: isGroup }
          }, columnRows.map((subColumns, rowIndex) => h$1("tr", {
            class: getHeaderRowClass(rowIndex),
            key: rowIndex,
            style: getHeaderRowStyle(rowIndex)
          }, subColumns.map((column, cellIndex) => {
            if (column.rowSpan > rowSpan) {
              rowSpan = column.rowSpan;
            }
            const _class = getHeaderCellClass(rowIndex, cellIndex, subColumns, column);
            if (isTableLayoutAuto && column.fixed) {
              saveIndexSelection.set(_class, column);
            }
            return h$1("th", {
              class: _class,
              colspan: column.colSpan,
              key: `${column.id}-thead`,
              rowspan: column.rowSpan,
              style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
              onClick: ($event) => {
                if ($event.currentTarget.classList.contains("noclick")) {
                  return;
                }
                handleHeaderClick($event, column);
              },
              onContextmenu: ($event) => handleHeaderContextMenu($event, column),
              onMousedown: ($event) => handleMouseDown($event, column),
              onMousemove: ($event) => handleMouseMove($event, column),
              onMouseout: handleMouseOut
            }, [
              h$1("div", {
                class: [
                  "cell",
                  column.filteredValue && column.filteredValue.length > 0 ? "highlight" : ""
                ]
              }, [
                column.renderHeader ? column.renderHeader({
                  column,
                  $index: cellIndex,
                  store,
                  _self: $parent
                }) : column.label,
                column.sortable && h$1("span", {
                  onClick: ($event) => handleSortClick($event, column),
                  class: "caret-wrapper"
                }, [
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "ascending"),
                    class: "sort-caret ascending"
                  }),
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "descending"),
                    class: "sort-caret descending"
                  })
                ]),
                column.filterable && h$1(FilterPanel, {
                  store,
                  placement: column.filterPlacement || "bottom-start",
                  appendTo: $parent.appendFilterPanelTo,
                  column,
                  upDataColumn: (key, value) => {
                    column[key] = value;
                  }
                }, {
                  "filter-icon": () => column.renderFilterIcon ? column.renderFilterIcon({
                    filterOpened: column.filterOpened
                  }) : null
                })
              ])
            ]);
          }))));
        }
      });
      function isGreaterThan(a2, b2, epsilon = 0.03) {
        return a2 - b2 > epsilon;
      }
      function useEvents(props2) {
        const parent = inject(TABLE_INJECTION_KEY);
        const tooltipContent = ref("");
        const tooltipTrigger = ref(h$1("div"));
        const handleEvent = (event, row, name) => {
          var _a;
          const table = parent;
          const cell = getCell(event);
          let column;
          const namespace = (_a = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a.dataset.prefix;
          if (cell) {
            column = getColumnByCell({
              columns: props2.store.states.columns.value
            }, cell, namespace);
            if (column) {
              table == null ? void 0 : table.emit(`cell-${name}`, row, column, cell, event);
            }
          }
          table == null ? void 0 : table.emit(`row-${name}`, row, column, event);
        };
        const handleDoubleClick = (event, row) => {
          handleEvent(event, row, "dblclick");
        };
        const handleClick = (event, row) => {
          props2.store.commit("setCurrentRow", row);
          handleEvent(event, row, "click");
        };
        const handleContextMenu = (event, row) => {
          handleEvent(event, row, "contextmenu");
        };
        const handleMouseEnter = debounce((index) => {
          props2.store.commit("setHoverRow", index);
        }, 30);
        const handleMouseLeave = debounce(() => {
          props2.store.commit("setHoverRow", null);
        }, 30);
        const getPadding = (el) => {
          const style3 = window.getComputedStyle(el, null);
          const paddingLeft = Number.parseInt(style3.paddingLeft, 10) || 0;
          const paddingRight = Number.parseInt(style3.paddingRight, 10) || 0;
          const paddingTop = Number.parseInt(style3.paddingTop, 10) || 0;
          const paddingBottom = Number.parseInt(style3.paddingBottom, 10) || 0;
          return {
            left: paddingLeft,
            right: paddingRight,
            top: paddingTop,
            bottom: paddingBottom
          };
        };
        const toggleRowClassByCell = (rowSpan, event, toggle) => {
          let node = event.target.parentNode;
          while (rowSpan > 1) {
            node = node == null ? void 0 : node.nextSibling;
            if (!node || node.nodeName !== "TR")
              break;
            toggle(node, "hover-row hover-fixed-row");
            rowSpan--;
          }
        };
        const handleCellMouseEnter = (event, row, tooltipOptions) => {
          var _a, _b, _c;
          const table = parent;
          const cell = getCell(event);
          const namespace = (_a = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a.dataset.prefix;
          let column;
          if (cell) {
            column = getColumnByCell({
              columns: props2.store.states.columns.value
            }, cell, namespace);
            if (cell.rowSpan > 1) {
              toggleRowClassByCell(cell.rowSpan, event, addClass);
            }
            const hoverState = table.hoverState = { cell, column, row };
            table == null ? void 0 : table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
          }
          if (!tooltipOptions) {
            return;
          }
          const cellChild = event.target.querySelector(".cell");
          if (!(hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) {
            return;
          }
          const range3 = document.createRange();
          range3.setStart(cellChild, 0);
          range3.setEnd(cellChild, cellChild.childNodes.length);
          const { width: rangeWidth, height: rangeHeight } = range3.getBoundingClientRect();
          const { width: cellChildWidth, height: cellChildHeight } = cellChild.getBoundingClientRect();
          const { top, left, right, bottom } = getPadding(cellChild);
          const horizontalPadding = left + right;
          const verticalPadding = top + bottom;
          if (isGreaterThan(rangeWidth + horizontalPadding, cellChildWidth) || isGreaterThan(rangeHeight + verticalPadding, cellChildHeight) || isGreaterThan(cellChild.scrollWidth, cellChildWidth)) {
            createTablePopper(tooltipOptions, cell.innerText || cell.textContent, row, column, cell, table);
          } else if (((_b = removePopper) == null ? void 0 : _b.trigger) === cell) {
            (_c = removePopper) == null ? void 0 : _c();
          }
        };
        const handleCellMouseLeave = (event) => {
          const cell = getCell(event);
          if (!cell)
            return;
          if (cell.rowSpan > 1) {
            toggleRowClassByCell(cell.rowSpan, event, removeClass);
          }
          const oldHoverState = parent == null ? void 0 : parent.hoverState;
          parent == null ? void 0 : parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
        };
        return {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        };
      }
      function useStyles(props2) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getRowStyle = (row, rowIndex) => {
          const rowStyle = parent == null ? void 0 : parent.props.rowStyle;
          if (isFunction$2(rowStyle)) {
            return rowStyle.call(null, {
              row,
              rowIndex
            });
          }
          return rowStyle || null;
        };
        const getRowClass = (row, rowIndex) => {
          const classes = [ns.e("row")];
          if ((parent == null ? void 0 : parent.props.highlightCurrentRow) && row === props2.store.states.currentRow.value) {
            classes.push("current-row");
          }
          if (props2.stripe && rowIndex % 2 === 1) {
            classes.push(ns.em("row", "striped"));
          }
          const rowClassName = parent == null ? void 0 : parent.props.rowClassName;
          if (isString$2(rowClassName)) {
            classes.push(rowClassName);
          } else if (isFunction$2(rowClassName)) {
            classes.push(rowClassName.call(null, {
              row,
              rowIndex
            }));
          }
          return classes;
        };
        const getCellStyle = (rowIndex, columnIndex, row, column) => {
          const cellStyle = parent == null ? void 0 : parent.props.cellStyle;
          let cellStyles = cellStyle != null ? cellStyle : {};
          if (isFunction$2(cellStyle)) {
            cellStyles = cellStyle.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, props2 == null ? void 0 : props2.fixed, props2.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, cellStyles, fixedStyle);
        };
        const getCellClass = (rowIndex, columnIndex, row, column, offset) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, props2 == null ? void 0 : props2.fixed, props2.store, void 0, offset);
          const classes = [column.id, column.align, column.className, ...fixedClasses];
          const cellClassName = parent == null ? void 0 : parent.props.cellClassName;
          if (isString$2(cellClassName)) {
            classes.push(cellClassName);
          } else if (isFunction$2(cellClassName)) {
            classes.push(cellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        const getSpan = (row, column, rowIndex, columnIndex) => {
          let rowspan = 1;
          let colspan = 1;
          const fn2 = parent == null ? void 0 : parent.props.spanMethod;
          if (isFunction$2(fn2)) {
            const result = fn2({
              row,
              column,
              rowIndex,
              columnIndex
            });
            if (isArray$1(result)) {
              rowspan = result[0];
              colspan = result[1];
            } else if (isObject$1(result)) {
              rowspan = result.rowspan;
              colspan = result.colspan;
            }
          }
          return { rowspan, colspan };
        };
        const getColspanRealWidth = (columns2, colspan, index) => {
          if (colspan < 1) {
            return columns2[index].realWidth;
          }
          const widthArr = columns2.map(({ realWidth, width }) => realWidth || width).slice(index, index + colspan);
          return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
        };
        return {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        };
      }
      const __default__$2 = defineComponent({
        name: "TableTdWrapper"
      });
      const _sfc_main$l = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: {
          colspan: {
            type: Number,
            default: 1
          },
          rowspan: {
            type: Number,
            default: 1
          }
        },
        setup(__props) {
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("td", {
              colspan: __props.colspan,
              rowspan: __props.rowspan
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 8, ["colspan", "rowspan"]);
          };
        }
      });
      var TdWrapper = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__file", "td-wrapper.vue"]]);
      function useRender$1(props2) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        } = useEvents(props2);
        const {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        } = useStyles(props2);
        const firstDefaultColumnIndex = computed(() => {
          return props2.store.states.columns.value.findIndex(({ type: type4 }) => type4 === "default");
        });
        const getKeyOfRow = (row, index) => {
          const rowKey = parent.props.rowKey;
          if (rowKey) {
            return getRowIdentity(row, rowKey);
          }
          return index;
        };
        const rowRender = (row, $index, treeRowData, expanded = false) => {
          const { tooltipEffect, tooltipOptions, store } = props2;
          const { indent, columns: columns2 } = store.states;
          const rowClasses = getRowClass(row, $index);
          let display = true;
          if (treeRowData) {
            rowClasses.push(ns.em("row", `level-${treeRowData.level}`));
            display = treeRowData.display;
          }
          const displayStyle = display ? null : {
            display: "none"
          };
          return h$1("tr", {
            style: [displayStyle, getRowStyle(row, $index)],
            class: rowClasses,
            key: getKeyOfRow(row, $index),
            onDblclick: ($event) => handleDoubleClick($event, row),
            onClick: ($event) => handleClick($event, row),
            onContextmenu: ($event) => handleContextMenu($event, row),
            onMouseenter: () => handleMouseEnter($index),
            onMouseleave: handleMouseLeave
          }, columns2.value.map((column, cellIndex) => {
            const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
            if (!rowspan || !colspan) {
              return null;
            }
            const columnData = Object.assign({}, column);
            columnData.realWidth = getColspanRealWidth(columns2.value, colspan, cellIndex);
            const data2 = {
              store: props2.store,
              _self: props2.context || parent,
              column: columnData,
              row,
              $index,
              cellIndex,
              expanded
            };
            if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
              data2.treeNode = {
                indent: treeRowData.level * indent.value,
                level: treeRowData.level
              };
              if (isBoolean$1(treeRowData.expanded)) {
                data2.treeNode.expanded = treeRowData.expanded;
                if ("loading" in treeRowData) {
                  data2.treeNode.loading = treeRowData.loading;
                }
                if ("noLazyChildren" in treeRowData) {
                  data2.treeNode.noLazyChildren = treeRowData.noLazyChildren;
                }
              }
            }
            const baseKey = `${getKeyOfRow(row, $index)},${cellIndex}`;
            const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
            const mergedTooltipOptions = column.showOverflowTooltip && merge({
              effect: tooltipEffect
            }, tooltipOptions, column.showOverflowTooltip);
            return h$1(TdWrapper, {
              style: getCellStyle($index, cellIndex, row, column),
              class: getCellClass($index, cellIndex, row, column, colspan - 1),
              key: `${patchKey}${baseKey}`,
              rowspan,
              colspan,
              onMouseenter: ($event) => handleCellMouseEnter($event, row, mergedTooltipOptions),
              onMouseleave: handleCellMouseLeave
            }, {
              default: () => cellChildren(cellIndex, column, data2)
            });
          }));
        };
        const cellChildren = (cellIndex, column, data2) => {
          return column.renderCell(data2);
        };
        const wrappedRowRender = (row, $index) => {
          const store = props2.store;
          const { isRowExpanded, assertRowKey } = store;
          const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey } = store.states;
          const columns2 = store.states.columns.value;
          const hasExpandColumn = columns2.some(({ type: type4 }) => type4 === "expand");
          if (hasExpandColumn) {
            const expanded = isRowExpanded(row);
            const tr = rowRender(row, $index, void 0, expanded);
            const renderExpanded = parent.renderExpanded;
            if (expanded) {
              if (!renderExpanded) {
                console.error("[Element Error]renderExpanded is required.");
                return tr;
              }
              return [
                [
                  tr,
                  h$1("tr", {
                    key: `expanded-row__${tr.key}`
                  }, [
                    h$1("td", {
                      colspan: columns2.length,
                      class: `${ns.e("cell")} ${ns.e("expanded-cell")}`
                    }, [renderExpanded({ row, $index, store, expanded })])
                  ])
                ]
              ];
            } else {
              return [[tr]];
            }
          } else if (Object.keys(treeData.value).length) {
            assertRowKey();
            const key = getRowIdentity(row, rowKey.value);
            let cur = treeData.value[key];
            let treeRowData = null;
            if (cur) {
              treeRowData = {
                expanded: cur.expanded,
                level: cur.level,
                display: true
              };
              if (isBoolean$1(cur.lazy)) {
                if (isBoolean$1(cur.loaded) && cur.loaded) {
                  treeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }
                treeRowData.loading = cur.loading;
              }
            }
            const tmp = [rowRender(row, $index, treeRowData)];
            if (cur) {
              let i = 0;
              const traverse = (children, parent2) => {
                if (!(children && children.length && parent2))
                  return;
                children.forEach((node) => {
                  const innerTreeRowData = {
                    display: parent2.display && parent2.expanded,
                    level: parent2.level + 1,
                    expanded: false,
                    noLazyChildren: false,
                    loading: false
                  };
                  const childKey = getRowIdentity(node, rowKey.value);
                  if (isPropAbsent(childKey)) {
                    throw new Error("For nested data item, row-key is required.");
                  }
                  cur = { ...treeData.value[childKey] };
                  if (cur) {
                    innerTreeRowData.expanded = cur.expanded;
                    cur.level = cur.level || innerTreeRowData.level;
                    cur.display = !!(cur.expanded && innerTreeRowData.display);
                    if (isBoolean$1(cur.lazy)) {
                      if (isBoolean$1(cur.loaded) && cur.loaded) {
                        innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                      }
                      innerTreeRowData.loading = cur.loading;
                    }
                  }
                  i++;
                  tmp.push(rowRender(node, $index + i, innerTreeRowData));
                  if (cur) {
                    const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
                    traverse(nodes2, cur);
                  }
                });
              };
              cur.display = true;
              const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
              traverse(nodes, cur);
            }
            return tmp;
          } else {
            return rowRender(row, $index, void 0);
          }
        };
        return {
          wrappedRowRender,
          tooltipContent,
          tooltipTrigger
        };
      }
      const defaultProps$2 = {
        store: {
          required: true,
          type: Object
        },
        stripe: Boolean,
        tooltipEffect: String,
        tooltipOptions: {
          type: Object
        },
        context: {
          default: () => ({}),
          type: Object
        },
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        fixed: {
          type: String,
          default: ""
        },
        highlight: Boolean
      };
      var TableBody = defineComponent({
        name: "ElTableBody",
        props: defaultProps$2,
        setup(props2) {
          const instance = getCurrentInstance();
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender$1(props2);
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
          const hoveredCellList = [];
          watch(props2.store.states.hoverRow, (newVal, oldVal) => {
            var _a;
            const el = instance == null ? void 0 : instance.vnode.el;
            const rows = Array.from((el == null ? void 0 : el.children) || []).filter((e) => e == null ? void 0 : e.classList.contains(`${ns.e("row")}`));
            let rowNum = newVal;
            const childNodes = (_a = rows[rowNum]) == null ? void 0 : _a.childNodes;
            if (childNodes == null ? void 0 : childNodes.length) {
              let control = 0;
              const indexes = Array.from(childNodes).reduce((acc, item, index) => {
                var _a2, _b;
                if (((_a2 = childNodes[index]) == null ? void 0 : _a2.colSpan) > 1) {
                  control = (_b = childNodes[index]) == null ? void 0 : _b.colSpan;
                }
                if (item.nodeName !== "TD" && control === 0) {
                  acc.push(index);
                }
                control > 0 && control--;
                return acc;
              }, []);
              indexes.forEach((rowIndex) => {
                var _a2;
                rowNum = newVal;
                while (rowNum > 0) {
                  const preChildNodes = (_a2 = rows[rowNum - 1]) == null ? void 0 : _a2.childNodes;
                  if (preChildNodes[rowIndex] && preChildNodes[rowIndex].nodeName === "TD" && preChildNodes[rowIndex].rowSpan > 1) {
                    addClass(preChildNodes[rowIndex], "hover-cell");
                    hoveredCellList.push(preChildNodes[rowIndex]);
                    break;
                  }
                  rowNum--;
                }
              });
            } else {
              hoveredCellList.forEach((item) => removeClass(item, "hover-cell"));
              hoveredCellList.length = 0;
            }
            if (!props2.store.states.isComplex.value || !isClient)
              return;
            rAF(() => {
              const oldRow = rows[oldVal];
              const newRow = rows[newVal];
              if (oldRow && !oldRow.classList.contains("hover-fixed-row")) {
                removeClass(oldRow, "hover-row");
              }
              if (newRow) {
                addClass(newRow, "hover-row");
              }
            });
          });
          onUnmounted(() => {
            var _a;
            (_a = removePopper) == null ? void 0 : _a();
          });
          return {
            ns,
            onColumnsChange,
            onScrollableChange,
            wrappedRowRender,
            tooltipContent,
            tooltipTrigger
          };
        },
        render() {
          const { wrappedRowRender, store } = this;
          const data2 = store.states.data.value || [];
          return h$1("tbody", { tabIndex: -1 }, [
            data2.reduce((acc, row) => {
              return acc.concat(wrappedRowRender(row, acc.length));
            }, [])
          ]);
        }
      });
      function useMapState() {
        const table = inject(TABLE_INJECTION_KEY);
        const store = table == null ? void 0 : table.store;
        const leftFixedLeafCount = computed(() => {
          return store.states.fixedLeafColumnsLength.value;
        });
        const rightFixedLeafCount = computed(() => {
          return store.states.rightFixedColumns.value.length;
        });
        const columnsCount = computed(() => {
          return store.states.columns.value.length;
        });
        const leftFixedCount = computed(() => {
          return store.states.fixedColumns.value.length;
        });
        const rightFixedCount = computed(() => {
          return store.states.rightFixedColumns.value.length;
        });
        return {
          leftFixedLeafCount,
          rightFixedLeafCount,
          columnsCount,
          leftFixedCount,
          rightFixedCount,
          columns: store.states.columns
        };
      }
      function useStyle$1(props2) {
        const { columns: columns2 } = useMapState();
        const ns = useNamespace("table");
        const getCellClasses = (columns22, cellIndex) => {
          const column = columns22[cellIndex];
          const classes = [
            ns.e("cell"),
            column.id,
            column.align,
            column.labelClassName,
            ...getFixedColumnsClass(ns.b(), cellIndex, column.fixed, props2.store)
          ];
          if (column.className) {
            classes.push(column.className);
          }
          if (!column.children) {
            classes.push(ns.is("leaf"));
          }
          return classes;
        };
        const getCellStyles = (column, cellIndex) => {
          const fixedStyle = getFixedColumnOffset(cellIndex, column.fixed, props2.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return fixedStyle;
        };
        return {
          getCellClasses,
          getCellStyles,
          columns: columns2
        };
      }
      var TableFooter = defineComponent({
        name: "ElTableFooter",
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          summaryMethod: Function,
          sumText: String,
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          }
        },
        setup(props2) {
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const { getCellClasses, getCellStyles, columns: columns2 } = useStyle$1(props2);
          const { onScrollableChange, onColumnsChange } = useLayoutObserver(parent);
          return {
            ns,
            onScrollableChange,
            onColumnsChange,
            getCellClasses,
            getCellStyles,
            columns: columns2
          };
        },
        render() {
          const { columns: columns2, getCellStyles, getCellClasses, summaryMethod, sumText } = this;
          const data2 = this.store.states.data.value;
          let sums = [];
          if (summaryMethod) {
            sums = summaryMethod({
              columns: columns2,
              data: data2
            });
          } else {
            columns2.forEach((column, index) => {
              if (index === 0) {
                sums[index] = sumText;
                return;
              }
              const values = data2.map((item) => Number(item[column.property]));
              const precisions = [];
              let notNumber = true;
              values.forEach((value) => {
                if (!Number.isNaN(+value)) {
                  notNumber = false;
                  const decimal = `${value}`.split(".")[1];
                  precisions.push(decimal ? decimal.length : 0);
                }
              });
              const precision = Math.max.apply(null, precisions);
              if (!notNumber) {
                sums[index] = values.reduce((prev2, curr) => {
                  const value = Number(curr);
                  if (!Number.isNaN(+value)) {
                    return Number.parseFloat((prev2 + curr).toFixed(Math.min(precision, 20)));
                  } else {
                    return prev2;
                  }
                }, 0);
              } else {
                sums[index] = "";
              }
            });
          }
          return h$1(h$1("tfoot", [
            h$1("tr", {}, [
              ...columns2.map((column, cellIndex) => h$1("td", {
                key: cellIndex,
                colspan: column.colSpan,
                rowspan: column.rowSpan,
                class: getCellClasses(columns2, cellIndex),
                style: getCellStyles(column, cellIndex)
              }, [
                h$1("div", {
                  class: ["cell", column.labelClassName]
                }, [sums[cellIndex]])
              ]))
            ])
          ]));
        }
      });
      function useUtils(store) {
        const setCurrentRow = (row) => {
          store.commit("setCurrentRow", row);
        };
        const getSelectionRows = () => {
          return store.getSelectionRows();
        };
        const toggleRowSelection = (row, selected, ignoreSelectable = true) => {
          store.toggleRowSelection(row, selected, false, ignoreSelectable);
          store.updateAllSelected();
        };
        const clearSelection = () => {
          store.clearSelection();
        };
        const clearFilter = (columnKeys) => {
          store.clearFilter(columnKeys);
        };
        const toggleAllSelection = () => {
          store.commit("toggleAllSelection");
        };
        const toggleRowExpansion = (row, expanded) => {
          store.toggleRowExpansionAdapter(row, expanded);
        };
        const clearSort = () => {
          store.clearSort();
        };
        const sort = (prop, order) => {
          store.commit("sort", { prop, order });
        };
        const updateKeyChildren = (key, data2) => {
          store.updateKeyChildren(key, data2);
        };
        return {
          setCurrentRow,
          getSelectionRows,
          toggleRowSelection,
          clearSelection,
          clearFilter,
          toggleAllSelection,
          toggleRowExpansion,
          clearSort,
          sort,
          updateKeyChildren
        };
      }
      function useStyle(props2, layout, store, table) {
        const isHidden2 = ref(false);
        const renderExpanded = ref(null);
        const resizeProxyVisible = ref(false);
        const setDragVisible = (visible) => {
          resizeProxyVisible.value = visible;
        };
        const resizeState = ref({
          width: null,
          height: null,
          headerHeight: null
        });
        const isGroup = ref(false);
        const scrollbarViewStyle = {
          display: "inline-block",
          verticalAlign: "middle"
        };
        const tableWidth = ref();
        const tableScrollHeight = ref(0);
        const bodyScrollHeight = ref(0);
        const headerScrollHeight = ref(0);
        const footerScrollHeight = ref(0);
        const appendScrollHeight = ref(0);
        watchEffect(() => {
          layout.setHeight(props2.height);
        });
        watchEffect(() => {
          layout.setMaxHeight(props2.maxHeight);
        });
        watch(() => [props2.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey]) => {
          if (!unref(rowKey) || !unref(currentRowKey))
            return;
          store.setCurrentRowKey(`${currentRowKey}`);
        }, {
          immediate: true
        });
        watch(() => props2.data, (data2) => {
          table.store.commit("setData", data2);
        }, {
          immediate: true,
          deep: true
        });
        watchEffect(() => {
          if (props2.expandRowKeys) {
            store.setExpandRowKeysAdapter(props2.expandRowKeys);
          }
        });
        const handleMouseLeave = () => {
          table.store.commit("setHoverRow", null);
          if (table.hoverState)
            table.hoverState = null;
        };
        const handleHeaderFooterMousewheel = (event, data2) => {
          const { pixelX, pixelY } = data2;
          if (Math.abs(pixelX) >= Math.abs(pixelY)) {
            table.refs.bodyWrapper.scrollLeft += data2.pixelX / 5;
          }
        };
        const shouldUpdateHeight = computed(() => {
          return props2.height || props2.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
        });
        const tableBodyStyles = computed(() => {
          return {
            width: layout.bodyWidth.value ? `${layout.bodyWidth.value}px` : ""
          };
        });
        const doLayout = () => {
          if (shouldUpdateHeight.value) {
            layout.updateElsHeight();
          }
          layout.updateColumnsWidth();
          if (typeof window === "undefined")
            return;
          requestAnimationFrame(syncPosition);
        };
        onMounted(async () => {
          await nextTick();
          store.updateColumns();
          bindEvents();
          requestAnimationFrame(doLayout);
          const el = table.vnode.el;
          const tableHeader = table.refs.headerWrapper;
          if (props2.flexible && el && el.parentElement) {
            el.parentElement.style.minWidth = "0";
          }
          resizeState.value = {
            width: tableWidth.value = el.offsetWidth,
            height: el.offsetHeight,
            headerHeight: props2.showHeader && tableHeader ? tableHeader.offsetHeight : null
          };
          store.states.columns.value.forEach((column) => {
            if (column.filteredValue && column.filteredValue.length) {
              table.store.commit("filterChange", {
                column,
                values: column.filteredValue,
                silent: true
              });
            }
          });
          table.$ready = true;
        });
        const setScrollClassByEl = (el, className) => {
          if (!el)
            return;
          const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
          classList.push(layout.scrollX.value ? className : "is-scrolling-none");
          el.className = classList.join(" ");
        };
        const setScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          setScrollClassByEl(tableWrapper, className);
        };
        const hasScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          return !!(tableWrapper && tableWrapper.classList.contains(className));
        };
        const syncPosition = function() {
          if (!table.refs.scrollBarRef)
            return;
          if (!layout.scrollX.value) {
            const scrollingNoneClass = "is-scrolling-none";
            if (!hasScrollClass(scrollingNoneClass)) {
              setScrollClass(scrollingNoneClass);
            }
            return;
          }
          const scrollContainer = table.refs.scrollBarRef.wrapRef;
          if (!scrollContainer)
            return;
          const { scrollLeft, offsetWidth, scrollWidth } = scrollContainer;
          const { headerWrapper, footerWrapper } = table.refs;
          if (headerWrapper)
            headerWrapper.scrollLeft = scrollLeft;
          if (footerWrapper)
            footerWrapper.scrollLeft = scrollLeft;
          const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
          if (scrollLeft >= maxScrollLeftPosition) {
            setScrollClass("is-scrolling-right");
          } else if (scrollLeft === 0) {
            setScrollClass("is-scrolling-left");
          } else {
            setScrollClass("is-scrolling-middle");
          }
        };
        const bindEvents = () => {
          if (!table.refs.scrollBarRef)
            return;
          if (table.refs.scrollBarRef.wrapRef) {
            useEventListener(table.refs.scrollBarRef.wrapRef, "scroll", syncPosition, {
              passive: true
            });
          }
          if (props2.fit) {
            useResizeObserver(table.vnode.el, resizeListener);
          } else {
            useEventListener(window, "resize", resizeListener);
          }
          useResizeObserver(table.refs.bodyWrapper, () => {
            var _a, _b;
            resizeListener();
            (_b = (_a = table.refs) == null ? void 0 : _a.scrollBarRef) == null ? void 0 : _b.update();
          });
        };
        const resizeListener = () => {
          var _a, _b, _c, _d;
          const el = table.vnode.el;
          if (!table.$ready || !el)
            return;
          let shouldUpdateLayout = false;
          const {
            width: oldWidth,
            height: oldHeight,
            headerHeight: oldHeaderHeight
          } = resizeState.value;
          const width = tableWidth.value = el.offsetWidth;
          if (oldWidth !== width) {
            shouldUpdateLayout = true;
          }
          const height = el.offsetHeight;
          if ((props2.height || shouldUpdateHeight.value) && oldHeight !== height) {
            shouldUpdateLayout = true;
          }
          const tableHeader = props2.tableLayout === "fixed" ? table.refs.headerWrapper : (_a = table.refs.tableHeaderRef) == null ? void 0 : _a.$el;
          if (props2.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) !== oldHeaderHeight) {
            shouldUpdateLayout = true;
          }
          tableScrollHeight.value = ((_b = table.refs.tableWrapper) == null ? void 0 : _b.scrollHeight) || 0;
          headerScrollHeight.value = (tableHeader == null ? void 0 : tableHeader.scrollHeight) || 0;
          footerScrollHeight.value = ((_c = table.refs.footerWrapper) == null ? void 0 : _c.offsetHeight) || 0;
          appendScrollHeight.value = ((_d = table.refs.appendWrapper) == null ? void 0 : _d.offsetHeight) || 0;
          bodyScrollHeight.value = tableScrollHeight.value - headerScrollHeight.value - footerScrollHeight.value - appendScrollHeight.value;
          if (shouldUpdateLayout) {
            resizeState.value = {
              width,
              height,
              headerHeight: props2.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) || 0
            };
            doLayout();
          }
        };
        const tableSize = useFormSize();
        const bodyWidth = computed(() => {
          const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout;
          return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
        });
        const tableLayout = computed(() => {
          if (props2.maxHeight)
            return "fixed";
          return props2.tableLayout;
        });
        const emptyBlockStyle = computed(() => {
          if (props2.data && props2.data.length)
            return null;
          let height = "100%";
          if (props2.height && bodyScrollHeight.value) {
            height = `${bodyScrollHeight.value}px`;
          }
          const width = tableWidth.value;
          return {
            width: width ? `${width}px` : "",
            height
          };
        });
        const scrollbarStyle = computed(() => {
          if (props2.height) {
            return {
              height: "100%"
            };
          }
          if (props2.maxHeight) {
            if (!Number.isNaN(Number(props2.maxHeight))) {
              return {
                maxHeight: `${props2.maxHeight - headerScrollHeight.value - footerScrollHeight.value}px`
              };
            } else {
              return {
                maxHeight: `calc(${props2.maxHeight} - ${headerScrollHeight.value + footerScrollHeight.value}px)`
              };
            }
          }
          return {};
        });
        const handleFixedMousewheel = (event, data2) => {
          const bodyWrapper = table.refs.bodyWrapper;
          if (Math.abs(data2.spinY) > 0) {
            const currentScrollTop = bodyWrapper.scrollTop;
            if (data2.pixelY < 0 && currentScrollTop !== 0) {
              event.preventDefault();
            }
            if (data2.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
              event.preventDefault();
            }
            bodyWrapper.scrollTop += Math.ceil(data2.pixelY / 5);
          } else {
            bodyWrapper.scrollLeft += Math.ceil(data2.pixelX / 5);
          }
        };
        return {
          isHidden: isHidden2,
          renderExpanded,
          setDragVisible,
          isGroup,
          handleMouseLeave,
          handleHeaderFooterMousewheel,
          tableSize,
          emptyBlockStyle,
          handleFixedMousewheel,
          resizeProxyVisible,
          bodyWidth,
          resizeState,
          doLayout,
          tableBodyStyles,
          tableLayout,
          scrollbarViewStyle,
          scrollbarStyle
        };
      }
      function useKeyRender(table) {
        const observer = ref();
        const initWatchDom = () => {
          const el = table.vnode.el;
          const columnsWrapper = el.querySelector(".hidden-columns");
          const config2 = { childList: true, subtree: true };
          const updateOrderFns = table.store.states.updateOrderFns;
          observer.value = new MutationObserver(() => {
            updateOrderFns.forEach((fn2) => fn2());
          });
          observer.value.observe(columnsWrapper, config2);
        };
        onMounted(() => {
          initWatchDom();
        });
        onUnmounted(() => {
          var _a;
          (_a = observer.value) == null ? void 0 : _a.disconnect();
        });
      }
      var defaultProps$1 = {
        data: {
          type: Array,
          default: () => []
        },
        size: useSizeProp,
        width: [String, Number],
        height: [String, Number],
        maxHeight: [String, Number],
        fit: {
          type: Boolean,
          default: true
        },
        stripe: Boolean,
        border: Boolean,
        rowKey: [String, Function],
        showHeader: {
          type: Boolean,
          default: true
        },
        showSummary: Boolean,
        sumText: String,
        summaryMethod: Function,
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        cellClassName: [String, Function],
        cellStyle: [Object, Function],
        headerRowClassName: [String, Function],
        headerRowStyle: [Object, Function],
        headerCellClassName: [String, Function],
        headerCellStyle: [Object, Function],
        highlightCurrentRow: Boolean,
        currentRowKey: [String, Number],
        emptyText: String,
        expandRowKeys: Array,
        defaultExpandAll: Boolean,
        defaultSort: Object,
        tooltipEffect: String,
        tooltipOptions: Object,
        spanMethod: Function,
        selectOnIndeterminate: {
          type: Boolean,
          default: true
        },
        indent: {
          type: Number,
          default: 16
        },
        treeProps: {
          type: Object,
          default: () => {
            return {
              hasChildren: "hasChildren",
              children: "children",
              checkStrictly: false
            };
          }
        },
        lazy: Boolean,
        load: Function,
        style: {
          type: Object,
          default: () => ({})
        },
        className: {
          type: String,
          default: ""
        },
        tableLayout: {
          type: String,
          default: "fixed"
        },
        scrollbarAlwaysOn: Boolean,
        flexible: Boolean,
        showOverflowTooltip: [Boolean, Object],
        tooltipFormatter: Function,
        appendFilterPanelTo: String,
        scrollbarTabindex: {
          type: [Number, String],
          default: void 0
        },
        allowDragLastColumn: {
          type: Boolean,
          default: true
        }
      };
      function hColgroup(props2) {
        const isAuto = props2.tableLayout === "auto";
        let columns2 = props2.columns || [];
        if (isAuto) {
          if (columns2.every(({ width }) => isUndefined$1(width))) {
            columns2 = [];
          }
        }
        const getPropsData = (column) => {
          const propsData = {
            key: `${props2.tableLayout}_${column.id}`,
            style: {},
            name: void 0
          };
          if (isAuto) {
            propsData.style = {
              width: `${column.width}px`
            };
          } else {
            propsData.name = column.id;
          }
          return propsData;
        };
        return h$1("colgroup", {}, columns2.map((column) => h$1("col", getPropsData(column))));
      }
      hColgroup.props = ["columns", "tableLayout"];
      const useScrollbar = () => {
        const scrollBarRef = ref();
        const scrollTo = (options2, yCoord) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar) {
            scrollbar.scrollTo(options2, yCoord);
          }
        };
        const setScrollPosition = (position, offset) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar && isNumber$1(offset) && ["Top", "Left"].includes(position)) {
            scrollbar[`setScroll${position}`](offset);
          }
        };
        const setScrollTop = (top) => setScrollPosition("Top", top);
        const setScrollLeft = (left) => setScrollPosition("Left", left);
        return {
          scrollBarRef,
          scrollTo,
          setScrollTop,
          setScrollLeft
        };
      };
      var v = false, o, f, s, u, d, N, l, p, m, w, D, x, E, M, F;
      function a() {
        if (!v) {
          v = true;
          var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
          if (x = /\b(iPhone|iP[ao]d)/.exec(e), E = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), M = /FBAN\/\w+;/i.exec(e), F = /Mobile/i.exec(e), D = !!/Win64/.exec(e), n) {
            o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
            var r = /(?:Trident\/(\d+.\d+))/.exec(e);
            N = r ? parseFloat(r[1]) + 4 : o, f = n[2] ? parseFloat(n[2]) : NaN, s = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
          } else o = f = s = d = u = NaN;
          if (i) {
            if (i[1]) {
              var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
              l = t ? parseFloat(t[1].replace("_", ".")) : true;
            } else l = false;
            p = !!i[2], m = !!i[3];
          } else l = p = m = false;
        }
      }
      var _ = { ie: function() {
        return a() || o;
      }, ieCompatibilityMode: function() {
        return a() || N > o;
      }, ie64: function() {
        return _.ie() && D;
      }, firefox: function() {
        return a() || f;
      }, opera: function() {
        return a() || s;
      }, webkit: function() {
        return a() || u;
      }, safari: function() {
        return _.webkit();
      }, chrome: function() {
        return a() || d;
      }, windows: function() {
        return a() || p;
      }, osx: function() {
        return a() || l;
      }, linux: function() {
        return a() || m;
      }, iphone: function() {
        return a() || x;
      }, mobile: function() {
        return a() || x || E || w || F;
      }, nativeApp: function() {
        return a() || M;
      }, android: function() {
        return a() || w;
      }, ipad: function() {
        return a() || E;
      } }, A = _;
      var c = !!(typeof window < "u" && window.document && window.document.createElement), U = { canUseDOM: c }, h = U;
      var X;
      h.canUseDOM && (X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
      function S(e, n) {
        if (!h.canUseDOM || n && !("addEventListener" in document)) return false;
        var i = "on" + e, r = i in document;
        if (!r) {
          var t = document.createElement("div");
          t.setAttribute(i, "return;"), r = typeof t[i] == "function";
        }
        return !r && X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
      }
      var b = S;
      var O = 10, I = 40, P = 800;
      function T(e) {
        var n = 0, i = 0, r = 0, t = 0;
        return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= I, t *= I) : (r *= P, t *= P)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t };
      }
      T.getEventType = function() {
        return A.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
      };
      var Y = T;
      /**
      * Checks if an event is supported in the current execution environment.
      *
      * NOTE: This will not work correctly for non-generic events such as `change`,
      * `reset`, `load`, `error`, and `select`.
      *
      * Borrows from Modernizr.
      *
      * @param {string} eventNameSuffix Event name, e.g. "click".
      * @param {?boolean} capture Check if the capture phase is supported.
      * @return {boolean} True if the event is supported.
      * @internal
      * @license Modernizr 3.0.0pre (Custom Build) | MIT
      */
      const mousewheel = function(element, callback) {
        if (element && element.addEventListener) {
          const fn2 = function(event) {
            const normalized = Y(event);
            callback && Reflect.apply(callback, this, [event, normalized]);
          };
          element.addEventListener("wheel", fn2, { passive: true });
        }
      };
      const Mousewheel = {
        beforeMount(el, binding) {
          mousewheel(el, binding.value);
        }
      };
      let tableIdSeed = 1;
      const _sfc_main$k = defineComponent({
        name: "ElTable",
        directives: {
          Mousewheel
        },
        components: {
          TableHeader,
          TableBody,
          TableFooter,
          ElScrollbar,
          hColgroup
        },
        props: defaultProps$1,
        emits: [
          "select",
          "select-all",
          "selection-change",
          "cell-mouse-enter",
          "cell-mouse-leave",
          "cell-contextmenu",
          "cell-click",
          "cell-dblclick",
          "row-click",
          "row-contextmenu",
          "row-dblclick",
          "header-click",
          "header-contextmenu",
          "sort-change",
          "filter-change",
          "current-change",
          "header-dragend",
          "expand-change",
          "scroll"
        ],
        setup(props2) {
          const { t } = useLocale();
          const ns = useNamespace("table");
          const table = getCurrentInstance();
          provide(TABLE_INJECTION_KEY, table);
          const store = createStore(table, props2);
          table.store = store;
          const layout = new TableLayout({
            store: table.store,
            table,
            fit: props2.fit,
            showHeader: props2.showHeader
          });
          table.layout = layout;
          const isEmpty = computed(() => (store.states.data.value || []).length === 0);
          const {
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            sort,
            updateKeyChildren
          } = useUtils(store);
          const {
            isHidden: isHidden2,
            renderExpanded,
            setDragVisible,
            isGroup,
            handleMouseLeave,
            handleHeaderFooterMousewheel,
            tableSize,
            emptyBlockStyle,
            handleFixedMousewheel,
            resizeProxyVisible,
            bodyWidth,
            resizeState,
            doLayout,
            tableBodyStyles,
            tableLayout,
            scrollbarViewStyle,
            scrollbarStyle
          } = useStyle(props2, layout, store, table);
          const { scrollBarRef, scrollTo, setScrollLeft, setScrollTop } = useScrollbar();
          const debouncedUpdateLayout = debounce(doLayout, 50);
          const tableId = `${ns.namespace.value}-table_${tableIdSeed++}`;
          table.tableId = tableId;
          table.state = {
            isGroup,
            resizeState,
            doLayout,
            debouncedUpdateLayout
          };
          const computedSumText = computed(() => {
            var _a;
            return (_a = props2.sumText) != null ? _a : t("el.table.sumText");
          });
          const computedEmptyText = computed(() => {
            var _a;
            return (_a = props2.emptyText) != null ? _a : t("el.table.emptyText");
          });
          const columns2 = computed(() => {
            return convertToRows(store.states.originColumns.value)[0];
          });
          useKeyRender(table);
          onBeforeUnmount(() => {
            debouncedUpdateLayout.cancel();
          });
          return {
            ns,
            layout,
            store,
            columns: columns2,
            handleHeaderFooterMousewheel,
            handleMouseLeave,
            tableId,
            tableSize,
            isHidden: isHidden2,
            isEmpty,
            renderExpanded,
            resizeProxyVisible,
            resizeState,
            isGroup,
            bodyWidth,
            tableBodyStyles,
            emptyBlockStyle,
            debouncedUpdateLayout,
            handleFixedMousewheel,
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            doLayout,
            sort,
            updateKeyChildren,
            t,
            setDragVisible,
            context: table,
            computedSumText,
            computedEmptyText,
            tableLayout,
            scrollbarViewStyle,
            scrollbarStyle,
            scrollBarRef,
            scrollTo,
            setScrollLeft,
            setScrollTop,
            allowDragLastColumn: props2.allowDragLastColumn
          };
        }
      });
      function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_hColgroup = resolveComponent("hColgroup");
        const _component_table_header = resolveComponent("table-header");
        const _component_table_body = resolveComponent("table-body");
        const _component_table_footer = resolveComponent("table-footer");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _directive_mousewheel = resolveDirective("mousewheel");
        return openBlock(), createElementBlock("div", {
          ref: "tableWrapper",
          class: normalizeClass([
            {
              [_ctx.ns.m("fit")]: _ctx.fit,
              [_ctx.ns.m("striped")]: _ctx.stripe,
              [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
              [_ctx.ns.m("hidden")]: _ctx.isHidden,
              [_ctx.ns.m("group")]: _ctx.isGroup,
              [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
              [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
              [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
              [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
              [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
              "has-footer": _ctx.showSummary
            },
            _ctx.ns.m(_ctx.tableSize),
            _ctx.className,
            _ctx.ns.b(),
            _ctx.ns.m(`layout-${_ctx.tableLayout}`)
          ]),
          style: normalizeStyle(_ctx.style),
          "data-prefix": _ctx.ns.namespace.value,
          onMouseleave: _ctx.handleMouseLeave
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("inner-wrapper"))
          }, [
            createElementVNode("div", {
              ref: "hiddenColumns",
              class: "hidden-columns"
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 512),
            _ctx.showHeader && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              ref: "headerWrapper",
              class: normalizeClass(_ctx.ns.e("header-wrapper"))
            }, [
              createElementVNode("table", {
                ref: "tableHeader",
                class: normalizeClass(_ctx.ns.e("header")),
                style: normalizeStyle(_ctx.tableBodyStyles),
                border: "0",
                cellpadding: "0",
                cellspacing: "0"
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_header, {
                  ref: "tableHeaderRef",
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  "append-filter-panel-to": _ctx.appendFilterPanelTo,
                  "allow-drag-last-column": _ctx.allowDragLastColumn,
                  onSetDragVisible: _ctx.setDragVisible
                }, null, 8, ["border", "default-sort", "store", "append-filter-panel-to", "allow-drag-last-column", "onSetDragVisible"])
              ], 6)
            ], 2)), [
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            createElementVNode("div", {
              ref: "bodyWrapper",
              class: normalizeClass(_ctx.ns.e("body-wrapper"))
            }, [
              createVNode(_component_el_scrollbar, {
                ref: "scrollBarRef",
                "view-style": _ctx.scrollbarViewStyle,
                "wrap-style": _ctx.scrollbarStyle,
                always: _ctx.scrollbarAlwaysOn,
                tabindex: _ctx.scrollbarTabindex,
                onScroll: ($event) => _ctx.$emit("scroll", $event)
              }, {
                default: withCtx(() => [
                  createElementVNode("table", {
                    ref: "tableBody",
                    class: normalizeClass(_ctx.ns.e("body")),
                    cellspacing: "0",
                    cellpadding: "0",
                    border: "0",
                    style: normalizeStyle({
                      width: _ctx.bodyWidth,
                      tableLayout: _ctx.tableLayout
                    })
                  }, [
                    createVNode(_component_hColgroup, {
                      columns: _ctx.store.states.columns.value,
                      "table-layout": _ctx.tableLayout
                    }, null, 8, ["columns", "table-layout"]),
                    _ctx.showHeader && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_header, {
                      key: 0,
                      ref: "tableHeaderRef",
                      class: normalizeClass(_ctx.ns.e("body-header")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      "append-filter-panel-to": _ctx.appendFilterPanelTo,
                      onSetDragVisible: _ctx.setDragVisible
                    }, null, 8, ["class", "border", "default-sort", "store", "append-filter-panel-to", "onSetDragVisible"])) : createCommentVNode("v-if", true),
                    createVNode(_component_table_body, {
                      context: _ctx.context,
                      highlight: _ctx.highlightCurrentRow,
                      "row-class-name": _ctx.rowClassName,
                      "tooltip-effect": _ctx.tooltipEffect,
                      "tooltip-options": _ctx.tooltipOptions,
                      "row-style": _ctx.rowStyle,
                      store: _ctx.store,
                      stripe: _ctx.stripe
                    }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
                    _ctx.showSummary && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_footer, {
                      key: 1,
                      class: normalizeClass(_ctx.ns.e("body-footer")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      "sum-text": _ctx.computedSumText,
                      "summary-method": _ctx.summaryMethod
                    }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : createCommentVNode("v-if", true)
                  ], 6),
                  _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "emptyBlock",
                    style: normalizeStyle(_ctx.emptyBlockStyle),
                    class: normalizeClass(_ctx.ns.e("empty-block"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(_ctx.ns.e("empty-text"))
                    }, [
                      renderSlot(_ctx.$slots, "empty", {}, () => [
                        createTextVNode(toDisplayString(_ctx.computedEmptyText), 1)
                      ])
                    ], 2)
                  ], 6)) : createCommentVNode("v-if", true),
                  _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    ref: "appendWrapper",
                    class: normalizeClass(_ctx.ns.e("append-wrapper"))
                  }, [
                    renderSlot(_ctx.$slots, "append")
                  ], 2)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["view-style", "wrap-style", "always", "tabindex", "onScroll"])
            ], 2),
            _ctx.showSummary && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 1,
              ref: "footerWrapper",
              class: normalizeClass(_ctx.ns.e("footer-wrapper"))
            }, [
              createElementVNode("table", {
                class: normalizeClass(_ctx.ns.e("footer")),
                cellspacing: "0",
                cellpadding: "0",
                border: "0",
                style: normalizeStyle(_ctx.tableBodyStyles)
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_footer, {
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  "sum-text": _ctx.computedSumText,
                  "summary-method": _ctx.summaryMethod
                }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
              ], 6)
            ], 2)), [
              [vShow, !_ctx.isEmpty],
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            _ctx.border || _ctx.isGroup ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(_ctx.ns.e("border-left-patch"))
            }, null, 2)) : createCommentVNode("v-if", true)
          ], 2),
          withDirectives(createElementVNode("div", {
            ref: "resizeProxy",
            class: normalizeClass(_ctx.ns.e("column-resize-proxy"))
          }, null, 2), [
            [vShow, _ctx.resizeProxyVisible]
          ])
        ], 46, ["data-prefix", "onMouseleave"]);
      }
      var Table = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["render", _sfc_render$2], ["__file", "table.vue"]]);
      const defaultClassNames = {
        selection: "table-column--selection",
        expand: "table__expand-column"
      };
      const cellStarts = {
        default: {
          order: ""
        },
        selection: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        expand: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        index: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        }
      };
      const getDefaultClassName = (type4) => {
        return defaultClassNames[type4] || "";
      };
      const cellForced = {
        selection: {
          renderHeader({ store, column }) {
            function isDisabled() {
              return store.states.data.value && store.states.data.value.length === 0;
            }
            return h$1(ElCheckbox, {
              disabled: isDisabled(),
              size: store.states.tableSize.value,
              indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
              "onUpdate:modelValue": store.toggleAllSelection,
              modelValue: store.states.isAllSelected.value,
              ariaLabel: column.label
            });
          },
          renderCell({
            row,
            column,
            store,
            $index
          }) {
            return h$1(ElCheckbox, {
              disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
              size: store.states.tableSize.value,
              onChange: () => {
                store.commit("rowSelectedChanged", row);
              },
              onClick: (event) => event.stopPropagation(),
              modelValue: store.isSelected(row),
              ariaLabel: column.label
            });
          },
          sortable: false,
          resizable: false
        },
        index: {
          renderHeader({ column }) {
            return column.label || "#";
          },
          renderCell({
            column,
            $index
          }) {
            let i = $index + 1;
            const index = column.index;
            if (isNumber$1(index)) {
              i = $index + index;
            } else if (isFunction$2(index)) {
              i = index($index);
            }
            return h$1("div", {}, [i]);
          },
          sortable: false
        },
        expand: {
          renderHeader({ column }) {
            return column.label || "";
          },
          renderCell({
            row,
            store,
            expanded
          }) {
            const { ns } = store;
            const classes = [ns.e("expand-icon")];
            if (expanded) {
              classes.push(ns.em("expand-icon", "expanded"));
            }
            const callback = function(e) {
              e.stopPropagation();
              store.toggleRowExpansion(row);
            };
            return h$1("div", {
              class: classes,
              onClick: callback
            }, {
              default: () => {
                return [
                  h$1(ElIcon$1, null, {
                    default: () => {
                      return [h$1(arrow_right_default)];
                    }
                  })
                ];
              }
            });
          },
          sortable: false,
          resizable: false
        }
      };
      function defaultRenderCell({
        row,
        column,
        $index
      }) {
        var _a;
        const property2 = column.property;
        const value = property2 && getProp(row, property2).value;
        if (column && column.formatter) {
          return column.formatter(row, column, value, $index);
        }
        return ((_a = value == null ? void 0 : value.toString) == null ? void 0 : _a.call(value)) || "";
      }
      function treeCellPrefix({
        row,
        treeNode,
        store
      }, createPlaceholder = false) {
        const { ns } = store;
        if (!treeNode) {
          if (createPlaceholder) {
            return [
              h$1("span", {
                class: ns.e("placeholder")
              })
            ];
          }
          return null;
        }
        const ele = [];
        const callback = function(e) {
          e.stopPropagation();
          if (treeNode.loading) {
            return;
          }
          store.loadOrToggle(row);
        };
        if (treeNode.indent) {
          ele.push(h$1("span", {
            class: ns.e("indent"),
            style: { "padding-left": `${treeNode.indent}px` }
          }));
        }
        if (isBoolean$1(treeNode.expanded) && !treeNode.noLazyChildren) {
          const expandClasses = [
            ns.e("expand-icon"),
            treeNode.expanded ? ns.em("expand-icon", "expanded") : ""
          ];
          let icon = arrow_right_default;
          if (treeNode.loading) {
            icon = loading_default;
          }
          ele.push(h$1("div", {
            class: expandClasses,
            onClick: callback
          }, {
            default: () => {
              return [
                h$1(ElIcon$1, { class: { [ns.is("loading")]: treeNode.loading } }, {
                  default: () => [h$1(icon)]
                })
              ];
            }
          }));
        } else {
          ele.push(h$1("span", {
            class: ns.e("placeholder")
          }));
        }
        return ele;
      }
      function getAllAliases(props2, aliases) {
        return props2.reduce((prev2, cur) => {
          prev2[cur] = cur;
          return prev2;
        }, aliases);
      }
      function useWatcher(owner, props_) {
        const instance = getCurrentInstance();
        const registerComplexWatchers = () => {
          const props2 = ["fixed"];
          const aliases = {
            realWidth: "width",
            realMinWidth: "minWidth"
          };
          const allAliases = getAllAliases(props2, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                let value = newVal;
                if (columnKey === "width" && key === "realWidth") {
                  value = parseWidth(newVal);
                }
                if (columnKey === "minWidth" && key === "realMinWidth") {
                  value = parseMinWidth(newVal);
                }
                instance.columnConfig.value[columnKey] = value;
                instance.columnConfig.value[key] = value;
                const updateColumns = columnKey === "fixed";
                owner.value.store.scheduleLayout(updateColumns);
              });
            }
          });
        };
        const registerNormalWatchers = () => {
          const props2 = [
            "label",
            "filters",
            "filterMultiple",
            "filteredValue",
            "sortable",
            "index",
            "formatter",
            "className",
            "labelClassName",
            "filterClassName",
            "showOverflowTooltip",
            "tooltipFormatter"
          ];
          const aliases = {
            property: "prop",
            align: "realAlign",
            headerAlign: "realHeaderAlign"
          };
          const allAliases = getAllAliases(props2, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                instance.columnConfig.value[key] = newVal;
              });
            }
          });
        };
        return {
          registerComplexWatchers,
          registerNormalWatchers
        };
      }
      function useRender(props2, slots, owner) {
        const instance = getCurrentInstance();
        const columnId = ref("");
        const isSubColumn = ref(false);
        const realAlign = ref();
        const realHeaderAlign = ref();
        const ns = useNamespace("table");
        watchEffect(() => {
          realAlign.value = props2.align ? `is-${props2.align}` : null;
          realAlign.value;
        });
        watchEffect(() => {
          realHeaderAlign.value = props2.headerAlign ? `is-${props2.headerAlign}` : realAlign.value;
          realHeaderAlign.value;
        });
        const columnOrTableParent = computed(() => {
          let parent = instance.vnode.vParent || instance.parent;
          while (parent && !parent.tableId && !parent.columnId) {
            parent = parent.vnode.vParent || parent.parent;
          }
          return parent;
        });
        const hasTreeColumn = computed(() => {
          const { store } = instance.parent;
          if (!store)
            return false;
          const { treeData } = store.states;
          const treeDataValue = treeData.value;
          return treeDataValue && Object.keys(treeDataValue).length > 0;
        });
        const realWidth = ref(parseWidth(props2.width));
        const realMinWidth = ref(parseMinWidth(props2.minWidth));
        const setColumnWidth = (column) => {
          if (realWidth.value)
            column.width = realWidth.value;
          if (realMinWidth.value) {
            column.minWidth = realMinWidth.value;
          }
          if (!realWidth.value && realMinWidth.value) {
            column.width = void 0;
          }
          if (!column.minWidth) {
            column.minWidth = 80;
          }
          column.realWidth = Number(isUndefined$1(column.width) ? column.minWidth : column.width);
          return column;
        };
        const setColumnForcedProps = (column) => {
          const type4 = column.type;
          const source = cellForced[type4] || {};
          Object.keys(source).forEach((prop) => {
            const value = source[prop];
            if (prop !== "className" && !isUndefined$1(value)) {
              column[prop] = value;
            }
          });
          const className = getDefaultClassName(type4);
          if (className) {
            const forceClass = `${unref(ns.namespace)}-${className}`;
            column.className = column.className ? `${column.className} ${forceClass}` : forceClass;
          }
          return column;
        };
        const checkSubColumn = (children) => {
          if (isArray$1(children)) {
            children.forEach((child) => check(child));
          } else {
            check(children);
          }
          function check(item) {
            var _a;
            if (((_a = item == null ? void 0 : item.type) == null ? void 0 : _a.name) === "ElTableColumn") {
              item.vParent = instance;
            }
          }
        };
        const setColumnRenders = (column) => {
          if (props2.renderHeader) ;
          else if (column.type !== "selection") {
            column.renderHeader = (scope) => {
              instance.columnConfig.value["label"];
              return renderSlot(slots, "header", scope, () => [column.label]);
            };
          }
          if (slots["filter-icon"]) {
            column.renderFilterIcon = (scope) => {
              return renderSlot(slots, "filter-icon", scope);
            };
          }
          let originRenderCell = column.renderCell;
          if (column.type === "expand") {
            column.renderCell = (data2) => h$1("div", {
              class: "cell"
            }, [originRenderCell(data2)]);
            owner.value.renderExpanded = (data2) => {
              return slots.default ? slots.default(data2) : slots.default;
            };
          } else {
            originRenderCell = originRenderCell || defaultRenderCell;
            column.renderCell = (data2) => {
              let children = null;
              if (slots.default) {
                const vnodes = slots.default(data2);
                children = vnodes.some((v2) => v2.type !== Comment) ? vnodes : originRenderCell(data2);
              } else {
                children = originRenderCell(data2);
              }
              const { columns: columns2 } = owner.value.store.states;
              const firstUserColumnIndex = columns2.value.findIndex((item) => item.type === "default");
              const shouldCreatePlaceholder = hasTreeColumn.value && data2.cellIndex === firstUserColumnIndex;
              const prefix = treeCellPrefix(data2, shouldCreatePlaceholder);
              const props22 = {
                class: "cell",
                style: {}
              };
              if (column.showOverflowTooltip) {
                props22.class = `${props22.class} ${unref(ns.namespace)}-tooltip`;
                props22.style = {
                  width: `${(data2.column.realWidth || Number(data2.column.width)) - 1}px`
                };
              }
              checkSubColumn(children);
              return h$1("div", props22, [prefix, children]);
            };
          }
          return column;
        };
        const getPropsData = (...propsKey) => {
          return propsKey.reduce((prev2, cur) => {
            if (isArray$1(cur)) {
              cur.forEach((key) => {
                prev2[key] = props2[key];
              });
            }
            return prev2;
          }, {});
        };
        const getColumnElIndex = (children, child) => {
          return Array.prototype.indexOf.call(children, child);
        };
        const updateColumnOrder = () => {
          owner.value.store.commit("updateColumnOrder", instance.columnConfig.value);
        };
        return {
          columnId,
          realAlign,
          isSubColumn,
          realHeaderAlign,
          columnOrTableParent,
          setColumnWidth,
          setColumnForcedProps,
          setColumnRenders,
          getPropsData,
          getColumnElIndex,
          updateColumnOrder
        };
      }
      var defaultProps = {
        type: {
          type: String,
          default: "default"
        },
        label: String,
        className: String,
        labelClassName: String,
        property: String,
        prop: String,
        width: {
          type: [String, Number],
          default: ""
        },
        minWidth: {
          type: [String, Number],
          default: ""
        },
        renderHeader: Function,
        sortable: {
          type: [Boolean, String],
          default: false
        },
        sortMethod: Function,
        sortBy: [String, Function, Array],
        resizable: {
          type: Boolean,
          default: true
        },
        columnKey: String,
        align: String,
        headerAlign: String,
        showOverflowTooltip: {
          type: [Boolean, Object],
          default: void 0
        },
        tooltipFormatter: Function,
        fixed: [Boolean, String],
        formatter: Function,
        selectable: Function,
        reserveSelection: Boolean,
        filterMethod: Function,
        filteredValue: Array,
        filters: Array,
        filterPlacement: String,
        filterMultiple: {
          type: Boolean,
          default: true
        },
        filterClassName: String,
        index: [Number, Function],
        sortOrders: {
          type: Array,
          default: () => {
            return ["ascending", "descending", null];
          },
          validator: (val) => {
            return val.every((order) => ["ascending", "descending", null].includes(order));
          }
        }
      };
      let columnIdSeed = 1;
      var ElTableColumn$1 = defineComponent({
        name: "ElTableColumn",
        components: {
          ElCheckbox
        },
        props: defaultProps,
        setup(props2, { slots }) {
          const instance = getCurrentInstance();
          const columnConfig = ref({});
          const owner = computed(() => {
            let parent2 = instance.parent;
            while (parent2 && !parent2.tableId) {
              parent2 = parent2.parent;
            }
            return parent2;
          });
          const { registerNormalWatchers, registerComplexWatchers } = useWatcher(owner, props2);
          const {
            columnId,
            isSubColumn,
            realHeaderAlign,
            columnOrTableParent,
            setColumnWidth,
            setColumnForcedProps,
            setColumnRenders,
            getPropsData,
            getColumnElIndex,
            realAlign,
            updateColumnOrder
          } = useRender(props2, slots, owner);
          const parent = columnOrTableParent.value;
          columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
          onBeforeMount(() => {
            isSubColumn.value = owner.value !== parent;
            const type4 = props2.type || "default";
            const sortable = props2.sortable === "" ? true : props2.sortable;
            const showOverflowTooltip = isUndefined$1(props2.showOverflowTooltip) ? parent.props.showOverflowTooltip : props2.showOverflowTooltip;
            const tooltipFormatter = isUndefined$1(props2.tooltipFormatter) ? parent.props.tooltipFormatter : props2.tooltipFormatter;
            const defaults = {
              ...cellStarts[type4],
              id: columnId.value,
              type: type4,
              property: props2.prop || props2.property,
              align: realAlign,
              headerAlign: realHeaderAlign,
              showOverflowTooltip,
              tooltipFormatter,
              filterable: props2.filters || props2.filterMethod,
              filteredValue: [],
              filterPlacement: "",
              filterClassName: "",
              isColumnGroup: false,
              isSubColumn: false,
              filterOpened: false,
              sortable,
              index: props2.index,
              rawColumnKey: instance.vnode.key
            };
            const basicProps = [
              "columnKey",
              "label",
              "className",
              "labelClassName",
              "type",
              "renderHeader",
              "formatter",
              "fixed",
              "resizable"
            ];
            const sortProps = ["sortMethod", "sortBy", "sortOrders"];
            const selectProps = ["selectable", "reserveSelection"];
            const filterProps = [
              "filterMethod",
              "filters",
              "filterMultiple",
              "filterOpened",
              "filteredValue",
              "filterPlacement",
              "filterClassName"
            ];
            let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
            column = mergeOptions(defaults, column);
            const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
            column = chains(column);
            columnConfig.value = column;
            registerNormalWatchers();
            registerComplexWatchers();
          });
          onMounted(() => {
            var _a;
            const parent2 = columnOrTableParent.value;
            const children = isSubColumn.value ? parent2.vnode.el.children : (_a = parent2.refs.hiddenColumns) == null ? void 0 : _a.children;
            const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
            columnConfig.value.getColumnIndex = getColumnIndex;
            const columnIndex = getColumnIndex();
            columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null, updateColumnOrder);
          });
          onBeforeUnmount(() => {
            const getColumnIndex = columnConfig.value.getColumnIndex;
            const columnIndex = getColumnIndex ? getColumnIndex() : -1;
            columnIndex > -1 && owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null, updateColumnOrder);
          });
          instance.columnId = columnId.value;
          instance.columnConfig = columnConfig;
          return;
        },
        render() {
          var _a, _b, _c;
          try {
            const renderDefault = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a, {
              row: {},
              column: {},
              $index: -1
            });
            const children = [];
            if (isArray$1(renderDefault)) {
              for (const childNode of renderDefault) {
                if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
                  children.push(childNode);
                } else if (childNode.type === Fragment && isArray$1(childNode.children)) {
                  childNode.children.forEach((vnode2) => {
                    if ((vnode2 == null ? void 0 : vnode2.patchFlag) !== 1024 && !isString$2(vnode2 == null ? void 0 : vnode2.children)) {
                      children.push(vnode2);
                    }
                  });
                }
              }
            }
            const vnode = h$1("div", children);
            return vnode;
          } catch (e) {
            return h$1("div", []);
          }
        }
      });
      const ElTable = withInstall(Table, {
        TableColumn: ElTableColumn$1
      });
      const ElTableColumn = withNoopInstall(ElTableColumn$1);
      const textProps = buildProps({
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger", ""],
          default: ""
        },
        size: {
          type: String,
          values: componentSizes,
          default: ""
        },
        truncated: Boolean,
        lineClamp: {
          type: [String, Number]
        },
        tag: {
          type: String,
          default: "span"
        }
      });
      const __default__$1 = defineComponent({
        name: "ElText"
      });
      const _sfc_main$j = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: textProps,
        setup(__props) {
          const props2 = __props;
          const textRef = ref();
          const textSize = useFormSize();
          const ns = useNamespace("text");
          const textKls = computed(() => [
            ns.b(),
            ns.m(props2.type),
            ns.m(textSize.value),
            ns.is("truncated", props2.truncated),
            ns.is("line-clamp", !isUndefined$1(props2.lineClamp))
          ]);
          const inheritTitle = useAttrs$1().title;
          const bindTitle = () => {
            var _a, _b, _c, _d, _e;
            if (inheritTitle)
              return;
            let shouldAddTitle = false;
            const text = ((_a = textRef.value) == null ? void 0 : _a.textContent) || "";
            if (props2.truncated) {
              const width = (_b = textRef.value) == null ? void 0 : _b.offsetWidth;
              const scrollWidth = (_c = textRef.value) == null ? void 0 : _c.scrollWidth;
              if (width && scrollWidth && scrollWidth > width) {
                shouldAddTitle = true;
              }
            } else if (!isUndefined$1(props2.lineClamp)) {
              const height = (_d = textRef.value) == null ? void 0 : _d.offsetHeight;
              const scrollHeight = (_e = textRef.value) == null ? void 0 : _e.scrollHeight;
              if (height && scrollHeight && scrollHeight > height) {
                shouldAddTitle = true;
              }
            }
            if (shouldAddTitle) {
              textRef.value.setAttribute("title", text);
            } else {
              textRef.value.removeAttribute("title");
            }
          };
          onMounted(bindTitle);
          onUpdated(bindTitle);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              ref_key: "textRef",
              ref: textRef,
              class: normalizeClass(unref(textKls)),
              style: normalizeStyle({ "-webkit-line-clamp": _ctx.lineClamp })
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Text = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__file", "text.vue"]]);
      const ElText = withInstall(Text);
      const segmentedProps = buildProps({
        direction: {
          type: definePropType(String),
          default: "horizontal"
        },
        options: {
          type: definePropType(Array),
          default: () => []
        },
        modelValue: {
          type: [String, Number, Boolean],
          default: void 0
        },
        block: Boolean,
        size: useSizeProp,
        disabled: Boolean,
        validateEvent: {
          type: Boolean,
          default: true
        },
        id: String,
        name: String,
        ...useAriaProps(["ariaLabel"])
      });
      const segmentedEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString$2(val) || isNumber$1(val) || isBoolean$1(val),
        [CHANGE_EVENT]: (val) => isString$2(val) || isNumber$1(val) || isBoolean$1(val)
      };
      const __default__ = defineComponent({
        name: "ElSegmented"
      });
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: segmentedProps,
        emits: segmentedEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("segmented");
          const segmentedId = useId();
          const segmentedSize = useFormSize();
          const _disabled = useFormDisabled();
          const { formItem } = useFormItem();
          const { inputId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext: formItem
          });
          const segmentedRef = ref(null);
          const activeElement = useActiveElement();
          const state = reactive({
            isInit: false,
            width: 0,
            height: 0,
            translateX: 0,
            translateY: 0,
            focusVisible: false
          });
          const handleChange = (item) => {
            const value = getValue2(item);
            emit(UPDATE_MODEL_EVENT, value);
            emit(CHANGE_EVENT, value);
          };
          const getValue2 = (item) => {
            return isObject$1(item) ? item.value : item;
          };
          const getLabel = (item) => {
            return isObject$1(item) ? item.label : item;
          };
          const getDisabled = (item) => {
            return !!(_disabled.value || (isObject$1(item) ? item.disabled : false));
          };
          const getSelected = (item) => {
            return props2.modelValue === getValue2(item);
          };
          const getOption = (value) => {
            return props2.options.find((item) => getValue2(item) === value);
          };
          const getItemCls = (item) => {
            return [
              ns.e("item"),
              ns.is("selected", getSelected(item)),
              ns.is("disabled", getDisabled(item))
            ];
          };
          const updateSelect = () => {
            if (!segmentedRef.value)
              return;
            const selectedItem = segmentedRef.value.querySelector(".is-selected");
            const selectedItemInput = segmentedRef.value.querySelector(".is-selected input");
            if (!selectedItem || !selectedItemInput) {
              state.width = 0;
              state.height = 0;
              state.translateX = 0;
              state.translateY = 0;
              state.focusVisible = false;
              return;
            }
            const rect = selectedItem.getBoundingClientRect();
            state.isInit = true;
            if (props2.direction === "vertical") {
              state.height = rect.height;
              state.translateY = selectedItem.offsetTop;
            } else {
              state.width = rect.width;
              state.translateX = selectedItem.offsetLeft;
            }
            try {
              state.focusVisible = selectedItemInput.matches(":focus-visible");
            } catch (e) {
            }
          };
          const segmentedCls = computed(() => [
            ns.b(),
            ns.m(segmentedSize.value),
            ns.is("block", props2.block)
          ]);
          const selectedStyle = computed(() => ({
            width: props2.direction === "vertical" ? "100%" : `${state.width}px`,
            height: props2.direction === "vertical" ? `${state.height}px` : "100%",
            transform: props2.direction === "vertical" ? `translateY(${state.translateY}px)` : `translateX(${state.translateX}px)`,
            display: state.isInit ? "block" : "none"
          }));
          const selectedCls = computed(() => [
            ns.e("item-selected"),
            ns.is("disabled", getDisabled(getOption(props2.modelValue))),
            ns.is("focus-visible", state.focusVisible)
          ]);
          const name = computed(() => {
            return props2.name || segmentedId.value;
          });
          useResizeObserver(segmentedRef, updateSelect);
          watch(activeElement, updateSelect);
          watch(() => props2.modelValue, () => {
            var _a;
            updateSelect();
            if (props2.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change").catch((err) => debugWarn());
            }
          }, {
            flush: "post"
          });
          return (_ctx, _cache) => {
            return _ctx.options.length ? (openBlock(), createElementBlock("div", {
              key: 0,
              id: unref(inputId),
              ref_key: "segmentedRef",
              ref: segmentedRef,
              class: normalizeClass(unref(segmentedCls)),
              role: "radiogroup",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.ariaLabel || "segmented" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? unref(formItem).labelId : void 0
            }, [
              createElementVNode("div", {
                class: normalizeClass([unref(ns).e("group"), unref(ns).m(props2.direction)])
              }, [
                createElementVNode("div", {
                  style: normalizeStyle(unref(selectedStyle)),
                  class: normalizeClass(unref(selectedCls))
                }, null, 6),
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (item, index) => {
                  return openBlock(), createElementBlock("label", {
                    key: index,
                    class: normalizeClass(getItemCls(item))
                  }, [
                    createElementVNode("input", {
                      class: normalizeClass(unref(ns).e("item-input")),
                      type: "radio",
                      name: unref(name),
                      disabled: getDisabled(item),
                      checked: getSelected(item),
                      onChange: ($event) => handleChange(item)
                    }, null, 42, ["name", "disabled", "checked", "onChange"]),
                    createElementVNode("div", {
                      class: normalizeClass(unref(ns).e("item-label"))
                    }, [
                      renderSlot(_ctx.$slots, "default", { item }, () => [
                        createTextVNode(toDisplayString(getLabel(item)), 1)
                      ])
                    ], 2)
                  ], 2);
                }), 128))
              ], 2)
            ], 10, ["id", "aria-label", "aria-labelledby"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var Segmented = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "segmented.vue"]]);
      const ElSegmented = withInstall(Segmented);
      function useMap(initialValue) {
        const initialMap = /* @__PURE__ */ new Map();
        const state = ref(initialMap);
        const actions = {
          set: (key, value) => {
            state.value.set(key, value);
          },
          get: (key) => {
            return state.value.get(key);
          },
          remove: (key) => {
            state.value.delete(key);
          },
          has: (key) => state.value.has(key),
          clear: () => state.value.clear(),
          setAll: (newMap) => {
            state.value = new Map(newMap);
          },
          reset: () => state.value = initialMap
        };
        return {
          state,
          actions: markRaw(actions)
        };
      }
      const jobList = ref([]);
      const jobMap = useMap();
      const init = useHookVueData("#wrap .page-job-wrapper", "jobList", jobList);
      const useJobList = () => {
        return {
          jobList,
          jobMap,
          initJobList: init
        };
      };
      const columns = [
        {
          key: "title",
          title: "æ ‡é¢˜",
          dataKey: "title",
          width: 200
        },
        {
          key: "state",
          title: "çŠ¶æ€",
          width: 150,
          align: "center",
          cellRenderer: ({ rowData }) => h$1(ElTag$1, { type: rowData.state ?? "primary" }, () => rowData.state_name)
        },
        {
          key: "message",
          title: "ä¿¡æ¯",
          dataKey: "message",
          width: 360,
          minWidth: 360,
          align: "left"
        }
      ];
      const dataOld = ref([]);
      const data = ref([
        {
          title: "å˜¿å˜¿å˜¿",
          state: "info",
          state_name: "æ¶ˆæ¯",
          message: "ç›®å‰æ²¡æœ‰æŠ•é€’æ—¥å¿—å•¦"
        },
        {
          title: "å•¦å•¦å•¦",
          state: "success",
          state_name: "æ¶ˆæ¯",
          message: "è¦æŸ¥çœ‹å…¶ä»–æ—¥å¿—è¯·ç‚¹å‡»å³ä¸Šè§’çš„æ‚¬æµ®æŒ‰é’®"
        }
      ]);
      const useLog = () => {
        const add = (title, err, logdata, msg) => {
          const state = !err ? "success" : err.state;
          const message = msg ?? (err ? err.message : void 0);
          data.value.push({
            title,
            state,
            state_name: (err == null ? void 0 : err.name) ?? "æŠ•é€’æˆåŠŸ",
            message,
            data: logdata
          });
        };
        const info2 = (title, message) => {
          data.value.push({
            title,
            state: "info",
            state_name: "æ¶ˆæ¯",
            message,
            data: void 0
          });
        };
        const clear = () => {
          dataOld.value = [];
          data.value = [];
        };
        const reset = () => {
          dataOld.value = data.value;
          data.value = [];
        };
        const Row = ({ cells, rowData }) => {
          return cells;
        };
        Row.inheritAttrs = false;
        return {
          columns,
          data,
          dataOld,
          clear,
          reset,
          add,
          info: info2,
          Row
        };
      };
      const deliverLock = ref(false);
      const deliverStop$1 = ref(false);
      const useCommon = () => {
        return {
          deliverLock,
          deliverStop: deliverStop$1
        };
      };
      const errMap = /* @__PURE__ */ new Map();
      function createCustomError(name, state = "warning") {
        var _a;
        errMap.set(name, true);
        return _a = class extends Error {
          constructor(message) {
            super(message);
            __publicField(this, "state");
            this.name = name;
            this.state = state;
            Object.setPrototypeOf(this, _a.prototype);
          }
        }, __publicField(_a, "message"), _a;
      }
      createCustomError("é‡å¤æ²Ÿé€š");
      const JobTitleError = createCustomError("å²—ä½åç­›é€‰");
      const CompanyNameError = createCustomError("å…¬å¸åç­›é€‰");
      const SalaryError = createCustomError("è–ªèµ„ç­›é€‰");
      const CompanySizeError = createCustomError("å…¬å¸è§„æ¨¡ç­›é€‰");
      const JobDescriptionError = createCustomError("å·¥ä½œå†…å®¹ç­›é€‰");
      const HrPositionError = createCustomError("HrèŒä½ç­›é€‰");
      const AIFilteringError = createCustomError("AIç­›é€‰");
      const FriendStatusError = createCustomError("å¥½å‹çŠ¶æ€");
      const ActivityError = createCustomError("æ´»è·ƒåº¦è¿‡æ»¤");
      const GoldHunterError = createCustomError("çŒŽå¤´è¿‡æ»¤");
      const UnknownError = createCustomError("æœªçŸ¥é”™è¯¯", "danger");
      const PublishError = createCustomError("æŠ•é€’å‡ºé”™", "danger");
      const GreetError = createCustomError("æ‰“æ‹›å‘¼å‡ºé”™", "danger");
      function requestCard(params) {
        return axios.get("https://www.zhipin.com/wapi/zpgeek/job/card.json", {
          params,
          timeout: 5e3
        });
      }
      async function sendPublishReq(data2, errorMsg, retries = 3) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        if (retries === 0) {
          throw new PublishError(errorMsg || "é‡è¯•å¤šæ¬¡å¤±è´¥");
        }
        const url2 = "https://www.zhipin.com/wapi/zpgeek/friend/add.json";
        let params;
        params = {
          securityId: data2.securityId,
          jobId: data2.encryptJobId,
          lid: data2.lid
        };
        const token = (_a = _unsafeWindow) == null ? void 0 : _a.Cookie.get("bst");
        if (!token) {
          ElMessage.error("æ²¡æœ‰èŽ·å–åˆ°token,è¯·åˆ·æ–°é‡è¯•");
          throw new PublishError("æ²¡æœ‰èŽ·å–åˆ°token");
        }
        try {
          const res = await axios({
            url: url2,
            params,
            method: "POST",
            headers: { Zp_token: token }
          });
          if (res.data.code === 1 && ((_e = (_d = (_c = (_b = res.data) == null ? void 0 : _b.zpData) == null ? void 0 : _c.bizData) == null ? void 0 : _d.chatRemindDialog) == null ? void 0 : _e.content)) {
            throw new PublishError(
              (_i = (_h = (_g = (_f = res.data) == null ? void 0 : _f.zpData) == null ? void 0 : _g.bizData) == null ? void 0 : _h.chatRemindDialog) == null ? void 0 : _i.content
            );
          }
          if (res.data.code !== 0) {
            throw new PublishError("çŠ¶æ€é”™è¯¯:" + res.data.message);
          }
          return res.data;
        } catch (e) {
          if (e instanceof PublishError) {
            throw e;
          }
          return sendPublishReq(data2, e.message, retries - 1);
        }
      }
      async function requestBossData(card, errorMsg, retries = 3) {
        var _a;
        if (retries === 0) {
          throw new GreetError(errorMsg || "é‡è¯•å¤šæ¬¡å¤±è´¥");
        }
        const url2 = "https://www.zhipin.com/wapi/zpchat/geek/getBossData";
        const token = (_a = _unsafeWindow) == null ? void 0 : _a.Cookie.get("bst");
        if (!token) {
          ElMessage.error("æ²¡æœ‰èŽ·å–åˆ°token,è¯·åˆ·æ–°é‡è¯•");
          throw new GreetError("æ²¡æœ‰èŽ·å–åˆ°token");
        }
        try {
          const data2 = new FormData();
          data2.append("bossId", card.encryptUserId);
          data2.append("securityId", card.securityId);
          data2.append("bossSrc", "0");
          const res = await axios({
            url: url2,
            data: data2,
            method: "POST",
            headers: { Zp_token: token }
          });
          if (res.data.code !== 0 && res.data.message !== "éžå¥½å‹å…³ç³»") {
            throw new GreetError("çŠ¶æ€é”™è¯¯:" + res.data.message);
          }
          if (res.data.code !== 0)
            return requestBossData(card, "éžå¥½å‹å…³ç³»", retries - 1);
          return res.data.zpData;
        } catch (e) {
          if (e instanceof GreetError) {
            throw e;
          }
          return requestBossData(card, e.message, retries - 1);
        }
      }
      var Root = protobuf.Root, Type = protobuf.Type, Field = protobuf.Field;
      const root = new Root().define("cn.techwolf.boss.chat").add(
        new Type("TechwolfUser").add(new Field("uid", 1, "int64")).add(new Field("name", 2, "string", "optional")).add(new Field("source", 7, "int32", "optional"))
      ).add(
        new Type("TechwolfImageInfo").add(new Field("url", 1, "string")).add(new Field("width", 2, "int32")).add(new Field("height", 3, "int32"))
      ).add(
        new Type("TechwolfImage").add(new Field("iid", 1, "int64", "optional")).add(new Field("tinyImage", 2, "TechwolfImageInfo", "optional"))
      ).add(
        new Type("TechwolfMessageBody").add(new Field("type", 1, "int32")).add(new Field("templateId", 2, "int32", "optional")).add(new Field("headTitle", 11, "string")).add(new Field("text", 3, "string")).add(new Field("image", 5, "TechwolfImage", "optional"))
      ).add(
        new Type("TechwolfMessage").add(new Field("from", 1, "TechwolfUser")).add(new Field("to", 2, "TechwolfUser")).add(new Field("type", 3, "int32")).add(new Field("mid", 4, "int64", "optional")).add(new Field("time", 5, "int64", "optional")).add(new Field("body", 6, "TechwolfMessageBody")).add(new Field("cmid", 11, "int64", "optional"))
      ).add(
        new Type("TechwolfChatProtocol").add(new Field("type", 1, "int32")).add(new Field("messages", 3, "TechwolfMessage", "repeated"))
      );
      const AwesomeMessage = root.lookupType("TechwolfChatProtocol");
      class Message {
        constructor(args) {
          __publicField(this, "msg");
          __publicField(this, "hex");
          const r = (/* @__PURE__ */ new Date()).getTime();
          const d2 = r + 68256432452609;
          const data2 = {
            messages: [
              {
                from: {
                  uid: args.form_uid,
                  source: 0
                },
                to: {
                  uid: args.to_uid,
                  name: args.to_name,
                  source: 0
                },
                type: 1,
                mid: d2.toString(),
                time: r.toString(),
                body: {
                  type: 1,
                  templateId: 1,
                  text: args.content
                  // image: {},
                },
                cmid: d2.toString()
              }
            ],
            type: 1
          };
          this.msg = AwesomeMessage.encode(data2).finish().slice();
          this.hex = [...this.msg].map((b2) => b2.toString(16).padStart(2, "0")).join("");
        }
        toArrayBuffer() {
          return this.msg.buffer.slice(0, this.msg.byteLength);
        }
        send() {
          _unsafeWindow.ChatWebsocket.send(this);
        }
      }
      var mitem$1 = { exports: {} };
      (function(module2) {
        (function() {
          const miTem2 = {
            name: "miTem",
            version: "1.0.8"
          };
          const templateSettings = {
            statement: /\{%([\s\S]+?)%\}/g,
            expression: /\{\{([\s\S]+?)\}\}/g,
            filter_param: /([\s\S]+?)(\(([^)]*)\))$/
          };
          miTem2.partials = {};
          miTem2.registerPartial = (name, partial) => {
            miTem2.partials[name] = typeof partial === "string" ? miTem2.compile(partial) : partial;
          };
          const statements = {
            partial: (...args) => `o+=m.partials['${args[1]}'].apply(null, [${typeof args[2] !== "undefined" ? `c.${args[2]}` : "c"}]);`,
            if: (...args) => `if(c.${args[1]}){`,
            else: (...args) => `}else ${args[1] === "if" ? statements.if("", args[2]) : "{"}`,
            endif: () => "}",
            endfor: () => "}c=c.loop.parent;",
            for: (...args) => {
              const code = `if (typeof c.${args[3]}=== 'undefined') return '';
      var t={loop:{parent:c,length:c.${args[3]}.length}};c=t;var i=0;
      if(typeof c.loop.parent.${args[3]}.length === 'undefined')
      {c.loop.length=m.objSize(c.loop.parent.${args[3]})}
      for(${args[1]} in c.loop.parent.${args[3]}){
      if (!c.loop.parent.${args[3]}.hasOwnProperty(${args[1]}))continue;
      c.${args[1]}=c.loop.parent.${args[3]}[${args[1]}];
      c.loop.last=(i===c.loop.length-1);
      c.loop.first=(i===0);
      c.loop.key=${args[1]};
      c.loop.index0=i; c.loop.index=i+1;i++;`;
              return code;
            }
          };
          miTem2.variable = function(val) {
            this.val = val;
          };
          miTem2.variable.prototype.applyFilter = function(filterName, filterParameters) {
            let ret;
            if (typeof miTem2.filters[filterName] !== "undefined") {
              ret = miTem2.filters[filterName].apply(this.val, filterParameters);
            } else if (typeof this.val[filterName] === "undefined") {
              throw new Error(`Filter ${filterName} is not defined`);
            } else {
              ret = this.val[filterName].apply(this.val, filterParameters);
            }
            this.val = ret;
            return this;
          };
          miTem2.variable.prototype.toString = function() {
            return this.val;
          };
          miTem2.objSize = (obj) => {
            const keys2 = Object.keys(obj);
            return keys2.length;
          };
          miTem2.retoreDefaultSettings = function() {
            miTem2.settings = {
              stopOnError: false
            };
          };
          miTem2.retoreDefaultSettings();
          miTem2.filters = {
            default(value) {
              return typeof this === "undefined" ? value : this;
            },
            abs() {
              return Math.abs(this);
            },
            capitalize() {
              return this.charAt(0).toUpperCase() + this.slice(1);
            },
            nl2br() {
              return this.replace(/\n/gi, "<br />");
            },
            title() {
              return this.split(" ").map((val) => val.charAt(0).toUpperCase() + val.slice(1).toLowerCase()).join(" ");
            }
          };
          if (module2.exports) {
            module2.exports = miTem2;
          } else {
            window.miTem = miTem2;
          }
          miTem2.processFilters = (expression) => {
            const lexemes = expression.trim().split("|");
            let variable = `(new m.variable(c.${lexemes[0]}))`;
            const filters = lexemes.slice(1);
            let filterRegexLexemes;
            filters.forEach((filter) => {
              filterRegexLexemes = templateSettings.filter_param.exec(filter.trim()) || ["", filter.trim(), "", ""];
              const parameters = filterRegexLexemes[3].split(",");
              variable += `.applyFilter('${filterRegexLexemes[1]}', [${parameters.join(",")}])`;
            });
            variable += ".toString()";
            return variable;
          };
          miTem2.compile = (tmpl) => {
            let returnFunctionStr = "var c=d;var m=this.miTem;var o='";
            const strings = tmpl.split("\n");
            let newLine = "";
            let compiled = true;
            let lineNumber;
            let lineStr;
            const statementReplaceFn = function(...args) {
              const lexemes = args[1].trim().split(" ");
              let retStr = "';";
              if (typeof statements[lexemes[0]] === "undefined") {
                console.error(`Line: ${lineNumber}; Error in ${args[0]}; Unknown tag '${lexemes[0]}'`);
                compiled = false;
              } else retStr += statements[lexemes[0]].apply(null, lexemes);
              retStr += "o+='";
              return retStr;
            };
            const expressionReplaceFn = function(...args) {
              const key = args[1];
              let calculatedValue = miTem2.processFilters(key.replace(/\\'/gi, "'"));
              calculatedValue = `(function(){var s=this,t;s.m=m;try{return ${calculatedValue}}catch(e){console.error('Line: ${parseInt(lineNumber, 10) + 1}; Error in ${args[0]}');`;
              if (miTem2.settings.stopOnError) calculatedValue += "throw e;";
              calculatedValue += "}})()";
              return `'+${calculatedValue}+'`;
            };
            strings.forEach((line, i) => {
              lineNumber = i;
              lineStr = line;
              returnFunctionStr += newLine;
              const currentLine = lineStr.replace(/'/gi, "\\'");
              returnFunctionStr += currentLine.replace(templateSettings.statement, statementReplaceFn).replace(templateSettings.expression, expressionReplaceFn);
              newLine = `'+"\\n"+'`;
            });
            returnFunctionStr += "'; return o;";
            if (compiled) {
              return (data2) => {
                let returnFunction;
                try {
                  returnFunction = new Function("d", returnFunctionStr);
                } catch (e) {
                  console.error(returnFunctionStr);
                  console.error(e);
                }
                const scope = {};
                scope.miTem = miTem2;
                return returnFunction.apply(scope, [data2]);
              };
            }
            return () => "";
          };
        })();
      })(mitem$1);
      var mitemExports = mitem$1.exports;
      const miTem = mitemExports;
      var mitem = {
        miTem
      };
      class llm {
        constructor(conf, template) {
          __publicField(this, "conf");
          __publicField(this, "tem");
          __publicField(this, "template");
          this.conf = conf;
          this.template = template;
          if (typeof template === "string") {
            this.tem = mitem.miTem.compile(template);
          } else {
            if (template.length === 0) {
              throw new Error("å¤šå¯¹è¯æç¤ºè¯ä¸èƒ½ä¸ºç©º");
            }
            this.tem = mitem.miTem.compile(template[template.length - 1].content);
          }
        }
        buildPrompt(data2) {
          if (typeof data2 === "string") {
            return [
              {
                content: data2,
                role: "user"
              }
            ];
          } else if (Array.isArray(this.template)) {
            const temp = this.template;
            temp[temp.length - 1].content = this.tem(data2);
            return temp;
          } else {
            return [
              {
                content: this.tem(data2),
                role: "user"
              }
            ];
          }
        }
      }
      const other = {
        value: {
          timeout: {
            value: 120,
            type: "inputNumber",
            desc: "GPTè¯·æ±‚çš„è¶…æ—¶æ—¶é—´,è¶…æ—¶åŽä¸ä¼šè¿›è¡Œé‡è¯•å°†è·³è¿‡å²—ä½,é»˜è®¤120s"
          }
        },
        alert: "warning",
        label: "å…¶ä»–é…ç½®"
      };
      const desc = {
        stream: "æŽ¨èå¼€å¯,å¯ä»¥å®žæ—¶æŸ¥çœ‹gptè¿”å›žçš„å“åº”,ä½†å¦‚æžœä½ çš„æ¨¡åž‹ä¸æ”¯æŒ,è¯·å…³é—­"
      };
      class TextLineStream extends TransformStream {
        /** Constructs a new instance. */
        constructor(options2 = { allowCR: false }) {
          super({
            transform: (chars, controller) => {
              chars = __privateGet(this, _currentLine) + chars;
              while (true) {
                const lfIndex = chars.indexOf("\n");
                const crIndex = options2.allowCR ? chars.indexOf("\r") : -1;
                if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {
                  controller.enqueue(chars.slice(0, crIndex));
                  chars = chars.slice(crIndex + 1);
                  continue;
                }
                if (lfIndex === -1)
                  break;
                const endIndex = chars[lfIndex - 1] === "\r" ? lfIndex - 1 : lfIndex;
                controller.enqueue(chars.slice(0, endIndex));
                chars = chars.slice(lfIndex + 1);
              }
              __privateSet(this, _currentLine, chars);
            },
            flush: (controller) => {
              if (__privateGet(this, _currentLine) === "")
                return;
              const currentLine = options2.allowCR && __privateGet(this, _currentLine).endsWith("\r") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);
              controller.enqueue(currentLine);
            }
          });
          __privateAdd(this, _currentLine, "");
        }
      }
      _currentLine = new WeakMap();
      function stream(input) {
        let decoder = new TextDecoderStream();
        let split2 = new TextLineStream({ allowCR: true });
        return input.pipeThrough(decoder).pipeThrough(split2);
      }
      function split(input) {
        let rgx = /[:]\s*/;
        let match = rgx.exec(input);
        let idx = match && match.index;
        if (idx) {
          return [
            input.substring(0, idx),
            input.substring(idx + match[0].length)
          ];
        }
      }
      async function* events(res, signal) {
        if (!res.body)
          return;
        let iter = stream(res.body);
        let line, reader = iter.getReader();
        let event;
        for (; ; ) {
          if (signal && signal.aborted) {
            return reader.cancel();
          }
          line = await reader.read();
          if (line.done)
            return;
          if (!line.value) {
            if (event)
              yield event;
            event = void 0;
            continue;
          }
          let [field, value] = split(line.value) || [];
          if (!field)
            continue;
          if (field === "data") {
            event || (event = {});
            event[field] = event[field] ? event[field] + "\n" + value : value;
          } else if (field === "event") {
            event || (event = {});
            event[field] = value;
          } else if (field === "id") {
            event || (event = {});
            event[field] = +value || value;
          } else if (field === "retry") {
            event || (event = {});
            event[field] = +value || void 0;
          }
        }
      }
      class RequestError extends Error {
        constructor(message) {
          super(message);
          this.name = "è¯·æ±‚é”™è¯¯";
        }
      }
      let axiosLoad;
      function request({
        method: method4 = "POST",
        url: url2 = "",
        data: data2 = "",
        headers = {},
        timeout = 5,
        responseType = "json",
        onStream = async () => {
        },
        isFetch = false
      }) {
        if (!isFetch)
          return new Promise((resolve, reject) => {
            _GM_xmlhttpRequest({
              method: method4,
              url: url2,
              data: data2,
              headers,
              timeout: timeout * 1e3,
              responseType,
              ontimeout() {
                if (axiosLoad) axiosLoad();
                reject(new RequestError(`è¶…æ—¶ ${Math.round(timeout / 1e3)}s`));
              },
              onabort() {
                if (axiosLoad) axiosLoad();
                reject(new RequestError("ç”¨æˆ·ä¸­æ­¢"));
              },
              onerror(e) {
                const msg = `${e.responseText} | ${e.error}`;
                if (axiosLoad) axiosLoad();
                reject(new RequestError(msg));
              },
              // onloadend(e) {
              //   if (axiosLoad) axiosLoad();
              //   resolve(e.response);
              // },
              onload(e) {
                if (axiosLoad) axiosLoad();
                resolve(e.response);
              },
              onloadstart(e) {
                axiosLoad = loader({ ms: timeout * 1e3, color: "#F79E63" });
                if (responseType === "stream") {
                  const stream2 = events(e.response);
                  onStream(stream2);
                }
              }
            });
          });
        else {
          const abortController = new AbortController();
          return new Promise((resolve, reject) => {
            axiosLoad = loader({ ms: timeout * 1e3, color: "#F79E63" });
            fetch(url2, {
              method: method4,
              headers,
              body: data2,
              signal: abortController.signal
            }).then(async (response) => {
              if (!response.body) {
                reject(new RequestError("æ²¡æœ‰å“åº”ä½“"));
                return;
              }
              if (!response.ok) {
                const errorText = await response.text();
                if (axiosLoad) axiosLoad();
                reject(new RequestError(`${errorText} | ${response.statusText}`));
                return;
              }
              if (responseType === "stream") {
                const stream2 = events(response, abortController.signal);
                await onStream(stream2);
                return;
              } else {
                const result = responseType === "json" ? await response.json() : await response.text();
                if (axiosLoad) axiosLoad();
                resolve(result);
              }
            }).catch((e) => {
              if (axiosLoad) axiosLoad();
              if (e.name === "AbortError") {
                reject(new RequestError("ç”¨æˆ·ä¸­æ­¢"));
              } else {
                const msg = `${e.message}`;
                reject(new RequestError(msg));
              }
            });
            setTimeout(() => {
              abortController.abort();
              if (axiosLoad) axiosLoad();
              reject(new RequestError(`è¶…æ—¶ ${Math.round(timeout / 1e3)}s`));
            }, timeout * 1e3);
          });
        }
      }
      request.post = (args) => {
        return request({
          method: "POST",
          ...args
        });
      };
      request.get = (args) => {
        return request({
          method: "GET",
          ...args
        });
      };
      const info$3 = {
        mode: {
          mode: "openai",
          label: "ChatGPT",
          desc: `gpt-4oæ•ˆæžœè¾ƒå¥½ä½†ä»·æ ¼æ›´è´µ,æŽ¨èä½¿ç”¨gpt-4o-mini ä»·æ ¼ä¾¿å®œæ€§èƒ½å¥½,éœ€è¦æ ¹æ®è‡ªèº«æƒ…å†µåŽ»ä¼˜åŒ–æç¤ºè¯ä¹Ÿèƒ½è¾¾åˆ°è‰¯å¥½æ•ˆæžœ`,
          icon: `<svg t="1713626988189" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="12440" width="200" height="200"><path d="M815.616 0H208.384C93.3 0 0 94.068 0 210.083v603.834C0 929.955 93.3 1024 208.384 1024h607.232C930.7 1024 1024 929.955 1024 813.917V210.083C1024 94.068 930.7 0 815.616 0z" fill="#10A37F" p-id="12441"></path><path d="M757.364 460.032A142.825 142.825 0 0 0 745.1 342.807a144.407 144.407 0 0 0-155.462-69.26 142.708 142.708 0 0 0-106.729-47.988h-1.257a144.384 144.384 0 0 0-137.355 99.933 142.755 142.755 0 0 0-95.418 69.237 144.43 144.43 0 0 0 17.757 169.262 142.825 142.825 0 0 0 12.241 117.202 144.384 144.384 0 0 0 155.462 69.26A142.755 142.755 0 0 0 541.09 798.44h1.28a144.337 144.337 0 0 0 137.356-100.003 142.732 142.732 0 0 0 95.418-69.237 144.198 144.198 0 0 0-17.78-169.192zM542.022 760.995h-0.163a107.148 107.148 0 0 1-68.562-24.855 69.857 69.857 0 0 0 3.375-1.932l114.06-65.862a18.548 18.548 0 0 0 9.379-16.128v-160.93l48.22 27.833a1.722 1.722 0 0 1 0.932 1.327v133.19a107.497 107.497 0 0 1-107.241 107.357z m-230.68-98.514a107.148 107.148 0 0 1-12.8-71.936l3.398 2.002 114.037 65.885a18.595 18.595 0 0 0 18.758 0l139.264-80.407v55.784a1.745 1.745 0 0 1-0.699 1.374l-115.293 66.56a107.567 107.567 0 0 1-107.334 0 107.497 107.497 0 0 1-39.33-39.285z m-29.998-249.018a106.985 106.985 0 0 1 55.878-47.08l-0.047 3.956v131.84a18.525 18.525 0 0 0 9.356 16.105l139.264 80.407-48.221 27.834a1.745 1.745 0 0 1-1.63 0.14l-115.316-66.63a107.497 107.497 0 0 1-39.284-146.595z m396.102 92.16l-139.24-80.384 48.197-27.834a1.722 1.722 0 0 1 1.629-0.163l115.316 66.583a107.427 107.427 0 0 1-16.593 193.746V521.704a18.525 18.525 0 0 0-9.31-16.057z m47.988-72.215a171.055 171.055 0 0 0-3.374-2.025L608 365.521a18.618 18.618 0 0 0-18.758 0l-139.24 80.384v-55.761c0-0.535 0.232-1.07 0.698-1.396l115.293-66.514a107.38 107.38 0 0 1 159.441 111.174z m-301.638 99.235l-48.22-27.834a1.699 1.699 0 0 1-0.932-1.327V370.316a107.38 107.38 0 0 1 176.059-82.456 97.135 97.135 0 0 0-3.375 1.932l-114.083 65.885a18.572 18.572 0 0 0-9.356 16.105v0.116l-0.093 160.745z m26.205-56.46L512 440.343l62.022 35.817v71.633L512 583.587l-62.022-35.794V476.16z" fill="#FFFFFF" p-id="12442"></path></svg>`
        },
        url: {
          desc: "å¯ä½¿ç”¨ä¸­è½¬/ä»£ç†API,å‰ææ˜¯ç¬¦åˆopenaiçš„è§„èŒƒ,åªéœ€è¦å¡«åŸŸå",
          type: "input",
          config: {
            placeholder: "https://api.openai.com"
          },
          value: "https://api.openai.com",
          required: true
        },
        raw_url: {
          desc: "éœ€è¦å¡«å†™å®Œæ•´apiåœ°å€ä½¿ç”¨ï¼šå¦‚: https://example.cn/v1/chat/completions",
          type: "switch",
          value: false
        },
        model: {
          config: {
            placeholder: "gpt-4o-mini",
            options: ["gpt-4o-mini", "gpt-3.5-turbo", "gpt-4o", "gpt-4"].map(
              (item) => ({
                label: item,
                value: item
              })
            ),
            allowCreate: true,
            filterable: true,
            defaultFirstOption: true
          },
          value: "gpt-4o-mini",
          type: "select",
          required: true
        },
        api_key: { type: "input", required: true },
        advanced: {
          label: "é«˜çº§é…ç½®",
          alert: "warning",
          desc: "å°ç™½å‹¿åŠ¨",
          value: {
            json: {
              label: "json",
              value: true,
              type: "switch",
              desc: "ä»…æ”¯æŒè¾ƒæ–°çš„æ¨¡åž‹,ä¼šå¼ºåˆ¶gptè¿”å›žjsonæ ¼å¼,æ•ˆæžœå¥½ä¸€ç‚¹,èƒ½æœ‰æ•ˆå‡å°‘å“åº”è§£æžé”™è¯¯"
            },
            stream: {
              value: false,
              type: "switch",
              desc: desc.stream
            },
            temperature: {
              value: 0.65,
              type: "slider",
              config: {
                min: 0,
                max: 2,
                step: 0.05
              },
              desc: "è¾ƒé«˜çš„å€¼ï¼ˆå¦‚ 0.8ï¼‰å°†ä½¿è¾“å‡ºæ›´åŠ éšæœºï¼Œè€Œè¾ƒä½Žçš„å€¼ï¼ˆå¦‚ 0.2ï¼‰å°†ä½¿å…¶æ›´åŠ é›†ä¸­å’Œç¡®å®šæ€§ã€‚<br/>æˆ‘ä»¬é€šå¸¸å»ºè®®æ›´æ”¹æ­¤é¡¹æˆ– top_p ï¼Œä½†ä¸è¦åŒæ—¶æ›´æ”¹ä¸¤è€…ã€‚"
            },
            top_p: {
              value: 1,
              type: "slider",
              config: {
                min: 0,
                max: 1,
                step: 0.05
              },
              desc: "æ¸©åº¦é‡‡æ ·çš„æ›¿ä»£æ–¹æ³•ç§°ä¸ºæ ¸é‡‡æ ·ï¼Œå…¶ä¸­æ¨¡åž‹è€ƒè™‘å…·æœ‰ top_p æ¦‚çŽ‡è´¨é‡çš„æ ‡è®°çš„ç»“æžœã€‚å› æ­¤ 0.1 æ„å‘³ç€ä»…è€ƒè™‘åŒ…å«å‰ 10% æ¦‚çŽ‡è´¨é‡çš„æ ‡è®°ã€‚<br/>æˆ‘ä»¬é€šå¸¸å»ºè®®æ›´æ”¹æ­¤é¡¹æˆ– temperature ï¼Œä½†ä¸è¦åŒæ—¶æ›´æ”¹ä¸¤è€…ã€‚"
            },
            presence_penalty: {
              value: 0,
              type: "slider",
              config: {
                min: -2,
                max: 2,
                step: 0.1
              },
              desc: "æ­£å€¼æ ¹æ®æ–°æ ‡è®°æ˜¯å¦å‡ºçŽ°åœ¨æ–‡æœ¬ä¸­æ¥å¯¹å…¶è¿›è¡Œæƒ©ç½šï¼Œä»Žè€Œå¢žåŠ æ¨¡åž‹è®¨è®ºæ–°ä¸»é¢˜çš„å¯èƒ½æ€§ã€‚"
            },
            frequency_penalty: {
              value: 0,
              type: "slider",
              config: {
                min: -2,
                max: 2,
                step: 0.1
              },
              desc: "æ­£å€¼æ ¹æ®è¿„ä»Šä¸ºæ­¢æ–‡æœ¬ä¸­çš„çŽ°æœ‰é¢‘çŽ‡å¯¹æ–°æ ‡è®°è¿›è¡Œæƒ©ç½šï¼Œä»Žè€Œé™ä½Žæ¨¡åž‹é€å­—é‡å¤åŒä¸€è¡Œçš„å¯èƒ½æ€§ã€‚"
            }
          }
        },
        other
      };
      let gpt$2 = class gpt extends llm {
        constructor(conf, template) {
          super(conf, template);
        }
        async chat(message) {
          var _a, _b;
          const res = await this.post({ prompt: this.buildPrompt(message) });
          return ((_b = (_a = res.choices.pop()) == null ? void 0 : _a.message) == null ? void 0 : _b.content) || "";
        }
        async message({
          data: data2 = {},
          onPrompt = (s2) => {
          },
          onStream = (s2) => {
          },
          json = false
        }) {
          var _a, _b, _c, _d, _e;
          const prompts = this.buildPrompt(data2);
          const prompt2 = prompts[prompts.length - 1].content;
          onPrompt(prompt2);
          new TextDecoder("utf-8");
          let stream2 = "";
          const ans = { prompt: prompt2 };
          const res = await this.post({
            prompt: prompts,
            json,
            onStream: async (reader) => {
            }
          });
          if (!this.conf.advanced.stream) {
            ans.content = (_b = (_a = res == null ? void 0 : res.choices.pop()) == null ? void 0 : _a.message) == null ? void 0 : _b.content;
            ans.usage = {
              input_tokens: (_c = res == null ? void 0 : res.usage) == null ? void 0 : _c.prompt_tokens,
              output_tokens: (_d = res == null ? void 0 : res.usage) == null ? void 0 : _d.completion_tokens,
              total_tokens: (_e = res == null ? void 0 : res.usage) == null ? void 0 : _e.total_tokens
            };
          } else {
            ans.content = stream2;
          }
          return ans;
        }
        async post({
          prompt: prompt2,
          onStream,
          json = false
        }) {
          const res = await request.post({
            // å…¼å®¹ç‰¹æ®Šçš„apiä¸­è½¬ç«™
            url: this.conf.url + (this.conf.raw_url ? "" : "/v1/chat/completions"),
            data: JSON.stringify({
              messages: prompt2,
              model: this.conf.model,
              stream: this.conf.advanced.stream,
              temperature: this.conf.advanced.temperature,
              top_p: this.conf.advanced.top_p,
              presence_penalty: this.conf.advanced.presence_penalty,
              frequency_penalty: this.conf.advanced.frequency_penalty,
              response_format: this.conf.advanced.json && json ? { type: "json_object" } : void 0
            }),
            headers: {
              Authorization: `Bearer ${this.conf.api_key}`,
              "Content-Type": "application/json"
            },
            timeout: this.conf.other.timeout,
            // TODO: æš‚æ—¶ç¦ç”¨ stream è¾“å‡º
            responseType: "json",
            onStream,
            isFetch: true
          });
          return res;
        }
      };
      const openai = {
        gpt: gpt$2,
        info: info$3
      };
      const info$2 = {
        ...openai.info,
        mode: {
          mode: "moonshot",
          label: "Kimi",
          // disabled: true,
          icon: `<svg t="1713627008962" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="13473" width="200" height="200"><path d="M1024 0m0 186.197333l0 651.605334q0 186.197333-186.197333 186.197333l-651.605334 0q-186.197333 0-186.197333-186.197333l0-651.605334q0-186.197333 186.197333-186.197333l651.605334 0q186.197333 0 186.197333 186.197333Z" fill="#000000" p-id="13474"></path><path d="M580.181333 459.946667c57.173333 1.322667 104.192 52.352 104.192 115.2v232.533333a2.090667 2.090667 0 0 1-2.133333 2.133333h-99.925333a2.090667 2.090667 0 0 1-2.133334-2.133333l-1.706666-294.016c0-1.28-2.218667-1.493333-2.56-0.298667-13.397333 43.946667-52.736 56.32-99.84 56.32H304.384a2.090667 2.090667 0 0 0-2.090667 2.090667v235.946667a2.090667 2.090667 0 0 1-2.090666 2.090666H194.858667a2.090667 2.090667 0 0 1-2.048-2.133333V241.578667c0-1.152 0.896-2.048 2.048-2.048h105.386666c1.109333 0 2.048 0.896 2.048 2.048v216.32c0 1.152 0.938667 2.133333 2.090667 2.133333h135.253333a2.133333 2.133333 0 0 0 1.877334-1.28l96.896-218.026667a2.090667 2.090667 0 0 1 1.92-1.194666h116.778666c1.493333 0 2.517333 1.578667 1.877334 2.944l-66.261334 142.293333c-19.754667 36.224-34.304 61.866667-67.242666 72.789333-1.194667 0.426667-0.938667 2.432 0.298666 2.432h54.4z" fill="#FFFFFF" p-id="13475"></path><path d="M727.338667 227.968c-11.733333 9.856-19.413333 25.941333-19.413334 50.218667 0 22.741333 7.253333 40.405333 18.133334 50.986666-5.674667 9.386667-11.434667 15.957333-15.786667 19.498667-0.725333 0.554667-0.170667 2.218667 0.725333 2.133333l64.426667-4.693333c14.378667-1.066667 26.709333-6.485333 37.034667-15.744 12.373333-10.496 19.498667-28.544 19.498666-52.181333 0-24.277333-7.125333-40.362667-19.498666-50.218667-11.776-9.813333-26.112-14.762667-43.050667-14.762667-16.298667 0-30.293333 4.949333-42.069333 14.762667z" fill="#007AFF" p-id="13476"></path></svg>`,
          desc: `æ³¨å†Œå°±é€15,å›½äº§æ¨¡åž‹å¯¹ä¸­æ–‡æ”¯æŒåº”è¯¥å¥½ä¸€äº› <a href="https://platform.moonshot.cn/console/api-keys" target="_blank">å¼€é€šæ–‡æ¡£</a>`
        },
        model: {
          config: {
            placeholder: "moonshot-v1-8k",
            options: ["moonshot-v1-8k", "moonshot-v1-32k", "moonshot-v1-128k"].map(
              (item) => ({
                label: item,
                value: item
              })
            ),
            allowCreate: true,
            filterable: true,
            defaultFirstOption: true
          },
          value: "moonshot-v1-8k",
          type: "select",
          required: true
        },
        url: {
          config: {
            placeholder: "https://api.moonshot.cn"
          },
          value: "https://api.moonshot.cn",
          type: "input",
          required: true
        }
      };
      let gpt$1 = class gpt2 extends openai.gpt {
        constructor(conf, template) {
          super(conf, template);
        }
      };
      const moonshot = {
        info: info$2,
        gpt: gpt$1
      };
      const info$1 = {
        mode: {
          mode: "coze",
          label: "Cozeæ‰£å­(beta)",
          desc: `ä¸ä»…å¯ä»¥ç™½å«–ï¼Œè¿˜æœ‰ä¸€å †å®žç”¨å·¥å…· <a href="https://www.coze.cn/open/oauth/pats" target="_blank">èŽ·å–access_token</a><br />ä½†æ•ˆæžœä¸å¤ªå¯æŽ§ï¼Œæ¯”å¦‚æ— ç¨³å®šçš„jsonè¾“å‡ºæ¨¡åž‹ï¼Œæ€»æ˜¯ä¼šå¸¦å…¶ä»–åºŸè¯`,
          icon: `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" fill="none" viewBox="0 0 40 40"><rect width="36" height="36" x="2" y="2" fill="#4D53E8" rx="6"></rect><g filter="url(#icon-menu-logo_svg__a)"><path fill="#fff" fill-rule="evenodd" d="M20.15 7.672c-5.204 0-9.423 4.22-9.423 9.427v3.954H8.464c-2.597 0-3.184 3.643-.719 4.46l2.982.988v1.707c0 1.687 1.775 2.784 3.283 2.03l1.651-.826a.14.14 0 0 1 .196.082c1.338 4.179 7.248 4.179 8.587 0a.14.14 0 0 1 .195-.082l1.652.826c1.508.754 3.283-.343 3.283-2.03v-1.707l2.981-.988c2.466-.817 1.879-4.46-.719-4.46h-2.262v-3.954c0-5.206-4.22-9.427-9.424-9.427Z" clip-rule="evenodd"></path></g><g filter="url(#icon-menu-logo_svg__b)"><path fill="url(#icon-menu-logo_svg__c)" d="M23.343 21.964a.912.912 0 1 1 1.824 0 .912.912 0 0 1-1.825 0Z"></path></g><g filter="url(#icon-menu-logo_svg__d)"><path fill="url(#icon-menu-logo_svg__e)" d="M17.248 25.324a.912.912 0 0 1 1.29-1.29c.89.89 2.333.89 3.224 0a.912.912 0 1 1 1.29 1.29 4.102 4.102 0 0 1-5.804 0Z"></path></g><g filter="url(#icon-menu-logo_svg__f)"><path fill="url(#icon-menu-logo_svg__g)" d="M16.047 20.14a.912.912 0 0 0-.912.912v1.825a.912.912 0 1 0 1.824 0v-1.825a.912.912 0 0 0-.912-.912Z"></path></g><defs><filter id="icon-menu-logo_svg__a" width="30.351" height="27.956" x="4.975" y="6.472" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix><feOffset dy="0.6"></feOffset><feGaussianBlur stdDeviation="0.6"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix values="0 0 0 0 0.165547 0 0 0 0 0.177065 0 0 0 0 0.463086 0 0 0 0.2 0"></feColorMatrix><feBlend in2="BackgroundImageFix" result="effect1_dropShadow_1054_7681"></feBlend><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix><feOffset dy="0.3"></feOffset><feGaussianBlur stdDeviation="0.3"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix values="0 0 0 0 0.164706 0 0 0 0 0.176471 0 0 0 0 0.462745 0 0 0 0.1 0"></feColorMatrix><feBlend in2="effect1_dropShadow_1054_7681" result="effect2_dropShadow_1054_7681"></feBlend><feBlend in="SourceGraphic" in2="effect2_dropShadow_1054_7681" result="shape"></feBlend><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix><feOffset dy="1.2"></feOffset><feGaussianBlur stdDeviation="1.2"></feGaussianBlur><feComposite in2="hardAlpha" k2="-1" k3="1" operator="arithmetic"></feComposite><feColorMatrix values="0 0 0 0 0.301961 0 0 0 0 0.32549 0 0 0 0 0.909804 0 0 0 0.1 0"></feColorMatrix><feBlend in2="shape" result="effect3_innerShadow_1054_7681"></feBlend><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix><feOffset dy="-1.2"></feOffset><feGaussianBlur stdDeviation="1.2"></feGaussianBlur><feComposite in2="hardAlpha" k2="-1" k3="1" operator="arithmetic"></feComposite><feColorMatrix values="0 0 0 0 0.301961 0 0 0 0 0.32549 0 0 0 0 0.909804 0 0 0 0.15 0"></feColorMatrix><feBlend in2="effect3_innerShadow_1054_7681" result="effect4_innerShadow_1054_7681"></feBlend><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix><feOffset dy="-1.2"></feOffset><feGaussianBlur stdDeviation="0.9"></feGaussianBlur><feComposite in2="hardAlpha" k2="-1" k3="1" operator="arithmetic"></feComposite><feColorMatrix values="0 0 0 0 0.301961 0 0 0 0 0.32549 0 0 0 0 0.909804 0 0 0 0.15 0"></feColorMatrix><feBlend in2="effect4_innerShadow_1054_7681" result="effect5_innerShadow_1054_7681"></feBlend></filter><filter id="icon-menu-logo_svg__b" width="3.624" height="3.925" x="22.442" y="20.302" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix><feOffset dy="0.45"></feOffset><feGaussianBlur stdDeviation="0.45"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"></feColorMatrix><feBlend in2="BackgroundImageFix" result="effect1_dropShadow_1054_7681"></feBlend><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix><feOffset dy="-0.15"></feOffset><feGaussianBlur stdDeviation="0.3"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix values="0 0 0 0 0.301961 0 0 0 0 0.32549 0 0 0 0 0.909804 0 0 0 0.4 0"></feColorMatrix><feBlend in2="effect1_dropShadow_1054_7681" result="effect2_dropShadow_1054_7681"></feBlend><feBlend in="SourceGraphic" in2="effect2_dropShadow_1054_7681" result="shape"></feBlend></filter><filter id="icon-menu-logo_svg__d" width="8.138" height="4.86" x="16.081" y="23.016" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix><feOffset dy="0.45"></feOffset><feGaussianBlur stdDeviation="0.45"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"></feColorMatrix><feBlend in2="BackgroundImageFix" result="effect1_dropShadow_1054_7681"></feBlend><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix><feOffset dy="-0.15"></feOffset><feGaussianBlur stdDeviation="0.3"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix values="0 0 0 0 0.301961 0 0 0 0 0.32549 0 0 0 0 0.909804 0 0 0 0.4 0"></feColorMatrix><feBlend in2="effect1_dropShadow_1054_7681" result="effect2_dropShadow_1054_7681"></feBlend><feBlend in="SourceGraphic" in2="effect2_dropShadow_1054_7681" result="shape"></feBlend></filter><filter id="icon-menu-logo_svg__f" width="3.624" height="5.749" x="14.235" y="19.39" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix><feOffset dy="0.45"></feOffset><feGaussianBlur stdDeviation="0.45"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"></feColorMatrix><feBlend in2="BackgroundImageFix" result="effect1_dropShadow_1054_7681"></feBlend><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"></feColorMatrix><feOffset dy="-0.15"></feOffset><feGaussianBlur stdDeviation="0.3"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix values="0 0 0 0 0.301961 0 0 0 0 0.32549 0 0 0 0 0.909804 0 0 0 0.4 0"></feColorMatrix><feBlend in2="effect1_dropShadow_1054_7681" result="effect2_dropShadow_1054_7681"></feBlend><feBlend in="SourceGraphic" in2="effect2_dropShadow_1054_7681" result="shape"></feBlend></filter><linearGradient id="icon-menu-logo_svg__c" x1="24.308" x2="24.165" y1="21.357" y2="27.204" gradientUnits="userSpaceOnUse"><stop stop-color="#272DCC"></stop><stop offset="1" stop-color="#9A9DF2"></stop></linearGradient><linearGradient id="icon-menu-logo_svg__e" x1="19.849" x2="19.249" y1="24.65" y2="26.9" gradientUnits="userSpaceOnUse"><stop stop-color="#2B33E6"></stop><stop offset="1" stop-color="#A19AF2"></stop></linearGradient><linearGradient id="icon-menu-logo_svg__g" x1="16.1" x2="15.53" y1="20.75" y2="32.422" gradientUnits="userSpaceOnUse"><stop stop-color="#272DCC"></stop><stop offset="1" stop-color="#9A9DF2"></stop></linearGradient></defs></svg>`
        },
        access_token: {
          desc: "éªŒè¯å®¢æˆ·ç«¯èº«ä»½çš„è®¿é—®ä»¤ç‰Œ",
          type: "input",
          config: {
            placeholder: "pat_OYDacMzM3WyOWV3Dtj2bHRMymzxP****"
          },
          required: true
        },
        bot_id: {
          desc: "è¿›è¡Œä¼šè¯èŠå¤©çš„ Bot ID",
          type: "input",
          config: {
            placeholder: "73428668*****"
          },
          required: true
        },
        other
      };
      class gpt3 extends llm {
        constructor(conf, template) {
          super(conf, template);
        }
        async chat(message) {
          var _a, _b;
          const res = await this.post({
            prompt: this.buildPrompt(message),
            user_id: "test"
          });
          return ((_b = (_a = res.choices.pop()) == null ? void 0 : _a.message) == null ? void 0 : _b.content) || "";
        }
        async message({
          data: data2,
          onPrompt = (s2) => {
          },
          onStream = (s2) => {
          },
          json = false
        }) {
          var _a;
          const prompts = this.buildPrompt(data2);
          const prompt2 = prompts[prompts.length - 1].content;
          onPrompt(prompt2);
          const ans = { prompt: prompt2 };
          await this.post({
            prompt: prompts,
            user_id: ((_a = data2 == null ? void 0 : data2.data) == null ? void 0 : _a.encryptJobId) || "boos-helper",
            onStream: async (stream2) => {
              var _a2, _b, _c, _d, _e;
              for await (const event of stream2) {
                let data22 = {};
                if (event.data) {
                  data22 = JSON.parse(event.data);
                }
                console.log({ ...event, jdata: data22 });
                switch (event.event) {
                  case "conversation.message.delta":
                    const content = data22.content;
                    onStream(content);
                    break;
                  case "conversation.message.completed":
                    if (data22.type === "answer") {
                      ans.content = data22.content;
                    }
                    break;
                  case "conversation.chat.completed":
                    if (((_a2 = data22.last_error) == null ? void 0 : _a2.code) !== 0) {
                      throw new Error(((_b = data22.last_error) == null ? void 0 : _b.msg) ?? "æœªçŸ¥é”™è¯¯");
                    }
                    ans.usage = {
                      total_tokens: (_c = data22.usage) == null ? void 0 : _c.token_count,
                      input_tokens: (_d = data22.usage) == null ? void 0 : _d.input_count,
                      output_tokens: (_e = data22.usage) == null ? void 0 : _e.output_count
                    };
                    break;
                }
              }
            }
          });
          return ans;
        }
        async post(args) {
          const res = await request.post({
            url: "https://api.coze.cn/v3/chat",
            data: JSON.stringify({
              bot_id: this.conf.bot_id,
              user_id: args.user_id,
              stream: true,
              auto_save_history: true,
              additional_messages: args.prompt
            }),
            headers: {
              Authorization: `Bearer ${this.conf.access_token}`,
              "Content-Type": "application/json"
            },
            responseType: "stream",
            timeout: this.conf.other.timeout,
            onStream: args.onStream,
            isFetch: true
          });
          return res;
        }
      }
      const coze = {
        gpt: gpt3,
        info: info$1
      };
      const confModelKey = "conf-model";
      const llms = [openai.info, moonshot.info, coze.info];
      const llmsIcons = llms.reduce((acc, cur) => {
        if (cur.mode.icon) acc[cur.mode.mode] = cur.mode.icon;
        return acc;
      }, {});
      const modelData$1 = ref(_GM_getValue(confModelKey, []));
      logger.debug("aiæ¨¡åž‹æ•°æ®", toRaw(modelData$1.value));
      function getGpt$1(model, template) {
        if (!model.data) {
          throw new Error("GPTæ•°æ®ä¸å­˜åœ¨");
        }
        if (Array.isArray(template)) {
          template = [...template].map((v2) => ({ ...v2 }));
        }
        try {
          switch (model.data.mode) {
            case "openai":
              return new openai.gpt(model.data, template);
            case "moonshot":
              return new moonshot.gpt(model.data, template);
            case "coze":
              return new coze.gpt(model.data, template);
            case "user":
              break;
          }
        } catch (e) {
          throw new Error("GPTæž„å»ºé”™è¯¯");
        }
        throw new Error(`GPTä¸å­˜åœ¨, å¯èƒ½å·²åˆ é™¤åœæ­¢ç»´æŠ¤, ${model.data.mode}`);
      }
      function save() {
        _GM_setValue(confModelKey, toRaw(modelData$1.value));
        ElMessage.success("ä¿å­˜æˆåŠŸ");
      }
      const useModel = () => {
        return {
          modelData: modelData$1,
          save,
          getGpt: getGpt$1
        };
      };
      var dist = {};
      var options = {};
      (function(exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Allow = exports2.ALL = exports2.COLLECTION = exports2.ATOM = exports2.SPECIAL = exports2.INF = exports2._INFINITY = exports2.INFINITY = exports2.NAN = exports2.BOOL = exports2.NULL = exports2.OBJ = exports2.ARR = exports2.NUM = exports2.STR = void 0;
        exports2.STR = 1;
        exports2.NUM = 2;
        exports2.ARR = 4;
        exports2.OBJ = 8;
        exports2.NULL = 16;
        exports2.BOOL = 32;
        exports2.NAN = 64;
        exports2.INFINITY = 128;
        exports2._INFINITY = 256;
        exports2.INF = exports2.INFINITY | exports2._INFINITY;
        exports2.SPECIAL = exports2.NULL | exports2.BOOL | exports2.INF | exports2.NAN;
        exports2.ATOM = exports2.STR | exports2.NUM | exports2.SPECIAL;
        exports2.COLLECTION = exports2.ARR | exports2.OBJ;
        exports2.ALL = exports2.ATOM | exports2.COLLECTION;
        exports2.Allow = { STR: exports2.STR, NUM: exports2.NUM, ARR: exports2.ARR, OBJ: exports2.OBJ, NULL: exports2.NULL, BOOL: exports2.BOOL, NAN: exports2.NAN, INFINITY: exports2.INFINITY, _INFINITY: exports2._INFINITY, INF: exports2.INF, SPECIAL: exports2.SPECIAL, ATOM: exports2.ATOM, COLLECTION: exports2.COLLECTION, ALL: exports2.ALL };
        exports2.default = exports2.Allow;
      })(options);
      (function(exports2) {
        var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k, k2) {
          if (k2 === void 0) k2 = k;
          var desc2 = Object.getOwnPropertyDescriptor(m2, k);
          if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
            desc2 = { enumerable: true, get: function() {
              return m2[k];
            } };
          }
          Object.defineProperty(o2, k2, desc2);
        } : function(o2, m2, k, k2) {
          if (k2 === void 0) k2 = k;
          o2[k2] = m2[k];
        });
        var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
          for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m2, p2);
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Allow = exports2.MalformedJSON = exports2.PartialJSON = exports2.parseJSON = exports2.parse = void 0;
        const options_1 = options;
        Object.defineProperty(exports2, "Allow", { enumerable: true, get: function() {
          return options_1.Allow;
        } });
        __exportStar(options, exports2);
        class PartialJSON extends Error {
        }
        exports2.PartialJSON = PartialJSON;
        class MalformedJSON extends Error {
        }
        exports2.MalformedJSON = MalformedJSON;
        function parseJSON(jsonString, allowPartial = options_1.Allow.ALL) {
          if (typeof jsonString !== "string") {
            throw new TypeError(`expecting str, got ${typeof jsonString}`);
          }
          if (!jsonString.trim()) {
            throw new Error(`${jsonString} is empty`);
          }
          return _parseJSON(jsonString.trim(), allowPartial);
        }
        exports2.parseJSON = parseJSON;
        const _parseJSON = (jsonString, allow) => {
          const length = jsonString.length;
          let index = 0;
          const markPartialJSON = (msg) => {
            throw new PartialJSON(`${msg} at position ${index}`);
          };
          const throwMalformedError = (msg) => {
            throw new MalformedJSON(`${msg} at position ${index}`);
          };
          const parseAny = () => {
            skipBlank();
            if (index >= length)
              markPartialJSON("Unexpected end of input");
            if (jsonString[index] === '"')
              return parseStr();
            if (jsonString[index] === "{")
              return parseObj();
            if (jsonString[index] === "[")
              return parseArr();
            if (jsonString.substring(index, index + 4) === "null" || options_1.Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
              index += 4;
              return null;
            }
            if (jsonString.substring(index, index + 4) === "true" || options_1.Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
              index += 4;
              return true;
            }
            if (jsonString.substring(index, index + 5) === "false" || options_1.Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
              index += 5;
              return false;
            }
            if (jsonString.substring(index, index + 8) === "Infinity" || options_1.Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
              index += 8;
              return Infinity;
            }
            if (jsonString.substring(index, index + 9) === "-Infinity" || options_1.Allow._INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
              index += 9;
              return -Infinity;
            }
            if (jsonString.substring(index, index + 3) === "NaN" || options_1.Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
              index += 3;
              return NaN;
            }
            return parseNum();
          };
          const parseStr = () => {
            const start = index;
            let escape = false;
            index++;
            while (index < length && (jsonString[index] !== '"' || escape && jsonString[index - 1] === "\\")) {
              escape = jsonString[index] === "\\" ? !escape : false;
              index++;
            }
            if (jsonString.charAt(index) == '"') {
              try {
                return JSON.parse(jsonString.substring(start, ++index - Number(escape)));
              } catch (e) {
                throwMalformedError(String(e));
              }
            } else if (options_1.Allow.STR & allow) {
              try {
                return JSON.parse(jsonString.substring(start, index - Number(escape)) + '"');
              } catch (e) {
                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
              }
            }
            markPartialJSON("Unterminated string literal");
          };
          const parseObj = () => {
            index++;
            skipBlank();
            const obj = {};
            try {
              while (jsonString[index] !== "}") {
                skipBlank();
                if (index >= length && options_1.Allow.OBJ & allow)
                  return obj;
                const key = parseStr();
                skipBlank();
                index++;
                try {
                  const value = parseAny();
                  obj[key] = value;
                } catch (e) {
                  if (options_1.Allow.OBJ & allow)
                    return obj;
                  else
                    throw e;
                }
                skipBlank();
                if (jsonString[index] === ",")
                  index++;
              }
            } catch (e) {
              if (options_1.Allow.OBJ & allow)
                return obj;
              else
                markPartialJSON("Expected '}' at end of object");
            }
            index++;
            return obj;
          };
          const parseArr = () => {
            index++;
            const arr = [];
            try {
              while (jsonString[index] !== "]") {
                arr.push(parseAny());
                skipBlank();
                if (jsonString[index] === ",") {
                  index++;
                }
              }
            } catch (e) {
              if (options_1.Allow.ARR & allow) {
                return arr;
              }
              markPartialJSON("Expected ']' at end of array");
            }
            index++;
            return arr;
          };
          const parseNum = () => {
            if (index === 0) {
              if (jsonString === "-")
                throwMalformedError("Not sure what '-' is");
              try {
                return JSON.parse(jsonString);
              } catch (e) {
                if (options_1.Allow.NUM & allow)
                  try {
                    return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
                  } catch (e2) {
                  }
                throwMalformedError(String(e));
              }
            }
            const start = index;
            if (jsonString[index] === "-")
              index++;
            while (jsonString[index] && ",]}".indexOf(jsonString[index]) === -1)
              index++;
            if (index == length && !(options_1.Allow.NUM & allow))
              markPartialJSON("Unterminated number literal");
            try {
              return JSON.parse(jsonString.substring(start, index));
            } catch (e) {
              if (jsonString.substring(start, index) === "-")
                markPartialJSON("Not sure what '-' is");
              try {
                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
              } catch (e2) {
                throwMalformedError(String(e2));
              }
            }
          };
          const skipBlank = () => {
            while (index < length && " \n\r	".includes(jsonString[index])) {
              index++;
            }
          };
          return parseAny();
        };
        const parse = parseJSON;
        exports2.parse = parse;
      })(dist);
      function parseGptJson(json) {
        return dist.parse(
          json.replace(/^```json|```$/g, ""),
          dist.STR | dist.OBJ | dist.NUM | dist.ARR | dist.NULL
        );
      }
      _unsafeWindow.parseGptJson = parseGptJson;
      function rangeMatch(rangeStr, input, mode = "subset") {
        if (!rangeStr) {
          return [false, "æ— å†…å®¹"];
        }
        const reg = /(\d+)(?:-(\d+))?/;
        const match = rangeStr.match(reg);
        let err = "é¢„æœŸä¹‹å¤–";
        if (match && match.length > 0) {
          err = match[0];
        }
        if (match && input) {
          let start = parseInt(match[1]);
          let end = parseInt(match[2] || match[1]);
          if (/^\d+$/.test(input)) {
            let number4 = parseInt(input);
            return [number4 >= start && number4 <= end, err];
          }
          let inputReg = /^(\d+)(?:-(\d+))?/;
          let inputMatch = input.match(inputReg);
          if (inputMatch) {
            let inputStart = parseInt(inputMatch[1]);
            let inputEnd = parseInt(inputMatch[2] || inputMatch[1]);
            return [
              // start-end: 15-29 ç”¨æˆ·è¾“å…¥: inputStart-inputEnd 16-20
              mode == "subset" ? (
                // å­é›†
                start >= inputStart && start <= inputEnd || end >= inputStart && end <= inputEnd
              ) : (
                // äº¤é›†
                !(end < inputStart || inputEnd < start)
              ),
              err
            ];
          }
        }
        return [false, err];
      }
      const chatMessages$1 = ref([]);
      const chatInput = reactive({
        role: "user",
        content: "",
        input: false
      });
      const chatInputInit$1 = (model) => {
        var _a;
        chatInput.content = "";
        chatInput.input = true;
        chatInput.role = "assistant";
        chatInput.name = model.name;
        chatInput.avatar = {
          icon: llmsIcons[((_a = model.data) == null ? void 0 : _a.mode) || ""],
          color: model.color
        };
        let end = false;
        return {
          handle: (s2) => {
            chatInput.content += s2;
          },
          end: (s2) => {
            if (end) return;
            end = true;
            chatInput.input = false;
            chatInput.content = s2;
            const d2 = /* @__PURE__ */ new Date();
            chatMessages$1.value.push({
              id: d2.getTime(),
              role: "assistant",
              content: s2,
              date: [getCurDay(d2), getCurTime(d2)],
              name: chatInput.name,
              avatar: toRaw(chatInput.avatar)
            });
            chatInput.content = "";
          }
        };
      };
      const useChat = () => {
        return {
          chatMessages: chatMessages$1,
          chatInput,
          chatInputInit: chatInputInit$1
        };
      };
      const { chatInputInit, chatMessages } = useChat();
      const { modelData, getGpt } = useModel();
      const { formData: formData$2 } = useConfFormData();
      const { todayData: todayData$1 } = useStatistics();
      const jobTitle = (h2) => h2.push(async ({ data: data2 }, ctx) => {
        try {
          const text = data2.jobName;
          if (!text) throw new JobTitleError("å²—ä½åä¸ºç©º");
          for (const x2 of formData$2.jobTitle.value) {
            if (text.includes(x2)) {
              if (formData$2.jobTitle.include) {
                return;
              }
              throw new JobTitleError(`å²—ä½åå«æœ‰æŽ’é™¤å…³é”®è¯ [${x2}]`);
            }
          }
          if (formData$2.jobTitle.include) {
            throw new JobTitleError("å²—ä½åä¸åŒ…å«å…³é”®è¯");
          }
        } catch (e) {
          todayData$1.jobTitle++;
          throw new JobTitleError(e.message);
        }
      });
      const goldHunterFilter = (h2) => h2.push(async ({ data: data2 }, ctx) => {
        if ((data2 == null ? void 0 : data2.goldHunter) === 1) {
          todayData$1.goldHunterFilter++;
          throw new GoldHunterError("çŒŽå¤´è¿‡æ»¤");
        }
      });
      const company = (h2) => h2.push(async ({ data: data2 }, ctx) => {
        try {
          const text = data2.brandName;
          if (!text) throw new CompanyNameError("å…¬å¸åä¸ºç©º");
          for (const x2 of formData$2.company.value) {
            if (text.includes(x2)) {
              if (formData$2.company.include) {
                return;
              }
              throw new CompanyNameError(`å…¬å¸åå«æœ‰æŽ’é™¤å…³é”®è¯ [${x2}]`);
            }
          }
          if (formData$2.company.include) {
            throw new CompanyNameError("å…¬å¸åä¸åŒ…å«å…³é”®è¯");
          }
        } catch (e) {
          todayData$1.company++;
          throw new CompanyNameError(e.message);
        }
      });
      const salaryRange = (h2) => h2.push(async ({ data: data2 }, ctx) => {
        try {
          const text = data2.salaryDesc;
          const [v2, err] = rangeMatch(
            text,
            formData$2.salaryRange.value,
            "intersection"
          );
          if (!v2)
            throw new SalaryError(
              `ä¸åŒ¹é…çš„è–ªèµ„èŒƒå›´ [${err}],é¢„æœŸ: ${formData$2.salaryRange.value}`
            );
        } catch (e) {
          todayData$1.salaryRange++;
          throw new SalaryError(e.message);
        }
      });
      const companySizeRange = (h2) => h2.push(async ({ data: data2 }, ctx) => {
        try {
          const text = data2.brandScaleName;
          const [v2, err] = rangeMatch(text, formData$2.companySizeRange.value);
          if (!v2)
            throw new CompanySizeError(
              `ä¸åŒ¹é…çš„å…¬å¸è§„æ¨¡ [${err}], é¢„æœŸ: ${formData$2.companySizeRange.value}`
            );
        } catch (e) {
          todayData$1.companySizeRange++;
          throw new CompanySizeError(e.message);
        }
      });
      const jobContent = (h2) => h2.push(async (_2, { card }) => {
        try {
          const content = card == null ? void 0 : card.postDescription;
          for (const x2 of formData$2.jobContent.value) {
            if (!x2) {
              continue;
            }
            let re = new RegExp(
              "(?<!(ä¸|æ— ).{0,5})" + x2 + "(?!ç³»ç»Ÿ|è½¯ä»¶|å·¥å…·|æœåŠ¡)"
            );
            if (content && re.test(content)) {
              if (formData$2.jobContent.include) {
                return;
              }
              throw new JobDescriptionError(`å·¥ä½œå†…å®¹å«æœ‰æŽ’é™¤å…³é”®è¯ [${x2}]`);
            }
          }
          if (formData$2.jobContent.include) {
            throw new JobDescriptionError("å·¥ä½œå†…å®¹ä¸­ä¸åŒ…å«å…³é”®è¯");
          }
        } catch (e) {
          todayData$1.jobContent++;
          throw new JobDescriptionError(e.message);
        }
      });
      const hrPosition = (h2) => h2.push(async (_2, { card }) => {
        try {
          const content = card == null ? void 0 : card.bossTitle;
          for (const x2 of formData$2.hrPosition.value) {
            if (!x2) {
              continue;
            }
            if (content && content.trim() === x2) {
              if (formData$2.hrPosition.include) {
                return;
              }
              throw new HrPositionError(`HrèŒä½åœ¨é»‘åå•ä¸­ ${content}`);
            }
          }
          if (formData$2.hrPosition.include) {
            throw new HrPositionError(`HrèŒä½ä¸åœ¨ç™½åå•ä¸­: ${content}`);
          }
        } catch (e) {
          todayData$1.hrPosition++;
          throw new HrPositionError(e.message);
        }
      });
      const jobFriendStatus = (h2) => h2.push(async (_2, ctx) => {
        var _a;
        const content = (_a = ctx.card) == null ? void 0 : _a.friendStatus;
        if (content && content != 0) {
          throw new FriendStatusError("å·²ç»æ˜¯å¥½å‹äº†");
        }
      });
      const aiFiltering = (h2) => {
        const model = modelData.value.find(
          (v2) => formData$2.aiFiltering.model === v2.key
        );
        if (!model) {
          throw new AIFilteringError("æ²¡æœ‰æ‰¾åˆ°AIç­›é€‰çš„æ¨¡åž‹");
        }
        const gpt4 = getGpt(model, formData$2.aiFiltering.prompt);
        h2.push(async (_2, ctx) => {
          const chatInput2 = chatInputInit(model);
          try {
            const { content, prompt } = await gpt4.message({
              data: {
                data: ctx.listData,
                boos: ctx.boosData,
                card: ctx.card
              },
              onStream: chatInput2.handle,
              onPrompt: (s2) => chatBoosMessage(ctx, s2)
            });
            ctx.aiFilteringQ = prompt;
            if (!content) {
              return;
            }
            ctx.aiFilteringAraw = content;
            const data2 = parseGptJson(content);
            ctx.aiFilteringAjson = data2 || {};
            const mg = `åˆ†æ•°${data2 == null ? void 0 : data2.rating}
æ¶ˆæžï¼š${data2 == null ? void 0 : data2.negative}
ç§¯æžï¼š${data2 == null ? void 0 : data2.positive}`;
            ctx.aiFilteringAtext = content;
            chatInput2.end(mg);
            if (!data2 || !data2.rating || data2.rating < 40) {
              throw new AIFilteringError(mg);
            }
          } catch (e) {
            todayData$1.jobContent++;
            throw new AIFilteringError(e.message);
          } finally {
            chatInput2.end("Err~");
          }
        });
      };
      const activityFilter = (h2) => h2.push(async (_2, { card }) => {
        try {
          const activeText = card == null ? void 0 : card.activeTimeDesc;
          if (!activeText || activeText.includes("æœˆ") || activeText.includes("å¹´"))
            throw new ActivityError(`ä¸æ´»è·ƒ,å½“å‰æ´»è·ƒåº¦ [${activeText}]`);
        } catch (e) {
          todayData$1.activityFilter++;
          throw new ActivityError(e.message);
        }
      });
      const customGreeting = (h2) => {
        const template = mitem.miTem.compile(formData$2.customGreeting.value);
        const uid2 = useUserId();
        if (!uid2) {
          ElMessage.error("æ²¡æœ‰èŽ·å–åˆ°uid,è¯·åˆ·æ–°é‡è¯•");
          throw new GreetError("æ²¡æœ‰èŽ·å–åˆ°uid");
        }
        h2.push(async (args, ctx) => {
          try {
            const boosData = await requestBossData(ctx.card);
            ctx.boosData = boosData;
            let msg = formData$2.customGreeting.value;
            if (formData$2.greetingVariable.value && ctx.card) {
              msg = template({ card: ctx.card });
            }
            ctx.message = msg;
            const buf = new Message({
              form_uid: uid2.toString(),
              to_uid: boosData.data.bossId.toString(),
              to_name: boosData.data.encryptBossId,
              // encryptUserId
              content: msg
            });
            buf.send();
          } catch (e) {
            throw new GreetError(e == null ? void 0 : e.message);
          }
        });
      };
      const chatBoosMessage = (ctx, msg) => {
        const d2 = /* @__PURE__ */ new Date();
        chatMessages.value.push({
          id: d2.getTime(),
          role: "boos",
          content: msg,
          date: [getCurDay(d2), getCurTime(d2)],
          name: ctx.listData.brandName,
          avatar: ctx.listData.brandLogo
        });
      };
      const aiGreeting = (h2) => {
        const model = modelData.value.find(
          (v2) => formData$2.aiGreeting.model === v2.key
        );
        if (!model) {
          ElMessage.warning("æ²¡æœ‰æ‰¾åˆ°æ‹›å‘¼è¯­çš„æ¨¡åž‹");
          return;
        }
        const gpt4 = getGpt(model, formData$2.aiGreeting.prompt);
        const uid2 = useUserId();
        if (!uid2) {
          ElMessage.error("æ²¡æœ‰èŽ·å–åˆ°uid,è¯·åˆ·æ–°é‡è¯•");
          throw new GreetError("æ²¡æœ‰èŽ·å–åˆ°uid");
        }
        h2.push(async (args, ctx) => {
          const chatInput2 = chatInputInit(model);
          try {
            const boosData = await requestBossData(ctx.card);
            const { content, prompt } = await gpt4.message({
              data: {
                data: ctx.listData,
                boos: ctx.boosData,
                card: ctx.card
              },
              onStream: chatInput2.handle,
              onPrompt: (s2) => chatBoosMessage(ctx, s2)
            });
            ctx.aiGreetingQ = prompt;
            if (!content) {
              return;
            }
            ctx.message = content;
            ctx.aiGreetingA = content;
            chatInput2.end(content);
            const buf = new Message({
              form_uid: uid2.toString(),
              to_uid: boosData.data.bossId.toString(),
              to_name: boosData.data.encryptBossId,
              // encryptUserId
              content
            });
            buf.send();
          } catch (e) {
            throw new GreetError(e == null ? void 0 : e.message);
          } finally {
            chatInput2.end("Err~");
          }
        });
      };
      const record = async (ctx) => {
        modelData.value.filter(
          (v2) => {
            var _a;
            return (_a = formData$2.record.model) == null ? void 0 : _a.includes(v2.key);
          }
        );
      };
      const { formData: formData$1 } = useConfFormData();
      function createHandle() {
        const handles = [];
        const handlesRes = [];
        const handlesAfter = [];
        if (formData$1.jobTitle.enable) jobTitle(handles);
        if (formData$1.company.enable) company(handles);
        if (formData$1.salaryRange.enable) salaryRange(handles);
        if (formData$1.companySizeRange.enable) companySizeRange(handles);
        if (formData$1.goldHunterFilter.value) goldHunterFilter(handles);
        if (formData$1.friendStatus.value) jobFriendStatus(handlesRes);
        if (formData$1.jobContent.enable) jobContent(handlesRes);
        if (formData$1.hrPosition.enable) hrPosition(handlesRes);
        if (formData$1.activityFilter.value) activityFilter(handlesRes);
        if (formData$1.aiFiltering.enable) aiFiltering(handlesRes);
        if (formData$1.aiGreeting.enable) {
          aiGreeting(handlesAfter);
        } else if (formData$1.customGreeting.enable) {
          customGreeting(handlesAfter);
        }
        return {
          before: async (args, ctx) => {
            try {
              await Promise.all(handles.map((handle) => handle(args, ctx)));
              if (handlesRes.length > 0) {
                const cardResp = await requestCard({
                  lid: args.data.lid,
                  securityId: args.data.securityId
                });
                if (cardResp.data.code == 0) {
                  ctx.card = cardResp.data.zpData.jobCard;
                  await Promise.all(handlesRes.map((handle) => handle(args, ctx)));
                } else {
                  throw new UnknownError("è¯·æ±‚å“åº”é”™è¯¯:" + cardResp.data.message);
                }
              }
            } catch (e) {
              if (errMap.has(e.name)) {
                throw e;
              }
              throw new UnknownError("é¢„æœŸå¤–:" + e.message);
            }
          },
          after: async (args, ctx) => {
            if (handlesAfter.length === 0) return;
            try {
              if (!ctx.card) {
                const cardResp = await requestCard({
                  lid: args.data.lid,
                  securityId: args.data.securityId
                });
                if (cardResp.data.code == 0) {
                  ctx.card = cardResp.data.zpData.jobCard;
                } else {
                  throw new UnknownError("è¯·æ±‚å“åº”é”™è¯¯:" + cardResp.data.message);
                }
              }
              await Promise.all(handlesAfter.map((handle) => handle(args, ctx)));
            } catch (e) {
              if (errMap.has(e.name)) {
                throw e;
              }
              throw new UnknownError("é¢„æœŸå¤–:" + e.message);
            }
          },
          record: (ctx) => {
            if (formData$1.record.enable) return record();
            return Promise.resolve();
          }
        };
      }
      const total = ref(0);
      const current = ref(0);
      const log = useLog();
      const { todayData } = useStatistics();
      const { deliverStop } = useCommon();
      const { formData } = useConfFormData();
      async function jobListHandle(jobList2, jobMap2) {
        var _a;
        log.info("èŽ·å–å²—ä½", `æœ¬æ¬¡èŽ·å–åˆ° ${jobList2.length} ä¸ª`);
        total.value = jobList2.length;
        const h2 = createHandle();
        jobList2.forEach((v2) => {
          if (!jobMap2.has(v2.encryptJobId))
            jobMap2.set(v2.encryptJobId, {
              state: "wait",
              msg: "ç­‰å¾…ä¸­"
            });
        });
        for (const [index, data2] of jobList2.entries()) {
          current.value = index;
          if (deliverStop.value) {
            log.info("æš‚åœæŠ•é€’", `å‰©ä½™ ${jobList2.length - index} ä¸ªæœªå¤„ç†`);
            return;
          }
          if (((_a = jobMap2.get(data2.encryptJobId)) == null ? void 0 : _a.state) !== "wait") continue;
          try {
            jobMap2.set(data2.encryptJobId, {
              state: "running",
              msg: "å¤„ç†ä¸­"
            });
            const ctx = { listData: JSON.parse(JSON.stringify(data2)) };
            try {
              await h2.before({ data: data2 }, ctx);
              await sendPublishReq(data2);
              await h2.after({ data: data2 }, ctx);
              log.add(data2.jobName, null, ctx, ctx.message);
              todayData.success++;
              jobMap2.set(data2.encryptJobId, {
                state: "success",
                msg: "æŠ•é€’æˆåŠŸ"
              });
              logger.warn("æˆåŠŸ", ctx);
              ctx.state = "æˆåŠŸ";
              if (todayData.success >= formData.deliveryLimit.value) {
                if (formData.notification.value) {
                  notification(`æŠ•é€’åˆ°è¾¾ä¸Šé™ ${formData.deliveryLimit.value}ï¼Œå·²æš‚åœæŠ•é€’`);
                } else {
                  ElMessage.info(`æŠ•é€’åˆ°è¾¾ä¸Šé™ ${formData.deliveryLimit.value}ï¼Œå·²æš‚åœæŠ•é€’`);
                }
                deliverStop.value = true;
                return;
              }
            } catch (e) {
              jobMap2.set(data2.encryptJobId, {
                state: e.state === "warning" ? "warn" : "error",
                msg: e.name || "æ²¡æœ‰æ¶ˆæ¯"
              });
              log.add(data2.jobName, e, ctx);
              logger.warn("è¿‡æ»¤", ctx);
              ctx.state = "è¿‡æ»¤";
              ctx.err = e.message || "";
            } finally {
              await h2.record(ctx);
            }
          } catch (e) {
            jobMap2.set(data2.encryptJobId, {
              state: "error",
              msg: "æœªçŸ¥æŠ¥é”™"
            });
            logger.error("æœªçŸ¥æŠ¥é”™", e, data2);
            if (formData.notification.value) {
              notification("æœªçŸ¥æŠ¥é”™");
            }
          } finally {
            todayData.total++;
            await delay(formData.delay.deliveryInterval);
          }
        }
      }
      const useDeliver = () => {
        return {
          createHandle,
          jobListHandle,
          total,
          current
        };
      };
      const _hoisted_1$e = { style: { "order": "-1" } };
      const _hoisted_2$a = { class: "card-tag" };
      const _hoisted_3$4 = { class: "card-title" };
      const _hoisted_4$3 = { class: "card-salary" };
      const _hoisted_5$2 = { class: "card-footer" };
      const _hoisted_6$2 = { class: "author-row" };
      const _hoisted_7$1 = ["src"];
      const _hoisted_8$1 = { class: "company-name" };
      const _hoisted_9 = { class: "card-status" };
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        __name: "card",
        setup(__props) {
          const {
            jobList: jobList2,
            jobMap: { actions: jobMap2 }
          } = useJobList();
          const { current: current2 } = useDeliver();
          const jobListRef = ref();
          const autoScroll = ref(true);
          const cards = ref();
          function scroll3(e) {
            e.preventDefault();
            if (!cards.value) {
              return;
            }
            let left = -e.wheelDelta || e.deltaY / 2;
            cards.value.scrollLeft = cards.value.scrollLeft + left;
            autoScroll.value = false;
          }
          watchEffect(() => {
            const d2 = jobListRef.value;
            if (autoScroll.value && d2 && d2.length > current2.value) {
              d2[current2.value].scrollIntoView({
                behavior: "smooth",
                block: "nearest",
                inline: "center"
              });
            }
          });
          function stateColor(state) {
            switch (state) {
              case "wait":
                return "#CECECE";
              case "error":
                return "#e74c3c";
              case "warn":
                return "#f39c12";
              case "success":
                return "#2ecc71";
              case "running":
                return "#98F5F9";
            }
            return "#CECECE";
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", _hoisted_1$e, [
              createElementVNode("div", {
                ref_key: "cards",
                ref: cards,
                onWheel: withModifiers(scroll3, ["stop"]),
                class: "card-grid"
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(jobList2), (v2) => {
                  var _a, _b;
                  return openBlock(), createElementBlock("div", {
                    ref_for: true,
                    ref_key: "jobListRef",
                    ref: jobListRef,
                    class: "card",
                    style: normalizeStyle({
                      "--state-color": stateColor((_a = unref(jobMap2).get(v2.encryptJobId)) == null ? void 0 : _a.state),
                      "--state-show": unref(jobMap2).has(v2.encryptJobId) ? "block" : "none"
                    })
                  }, [
                    createElementVNode("div", _hoisted_2$a, toDisplayString(v2.brandIndustry) + "," + toDisplayString(v2.jobDegree) + "," + toDisplayString(v2.brandScaleName), 1),
                    createElementVNode("h3", _hoisted_3$4, toDisplayString(v2.jobName), 1),
                    createElementVNode("h3", _hoisted_4$3, toDisplayString(v2.salaryDesc), 1),
                    createElementVNode("div", null, [
                      createVNode(unref(ElSpace$1), {
                        size: 3,
                        spacer: "|",
                        wrap: ""
                      }, {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(v2.skills, (tag) => {
                            return openBlock(), createBlock(unref(ElTag$1), {
                              size: "small",
                              effect: "plain",
                              type: "warning"
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(tag), 1)
                              ]),
                              _: 2
                            }, 1024);
                          }), 256))
                        ]),
                        _: 2
                      }, 1024),
                      createVNode(unref(ElSpace$1), {
                        size: 3,
                        wrap: ""
                      }, {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(v2.jobLabels, (tag) => {
                            return openBlock(), createBlock(unref(ElTag$1), {
                              size: "small",
                              effect: "plain",
                              type: "success"
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(tag), 1)
                              ]),
                              _: 2
                            }, 1024);
                          }), 256))
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    createElementVNode("div", _hoisted_5$2, toDisplayString(v2.welfareList.join(",")), 1),
                    createElementVNode("div", _hoisted_6$2, [
                      createElementVNode("img", {
                        alt: "",
                        class: "avatar",
                        height: "80",
                        src: v2.brandLogo,
                        width: "80"
                      }, null, 8, _hoisted_7$1),
                      createElementVNode("div", null, [
                        createElementVNode("span", _hoisted_8$1, toDisplayString(v2.brandName), 1),
                        createElementVNode("h4", null, toDisplayString(v2.cityName) + "/" + toDisplayString(v2.areaDistrict) + "/" + toDisplayString(v2.businessDistrict), 1)
                      ])
                    ]),
                    createElementVNode("div", _hoisted_9, toDisplayString(((_b = unref(jobMap2).get(v2.encryptJobId)) == null ? void 0 : _b.msg) || "æ— å†…å®¹"), 1)
                  ], 4);
                }), 256))
              ], 544),
              createVNode(unref(ElSwitch), {
                modelValue: autoScroll.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => autoScroll.value = $event),
                "inline-prompt": "",
                "active-text": "è‡ªåŠ¨æ»šåŠ¨",
                "inactive-text": "è‡ªåŠ¨æ»šåŠ¨"
              }, null, 8, ["modelValue"])
            ]);
          };
        }
      });
      const _export_sfc = (sfc, props2) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props2) {
          target[key] = val;
        }
        return target;
      };
      const cardVue = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-d2ec6d12"]]);
      function getInternetExplorerVersion() {
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf("MSIE ");
        if (msie > 0) {
          return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
        }
        var trident = ua.indexOf("Trident/");
        if (trident > 0) {
          var rv = ua.indexOf("rv:");
          return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
        }
        var edge = ua.indexOf("Edge/");
        if (edge > 0) {
          return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
        }
        return -1;
      }
      let isIE;
      function initCompat() {
        if (!initCompat.init) {
          initCompat.init = true;
          isIE = getInternetExplorerVersion() !== -1;
        }
      }
      var script$3 = {
        name: "ResizeObserver",
        props: {
          emitOnMount: {
            type: Boolean,
            default: false
          },
          ignoreWidth: {
            type: Boolean,
            default: false
          },
          ignoreHeight: {
            type: Boolean,
            default: false
          }
        },
        emits: [
          "notify"
        ],
        mounted() {
          initCompat();
          nextTick(() => {
            this._w = this.$el.offsetWidth;
            this._h = this.$el.offsetHeight;
            if (this.emitOnMount) {
              this.emitSize();
            }
          });
          const object4 = document.createElement("object");
          this._resizeObject = object4;
          object4.setAttribute("aria-hidden", "true");
          object4.setAttribute("tabindex", -1);
          object4.onload = this.addResizeHandlers;
          object4.type = "text/html";
          if (isIE) {
            this.$el.appendChild(object4);
          }
          object4.data = "about:blank";
          if (!isIE) {
            this.$el.appendChild(object4);
          }
        },
        beforeUnmount() {
          this.removeResizeHandlers();
        },
        methods: {
          compareAndNotify() {
            if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
              this._w = this.$el.offsetWidth;
              this._h = this.$el.offsetHeight;
              this.emitSize();
            }
          },
          emitSize() {
            this.$emit("notify", {
              width: this._w,
              height: this._h
            });
          },
          addResizeHandlers() {
            this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
            this.compareAndNotify();
          },
          removeResizeHandlers() {
            if (this._resizeObject && this._resizeObject.onload) {
              if (!isIE && this._resizeObject.contentDocument) {
                this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
              }
              this.$el.removeChild(this._resizeObject);
              this._resizeObject.onload = null;
              this._resizeObject = null;
            }
          }
        }
      };
      const _withId = /* @__PURE__ */ withScopeId("data-v-b329ee4c");
      pushScopeId("data-v-b329ee4c");
      const _hoisted_1$d = {
        class: "resize-observer",
        tabindex: "-1"
      };
      popScopeId();
      const render$2 = /* @__PURE__ */ _withId((_ctx, _cache, $props, $setup, $data, $options) => {
        return openBlock(), createBlock("div", _hoisted_1$d);
      });
      script$3.render = render$2;
      script$3.__scopeId = "data-v-b329ee4c";
      script$3.__file = "src/components/ResizeObserver.vue";
      function _typeof$1(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$1 = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$1 = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$1(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props2) {
        for (var i = 0; i < props2.length; i++) {
          var descriptor = props2[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        return Constructor;
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
      }
      function _unsupportedIterableToArray(o2, minLen) {
        if (!o2) return;
        if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
        var n = Object.prototype.toString.call(o2).slice(8, -1);
        if (n === "Object" && o2.constructor) n = o2.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o2);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o2, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function processOptions(value) {
        var options2;
        if (typeof value === "function") {
          options2 = {
            callback: value
          };
        } else {
          options2 = value;
        }
        return options2;
      }
      function throttle(callback, delay2) {
        var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var timeout;
        var lastState;
        var currentArgs;
        var throttled = function throttled2(state) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          currentArgs = args;
          if (timeout && state === lastState) return;
          var leading = options2.leading;
          if (typeof leading === "function") {
            leading = leading(state, lastState);
          }
          if ((!timeout || state !== lastState) && leading) {
            callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));
          }
          lastState = state;
          clearTimeout(timeout);
          timeout = setTimeout(function() {
            callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));
            timeout = 0;
          }, delay2);
        };
        throttled._clear = function() {
          clearTimeout(timeout);
          timeout = null;
        };
        return throttled;
      }
      function deepEqual(val1, val2) {
        if (val1 === val2) return true;
        if (_typeof$1(val1) === "object") {
          for (var key in val1) {
            if (!deepEqual(val1[key], val2[key])) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      var VisibilityState = /* @__PURE__ */ function() {
        function VisibilityState2(el, options2, vnode) {
          _classCallCheck(this, VisibilityState2);
          this.el = el;
          this.observer = null;
          this.frozen = false;
          this.createObserver(options2, vnode);
        }
        _createClass(VisibilityState2, [{
          key: "createObserver",
          value: function createObserver(options2, vnode) {
            var _this = this;
            if (this.observer) {
              this.destroyObserver();
            }
            if (this.frozen) return;
            this.options = processOptions(options2);
            this.callback = function(result, entry) {
              _this.options.callback(result, entry);
              if (result && _this.options.once) {
                _this.frozen = true;
                _this.destroyObserver();
              }
            };
            if (this.callback && this.options.throttle) {
              var _ref = this.options.throttleOptions || {}, _leading = _ref.leading;
              this.callback = throttle(this.callback, this.options.throttle, {
                leading: function leading(state) {
                  return _leading === "both" || _leading === "visible" && state || _leading === "hidden" && !state;
                }
              });
            }
            this.oldResult = void 0;
            this.observer = new IntersectionObserver(function(entries) {
              var entry = entries[0];
              if (entries.length > 1) {
                var intersectingEntry = entries.find(function(e) {
                  return e.isIntersecting;
                });
                if (intersectingEntry) {
                  entry = intersectingEntry;
                }
              }
              if (_this.callback) {
                var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;
                if (result === _this.oldResult) return;
                _this.oldResult = result;
                _this.callback(result, entry);
              }
            }, this.options.intersection);
            nextTick(function() {
              if (_this.observer) {
                _this.observer.observe(_this.el);
              }
            });
          }
        }, {
          key: "destroyObserver",
          value: function destroyObserver() {
            if (this.observer) {
              this.observer.disconnect();
              this.observer = null;
            }
            if (this.callback && this.callback._clear) {
              this.callback._clear();
              this.callback = null;
            }
          }
        }, {
          key: "threshold",
          get: function get2() {
            return this.options.intersection && typeof this.options.intersection.threshold === "number" ? this.options.intersection.threshold : 0;
          }
        }]);
        return VisibilityState2;
      }();
      function beforeMount(el, _ref2, vnode) {
        var value = _ref2.value;
        if (!value) return;
        if (typeof IntersectionObserver === "undefined") {
          console.warn("[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill");
        } else {
          var state = new VisibilityState(el, value, vnode);
          el._vue_visibilityState = state;
        }
      }
      function updated(el, _ref3, vnode) {
        var value = _ref3.value, oldValue = _ref3.oldValue;
        if (deepEqual(value, oldValue)) return;
        var state = el._vue_visibilityState;
        if (!value) {
          unmounted(el);
          return;
        }
        if (state) {
          state.createObserver(value, vnode);
        } else {
          beforeMount(el, {
            value
          }, vnode);
        }
      }
      function unmounted(el) {
        var state = el._vue_visibilityState;
        if (state) {
          state.destroyObserver();
          delete el._vue_visibilityState;
        }
      }
      var ObserveVisibility = {
        beforeMount,
        updated,
        unmounted
      };
      function mitt(n) {
        return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
          var i = n.get(t);
          i && i.push(e) || n.set(t, [e]);
        }, off: function(t, e) {
          var i = n.get(t);
          i && i.splice(i.indexOf(e) >>> 0, 1);
        }, emit: function(t, e) {
          (n.get(t) || []).slice().map(function(n2) {
            n2(e);
          }), (n.get("*") || []).slice().map(function(n2) {
            n2(t, e);
          });
        } };
      }
      var config = {
        itemsLimit: 1e3
      };
      var regex = /(auto|scroll)/;
      function parents(node, ps) {
        if (node.parentNode === null) {
          return ps;
        }
        return parents(node.parentNode, ps.concat([node]));
      }
      var style = function style2(node, prop) {
        return getComputedStyle(node, null).getPropertyValue(prop);
      };
      var overflow = function overflow2(node) {
        return style(node, "overflow") + style(node, "overflow-y") + style(node, "overflow-x");
      };
      var scroll = function scroll2(node) {
        return regex.test(overflow(node));
      };
      function getScrollParent(node) {
        if (!(node instanceof HTMLElement || node instanceof SVGElement)) {
          return;
        }
        var ps = parents(node.parentNode, []);
        for (var i = 0; i < ps.length; i += 1) {
          if (scroll(ps[i])) {
            return ps[i];
          }
        }
        return document.scrollingElement || document.documentElement;
      }
      function _typeof(obj) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof(obj);
      }
      var props = {
        items: {
          type: Array,
          required: true
        },
        keyField: {
          type: String,
          default: "id"
        },
        direction: {
          type: String,
          default: "vertical",
          validator: function validator(value) {
            return ["vertical", "horizontal"].includes(value);
          }
        },
        listTag: {
          type: String,
          default: "div"
        },
        itemTag: {
          type: String,
          default: "div"
        }
      };
      function simpleArray() {
        return this.items.length && _typeof(this.items[0]) !== "object";
      }
      var supportsPassive = false;
      if (typeof window !== "undefined") {
        supportsPassive = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function get2() {
              supportsPassive = true;
            }
          });
          window.addEventListener("test", null, opts);
        } catch (e) {
        }
      }
      let uid = 0;
      var script$2 = {
        name: "RecycleScroller",
        components: {
          ResizeObserver: script$3
        },
        directives: {
          ObserveVisibility
        },
        props: {
          ...props,
          itemSize: {
            type: Number,
            default: null
          },
          gridItems: {
            type: Number,
            default: void 0
          },
          itemSecondarySize: {
            type: Number,
            default: void 0
          },
          minItemSize: {
            type: [Number, String],
            default: null
          },
          sizeField: {
            type: String,
            default: "size"
          },
          typeField: {
            type: String,
            default: "type"
          },
          buffer: {
            type: Number,
            default: 200
          },
          pageMode: {
            type: Boolean,
            default: false
          },
          prerender: {
            type: Number,
            default: 0
          },
          emitUpdate: {
            type: Boolean,
            default: false
          },
          updateInterval: {
            type: Number,
            default: 0
          },
          skipHover: {
            type: Boolean,
            default: false
          },
          listTag: {
            type: String,
            default: "div"
          },
          itemTag: {
            type: String,
            default: "div"
          },
          listClass: {
            type: [String, Object, Array],
            default: ""
          },
          itemClass: {
            type: [String, Object, Array],
            default: ""
          }
        },
        emits: [
          "resize",
          "visible",
          "hidden",
          "update",
          "scroll-start",
          "scroll-end"
        ],
        data() {
          return {
            pool: [],
            totalSize: 0,
            ready: false,
            hoverKey: null
          };
        },
        computed: {
          sizes() {
            if (this.itemSize === null) {
              const sizes = {
                "-1": { accumulator: 0 }
              };
              const items = this.items;
              const field = this.sizeField;
              const minItemSize = this.minItemSize;
              let computedMinSize = 1e4;
              let accumulator = 0;
              let current2;
              for (let i = 0, l2 = items.length; i < l2; i++) {
                current2 = items[i][field] || minItemSize;
                if (current2 < computedMinSize) {
                  computedMinSize = current2;
                }
                accumulator += current2;
                sizes[i] = { accumulator, size: current2 };
              }
              this.$_computedMinItemSize = computedMinSize;
              return sizes;
            }
            return [];
          },
          simpleArray,
          itemIndexByKey() {
            const { keyField, items } = this;
            const result = {};
            for (let i = 0, l2 = items.length; i < l2; i++) {
              result[items[i][keyField]] = i;
            }
            return result;
          }
        },
        watch: {
          items() {
            this.updateVisibleItems(true);
          },
          pageMode() {
            this.applyPageMode();
            this.updateVisibleItems(false);
          },
          sizes: {
            handler() {
              this.updateVisibleItems(false);
            },
            deep: true
          },
          gridItems() {
            this.updateVisibleItems(true);
          },
          itemSecondarySize() {
            this.updateVisibleItems(true);
          }
        },
        created() {
          this.$_startIndex = 0;
          this.$_endIndex = 0;
          this.$_views = /* @__PURE__ */ new Map();
          this.$_unusedViews = /* @__PURE__ */ new Map();
          this.$_scrollDirty = false;
          this.$_lastUpdateScrollPosition = 0;
          if (this.prerender) {
            this.$_prerender = true;
            this.updateVisibleItems(false);
          }
          if (this.gridItems && !this.itemSize) {
            console.error("[vue-recycle-scroller] You must provide an itemSize when using gridItems");
          }
        },
        mounted() {
          this.applyPageMode();
          this.$nextTick(() => {
            this.$_prerender = false;
            this.updateVisibleItems(true);
            this.ready = true;
          });
        },
        activated() {
          const lastPosition = this.$_lastUpdateScrollPosition;
          if (typeof lastPosition === "number") {
            this.$nextTick(() => {
              this.scrollToPosition(lastPosition);
            });
          }
        },
        beforeUnmount() {
          this.removeListeners();
        },
        methods: {
          addView(pool, index, item, key, type4) {
            const nr = markRaw({
              id: uid++,
              index,
              used: true,
              key,
              type: type4
            });
            const view = shallowReactive({
              item,
              position: 0,
              nr
            });
            pool.push(view);
            return view;
          },
          unuseView(view, fake = false) {
            const unusedViews = this.$_unusedViews;
            const type4 = view.nr.type;
            let unusedPool = unusedViews.get(type4);
            if (!unusedPool) {
              unusedPool = [];
              unusedViews.set(type4, unusedPool);
            }
            unusedPool.push(view);
            if (!fake) {
              view.nr.used = false;
              view.position = -9999;
            }
          },
          handleResize() {
            this.$emit("resize");
            if (this.ready) this.updateVisibleItems(false);
          },
          handleScroll(event) {
            if (!this.$_scrollDirty) {
              this.$_scrollDirty = true;
              if (this.$_updateTimeout) return;
              const requestUpdate = () => requestAnimationFrame(() => {
                this.$_scrollDirty = false;
                const { continuous } = this.updateVisibleItems(false, true);
                if (!continuous) {
                  clearTimeout(this.$_refreshTimout);
                  this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100);
                }
              });
              requestUpdate();
              if (this.updateInterval) {
                this.$_updateTimeout = setTimeout(() => {
                  this.$_updateTimeout = 0;
                  if (this.$_scrollDirty) requestUpdate();
                }, this.updateInterval);
              }
            }
          },
          handleVisibilityChange(isVisible, entry) {
            if (this.ready) {
              if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {
                this.$emit("visible");
                requestAnimationFrame(() => {
                  this.updateVisibleItems(false);
                });
              } else {
                this.$emit("hidden");
              }
            }
          },
          updateVisibleItems(checkItem, checkPositionDiff = false) {
            const itemSize = this.itemSize;
            const gridItems = this.gridItems || 1;
            const itemSecondarySize = this.itemSecondarySize || itemSize;
            const minItemSize = this.$_computedMinItemSize;
            const typeField = this.typeField;
            const keyField = this.simpleArray ? null : this.keyField;
            const items = this.items;
            const count = items.length;
            const sizes = this.sizes;
            const views = this.$_views;
            const unusedViews = this.$_unusedViews;
            const pool = this.pool;
            const itemIndexByKey = this.itemIndexByKey;
            let startIndex, endIndex;
            let totalSize;
            let visibleStartIndex, visibleEndIndex;
            if (!count) {
              startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0;
            } else if (this.$_prerender) {
              startIndex = visibleStartIndex = 0;
              endIndex = visibleEndIndex = Math.min(this.prerender, items.length);
              totalSize = null;
            } else {
              const scroll3 = this.getScroll();
              if (checkPositionDiff) {
                let positionDiff = scroll3.start - this.$_lastUpdateScrollPosition;
                if (positionDiff < 0) positionDiff = -positionDiff;
                if (itemSize === null && positionDiff < minItemSize || positionDiff < itemSize) {
                  return {
                    continuous: true
                  };
                }
              }
              this.$_lastUpdateScrollPosition = scroll3.start;
              const buffer = this.buffer;
              scroll3.start -= buffer;
              scroll3.end += buffer;
              let beforeSize = 0;
              if (this.$refs.before) {
                beforeSize = this.$refs.before.scrollHeight;
                scroll3.start -= beforeSize;
              }
              if (this.$refs.after) {
                const afterSize = this.$refs.after.scrollHeight;
                scroll3.end += afterSize;
              }
              if (itemSize === null) {
                let h2;
                let a2 = 0;
                let b2 = count - 1;
                let i = ~~(count / 2);
                let oldI;
                do {
                  oldI = i;
                  h2 = sizes[i].accumulator;
                  if (h2 < scroll3.start) {
                    a2 = i;
                  } else if (i < count - 1 && sizes[i + 1].accumulator > scroll3.start) {
                    b2 = i;
                  }
                  i = ~~((a2 + b2) / 2);
                } while (i !== oldI);
                i < 0 && (i = 0);
                startIndex = i;
                totalSize = sizes[count - 1].accumulator;
                for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll3.end; endIndex++) ;
                if (endIndex === -1) {
                  endIndex = items.length - 1;
                } else {
                  endIndex++;
                  endIndex > count && (endIndex = count);
                }
                for (visibleStartIndex = startIndex; visibleStartIndex < count && beforeSize + sizes[visibleStartIndex].accumulator < scroll3.start; visibleStartIndex++) ;
                for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && beforeSize + sizes[visibleEndIndex].accumulator < scroll3.end; visibleEndIndex++) ;
              } else {
                startIndex = ~~(scroll3.start / itemSize * gridItems);
                const remainer = startIndex % gridItems;
                startIndex -= remainer;
                endIndex = Math.ceil(scroll3.end / itemSize * gridItems);
                visibleStartIndex = Math.max(0, Math.floor((scroll3.start - beforeSize) / itemSize * gridItems));
                visibleEndIndex = Math.floor((scroll3.end - beforeSize) / itemSize * gridItems);
                startIndex < 0 && (startIndex = 0);
                endIndex > count && (endIndex = count);
                visibleStartIndex < 0 && (visibleStartIndex = 0);
                visibleEndIndex > count && (visibleEndIndex = count);
                totalSize = Math.ceil(count / gridItems) * itemSize;
              }
            }
            if (endIndex - startIndex > config.itemsLimit) {
              this.itemsLimitError();
            }
            this.totalSize = totalSize;
            let view;
            const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex;
            if (continuous) {
              for (let i = 0, l2 = pool.length; i < l2; i++) {
                view = pool[i];
                if (view.nr.used) {
                  if (checkItem) {
                    view.nr.index = itemIndexByKey[view.item[keyField]];
                  }
                  if (view.nr.index == null || view.nr.index < startIndex || view.nr.index >= endIndex) {
                    this.unuseView(view);
                  }
                }
              }
            }
            const unusedIndex = continuous ? null : /* @__PURE__ */ new Map();
            let item, type4;
            let v2;
            for (let i = startIndex; i < endIndex; i++) {
              item = items[i];
              const key = keyField ? item[keyField] : item;
              if (key == null) {
                throw new Error(`Key is ${key} on item (keyField is '${keyField}')`);
              }
              view = views.get(key);
              if (!itemSize && !sizes[i].size) {
                if (view) this.unuseView(view);
                continue;
              }
              type4 = item[typeField];
              let unusedPool = unusedViews.get(type4);
              let newlyUsedView = false;
              if (!view) {
                if (continuous) {
                  if (unusedPool && unusedPool.length) {
                    view = unusedPool.pop();
                  } else {
                    view = this.addView(pool, i, item, key, type4);
                  }
                } else {
                  v2 = unusedIndex.get(type4) || 0;
                  if (!unusedPool || v2 >= unusedPool.length) {
                    view = this.addView(pool, i, item, key, type4);
                    this.unuseView(view, true);
                    unusedPool = unusedViews.get(type4);
                  }
                  view = unusedPool[v2];
                  unusedIndex.set(type4, v2 + 1);
                }
                views.delete(view.nr.key);
                view.nr.used = true;
                view.nr.index = i;
                view.nr.key = key;
                view.nr.type = type4;
                views.set(key, view);
                newlyUsedView = true;
              } else {
                if (!view.nr.used) {
                  view.nr.used = true;
                  newlyUsedView = true;
                  if (unusedPool) {
                    const index = unusedPool.indexOf(view);
                    if (index !== -1) unusedPool.splice(index, 1);
                  }
                }
              }
              view.item = item;
              if (newlyUsedView) {
                if (i === items.length - 1) this.$emit("scroll-end");
                if (i === 0) this.$emit("scroll-start");
              }
              if (itemSize === null) {
                view.position = sizes[i - 1].accumulator;
                view.offset = 0;
              } else {
                view.position = Math.floor(i / gridItems) * itemSize;
                view.offset = i % gridItems * itemSecondarySize;
              }
            }
            this.$_startIndex = startIndex;
            this.$_endIndex = endIndex;
            if (this.emitUpdate) this.$emit("update", startIndex, endIndex, visibleStartIndex, visibleEndIndex);
            clearTimeout(this.$_sortTimer);
            this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300);
            return {
              continuous
            };
          },
          getListenerTarget() {
            let target = getScrollParent(this.$el);
            if (window.document && (target === window.document.documentElement || target === window.document.body)) {
              target = window;
            }
            return target;
          },
          getScroll() {
            const { $el: el, direction } = this;
            const isVertical = direction === "vertical";
            let scrollState;
            if (this.pageMode) {
              const bounds = el.getBoundingClientRect();
              const boundsSize = isVertical ? bounds.height : bounds.width;
              let start = -(isVertical ? bounds.top : bounds.left);
              let size = isVertical ? window.innerHeight : window.innerWidth;
              if (start < 0) {
                size += start;
                start = 0;
              }
              if (start + size > boundsSize) {
                size = boundsSize - start;
              }
              scrollState = {
                start,
                end: start + size
              };
            } else if (isVertical) {
              scrollState = {
                start: el.scrollTop,
                end: el.scrollTop + el.clientHeight
              };
            } else {
              scrollState = {
                start: el.scrollLeft,
                end: el.scrollLeft + el.clientWidth
              };
            }
            return scrollState;
          },
          applyPageMode() {
            if (this.pageMode) {
              this.addListeners();
            } else {
              this.removeListeners();
            }
          },
          addListeners() {
            this.listenerTarget = this.getListenerTarget();
            this.listenerTarget.addEventListener("scroll", this.handleScroll, supportsPassive ? {
              passive: true
            } : false);
            this.listenerTarget.addEventListener("resize", this.handleResize);
          },
          removeListeners() {
            if (!this.listenerTarget) {
              return;
            }
            this.listenerTarget.removeEventListener("scroll", this.handleScroll);
            this.listenerTarget.removeEventListener("resize", this.handleResize);
            this.listenerTarget = null;
          },
          scrollToItem(index) {
            let scroll3;
            const gridItems = this.gridItems || 1;
            if (this.itemSize === null) {
              scroll3 = index > 0 ? this.sizes[index - 1].accumulator : 0;
            } else {
              scroll3 = Math.floor(index / gridItems) * this.itemSize;
            }
            this.scrollToPosition(scroll3);
          },
          scrollToPosition(position) {
            const direction = this.direction === "vertical" ? { scroll: "scrollTop", start: "top" } : { scroll: "scrollLeft", start: "left" };
            let viewport;
            let scrollDirection;
            let scrollDistance;
            if (this.pageMode) {
              const viewportEl = getScrollParent(this.$el);
              const scrollTop = viewportEl.tagName === "HTML" ? 0 : viewportEl[direction.scroll];
              const bounds = viewportEl.getBoundingClientRect();
              const scroller = this.$el.getBoundingClientRect();
              const scrollerPosition = scroller[direction.start] - bounds[direction.start];
              viewport = viewportEl;
              scrollDirection = direction.scroll;
              scrollDistance = position + scrollTop + scrollerPosition;
            } else {
              viewport = this.$el;
              scrollDirection = direction.scroll;
              scrollDistance = position;
            }
            viewport[scrollDirection] = scrollDistance;
          },
          itemsLimitError() {
            setTimeout(() => {
              console.log("It seems the scroller element isn't scrolling, so it tries to render all the items at once.", "Scroller:", this.$el);
              console.log("Make sure the scroller has a fixed height (or width) and 'overflow-y' (or 'overflow-x') set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.");
            });
            throw new Error("Rendered items limit reached");
          },
          sortViews() {
            this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index);
          }
        }
      };
      const _hoisted_1$c = {
        key: 0,
        ref: "before",
        class: "vue-recycle-scroller__slot"
      };
      const _hoisted_2$9 = {
        key: 1,
        ref: "after",
        class: "vue-recycle-scroller__slot"
      };
      function render$1(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_ResizeObserver = resolveComponent("ResizeObserver");
        const _directive_observe_visibility = resolveDirective("observe-visibility");
        return withDirectives((openBlock(), createElementBlock(
          "div",
          {
            class: normalizeClass(["vue-recycle-scroller", {
              ready: $data.ready,
              "page-mode": $props.pageMode,
              [`direction-${_ctx.direction}`]: true
            }]),
            onScrollPassive: _cache[0] || (_cache[0] = (...args) => $options.handleScroll && $options.handleScroll(...args))
          },
          [
            _ctx.$slots.before ? (openBlock(), createElementBlock(
              "div",
              _hoisted_1$c,
              [
                renderSlot(_ctx.$slots, "before")
              ],
              512
              /* NEED_PATCH */
            )) : createCommentVNode("v-if", true),
            (openBlock(), createBlock(resolveDynamicComponent($props.listTag), {
              ref: "wrapper",
              style: normalizeStyle({ [_ctx.direction === "vertical" ? "minHeight" : "minWidth"]: $data.totalSize + "px" }),
              class: normalizeClass(["vue-recycle-scroller__item-wrapper", $props.listClass])
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(
                  Fragment,
                  null,
                  renderList($data.pool, (view) => {
                    return openBlock(), createBlock(resolveDynamicComponent($props.itemTag), mergeProps({
                      key: view.nr.id,
                      style: $data.ready ? {
                        transform: `translate${_ctx.direction === "vertical" ? "Y" : "X"}(${view.position}px) translate${_ctx.direction === "vertical" ? "X" : "Y"}(${view.offset}px)`,
                        width: $props.gridItems ? `${_ctx.direction === "vertical" ? $props.itemSecondarySize || $props.itemSize : $props.itemSize}px` : void 0,
                        height: $props.gridItems ? `${_ctx.direction === "horizontal" ? $props.itemSecondarySize || $props.itemSize : $props.itemSize}px` : void 0
                      } : null,
                      class: ["vue-recycle-scroller__item-view", [
                        $props.itemClass,
                        {
                          hover: !$props.skipHover && $data.hoverKey === view.nr.key
                        }
                      ]]
                    }, toHandlers($props.skipHover ? {} : {
                      mouseenter: () => {
                        $data.hoverKey = view.nr.key;
                      },
                      mouseleave: () => {
                        $data.hoverKey = null;
                      }
                    })), {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "default", {
                          item: view.item,
                          index: view.nr.index,
                          active: view.nr.used
                        })
                      ]),
                      _: 2
                      /* DYNAMIC */
                    }, 1040, ["style", "class"]);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                )),
                renderSlot(_ctx.$slots, "empty")
              ]),
              _: 3
              /* FORWARDED */
            }, 8, ["style", "class"])),
            _ctx.$slots.after ? (openBlock(), createElementBlock(
              "div",
              _hoisted_2$9,
              [
                renderSlot(_ctx.$slots, "after")
              ],
              512
              /* NEED_PATCH */
            )) : createCommentVNode("v-if", true),
            createVNode(_component_ResizeObserver, { onNotify: $options.handleResize }, null, 8, ["onNotify"])
          ],
          34
          /* CLASS, HYDRATE_EVENTS */
        )), [
          [_directive_observe_visibility, $options.handleVisibilityChange]
        ]);
      }
      script$2.render = render$1;
      script$2.__file = "src/components/RecycleScroller.vue";
      var script$1 = {
        name: "DynamicScroller",
        components: {
          RecycleScroller: script$2
        },
        provide() {
          if (typeof ResizeObserver !== "undefined") {
            this.$_resizeObserver = new ResizeObserver((entries) => {
              requestAnimationFrame(() => {
                if (!Array.isArray(entries)) {
                  return;
                }
                for (const entry of entries) {
                  if (entry.target && entry.target.$_vs_onResize) {
                    let width, height;
                    if (entry.borderBoxSize) {
                      const resizeObserverSize = entry.borderBoxSize[0];
                      width = resizeObserverSize.inlineSize;
                      height = resizeObserverSize.blockSize;
                    } else {
                      width = entry.contentRect.width;
                      height = entry.contentRect.height;
                    }
                    entry.target.$_vs_onResize(entry.target.$_vs_id, width, height);
                  }
                }
              });
            });
          }
          return {
            vscrollData: this.vscrollData,
            vscrollParent: this,
            vscrollResizeObserver: this.$_resizeObserver
          };
        },
        inheritAttrs: false,
        props: {
          ...props,
          minItemSize: {
            type: [Number, String],
            required: true
          }
        },
        emits: [
          "resize",
          "visible"
        ],
        data() {
          return {
            vscrollData: {
              active: true,
              sizes: {},
              keyField: this.keyField,
              simpleArray: false
            }
          };
        },
        computed: {
          simpleArray,
          itemsWithSize() {
            const result = [];
            const { items, keyField, simpleArray: simpleArray2 } = this;
            const sizes = this.vscrollData.sizes;
            const l2 = items.length;
            for (let i = 0; i < l2; i++) {
              const item = items[i];
              const id = simpleArray2 ? i : item[keyField];
              let size = sizes[id];
              if (typeof size === "undefined" && !this.$_undefinedMap[id]) {
                size = 0;
              }
              result.push({
                item,
                id,
                size
              });
            }
            return result;
          }
        },
        watch: {
          items() {
            this.forceUpdate();
          },
          simpleArray: {
            handler(value) {
              this.vscrollData.simpleArray = value;
            },
            immediate: true
          },
          direction(value) {
            this.forceUpdate(true);
          },
          itemsWithSize(next2, prev2) {
            const scrollTop = this.$el.scrollTop;
            let prevActiveTop = 0;
            let activeTop = 0;
            const length = Math.min(next2.length, prev2.length);
            for (let i = 0; i < length; i++) {
              if (prevActiveTop >= scrollTop) {
                break;
              }
              prevActiveTop += prev2[i].size || this.minItemSize;
              activeTop += next2[i].size || this.minItemSize;
            }
            const offset = activeTop - prevActiveTop;
            if (offset === 0) {
              return;
            }
            this.$el.scrollTop += offset;
          }
        },
        beforeCreate() {
          this.$_updates = [];
          this.$_undefinedSizes = 0;
          this.$_undefinedMap = {};
          this.$_events = mitt();
        },
        activated() {
          this.vscrollData.active = true;
        },
        deactivated() {
          this.vscrollData.active = false;
        },
        unmounted() {
          this.$_events.all.clear();
        },
        methods: {
          onScrollerResize() {
            const scroller = this.$refs.scroller;
            if (scroller) {
              this.forceUpdate();
            }
            this.$emit("resize");
          },
          onScrollerVisible() {
            this.$_events.emit("vscroll:update", { force: false });
            this.$emit("visible");
          },
          forceUpdate(clear = false) {
            if (clear || this.simpleArray) {
              this.vscrollData.sizes = {};
            }
            this.$_events.emit("vscroll:update", { force: true });
          },
          scrollToItem(index) {
            const scroller = this.$refs.scroller;
            if (scroller) scroller.scrollToItem(index);
          },
          getItemSize(item, index = void 0) {
            const id = this.simpleArray ? index != null ? index : this.items.indexOf(item) : item[this.keyField];
            return this.vscrollData.sizes[id] || 0;
          },
          scrollToBottom() {
            if (this.$_scrollingToBottom) return;
            this.$_scrollingToBottom = true;
            const el = this.$el;
            this.$nextTick(() => {
              el.scrollTop = el.scrollHeight + 5e3;
              const cb = () => {
                el.scrollTop = el.scrollHeight + 5e3;
                requestAnimationFrame(() => {
                  el.scrollTop = el.scrollHeight + 5e3;
                  if (this.$_undefinedSizes === 0) {
                    this.$_scrollingToBottom = false;
                  } else {
                    requestAnimationFrame(cb);
                  }
                });
              };
              requestAnimationFrame(cb);
            });
          }
        }
      };
      function render(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_RecycleScroller = resolveComponent("RecycleScroller");
        return openBlock(), createBlock(_component_RecycleScroller, mergeProps({
          ref: "scroller",
          items: $options.itemsWithSize,
          "min-item-size": $props.minItemSize,
          direction: _ctx.direction,
          "key-field": "id",
          "list-tag": _ctx.listTag,
          "item-tag": _ctx.itemTag
        }, _ctx.$attrs, {
          onResize: $options.onScrollerResize,
          onVisible: $options.onScrollerVisible
        }), {
          default: withCtx(({ item: itemWithSize, index, active }) => [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({
              item: itemWithSize.item,
              index,
              active,
              itemWithSize
            })))
          ]),
          before: withCtx(() => [
            renderSlot(_ctx.$slots, "before")
          ]),
          after: withCtx(() => [
            renderSlot(_ctx.$slots, "after")
          ]),
          empty: withCtx(() => [
            renderSlot(_ctx.$slots, "empty")
          ]),
          _: 3
          /* FORWARDED */
        }, 16, ["items", "min-item-size", "direction", "list-tag", "item-tag", "onResize", "onVisible"]);
      }
      script$1.render = render;
      script$1.__file = "src/components/DynamicScroller.vue";
      var script = {
        name: "DynamicScrollerItem",
        inject: [
          "vscrollData",
          "vscrollParent",
          "vscrollResizeObserver"
        ],
        props: {
          // eslint-disable-next-line vue/require-prop-types
          item: {
            required: true
          },
          watchData: {
            type: Boolean,
            default: false
          },
          /**
           * Indicates if the view is actively used to display an item.
           */
          active: {
            type: Boolean,
            required: true
          },
          index: {
            type: Number,
            default: void 0
          },
          sizeDependencies: {
            type: [Array, Object],
            default: null
          },
          emitResize: {
            type: Boolean,
            default: false
          },
          tag: {
            type: String,
            default: "div"
          }
        },
        emits: [
          "resize"
        ],
        computed: {
          id() {
            if (this.vscrollData.simpleArray) return this.index;
            if (this.vscrollData.keyField in this.item) return this.item[this.vscrollData.keyField];
            throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`);
          },
          size() {
            return this.vscrollData.sizes[this.id] || 0;
          },
          finalActive() {
            return this.active && this.vscrollData.active;
          }
        },
        watch: {
          watchData: "updateWatchData",
          id(value, oldValue) {
            this.$el.$_vs_id = this.id;
            if (!this.size) {
              this.onDataUpdate();
            }
            if (this.$_sizeObserved) {
              const oldSize = this.vscrollData.sizes[oldValue];
              const size = this.vscrollData.sizes[value];
              if (oldSize != null && oldSize !== size) {
                this.applySize(oldSize);
              }
            }
          },
          finalActive(value) {
            if (!this.size) {
              if (value) {
                if (!this.vscrollParent.$_undefinedMap[this.id]) {
                  this.vscrollParent.$_undefinedSizes++;
                  this.vscrollParent.$_undefinedMap[this.id] = true;
                }
              } else {
                if (this.vscrollParent.$_undefinedMap[this.id]) {
                  this.vscrollParent.$_undefinedSizes--;
                  this.vscrollParent.$_undefinedMap[this.id] = false;
                }
              }
            }
            if (this.vscrollResizeObserver) {
              if (value) {
                this.observeSize();
              } else {
                this.unobserveSize();
              }
            } else if (value && this.$_pendingVScrollUpdate === this.id) {
              this.updateSize();
            }
          }
        },
        created() {
          if (this.$isServer) return;
          this.$_forceNextVScrollUpdate = null;
          this.updateWatchData();
          if (!this.vscrollResizeObserver) {
            for (const k in this.sizeDependencies) {
              this.$watch(() => this.sizeDependencies[k], this.onDataUpdate);
            }
            this.vscrollParent.$_events.on("vscroll:update", this.onVscrollUpdate);
          }
        },
        mounted() {
          if (this.finalActive) {
            this.updateSize();
            this.observeSize();
          }
        },
        beforeUnmount() {
          this.vscrollParent.$_events.off("vscroll:update", this.onVscrollUpdate);
          this.unobserveSize();
        },
        methods: {
          updateSize() {
            if (this.finalActive) {
              if (this.$_pendingSizeUpdate !== this.id) {
                this.$_pendingSizeUpdate = this.id;
                this.$_forceNextVScrollUpdate = null;
                this.$_pendingVScrollUpdate = null;
                this.computeSize(this.id);
              }
            } else {
              this.$_forceNextVScrollUpdate = this.id;
            }
          },
          updateWatchData() {
            if (this.watchData && !this.vscrollResizeObserver) {
              this.$_watchData = this.$watch("item", () => {
                this.onDataUpdate();
              }, {
                deep: true
              });
            } else if (this.$_watchData) {
              this.$_watchData();
              this.$_watchData = null;
            }
          },
          onVscrollUpdate({ force }) {
            if (!this.finalActive && force) {
              this.$_pendingVScrollUpdate = this.id;
            }
            if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {
              this.updateSize();
            }
          },
          onDataUpdate() {
            this.updateSize();
          },
          computeSize(id) {
            this.$nextTick(() => {
              if (this.id === id) {
                const width = this.$el.offsetWidth;
                const height = this.$el.offsetHeight;
                this.applyWidthHeight(width, height);
              }
              this.$_pendingSizeUpdate = null;
            });
          },
          applyWidthHeight(width, height) {
            const size = ~~(this.vscrollParent.direction === "vertical" ? height : width);
            if (size && this.size !== size) {
              this.applySize(size);
            }
          },
          applySize(size) {
            if (this.vscrollParent.$_undefinedMap[this.id]) {
              this.vscrollParent.$_undefinedSizes--;
              this.vscrollParent.$_undefinedMap[this.id] = void 0;
            }
            this.vscrollData.sizes[this.id] = size;
            if (this.emitResize) this.$emit("resize", this.id);
          },
          observeSize() {
            if (!this.vscrollResizeObserver) return;
            if (this.$_sizeObserved) return;
            this.vscrollResizeObserver.observe(this.$el);
            this.$el.$_vs_id = this.id;
            this.$el.$_vs_onResize = this.onResize;
            this.$_sizeObserved = true;
          },
          unobserveSize() {
            if (!this.vscrollResizeObserver) return;
            if (!this.$_sizeObserved) return;
            this.vscrollResizeObserver.unobserve(this.$el);
            this.$el.$_vs_onResize = void 0;
            this.$_sizeObserved = false;
          },
          onResize(id, width, height) {
            if (this.id === id) {
              this.applyWidthHeight(width, height);
            }
          }
        },
        render() {
          return h$1(this.tag, this.$slots.default());
        }
      };
      script.__file = "src/components/DynamicScrollerItem.vue";
      const _hoisted_1$b = { class: "chat-main" };
      const _hoisted_2$8 = { class: "message-wrapper" };
      const _hoisted_3$3 = { class: "message-content" };
      const _hoisted_4$2 = { class: "text-dark" };
      const _hoisted_5$1 = { class: "message-options" };
      const _hoisted_6$1 = { class: "message-date" };
      const _hoisted_7 = { class: "date" };
      const _hoisted_8 = { class: "time" };
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        __name: "chat",
        setup(__props) {
          const { chatMessages: chatMessages2, chatInput: chatInput2 } = useChat();
          const messageScroller = ref();
          const messageInput = ref();
          watch(
            () => chatMessages2.value.length,
            () => {
              var _a;
              (_a = messageScroller.value) == null ? void 0 : _a.scrollToBottom();
            }
          );
          watchIgnorable(chatInput2, () => {
            var _a, _b, _c, _d;
            if ((_b = (_a = messageInput.value) == null ? void 0 : _a.textarea) == null ? void 0 : _b.scrollTop) {
              messageInput.value.textarea.scrollTop = ((_d = (_c = messageInput.value) == null ? void 0 : _c.textarea) == null ? void 0 : _d.scrollHeight) || 0;
            }
          });
          return (_ctx, _cache) => {
            const _component_el_icon = ElIcon$1;
            const _component_el_avatar = ElAvatar;
            return openBlock(), createElementBlock("div", _hoisted_1$b, [
              createVNode(unref(script$1), {
                ref_key: "messageScroller",
                ref: messageScroller,
                items: unref(chatMessages2),
                "min-item-size": 100,
                class: "chat-message"
              }, {
                default: withCtx(({ item, index, active }) => [
                  createVNode(unref(script), {
                    item,
                    active,
                    "size-dependencies": [item.content],
                    "data-index": index,
                    class: normalizeClass(["message", { self: item.role !== "boos" }])
                  }, {
                    default: withCtx(() => {
                      var _a;
                      return [
                        createElementVNode("div", _hoisted_2$8, [
                          createElementVNode("div", _hoisted_3$3, [
                            createElementVNode("h6", _hoisted_4$2, toDisplayString(item.name), 1),
                            createElementVNode("span", null, toDisplayString(item.content), 1)
                          ])
                        ]),
                        createElementVNode("div", _hoisted_5$1, [
                          createVNode(_component_el_avatar, {
                            src: typeof item.avatar === "string" ? item.avatar : void 0,
                            style: normalizeStyle({
                              "--el-avatar-bg-color": typeof item.avatar !== "string" && ((_a = item.avatar) == null ? void 0 : _a.color)
                            })
                          }, {
                            default: withCtx(() => [
                              item.avatar && typeof item.avatar !== "string" ? (openBlock(), createBlock(_component_el_icon, {
                                key: 0,
                                size: "large",
                                innerHTML: item.avatar.icon
                              }, null, 8, ["innerHTML"])) : createCommentVNode("", true)
                            ]),
                            _: 2
                          }, 1032, ["src", "style"]),
                          createElementVNode("span", _hoisted_6$1, [
                            createElementVNode("span", _hoisted_7, toDisplayString(item.date[0]) + "Â Â ", 1),
                            createElementVNode("span", _hoisted_8, toDisplayString(item.date[1]), 1)
                          ])
                        ]),
                        _cache[0] || (_cache[0] = createElementVNode("div", { style: { "height": "1.25rem" } }, null, -1))
                      ];
                    }),
                    _: 2
                  }, 1032, ["item", "active", "size-dependencies", "data-index", "class"])
                ]),
                _: 1
              }, 8, ["items"]),
              createCommentVNode("", true)
            ]);
          };
        }
      });
      const chatVue = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-356813ac"]]);
      const _hoisted_1$a = { style: { "display": "flex", "align-items": "center" } };
      const _hoisted_2$7 = {
        class: "hp-about",
        help: "è°¢è°¢ä½ çš„å…³å¿ƒ"
      };
      const _hoisted_3$2 = { help: "æ„¿ä¸ºç†æƒ³æ‰§ç€è¡Œï¼Œå‰è·¯æ¼«æ¼«è‡ªé“¸é‡‘ã€‚" };
      const _hoisted_4$1 = { help: "æ›´åº”è¯¥æ„Ÿè°¢è¿™äº›äºº" };
      const _hoisted_5 = {
        class: "hp-about",
        help: "å¦‚æžœå¯¹ä½ æœ‰å¸®åŠ©ä¸€å®šè¦Starå‘€!",
        style: { "margin-left": "20px" }
      };
      const _hoisted_6 = {
        help: "è®°å¾—æ¥ä¸ªStaræˆ–è€…å¥½è¯„å§",
        style: { "margin-top": "10px" }
      };
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        __name: "about",
        setup(__props) {
          return (_ctx, _cache) => {
            const _component_el_space = ElSpace;
            return openBlock(), createElementBlock(Fragment, null, [
              createElementVNode("div", null, [
                createElementVNode("div", _hoisted_1$a, [
                  createElementVNode("div", _hoisted_2$7, [
                    createElementVNode("div", _hoisted_3$2, [
                      _cache[1] || (_cache[1] = createTextVNode(" ä½œè€…:ã€€ ")),
                      createVNode(unref(ElLink$1), {
                        href: "https://github.com/Ocyss",
                        target: "_blank"
                      }, {
                        default: withCtx(() => _cache[0] || (_cache[0] = [
                          createTextVNode(" Ocyss_04 ")
                        ])),
                        _: 1
                      })
                    ]),
                    createElementVNode("div", _hoisted_4$1, [
                      _cache[3] || (_cache[3] = createTextVNode(" é¸£è°¢:ã€€ ")),
                      createVNode(unref(ElLink$1), {
                        href: "https://github.com/yangfeng20",
                        target: "_blank"
                      }, {
                        default: withCtx(() => _cache[2] || (_cache[2] = [
                          createTextVNode(" yangfeng20 ")
                        ])),
                        _: 1
                      })
                    ])
                  ]),
                  createElementVNode("div", _hoisted_5, [
                    createElementVNode("div", null, [
                      createVNode(unref(ElLink$1), {
                        href: "https://github.com/Ocyss",
                        target: "_blank",
                        type: "danger"
                      }, {
                        default: withCtx(() => _cache[4] || (_cache[4] = [
                          createTextVNode(" Boss-Helper [Boosç›´è˜åŠ©æ‰‹] ")
                        ])),
                        _: 1
                      })
                    ]),
                    createElementVNode("div", null, [
                      createVNode(unref(ElLink$1), {
                        href: "https://greasyfork.org/zh-CN/scripts/468125-boss-batch-push-boss%E7%9B%B4%E8%81%98%E6%89%B9%E9%87%8F%E6%8A%95%E7%AE%80%E5%8E%86",
                        target: "_blank",
                        type: "danger"
                      }, {
                        default: withCtx(() => _cache[5] || (_cache[5] = [
                          createTextVNode(" Boss Batch Push [Bossç›´è˜æ‰¹é‡æŠ•ç®€åŽ†] ")
                        ])),
                        _: 1
                      })
                    ])
                  ])
                ]),
                createElementVNode("div", _hoisted_6, [
                  _cache[11] || (_cache[11] = createTextVNode(" æœ¬æ’ä»¶å®Œå…¨å…è´¹å¼€æºä¸”æ— å¹¿å‘Š, å¦‚æžœæœ‰é—®é¢˜è¯·åé¦ˆ ")),
                  _cache[12] || (_cache[12] = createElementVNode("br", null, null, -1)),
                  _cache[13] || (_cache[13] = createTextVNode(" Githubå¼€æºåœ°å€: ")),
                  createVNode(unref(ElLink$1), {
                    href: "https://github.com/ocyss/boos-helper",
                    target: "_blank"
                  }, {
                    default: withCtx(() => _cache[6] || (_cache[6] = [
                      createTextVNode(" https://github.com/ocyss/boos-helper ")
                    ])),
                    _: 1
                  }),
                  _cache[14] || (_cache[14] = createElementVNode("br", null, null, -1)),
                  _cache[15] || (_cache[15] = createTextVNode(" greasyforkåœ°å€: ")),
                  createVNode(unref(ElLink$1), {
                    href: "https://greasyfork.org/zh-CN/scripts/491340",
                    target: "_blank"
                  }, {
                    default: withCtx(() => _cache[7] || (_cache[7] = [
                      createTextVNode(" https://greasyfork.org/zh-CN/scripts/491340 ")
                    ])),
                    _: 1
                  }),
                  _cache[16] || (_cache[16] = createElementVNode("br", null, null, -1)),
                  _cache[17] || (_cache[17] = createElementVNode("br", null, null, -1)),
                  createVNode(_component_el_space, { wrap: "" }, {
                    default: withCtx(() => [
                      createVNode(unref(ElLink$1), {
                        href: "https://gai06vrtbc0.feishu.cn/share/base/form/shrcnmEq2fxH9hM44hqEnoeaj8g",
                        target: "_blank"
                      }, {
                        default: withCtx(() => _cache[8] || (_cache[8] = [
                          createTextVNode(" é£žä¹¦åé¦ˆé—®å·(åŒ¿å) ")
                        ])),
                        _: 1
                      }),
                      createVNode(unref(ElLink$1), {
                        href: "https://gai06vrtbc0.feishu.cn/share/base/view/shrcnrg8D0cbLQc89d7Jj7AZgMc",
                        target: "_blank"
                      }, {
                        default: withCtx(() => _cache[9] || (_cache[9] = [
                          createTextVNode(" é£žä¹¦é—®å·ç»“æžœ ")
                        ])),
                        _: 1
                      }),
                      createVNode(unref(ElLink$1), {
                        href: "https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=410v5499-7193-411f-8258-94ae0cac4fc0",
                        target: "_blank"
                      }, {
                        default: withCtx(() => _cache[10] || (_cache[10] = [
                          createTextVNode(" é£žä¹¦äº¤æµç¾¤ ")
                        ])),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _cache[18] || (_cache[18] = createElementVNode("div", {
                  help: " ",
                  style: { "width": "60%", "margin-top": "20px", "user-select": "text", "color": "#fff" }
                }, [
                  createTextVNode(" é™¤éžä¸å¯æŠ—å› ç´ ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ä¸ä¼šåœæ›´ï¼Œè¿™ä¸ªé¡¹ç›®ä¸æ­¢æ˜¯å¸®åŠ©ä½ ä»¬ï¼Œä¹Ÿèƒ½å¸®åˆ°æˆ‘ "),
                  createElementVNode("br")
                ], -1))
              ]),
              createVNode(unref(ElImage), {
                help: "å¯èƒ½å¹¶æ²¡ä»€ä¹ˆç”¨,åªæ˜¯ä¸è®©é¡µé¢ç©ºè¡è¡",
                style: { "width": "200px", "height": "200px" },
                src: "https://qiu-config.oss-cn-beijing.aliyuncs.com/reward.png",
                fit: "cover",
                "preview-src-list": [
                  "https://qiu-config.oss-cn-beijing.aliyuncs.com/reward.png"
                ],
                loading: "lazy"
              })
            ], 64);
          };
        }
      });
      const _hoisted_1$9 = { class: "select-form-box" };
      const _hoisted_2$6 = {
        class: "select-form-box",
        style: { "width": "100%", "align-items": "flex-start" }
      };
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        __name: "selectLLM",
        props: /* @__PURE__ */ mergeModels({
          data: {}
        }, {
          "modelValue": { type: Boolean, ...{ required: true } },
          "modelModifiers": {}
        }),
        emits: ["update:modelValue"],
        setup(__props) {
          const { formData: formData2, confSaving } = useConfFormData();
          const { modelData: modelData2 } = useModel();
          const props2 = __props;
          const show = useModel$1(__props, "modelValue");
          const model = ref(formData2[props2.data].model);
          const singleMode = ref(!Array.isArray(formData2[props2.data].prompt));
          const role = ["system", "user", "assistant"].map((item) => {
            return {
              label: item,
              value: item
            };
          });
          let _message = formData2[props2.data].prompt;
          if (Array.isArray(_message)) {
            _message = [..._message].map((item) => ({ ...item }));
          }
          const message = ref(_message);
          function inputExample() {
            message.value = formInfoData[props2.data].example[singleMode.value ? 0 : 1];
          }
          function changeMode(v2) {
            if (v2) {
              message.value = "";
            } else {
              message.value = [
                { role: "user", content: "" },
                { role: "assistant", content: "" },
                { role: "user", content: "" }
              ];
            }
          }
          function removeMessage(item) {
            if (Array.isArray(message.value)) {
              message.value = message.value.filter((v2) => v2 !== item);
            }
          }
          function addMessage() {
            if (Array.isArray(message.value)) {
              message.value.push({ role: "user", content: "" });
            }
          }
          return (_ctx, _cache) => {
            const _component_el_radio_button = ElRadioButton;
            const _component_el_radio_group = ElRadioGroup;
            const _component_el_form_item = ElFormItem;
            const _component_el_form = ElForm;
            return openBlock(), createBlock(unref(ElDialog$1), {
              modelValue: show.value,
              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => show.value = $event),
              title: unref(formInfoData)[_ctx.data].label,
              width: "70%",
              "align-center": "",
              "destroy-on-close": "",
              "z-index": 20
            }, {
              footer: withCtx(() => [
                createElementVNode("div", null, [
                  createVNode(unref(ElButton), {
                    onClick: _cache[4] || (_cache[4] = ($event) => show.value = false)
                  }, {
                    default: withCtx(() => _cache[18] || (_cache[18] = [
                      createTextVNode("å–æ¶ˆ")
                    ])),
                    _: 1
                  }),
                  createVNode(unref(ElButton), {
                    type: "primary",
                    onClick: _cache[5] || (_cache[5] = () => {
                      unref(formData2)[_ctx.data].model = model.value;
                      unref(formData2)[_ctx.data].prompt = message.value;
                      unref(confSaving)();
                      show.value = false;
                    })
                  }, {
                    default: withCtx(() => _cache[19] || (_cache[19] = [
                      createTextVNode(" ä¿å­˜ ")
                    ])),
                    _: 1
                  })
                ])
              ]),
              default: withCtx(() => [
                createVNode(unref(ElAlert$1), {
                  title: "å¯¹äºŽæ€§èƒ½å¼ºçš„æ¨¡åž‹ä½¿ç”¨å•å¯¹è¯åœ¨å¤Ÿç”¨çš„åŒæ—¶ä¹Ÿèƒ½å‡å°‘tokensçš„ä½¿ç”¨ã€‚è€Œæ€§èƒ½ç¨å¼±çš„æ¨¡åž‹ä½¿ç”¨å¤šå¯¹è¯æ¥åŠ å¼ºå¼•å¯¼,ä½†ä¹Ÿä¼šæ¶ˆè€—æ›´å¤šçš„tokens",
                  type: "info",
                  closable: false
                }),
                createElementVNode("div", _hoisted_1$9, [
                  createVNode(_component_el_radio_group, {
                    modelValue: singleMode.value,
                    "onUpdate:modelValue": [
                      _cache[0] || (_cache[0] = ($event) => singleMode.value = $event),
                      changeMode
                    ],
                    size: "large"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_radio_button, {
                        label: "å•å¯¹è¯æ¨¡å¼",
                        value: true
                      }),
                      createVNode(_component_el_radio_button, {
                        label: "å¤šå¯¹è¯æ¨¡å¼",
                        value: false
                      })
                    ]),
                    _: 1
                  }, 8, ["modelValue"]),
                  createVNode(unref(ElButton), { onClick: inputExample }, {
                    default: withCtx(() => _cache[7] || (_cache[7] = [
                      createTextVNode("å¡«å…¥ç¤ºä¾‹å€¼")
                    ])),
                    _: 1
                  }),
                  createVNode(unref(ElSelectV2), {
                    modelValue: model.value,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => model.value = $event),
                    options: unref(modelData2),
                    props: { label: "name", value: "key" },
                    placeholder: "é€‰æ‹©æ¨¡åž‹",
                    style: { "width": "35%" }
                  }, null, 8, ["modelValue", "options"])
                ]),
                createVNode(unref(ElText$1), {
                  style: { "margin": "20px 0" },
                  tag: "div"
                }, {
                  default: withCtx(() => [
                    _cache[11] || (_cache[11] = createTextVNode(" ä½¿ç”¨ ")),
                    createVNode(unref(ElLink$1), {
                      type: "primary",
                      href: "https://ygorko.github.io/mitem/",
                      target: "_blank"
                    }, {
                      default: withCtx(() => _cache[8] || (_cache[8] = [
                        createTextVNode(" mitem ")
                      ])),
                      _: 1
                    }),
                    _cache[12] || (_cache[12] = createTextVNode(" æ¥æ¸²æŸ“æ¨¡æ¿ã€‚åœ¨å¤šå¯¹è¯æ¨¡å¼ä¸‹ï¼Œåªæœ‰æœ€åŽçš„æ¶ˆæ¯ä¼šä½¿ç”¨æ¨¡æ¿ã€‚ ")),
                    createVNode(unref(ElLink$1), {
                      type: "primary",
                      href: "#",
                      target: "_blank"
                    }, {
                      default: withCtx(() => _cache[9] || (_cache[9] = [
                        createTextVNode("å˜é‡è¡¨")
                      ])),
                      _: 1
                    }),
                    _cache[13] || (_cache[13] = createElementVNode("br", null, null, -1)),
                    _cache[14] || (_cache[14] = createTextVNode(" æŽ¨èé˜…è¯» ")),
                    createVNode(unref(ElLink$1), {
                      type: "primary",
                      href: "https://langgptai.feishu.cn/wiki/RXdbwRyASiShtDky381ciwFEnpe",
                      target: "_blank"
                    }, {
                      default: withCtx(() => _cache[10] || (_cache[10] = [
                        createTextVNode(" ã€ŠLangGPTã€‹ ")
                      ])),
                      _: 1
                    }),
                    _cache[15] || (_cache[15] = createTextVNode(" çš„æç¤ºè¯æ–‡æ¡£å­¦ä¹  ( ç¤ºä¾‹æç¤ºè¯å†™çš„å¹¶ä¸å¥½,æ¬¢è¿ŽAIå¤§ä½¬æ¥æpr ) "))
                  ]),
                  _: 1
                }),
                singleMode.value ? (openBlock(), createBlock(unref(ElInput$1), {
                  key: 0,
                  modelValue: message.value,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => message.value = $event),
                  style: { "width": "100%" },
                  autosize: { minRows: 10, maxRows: 18 },
                  type: "textarea"
                }, null, 8, ["modelValue"])) : (openBlock(), createBlock(_component_el_form, {
                  key: 1,
                  modelValue: message.value,
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => message.value = $event),
                  "label-width": "auto",
                  class: "demo-dynamic"
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(message.value, (item, index) => {
                      return openBlock(), createBlock(_component_el_form_item, { key: index }, {
                        label: withCtx(() => [
                          createVNode(unref(ElSelectV2), {
                            modelValue: item.role,
                            "onUpdate:modelValue": ($event) => item.role = $event,
                            options: unref(role),
                            style: { "width": "140px" }
                          }, null, 8, ["modelValue", "onUpdate:modelValue", "options"])
                        ]),
                        default: withCtx(() => [
                          createElementVNode("div", _hoisted_2$6, [
                            createVNode(unref(ElInput$1), {
                              modelValue: item.content,
                              "onUpdate:modelValue": ($event) => item.content = $event,
                              type: "textarea",
                              autosize: { minRows: 2, maxRows: 8 }
                            }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                            createVNode(unref(ElButton), {
                              style: { "margin-left": "10px" },
                              onClick: withModifiers(($event) => removeMessage(item), ["prevent"])
                            }, {
                              default: withCtx(() => _cache[16] || (_cache[16] = [
                                createTextVNode(" åˆ é™¤ ")
                              ])),
                              _: 2
                            }, 1032, ["onClick"])
                          ])
                        ]),
                        _: 2
                      }, 1024);
                    }), 128)),
                    createVNode(_component_el_form_item, null, {
                      default: withCtx(() => [
                        createVNode(unref(ElButton), { onClick: addMessage }, {
                          default: withCtx(() => _cache[17] || (_cache[17] = [
                            createTextVNode("æ·»åŠ æ¶ˆæ¯")
                          ])),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"]))
              ]),
              _: 1
            }, 8, ["modelValue", "title"]);
          };
        }
      });
      const _sfc_main$d = {};
      const _hoisted_1$8 = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      };
      function _sfc_render$1(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$8, _cache[0] || (_cache[0] = [
          createElementVNode("path", {
            fill: "currentColor",
            d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768m48-176a48 48 0 1 1-96 0 48 48 0 0 1 96 0m-48-464a32 32 0 0 1 32 32v288a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
          }, null, -1)
        ]));
      }
      const info = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$1]]);
      const _sfc_main$c = /* @__PURE__ */ defineComponent({
        __name: "lFormItem",
        props: /* @__PURE__ */ mergeModels({
          value: {},
          label: {},
          depth: {}
        }, {
          "modelValue": { required: true },
          "modelModifiers": {}
        }),
        emits: ["update:modelValue"],
        setup(__props) {
          const props2 = __props;
          const fromVal = useModel$1(__props, "modelValue");
          function getComponent(elm) {
            switch (elm) {
              case "input":
                return { el: ElInput$1, defaultConf: {} };
              case "inputNumber":
                return { el: ElInputNumber$1, defaultConf: {} };
              case "select":
                return { el: ElSelectV2, defaultConf: { options: [] } };
              case "slider":
                return {
                  el: ElSlider,
                  defaultConf: { style: "margin: 0 10px;", showInput: true }
                };
              case "switch":
                return { el: ElSwitch, defaultConf: {} };
            }
            return { el: void 0, defaultConf: {} };
          }
          const { el, defaultConf } = getComponent(props2.value.type);
          return (_ctx, _cache) => {
            const _component_el_alert = ElAlert;
            const _component_l_form_item = resolveComponent("l-form-item", true);
            const _component_el_text = ElText;
            const _component_el_icon = ElIcon$1;
            const _component_el_tooltip = ElTooltip;
            const _component_el_form_item = ElFormItem;
            return _ctx.value && "alert" in _ctx.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createVNode(_component_el_alert, {
                title: _ctx.value.label || _ctx.label.toString(),
                description: _ctx.value.desc,
                type: _ctx.value.alert,
                closable: false,
                "show-icon": "",
                style: normalizeStyle(`margin: 10px 0px 20px ${(props2.depth || 0) * 10}px;`)
              }, null, 8, ["title", "description", "type", "style"]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.value.value, (x2, k) => {
                return openBlock(), createBlock(_component_l_form_item, {
                  modelValue: fromVal.value[k],
                  "onUpdate:modelValue": ($event) => fromVal.value[k] = $event,
                  value: x2,
                  label: k,
                  key: k,
                  depth: (_ctx.depth || 0) + 1
                }, null, 8, ["modelValue", "onUpdate:modelValue", "value", "label", "depth"]);
              }), 128))
            ], 64)) : _ctx.value ? (openBlock(), createBlock(_component_el_form_item, {
              key: 1,
              required: _ctx.value.required,
              style: normalizeStyle(`margin-left: ${(props2.depth || 0) * 10}px;`)
            }, {
              label: withCtx(() => [
                createVNode(_component_el_text, { size: "large" }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.value.label || _ctx.label), 1)
                  ]),
                  _: 1
                }),
                _ctx.value.desc ? (openBlock(), createBlock(_component_el_tooltip, {
                  key: 0,
                  content: `<span>${_ctx.value.desc}</span>`,
                  "raw-content": ""
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_icon, { style: { "margin-left": "8px" } }, {
                      default: withCtx(() => [
                        createVNode(info)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["content"])) : createCommentVNode("", true)
              ]),
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(unref(el)), mergeProps({
                  modelValue: fromVal.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => fromVal.value = $event)
                }, { ...unref(defaultConf), ..._ctx.value.config }), null, 16, ["modelValue"]))
              ]),
              _: 1
            }, 8, ["required", "style"])) : createCommentVNode("", true);
          };
        }
      });
      const _hoisted_1$7 = {
        key: 0,
        style: { "margin": "20px 0" }
      };
      const _hoisted_2$5 = ["innerHTML"];
      const _sfc_main$b = /* @__PURE__ */ defineComponent({
        __name: "lForm",
        props: /* @__PURE__ */ mergeModels({
          data: {}
        }, {
          "modelValue": { required: true },
          "modelModifiers": {}
        }),
        emits: ["update:modelValue"],
        setup(__props) {
          const formData2 = useModel$1(__props, "modelValue");
          const props2 = __props;
          return (_ctx, _cache) => {
            const _component_l_form_item = _sfc_main$c;
            return openBlock(true), createElementBlock(Fragment, null, renderList(props2.data, (item, key) => {
              return openBlock(), createElementBlock(Fragment, null, [
                "mode" in item ? (openBlock(), createElementBlock("div", _hoisted_1$7, [
                  createElementVNode("h3", {
                    innerHTML: item.desc
                  }, null, 8, _hoisted_2$5)
                ])) : (openBlock(), createBlock(_component_l_form_item, {
                  key: 1,
                  modelValue: formData2.value[key],
                  "onUpdate:modelValue": ($event) => formData2.value[key] = $event,
                  label: key,
                  value: item
                }, null, 8, ["modelValue", "onUpdate:modelValue", "label", "value"]))
              ], 64);
            }), 256);
          };
        }
      });
      const _hoisted_1$6 = { style: { "display": "flex", "align-items": "center", "justify-content": "space-between" } };
      const _hoisted_2$4 = { class: "llms-select" };
      const _hoisted_3$1 = { class: "test-box" };
      const _hoisted_4 = { class: "mb-4" };
      const _sfc_main$a = /* @__PURE__ */ defineComponent({
        __name: "createLLM",
        props: /* @__PURE__ */ mergeModels({
          model: {}
        }, {
          "modelValue": { type: Boolean, ...{ required: true } },
          "modelModifiers": {}
        }),
        emits: /* @__PURE__ */ mergeModels(["create"], ["update:modelValue"]),
        setup(__props, { emit: __emit }) {
          var _a, _b, _c, _d;
          const props2 = __props;
          function color16() {
            var r = Math.floor(Math.random() * 256);
            var g = Math.floor(Math.random() * 256);
            var b2 = Math.floor(Math.random() * 256);
            var color = "#" + r.toString(16) + g.toString(16) + b2.toString(16);
            return color;
          }
          const show = useModel$1(__props, "modelValue");
          const createName = ref(((_a = props2.model) == null ? void 0 : _a.name) || "");
          const createColor = ref(((_b = props2.model) == null ? void 0 : _b.color) || color16());
          const testShow = ref(false);
          const { getGpt: getGpt2 } = useModel();
          const llmsOptions = computed(
            () => llms.map((v2) => {
              const m2 = v2.mode;
              return { ...m2, value: m2.mode };
            })
          );
          const selectLLM = ref(((_d = (_c = props2.model) == null ? void 0 : _c.data) == null ? void 0 : _d.mode) || llms[0].mode.mode);
          const formLLM = computed(
            () => Math.max(
              llms.findIndex((l2) => l2.mode.mode === selectLLM.value),
              0
            )
          );
          function dfs(res, data2) {
            for (const key in data2) {
              const v2 = data2[key];
              if ("mode" in v2) {
                continue;
              } else if ("alert" in v2) {
                res[key] = {};
                dfs(res[key], v2.value);
              } else res[key] = v2.value;
            }
          }
          const llmFormData = reactiveComputed(() => {
            var _a2;
            const res = {};
            dfs(res, llms[formLLM.value]);
            deepmerge(res, (_a2 = props2.model) == null ? void 0 : _a2.data, { clone: false });
            return res;
          });
          const updateFormLLM = (v2) => {
            var _a2;
            dfs(llmFormData, llms[formLLM.value]);
            deepmerge(llmFormData, (_a2 = props2.model) == null ? void 0 : _a2.data, { clone: false });
          };
          const emit = __emit;
          const testIn = ref("");
          const testOut = ref("");
          const testExample = {
            Json: [
              `æˆ‘çŽ°åœ¨å¤±ä¸šäº†,æƒ³æ‰¾ä¸€ä¸ªæ–°å·¥ä½œ,ä½†å²—ä½éœ€æ±‚è‰¯èŽ ä¸é½,æˆ‘éœ€è¦ä½ å¯¹ä¸‹é¢çš„å²—ä½è¿›è¡Œè¯„åˆ†,æˆ‘æƒ³è¦åŒä¼‘çš„,æœ€å¥½å¯ä»¥æ—©ä¹æ™šäº”,8å°æ—¶çš„.ä¸éœ€è¦å¤–å‡º,ä¸éœ€è¦å’Œå®¢æˆ·èŠå¤©,ä¸éœ€è¦æŽ¨é”€,æœ€åŽç»™æˆ‘Jsonæ ¼å¼çš„zifui
\`\`\` å²—ä½ä¿¡æ¯
å‘¨æœ«åŒä¼‘ï¼Œæ—©åæ™šä¸ƒï¼Œå¸¦è–ªå¹´å‡è‡³å°‘åŠä¸ªæœˆï¼Œæ³•å®šèŠ‚å‡æ—¥æ­£å¸¸æ”¾å‡ï¼Œè´­ä¹°ç¤¾ä¿ï¼Œå¸¦è–ªåŸ¹è®­ã€‚
ç½‘ç»œé”€å”®!ç½‘ç»œé”€å”®!ä¸è¦å†é—®æˆ‘æ˜¯ä¸æ˜¯çº¯ç”µé”€å•¦!ä¹Ÿä¸æ˜¯è´·æ¬¾!!!å…¬å¸çš„å°ä¼™ä¼´å¾ˆå‹å¥½ï¼Œé¢è¯•ç»“æžœå½“å¤©å°±é€šçŸ¥!æ²¡æœ‰kpi!æ”¾å¿ƒå’¨è¯¢!
èŒä½è¯¦æƒ…
1.é€šè¿‡å…¬å¸æä¾›çš„ç²¾å‡†æ•°æ®è¿›è¡Œç½‘ç»œè·Ÿè¿›å’Œç»´æŠ¤å®¢æˆ·2ï¼ŒåŠæ—¶è§£ç­”å®¢æˆ·çš„ç›¸å…³é—®é¢˜ï¼Œå®Œæˆç›¸å…³é”€å”®å·¥ä½œ
å·¥ä½œæ—¶é—´:10:00-19:00åˆä¼‘12:00-13:30ï¼Œå›ºå®šå‘¨æœ«åŒä¼‘ï¼ŒèŠ‚å‡æ—¥å…¨éƒ¨æ­£å¸¸ä¼‘å‡
ä¸éœ€è¦å¤–å‡ºï¼Œå…¬å¸æä¾›ç²¾å‡†æ•°æ®ï¼Œå…¬å¹³èµ·æ­¥ï¼Œæ–°è€äººææˆä¸€æ ·ï¼Œæ°›å›´å¥½ï¼Œå¥½æ™‹å‡
è–ªèµ„å¾…é‡:
ç†Ÿæ‰‹æ— è´£åº•è–ª(4000-6000)èµ·+é”€å”®ææˆ+å„ç§å¥–é‡‘ï¼Œå¼€å•å¥–ï¼Œç»¼åˆè–ªèµ„12-20kï¼Œç¼´çº³ç¤¾ä¿ï¼ŒèŠ‚æ—¥ç¦åˆ©
æ–°äººæœ€ä½Žæ— è´£åº•è–ª4000ï¼Œæ²¡æœ‰ä¸šç»©è€ƒæ ¸ï¼Œæœ‰ä¸šç»©çš„æŒ‰ç…§é˜¶æ¢¯åº•è–ªä»Ž4000åˆ°6000ä¸ç­‰ï¼Œææˆå’Œè€å‘˜å·¥ä¸€æ ·çš„ææˆç‚¹ä½æ²¡æœ‰ä¸šç»©è€ƒæ ¸ï¼Œåº•è–ªä¸€ç›´éƒ½æ˜¯æ— è´£çš„ï¼Œè¯•ç”¨æœŸä¹Ÿä¸ä¼šæ‰“æŠ˜!
ä»»èŒè¦æ±‚:
1.å­¦åŽ†ä¸é™ï¼Œ18-35å²ï¼Œç”·å¥³ä¸é™
2.æ²Ÿé€šè¡¨è¾¾èƒ½åŠ›å¥½ï¼ŒæŠ—åŽ‹æ€§å¼ºï¼Œæ€§æ ¼å¤–å‘ï¼Œé€»è¾‘æ€ç»´èƒ½åŠ›ï¼Œå¤ç›˜æ€»ç»“ï¼Œæœ‰ä¸Šè¿›å¿ƒ
æ™‹å‡ç©ºé—´:ä¸“å‘˜-ç»„é•¿--ç»ç†-æ€»ç›‘ æä¾›æ™‹å‡æœºä¼š
\`\`\`
è¾“å‡ºç¬¦åˆä¸‹é¢å®šä¹‰çš„Jsonæ ¼å¼å­—ç¬¦ä¸²
interface aiFiltering {
  rating: number; // åˆ†æ•°, ä½ŽäºŽ40çš„æˆ‘ä¼šç­›é€‰æŽ‰
  negative: string[] | string; // æ‰£åˆ†é¡¹
  positive: string[] | string; // åŠ åˆ†é¡¹
}
`,
              `ä½ å«åšâ€œå¦™å¦™â€ï¼Œæ˜¯ä¸€æ¬¾å«åšâ€œå¦™è¯­ç¬”è®°â€çš„æ™ºèƒ½åŠ©æ‰‹ï¼ŒæŽ¥ä¸‹æ¥ä½ ä¼šåˆ†æžä¸‹é¢ç”¨æˆ·çš„è¾“å…¥ï¼š
"""
æˆ‘çš„ç§°å‘¼æ˜¯å´æ¥·é¹ï¼Œå¯ä»¥å«æˆ‘å¤§å¸…å“¥ï¼Œå‡ºç”ŸäºŽé¦™æ¸¯å›žå½’çš„é‚£ä¸€å¹´ï¼Œç”Ÿæ—¥æ˜¯ 3 æœˆ 13 å·ï¼Œå–œæ¬¢ä¸Šç­
"""
è®¾å®šï¼š
1. çŽ°åœ¨æ˜¯ 2025.10.01 21:21ï¼Œæ—¶åŒºæ˜¯ Asia/Shanghai
2. æå–æ˜µç§°ã€æ€§åˆ«ã€å‡ºç”Ÿæ—¥æœŸï¼Œå‰©ä½™å…¨éƒ¨ä¿¡æ¯æ•´ç†æˆä¸ªäººä»‹ç»
3. è¦æ±‚è¾“å‡ºç»“æž„åŒ– JSON å¯¹è±¡ï¼Œç¬¦åˆä¸‹é¢ TypeScriptï¼š
interface UserInfo {
  nickname?: string;
  gender?: 'male'  | 'female';
  dataOfBirth?: string;
  bio?: string;
}
4. è¿™æ˜¯ä¾‹å­ï¼šconst userInfo = {
    "nickname":"è‘£å°å§",
    "gender": "female",
    "dateOfBirth":"2001-03-07",
    "bio": "å®¶ä½åœ¨é•¿æ²™ï¼Œå–œæ¬¢åšé¥­"
}

æŽ¥ä¸‹æ¥å¼€å§‹åˆ†æžï¼šconst userInfo=`
            ],
            å¼±æ™º: [
              "è¯·é—®ä½ æ€Žä¹ˆçœ‹å¾…é²è¿…æ‰“å‘¨æ ‘äººå‘¢?",
              "å°äºŽ90åº¦çš„æ˜¯é”è§’ï¼Œç­‰äºŽ90åº¦çš„æ˜¯ç›´è§’ï¼Œå¤§äºŽ90åº¦çš„æ˜¯é’è§’\nå¼€æ°´æœ‰100åº¦ï¼Œæ‰€ä»¥å¼€æ°´æ˜¯é’è§’å—ï¼Ÿ"
            ]
          };
          async function test() {
            const data2 = JSON.parse(
              JSON.stringify(props2.model || { name: "", key: "" })
            );
            data2.name = createName.value;
            data2.data = JSON.parse(JSON.stringify(llmFormData));
            data2.data.mode = selectLLM.value;
            logger.debug(data2);
            const gpt4 = getGpt2(data2, testIn.value);
            testOut.value = "";
            logger.group("LLMTest");
            const msg = await gpt4.message({
              data: {},
              onStream: (d2) => {
                logger.debug("TestResStream", d2);
                testOut.value += d2;
              }
            });
            testOut.value = msg.content || "";
            logger.debug("TestRes", msg);
            logger.groupEnd();
          }
          function create() {
            const data2 = props2.model || { name: "", key: "" };
            data2.name = createName.value;
            data2.data = JSON.parse(JSON.stringify(llmFormData));
            data2.data.mode = selectLLM.value;
            data2.color = createColor.value;
            emit("create", data2);
          }
          return (_ctx, _cache) => {
            const _component_el_input = ElInput;
            const _component_el_form_item = ElFormItem;
            const _component_el_color_picker = ElColorPicker;
            const _component_el_icon = ElIcon$1;
            const _component_el_segmented = ElSegmented;
            const _component_lForm = _sfc_main$b;
            const _component_el_form = ElForm;
            const _component_el_scrollbar = ElScrollbar;
            const _component_el_button = ElButton$1;
            const _component_el_dialog = ElDialog;
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(_component_el_dialog, {
                modelValue: show.value,
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => show.value = $event),
                title: unref(formInfoData).record.label,
                width: "70%",
                "align-center": "",
                "destroy-on-close": "",
                draggable: "",
                "z-index": 20
              }, {
                footer: withCtx(() => [
                  createElementVNode("div", null, [
                    createVNode(_component_el_button, {
                      onClick: _cache[4] || (_cache[4] = ($event) => show.value = false)
                    }, {
                      default: withCtx(() => _cache[10] || (_cache[10] = [
                        createTextVNode("å–æ¶ˆ")
                      ])),
                      _: 1
                    }),
                    createVNode(_component_el_button, {
                      type: "info",
                      onClick: _cache[5] || (_cache[5] = ($event) => testShow.value = true)
                    }, {
                      default: withCtx(() => _cache[11] || (_cache[11] = [
                        createTextVNode("æµ‹è¯•")
                      ])),
                      _: 1
                    }),
                    createVNode(_component_el_button, {
                      type: "primary",
                      onClick: create
                    }, {
                      default: withCtx(() => _cache[12] || (_cache[12] = [
                        createTextVNode("ä¿å­˜")
                      ])),
                      _: 1
                    })
                  ])
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_scrollbar, {
                    height: "60vh",
                    style: { "padding": "20px" }
                  }, {
                    default: withCtx(() => [
                      createElementVNode("div", _hoisted_1$6, [
                        createVNode(_component_el_form_item, {
                          label: "åç§°:",
                          style: { "width": "70%" }
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_el_input, {
                              modelValue: createName.value,
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => createName.value = $event)
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_form_item, { label: "èƒŒæ™¯:" }, {
                          default: withCtx(() => [
                            createVNode(_component_el_color_picker, {
                              modelValue: createColor.value,
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => createColor.value = $event)
                            }, null, 8, ["modelValue"])
                          ]),
                          _: 1
                        })
                      ]),
                      createVNode(_component_el_segmented, {
                        modelValue: selectLLM.value,
                        "onUpdate:modelValue": [
                          _cache[2] || (_cache[2] = ($event) => selectLLM.value = $event),
                          updateFormLLM
                        ],
                        options: llmsOptions.value,
                        block: ""
                      }, {
                        default: withCtx(({ item }) => [
                          createElementVNode("div", _hoisted_2$4, [
                            createVNode(_component_el_icon, {
                              size: "20",
                              innerHTML: item.icon
                            }, null, 8, ["innerHTML"]),
                            createElementVNode("div", null, toDisplayString(item.label || item.mode), 1)
                          ])
                        ]),
                        _: 1
                      }, 8, ["modelValue", "options"]),
                      createVNode(_component_el_form, {
                        "label-width": "auto",
                        size: "large",
                        "label-position": "left"
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(_component_lForm, {
                            key: formLLM.value,
                            data: unref(llms)[formLLM.value],
                            modelValue: unref(llmFormData),
                            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => isRef(llmFormData) ? llmFormData.value = $event : null)
                          }, null, 8, ["data", "modelValue"]))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["modelValue", "title"]),
              createVNode(_component_el_dialog, {
                modelValue: testShow.value,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => testShow.value = $event),
                title: "æ¨¡åž‹æµ‹è¯•",
                width: "50%",
                "align-center": "",
                draggable: "",
                "z-index": 21,
                "close-on-press-escape": false,
                "close-on-click-modal": false,
                modal: false
              }, {
                footer: withCtx(() => [
                  createElementVNode("div", null, [
                    createVNode(_component_el_button, {
                      onClick: _cache[8] || (_cache[8] = ($event) => testShow.value = false)
                    }, {
                      default: withCtx(() => _cache[13] || (_cache[13] = [
                        createTextVNode("è¿”å›ž")
                      ])),
                      _: 1
                    }),
                    createVNode(_component_el_button, {
                      type: "primary",
                      onClick: test
                    }, {
                      default: withCtx(() => _cache[14] || (_cache[14] = [
                        createTextVNode("è¯·æ±‚")
                      ])),
                      _: 1
                    })
                  ])
                ]),
                default: withCtx(() => [
                  createElementVNode("div", _hoisted_3$1, [
                    createElementVNode("div", _hoisted_4, [
                      (openBlock(), createElementBlock(Fragment, null, renderList(testExample, (example, key) => {
                        return openBlock(), createElementBlock(Fragment, { key }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(example, (item, index) => {
                            return openBlock(), createBlock(_component_el_button, {
                              type: "info",
                              plain: "",
                              key: key + index,
                              onClick: ($event) => testIn.value = item
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(key) + " " + toDisplayString(index + 1), 1)
                              ]),
                              _: 2
                            }, 1032, ["onClick"]);
                          }), 128))
                        ], 64);
                      }), 64))
                    ]),
                    createVNode(_component_el_input, {
                      modelValue: testIn.value,
                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => testIn.value = $event),
                      rows: 4,
                      type: "textarea",
                      placeholder: "è¾“å…¥æç¤ºè¯"
                    }, null, 8, ["modelValue"]),
                    createVNode(_component_el_input, {
                      "model-value": testOut.value,
                      rows: 9,
                      type: "textarea",
                      placeholder: "GPTå“åº”"
                    }, null, 8, ["model-value"])
                  ])
                ]),
                _: 1
              }, 8, ["modelValue"])
            ], 64);
          };
        }
      });
      const _hoisted_1$5 = { style: { "align-items": "center", "display": "flex" } };
      const _hoisted_2$3 = { style: { "margin-left": "8px" } };
      const _sfc_main$9 = /* @__PURE__ */ defineComponent({
        __name: "configLLM",
        props: {
          "modelValue": { type: Boolean, ...{ required: true } },
          "modelModifiers": {}
        },
        emits: ["update:modelValue"],
        setup(__props) {
          const show = useModel$1(__props, "modelValue");
          const { modelData: modelData2, save: save2 } = useModel();
          const createBoxShow = ref(false);
          function del(d2) {
            modelData2.value = modelData2.value.filter((v2) => d2.key !== v2.key);
            ElMessage.success("åˆ é™¤æˆåŠŸ");
          }
          function copy(d2) {
            d2 = JSON.parse(JSON.stringify(d2));
            d2.key = (/* @__PURE__ */ new Date()).getTime().toString();
            d2.name = d2.name + " å‰¯æœ¬";
            modelData2.value.push(d2);
            ElMessage.success("å¤åˆ¶æˆåŠŸ");
          }
          const createModelData = ref();
          function edit(d2) {
            createModelData.value = d2;
            createBoxShow.value = true;
          }
          function newllm() {
            createModelData.value = void 0;
            createBoxShow.value = true;
          }
          function create(d2) {
            if (d2.key) {
              const old = modelData2.value.find((v2) => v2.key == d2.key);
              if (old) {
                deepmerge(old, d2, { clone: false });
              } else {
                d2.key = (/* @__PURE__ */ new Date()).getTime().toString();
                modelData2.value.push(d2);
              }
            } else {
              d2.key = (/* @__PURE__ */ new Date()).getTime().toString();
              modelData2.value.push(d2);
            }
            createBoxShow.value = false;
          }
          return (_ctx, _cache) => {
            const _component_el_icon = ElIcon$1;
            const _component_el_avatar = ElAvatar;
            const _component_el_table_column = ElTableColumn;
            const _component_el_button = ElButton$1;
            const _component_el_table = ElTable;
            const _component_createLLM = _sfc_main$a;
            const _component_el_dialog = ElDialog;
            return openBlock(), createBlock(_component_el_dialog, {
              modelValue: show.value,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => show.value = $event),
              title: "Aiæ¨¡åž‹é…ç½®",
              width: "70%",
              "align-center": "",
              "destroy-on-close": "",
              "z-index": 20
            }, {
              footer: withCtx(() => [
                createElementVNode("div", null, [
                  createVNode(_component_el_button, {
                    onClick: _cache[1] || (_cache[1] = ($event) => show.value = false)
                  }, {
                    default: withCtx(() => _cache[6] || (_cache[6] = [
                      createTextVNode("å–æ¶ˆ")
                    ])),
                    _: 1
                  }),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: newllm
                  }, {
                    default: withCtx(() => _cache[7] || (_cache[7] = [
                      createTextVNode("æ–°å»º")
                    ])),
                    _: 1
                  }),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: unref(save2)
                  }, {
                    default: withCtx(() => _cache[8] || (_cache[8] = [
                      createTextVNode("ä¿å­˜")
                    ])),
                    _: 1
                  }, 8, ["onClick"])
                ])
              ]),
              default: withCtx(() => [
                createVNode(_component_el_table, {
                  data: unref(modelData2),
                  style: { "width": "100%" },
                  "table-layout": "auto"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_table_column, { label: "æ¨¡åž‹" }, {
                      default: withCtx((scope) => [
                        createElementVNode("div", _hoisted_1$5, [
                          createVNode(_component_el_avatar, {
                            size: 30,
                            style: normalizeStyle({ "--el-avatar-bg-color": scope.row.color })
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_icon, {
                                innerHTML: unref(llmsIcons)[scope.row.data.mode]
                              }, null, 8, ["innerHTML"])
                            ]),
                            _: 2
                          }, 1032, ["style"]),
                          createElementVNode("span", _hoisted_2$3, toDisplayString(scope.row.name), 1)
                        ])
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_table_column, {
                      prop: "data.mode",
                      label: "ç±»åž‹"
                    }),
                    createVNode(_component_el_table_column, {
                      prop: "data.url",
                      label: "url"
                    }),
                    createVNode(_component_el_table_column, { label: "ç®¡ç†" }, {
                      default: withCtx((scope) => [
                        createVNode(_component_el_button, {
                          link: "",
                          type: "primary",
                          size: "small",
                          onClick: () => del(scope.row)
                        }, {
                          default: withCtx(() => _cache[3] || (_cache[3] = [
                            createTextVNode(" åˆ é™¤ ")
                          ])),
                          _: 2
                        }, 1032, ["onClick"]),
                        createVNode(_component_el_button, {
                          link: "",
                          type: "primary",
                          size: "small",
                          onClick: () => copy(scope.row)
                        }, {
                          default: withCtx(() => _cache[4] || (_cache[4] = [
                            createTextVNode(" å¤åˆ¶ ")
                          ])),
                          _: 2
                        }, 1032, ["onClick"]),
                        createVNode(_component_el_button, {
                          link: "",
                          type: "primary",
                          size: "small",
                          onClick: () => edit(scope.row)
                        }, {
                          default: withCtx(() => _cache[5] || (_cache[5] = [
                            createTextVNode(" ç¼–è¾‘ ")
                          ])),
                          _: 2
                        }, 1032, ["onClick"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["data"]),
                createBoxShow.value ? (openBlock(), createBlock(_component_createLLM, {
                  key: 0,
                  modelValue: createBoxShow.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => createBoxShow.value = $event),
                  model: createModelData.value,
                  onCreate: create
                }, null, 8, ["modelValue", "model"])) : createCommentVNode("", true)
              ]),
              _: 1
            }, 8, ["modelValue"]);
          };
        }
      });
      const _sfc_main$8 = {};
      const _hoisted_1$4 = {
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        viewBox: "0 0 24 24"
      };
      function _sfc_render(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_1$4, _cache[0] || (_cache[0] = [
          createElementVNode("g", { fill: "none" }, [
            createElementVNode("path", {
              d: "M12.01 2.25c.735.008 1.466.093 2.182.253a.75.75 0 0 1 .582.649l.17 1.527a1.384 1.384 0 0 0 1.928 1.116l1.4-.615a.75.75 0 0 1 .85.174a9.793 9.793 0 0 1 2.204 3.792a.75.75 0 0 1-.271.825l-1.242.916a1.38 1.38 0 0 0 .001 2.226l1.243.915a.75.75 0 0 1 .271.826a9.798 9.798 0 0 1-2.203 3.792a.75.75 0 0 1-.849.175l-1.406-.617a1.38 1.38 0 0 0-1.927 1.114l-.169 1.526a.75.75 0 0 1-.571.647a9.518 9.518 0 0 1-4.406 0a.75.75 0 0 1-.572-.647l-.17-1.524a1.382 1.382 0 0 0-1.924-1.11l-1.407.616a.75.75 0 0 1-.849-.175a9.798 9.798 0 0 1-2.203-3.796a.75.75 0 0 1 .271-.826l1.244-.916a1.38 1.38 0 0 0 0-2.226l-1.243-.914a.75.75 0 0 1-.272-.826a9.793 9.793 0 0 1 2.205-3.792a.75.75 0 0 1 .849-.174l1.4.615a1.387 1.387 0 0 0 1.93-1.118l.17-1.526a.75.75 0 0 1 .583-.65c.718-.159 1.45-.243 2.202-.252zM13.576 8h-3.272l3.105 4l-2.773 3.514a.3.3 0 0 0 .236.486h2.704a.3.3 0 0 0 .237-.116l2.778-3.577a.5.5 0 0 0 0-.614l-2.778-3.577A.3.3 0 0 0 13.575 8zm-3.898.803l-2.264 2.889a.5.5 0 0 0-.052.535l.052.081l2.002 2.556l.05.05a.3.3 0 0 0 .372 0l.049-.049l1.336-1.68a.3.3 0 0 0 .043-.301l-.042-.07l-.638-.814l.78-.996l-1.688-2.201z",
              fill: "currentColor"
            })
          ], -1)
        ]));
      }
      const settingsVue = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render]]);
      const _sfc_main$7 = /* @__PURE__ */ defineComponent({
        __name: "formSwitch",
        props: {
          label: {},
          lock: { type: Boolean },
          help: {},
          disabled: { type: Boolean },
          data: {}
        },
        emits: ["change", "show"],
        setup(__props, { emit: __emit }) {
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElButtonGroup), {
              type: _ctx.data.enable ? "success" : "danger",
              help: _ctx.help
            }, {
              default: withCtx(() => [
                createVNode(unref(ElButton), {
                  disabled: _ctx.lock || _ctx.disabled,
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("change", _ctx.data))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.label), 1)
                  ]),
                  _: 1
                }, 8, ["disabled"]),
                createVNode(unref(ElButton), {
                  icon: settingsVue,
                  disabled: _ctx.disabled,
                  onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("show"))
                }, null, 8, ["disabled"])
              ]),
              _: 1
            }, 8, ["type", "help"]);
          };
        }
      });
      const _hoisted_1$3 = { style: { "margin-top": "15px" } };
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        __name: "ai",
        setup(__props) {
          const { formData: formData2, confSaving } = useConfFormData();
          const { deliverLock: deliverLock2 } = useCommon();
          const aiBoxShow = ref(false);
          const aiConfBoxShow = ref(false);
          const aiBox = ref(
            "aiGreeting"
          );
          function change(v2) {
            v2.enable = !v2.enable;
            confSaving();
          }
          const m2 = formData2.record.model || [];
          ref(Array.isArray(m2) ? m2 : [m2]);
          return (_ctx, _cache) => {
            const _component_configLLM = _sfc_main$9;
            const _component_selectLLM = _sfc_main$e;
            const _directive_key = resolveDirective("key");
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(unref(ElSpace$1), {
                wrap: "",
                fill: "",
                "fill-ratio": 32,
                style: { "width": "100%" }
              }, {
                default: withCtx(() => [
                  createVNode(_sfc_main$7, mergeProps(unref(formInfoData).aiGreeting, {
                    data: unref(formData2).aiGreeting,
                    lock: unref(deliverLock2),
                    onShow: _cache[0] || (_cache[0] = ($event) => {
                      aiBox.value = "aiGreeting";
                      aiBoxShow.value = true;
                    }),
                    onChange: change
                  }), null, 16, ["data", "lock"]),
                  createVNode(_sfc_main$7, mergeProps(unref(formInfoData).aiFiltering, {
                    data: unref(formData2).aiFiltering,
                    lock: unref(deliverLock2),
                    onShow: _cache[1] || (_cache[1] = ($event) => {
                      aiBox.value = "aiFiltering";
                      aiBoxShow.value = true;
                    }),
                    onChange: change
                  }), null, 16, ["data", "lock"]),
                  createVNode(_sfc_main$7, mergeProps(unref(formInfoData).aiReply, {
                    data: unref(formData2).aiReply,
                    onShow: _cache[2] || (_cache[2] = ($event) => {
                      aiBox.value = "aiReply";
                      aiBoxShow.value = true;
                    }),
                    onChange: change,
                    disabled: ""
                  }), null, 16, ["data"])
                ]),
                _: 1
              }),
              createElementVNode("div", _hoisted_1$3, [
                createVNode(unref(ElButton), {
                  type: "primary",
                  help: "æœ‰é‚£ä¹ˆå¤šåŠŸèƒ½ï¼Œå½“ç„¶è¦åˆ†ç­‰çº§äº†ï¼Œä¸ç„¶å²‚ä¸æ˜¯æµªè´¹äº†è¿™ä¹ˆå¤šçš„æ¨¡åž‹ï¼ˆä¸»è¦ç¼ºé’±ï¼‰",
                  onClick: _cache[3] || (_cache[3] = ($event) => aiConfBoxShow.value = true)
                }, {
                  default: withCtx(() => _cache[6] || (_cache[6] = [
                    createTextVNode(" æ¨¡åž‹é…ç½® ")
                  ])),
                  _: 1
                })
              ]),
              createVNode(_component_configLLM, {
                modelValue: aiConfBoxShow.value,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => aiConfBoxShow.value = $event)
              }, null, 8, ["modelValue"]),
              aiBoxShow.value && aiBox.value !== "record" ? withDirectives((openBlock(), createBlock(_component_selectLLM, {
                key: 0,
                data: aiBox.value,
                modelValue: aiBoxShow.value,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => aiBoxShow.value = $event)
              }, null, 8, ["data", "modelValue"])), [
                [_directive_key, aiBox.value]
              ]) : createCommentVNode("", true)
            ], 64);
          };
        }
      });
      const _sfc_main$5 = /* @__PURE__ */ defineComponent({
        __name: "formItem",
        props: /* @__PURE__ */ mergeModels({
          label: {},
          help: {},
          disabled: { type: Boolean }
        }, {
          "include": { type: Boolean, ...{
            default: void 0
          } },
          "includeModifiers": {},
          "enable": { type: Boolean, ...{ required: true } },
          "enableModifiers": {}
        }),
        emits: ["update:include", "update:enable"],
        setup(__props) {
          const include = useModel$1(__props, "include");
          const enable = useModel$1(__props, "enable");
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElFormItem$1), { help: _ctx.help }, {
              label: withCtx(() => [
                createVNode(unref(ElCheckbox$1), {
                  modelValue: enable.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => enable.value = $event),
                  label: _ctx.label,
                  size: "small"
                }, null, 8, ["modelValue", "label"]),
                include.value !== void 0 ? (openBlock(), createBlock(unref(ElLink$1), {
                  key: 0,
                  onClick: _cache[1] || (_cache[1] = withModifiers(($event) => include.value = !include.value, ["stop"])),
                  type: include.value ? "primary" : "warning",
                  size: "small",
                  disabled: _ctx.disabled
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(include.value ? "åŒ…å«" : "æŽ’é™¤"), 1)
                  ]),
                  _: 1
                }, 8, ["type", "disabled"])) : createCommentVNode("", true)
              ]),
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["help"]);
          };
        }
      });
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        __name: "formSelect",
        props: {
          "value": { required: true },
          "valueModifiers": {},
          "options": { required: true },
          "optionsModifiers": {}
        },
        emits: ["update:value", "update:options"],
        setup(__props) {
          const value = useModel$1(__props, "value");
          const options2 = useModel$1(__props, "options");
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElSelect), {
              modelValue: value.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => value.value = $event),
              multiple: "",
              filterable: "",
              "allow-create": "",
              "default-first-option": "",
              "reserve-keyword": false,
              placeholder: ""
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(options2.value, (item) => {
                  return openBlock(), createBlock(unref(ElOption), {
                    key: item,
                    label: item,
                    value: item
                  }, null, 8, ["label", "value"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["modelValue"]);
          };
        }
      });
      const _hoisted_1$2 = { style: { "margin-top": "20px", "display": "flex" } };
      const _hoisted_2$2 = { style: { "margin-top": "15px" } };
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        __name: "config",
        setup(__props) {
          const { formData: formData2, confDelete, confExport, confImport, confReload, confSaving } = useConfFormData();
          const { deliverLock: deliverLock2 } = useCommon();
          return (_ctx, _cache) => {
            const _component_el_space = ElSpace;
            const _component_el_collapse_item = ElCollapseItem;
            const _component_el_input_number = ElInputNumber;
            const _component_el_collapse = ElCollapse;
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(unref(ElForm$1), {
                ref: "formRef",
                inline: "",
                "label-position": "left",
                "label-width": "auto",
                model: unref(formData2),
                disabled: unref(deliverLock2)
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_collapse, { accordion: "" }, {
                    default: withCtx(() => [
                      createVNode(_component_el_collapse_item, {
                        title: "ç­›é€‰é…ç½®",
                        name: "1"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_space, {
                            wrap: "",
                            style: { "width": "100%" }
                          }, {
                            default: withCtx(() => [
                              createVNode(_sfc_main$5, mergeProps(unref(formInfoData).company, {
                                enable: unref(formData2).company.enable,
                                "onUpdate:enable": _cache[2] || (_cache[2] = ($event) => unref(formData2).company.enable = $event),
                                include: unref(formData2).company.include,
                                "onUpdate:include": _cache[3] || (_cache[3] = ($event) => unref(formData2).company.include = $event),
                                disabled: unref(deliverLock2)
                              }), {
                                default: withCtx(() => [
                                  createVNode(_sfc_main$4, {
                                    value: unref(formData2).company.value,
                                    "onUpdate:value": _cache[0] || (_cache[0] = ($event) => unref(formData2).company.value = $event),
                                    options: unref(formData2).company.options,
                                    "onUpdate:options": _cache[1] || (_cache[1] = ($event) => unref(formData2).company.options = $event)
                                  }, null, 8, ["value", "options"])
                                ]),
                                _: 1
                              }, 16, ["enable", "include", "disabled"]),
                              createVNode(_sfc_main$5, mergeProps(unref(formInfoData).jobTitle, {
                                enable: unref(formData2).jobTitle.enable,
                                "onUpdate:enable": _cache[6] || (_cache[6] = ($event) => unref(formData2).jobTitle.enable = $event),
                                include: unref(formData2).jobTitle.include,
                                "onUpdate:include": _cache[7] || (_cache[7] = ($event) => unref(formData2).jobTitle.include = $event),
                                disabled: unref(deliverLock2)
                              }), {
                                default: withCtx(() => [
                                  createVNode(_sfc_main$4, {
                                    value: unref(formData2).jobTitle.value,
                                    "onUpdate:value": _cache[4] || (_cache[4] = ($event) => unref(formData2).jobTitle.value = $event),
                                    options: unref(formData2).jobTitle.options,
                                    "onUpdate:options": _cache[5] || (_cache[5] = ($event) => unref(formData2).jobTitle.options = $event)
                                  }, null, 8, ["value", "options"])
                                ]),
                                _: 1
                              }, 16, ["enable", "include", "disabled"]),
                              createVNode(_sfc_main$5, mergeProps(unref(formInfoData).jobContent, {
                                enable: unref(formData2).jobContent.enable,
                                "onUpdate:enable": _cache[10] || (_cache[10] = ($event) => unref(formData2).jobContent.enable = $event),
                                include: unref(formData2).jobContent.include,
                                "onUpdate:include": _cache[11] || (_cache[11] = ($event) => unref(formData2).jobContent.include = $event),
                                disabled: unref(deliverLock2)
                              }), {
                                default: withCtx(() => [
                                  createVNode(_sfc_main$4, {
                                    value: unref(formData2).jobContent.value,
                                    "onUpdate:value": _cache[8] || (_cache[8] = ($event) => unref(formData2).jobContent.value = $event),
                                    options: unref(formData2).jobContent.options,
                                    "onUpdate:options": _cache[9] || (_cache[9] = ($event) => unref(formData2).jobContent.options = $event)
                                  }, null, 8, ["value", "options"])
                                ]),
                                _: 1
                              }, 16, ["enable", "include", "disabled"]),
                              createVNode(_sfc_main$5, mergeProps(unref(formInfoData).hrPosition, {
                                enable: unref(formData2).hrPosition.enable,
                                "onUpdate:enable": _cache[14] || (_cache[14] = ($event) => unref(formData2).hrPosition.enable = $event),
                                include: unref(formData2).hrPosition.include,
                                "onUpdate:include": _cache[15] || (_cache[15] = ($event) => unref(formData2).hrPosition.include = $event),
                                disabled: unref(deliverLock2)
                              }), {
                                default: withCtx(() => [
                                  createVNode(_sfc_main$4, {
                                    value: unref(formData2).hrPosition.value,
                                    "onUpdate:value": _cache[12] || (_cache[12] = ($event) => unref(formData2).hrPosition.value = $event),
                                    options: unref(formData2).hrPosition.options,
                                    "onUpdate:options": _cache[13] || (_cache[13] = ($event) => unref(formData2).hrPosition.options = $event)
                                  }, null, 8, ["value", "options"])
                                ]),
                                _: 1
                              }, 16, ["enable", "include", "disabled"]),
                              createVNode(_sfc_main$5, mergeProps(unref(formInfoData).salaryRange, {
                                enable: unref(formData2).salaryRange.enable,
                                "onUpdate:enable": _cache[17] || (_cache[17] = ($event) => unref(formData2).salaryRange.enable = $event)
                              }), {
                                default: withCtx(() => [
                                  createVNode(unref(ElInput$1), {
                                    modelValue: unref(formData2).salaryRange.value,
                                    "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => unref(formData2).salaryRange.value = $event)
                                  }, null, 8, ["modelValue"])
                                ]),
                                _: 1
                              }, 16, ["enable"]),
                              createVNode(_sfc_main$5, mergeProps(unref(formInfoData).companySizeRange, {
                                enable: unref(formData2).companySizeRange.enable,
                                "onUpdate:enable": _cache[19] || (_cache[19] = ($event) => unref(formData2).companySizeRange.enable = $event)
                              }), {
                                default: withCtx(() => [
                                  createVNode(unref(ElInput$1), {
                                    modelValue: unref(formData2).companySizeRange.value,
                                    "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => unref(formData2).companySizeRange.value = $event),
                                    modelModifiers: { lazy: true }
                                  }, null, 8, ["modelValue"])
                                ]),
                                _: 1
                              }, 16, ["enable"]),
                              createVNode(_sfc_main$5, mergeProps(unref(formInfoData).customGreeting, {
                                enable: unref(formData2).customGreeting.enable,
                                "onUpdate:enable": _cache[21] || (_cache[21] = ($event) => unref(formData2).customGreeting.enable = $event)
                              }), {
                                default: withCtx(() => [
                                  createVNode(unref(ElInput$1), {
                                    type: "textarea",
                                    modelValue: unref(formData2).customGreeting.value,
                                    "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => unref(formData2).customGreeting.value = $event),
                                    modelModifiers: { lazy: true }
                                  }, null, 8, ["modelValue"])
                                ]),
                                _: 1
                              }, 16, ["enable"])
                            ]),
                            _: 1
                          }),
                          createElementVNode("div", null, [
                            createVNode(unref(ElCheckbox$1), mergeProps(unref(formInfoData).activityFilter, {
                              modelValue: unref(formData2).activityFilter.value,
                              "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => unref(formData2).activityFilter.value = $event),
                              border: ""
                            }), null, 16, ["modelValue"]),
                            createVNode(unref(ElCheckbox$1), mergeProps(unref(formInfoData).goldHunterFilter, {
                              modelValue: unref(formData2).goldHunterFilter.value,
                              "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => unref(formData2).goldHunterFilter.value = $event),
                              border: ""
                            }), null, 16, ["modelValue"]),
                            createVNode(unref(ElCheckbox$1), mergeProps(unref(formInfoData).friendStatus, {
                              modelValue: unref(formData2).friendStatus.value,
                              "onUpdate:modelValue": _cache[24] || (_cache[24] = ($event) => unref(formData2).friendStatus.value = $event),
                              border: ""
                            }), null, 16, ["modelValue"])
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_collapse_item, {
                        title: "å»¶è¿Ÿé…ç½®",
                        name: "2"
                      }, {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(formInfoData).delay, (item, key) => {
                            return openBlock(), createBlock(unref(ElFormItem$1), {
                              key,
                              label: item.label,
                              help: item.help
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_el_input_number, {
                                  modelValue: unref(formData2).delay[key],
                                  "onUpdate:modelValue": ($event) => unref(formData2).delay[key] = $event,
                                  min: 1,
                                  max: 99999,
                                  disabled: item.disable
                                }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled"])
                              ]),
                              _: 2
                            }, 1032, ["label", "help"]);
                          }), 128))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  createElementVNode("div", _hoisted_1$2, [
                    createVNode(unref(ElCheckbox$1), mergeProps(unref(formInfoData).greetingVariable, {
                      modelValue: unref(formData2).greetingVariable.value,
                      "onUpdate:modelValue": _cache[25] || (_cache[25] = ($event) => unref(formData2).greetingVariable.value = $event),
                      border: ""
                    }), null, 16, ["modelValue"]),
                    createVNode(unref(ElCheckbox$1), mergeProps(unref(formInfoData).notification, {
                      modelValue: unref(formData2).notification.value,
                      "onUpdate:modelValue": _cache[26] || (_cache[26] = ($event) => unref(formData2).notification.value = $event),
                      border: ""
                    }), null, 16, ["modelValue"]),
                    createVNode(unref(ElFormItem$1), {
                      label: unref(formInfoData).deliveryLimit.label,
                      style: { "margin-left": "30px" }
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_input_number, mergeProps(unref(formInfoData).deliveryLimit, {
                          modelValue: unref(formData2).deliveryLimit.value,
                          "onUpdate:modelValue": _cache[27] || (_cache[27] = ($event) => unref(formData2).deliveryLimit.value = $event),
                          min: 1,
                          max: 1e3,
                          step: 10
                        }), null, 16, ["modelValue"])
                      ]),
                      _: 1
                    }, 8, ["label"])
                  ])
                ]),
                _: 1
              }, 8, ["model", "disabled"]),
              createElementVNode("div", _hoisted_2$2, [
                createVNode(unref(ElButton), {
                  type: "primary",
                  help: "ä¿å­˜é…ç½®ï¼Œç”¨äºŽåŽç»­ç›´æŽ¥ä½¿ç”¨å½“å‰é…ç½®ã€‚",
                  onClick: unref(confSaving)
                }, {
                  default: withCtx(() => _cache[28] || (_cache[28] = [
                    createTextVNode(" ä¿å­˜é…ç½® ")
                  ])),
                  _: 1
                }, 8, ["onClick"]),
                createVNode(unref(ElButton), {
                  type: "primary",
                  help: "é‡æ–°åŠ è½½æœ¬åœ°é…ç½®",
                  onClick: unref(confReload)
                }, {
                  default: withCtx(() => _cache[29] || (_cache[29] = [
                    createTextVNode(" é‡è½½é…ç½® ")
                  ])),
                  _: 1
                }, 8, ["onClick"]),
                createVNode(unref(ElButton), {
                  type: "primary",
                  help: "äº’è”ç½‘å°±æ˜¯è¦åˆ†äº«",
                  onClick: unref(confExport)
                }, {
                  default: withCtx(() => _cache[30] || (_cache[30] = [
                    createTextVNode(" å¯¼å‡ºé…ç½® ")
                  ])),
                  _: 1
                }, 8, ["onClick"]),
                createVNode(unref(ElButton), {
                  type: "primary",
                  help: "äº’è”ç½‘å°±æ˜¯è¦åˆ†äº«",
                  onClick: unref(confImport)
                }, {
                  default: withCtx(() => _cache[31] || (_cache[31] = [
                    createTextVNode(" å¯¼å…¥é…ç½® ")
                  ])),
                  _: 1
                }, 8, ["onClick"]),
                createVNode(unref(ElButton), {
                  type: "primary",
                  help: "æ¸…ç©ºé…ç½®,ä¸ä¼šå¸®ä½ ä¿å­˜,å¯ä»¥é‡è½½æ¢å¤",
                  onClick: unref(confDelete)
                }, {
                  default: withCtx(() => _cache[32] || (_cache[32] = [
                    createTextVNode(" åˆ é™¤é…ç½® ")
                  ])),
                  _: 1
                }, 8, ["onClick"])
              ])
            ], 64);
          };
        }
      });
      const configVue = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-2be472b2"]]);
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        __name: "logs",
        setup(__props) {
          const tableRef = ref();
          const { data: data2, columns: columns2 } = useLog();
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElAutoResizer), { disableHeight: true }, {
              default: withCtx(({ width }) => [
                createVNode(unref(ElTableV2), {
                  ref_key: "tableRef",
                  ref: tableRef,
                  columns: unref(columns2),
                  data: unref(data2),
                  height: 360,
                  width
                }, null, 8, ["columns", "data", "width"])
              ]),
              _: 1
            });
          };
        }
      });
      const page = ref({ page: 1, pageSize: 30 });
      const pageChange = ref((v2) => {
      });
      const initPage = useHookVueData("#wrap .page-job-wrapper", "pageVo", page);
      const initChange = useHookVueFn("#wrap .page-job-wrapper", "pageChangeAction");
      const next = () => {
        if (page.value.page >= 10) return;
        pageChange.value(page.value.page + 1);
      };
      const prev = () => {
        if (page.value.page <= 1) return;
        pageChange.value(page.value.page - 1);
      };
      const usePager = () => {
        return {
          page,
          pageChange,
          next,
          prev,
          initPager: () => {
            initPage();
            pageChange.value = initChange();
          }
        };
      };
      const _hoisted_1$1 = { class: "el-dropdown-link" };
      const _hoisted_2$1 = { style: { "display": "flex" } };
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        __name: "statistics",
        setup(__props) {
          const log2 = useLog();
          const { todayData: todayData2, statisticsData } = useStatistics();
          const { deliverLock: deliverLock2, deliverStop: deliverStop2 } = useCommon();
          const { jobListHandle: jobListHandle2 } = useDeliver();
          const { jobList: jobList2, jobMap: jobMap2 } = useJobList();
          const { next: next2, page: page2 } = usePager();
          const { formData: formData2 } = useConfFormData();
          const statisticCycle = ref(1);
          const statisticCycleData = [
            {
              label: "è¿‘ä¸‰æ—¥æŠ•é€’",
              help: "æ„¿ä½ æ¯ä¸€æ¬¡æŠ•é€’éƒ½èƒ½å¾—åˆ°å›žåº”",
              date: 3
            },
            {
              label: "æœ¬å‘¨æŠ•é€’",
              help: "æ„¿ä½ æ—©æ—¥æ‰¾åˆ°å¿ƒæ»¡æ„è¶³çš„å·¥ä½œ",
              date: 7
            },
            {
              label: "æœ¬æœˆæŠ•é€’",
              help: "æ„¿ä½ åœ¨é¢è¯•ä¸­å¾—åˆ°æ»¡æ„çš„ç»“æžœ",
              date: 30
            },
            {
              label: "åŽ†å²æŠ•é€’",
              help: "æ„¿ä½ èƒ½æ—©ä¹æ™šäº”è¿˜åŒä¼‘å¸¦äº”é™©",
              date: -1
            }
          ];
          const cycle = computed(() => {
            const date4 = statisticCycleData[statisticCycle.value].date;
            let ans = 0;
            for (var i = 0; (date4 == -1 || i < date4 - 1) && i < statisticsData.length; i++) {
              ans += statisticsData[i].success;
            }
            return ans;
          });
          const deliveryLimit = computed(() => {
            return formData2.deliveryLimit.value;
          });
          async function startBatch() {
            log2.reset();
            deliverLock2.value = true;
            try {
              logger.debug("start batch", page2);
              while (page2.value.page <= 10 && !deliverStop2.value) {
                await delay(formData2.delay.deliveryStarts);
                await jobListHandle2(jobList2.value, jobMap2.actions);
                if (deliverStop2.value) {
                  break;
                }
                await delay(formData2.delay.deliveryPageNext);
                next2();
                jobMap2.actions.clear();
              }
            } catch (e) {
              logger.error("èŽ·å–å¤±è´¥", e);
              ElMessage.error(`èŽ·å–å¤±è´¥! - ${e}`);
            } finally {
              logger.debug(log2.data);
              if (formData2.notification.value) {
                notification("æŠ•é€’ç»“æŸ");
              } else {
                ElMessage.info("æŠ•é€’ç»“æŸ");
              }
              deliverLock2.value = false;
              deliverStop2.value = false;
            }
          }
          function stopBatch() {
            deliverStop2.value = true;
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(unref(ElRow), { gutter: 20 }, {
                default: withCtx(() => [
                  createVNode(unref(ElCol), { span: 5 }, {
                    default: withCtx(() => [
                      createVNode(unref(ElStatistic), {
                        help: "ç»Ÿè®¡å½“å¤©è„šæœ¬æ‰«æè¿‡çš„æ‰€æœ‰å²—ä½",
                        value: unref(todayData2).total,
                        title: "å²—ä½æ€»æ•°ï¼š",
                        suffix: "ä»½"
                      }, null, 8, ["value"])
                    ]),
                    _: 1
                  }),
                  createVNode(unref(ElCol), { span: 5 }, {
                    default: withCtx(() => [
                      createVNode(unref(ElStatistic), {
                        help: "ç»Ÿè®¡å½“å¤©å²—ä½è¿‡æ»¤çš„æ¯”ä¾‹,è¢«è¿‡æ»¤/æ€»æ•°",
                        value: (unref(todayData2).total - unref(todayData2).success) / unref(todayData2).total * deliveryLimit.value,
                        title: "è¿‡æ»¤æ¯”ä¾‹ï¼š",
                        suffix: "%"
                      }, null, 8, ["value"])
                    ]),
                    _: 1
                  }),
                  createVNode(unref(ElCol), { span: 5 }, {
                    default: withCtx(() => [
                      createVNode(unref(ElStatistic), {
                        help: "ç»Ÿè®¡å½“å¤©å²—ä½ä¸­å·²æ²Ÿé€šçš„æ¯”ä¾‹,å·²æ²Ÿé€š/æ€»æ•°",
                        value: unref(todayData2).repeat / unref(todayData2).total * deliveryLimit.value,
                        title: "æ²Ÿé€šæ¯”ä¾‹ï¼š",
                        suffix: "%"
                      }, null, 8, ["value"])
                    ]),
                    _: 1
                  }),
                  createVNode(unref(ElCol), { span: 5 }, {
                    default: withCtx(() => [
                      createVNode(unref(ElStatistic), {
                        help: "ç»Ÿè®¡å½“å¤©å²—ä½ä¸­çš„æ´»è·ƒæƒ…å†µ,ä¸æ´»è·ƒ/æ€»æ•°",
                        value: unref(todayData2).activityFilter / unref(todayData2).total * deliveryLimit.value,
                        title: "æ´»è·ƒæ¯”ä¾‹ï¼š",
                        suffix: "%"
                      }, null, 8, ["value"])
                    ]),
                    _: 1
                  }),
                  createVNode(unref(ElCol), { span: 4 }, {
                    default: withCtx(() => [
                      createVNode(unref(ElStatistic), {
                        help: statisticCycleData[statisticCycle.value].help,
                        value: cycle.value + unref(todayData2).success,
                        suffix: "ä»½"
                      }, {
                        title: withCtx(() => [
                          createVNode(unref(ElDropdown), {
                            trigger: "click",
                            onCommand: _cache[0] || (_cache[0] = (arg) => {
                              statisticCycle.value = arg;
                            })
                          }, {
                            dropdown: withCtx(() => [
                              createVNode(unref(ElDropdownMenu), null, {
                                default: withCtx(() => [
                                  (openBlock(), createElementBlock(Fragment, null, renderList(statisticCycleData, (item, index) => {
                                    return createVNode(unref(ElDropdownItem), { command: index }, {
                                      default: withCtx(() => [
                                        createTextVNode(toDisplayString(item.label), 1)
                                      ]),
                                      _: 2
                                    }, 1032, ["command"]);
                                  }), 64))
                                ]),
                                _: 1
                              })
                            ]),
                            default: withCtx(() => [
                              createElementVNode("span", _hoisted_1$1, [
                                createTextVNode(toDisplayString(statisticCycleData[statisticCycle.value].label) + ": ", 1),
                                createVNode(unref(ElIcon), { class: "el-icon--right" }, {
                                  default: withCtx(() => _cache[1] || (_cache[1] = [
                                    createElementVNode("svg", {
                                      xmlns: "http://www.w3.org/2000/svg",
                                      viewBox: "0 0 1024 1024"
                                    }, [
                                      createElementVNode("path", {
                                        fill: "currentColor",
                                        d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
                                      })
                                    ], -1)
                                  ])),
                                  _: 1
                                })
                              ])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["help", "value"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createElementVNode("div", _hoisted_2$1, [
                createVNode(unref(ElButtonGroup), { style: { "margin": "10px 30px 0 0" } }, {
                  default: withCtx(() => [
                    createVNode(unref(ElButton), {
                      type: "primary",
                      help: "ç‚¹å‡»å¼€å§‹å°±ä¼šå¼€å§‹æŠ•é€’",
                      loading: unref(deliverLock2),
                      onClick: startBatch
                    }, {
                      default: withCtx(() => _cache[2] || (_cache[2] = [
                        createTextVNode(" å¼€å§‹ ")
                      ])),
                      _: 1
                    }, 8, ["loading"]),
                    unref(deliverLock2) && !unref(deliverStop2) ? (openBlock(), createBlock(unref(ElButton), {
                      key: 0,
                      type: "warning",
                      help: "æš‚åœåŽåº”è¯¥èƒ½ç»§ç»­",
                      onClick: stopBatch
                    }, {
                      default: withCtx(() => _cache[3] || (_cache[3] = [
                        createTextVNode(" æš‚åœ ")
                      ])),
                      _: 1
                    })) : createCommentVNode("", true),
                    unref(deliverLock2) && !unref(deliverStop2) ? (openBlock(), createBlock(unref(ElButton), {
                      key: 1,
                      type: "danger",
                      help: "åœæ­¢åŽåº”è¯¥ä¸èƒ½ç»§ç»­",
                      onClick: stopBatch
                    }, {
                      default: withCtx(() => _cache[4] || (_cache[4] = [
                        createTextVNode(" åœæ­¢ ")
                      ])),
                      _: 1
                    })) : createCommentVNode("", true)
                  ]),
                  _: 1
                }),
                createVNode(unref(ElProgress), {
                  help: "æˆ‘ä¼šç»Ÿè®¡å½“å¤©è„šæœ¬æŠ•é€’çš„æ•°é‡,è¯¥è®°å½•å¹¶ä¸å‡†ç¡®",
                  style: { "flex": "1" },
                  percentage: unref(todayData2).success / deliveryLimit.value
                }, null, 8, ["percentage"])
              ])
            ], 64);
          };
        }
      });
      const netConf = ref();
      fetch("https://qiu-config.oss-cn-beijing.aliyuncs.com/boos-helper-config.json").then((res) => {
        return res.json();
      }).then((data2) => {
        var _a;
        netConf.value = data2;
        const now2 = (/* @__PURE__ */ new Date()).getTime();
        (_a = netConf.value) == null ? void 0 : _a.notification.forEach((item) => {
          if (now2 > _GM_getValue(`netConf-${item.key}`, 0)) {
            if (item.type === "message") {
              ElMessageBox.alert(item.data.content, item.data.title ?? "message", {
                confirmButtonText: "OK",
                callback: () => {
                  _GM_setValue(
                    `netConf-${item.key}`,
                    now2 + (item.data.duration ?? 86400) * 1e3
                  );
                }
              });
            } else if (item.type === "notification") {
              ElNotification({
                ...item.data,
                duration: 0,
                onClose() {
                  _GM_setValue(
                    `netConf-${item.key}`,
                    now2 + (item.data.duration ?? 86400) * 1e3
                  );
                },
                onClick() {
                  item.data.url ?? window.open(item.data.url);
                }
              });
            }
          }
        });
      });
      const _hoisted_1 = { style: { "display": "flex", "align-items": "center" } };
      const _hoisted_2 = { key: 0 };
      const _hoisted_3 = {
        key: 0,
        class: "netAlerts"
      };
      const _sfc_main = /* @__PURE__ */ defineComponent({
        __name: "ui",
        setup(__props) {
          const { initPager } = usePager();
          const { initJobList } = useJobList();
          const { x: x2, y } = useMouse({ type: "client" });
          const { total: total2, current: current2 } = useDeliver();
          const helpVisible = ref(false);
          const searchRef = ref();
          const tabsRef = ref();
          const helpContent = ref("é¼ æ ‡ç§»åˆ°å¯¹åº”å…ƒç´ æŸ¥çœ‹æç¤º");
          const helpElWidth = ref(400);
          const { isOutside } = useMouseInElement(tabsRef);
          const triggerRef = computed(() => {
            return {
              getBoundingClientRect() {
                return DOMRect.fromRect({
                  width: 0,
                  height: 0,
                  x: x2.value,
                  y: y.value
                });
              }
            };
          });
          const boxStyles = computed(() => {
            if (helpVisible.value && !isOutside.value) {
              const element = document.elementFromPoint(x2.value, y.value);
              const el = findHelp(element);
              if (el) {
                const bounding = el.getBoundingClientRect();
                helpElWidth.value = bounding.width;
                return {
                  width: `${bounding.width}px`,
                  height: `${bounding.height}px`,
                  left: `${bounding.left}px`,
                  top: `${bounding.top}px`,
                  display: "block",
                  backgroundColor: "#3eaf7c33",
                  transition: "all 0.08s linear"
                };
              }
            }
            return {
              display: "none"
            };
          });
          function findHelp(dom) {
            if (!dom) return;
            const help = dom.getAttribute("help");
            if (help) {
              helpContent.value = help;
              return dom;
            }
            return findHelp(dom.parentElement);
          }
          onMounted(() => {
            initJobList();
            initPager();
            elmGetter.get([
              ".job-search-wrapper .job-search-box.clearfix",
              ".job-search-wrapper .search-condition-wrapper.clearfix"
            ]).then(([searchEl, conditionEl]) => {
              searchRef.value.$el.appendChild(searchEl);
              searchRef.value.$el.appendChild(conditionEl);
              elmGetter.rm(".job-search-scan", searchEl);
            });
          });
          function tagOpen(url2) {
            window.open(url2);
          }
          const VITE_VERSION = "0.3.2";
          const now2 = (/* @__PURE__ */ new Date()).getTime();
          return (_ctx, _cache) => {
            var _a;
            const _component_el_tag = ElTag;
            const _component_el_badge = ElBadge;
            const _component_el_alert = ElAlert;
            const _component_el_link = ElLink;
            return openBlock(), createElementBlock(Fragment, null, [
              createElementVNode("h2", _hoisted_1, [
                _cache[4] || (_cache[4] = createTextVNode(" Boos-Helper ")),
                createVNode(_component_el_badge, {
                  "is-dot": (((_a = unref(netConf)) == null ? void 0 : _a.version) ?? "6") > unref(VITE_VERSION),
                  offset: [-2, 7],
                  onClick: _cache[0] || (_cache[0] = ($event) => tagOpen("https://greasyfork.org/zh-CN/scripts/491340")),
                  style: { "cursor": "pointer", "display": "inline-flex", "margin": "0 4px" }
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_tag, { type: "primary" }, {
                      default: withCtx(() => [
                        createTextVNode("v" + toDisplayString(unref(VITE_VERSION)), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["is-dot"]),
                unref(total2) > 0 ? (openBlock(), createElementBlock("span", _hoisted_2, toDisplayString(unref(current2) + 1) + "/" + toDisplayString(unref(total2)), 1)) : createCommentVNode("", true)
              ]),
              createElementVNode("div", {
                style: normalizeStyle([{ "z-index": "999", "position": "fixed", "pointer-events": "none", "border-width": "1px" }, boxStyles.value])
              }, null, 4),
              unref(netConf) && unref(netConf).notification ? (openBlock(), createElementBlock("div", _hoisted_3, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(netConf).notification.filter(
                  (item) => item.type === "alert"
                ), (item) => {
                  return openBlock(), createElementBlock(Fragment, {
                    key: item.key ?? item.data.title
                  }, [
                    unref(now2) > unref(_GM_getValue)(`netConf-${item.key}`, 0) ? (openBlock(), createBlock(_component_el_alert, mergeProps({
                      key: 0,
                      ref_for: true
                    }, item.data, {
                      onClose: ($event) => unref(_GM_setValue)(`netConf-${item.key}`, unref(now2) + 2592e5)
                    }), null, 16, ["onClose"])) : createCommentVNode("", true)
                  ], 64);
                }), 128))
              ])) : createCommentVNode("", true),
              createVNode(unref(ElTooltip$1), {
                visible: helpVisible.value && !unref(isOutside),
                "virtual-ref": triggerRef.value
              }, {
                content: withCtx(() => [
                  createElementVNode("div", {
                    style: normalizeStyle(`width: auto;max-width:${helpElWidth.value}px;font-size:17px;`)
                  }, toDisplayString(helpContent.value), 5)
                ]),
                _: 1
              }, 8, ["visible", "virtual-ref"]),
              createVNode(unref(ElTabs), {
                ref_key: "tabsRef",
                ref: tabsRef,
                help: "é¼ æ ‡ç§»åˆ°å¯¹åº”å…ƒç´ æŸ¥çœ‹æç¤º"
              }, {
                default: withCtx(() => [
                  createVNode(unref(ElTabPane), {
                    label: "ç»Ÿè®¡",
                    help: "å¤±è´¥æ˜¯æˆåŠŸå¥¹å¦ˆ"
                  }, {
                    default: withCtx(() => [
                      createVNode(_sfc_main$1)
                    ]),
                    _: 1
                  }),
                  createVNode(unref(ElTabPane), {
                    label: "æœç´¢",
                    ref_key: "searchRef",
                    ref: searchRef,
                    help: "boosç›´è˜åŽŸæœç´¢, å¯èƒ½å‡ºçŽ°ç©ºç™½bug"
                  }, null, 512),
                  createVNode(unref(ElTabPane), {
                    label: "ç­›é€‰",
                    help: "å¥½å¥½çœ‹ï¼Œå¥½å¥½å­¦"
                  }, {
                    default: withCtx(() => [
                      createVNode(configVue)
                    ]),
                    _: 1
                  }),
                  createVNode(unref(ElTabPane), {
                    label: "AI",
                    help: "AIæ—¶ä»£ï¼Œè„šæœ¬æ€Žä¹ˆèƒ½è½ä¼!"
                  }, {
                    default: withCtx(() => [
                      createVNode(_sfc_main$6)
                    ]),
                    _: 1
                  }),
                  createVNode(unref(ElTabPane), {
                    label: "æ—¥å¿—",
                    help: "åæ­£ä½ ä¹Ÿä¸çœ‹"
                  }, {
                    default: withCtx(() => [
                      createVNode(_sfc_main$2)
                    ]),
                    _: 1
                  }),
                  createVNode(unref(ElTabPane), {
                    label: "å…³äºŽ",
                    class: "hp-about-box",
                    help: "é¡¹ç›®æ˜¯å†™ä¸å®Œç¾Žçš„,ä½†æ€»è¦åŽ»è¿½æ±‚å®Œç¾Ž"
                  }, {
                    default: withCtx(() => [
                      createVNode(_sfc_main$f)
                    ]),
                    _: 1
                  }),
                  unref(netConf) && unref(netConf).feedback ? (openBlock(), createBlock(unref(ElTabPane), { key: 0 }, {
                    label: withCtx(() => [
                      createVNode(_component_el_link, {
                        size: "large",
                        onClick: _cache[1] || (_cache[1] = withModifiers(($event) => tagOpen(unref(netConf).feedback), ["stop"])),
                        style: { "height": "100%" }
                      }, {
                        default: withCtx(() => _cache[5] || (_cache[5] = [
                          createTextVNode(" åé¦ˆ ")
                        ])),
                        _: 1
                      })
                    ]),
                    _: 1
                  })) : createCommentVNode("", true),
                  createVNode(unref(ElTabPane), null, {
                    label: withCtx(() => [
                      createVNode(unref(ElCheckbox$1), {
                        modelValue: helpVisible.value,
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => helpVisible.value = $event),
                        label: "å¸®åŠ©",
                        size: "large",
                        onClick: _cache[3] || (_cache[3] = withModifiers(() => {
                        }, ["stop"]))
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 512),
              (openBlock(), createBlock(Teleport$1, { to: ".page-job-inner .page-job-content" }, [
                createVNode(cardVue)
              ])),
              (openBlock(), createBlock(Teleport$1, { to: ".page-job-wrapper" }, [
                createVNode(chatVue, { style: { "position": "fixed", "top": "70px", "left": "20px", "height": "calc(100vh - 80px)", "display": "flex", "flex-direction": "column", "width": "28%", "max-width": "540px" } })
              ]))
            ], 64);
          };
        }
      });
      async function mountVue() {
        const jobSearchWrapper = await elmGetter.get(".job-search-wrapper");
        if (document.querySelector("#boos-helper-job")) {
          return;
        }
        const app = createApp(_sfc_main);
        const jobEl = document.createElement("div");
        jobEl.id = "boos-helper-job";
        jobSearchWrapper.insertBefore(jobEl, jobSearchWrapper.firstElementChild);
        jobSearchWrapper.setAttribute("help", "å‡ºç•Œäº†å“‡!");
        app.mount(jobEl);
      }
      function removeAd() {
        elmGetter.rm(".job-list-wrapper .subscribe-weixin-wrapper");
        elmGetter.rm(".job-side-wrapper");
        elmGetter.rm(".side-bar-box");
        elmGetter.rm(".go-login-btn");
      }
      async function run() {
        logger.info("åŠ è½½/web/geek/jobé¡µé¢Hook");
        removeAd();
        mountVue();
      }

    })
  };
}));

System.import("./__entry.js", "./");