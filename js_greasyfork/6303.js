// ==UserScript==
// @name               iciba划词翻译
// @namespace          noe132.com
// @author             noe132
// @include            http://*
// @include            https://*
// @include            file://*
// @exclude            http://www.iciba.com*
// @grant              GM_xmlhttpRequest
// @grant              GM_getValue
// @grant              GM_setValue
// @grant              GM_registerMenuCommand
// @grant              GM.xmlHttpRequest
// @grant              GM.getValue
// @grant              GM.setValue
// @grant              unsafeWindow
// @license            MIT
// @icon               http://tb.himg.baidu.com/sys/portrait/item/d4346e6f65313332ac06
// @version            4.11.18
// @supportURL         https://github.com/Firefox-Pro-Coding/iciba-translate-userscript
// @description        小巧简洁实用的划词翻译。选择单词或段落进行查词或翻译，或手动输入文本查词翻译。支持iciba，google字典，google翻译，百度翻译等多个查词翻译接口
// @downloadURL https://update.greasyfork.org/scripts/6303/iciba%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91.user.js
// @updateURL https://update.greasyfork.org/scripts/6303/iciba%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91.meta.js
// ==/UserScript==

// this file was compiled by webpack.

// corejs@3 polyfill bug in tampermonkey env
if (!window.Symbol) {
  window.Symbol = unsafeWindow.Symbol
}


var Promise = Reflect.getPrototypeOf(Response.prototype.text().catch(() => {})).constructor;
window.Promise = Promise;
var self = window;
if (typeof GM !== 'undefined' || typeof GM_setValue !== 'undefined') {
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 6040:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".the-app[data-v-63465bcb]{color:#000;font-family:Source Han Sans SC,Microsoft Yahei UI,Microsoft Yahei,Arial,sans-serif;font-size:16px;font-weight:400;line-height:1.5}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 1517:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "*,:after,:before{--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(33,150,243,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.visible{visibility:visible}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.inset-0{bottom:0;left:0;right:0;top:0}.right-0{right:0}.top-auto{top:auto}.left-auto{left:auto}.bottom-0{bottom:0}.z-20{z-index:20}.m-2px{margin:2px}.my-1{margin-bottom:4px;margin-top:4px}.my-2px{margin-bottom:2px;margin-top:2px}.mx-2{margin-left:8px;margin-right:8px}.my-px{margin-bottom:1px;margin-top:1px}.my-2{margin-bottom:8px;margin-top:8px}.mr-2{margin-right:8px}.mt-6{margin-top:24px}.mt-1{margin-top:4px}.mb-0{margin-bottom:0}.mr-4{margin-right:16px}.mb-1{margin-bottom:4px}.mt-4{margin-top:16px}.ml-1{margin-left:4px}.mt-2px{margin-top:2px}.ml-2{margin-left:8px}.mb-2px{margin-bottom:2px}.mb-2{margin-bottom:8px}.mt-0{margin-top:0}.mt-2{margin-top:8px}.-mt-2px{margin-top:-2px}.mt-5{margin-top:20px}.mt-12{margin-top:48px}.mb-3px{margin-bottom:3px}.mt-6px{margin-top:6px}.mt-3px{margin-top:3px}.mr-1{margin-right:4px}.mr-3{margin-right:12px}.mt-8{margin-top:32px}.ml-2px{margin-left:2px}.mt-5px{margin-top:5px}.mr-5px{margin-right:5px}.ml-5px{margin-left:5px}.mt-px{margin-top:1px}.ml-4{margin-left:16px}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.hidden{display:none}.h-0{height:0}.h-auto{height:auto}.w-full{width:100%}.w-0{width:0}.w-6{width:24px}.flex-1{flex:1 1 0%}.flex-auto{flex:1 1 auto}.flex-none{flex:none}.grow-0{flex-grow:0}.grow{flex-grow:1}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.cursor-pointer{cursor:pointer}.select-none{user-select:none}.resize{resize:both}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.items-start{align-items:flex-start}.items-center{align-items:center}.items-stretch{align-items:stretch}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.justify-around{justify-content:space-around}.self-start{align-self:flex-start}.self-stretch{align-self:stretch}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-visible{overflow:visible}.overflow-x-hidden{overflow-x:hidden}.overflow-y-scroll{overflow-y:scroll}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.break-words{overflow-wrap:break-word}.rounded-full{border-radius:9999px}.rounded-6{border-radius:6px}.rounded-4{border-radius:4px}.rounded-5{border-radius:5px}.border-b{border-bottom-width:1px}.border-l{border-left-width:1px}.border-t{border-top-width:1px}.border-grey-300{border-color:#e0e0e0}.border-grey-350{border-color:#d5d5d5}.border-grey-400{border-color:#bdbdbd}.bg-grey-200{background-color:#eee}.bg-white{background-color:#fff}.bg-blue-700{background-color:#1976d2}.bg-grey-400{background-color:#bdbdbd}.bg-indigo-500{background-color:#3f51b5}.bg-bg-5{background-color:#f7f7f7}.bg-grey-300{background-color:#e0e0e0}.bg-grey-500{background-color:#9e9e9e}.p-2{padding:8px}.p-4{padding:16px}.p-10px{padding:10px}.py-5px{padding-bottom:5px;padding-top:5px}.px-2{padding-left:8px;padding-right:8px}.px-4{padding-left:16px;padding-right:16px}.py-3{padding-bottom:12px;padding-top:12px}.py-4{padding-bottom:16px;padding-top:16px}.px-3{padding-left:12px;padding-right:12px}.py-1{padding-bottom:4px;padding-top:4px}.py-10px{padding-bottom:10px;padding-top:10px}.px-1{padding-left:4px;padding-right:4px}.px-5{padding-left:20px;padding-right:20px}.py-px{padding-bottom:1px;padding-top:1px}.px-6px{padding-left:6px;padding-right:6px}.pr-10px{padding-right:10px}.pt-2{padding-top:8px}.pl-10px{padding-left:10px}.pr-14px{padding-right:14px}.pt-1{padding-top:4px}.pr-12{padding-right:48px}.pr-6{padding-right:24px}.pt-5{padding-top:20px}.pb-7{padding-bottom:28px}.pr-5{padding-right:20px}.pr-7{padding-right:28px}.pr-6px{padding-right:6px}.pr-3px{padding-right:3px}.pr-1{padding-right:4px}.pt-2px{padding-top:2px}.pl-1{padding-left:4px}.pr-2{padding-right:8px}.pt-4{padding-top:16px}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-14{font-size:14px}.text-20{font-size:20px}.text-12{font-size:12px}.text-16{font-size:16px}.text-13{font-size:13px}.text-15{font-size:15px}.text-28{font-size:28px}.text-18{font-size:18px}.text-0{font-size:0}.font-medium{font-weight:500}.font-bold{font-weight:700}.italic{font-style:italic}.leading-relaxed{line-height:1.625}.leading-normal{line-height:1.5}.leading-snug{line-height:1.375}.text-grey-700{color:#616161}.text-grey-400{color:#bdbdbd}.text-grey-800{color:#424242}.text-grey-600{color:#757575}.text-white{color:#fff}.text-grey-500{color:#9e9e9e}.text-gray-800{color:#1f2937}.text-primary{color:#409eff}.text-grey-900{color:#212121}.text-red-500{color:#f44336}.text-blue-500{color:#2196f3}.text-link{color:#77a9dd}.text-orange-400{color:#ffa726}.text-green-600{color:#43a047}.text-red-400{color:#ef5350}.no-underline{text-decoration-line:none}.opacity-75{opacity:.75}.shadow-8{--tw-shadow:0px 5px 5px -3px rgba(0,0,0,.2),0px 8px 10px 1px rgba(0,0,0,.14),0px 3px 14px 2px rgba(0,0,0,.12);--tw-shadow-colored:0px 5px 5px -3px var(--tw-shadow-color),0px 8px 10px 1px var(--tw-shadow-color),0px 3px 14px 2px var(--tw-shadow-color)}.shadow-16,.shadow-8{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.shadow-16{--tw-shadow:0px 8px 10px -5px rgba(0,0,0,.2),0px 16px 24px 2px rgba(0,0,0,.14),0px 6px 30px 5px rgba(0,0,0,.12);--tw-shadow-colored:0px 8px 10px -5px var(--tw-shadow-color),0px 16px 24px 2px var(--tw-shadow-color),0px 6px 30px 5px var(--tw-shadow-color)}.shadow-2{--tw-shadow:0px 3px 1px -2px rgba(0,0,0,.2),0px 2px 2px 0px rgba(0,0,0,.14),0px 1px 5px 0px rgba(0,0,0,.12);--tw-shadow-colored:0px 3px 1px -2px var(--tw-shadow-color),0px 2px 2px 0px var(--tw-shadow-color),0px 1px 5px 0px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.outline-none{outline:2px solid transparent;outline-offset:2px}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition{transition-duration:.15s;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1)}.transition-transform{transition-duration:.15s;transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1)}.transition-opacity{transition-duration:.15s;transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1)}.duration-300{transition-duration:.3s}.duration-100{transition-duration:.1s}.duration-150{transition-duration:.15s}.duration-200{transition-duration:.2s}.ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.ease-linear{transition-timing-function:linear}.hover\\:bg-grey-100:hover{background-color:#f5f5f5}.hover\\:bg-bg-2:hover,.hover\\:bg-grey-300:hover{background-color:#e0e0e0}.hover\\:text-primary:hover{color:#409eff}.hover\\:text-grey-600:hover{color:#757575}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:opacity-100:hover{opacity:1}.group:hover .group-hover\\:bg-grey-300{background-color:#e0e0e0}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 9615:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".flex-col{display:flex}.flex-center{align-items:center;justify-content:center}html{-webkit-text-size-adjust:100%;box-sizing:border-box;overflow-y:scroll}*,:after,:before{border:0 solid #e2e8f0;box-sizing:inherit}:after,:before{text-decoration:inherit;vertical-align:inherit}*{background-repeat:no-repeat;box-sizing:border-box;margin:0;padding:0}audio:not([controls]){display:none;height:0}hr{overflow:visible}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}summary{display:list-item}small{font-size:80%}[hidden],template{display:none}abbr[title]{border-bottom:1px dotted;text-decoration:none}a{-webkit-text-decoration-skip:objects;background-color:initial}a:active,a:hover{outline-width:0}code,kbd,pre,samp{font-family:monospace,monospace}b,strong{font-weight:bolder}dfn{font-style:italic}mark{background-color:#ff0;color:#000}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:initial}sub{bottom:-.25em}sup{top:-.5em}input{border-radius:0}[type=button],[type=reset],[type=submit] [role=button],button{cursor:pointer}[disabled]{cursor:default}[type=number]{width:auto}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}textarea{overflow:auto;resize:vertical}button,input,optgroup,select,textarea{font:inherit}optgroup{font-weight:700}button{overflow:visible}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:0;padding:0}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button:-moz-focusring{border:0;outline:0}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}button,select{text-transform:none}button,input,select,textarea{background-color:initial;border-style:none;color:inherit}select{-moz-appearance:none;-webkit-appearance:none}select::-ms-expand{display:none}select::-ms-value{color:currentColor}legend{border:0;color:inherit;display:table;max-width:100%;white-space:normal}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}img{border-style:none}progress{vertical-align:initial}svg:not(:root){overflow:hidden}audio,canvas,progress,video{display:inline-block}@media screen{[hidden~=screen]{display:inherit}[hidden~=screen]:not(:active):not(:focus):not(:target){clip:rect(0 0 0 0)!important;position:absolute!important}}[aria-busy=true]{cursor:progress}[aria-controls]{cursor:pointer}[aria-disabled]{cursor:default}::-moz-selection{background-color:#b3d4fc;color:#000;text-shadow:none}::selection{background-color:#b3d4fc;color:#000;text-shadow:none}.v-ripple__container{border-radius:inherit;contain:strict;height:100%;width:100%;z-index:0}.v-ripple__animation,.v-ripple__container{color:inherit;left:0;overflow:hidden;pointer-events:none;position:absolute;top:0}.v-ripple__animation{background:currentColor;border-radius:50%;opacity:0;will-change:transform,opacity}.v-ripple__animation--enter{transition:none}.v-ripple__animation--in{transition:transform .25s cubic-bezier(.4,0,.2,1),opacity .1s cubic-bezier(.4,0,.2,1)}.v-ripple__animation--out{transition:opacity .3s cubic-bezier(.4,0,.2,1)}a{color:#1976d2}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 4196:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".icon-box[data-v-fc866c20]{cursor:pointer;height:48px;width:48px}.icon-box[data-v-fc866c20]:hover{background:#ddd}.check-icon[data-v-fc866c20]{height:20px;right:0;top:0;width:20px}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 367:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".scrollable .scroll-bar-track[data-v-5ec67402]{bottom:3px;top:3px;width:12px;z-index:200}.scrollable .scroll-bar-track .scroll-bar-thumb[data-v-5ec67402]{background:rgba(0,0,0,.15);cursor:pointer;height:0;left:3px;top:0;transition-property:width,left;width:6px}.scrollable .scroll-bar-track.moving .scroll-bar-thumb[data-v-5ec67402],.scrollable .scroll-bar-track:hover .scroll-bar-thumb[data-v-5ec67402]{background:rgba(0,0,0,.25);left:2px;width:8px}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 6641:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".icon[data-v-5a9d8295]{height:24px;width:24px}.icon .ripple[data-v-5a9d8295]{height:48px;left:50%;pointer-events:none;top:50%;transform:translate(-50%,-50%);width:48px}.icon .ripple.checked[data-v-5a9d8295] .v-ripple__container{color:#1976d2}.icon .ripple .ripple-trigger[data-v-5a9d8295]{height:24px;left:50%;pointer-events:all;top:50%;transform:translate(-50%,-50%);width:24px}.icon .ripple[data-v-5a9d8295] .v-ripple__container{height:48px;width:48px}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 8529:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".input[data-v-3651d216]{width:200px}.input[data-v-3651d216]:focus{outline:2px solid #48f}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 5071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".modal-component[data-v-76591e7d]{background:rgba(0,0,0,.3)}.modal-component.m-enter-from[data-v-76591e7d],.modal-component.m-leave-to[data-v-76591e7d]{background:transparent}.modal-component.m-enter-from .modal-container[data-v-76591e7d],.modal-component.m-leave-to .modal-container[data-v-76591e7d]{opacity:0}.modal-component.m-enter-from .modal-container[data-v-76591e7d]{transform:scale(.9)}.modal-component.m-enter-to[data-v-76591e7d],.modal-component.m-leave-from[data-v-76591e7d]{background:rgba(0,0,0,.3)}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 3195:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".icon[data-v-86d4bb56]{height:24px;width:24px}.icon .ripple[data-v-86d4bb56]{height:48px;left:50%;pointer-events:none;top:50%;transform:translate(-50%,-50%);width:48px}.icon .ripple.checked[data-v-86d4bb56] .v-ripple__container{color:#1976d2}.icon .ripple .ripple-trigger[data-v-86d4bb56]{height:24px;left:50%;pointer-events:all;top:50%;transform:translate(-50%,-50%);width:24px}.icon .ripple[data-v-86d4bb56] .v-ripple__container{height:48px;width:48px}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 2053:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".track[data-v-629e59a4]{height:32px}.track-left[data-v-629e59a4],.track-right[data-v-629e59a4]{height:2px;width:50%}.notch[data-v-629e59a4]{height:15px;top:50%;transform:translate(-50%,-50%);transition-property:width,height;width:15px}.notch.dragging[data-v-629e59a4]{height:0;width:0}.bubble[data-v-629e59a4]{border-radius:50% 50% 0;height:26px;margin-left:-13px;top:50%;transform:translate(-50%,-150%) rotate(45deg) scale(0);transform-origin:100% 100%;width:26px}.bubble.dragging[data-v-629e59a4]{transform:translate(-50%,-150%) rotate(45deg)}.bubble .text[data-v-629e59a4]{transform:rotate(-45deg)}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 4460:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".i-tabs-items .window-container{min-height:100%;overflow:hidden;transition-property:height;width:100%}.i-tabs-items .vnode-window{width:100%}.i-tabs-items .vnode-window.animating{transition:.3s ease}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 3102:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".i-tabs{-moz-user-select:none;user-select:none}.i-tabs .slider{background:hsla(0,0%,100%,.6);width:3px}.i-tabs .tab{color:hsla(0,0%,100%,.7);cursor:pointer;font-weight:500;line-height:22px;padding:12px;text-transform:uppercase;transition:color .1s ease}.i-tabs .tab.active{color:#fff}.i-tabs .tab .active-ripple .v-ripple__animation--in{opacity:.25!important}.i-tabs .tab .inactive-ripple .v-ripple__animation--in{opacity:.2}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 1464:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".input[data-v-16445f67]{border-bottom:2px solid #757575;outline:0;width:200px}.input[data-v-16445f67]:focus{border-bottom:2px solid #48f}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".scroll-container[data-v-97a84f04]{max-height:250px}.language-select-box .title-box .cancel-button[data-v-97a84f04]{cursor:pointer;padding:1px 6px}.language-select-box .title-box .cancel-button[data-v-97a84f04]:hover{background:#e0e0e0}.language-select-box .language-item[data-v-97a84f04]{cursor:pointer;flex:0 0 33.3333%;padding:1px 0}.language-select-box .language-item.active[data-v-97a84f04]{background:#e8e8e8}.language-select-box .language-item[data-v-97a84f04]:hover{background:#e0e0e0}.bottom-info-box .language-info-box[data-v-97a84f04]{color:#bbb;-moz-user-select:none;user-select:none}.bottom-info-box .language-info-box .language[data-v-97a84f04]{cursor:pointer}.bottom-info-box .language-info-box .language[data-v-97a84f04]:hover{color:#409eff}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 9941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".app-info-text-input[data-v-529beb18] .label{width:120px}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 7066:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".scroll-container[data-v-27d91445]{max-height:250px}.language-select-box .title-box .cancel-button[data-v-27d91445]{cursor:pointer;padding:1px 6px}.language-select-box .title-box .cancel-button[data-v-27d91445]:hover{background:#e0e0e0}.language-select-box .language-item[data-v-27d91445]{cursor:pointer;flex:0 0 33.3333%;padding:1px 0}.language-select-box .language-item.active[data-v-27d91445]{background:#e8e8e8}.language-select-box .language-item[data-v-27d91445]:hover{background:#e0e0e0}.bottom-info-box .tts-box[data-v-27d91445]{opacity:.9;-moz-user-select:none;user-select:none}.bottom-info-box .tts-box .play-sound[data-v-27d91445]{cursor:pointer;opacity:.45}.bottom-info-box .tts-box .play-sound .audio-icon[data-v-27d91445]{margin:0 0 0 2px;opacity:.8}.bottom-info-box .tts-box .play-sound[data-v-27d91445]:hover{opacity:.7}.bottom-info-box .tts-box .play-sound[data-v-27d91445]:active{background-position:center calc(50% + 1px);opacity:1}.bottom-info-box .language-info-box[data-v-27d91445]{color:#bbb;-moz-user-select:none;user-select:none}.bottom-info-box .language-info-box .language[data-v-27d91445]{cursor:pointer}.bottom-info-box .language-info-box .language[data-v-27d91445]:hover{color:#409eff}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 8038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".google-dict-box[data-v-21539aa9]{font-family:Arial,Microsoft Yahei UI,sans-serif}.scroll-container[data-v-21539aa9]{max-height:250px}.expand-button[data-v-21539aa9]{cursor:pointer;height:24px;opacity:.3;right:5px;top:5px;width:24px;z-index:2}.expand-button.with-scroll-bar[data-v-21539aa9]{right:12px}.expand-button[data-v-21539aa9]:hover{opacity:.6}.expand-button[data-v-21539aa9]:active{opacity:.9}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 1543:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".google-dict-modal[data-v-ea3555cc]{font-family:Arial,Microsoft Yahei UI,sans-serif;height:100vh;max-width:800px;width:80vw}.fold-control[data-v-ea3555cc]{left:50%;top:0;transform:translate(-50%)}.fold-control .control-btn[data-v-ea3555cc]{height:32px;width:32px}.fold-control .control-btn.disable[data-v-ea3555cc]{opacity:.2;pointer-events:none}.fold-control .control-btn[data-v-ea3555cc]:hover{background-color:#f0f0f0}.fold-control .control-btn:hover .tooltip[data-v-ea3555cc]{opacity:1}.fold-control .control-btn[data-v-ea3555cc]:active{box-shadow:inset 0 1px 3px rgba(0,0,0,.3)}.fold-control .tooltip[data-v-ea3555cc]{background:rgba(0,0,0,.5);border-radius:4px;bottom:-8px;color:#fff;font-size:12px;left:50%;opacity:0;padding:1px 6px;pointer-events:none;position:absolute;transform:translate(-50%,100%);transition:.3s cubic-bezier(.4,0,.2,1)}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 2942:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".phonetics-box[data-v-80abc988]{font-family:Noto Sans,Arial,sans-serif;height:20px;line-height:20px}.phonetics-box .play-button[data-v-80abc988]{cursor:pointer;height:20px;opacity:.45;width:22px}.phonetics-box .play-button[data-v-80abc988]:hover{opacity:.7}.phonetics-box .play-button[data-v-80abc988]:active{background-position:center calc(50% + 1px);opacity:1}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 6646:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".entry-item .sense-item-number[data-v-13c640e0]{flex:0 0 30px}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 1995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".image-loader.loading[data-v-c0604a02]{border-radius:4px;box-shadow:0 0 0 3px #e9f4fb}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 2015:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".label-box.size-small[data-v-58734797] .label{font-size:12px;padding:1px 4px}.label-box.size-medium[data-v-58734797] .label{font-size:12px;padding:2px 6px}.label-box.size-large[data-v-58734797] .label{font-size:14px;padding:3px 8px}.label-box.color-plain[data-v-58734797] .label{background:#f0f0f0}.label-box.color-lightpink[data-v-58734797] .label{background:#fbe0e0}.label-box.color-lightblue[data-v-58734797] .label{background:#d7eaf9}.label-box.color-geographic[data-v-58734797] .label{background:#ddf7ba;text-transform:uppercase}.label-box.color-register[data-v-58734797] .label,.label-box.color-registers[data-v-58734797] .label{background:#f0f0f0;text-transform:uppercase}.label-box.color-subject[data-v-58734797] .label{background:#f2e0fa;text-transform:uppercase}.label-box .label[data-v-58734797]{margin-right:5px}.label-box .label.last[data-v-58734797]{margin-right:0}.label-box .label .tooltip[data-v-58734797]{background:rgba(0,0,0,.5);filter:drop-shadow(0 0 .5px black);line-height:16px;margin-right:-7px;padding:0 4px 0 3px;pointer-events:none;right:0;top:50%;transform:translate(100%,-50%);transition:.12s;white-space:nowrap;z-index:200000}.label-box .label .tooltip[data-v-58734797]:after{border:6px solid transparent;border-right-color:rgba(0,0,0,.5);content:\"\";left:0;margin-left:1px;position:absolute;top:50%;transform:translate(-100%,-50%);z-index:1}.label-box .label .tooltip.p-enter[data-v-58734797],.label-box .label .tooltip.p-leave-to[data-v-58734797]{opacity:0}.label-box .label .tooltip.p-enter-to[data-v-58734797],.label-box .label .tooltip.p-leave[data-v-58734797]{opacity:1}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 269:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".sense-item .sense-item-number[data-v-b981c738]{flex:0 0 32px;padding:0 10px 0 0}.sense-item .subsense-item .subsense-number[data-v-b981c738]{font-family:consolas,monospace}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 5698:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".thesaurus-syn-ant .type-synonyms[data-v-2759b815]{color:#78b07b}.thesaurus-syn-ant .type-antonyms[data-v-2759b815]{color:#ce8383}.thesaurus-syn-ant .show-more-or-less[data-v-2759b815]{opacity:.7}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 1176:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".scroll-container[data-v-29b37c76]{max-height:250px}.language-select-box .language-item[data-v-29b37c76]{flex:0 0 33.3333%;padding:1px 0}.language-select-box .language-item.active[data-v-29b37c76]{background:#e8e8e8}.language-select-box .language-item[data-v-29b37c76]:hover{background:#e0e0e0}.bottom-info-box .tts-box[data-v-29b37c76]{opacity:.9}.bottom-info-box .tts-box .play-sound[data-v-29b37c76]{opacity:.45}.bottom-info-box .tts-box .play-sound .audio-icon[data-v-29b37c76]{margin:0 0 0 2px;opacity:.8}.bottom-info-box .tts-box .play-sound[data-v-29b37c76]:hover{opacity:.7}.bottom-info-box .tts-box .play-sound[data-v-29b37c76]:active{background-position:center calc(50% + 1px);opacity:1}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 38:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".pronunciation-item[data-v-267555b4]{flex:0 0 20px;height:20px;line-height:20px}.pronunciation-item .play-sound[data-v-267555b4]{cursor:pointer;height:20px;opacity:.45;width:20px}.pronunciation-item .play-sound[data-v-267555b4]:hover{opacity:.7}.pronunciation-item .play-sound[data-v-267555b4]:active{background-position:center calc(50% + 1px);opacity:1}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 876:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".scroll-container[data-v-08018802]{max-height:250px}.main-box>div[data-v-08018802]:first-child{margin-top:0!important}.symbols-box .part-item[data-v-08018802]{line-height:20px}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 4444:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".scroll-container[data-v-4129bac5]{max-height:250px}.content-box[data-v-4129bac5]{font-family:Source Han Sans SC,Source Sans Pro,Helvetica Neue,Helvetica,Arial,sans-serif}.content-box .row .keyword[data-v-4129bac5]{cursor:pointer;text-decoration:underline}.content-box .row .keyword.definition-keyword[data-v-4129bac5]{color:#6cace0}.content-box .row .keyword.example-keyword[data-v-4129bac5]{color:#99c3e6}.content-box .row .definition[data-v-4129bac5]{line-height:20px}.content-box .divider[data-v-4129bac5]{height:1px;width:100%}.content-box .thumb[data-v-4129bac5]{opacity:.7}.content-box .thumb.thumb-down[data-v-4129bac5]{transform:translateY(3px) rotate(180deg)}.u-toolip[data-v-4129bac5]{filter:drop-shadow(0 2px 1px rgba(0,0,0,.15)) drop-shadow(0 2px 1.2px rgba(0,0,0,.16)) drop-shadow(0 1px 2.2px rgba(0,0,0,.12));max-width:280px;padding:5px 8px;transform:translate(calc(-50% + 10px),17px);z-index:2}.u-toolip .inner-content[data-v-4129bac5]{max-height:105px;overflow:hidden}.u-toolip .loadin-spinner[data-v-4129bac5]{margin:6px 0}@keyframes rotate-4129bac5{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.u-toolip .rotate[data-v-4129bac5]{animation-duration:1.2s;animation-iteration-count:infinite;animation-name:rotate-4129bac5;animation-timing-function:linear}.u-toolip[data-v-4129bac5]:before{border-bottom:10px solid #fff;border-left:10px solid transparent;border-right:10px solid transparent;content:\"\";left:50%;position:absolute;top:-10px;transform:translate(-50%) scaleY(1.5) skewX(40deg);transform-origin:50% bottom}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 7772:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".scroll-container[data-v-45930c7a]{max-height:250px}.main-box .play-sound[data-v-45930c7a]{cursor:pointer;height:20px;opacity:.45;width:20px}.main-box .play-sound[data-v-45930c7a]:hover{opacity:.7}.main-box .play-sound[data-v-45930c7a]:active{background-position:center calc(50% + 1px);opacity:1}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 3136:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".toast-box[data-v-22ad7e37]{background:rgba(0,0,0,.5);border-radius:6px;bottom:10%;left:50%;padding:10px 18px;transform:translate(-50%,-50%);transform-origin:left top;z-index:2147483647}.t-enter-from[data-v-22ad7e37],.t-leave-to[data-v-22ad7e37]{opacity:0}.toast-box.t-enter-from[data-v-22ad7e37]{transform:scale(.9) translate(-50%,-50%)}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 180:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".history-window[data-v-2d428882]{height:560px;width:480px}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 7843:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".iciba-circle[data-v-b769a32c]{height:22px;opacity:.9;width:22px;z-index:10000}.iciba-circle.circle[data-v-b769a32c]{border-radius:9999px}.iciba-circle[data-v-b769a32c]:not(.has-icon){background:#a8c6f0;border:1px solid #0f0f0f;box-shadow:0 1px 1px -1px rgba(0,0,0,.2),0 0 1px 0 rgba(0,0,0,.14),0 0 3px 0 rgba(0,0,0,.12);opacity:.7}.iciba-circle[data-v-b769a32c]:not(.has-icon):active{box-shadow:0 1px 1px -1px rgba(0,0,0,.2),0 0 1px 0 rgba(0,0,0,.14),0 0 3px 0 rgba(0,0,0,.12),inset 1px 1px 1px rgba(0,0,0,.4)}.iciba-circle.c-leave-active[data-v-b769a32c]{transition:.15s cubic-bezier(.4,0,.2,1);transition-property:opacity,transform}.iciba-circle.c-leave-to[data-v-b769a32c]{opacity:0;transform:scale(.9)}.iciba-circle.c-leave[data-v-b769a32c]{opacity:1;transform:scale(1)}.iciba-circle[data-v-b769a32c]:hover{opacity:1}.iciba-circle[data-v-b769a32c]:active{filter:brightness(.7)}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 370:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".iciba-main-wrap[data-v-becc6b2c]{z-index:9999}.iciba-main-wrap.m-enter-from[data-v-becc6b2c]{opacity:0}.iciba-main-wrap.m-enter-from .iciba-main[data-v-becc6b2c]{transform:translateY(-6px)}.iciba-main-wrap.m-leave-to[data-v-becc6b2c]{opacity:0}.iciba-main-wrap.m-enter-to[data-v-becc6b2c],.iciba-main-wrap.m-leave-from[data-v-becc6b2c]{opacity:1}.iciba-main[data-v-becc6b2c]{filter:drop-shadow(0 2px 1.5px rgba(0,0,0,.14)) drop-shadow(0 4px 2.5px rgba(0,0,0,.15)) drop-shadow(0 1px 5px rgba(0,0,0,.12));left:0;letter-spacing:0;top:0;width:300px}.input-box[data-v-becc6b2c]{height:28px;z-index:1}.input-box .iciba-input-box .search-input[data-v-becc6b2c]{height:27px;letter-spacing:0;line-height:27px;padding:0 4px 0 7px;z-index:2}.input-box .iciba-input-box .search-input[data-v-becc6b2c]:focus{outline:none}.input-box .iciba-input-box.focused[data-v-becc6b2c]:before{content:\"\";height:calc(100% - 1px);left:1px;outline:2px solid #48f;outline-offset:-1px;position:absolute;top:1px;width:calc(100% - 1px)}.input-box .iciba-input-box .input-button[data-v-becc6b2c]{height:27px;opacity:.2;width:27px;z-index:2}.input-box .iciba-input-box .input-button[data-v-becc6b2c]:hover{opacity:.6}.input-box .iciba-input-box .input-button[data-v-becc6b2c]:active{background-position:center calc(50% + 1px);opacity:.9}.input-box .provider-box[data-v-becc6b2c]{height:28px}.input-box .provider-box .provider-button[data-v-becc6b2c]{background-color:#f7f7f7;flex:0 0 28px;height:27px;width:28px}.input-box .provider-box .provider-button[data-v-becc6b2c]:focus{outline:none}.input-box .provider-box .provider-button[data-v-becc6b2c]:focus:before{content:\"\";height:calc(100% - 1px);left:0;outline:2px solid #48f;outline-offset:-1px;position:absolute;top:1px;width:100%}.input-box .provider-box .provider-button[data-v-becc6b2c]:last-child:focus:before{width:calc(100% - 1px)}.input-box .provider-box .provider-button[data-v-becc6b2c]:hover{background-color:#fcfcfc}.input-box .provider-box .provider-button[data-v-becc6b2c]:active{background-color:#f0f0f0;background-position:center calc(50% + 1px);box-shadow:inset 0 0 6px #aaa}.content-box[data-v-becc6b2c]{background:#f7f7f7;z-index:2}.content-box .content-item[data-v-becc6b2c]{padding:7px 10px 10px}.stick-box[data-v-becc6b2c]{background:#eee;background-color:#f7f7f7;height:56px;right:0;top:0;transform:translate(100%);transition-duration:.1s;width:28px;z-index:0}.stick-box.s-enter[data-v-becc6b2c],.stick-box.s-leave-to[data-v-becc6b2c]{transform:translate(0);transition-delay:.3s}.stick-box.s-enter-to[data-v-becc6b2c],.stick-box.s-leave[data-v-becc6b2c]{transform:translate(100%)}.stick-box .drag[data-v-becc6b2c]{cursor:-webkit-grab;cursor:grab}.stick-box .drag[data-v-becc6b2c],.stick-box .stick[data-v-becc6b2c]{height:28px;width:28px}.stick-box .stick .i-icon[data-v-becc6b2c]{opacity:.4;transform:rotate(45deg)}.stick-box .stick.pinned .i-icon[data-v-becc6b2c]{opacity:1;transform:rotate(0)}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 9502:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".setting-window[data-v-52c940b4]{height:580px;width:580px}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 5832:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".default-iciba-circle[data-v-d6c1cc28]{background:#a8c6f0;border:1px solid #0f0f0f;border-radius:9999px;box-shadow:0 1px 1px -1px rgba(0,0,0,.2),0 0 1px 0 rgba(0,0,0,.14),0 0 3px 0 rgba(0,0,0,.12);opacity:.7}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 1392:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ = __webpack_require__(3116);
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3759);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".icon-box-container .icon-item[data-v-be105b76]{height:44px;width:44px}.icon-box-container .icon-item.icon-move[data-v-be105b76]{transition:transform .3s cubic-bezier(.4,0,.2,1)}.icon-box-container .icon-item .mask-box[data-v-be105b76]{background:#eee;border:1px solid #aaa;border-radius:3px;height:44px;left:0;top:0;width:44px;z-index:2}.icon-box-container .icon-item .mask-box.mask-enter-to[data-v-be105b76],.icon-box-container .icon-item .mask-box.mask-leave[data-v-be105b76]{opacity:1}.icon-box-container .icon-item .mask-box.mask-enter[data-v-be105b76],.icon-box-container .icon-item .mask-box.mask-leave-to[data-v-be105b76]{opacity:0}.icon-box-container .icon-item .mask-box.mask-leave-active[data-v-be105b76]{transition-delay:.2s}.icon-box-container .icon-item .icon-box[data-v-be105b76]{height:44px;width:44px;z-index:3}.icon-box-container .icon-item .icon-box .icon.inactive[data-v-be105b76]{opacity:.25}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 2751:
/***/ ((module) => {

var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;


/***/ }),

/***/ 5816:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(7419);

module.exports = parent;


/***/ }),

/***/ 1902:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(3618);
__webpack_require__(1780);
var entryVirtual = __webpack_require__(1298);

module.exports = entryVirtual('Array').flatMap;


/***/ }),

/***/ 5519:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(4428);
__webpack_require__(9365);
var entryVirtual = __webpack_require__(1298);

module.exports = entryVirtual('Array').keys;


/***/ }),

/***/ 2557:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(5460);
var entryVirtual = __webpack_require__(1298);

module.exports = entryVirtual('Array').reduce;


/***/ }),

/***/ 1622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototypeOf = __webpack_require__(1064);
var method = __webpack_require__(1902);

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.flatMap;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.flatMap) ? method : own;
};


/***/ }),

/***/ 5011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototypeOf = __webpack_require__(1064);
var method = __webpack_require__(3838);

var StringPrototype = String.prototype;

module.exports = function (it) {
  var own = it.matchAll;
  return typeof it == 'string' || it === StringPrototype
    || (isPrototypeOf(StringPrototype, it) && own === StringPrototype.matchAll) ? method : own;
};


/***/ }),

/***/ 4133:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototypeOf = __webpack_require__(1064);
var method = __webpack_require__(2557);

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.reduce;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.reduce) ? method : own;
};


/***/ }),

/***/ 249:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototypeOf = __webpack_require__(1064);
var method = __webpack_require__(2154);

var StringPrototype = String.prototype;

module.exports = function (it) {
  var own = it.trim;
  return typeof it == 'string' || it === StringPrototype
    || (isPrototypeOf(StringPrototype, it) && own === StringPrototype.trim) ? method : own;
};


/***/ }),

/***/ 9971:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(4428);
__webpack_require__(6830);
var path = __webpack_require__(1559);

module.exports = path.Object.fromEntries;


/***/ }),

/***/ 4556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(9889);
__webpack_require__(4428);
__webpack_require__(9365);
__webpack_require__(1025);
__webpack_require__(1305);
__webpack_require__(2229);
__webpack_require__(3000);
__webpack_require__(597);
var path = __webpack_require__(1559);

module.exports = path.Promise;


/***/ }),

/***/ 3838:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(9365);
__webpack_require__(6756);
__webpack_require__(7293);
var entryVirtual = __webpack_require__(1298);

module.exports = entryVirtual('String').matchAll;


/***/ }),

/***/ 2154:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(4586);
var entryVirtual = __webpack_require__(1298);

module.exports = entryVirtual('String').trim;


/***/ }),

/***/ 7611:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// TODO: remove from `core-js@4`
__webpack_require__(8129);

var parent = __webpack_require__(5816);

module.exports = parent;


/***/ }),

/***/ 8709:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var isCallable = __webpack_require__(6811);
var tryToString = __webpack_require__(5986);

var TypeError = global.TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 9904:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var isConstructor = __webpack_require__(6033);
var tryToString = __webpack_require__(5986);

var TypeError = global.TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ 3908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var isCallable = __webpack_require__(6811);

var String = global.String;
var TypeError = global.TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw TypeError("Can't set " + String(argument) + ' as a prototype');
};


/***/ }),

/***/ 5254:
/***/ ((module) => {

module.exports = function () { /* empty */ };


/***/ }),

/***/ 9557:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(5422).charAt);

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ 4117:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var isPrototypeOf = __webpack_require__(1064);

var TypeError = global.TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw TypeError('Incorrect invocation');
};


/***/ }),

/***/ 5863:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var isObject = __webpack_require__(280);

var String = global.String;
var TypeError = global.TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw TypeError(String(argument) + ' is not an object');
};


/***/ }),

/***/ 1235:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(7728);
var toAbsoluteIndex = __webpack_require__(5035);
var lengthOfArrayLike = __webpack_require__(502);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 8127:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(5907);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ 2421:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var aCallable = __webpack_require__(8709);
var toObject = __webpack_require__(5041);
var IndexedObject = __webpack_require__(3125);
var lengthOfArrayLike = __webpack_require__(502);

var TypeError = global.TypeError;

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aCallable(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike(O);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ 5924:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var toAbsoluteIndex = __webpack_require__(5035);
var lengthOfArrayLike = __webpack_require__(502);
var createProperty = __webpack_require__(3699);

var Array = global.Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ 106:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);

module.exports = uncurryThis([].slice);


/***/ }),

/***/ 2539:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arraySlice = __webpack_require__(5924);

var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(
    array,
    mergeSort(arraySlice(array, 0, middle), comparefn),
    mergeSort(arraySlice(array, middle), comparefn),
    comparefn
  );
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  } return array;
};

var merge = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;

  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = (lindex < llength && rindex < rlength)
      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
      : lindex < llength ? left[lindex++] : right[rindex++];
  } return array;
};

module.exports = mergeSort;


/***/ }),

/***/ 8621:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var isArray = __webpack_require__(9087);
var isConstructor = __webpack_require__(6033);
var isObject = __webpack_require__(280);
var wellKnownSymbol = __webpack_require__(2618);

var SPECIES = wellKnownSymbol('species');
var Array = global.Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ 432:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arraySpeciesConstructor = __webpack_require__(8621);

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ 8955:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(2618);

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ 8362:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 3603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var TO_STRING_TAG_SUPPORT = __webpack_require__(5864);
var isCallable = __webpack_require__(6811);
var classofRaw = __webpack_require__(8362);
var wellKnownSymbol = __webpack_require__(2618);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var Object = global.Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 1401:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);

var replace = uncurryThis(''.replace);

var TEST = (function (arg) { return String(Error(arg).stack); })('zxcasd');
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

module.exports = function (stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string') {
    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  } return stack;
};


/***/ }),

/***/ 9114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasOwn = __webpack_require__(757);
var ownKeys = __webpack_require__(6914);
var getOwnPropertyDescriptorModule = __webpack_require__(9379);
var definePropertyModule = __webpack_require__(2067);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 2346:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(5907);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 3968:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = (__webpack_require__(3826).IteratorPrototype);
var create = __webpack_require__(9977);
var createPropertyDescriptor = __webpack_require__(4221);
var setToStringTag = __webpack_require__(6973);
var Iterators = __webpack_require__(2815);

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ 8171:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(4155);
var definePropertyModule = __webpack_require__(2067);
var createPropertyDescriptor = __webpack_require__(4221);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 4221:
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 3699:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPropertyKey = __webpack_require__(3793);
var definePropertyModule = __webpack_require__(2067);
var createPropertyDescriptor = __webpack_require__(4221);

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ 2313:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(9523);
var call = __webpack_require__(132);
var IS_PURE = __webpack_require__(5313);
var FunctionName = __webpack_require__(9667);
var isCallable = __webpack_require__(6811);
var createIteratorConstructor = __webpack_require__(3968);
var getPrototypeOf = __webpack_require__(2833);
var setPrototypeOf = __webpack_require__(3200);
var setToStringTag = __webpack_require__(6973);
var createNonEnumerableProperty = __webpack_require__(8171);
var redefine = __webpack_require__(8090);
var wellKnownSymbol = __webpack_require__(2618);
var Iterators = __webpack_require__(2815);
var IteratorsCore = __webpack_require__(3826);

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ 4155:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(5907);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 1884:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var isObject = __webpack_require__(280);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 2176:
/***/ ((module) => {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ 6701:
/***/ ((module) => {

module.exports = typeof window == 'object';


/***/ }),

/***/ 6486:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(9580);
var global = __webpack_require__(9790);

module.exports = /ipad|iphone|ipod/i.test(userAgent) && global.Pebble !== undefined;


/***/ }),

/***/ 4805:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(9580);

module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);


/***/ }),

/***/ 8799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(8362);
var global = __webpack_require__(9790);

module.exports = classof(global.process) == 'process';


/***/ }),

/***/ 5704:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(9580);

module.exports = /web0s(?!.*chrome)/i.test(userAgent);


/***/ }),

/***/ 9580:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(7697);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 4740:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var userAgent = __webpack_require__(9580);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 1298:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(1559);

module.exports = function (CONSTRUCTOR) {
  return path[CONSTRUCTOR + 'Prototype'];
};


/***/ }),

/***/ 538:
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 6935:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(5907);
var createPropertyDescriptor = __webpack_require__(4221);

module.exports = !fails(function () {
  var error = Error('a');
  if (!('stack' in error)) return true;
  // eslint-disable-next-line es/no-object-defineproperty -- safe
  Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
  return error.stack !== 7;
});


/***/ }),

/***/ 9523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9790);
var apply = __webpack_require__(1541);
var uncurryThis = __webpack_require__(9320);
var isCallable = __webpack_require__(6811);
var getOwnPropertyDescriptor = (__webpack_require__(9379).f);
var isForced = __webpack_require__(1434);
var path = __webpack_require__(1559);
var bind = __webpack_require__(9037);
var createNonEnumerableProperty = __webpack_require__(8171);
var hasOwn = __webpack_require__(757);

var wrapConstructor = function (NativeConstructor) {
  var Wrapper = function (a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0: return new NativeConstructor();
        case 1: return new NativeConstructor(a);
        case 2: return new NativeConstructor(a, b);
      } return new NativeConstructor(a, b, c);
    } return apply(NativeConstructor, this, arguments);
  };
  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;

  var nativeSource = GLOBAL ? global : STATIC ? global[TARGET] : (global[TARGET] || {}).prototype;

  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;

  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contains in native
    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);

    targetProperty = target[key];

    if (USE_NATIVE) if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(nativeSource, key);
      nativeProperty = descriptor && descriptor.value;
    } else nativeProperty = nativeSource[key];

    // export native or implementation
    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;

    // bind timers to global for call from export context
    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, global);
    // wrap global constructors for prevent changs in this version
    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
    // make static versions for prototype methods
    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
    // default case
    else resultProperty = sourceProperty;

    // add a flag to not completely full polyfills
    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(resultProperty, 'sham', true);
    }

    createNonEnumerableProperty(target, key, resultProperty);

    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
      }
      // export virtual prototype methods
      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
      // export real prototype methods
      if (options.real && targetPrototype && !targetPrototype[key]) {
        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
      }
    }
  }
};


/***/ }),

/***/ 5907:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 493:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(9790);
var isArray = __webpack_require__(9087);
var lengthOfArrayLike = __webpack_require__(502);
var bind = __webpack_require__(9037);

var TypeError = global.TypeError;

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg) : false;
  var element, elementLen;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        elementLen = lengthOfArrayLike(element);
        targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;


/***/ }),

/***/ 1541:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(386);

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ 9037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);
var aCallable = __webpack_require__(8709);
var NATIVE_BIND = __webpack_require__(386);

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 386:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(5907);

module.exports = !fails(function () {
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 132:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(386);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 9667:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(4155);
var hasOwn = __webpack_require__(757);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 9320:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_BIND = __webpack_require__(386);

var FunctionPrototype = Function.prototype;
var bind = FunctionPrototype.bind;
var call = FunctionPrototype.call;
var uncurryThis = NATIVE_BIND && bind.bind(call, call);

module.exports = NATIVE_BIND ? function (fn) {
  return fn && uncurryThis(fn);
} : function (fn) {
  return fn && function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 7697:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(1559);
var global = __webpack_require__(9790);
var isCallable = __webpack_require__(6811);

var aFunction = function (variable) {
  return isCallable(variable) ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 7936:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(3603);
var getMethod = __webpack_require__(9562);
var Iterators = __webpack_require__(2815);
var wellKnownSymbol = __webpack_require__(2618);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ 5748:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var call = __webpack_require__(132);
var aCallable = __webpack_require__(8709);
var anObject = __webpack_require__(5863);
var tryToString = __webpack_require__(5986);
var getIteratorMethod = __webpack_require__(7936);

var TypeError = global.TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ 9562:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(8709);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ 9790:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 757:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);
var toObject = __webpack_require__(5041);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 6064:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length == 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ 4933:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(7697);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 4071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(4155);
var fails = __webpack_require__(5907);
var createElement = __webpack_require__(1884);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 3125:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var uncurryThis = __webpack_require__(9320);
var fails = __webpack_require__(5907);
var classof = __webpack_require__(8362);

var Object = global.Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : Object(it);
} : Object;


/***/ }),

/***/ 9808:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);
var isCallable = __webpack_require__(6811);
var store = __webpack_require__(7387);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 3361:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(280);
var createNonEnumerableProperty = __webpack_require__(8171);

// `InstallErrorCause` abstract operation
// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
module.exports = function (O, options) {
  if (isObject(options) && 'cause' in options) {
    createNonEnumerableProperty(O, 'cause', options.cause);
  }
};


/***/ }),

/***/ 9468:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(222);
var global = __webpack_require__(9790);
var uncurryThis = __webpack_require__(9320);
var isObject = __webpack_require__(280);
var createNonEnumerableProperty = __webpack_require__(8171);
var hasOwn = __webpack_require__(757);
var shared = __webpack_require__(7387);
var sharedKey = __webpack_require__(1657);
var hiddenKeys = __webpack_require__(6064);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = uncurryThis(store.get);
  var wmhas = uncurryThis(store.has);
  var wmset = uncurryThis(store.set);
  set = function (it, metadata) {
    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget(store, it) || {};
  };
  has = function (it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 8593:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(2618);
var Iterators = __webpack_require__(2815);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ 9087:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(8362);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};


/***/ }),

/***/ 6811:
/***/ ((module) => {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 6033:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);
var fails = __webpack_require__(5907);
var isCallable = __webpack_require__(6811);
var classof = __webpack_require__(3603);
var getBuiltIn = __webpack_require__(7697);
var inspectSource = __webpack_require__(9808);

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ 1434:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(5907);
var isCallable = __webpack_require__(6811);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(6811);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 5313:
/***/ ((module) => {

module.exports = true;


/***/ }),

/***/ 3591:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(280);
var classof = __webpack_require__(8362);
var wellKnownSymbol = __webpack_require__(2618);

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ 2648:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var getBuiltIn = __webpack_require__(7697);
var isCallable = __webpack_require__(6811);
var isPrototypeOf = __webpack_require__(1064);
var USE_SYMBOL_AS_UID = __webpack_require__(221);

var Object = global.Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object(it));
};


/***/ }),

/***/ 2357:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var bind = __webpack_require__(9037);
var call = __webpack_require__(132);
var anObject = __webpack_require__(5863);
var tryToString = __webpack_require__(5986);
var isArrayIteratorMethod = __webpack_require__(8593);
var lengthOfArrayLike = __webpack_require__(502);
var isPrototypeOf = __webpack_require__(1064);
var getIterator = __webpack_require__(5748);
var getIteratorMethod = __webpack_require__(7936);
var iteratorClose = __webpack_require__(9826);

var TypeError = global.TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ 9826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var call = __webpack_require__(132);
var anObject = __webpack_require__(5863);
var getMethod = __webpack_require__(9562);

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ 3826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(5907);
var isCallable = __webpack_require__(6811);
var create = __webpack_require__(9977);
var getPrototypeOf = __webpack_require__(2833);
var redefine = __webpack_require__(8090);
var wellKnownSymbol = __webpack_require__(2618);
var IS_PURE = __webpack_require__(5313);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  redefine(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 2815:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 502:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toLength = __webpack_require__(8491);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 5168:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var bind = __webpack_require__(9037);
var getOwnPropertyDescriptor = (__webpack_require__(9379).f);
var macrotask = (__webpack_require__(2772).set);
var IS_IOS = __webpack_require__(4805);
var IS_IOS_PEBBLE = __webpack_require__(6486);
var IS_WEBOS_WEBKIT = __webpack_require__(5704);
var IS_NODE = __webpack_require__(8799);

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    // workaround of WebKit ~ iOS Safari 10.1 bug
    promise.constructor = Promise;
    then = bind(promise.then, promise);
    notify = function () {
      then(flush);
    };
  // Node.js without promises
  } else if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    // strange IE + webpack dev server bug - use .bind(global)
    macrotask = bind(macrotask, global);
    notify = function () {
      macrotask(flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ 517:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);

module.exports = global.Promise;


/***/ }),

/***/ 4027:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(4740);
var fails = __webpack_require__(5907);

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 5981:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(5907);
var wellKnownSymbol = __webpack_require__(2618);
var IS_PURE = __webpack_require__(5313);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = !fails(function () {
  // eslint-disable-next-line unicorn/relative-url-style -- required for testing
  var url = new URL('b?a=1&b=2&c=3', 'http://a');
  var searchParams = url.searchParams;
  var result = '';
  url.pathname = 'c%20d';
  searchParams.forEach(function (value, key) {
    searchParams['delete']('b');
    result += key + value;
  });
  return (IS_PURE && !url.toJSON)
    || !searchParams.sort
    || url.href !== 'http://a/c%20d?a=1&c=3'
    || searchParams.get('c') !== '3'
    || String(new URLSearchParams('?a=1')) !== 'a=1'
    || !searchParams[ITERATOR]
    // throws in Edge
    || new URL('https://a@b').username !== 'a'
    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
    // not punycoded in Edge
    || new URL('http://тест').host !== 'xn--e1aybc'
    // not escaped in Chrome 62-
    || new URL('http://a#б').hash !== '#%D0%B1'
    // fails in Chrome 66-
    || result !== 'a1c3'
    // throws in Safari
    || new URL('http://x', undefined).host !== 'x';
});


/***/ }),

/***/ 222:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var isCallable = __webpack_require__(6811);
var inspectSource = __webpack_require__(9808);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 318:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(8709);

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable(resolve);
  this.reject = aCallable(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ 9306:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toString = __webpack_require__(3889);

module.exports = function (argument, $default) {
  return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
};


/***/ }),

/***/ 9977:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(5863);
var definePropertiesModule = __webpack_require__(6168);
var enumBugKeys = __webpack_require__(538);
var hiddenKeys = __webpack_require__(6064);
var html = __webpack_require__(4933);
var documentCreateElement = __webpack_require__(1884);
var sharedKey = __webpack_require__(1657);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ 6168:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(4155);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(7954);
var definePropertyModule = __webpack_require__(2067);
var anObject = __webpack_require__(5863);
var toIndexedObject = __webpack_require__(7728);
var objectKeys = __webpack_require__(8922);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ 2067:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var DESCRIPTORS = __webpack_require__(4155);
var IE8_DOM_DEFINE = __webpack_require__(4071);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(7954);
var anObject = __webpack_require__(5863);
var toPropertyKey = __webpack_require__(3793);

var TypeError = global.TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 9379:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(4155);
var call = __webpack_require__(132);
var propertyIsEnumerableModule = __webpack_require__(7530);
var createPropertyDescriptor = __webpack_require__(4221);
var toIndexedObject = __webpack_require__(7728);
var toPropertyKey = __webpack_require__(3793);
var hasOwn = __webpack_require__(757);
var IE8_DOM_DEFINE = __webpack_require__(4071);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 2020:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(1482);
var enumBugKeys = __webpack_require__(538);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 3684:
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 2833:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var hasOwn = __webpack_require__(757);
var isCallable = __webpack_require__(6811);
var toObject = __webpack_require__(5041);
var sharedKey = __webpack_require__(1657);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(2346);

var IE_PROTO = sharedKey('IE_PROTO');
var Object = global.Object;
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 1064:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 1482:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);
var hasOwn = __webpack_require__(757);
var toIndexedObject = __webpack_require__(7728);
var indexOf = (__webpack_require__(1235).indexOf);
var hiddenKeys = __webpack_require__(6064);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 8922:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(1482);
var enumBugKeys = __webpack_require__(538);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 7530:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 3200:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-proto -- safe */
var uncurryThis = __webpack_require__(9320);
var anObject = __webpack_require__(5863);
var aPossiblePrototype = __webpack_require__(3908);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 873:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(5864);
var classof = __webpack_require__(3603);

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ 5692:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var call = __webpack_require__(132);
var isCallable = __webpack_require__(6811);
var isObject = __webpack_require__(280);

var TypeError = global.TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 6914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(7697);
var uncurryThis = __webpack_require__(9320);
var getOwnPropertyNamesModule = __webpack_require__(2020);
var getOwnPropertySymbolsModule = __webpack_require__(3684);
var anObject = __webpack_require__(5863);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 1559:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 6171:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ 9227:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(5863);
var isObject = __webpack_require__(280);
var newPromiseCapability = __webpack_require__(318);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ 3608:
/***/ ((module) => {

var Queue = function () {
  this.head = null;
  this.tail = null;
};

Queue.prototype = {
  add: function (item) {
    var entry = { item: item, next: null };
    if (this.head) this.tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry) this.tail = null;
      return entry.item;
    }
  }
};

module.exports = Queue;


/***/ }),

/***/ 1924:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var redefine = __webpack_require__(8090);

module.exports = function (target, src, options) {
  for (var key in src) {
    if (options && options.unsafe && target[key]) target[key] = src[key];
    else redefine(target, key, src[key], options);
  } return target;
};


/***/ }),

/***/ 8090:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createNonEnumerableProperty = __webpack_require__(8171);

module.exports = function (target, key, value, options) {
  if (options && options.enumerable) target[key] = value;
  else createNonEnumerableProperty(target, key, value);
};


/***/ }),

/***/ 1313:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var call = __webpack_require__(132);
var anObject = __webpack_require__(5863);
var isCallable = __webpack_require__(6811);
var classof = __webpack_require__(8362);
var regexpExec = __webpack_require__(7958);

var TypeError = global.TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (isCallable(exec)) {
    var result = call(exec, R, S);
    if (result !== null) anObject(result);
    return result;
  }
  if (classof(R) === 'RegExp') return call(regexpExec, R, S);
  throw TypeError('RegExp#exec called on incompatible receiver');
};


/***/ }),

/***/ 7958:
/***/ ((module) => {

module.exports = /./.exec;


/***/ }),

/***/ 5712:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(5863);

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ 2190:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);

var TypeError = global.TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 7506:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 4974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(7697);
var definePropertyModule = __webpack_require__(2067);
var wellKnownSymbol = __webpack_require__(2618);
var DESCRIPTORS = __webpack_require__(4155);

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ 6973:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(5864);
var defineProperty = (__webpack_require__(2067).f);
var createNonEnumerableProperty = __webpack_require__(8171);
var hasOwn = __webpack_require__(757);
var toString = __webpack_require__(873);
var wellKnownSymbol = __webpack_require__(2618);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC, SET_METHOD) {
  if (it) {
    var target = STATIC ? it : it.prototype;
    if (!hasOwn(target, TO_STRING_TAG)) {
      defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
    }
    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
      createNonEnumerableProperty(target, 'toString', toString);
    }
  }
};


/***/ }),

/***/ 1657:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(2898);
var uid = __webpack_require__(720);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 7387:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var setGlobal = __webpack_require__(7506);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ 2898:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(5313);
var store = __webpack_require__(7387);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.21.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.21.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 1186:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(5863);
var aConstructor = __webpack_require__(9904);
var wellKnownSymbol = __webpack_require__(2618);

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aConstructor(S);
};


/***/ }),

/***/ 5422:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);
var toIntegerOrInfinity = __webpack_require__(1422);
var toString = __webpack_require__(3889);
var requireObjectCoercible = __webpack_require__(2190);

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ 377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var PROPER_FUNCTION_NAME = (__webpack_require__(9667).PROPER);
var fails = __webpack_require__(5907);
var whitespaces = __webpack_require__(624);

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]()
      || non[METHOD_NAME]() !== non
      || (PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME);
  });
};


/***/ }),

/***/ 7614:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);
var requireObjectCoercible = __webpack_require__(2190);
var toString = __webpack_require__(3889);
var whitespaces = __webpack_require__(624);

var replace = uncurryThis(''.replace);
var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ 2772:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var apply = __webpack_require__(1541);
var bind = __webpack_require__(9037);
var isCallable = __webpack_require__(6811);
var hasOwn = __webpack_require__(757);
var fails = __webpack_require__(5907);
var html = __webpack_require__(4933);
var arraySlice = __webpack_require__(106);
var createElement = __webpack_require__(1884);
var validateArgumentsLength = __webpack_require__(4936);
var IS_IOS = __webpack_require__(4805);
var IS_NODE = __webpack_require__(8799);

var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var Dispatch = global.Dispatch;
var Function = global.Function;
var MessageChannel = global.MessageChannel;
var String = global.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var location, defer, channel, port;

try {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  location = global.location;
} catch (error) { /* empty */ }

var run = function (id) {
  if (hasOwn(queue, id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(String(id), location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable(handler) ? handler : Function(handler);
    var args = arraySlice(arguments, 1);
    queue[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    isCallable(global.postMessage) &&
    !global.importScripts &&
    location && location.protocol !== 'file:' &&
    !fails(post)
  ) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ 5035:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(1422);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 7728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(3125);
var requireObjectCoercible = __webpack_require__(2190);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 1422:
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- safe
  return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
};


/***/ }),

/***/ 8491:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIntegerOrInfinity = __webpack_require__(1422);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 5041:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var requireObjectCoercible = __webpack_require__(2190);

var Object = global.Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 9743:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var call = __webpack_require__(132);
var isObject = __webpack_require__(280);
var isSymbol = __webpack_require__(2648);
var getMethod = __webpack_require__(9562);
var ordinaryToPrimitive = __webpack_require__(5692);
var wellKnownSymbol = __webpack_require__(2618);

var TypeError = global.TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 3793:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(9743);
var isSymbol = __webpack_require__(2648);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 5864:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(2618);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 3889:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var classof = __webpack_require__(3603);

var String = global.String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String(argument);
};


/***/ }),

/***/ 5986:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);

var String = global.String;

module.exports = function (argument) {
  try {
    return String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 720:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var uncurryThis = __webpack_require__(9320);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 221:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(4027);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 7954:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(4155);
var fails = __webpack_require__(5907);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ 4936:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);

var TypeError = global.TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ 2618:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9790);
var shared = __webpack_require__(2898);
var hasOwn = __webpack_require__(757);
var uid = __webpack_require__(720);
var NATIVE_SYMBOL = __webpack_require__(4027);
var USE_SYMBOL_AS_UID = __webpack_require__(221);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var symbolFor = Symbol && Symbol['for'];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    var description = 'Symbol.' + name;
    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 624:
/***/ ((module) => {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ 9889:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(9523);
var global = __webpack_require__(9790);
var isPrototypeOf = __webpack_require__(1064);
var getPrototypeOf = __webpack_require__(2833);
var setPrototypeOf = __webpack_require__(3200);
var copyConstructorProperties = __webpack_require__(9114);
var create = __webpack_require__(9977);
var createNonEnumerableProperty = __webpack_require__(8171);
var createPropertyDescriptor = __webpack_require__(4221);
var clearErrorStack = __webpack_require__(1401);
var installErrorCause = __webpack_require__(3361);
var iterate = __webpack_require__(2357);
var normalizeStringArgument = __webpack_require__(9306);
var wellKnownSymbol = __webpack_require__(2618);
var ERROR_STACK_INSTALLABLE = __webpack_require__(6935);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var Error = global.Error;
var push = [].push;

var $AggregateError = function AggregateError(errors, message /* , options */) {
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
  var that;
  if (setPrototypeOf) {
    that = setPrototypeOf(new Error(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
  } else {
    that = isInstance ? this : create(AggregateErrorPrototype);
    createNonEnumerableProperty(that, TO_STRING_TAG, 'Error');
  }
  if (message !== undefined) createNonEnumerableProperty(that, 'message', normalizeStringArgument(message));
  if (ERROR_STACK_INSTALLABLE) createNonEnumerableProperty(that, 'stack', clearErrorStack(that.stack, 1));
  installErrorCause(that, options);
  var errorsArray = [];
  iterate(errors, push, { that: errorsArray });
  createNonEnumerableProperty(that, 'errors', errorsArray);
  return that;
};

if (setPrototypeOf) setPrototypeOf($AggregateError, Error);
else copyConstructorProperties($AggregateError, Error, { name: true });

var AggregateErrorPrototype = $AggregateError.prototype = create(Error.prototype, {
  constructor: createPropertyDescriptor(1, $AggregateError),
  message: createPropertyDescriptor(1, ''),
  name: createPropertyDescriptor(1, 'AggregateError')
});

// `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor
$({ global: true }, {
  AggregateError: $AggregateError
});


/***/ }),

/***/ 3618:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(9523);
var flattenIntoArray = __webpack_require__(493);
var aCallable = __webpack_require__(8709);
var toObject = __webpack_require__(5041);
var lengthOfArrayLike = __webpack_require__(502);
var arraySpeciesCreate = __webpack_require__(432);

// `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap
$({ target: 'Array', proto: true }, {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen = lengthOfArrayLike(O);
    var A;
    aCallable(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});


/***/ }),

/***/ 4428:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(7728);
var addToUnscopables = __webpack_require__(5254);
var Iterators = __webpack_require__(2815);
var InternalStateModule = __webpack_require__(9468);
var defineProperty = (__webpack_require__(2067).f);
var defineIterator = __webpack_require__(2313);
var IS_PURE = __webpack_require__(5313);
var DESCRIPTORS = __webpack_require__(4155);

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }


/***/ }),

/***/ 5460:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(9523);
var $reduce = (__webpack_require__(2421).left);
var arrayMethodIsStrict = __webpack_require__(8127);
var CHROME_VERSION = __webpack_require__(4740);
var IS_NODE = __webpack_require__(8799);

var STRICT_METHOD = arrayMethodIsStrict('reduce');
// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;

// `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 1780:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(5254);

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flatMap');


/***/ }),

/***/ 6830:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(9523);
var iterate = __webpack_require__(2357);
var createProperty = __webpack_require__(3699);

// `Object.fromEntries` method
// https://github.com/tc39/proposal-object-from-entries
$({ target: 'Object', stat: true }, {
  fromEntries: function fromEntries(iterable) {
    var obj = {};
    iterate(iterable, function (k, v) {
      createProperty(obj, k, v);
    }, { AS_ENTRIES: true });
    return obj;
  }
});


/***/ }),

/***/ 9365:
/***/ (() => {

// empty


/***/ }),

/***/ 1305:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(9523);
var call = __webpack_require__(132);
var aCallable = __webpack_require__(8709);
var newPromiseCapabilityModule = __webpack_require__(318);
var perform = __webpack_require__(6171);
var iterate = __webpack_require__(2357);

// `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled
$({ target: 'Promise', stat: true }, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aCallable(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call(promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'fulfilled', value: value };
          --remaining || resolve(values);
        }, function (error) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'rejected', reason: error };
          --remaining || resolve(values);
        });
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 2229:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(9523);
var aCallable = __webpack_require__(8709);
var getBuiltIn = __webpack_require__(7697);
var call = __webpack_require__(132);
var newPromiseCapabilityModule = __webpack_require__(318);
var perform = __webpack_require__(6171);
var iterate = __webpack_require__(2357);

var PROMISE_ANY_ERROR = 'No one promise resolved';

// `Promise.any` method
// https://tc39.es/ecma262/#sec-promise.any
$({ target: 'Promise', stat: true }, {
  any: function any(iterable) {
    var C = this;
    var AggregateError = getBuiltIn('AggregateError');
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aCallable(C.resolve);
      var errors = [];
      var counter = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyRejected = false;
        remaining++;
        call(promiseResolve, C, promise).then(function (value) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyResolved = true;
          resolve(value);
        }, function (error) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyRejected = true;
          errors[index] = error;
          --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 3000:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(9523);
var IS_PURE = __webpack_require__(5313);
var NativePromise = __webpack_require__(517);
var fails = __webpack_require__(5907);
var getBuiltIn = __webpack_require__(7697);
var isCallable = __webpack_require__(6811);
var speciesConstructor = __webpack_require__(1186);
var promiseResolve = __webpack_require__(9227);
var redefine = __webpack_require__(8090);

// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromise && fails(function () {
  // eslint-disable-next-line unicorn/no-thenable -- required for testing
  NativePromise.prototype['finally'].call({ then: function () { /* empty */ } }, function () { /* empty */ });
});

// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = isCallable(onFinally);
    return this.then(
      isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () { return x; });
      } : onFinally,
      isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () { throw e; });
      } : onFinally
    );
  }
});

// makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`
if (!IS_PURE && isCallable(NativePromise)) {
  var method = getBuiltIn('Promise').prototype['finally'];
  if (NativePromise.prototype['finally'] !== method) {
    redefine(NativePromise.prototype, 'finally', method, { unsafe: true });
  }
}


/***/ }),

/***/ 1025:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(9523);
var IS_PURE = __webpack_require__(5313);
var global = __webpack_require__(9790);
var getBuiltIn = __webpack_require__(7697);
var call = __webpack_require__(132);
var NativePromise = __webpack_require__(517);
var redefine = __webpack_require__(8090);
var redefineAll = __webpack_require__(1924);
var setPrototypeOf = __webpack_require__(3200);
var setToStringTag = __webpack_require__(6973);
var setSpecies = __webpack_require__(4974);
var aCallable = __webpack_require__(8709);
var isCallable = __webpack_require__(6811);
var isObject = __webpack_require__(280);
var anInstance = __webpack_require__(4117);
var inspectSource = __webpack_require__(9808);
var iterate = __webpack_require__(2357);
var checkCorrectnessOfIteration = __webpack_require__(8955);
var speciesConstructor = __webpack_require__(1186);
var task = (__webpack_require__(2772).set);
var microtask = __webpack_require__(5168);
var promiseResolve = __webpack_require__(9227);
var hostReportErrors = __webpack_require__(637);
var newPromiseCapabilityModule = __webpack_require__(318);
var perform = __webpack_require__(6171);
var Queue = __webpack_require__(3608);
var InternalStateModule = __webpack_require__(9468);
var isForced = __webpack_require__(1434);
var wellKnownSymbol = __webpack_require__(2618);
var IS_BROWSER = __webpack_require__(6701);
var IS_NODE = __webpack_require__(8799);
var V8_VERSION = __webpack_require__(4740);

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';

var getInternalState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var NativePromisePrototype = NativePromise && NativePromise.prototype;
var PromiseConstructor = NativePromise;
var PromisePrototype = NativePromisePrototype;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;

var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var NATIVE_REJECTION_EVENT = isCallable(global.PromiseRejectionEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var SUBCLASSING = false;

var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced(PROMISE, function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  // We need Promise#finally in the pure version for preventing prototype pollution
  if (IS_PURE && !PromisePrototype['finally']) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = new PromiseConstructor(function (resolve) { resolve(1); });
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
  if (!SUBCLASSING) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && isCallable(then = it.then) ? then : false;
};

var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve = reaction.resolve;
  var reject = reaction.reject;
  var domain = reaction.domain;
  var result, then, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value); // can throw
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject(TypeError('Promise-chain cycle'));
      } else if (then = isThenable(result)) {
        call(then, result, resolve, reject);
      } else resolve(result);
    } else reject(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject(error);
  }
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          call(then, value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromisePrototype);
    aCallable(executor);
    call(Internal, this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromisePrototype, {
    // `Promise.prototype.then` method
    // https://tc39.es/ecma262/#sec-promise.prototype.then
    // eslint-disable-next-line unicorn/no-thenable -- safe
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      state.parent = true;
      reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable(onRejected) && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      if (state.state == PENDING) state.reactions.add(reaction);
      else microtask(function () {
        callReaction(reaction, state);
      });
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.es/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && isCallable(NativePromise) && NativePromisePrototype !== Object.prototype) {
    nativeThen = NativePromisePrototype.then;

    if (!SUBCLASSING) {
      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
      redefine(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          call(nativeThen, that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });

      // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
      redefine(NativePromisePrototype, 'catch', PromisePrototype['catch'], { unsafe: true });
    }

    // make `.constructor === Promise` work for native promise-based APIs
    try {
      delete NativePromisePrototype.constructor;
    } catch (error) { /* empty */ }

    // make `instanceof Promise` work for native promise-based APIs
    if (setPrototypeOf) {
      setPrototypeOf(NativePromisePrototype, PromisePrototype);
    }
  }
}

$({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.es/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    call(capability.reject, undefined, r);
    return capability.promise;
  }
});

$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.es/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.es/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call($promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.es/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      iterate(iterable, function (promise) {
        call($promiseResolve, C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ 6756:
/***/ (() => {

// empty


/***/ }),

/***/ 597:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(5422).charAt);
var toString = __webpack_require__(3889);
var InternalStateModule = __webpack_require__(9468);
var defineIterator = __webpack_require__(2313);

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ 7293:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-string-prototype-matchall -- safe */
var $ = __webpack_require__(9523);
var global = __webpack_require__(9790);
var call = __webpack_require__(132);
var uncurryThis = __webpack_require__(9320);
var createIteratorConstructor = __webpack_require__(3968);
var requireObjectCoercible = __webpack_require__(2190);
var toLength = __webpack_require__(8491);
var toString = __webpack_require__(3889);
var anObject = __webpack_require__(5863);
var classof = __webpack_require__(8362);
var isPrototypeOf = __webpack_require__(1064);
var isRegExp = __webpack_require__(3591);
var regExpFlags = __webpack_require__(5712);
var getMethod = __webpack_require__(9562);
var redefine = __webpack_require__(8090);
var fails = __webpack_require__(5907);
var wellKnownSymbol = __webpack_require__(2618);
var speciesConstructor = __webpack_require__(1186);
var advanceStringIndex = __webpack_require__(9557);
var regExpExec = __webpack_require__(1313);
var InternalStateModule = __webpack_require__(9468);
var IS_PURE = __webpack_require__(5313);

var MATCH_ALL = wellKnownSymbol('matchAll');
var REGEXP_STRING = 'RegExp String';
var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
var RegExpPrototype = RegExp.prototype;
var TypeError = global.TypeError;
var getFlags = uncurryThis(regExpFlags);
var stringIndexOf = uncurryThis(''.indexOf);
var un$MatchAll = uncurryThis(''.matchAll);

var WORKS_WITH_NON_GLOBAL_REGEX = !!un$MatchAll && !fails(function () {
  un$MatchAll('a', /./);
});

var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
  setInternalState(this, {
    type: REGEXP_STRING_ITERATOR,
    regexp: regexp,
    string: string,
    global: $global,
    unicode: fullUnicode,
    done: false
  });
}, REGEXP_STRING, function next() {
  var state = getInternalState(this);
  if (state.done) return { value: undefined, done: true };
  var R = state.regexp;
  var S = state.string;
  var match = regExpExec(R, S);
  if (match === null) return { value: undefined, done: state.done = true };
  if (state.global) {
    if (toString(match[0]) === '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
    return { value: match, done: false };
  }
  state.done = true;
  return { value: match, done: false };
});

var $matchAll = function (string) {
  var R = anObject(this);
  var S = toString(string);
  var C, flagsValue, flags, matcher, $global, fullUnicode;
  C = speciesConstructor(R, RegExp);
  flagsValue = R.flags;
  if (flagsValue === undefined && isPrototypeOf(RegExpPrototype, R) && !('flags' in RegExpPrototype)) {
    flagsValue = getFlags(R);
  }
  flags = flagsValue === undefined ? '' : toString(flagsValue);
  matcher = new C(C === RegExp ? R.source : R, flags);
  $global = !!~stringIndexOf(flags, 'g');
  fullUnicode = !!~stringIndexOf(flags, 'u');
  matcher.lastIndex = toLength(R.lastIndex);
  return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
};

// `String.prototype.matchAll` method
// https://tc39.es/ecma262/#sec-string.prototype.matchall
$({ target: 'String', proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
  matchAll: function matchAll(regexp) {
    var O = requireObjectCoercible(this);
    var flags, S, matcher, rx;
    if (regexp != null) {
      if (isRegExp(regexp)) {
        flags = toString(requireObjectCoercible('flags' in RegExpPrototype
          ? regexp.flags
          : getFlags(regexp)
        ));
        if (!~stringIndexOf(flags, 'g')) throw TypeError('`.matchAll` does not allow non-global regexes');
      }
      if (WORKS_WITH_NON_GLOBAL_REGEX) return un$MatchAll(O, regexp);
      matcher = getMethod(regexp, MATCH_ALL);
      if (matcher === undefined && IS_PURE && classof(regexp) == 'RegExp') matcher = $matchAll;
      if (matcher) return call(matcher, regexp, O);
    } else if (WORKS_WITH_NON_GLOBAL_REGEX) return un$MatchAll(O, regexp);
    S = toString(O);
    rx = new RegExp(regexp, 'g');
    return IS_PURE ? call($matchAll, rx, S) : rx[MATCH_ALL](S);
  }
});

IS_PURE || MATCH_ALL in RegExpPrototype || redefine(RegExpPrototype, MATCH_ALL, $matchAll);


/***/ }),

/***/ 4586:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(9523);
var $trim = (__webpack_require__(7614).trim);
var forcedStringTrimMethod = __webpack_require__(377);

// `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim
$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});


/***/ }),

/***/ 8129:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
__webpack_require__(7293);


/***/ }),

/***/ 4989:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(4428);
var DOMIterables = __webpack_require__(2176);
var global = __webpack_require__(9790);
var classof = __webpack_require__(3603);
var createNonEnumerableProperty = __webpack_require__(8171);
var Iterators = __webpack_require__(2815);
var wellKnownSymbol = __webpack_require__(2618);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) {
    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
  }
  Iterators[COLLECTION_NAME] = Iterators.Array;
}


/***/ }),

/***/ 8040:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(4428);
var $ = __webpack_require__(9523);
var global = __webpack_require__(9790);
var getBuiltIn = __webpack_require__(7697);
var call = __webpack_require__(132);
var uncurryThis = __webpack_require__(9320);
var USE_NATIVE_URL = __webpack_require__(5981);
var redefine = __webpack_require__(8090);
var redefineAll = __webpack_require__(1924);
var setToStringTag = __webpack_require__(6973);
var createIteratorConstructor = __webpack_require__(3968);
var InternalStateModule = __webpack_require__(9468);
var anInstance = __webpack_require__(4117);
var isCallable = __webpack_require__(6811);
var hasOwn = __webpack_require__(757);
var bind = __webpack_require__(9037);
var classof = __webpack_require__(3603);
var anObject = __webpack_require__(5863);
var isObject = __webpack_require__(280);
var $toString = __webpack_require__(3889);
var create = __webpack_require__(9977);
var createPropertyDescriptor = __webpack_require__(4221);
var getIterator = __webpack_require__(5748);
var getIteratorMethod = __webpack_require__(7936);
var validateArgumentsLength = __webpack_require__(4936);
var wellKnownSymbol = __webpack_require__(2618);
var arraySort = __webpack_require__(2539);

var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);

var n$Fetch = getBuiltIn('fetch');
var N$Request = getBuiltIn('Request');
var Headers = getBuiltIn('Headers');
var RequestPrototype = N$Request && N$Request.prototype;
var HeadersPrototype = Headers && Headers.prototype;
var RegExp = global.RegExp;
var TypeError = global.TypeError;
var decodeURIComponent = global.decodeURIComponent;
var encodeURIComponent = global.encodeURIComponent;
var charAt = uncurryThis(''.charAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var splice = uncurryThis([].splice);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);

var plus = /\+/g;
var sequences = Array(4);

var percentSequence = function (bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};

var percentDecode = function (sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};

var deserialize = function (it) {
  var result = replace(it, plus, ' ');
  var bytes = 4;
  try {
    return decodeURIComponent(result);
  } catch (error) {
    while (bytes) {
      result = replace(result, percentSequence(bytes--), percentDecode);
    }
    return result;
  }
};

var find = /[!'()~]|%20/g;

var replacements = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replacements[match];
};

var serialize = function (it) {
  return replace(encodeURIComponent(it), find, replacer);
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;
  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  } return step;
}, true);

var URLSearchParamsState = function (init) {
  this.entries = [];
  this.url = null;

  if (init !== undefined) {
    if (isObject(init)) this.parseObject(init);
    else this.parseQuery(typeof init == 'string' ? charAt(init, 0) === '?' ? stringSlice(init, 1) : init : $toString(init));
  }
};

URLSearchParamsState.prototype = {
  type: URL_SEARCH_PARAMS,
  bindURL: function (url) {
    this.url = url;
    this.update();
  },
  parseObject: function (object) {
    var iteratorMethod = getIteratorMethod(object);
    var iterator, next, step, entryIterator, entryNext, first, second;

    if (iteratorMethod) {
      iterator = getIterator(object, iteratorMethod);
      next = iterator.next;
      while (!(step = call(next, iterator)).done) {
        entryIterator = getIterator(anObject(step.value));
        entryNext = entryIterator.next;
        if (
          (first = call(entryNext, entryIterator)).done ||
          (second = call(entryNext, entryIterator)).done ||
          !call(entryNext, entryIterator).done
        ) throw TypeError('Expected sequence with length 2');
        push(this.entries, { key: $toString(first.value), value: $toString(second.value) });
      }
    } else for (var key in object) if (hasOwn(object, key)) {
      push(this.entries, { key: key, value: $toString(object[key]) });
    }
  },
  parseQuery: function (query) {
    if (query) {
      var attributes = split(query, '&');
      var index = 0;
      var attribute, entry;
      while (index < attributes.length) {
        attribute = attributes[index++];
        if (attribute.length) {
          entry = split(attribute, '=');
          push(this.entries, {
            key: deserialize(shift(entry)),
            value: deserialize(join(entry, '='))
          });
        }
      }
    }
  },
  serialize: function () {
    var entries = this.entries;
    var result = [];
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      push(result, serialize(entry.key) + '=' + serialize(entry.value));
    } return join(result, '&');
  },
  update: function () {
    this.entries.length = 0;
    this.parseQuery(this.url.query);
  },
  updateURL: function () {
    if (this.url) this.url.update();
  }
};

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
  anInstance(this, URLSearchParamsPrototype);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  setInternalState(this, new URLSearchParamsState(init));
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

redefineAll(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.append` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    validateArgumentsLength(arguments.length, 2);
    var state = getInternalParamsState(this);
    push(state.entries, { key: $toString(name), value: $toString(value) });
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var key = $toString(name);
    var index = 0;
    while (index < entries.length) {
      if (entries[index].key === key) splice(entries, index, 1);
      else index++;
    }
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = $toString(name);
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = $toString(name);
    var result = [];
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) push(result, entries[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = $toString(name);
    var index = 0;
    while (index < entries.length) {
      if (entries[index++].key === key) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var found = false;
    var key = $toString(name);
    var val = $toString(value);
    var index = 0;
    var entry;
    for (; index < entries.length; index++) {
      entry = entries[index];
      if (entry.key === key) {
        if (found) splice(entries, index--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) push(entries, { key: key, value: val });
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    arraySort(state.entries, function (a, b) {
      return a.key > b.key ? 1 : -1;
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined);
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, { enumerable: true });

// `URLSearchParams.prototype[@@iterator]` method
redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: 'entries' });

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
redefine(URLSearchParamsPrototype, 'toString', function toString() {
  return getInternalParamsState(this).serialize();
}, { enumerable: true });

setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

$({ global: true, forced: !USE_NATIVE_URL }, {
  URLSearchParams: URLSearchParamsConstructor
});

// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
if (!USE_NATIVE_URL && isCallable(Headers)) {
  var headersHas = uncurryThis(HeadersPrototype.has);
  var headersSet = uncurryThis(HeadersPrototype.set);

  var wrapRequestOptions = function (init) {
    if (isObject(init)) {
      var body = init.body;
      var headers;
      if (classof(body) === URL_SEARCH_PARAMS) {
        headers = init.headers ? new Headers(init.headers) : new Headers();
        if (!headersHas(headers, 'content-type')) {
          headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
        return create(init, {
          body: createPropertyDescriptor(0, $toString(body)),
          headers: createPropertyDescriptor(0, headers)
        });
      }
    } return init;
  };

  if (isCallable(n$Fetch)) {
    $({ global: true, enumerable: true, forced: true }, {
      fetch: function fetch(input /* , init */) {
        return n$Fetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
      }
    });
  }

  if (isCallable(N$Request)) {
    var RequestConstructor = function Request(input /* , init */) {
      anInstance(this, RequestPrototype);
      return new N$Request(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
    };

    RequestPrototype.constructor = RequestConstructor;
    RequestConstructor.prototype = RequestPrototype;

    $({ global: true, forced: true }, {
      Request: RequestConstructor
    });
  }
}

module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};


/***/ }),

/***/ 3659:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(5519);

module.exports = parent;


/***/ }),

/***/ 5302:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(1622);

module.exports = parent;


/***/ }),

/***/ 1748:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(4989);
var classof = __webpack_require__(3603);
var hasOwn = __webpack_require__(757);
var isPrototypeOf = __webpack_require__(1064);
var method = __webpack_require__(3659);

var ArrayPrototype = Array.prototype;

var DOMIterables = {
  DOMTokenList: true,
  NodeList: true
};

module.exports = function (it) {
  var own = it.keys;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.keys)
    || hasOwn(DOMIterables, classof(it)) ? method : own;
};


/***/ }),

/***/ 7419:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(5011);

module.exports = parent;


/***/ }),

/***/ 1458:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(4133);

module.exports = parent;


/***/ }),

/***/ 7995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(249);

module.exports = parent;


/***/ }),

/***/ 5239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(9971);
__webpack_require__(4989);

module.exports = parent;


/***/ }),

/***/ 2436:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(4556);
__webpack_require__(4989);

module.exports = parent;


/***/ }),

/***/ 5765:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var parent = __webpack_require__(2913);
__webpack_require__(4989);

module.exports = parent;


/***/ }),

/***/ 2913:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(8040);
var path = __webpack_require__(1559);

module.exports = path.URLSearchParams;


/***/ }),

/***/ 6415:
/***/ ((module) => {

(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();


/***/ }),

/***/ 5700:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {
	        crypto = __webpack_require__.g.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __webpack_require__(2480);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ 7334:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(5700), __webpack_require__(8960), __webpack_require__(6132));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.HmacSHA1;

}));

/***/ }),

/***/ 6132:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(5700));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),

/***/ 8960:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(5700));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),

/***/ 3759:
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ 3116:
/***/ ((module) => {

"use strict";


module.exports = function (i) {
  return i[1];
};

/***/ }),

/***/ 9052:
/***/ ((module) => {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ 5377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function(){
  var crypt = __webpack_require__(6415),
      utf8 = (__webpack_require__(2751).utf8),
      isBuffer = __webpack_require__(9052),
      bin = (__webpack_require__(2751).bin),

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message) && message.constructor !== Uint8Array)
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();


/***/ }),

/***/ 3721:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
// runtime helper for setting properties on components
// in a tree-shakable way
exports.Z = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ 8334:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "P": () => (/* binding */ stringify)
/* harmony export */ });
/** fix prototype.js Array.prototype.toJSON pollution */
const stringify = (...args) => {
  const stringyfy = JSON.stringify;
  const arrayToJSON = Array.prototype.toJSON;
  const hasToJSON = ('toJSON' in Array.prototype);

  if (hasToJSON) {
    Array.prototype.toJSON = undefined;
  }

  const result = stringyfy.call(JSON, ...args);

  if (hasToJSON) {
    Array.prototype.toJSON = arrayToJSON;
  }

  return result;
};

/***/ }),

/***/ 2585:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(6040);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("61f6ac54", content, true);

/***/ }),

/***/ 8769:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(1517);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("5984f254", content, true);

/***/ }),

/***/ 3295:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(9615);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("665b75da", content, true);

/***/ }),

/***/ 3959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(4196);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("5206f8dc", content, true);

/***/ }),

/***/ 5428:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(367);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("4614f998", content, true);

/***/ }),

/***/ 685:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(6641);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("50f72d42", content, true);

/***/ }),

/***/ 4259:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(8529);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("2039f04b", content, true);

/***/ }),

/***/ 5660:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(5071);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("054561c8", content, true);

/***/ }),

/***/ 9346:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(3195);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("79e76bf6", content, true);

/***/ }),

/***/ 993:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(2053);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("170325a2", content, true);

/***/ }),

/***/ 1783:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(4460);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("0b654ebe", content, true);

/***/ }),

/***/ 8375:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(3102);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("16db0e1c", content, true);

/***/ }),

/***/ 9902:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(1464);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("8f53862a", content, true);

/***/ }),

/***/ 5421:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(413);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("532563d0", content, true);

/***/ }),

/***/ 2661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(9941);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("6ec83bf1", content, true);

/***/ }),

/***/ 881:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(7066);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("0fbc82e6", content, true);

/***/ }),

/***/ 2750:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(8038);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("c645fbea", content, true);

/***/ }),

/***/ 5937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(1543);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("1fccd0f2", content, true);

/***/ }),

/***/ 9255:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(2942);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("d6778a1e", content, true);

/***/ }),

/***/ 5044:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(6646);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("3b73e02b", content, true);

/***/ }),

/***/ 2708:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(1995);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("9b122c2a", content, true);

/***/ }),

/***/ 7882:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(2015);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("82714740", content, true);

/***/ }),

/***/ 9731:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(269);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("062bc42a", content, true);

/***/ }),

/***/ 6210:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(5698);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("93d1bf68", content, true);

/***/ }),

/***/ 7183:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(1176);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("7f3145e5", content, true);

/***/ }),

/***/ 8122:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(38);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("94adbae6", content, true);

/***/ }),

/***/ 5112:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(876);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("0defba54", content, true);

/***/ }),

/***/ 1855:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(4444);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("20c3cd84", content, true);

/***/ }),

/***/ 6446:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(7772);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("a482810e", content, true);

/***/ }),

/***/ 1853:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(3136);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("4ef719cd", content, true);

/***/ }),

/***/ 6532:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(180);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("4b9b7a83", content, true);

/***/ }),

/***/ 4632:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(7843);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("c86d5502", content, true);

/***/ }),

/***/ 4558:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(370);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("5aa227ca", content, true);

/***/ }),

/***/ 7908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(9502);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("34844824", content, true);

/***/ }),

/***/ 7981:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(5832);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("1930f0b2", content, true);

/***/ }),

/***/ 3922:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(1392);
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(5815)/* ["default"] */ .Z)
var update = add("e5463610", content, true);

/***/ }),

/***/ 5815:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ addStylesClient)
});

;// CONCATENATED MODULE: ./utils/vue-style-loader/lib/listToStyles.js
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };

    if (!newStyles[id]) {
      styles.push(newStyles[id] = {
        id: id,
        parts: [part]
      });
    } else {
      newStyles[id].parts.push(part);
    }
  }

  return styles;
}
;// CONCATENATED MODULE: ./utils/vue-style-loader/lib/addStylesClient.js
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/


var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

// var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var head = document.querySelector('.iciba-root').shadowRoot
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var root = options.insertInto ? options.insertInto() : head
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  root.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var root = options.insertInto ? options.insertInto() : document
  var styleElement = root.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ 2480:
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

;// CONCATENATED MODULE: ./src/service/shadowRoot/index.ts
const icibaRoot = document.createElement('div');
icibaRoot.className = 'iciba-root';
icibaRoot.style.all = 'initial';
document.body.append(icibaRoot);
const mo = new MutationObserver(() => {
  if (!document.body.contains(icibaRoot)) {
    document.body.append(icibaRoot);
  }
});
mo.observe(document.body, {
  childList: true
});

const pollingCheck = () => {
  if (!document.body.contains(icibaRoot)) {
    document.body.append(icibaRoot);
  }

  setTimeout(pollingCheck, 500);
};

pollingCheck();
const shadowRoot = (() => {
  let sr;

  if (icibaRoot.attachShadow) {
    sr = icibaRoot.attachShadow({
      mode: 'open'
    });
  } else {
    // shadow dom v0
    // < firefox 59
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    sr = icibaRoot.createShadowRoot();
  }

  return sr;
})();
;// CONCATENATED MODULE: ./node_modules/@vue/shared/dist/shared.esm-bundler.js
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function shared_esm_bundler_makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* STABLE */]: 'STABLE',
    [2 /* DYNAMIC */]: 'DYNAMIC',
    [3 /* FORWARDED */]: 'FORWARDED'
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ shared_esm_bundler_makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count +=
            lines[i].length +
                ((newlineSequences[i] && newlineSequences[i].length) || 0);
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ shared_esm_bundler_makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ shared_esm_bundler_makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */
function includeBooleanAttr(value) {
    return !!value || value === '';
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`)));
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownHtmlAttr = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`)));
/**
 * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute
 */
const isKnownSvgAttr = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +
    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +
    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +
    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +
    `color-interpolation-filters,color-profile,color-rendering,` +
    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +
    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +
    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +
    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +
    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +
    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +
    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +
    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +
    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +
    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +
    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +
    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +
    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +
    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +
    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +
    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +
    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +
    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +
    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +
    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +
    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +
    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +
    `strikethrough-position,strikethrough-thickness,string,stroke,` +
    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +
    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +
    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +
    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +
    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +
    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +
    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +
    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +
    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +
    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +
    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`)));

function normalizeStyle(value) {
    if (shared_esm_bundler_isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = shared_esm_bundler_isString(item)
                ? parseStringStyle(item)
                : normalizeStyle(item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (shared_esm_bundler_isString(value)) {
        return value;
    }
    else if (shared_esm_bundler_isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles || shared_esm_bundler_isString(styles)) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : shared_esm_bundler_hyphenate(key);
        if (shared_esm_bundler_isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (shared_esm_bundler_isString(value)) {
        res = value;
    }
    else if (shared_esm_bundler_isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (shared_esm_bundler_isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props)
        return null;
    let { class: klass, style } = props;
    if (klass && !shared_esm_bundler_isString(klass)) {
        props.class = normalizeClass(klass);
    }
    if (style) {
        props.style = normalizeStyle(style);
    }
    return props;
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = (/* unused pure expression or super */ null && ('html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot'));
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = (/* unused pure expression or super */ null && ('svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view'));
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const shared_esm_bundler_isHTMLTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(HTML_TAGS)));
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const shared_esm_bundler_isSVGTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(SVG_TAGS)));
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isVoidTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(VOID_TAGS)));

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = shared_esm_bundler_looseEqual(a[i], b[i]);
    }
    return equal;
}
function shared_esm_bundler_looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = shared_esm_bundler_isArray(a);
    bValidType = shared_esm_bundler_isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = shared_esm_bundler_isObject(a);
    bValidType = shared_esm_bundler_isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !shared_esm_bundler_looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function shared_esm_bundler_looseIndexOf(arr, val) {
    return arr.findIndex(item => shared_esm_bundler_looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return shared_esm_bundler_isString(val)
        ? val
        : val == null
            ? ''
            : shared_esm_bundler_isArray(val) ||
                (shared_esm_bundler_isObject(val) &&
                    (val.toString === objectToString || !shared_esm_bundler_isFunction(val.toString)))
                ? (__webpack_require__(8334)/* .stringify */ .P)(val, replacer, 2)
                : String(val);
};
const replacer = (_key, val) => {
    // can't use isRef here since @vue/shared has no deps
    if (val && val.__v_isRef) {
        return replacer(_key, val.value);
    }
    else if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (shared_esm_bundler_isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (shared_esm_bundler_isObject(val) && !shared_esm_bundler_isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const shared_esm_bundler_EMPTY_OBJ = ( false)
    ? 0
    : {};
const EMPTY_ARR = ( false) ? 0 : [];
const shared_esm_bundler_NOOP = () => { };
/**
 * Always return false.
 */
const shared_esm_bundler_NO = () => false;
const onRE = /^on[^a-z]/;
const shared_esm_bundler_isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const shared_esm_bundler_extend = Object.assign;
const shared_esm_bundler_remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const shared_esm_bundler_hasOwnProperty = Object.prototype.hasOwnProperty;
const shared_esm_bundler_hasOwn = (val, key) => shared_esm_bundler_hasOwnProperty.call(val, key);
const shared_esm_bundler_isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const shared_esm_bundler_isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => val instanceof Date;
const shared_esm_bundler_isFunction = (val) => typeof val === 'function';
const shared_esm_bundler_isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const shared_esm_bundler_isObject = (val) => val !== null && typeof val === 'object';
const shared_esm_bundler_isPromise = (val) => {
    return shared_esm_bundler_isObject(val) && shared_esm_bundler_isFunction(val.then) && shared_esm_bundler_isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const shared_esm_bundler_toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => shared_esm_bundler_isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const shared_esm_bundler_isReservedProp = /*#__PURE__*/ shared_esm_bundler_makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const shared_esm_bundler_isBuiltInDirective = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo')));
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const shared_esm_bundler_hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const shared_esm_bundler_capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const shared_esm_bundler_toHandlerKey = cacheStringFunction((str) => str ? `on${shared_esm_bundler_capitalize(str)}` : ``);
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const shared_esm_bundler_toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};



;// CONCATENATED MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js


function reactivity_esm_bundler_warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeEffectScope;
class EffectScope {
    constructor(detached = false) {
        this.active = true;
        this.effects = [];
        this.cleanups = [];
        if (!detached && activeEffectScope) {
            this.parent = activeEffectScope;
            this.index =
                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    run(fn) {
        if (this.active) {
            try {
                activeEffectScope = this;
                return fn();
            }
            finally {
                activeEffectScope = this.parent;
            }
        }
        else if ((false)) {}
    }
    on() {
        activeEffectScope = this;
    }
    off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this.active) {
            let i, l;
            for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].stop();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                }
            }
            // nested scope, dereference from parent to avoid memory leaks
            if (this.parent && !fromParent) {
                // optimized O(1) removal
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) {
        scope.effects.push(effect);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
    }
    else if ((false)) {}
}

const createDep = (effects) => {
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].w |= trackOpBit; // set was tracked
        }
    }
};
const finalizeDepMarkers = (effect) => {
    const { deps } = effect;
    if (deps.length) {
        let ptr = 0;
        for (let i = 0; i < deps.length; i++) {
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) {
                dep.delete(effect);
            }
            else {
                deps[ptr++] = dep;
            }
            // clear bits
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
    }
};

const targetMap = new WeakMap();
// The number of effects currently being tracked recursively.
let effectTrackDepth = 0;
let trackOpBit = 1;
/**
 * The bitwise track markers support at most 30 levels of recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol(( false) ? 0 : '');
const MAP_KEY_ITERATE_KEY = Symbol(( false) ? 0 : '');
class ReactiveEffect {
    constructor(fn, scheduler = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = undefined;
        recordEffectScope(this, scope);
    }
    run() {
        if (!this.active) {
            return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
            if (parent === this) {
                return;
            }
            parent = parent.parent;
        }
        try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
                initDepMarkers(this);
            }
            else {
                cleanupEffect(this);
            }
            return this.fn();
        }
        finally {
            if (effectTrackDepth <= maxMarkerBits) {
                finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = undefined;
        }
    }
    stop() {
        if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
                this.onStop();
            }
            this.active = false;
        }
    }
}
function cleanupEffect(effect) {
    const { deps } = effect;
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect);
        }
        deps.length = 0;
    }
}
function effect(fn, options) {
    if (fn.effect) {
        fn = fn.effect.fn;
    }
    const _effect = new ReactiveEffect(fn);
    if (options) {
        extend(_effect, options);
        if (options.scope)
            recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) {
        _effect.run();
    }
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === undefined ? true : last;
}
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
            targetMap.set(target, (depsMap = new Map()));
        }
        let dep = depsMap.get(key);
        if (!dep) {
            depsMap.set(key, (dep = createDep()));
        }
        const eventInfo = ( false)
            ? 0
            : undefined;
        trackEffects(dep, eventInfo);
    }
}
function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit; // set newly tracked
            shouldTrack = !wasTracked(dep);
        }
    }
    else {
        // Full cleanup mode.
        shouldTrack = !dep.has(activeEffect);
    }
    if (shouldTrack) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (false) {}
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        // never been tracked
        return;
    }
    let deps = [];
    if (type === "clear" /* CLEAR */) {
        // collection being cleared
        // trigger all effects for target
        deps = [...depsMap.values()];
    }
    else if (key === 'length' && shared_esm_bundler_isArray(target)) {
        depsMap.forEach((dep, key) => {
            if (key === 'length' || key >= newValue) {
                deps.push(dep);
            }
        });
    }
    else {
        // schedule runs for SET | ADD | DELETE
        if (key !== void 0) {
            deps.push(depsMap.get(key));
        }
        // also run for iteration key on ADD | DELETE | Map.SET
        switch (type) {
            case "add" /* ADD */:
                if (!shared_esm_bundler_isArray(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if (isMap(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                else if (isIntegerKey(key)) {
                    // new index added to array -> length changes
                    deps.push(depsMap.get('length'));
                }
                break;
            case "delete" /* DELETE */:
                if (!shared_esm_bundler_isArray(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if (isMap(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                break;
            case "set" /* SET */:
                if (isMap(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                }
                break;
        }
    }
    const eventInfo = ( false)
        ? 0
        : undefined;
    if (deps.length === 1) {
        if (deps[0]) {
            if ((false)) {}
            else {
                triggerEffects(deps[0]);
            }
        }
    }
    else {
        const effects = [];
        for (const dep of deps) {
            if (dep) {
                effects.push(...dep);
            }
        }
        if ((false)) {}
        else {
            triggerEffects(createDep(effects));
        }
    }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
    // spread into array for stabilization
    for (const effect of shared_esm_bundler_isArray(dep) ? dep : [...dep]) {
        if (effect !== activeEffect || effect.allowRecurse) {
            if (false) {}
            if (effect.scheduler) {
                effect.scheduler();
            }
            else {
                effect.run();
            }
        }
    }
}

const isNonTrackableKeys = /*#__PURE__*/ shared_esm_bundler_makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)
    .map(key => Symbol[key])
    .filter(isSymbol));
const get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
        instrumentations[key] = function (...args) {
            const arr = reactivity_esm_bundler_toRaw(this);
            for (let i = 0, l = this.length; i < l; i++) {
                track(arr, "get" /* GET */, i + '');
            }
            // we run the method using the original args first (which may be reactive)
            const res = arr[key](...args);
            if (res === -1 || res === false) {
                // if that didn't work, run it again using raw values.
                return arr[key](...args.map(reactivity_esm_bundler_toRaw));
            }
            else {
                return res;
            }
        };
    });
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
        instrumentations[key] = function (...args) {
            pauseTracking();
            const res = reactivity_esm_bundler_toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
    return function get(target, key, receiver) {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_isShallow" /* IS_SHALLOW */) {
            return shallow;
        }
        else if (key === "__v_raw" /* RAW */ &&
            receiver ===
                (isReadonly
                    ? shallow
                        ? shallowReadonlyMap
                        : readonlyMap
                    : shallow
                        ? shallowReactiveMap
                        : reactiveMap).get(target)) {
            return target;
        }
        const targetIsArray = shared_esm_bundler_isArray(target);
        if (!isReadonly && targetIsArray && shared_esm_bundler_hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
        }
        if (!isReadonly) {
            track(target, "get" /* GET */, key);
        }
        if (shallow) {
            return res;
        }
        if (reactivity_esm_bundler_isRef(res)) {
            // ref unwrapping - does not apply for Array + integer key.
            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
            return shouldUnwrap ? res.value : res;
        }
        if (shared_esm_bundler_isObject(res)) {
            // Convert returned value into a proxy as well. we do the isObject check
            // here to avoid invalid value warning. Also need to lazy access readonly
            // and reactive here to avoid circular dependency.
            return isReadonly ? readonly(res) : reactivity_esm_bundler_reactive(res);
        }
        return res;
    };
}
const set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);
function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
        let oldValue = target[key];
        if (reactivity_esm_bundler_isReadonly(oldValue) && reactivity_esm_bundler_isRef(oldValue) && !reactivity_esm_bundler_isRef(value)) {
            return false;
        }
        if (!shallow && !reactivity_esm_bundler_isReadonly(value)) {
            if (!isShallow(value)) {
                value = reactivity_esm_bundler_toRaw(value);
                oldValue = reactivity_esm_bundler_toRaw(oldValue);
            }
            if (!shared_esm_bundler_isArray(target) && reactivity_esm_bundler_isRef(oldValue) && !reactivity_esm_bundler_isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = shared_esm_bundler_isArray(target) && isIntegerKey(key)
            ? Number(key) < target.length
            : shared_esm_bundler_hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        // don't trigger if target is something up in the prototype chain of original
        if (target === reactivity_esm_bundler_toRaw(receiver)) {
            if (!hadKey) {
                trigger(target, "add" /* ADD */, key, value);
            }
            else if (hasChanged(value, oldValue)) {
                trigger(target, "set" /* SET */, key, value, oldValue);
            }
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = shared_esm_bundler_hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has" /* HAS */, key);
    }
    return result;
}
function ownKeys(target) {
    track(target, "iterate" /* ITERATE */, shared_esm_bundler_isArray(target) ? 'length' : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
        if ((false)) {}
        return true;
    },
    deleteProperty(target, key) {
        if ((false)) {}
        return true;
    }
};
const shallowReactiveHandlers = /*#__PURE__*/ shared_esm_bundler_extend({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
const shallowReadonlyHandlers = /*#__PURE__*/ shared_esm_bundler_extend({}, readonlyHandlers, {
    get: shallowReadonlyGet
});

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly = false, isShallow = false) {
    // #1772: readonly(reactive(Map)) should return readonly + reactive version
    // of the value
    target = target["__v_raw" /* RAW */];
    const rawTarget = reactivity_esm_bundler_toRaw(target);
    const rawKey = reactivity_esm_bundler_toRaw(key);
    if (key !== rawKey) {
        !isReadonly && track(rawTarget, "get" /* GET */, key);
    }
    !isReadonly && track(rawTarget, "get" /* GET */, rawKey);
    const { has } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
    }
    else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
    }
    else if (target !== rawTarget) {
        // #3602 readonly(reactive(Map))
        // ensure that the nested reactive `Map` can do tracking for itself
        target.get(key);
    }
}
function has$1(key, isReadonly = false) {
    const target = this["__v_raw" /* RAW */];
    const rawTarget = reactivity_esm_bundler_toRaw(target);
    const rawKey = reactivity_esm_bundler_toRaw(key);
    if (key !== rawKey) {
        !isReadonly && track(rawTarget, "has" /* HAS */, key);
    }
    !isReadonly && track(rawTarget, "has" /* HAS */, rawKey);
    return key === rawKey
        ? target.has(key)
        : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw" /* RAW */];
    !isReadonly && track(reactivity_esm_bundler_toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);
    return Reflect.get(target, 'size', target);
}
function add(value) {
    value = reactivity_esm_bundler_toRaw(value);
    const target = reactivity_esm_bundler_toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add" /* ADD */, value, value);
    }
    return this;
}
function set$1(key, value) {
    value = reactivity_esm_bundler_toRaw(value);
    const target = reactivity_esm_bundler_toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = reactivity_esm_bundler_toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((false)) {}
    const oldValue = get.call(target, key);
    target.set(key, value);
    if (!hadKey) {
        trigger(target, "add" /* ADD */, key, value);
    }
    else if (hasChanged(value, oldValue)) {
        trigger(target, "set" /* SET */, key, value, oldValue);
    }
    return this;
}
function deleteEntry(key) {
    const target = reactivity_esm_bundler_toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = reactivity_esm_bundler_toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((false)) {}
    const oldValue = get ? get.call(target, key) : undefined;
    // forward the operation before queueing reactions
    const result = target.delete(key);
    if (hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function clear() {
    const target = reactivity_esm_bundler_toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = ( false)
        ? 0
        : undefined;
    // forward the operation before queueing reactions
    const result = target.clear();
    if (hadItems) {
        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
    }
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw" /* RAW */];
        const rawTarget = reactivity_esm_bundler_toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);
        return target.forEach((value, key) => {
            // important: make sure the callback is
            // 1. invoked with the reactive map as `this` and 3rd arg
            // 2. the value received should be a corresponding reactive/readonly.
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function (...args) {
        const target = this["__v_raw" /* RAW */];
        const rawTarget = reactivity_esm_bundler_toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
        const isKeyOnly = method === 'keys' && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly &&
            track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        // return a wrapped iterator which returns observed versions of the
        // values emitted from the real iterator
        return {
            // iterator protocol
            next() {
                const { value, done } = innerIterator.next();
                return done
                    ? { value, done }
                    : {
                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                        done
                    };
            },
            // iterable protocol
            [Symbol.iterator]() {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function (...args) {
        if ((false)) {}
        return type === "delete" /* DELETE */ ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations = {
        get(key) {
            return get$1(this, key);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations = {
        get(key) {
            return get$1(this, key, false, true);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
    iteratorMethods.forEach(method => {
        mutableInstrumentations[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations[method] = createIterableMethod(method, true, false);
        shallowInstrumentations[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow
        ? isReadonly
            ? shallowReadonlyInstrumentations
            : shallowInstrumentations
        : isReadonly
            ? readonlyInstrumentations
            : mutableInstrumentations;
    return (target, key, receiver) => {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* RAW */) {
            return target;
        }
        return Reflect.get(shared_esm_bundler_hasOwn(instrumentations, key) && key in target
            ? instrumentations
            : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
    const rawKey = reactivity_esm_bundler_toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
        const type = toRawType(target);
        console.warn(`Reactive ${type} contains both the raw and reactive ` +
            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +
            `which can lead to inconsistencies. ` +
            `Avoid differentiating between the raw and reactive versions ` +
            `of an object and only use the reactive version if possible.`);
    }
}

const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
    switch (rawType) {
        case 'Object':
        case 'Array':
            return 1 /* COMMON */;
        case 'Map':
        case 'Set':
        case 'WeakMap':
        case 'WeakSet':
            return 2 /* COLLECTION */;
        default:
            return 0 /* INVALID */;
    }
}
function getTargetType(value) {
    return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)
        ? 0 /* INVALID */
        : targetTypeMap(shared_esm_bundler_toRawType(value));
}
function reactivity_esm_bundler_reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (reactivity_esm_bundler_isReadonly(target)) {
        return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!shared_esm_bundler_isObject(target)) {
        if ((false)) {}
        return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target["__v_raw" /* RAW */] &&
        !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
        return target;
    }
    // target already has corresponding Proxy
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
        return existingProxy;
    }
    // only a whitelist of value types can be observed.
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */) {
        return target;
    }
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function reactivity_esm_bundler_isReactive(value) {
    if (reactivity_esm_bundler_isReadonly(value)) {
        return reactivity_esm_bundler_isReactive(value["__v_raw" /* RAW */]);
    }
    return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
}
function reactivity_esm_bundler_isReadonly(value) {
    return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow" /* IS_SHALLOW */]);
}
function isProxy(value) {
    return reactivity_esm_bundler_isReactive(value) || reactivity_esm_bundler_isReadonly(value);
}
function reactivity_esm_bundler_toRaw(observed) {
    const raw = observed && observed["__v_raw" /* RAW */];
    return raw ? reactivity_esm_bundler_toRaw(raw) : observed;
}
function markRaw(value) {
    def(value, "__v_skip" /* SKIP */, true);
    return value;
}
const toReactive = (value) => shared_esm_bundler_isObject(value) ? reactivity_esm_bundler_reactive(value) : value;
const toReadonly = (value) => shared_esm_bundler_isObject(value) ? readonly(value) : value;

function trackRefValue(ref) {
    if (shouldTrack && activeEffect) {
        ref = reactivity_esm_bundler_toRaw(ref);
        if ((false)) {}
        else {
            trackEffects(ref.dep || (ref.dep = createDep()));
        }
    }
}
function triggerRefValue(ref, newVal) {
    ref = reactivity_esm_bundler_toRaw(ref);
    if (ref.dep) {
        if ((false)) {}
        else {
            triggerEffects(ref.dep);
        }
    }
}
function reactivity_esm_bundler_isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function reactivity_esm_bundler_ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (reactivity_esm_bundler_isRef(rawValue)) {
        return rawValue;
    }
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = undefined;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : reactivity_esm_bundler_toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        newVal = this.__v_isShallow ? newVal : reactivity_esm_bundler_toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = this.__v_isShallow ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
        }
    }
}
function triggerRef(ref) {
    triggerRefValue(ref, ( false) ? 0 : void 0);
}
function unref(ref) {
    return reactivity_esm_bundler_isRef(ref) ? ref.value : ref;
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (reactivity_esm_bundler_isRef(oldValue) && !reactivity_esm_bundler_isRef(value)) {
            oldValue.value = value;
            return true;
        }
        else {
            return Reflect.set(target, key, value, receiver);
        }
    }
};
function proxyRefs(objectWithRefs) {
    return reactivity_esm_bundler_isReactive(objectWithRefs)
        ? objectWithRefs
        : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory) {
        this.dep = undefined;
        this.__v_isRef = true;
        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (false) {}
    const ret = isArray(object) ? new Array(object.length) : {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === undefined ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
}
function toRef(object, key, defaultValue) {
    const val = object[key];
    return reactivity_esm_bundler_isRef(val)
        ? val
        : new ObjectRefImpl(object, key, defaultValue);
}

class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR) {
        this._setter = _setter;
        this.dep = undefined;
        this.__v_isRef = true;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
            }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly" /* IS_READONLY */] = isReadonly;
    }
    get value() {
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        const self = reactivity_esm_bundler_toRaw(this);
        trackRefValue(self);
        if (self._dirty || !self._cacheable) {
            self._dirty = false;
            self._value = self.effect.run();
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = shared_esm_bundler_isFunction(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ( false)
            ? 0
            : shared_esm_bundler_NOOP;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (false) {}
    return cRef;
}

var _a;
const tick = Promise.resolve();
const queue = (/* unused pure expression or super */ null && ([]));
let queued = false;
const scheduler = (fn) => {
    queue.push(fn);
    if (!queued) {
        queued = true;
        tick.then(flush);
    }
};
const flush = () => {
    for (let i = 0; i < queue.length; i++) {
        queue[i]();
    }
    queue.length = 0;
    queued = false;
};
class DeferredComputedRefImpl {
    constructor(getter) {
        this.dep = undefined;
        this._dirty = true;
        this.__v_isRef = true;
        this[_a] = true;
        let compareTarget;
        let hasCompareTarget = false;
        let scheduled = false;
        this.effect = new ReactiveEffect(getter, (computedTrigger) => {
            if (this.dep) {
                if (computedTrigger) {
                    compareTarget = this._value;
                    hasCompareTarget = true;
                }
                else if (!scheduled) {
                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                    scheduled = true;
                    hasCompareTarget = false;
                    scheduler(() => {
                        if (this.effect.active && this._get() !== valueToCompare) {
                            triggerRefValue(this);
                        }
                        scheduled = false;
                    });
                }
                // chained upstream computeds are notified synchronously to ensure
                // value invalidation in case of sync access; normal effects are
                // deferred to be triggered in scheduler.
                for (const e of this.dep) {
                    if (e.computed instanceof DeferredComputedRefImpl) {
                        e.scheduler(true /* computedTrigger */);
                    }
                }
            }
            this._dirty = true;
        });
        this.effect.computed = this;
    }
    _get() {
        if (this._dirty) {
            this._dirty = false;
            return (this._value = this.effect.run());
        }
        return this._value;
    }
    get value() {
        trackRefValue(this);
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        return reactivity_esm_bundler_toRaw(this)._get();
    }
}
_a = "__v_isReadonly" /* IS_READONLY */;
function deferredComputed(getter) {
    return new DeferredComputedRefImpl(getter);
}



;// CONCATENATED MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js





const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function runtime_core_esm_bundler_warn(msg, ...args) {
    // avoid props formatting or warn handler tracking deps that might be mutated
    // during patch, leading to infinite recursion.
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
            msg + args.join(''),
            instance && instance.proxy,
            trace
                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
                .join('\n'),
            trace
        ]);
    }
    else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        /* istanbul ignore if */
        if (trace.length &&
            // avoid spamming console during tests
            !false) {
            warnArgs.push(`\n`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
    }
    resetTracking();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
        return [];
    }
    // we can't just use the stack because it will be incomplete during updates
    // that did not start from the root. Re-construct the parent chain using
    // instance parent pointers.
    const normalizedStack = [];
    while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
            last.recurseCount++;
        }
        else {
            normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
            });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
/* istanbul ignore next */
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props
        ? [open, ...formatProps(vnode.props), close]
        : [open + close];
}
/* istanbul ignore next */
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach(key => {
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
        res.push(` ...`);
    }
    return res;
}
/* istanbul ignore next */
function formatProp(key, value, raw) {
    if (shared_esm_bundler_isString(value)) {
        value = (__webpack_require__(8334)/* .stringify */ .P)(value);
        return raw ? value : [`${key}=${value}`];
    }
    else if (typeof value === 'number' ||
        typeof value === 'boolean' ||
        value == null) {
        return raw ? value : [`${key}=${value}`];
    }
    else if (reactivity_esm_bundler_isRef(value)) {
        value = formatProp(key, reactivity_esm_bundler_toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
    }
    else if (shared_esm_bundler_isFunction(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    }
    else {
        value = reactivity_esm_bundler_toRaw(value);
        return raw ? value : [`${key}=`, value];
    }
}

const ErrorTypeStrings = {
    ["sp" /* SERVER_PREFETCH */]: 'serverPrefetch hook',
    ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
    ["c" /* CREATED */]: 'created hook',
    ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
    ["m" /* MOUNTED */]: 'mounted hook',
    ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
    ["u" /* UPDATED */]: 'updated',
    ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
    ["um" /* UNMOUNTED */]: 'unmounted hook',
    ["a" /* ACTIVATED */]: 'activated hook',
    ["da" /* DEACTIVATED */]: 'deactivated hook',
    ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
    ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
    ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
    [0 /* SETUP_FUNCTION */]: 'setup function',
    [1 /* RENDER_FUNCTION */]: 'render function',
    [2 /* WATCH_GETTER */]: 'watcher getter',
    [3 /* WATCH_CALLBACK */]: 'watcher callback',
    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
    [7 /* VNODE_HOOK */]: 'vnode hook',
    [8 /* DIRECTIVE_HOOK */]: 'directive hook',
    [9 /* TRANSITION_HOOK */]: 'transition hook',
    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
    [12 /* FUNCTION_REF */]: 'ref function',
    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    }
    catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (shared_esm_bundler_isFunction(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && shared_esm_bundler_isPromise(res)) {
            res.catch(err => {
                handleError(err, instance, type);
            });
        }
        return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        // the exposed instance is the render proxy to keep it consistent with 2.x
        const exposedInstance = instance.proxy;
        // in production the hook receives only the error code
        const errorInfo = ( false) ? 0 : type;
        while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                        return;
                    }
                }
            }
            cur = cur.parent;
        }
        // app-level handling
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    if ((false)) {}
    else {
        // recover in prod to reduce the impact on end-user
        console.error(err);
    }
}

let isFlushing = false;
let isFlushPending = false;
const runtime_core_esm_bundler_queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function runtime_core_esm_bundler_nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
// #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.
function findInsertionIndex(id) {
    // the start index should be `flushIndex + 1`
    let start = flushIndex + 1;
    let end = runtime_core_esm_bundler_queue.length;
    while (start < end) {
        const middle = (start + end) >>> 1;
        const middleJobId = getId(runtime_core_esm_bundler_queue[middle]);
        middleJobId < id ? (start = middle + 1) : (end = middle);
    }
    return start;
}
function queueJob(job) {
    // the dedupe search uses the startIndex argument of Array.includes()
    // by default the search index includes the current job that is being run
    // so it cannot recursively trigger itself again.
    // if the job is a watch() callback, the search will start with a +1 index to
    // allow it recursively trigger itself - it is the user's responsibility to
    // ensure it doesn't end up in an infinite loop.
    if ((!runtime_core_esm_bundler_queue.length ||
        !runtime_core_esm_bundler_queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&
        job !== currentPreFlushParentJob) {
        if (job.id == null) {
            runtime_core_esm_bundler_queue.push(job);
        }
        else {
            runtime_core_esm_bundler_queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = runtime_core_esm_bundler_queue.indexOf(job);
    if (i > flushIndex) {
        runtime_core_esm_bundler_queue.splice(i, 1);
    }
}
function queueCb(cb, activeQueue, pendingQueue, index) {
    if (!shared_esm_bundler_isArray(cb)) {
        if (!activeQueue ||
            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
            pendingQueue.push(cb);
        }
    }
    else {
        // if cb is an array, it is a component lifecycle hook which can only be
        // triggered by a job, which is already deduped in the main queue, so
        // we can skip duplicate check here to improve perf
        pendingQueue.push(...cb);
    }
    queueFlush();
}
function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
    if (pendingPreFlushCbs.length) {
        currentPreFlushParentJob = parentJob;
        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
        pendingPreFlushCbs.length = 0;
        if ((false)) {}
        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
            if (false) {}
            activePreFlushCbs[preFlushIndex]();
        }
        activePreFlushCbs = null;
        preFlushIndex = 0;
        currentPreFlushParentJob = null;
        // recursively flush until it drains
        flushPreFlushCbs(seen, parentJob);
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        // #1947 already has active queue, nested flushPostFlushCbs call
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        if ((false)) {}
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            if (false) {}
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if ((false)) {}
    flushPreFlushCbs(seen);
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child so its render effect will have smaller
    //    priority number)
    // 2. If a component is unmounted during a parent component's update,
    //    its update can be skipped.
    runtime_core_esm_bundler_queue.sort((a, b) => getId(a) - getId(b));
    // conditional usage of checkRecursiveUpdate must be determined out of
    // try ... catch block since Rollup by default de-optimizes treeshaking
    // inside try-catch. This can leave all warning code unshaked. Although
    // they would get eventually shaken by a minifier like terser, some minifiers
    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
    const check = ( false)
        ? 0
        : shared_esm_bundler_NOOP;
    try {
        for (flushIndex = 0; flushIndex < runtime_core_esm_bundler_queue.length; flushIndex++) {
            const job = runtime_core_esm_bundler_queue[flushIndex];
            if (job && job.active !== false) {
                if (false) {}
                // console.log(`running:`, job.id)
                callWithErrorHandling(job, null, 14 /* SCHEDULER */);
            }
        }
    }
    finally {
        flushIndex = 0;
        runtime_core_esm_bundler_queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        // some postFlushCb queued jobs!
        // keep flushing until it drains.
        if (runtime_core_esm_bundler_queue.length ||
            pendingPreFlushCbs.length ||
            pendingPostFlushCbs.length) {
            flushJobs(seen);
        }
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
        seen.set(fn, 1);
    }
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            runtime_core_esm_bundler_warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +
                `This means you have a reactive effect that is mutating its own ` +
                `dependencies and thus recursively triggering itself. Possible sources ` +
                `include component template, render function, updated hook or ` +
                `watcher source function.`);
            return true;
        }
        else {
            seen.set(fn, count + 1);
        }
    }
}

/* eslint-disable no-restricted-globals */
let isHmrUpdating = false;
const hmrDirtyComponents = new Set();
// Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.
if ((false)) {}
const map = new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) {
        return false;
    }
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
        return;
    }
    // update initial record (for not-yet-rendered component)
    record.initialDef.render = newRender;
    [...record.instances].forEach(instance => {
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        // this flag forces child components with slot content to update
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
        return;
    newComp = normalizeClassComponent(newComp);
    // update initial def (for not-yet-rendered components)
    updateComponentDef(record.initialDef, newComp);
    // create a snapshot which avoids the set being mutated during updates
    const instances = [...record.instances];
    for (const instance of instances) {
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            // 1. Update existing comp definition to match new one
            if (oldComp !== record.initialDef) {
                updateComponentDef(oldComp, newComp);
            }
            // 2. mark definition dirty. This forces the renderer to replace the
            // component on patch.
            hmrDirtyComponents.add(oldComp);
        }
        // 3. invalidate options resolution cache
        instance.appContext.optionsCache.delete(instance.type);
        // 4. actually update
        if (instance.ceReload) {
            // custom element
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        }
        else if (instance.parent) {
            // 4. Force the parent instance to re-render. This will cause all updated
            // components to be unmounted and re-mounted. Queue the update so that we
            // don't end up forcing the same parent to re-render multiple times.
            queueJob(instance.parent.update);
            // instance is the inner component of an async custom element
            // invoke to reset styles
            if (instance.parent.type.__asyncLoader &&
                instance.parent.ceReload) {
                instance.parent.ceReload(newComp.styles);
            }
        }
        else if (instance.appContext.reload) {
            // root instance mounted via createApp() has a reload method
            instance.appContext.reload();
        }
        else if (typeof window !== 'undefined') {
            // root instance inside tree created via raw render(). Force reload.
            window.location.reload();
        }
        else {
            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
        }
    }
    // 5. make sure to cleanup dirty hmr components after update
    queuePostFlushCb(() => {
        for (const instance of instances) {
            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
        }
    });
}
function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (const key in oldComp) {
        if (key !== '__file' && !(key in newComp)) {
            delete oldComp[key];
        }
    }
}
function tryWrap(fn) {
    return (id, arg) => {
        try {
            return fn(id, arg);
        }
        catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                `Full reload required.`);
        }
    };
}

let devtools;
let buffer = (/* unused pure expression or super */ null && ([]));
let devtoolsNotInstalled = false;
function emit(event, ...args) {
    if (devtools) {
        devtools.emit(event, ...args);
    }
    else if (!devtoolsNotInstalled) {
        buffer.push({ event, args });
    }
}
function setDevtoolsHook(hook, target) {
    var _a, _b;
    devtools = hook;
    if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
        buffer = [];
    }
    else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    // eslint-disable-next-line no-restricted-globals
    typeof window !== 'undefined' &&
        // some envs mock window but not fully
        window.HTMLElement &&
        // also exclude jsdom
        !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {
        const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);
        replay.push((newHook) => {
            setDevtoolsHook(newHook, target);
        });
        // clear buffer after 3s - the user probably doesn't have devtools installed
        // at all, and keeping the buffer will cause memory leaks (#4738)
        setTimeout(() => {
            if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3000);
    }
    else {
        // non-browser env, assume not installed
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit("app:init" /* APP_INIT */, app, version, {
        Fragment: runtime_core_esm_bundler_Fragment,
        Text,
        Comment,
        Static: runtime_core_esm_bundler_Static
    });
}
function devtoolsUnmountApp(app) {
    emit("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /*#__PURE__*/ (/* unused pure expression or super */ null && (createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */)));
const devtoolsComponentUpdated = 
/*#__PURE__*/ (/* unused pure expression or super */ null && (createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */)));
const devtoolsComponentRemoved = 
/*#__PURE__*/ (/* unused pure expression or super */ null && (createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */)));
function createDevtoolsComponentHook(hook) {
    return (component) => {
        emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
    };
}
const devtoolsPerfStart = /*#__PURE__*/ (/* unused pure expression or super */ null && (createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */)));
const devtoolsPerfEnd = /*#__PURE__*/ (/* unused pure expression or super */ null && (createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */)));
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
        emit(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);
}

function emit$1(instance, event, ...rawArgs) {
    const props = instance.vnode.props || shared_esm_bundler_EMPTY_OBJ;
    if ((false)) {}
    let args = rawArgs;
    const isModelListener = event.startsWith('update:');
    // for v-model update:xxx events, apply modifiers on args
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || shared_esm_bundler_EMPTY_OBJ;
        if (trim) {
            args = rawArgs.map(a => a.trim());
        }
        else if (number) {
            args = rawArgs.map(shared_esm_bundler_toNumber);
        }
    }
    if (false) {}
    if ((false)) {}
    let handlerName;
    let handler = props[(handlerName = shared_esm_bundler_toHandlerKey(event))] ||
        // also try camelCase event handler (#2249)
        props[(handlerName = shared_esm_bundler_toHandlerKey(camelize(event)))];
    // for v-model update:xxx events, also trigger kebab-case equivalent
    // for props passed via kebab-case
    if (!handler && isModelListener) {
        handler = props[(handlerName = shared_esm_bundler_toHandlerKey(shared_esm_bundler_hyphenate(event)))];
    }
    if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) {
            instance.emitted = {};
        }
        else if (instance.emitted[handlerName]) {
            return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== undefined) {
        return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    // apply mixin/extends props
    let hasExtends = false;
    if (false) {}
    if (!raw && !hasExtends) {
        cache.set(comp, null);
        return null;
    }
    if (shared_esm_bundler_isArray(raw)) {
        raw.forEach(key => (normalized[key] = null));
    }
    else {
        shared_esm_bundler_extend(normalized, raw);
    }
    cache.set(comp, normalized);
    return normalized;
}
// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(options, key) {
    if (!options || !shared_esm_bundler_isOn(key)) {
        return false;
    }
    key = key.slice(2).replace(/Once$/, '');
    return (shared_esm_bundler_hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||
        shared_esm_bundler_hasOwn(options, shared_esm_bundler_hyphenate(key)) ||
        shared_esm_bundler_hasOwn(options, key));
}

/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */
let currentRenderingInstance = null;
let currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = (instance && instance.type.__scopeId) || null;
    return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */
function pushScopeId(id) {
    currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */
function popScopeId() {
    currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */
const withScopeId = (_id) => withCtx;
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only
) {
    if (!ctx)
        return fn;
    // already normalized
    if (fn._n) {
        return fn;
    }
    const renderFnWithContext = (...args) => {
        // If a user calls a compiled slot inside a template expression (#1745), it
        // can mess up block tracking, so by default we disable block tracking and
        // force bail out when invoking a compiled slot (indicated by the ._d flag).
        // This isn't necessary if rendering a compiled `<slot>`, so we flip the
        // ._d flag off when invoking the wrapped fn inside `renderSlot`.
        if (renderFnWithContext._d) {
            setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        const res = fn(...args);
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
            setBlockTracking(1);
        }
        if (false) {}
        return res;
    };
    // mark normalized to avoid duplicated wrapping
    renderFnWithContext._n = true;
    // mark this as compiled by default
    // this is used in vnode.ts -> normalizeChildren() to set the slot
    // rendering flag.
    renderFnWithContext._c = true;
    // disable block tracking by default
    renderFnWithContext._d = true;
    return renderFnWithContext;
}

/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    if ((false)) {}
    try {
        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
            // withProxy is a proxy with a different `has` trap only for
            // runtime-compiled render functions using `with` block.
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        }
        else {
            // functional
            const render = Component;
            // in dev, mark attrs accessed if optional props (attrs === props)
            if (false) {}
            result = normalizeVNode(render.length > 1
                ? render(props, ( false)
                    ? 0
                    : { attrs, slots, emit })
                : render(props, null /* we know it doesn't need it */));
            fallthroughAttrs = Component.props
                ? attrs
                : getFunctionalFallthrough(attrs);
        }
    }
    catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1 /* RENDER_FUNCTION */);
        result = runtime_core_esm_bundler_createVNode(Comment);
    }
    // attr merging
    // in dev mode, comments are preserved, and it's possible for a template
    // to have comments along side the root element which makes it a fragment
    let root = result;
    let setRoot = undefined;
    if (false /* DEV_ROOT_FRAGMENT */) {}
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & (1 /* ELEMENT */ | 6 /* COMPONENT */)) {
                if (propsOptions && keys.some(isModelListener)) {
                    // If a v-model listener (onUpdate:xxx) has a corresponding declared
                    // prop, it indicates this component expects to handle v-model and
                    // it should not fallthrough.
                    // related: #1543, #1643, #1989
                    fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                }
                root = cloneVNode(root, fallthroughAttrs);
            }
            else if (false) {}
        }
    }
    // inherit directives
    if (vnode.dirs) {
        if (false) {}
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    // inherit transition data
    if (vnode.transition) {
        if (false) {}
        root.transition = vnode.transition;
    }
    if (false) {}
    else {
        result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */
const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) {
        return [vnode, undefined];
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) {
                dynamicChildren[dynamicIndex] = updatedRoot;
            }
            else if (updatedRoot.patchFlag > 0) {
                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
        }
    };
    return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
            // ignore user comment
            if (child.type !== Comment || child.children === 'v-if') {
                if (singleRoot) {
                    // has more than 1 non-comment child, return now
                    return;
                }
                else {
                    singleRoot = child;
                }
            }
        }
        else {
            return;
        }
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
        if (key === 'class' || key === 'style' || shared_esm_bundler_isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
        }
    }
    return res;
};
const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
        }
    }
    return res;
};
const isElementRoot = (vnode) => {
    return (vnode.shapeFlag & (6 /* COMPONENT */ | 1 /* ELEMENT */) ||
        vnode.type === Comment // potential v-if branch switch
    );
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if (false) {}
    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) {
        return true;
    }
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
            // slot content that references values that might have changed,
            // e.g. in a v-for
            return true;
        }
        if (patchFlag & 16 /* FULL_PROPS */) {
            if (!prevProps) {
                return !!nextProps;
            }
            // presence of this flag indicates props are always non-null
            return hasPropsChanged(prevProps, nextProps, emits);
        }
        else if (patchFlag & 8 /* PROPS */) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] &&
                    !isEmitListener(emits, key)) {
                    return true;
                }
            }
        }
    }
    else {
        // this path is only taken by manually written render functions
        // so presence of any children leads to a forced update
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
                return true;
            }
        }
        if (prevProps === nextProps) {
            return false;
        }
        if (!prevProps) {
            return !!nextProps;
        }
        if (!nextProps) {
            return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] &&
            !isEmitListener(emitsOptions, key)) {
            return true;
        }
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el // HostNode
) {
    while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}

const isSuspense = (type) => type.__isSuspense;
// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
const SuspenseImpl = {
    name: 'Suspense',
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, 
    // platform-specific impl passed from renderer
    rendererInternals) {
        if (n1 == null) {
            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        }
        else {
            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
        }
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
// Force-casted public typing for h and TSX props inference
const Suspense = ((/* unused pure expression or super */ null && (SuspenseImpl)) );
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if (shared_esm_bundler_isFunction(eventListener)) {
        eventListener();
    }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement('div');
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));
    // start mounting the content subtree in an off-dom container
    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    // now check if we have encountered any async deps
    if (suspense.deps > 0) {
        // has async
        // invoke @fallback event
        triggerEvent(vnode, 'onPending');
        triggerEvent(vnode, 'onFallback');
        // mount the fallback tree
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    }
    else {
        // Suspense has no async deps. Just resolve.
        suspense.resolve();
    }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = (n2.suspense = n1.suspense);
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            // same root type but content may have changed.
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                suspense.resolve();
            }
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        }
        else {
            // toggled before pending tree is resolved
            suspense.pendingId++;
            if (isHydrating) {
                // if toggled before hydration is finished, the current DOM tree is
                // no longer valid. set it as the active branch so it will be unmounted
                // when resolved
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            }
            else {
                unmount(pendingBranch, parentComponent, suspense);
            }
            // increment pending ID. this is used to invalidate async callbacks
            // reset suspense state
            suspense.deps = 0;
            // discard effects from pending branch
            suspense.effects.length = 0;
            // discard previous container
            suspense.hiddenContainer = createElement('div');
            if (isInFallback) {
                // already in fallback state
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            }
            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                // toggled "back" to current active branch
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                // force resolve
                suspense.resolve(true);
            }
            else {
                // switched to a 3rd branch
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
            }
        }
    }
    else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            // root did not change, just normal patch
            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            setActiveBranch(suspense, newBranch);
        }
        else {
            // root node toggled
            // invoke @pending event
            triggerEvent(n2, 'onPending');
            // mount pending branch in off-dom container
            suspense.pendingBranch = newBranch;
            suspense.pendingId++;
            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                // incoming branch has no async deps, resolve now.
                suspense.resolve();
            }
            else {
                const { timeout, pendingId } = suspense;
                if (timeout > 0) {
                    setTimeout(() => {
                        if (suspense.pendingId === pendingId) {
                            suspense.fallback(newFallback);
                        }
                    }, timeout);
                }
                else if (timeout === 0) {
                    suspense.fallback(newFallback);
                }
            }
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    /* istanbul ignore if */
    if (false) {}
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    const timeout = shared_esm_bundler_toNumber(vnode.props && vnode.props.timeout);
    const suspense = {
        vnode,
        parent,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === 'number' ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false) {
            if ((false)) {}
            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;
            if (suspense.isHydrating) {
                suspense.isHydrating = false;
            }
            else if (!resume) {
                const delayEnter = activeBranch &&
                    pendingBranch.transition &&
                    pendingBranch.transition.mode === 'out-in';
                if (delayEnter) {
                    activeBranch.transition.afterLeave = () => {
                        if (pendingId === suspense.pendingId) {
                            move(pendingBranch, container, anchor, 0 /* ENTER */);
                        }
                    };
                }
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount current active tree
                if (activeBranch) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(activeBranch);
                    unmount(activeBranch, parentComponent, suspense, true);
                }
                if (!delayEnter) {
                    // move content from off-dom container to actual container
                    move(pendingBranch, container, anchor, 0 /* ENTER */);
                }
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            // flush buffered effects
            // check if there is a pending parent suspense
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent) {
                if (parent.pendingBranch) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            // no pending parent suspense, flush all jobs
            if (!hasUnresolvedAncestor) {
                queuePostFlushCb(effects);
            }
            suspense.effects = [];
            // invoke @resolve event
            triggerEvent(vnode, 'onResolve');
        },
        fallback(fallbackVNode) {
            if (!suspense.pendingBranch) {
                return;
            }
            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;
            // invoke @fallback event
            triggerEvent(vnode, 'onFallback');
            const anchor = next(activeBranch);
            const mountFallback = () => {
                if (!suspense.isInFallback) {
                    return;
                }
                // mount the fallback tree
                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';
            if (delayEnter) {
                activeBranch.transition.afterLeave = mountFallback;
            }
            suspense.isInFallback = true;
            // unmount current active branch
            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
            true // shouldRemove
            );
            if (!delayEnter) {
                mountFallback();
            }
        },
        move(container, anchor, type) {
            suspense.activeBranch &&
                move(suspense.activeBranch, container, anchor, type);
            suspense.container = container;
        },
        next() {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) {
                suspense.deps++;
            }
            const hydratedEl = instance.vnode.el;
            instance
                .asyncDep.catch(err => {
                handleError(err, instance, 0 /* SETUP_FUNCTION */);
            })
                .then(asyncSetupResult => {
                // retry when the setup() promise resolves.
                // component may have been unmounted before resolve.
                if (instance.isUnmounted ||
                    suspense.isUnmounted ||
                    suspense.pendingId !== instance.suspenseId) {
                    return;
                }
                // retry from this component
                instance.asyncResolved = true;
                const { vnode } = instance;
                if ((false)) {}
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl;
                }
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode, 
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), 
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) {
                    remove(placeholder);
                }
                updateHOCHostEl(instance, vnode.el);
                if ((false)) {}
                // only decrease deps count if suspense is not already resolved
                if (isInPendingSuspense && --suspense.deps === 0) {
                    suspense.resolve();
                }
            });
        },
        unmount(parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) {
                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
            }
            if (suspense.pendingBranch) {
                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
            }
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    /* eslint-disable no-restricted-globals */
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));
    // there are two possible scenarios for server-rendered suspense:
    // - success: ssr content should be fully resolved
    // - failure: ssr content should be the fallback branch.
    // however, on the client we don't really know if it has failed or not
    // attempt to hydrate the DOM assuming it has succeeded, but we still
    // need to construct a suspense boundary first
    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) {
        suspense.resolve();
    }
    return result;
    /* eslint-enable no-restricted-globals */
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren
        ? normalizeSuspenseSlot(children.fallback)
        : runtime_core_esm_bundler_createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if (shared_esm_bundler_isFunction(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            // disableTracking: false
            // allow block tracking for compiled slots
            // (see ./componentRenderContext.ts)
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if (shared_esm_bundler_isArray(s)) {
        const singleChild = filterSingleRoot(s);
        if (false) {}
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) {
        s.dynamicChildren = block.filter(c => c !== s);
    }
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if (shared_esm_bundler_isArray(fn)) {
            suspense.effects.push(...fn);
        }
        else {
            suspense.effects.push(fn);
        }
    }
    else {
        queuePostFlushCb(fn);
    }
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = (vnode.el = branch.el);
    // in case suspense is the root node of a component,
    // recursively update the HOC el
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}

function provide(key, value) {
    if (!currentInstance) {
        if ((false)) {}
    }
    else {
        let provides = currentInstance.provides;
        // by default an instance inherits its parent's provides object
        // but when it needs to provide values of its own, it creates its
        // own provides object using parent provides object as prototype.
        // this way in `inject` we can simply look up injections from direct
        // parent and let the prototype chain do the work.
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
        }
        // TS doesn't allow symbol as index type
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        const provides = instance.parent == null
            ? instance.vnode.appContext && instance.vnode.appContext.provides
            : instance.parent.provides;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && shared_esm_bundler_isFunction(defaultValue)
                ? defaultValue.call(instance.proxy)
                : defaultValue;
        }
        else if ((false)) {}
    }
    else if ((false)) {}
}

// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function runtime_core_esm_bundler_watchPostEffect(effect, options) {
    return doWatch(effect, null, (( false)
        ? 0
        : { flush: 'post' }));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (( false)
        ? 0
        : { flush: 'sync' }));
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (false) {}
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = shared_esm_bundler_EMPTY_OBJ) {
    if (false) {}
    const warnInvalidSource = (s) => {
        runtime_core_esm_bundler_warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
            `a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (reactivity_esm_bundler_isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
    }
    else if (reactivity_esm_bundler_isReactive(source)) {
        getter = () => source;
        deep = true;
    }
    else if (shared_esm_bundler_isArray(source)) {
        isMultiSource = true;
        forceTrigger = source.some(reactivity_esm_bundler_isReactive);
        getter = () => source.map(s => {
            if (reactivity_esm_bundler_isRef(s)) {
                return s.value;
            }
            else if (reactivity_esm_bundler_isReactive(s)) {
                return traverse(s);
            }
            else if (shared_esm_bundler_isFunction(s)) {
                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
            }
            else {
                ( false) && 0;
            }
        });
    }
    else if (shared_esm_bundler_isFunction(source)) {
        if (cb) {
            // getter with cb
            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onCleanup]);
            };
        }
    }
    else {
        getter = shared_esm_bundler_NOOP;
        ( false) && 0;
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
        cleanup = effect.onStop = () => {
            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager
    if (isInSSRComponentSetup) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = shared_esm_bundler_NOOP;
        if (!cb) {
            getter();
        }
        else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup
            ]);
        }
        return shared_esm_bundler_NOOP;
    }
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    const job = () => {
        if (!effect.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            const newValue = effect.run();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some((v, i) => hasChanged(v, oldValue[i]))
                    : hasChanged(newValue, oldValue)) ||
                (false  )) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            effect.run();
        }
    };
    // important: mark the job as a watcher callback so that scheduler knows
    // it is allowed to self-trigger (#1727)
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === 'sync') {
        scheduler = job; // the scheduler function gets called directly
    }
    else if (flush === 'post') {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    }
    else {
        // default: 'pre'
        scheduler = () => {
            if (!instance || instance.isMounted) {
                queuePreFlushCb(job);
            }
            else {
                // with 'pre' option, the first call must happen before
                // the component is mounted so it is called synchronously.
                job();
            }
        };
    }
    const effect = new ReactiveEffect(getter, scheduler);
    if ((false)) {}
    // initial run
    if (cb) {
        if (immediate) {
            job();
        }
        else {
            oldValue = effect.run();
        }
    }
    else if (flush === 'post') {
        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    }
    else {
        effect.run();
    }
    return () => {
        effect.stop();
        if (instance && instance.scope) {
            shared_esm_bundler_remove(instance.scope.effects, effect);
        }
    };
}
// this.$watch
function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source)
        ? source.includes('.')
            ? createPathGetter(publicThis, source)
            : () => publicThis[source]
        : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction(value)) {
        cb = value;
    }
    else {
        cb = value.handler;
        options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
        setCurrentInstance(cur);
    }
    else {
        unsetCurrentInstance();
    }
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split('.');
    return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
        }
        return cur;
    };
}
function traverse(value, seen) {
    if (!shared_esm_bundler_isObject(value) || value["__v_skip" /* SKIP */]) {
        return value;
    }
    seen = seen || new Set();
    if (seen.has(value)) {
        return value;
    }
    seen.add(value);
    if (reactivity_esm_bundler_isRef(value)) {
        traverse(value.value, seen);
    }
    else if (shared_esm_bundler_isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if (shared_esm_bundler_isSet(value) || isMap(value)) {
        value.forEach((v) => {
            traverse(v, seen);
        });
    }
    else if (isPlainObject(value)) {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}

function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: new Map()
    };
    runtime_core_esm_bundler_onMounted(() => {
        state.isMounted = true;
    });
    onBeforeUnmount(() => {
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
    },
    setup(props, { slots }) {
        const instance = runtime_core_esm_bundler_getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
                return;
            }
            // warn multiple elements
            if (false) {}
            // there's no need to track reactivity for these props so use the raw
            // props for a bit better perf
            const rawProps = reactivity_esm_bundler_toRaw(props);
            const { mode } = rawProps;
            // check mode
            if (false) {}
            // at this point children has a guaranteed length of 1.
            const child = children[0];
            if (state.isLeaving) {
                return emptyPlaceholder(child);
            }
            // in the case of <transition><keep-alive/></transition>, we need to
            // compare the type of the kept-alive children.
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
                return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === undefined) {
                    prevTransitionKey = key;
                }
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            // handle mode
            if (oldInnerChild &&
                oldInnerChild.type !== Comment &&
                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                    state.isLeaving = true;
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = () => {
                        state.isLeaving = false;
                        instance.update();
                    };
                    return emptyPlaceholder(child);
                }
                else if (mode === 'in-out' && innerChild.type !== Comment) {
                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                        // early removal callback
                        el._leaveCb = () => {
                            earlyRemove();
                            el._leaveCb = undefined;
                            delete enterHooks.delayedLeave;
                        };
                        enterHooks.delayedLeave = delayedLeave;
                    };
                }
            }
            return child;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args) => {
        hook &&
            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) {
                    hook = onBeforeAppear || onBeforeEnter;
                }
                else {
                    return;
                }
            }
            // for same element (v-show)
            if (el._leaveCb) {
                el._leaveCb(true /* cancelled */);
            }
            // for toggled element with same key (v-if)
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode &&
                isSameVNodeType(vnode, leavingVNode) &&
                leavingVNode.el._leaveCb) {
                // force early removal (not cancelled)
                leavingVNode.el._leaveCb();
            }
            callHook(hook, [el]);
        },
        enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                }
                else {
                    return;
                }
            }
            let called = false;
            const done = (el._enterCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                if (cancelled) {
                    callHook(cancelHook, [el]);
                }
                else {
                    callHook(afterHook, [el]);
                }
                if (hooks.delayedLeave) {
                    hooks.delayedLeave();
                }
                el._enterCb = undefined;
            });
            if (hook) {
                hook(el, done);
                if (hook.length <= 1) {
                    done();
                }
            }
            else {
                done();
            }
        },
        leave(el, remove) {
            const key = String(vnode.key);
            if (el._enterCb) {
                el._enterCb(true /* cancelled */);
            }
            if (state.isUnmounting) {
                return remove();
            }
            callHook(onBeforeLeave, [el]);
            let called = false;
            const done = (el._leaveCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                remove();
                if (cancelled) {
                    callHook(onLeaveCancelled, [el]);
                }
                else {
                    callHook(onAfterLeave, [el]);
                }
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key];
                }
            });
            leavingVNodesCache[key] = vnode;
            if (onLeave) {
                onLeave(el, done);
                if (onLeave.length <= 1) {
                    done();
                }
            }
            else {
                done();
            }
        },
        clone(vnode) {
            return resolveTransitionHooks(vnode, props, state, instance);
        }
    };
    return hooks;
}
// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode)
        ? vnode.children
            ? vnode.children[0]
            : undefined
        : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
    }
    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    }
    else {
        vnode.transition = hooks;
    }
}
function getTransitionRawChildren(children, keepComment = false) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // handle fragment children case, e.g. v-for
        if (child.type === runtime_core_esm_bundler_Fragment) {
            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)
                keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
        }
        // comment placeholders should be skipped, e.g. v-if
        else if (keepComment || child.type !== Comment) {
            ret.push(child);
        }
    }
    // #1126 if a transition children list contains multiple sub fragments, these
    // fragments will be merged into a flat children array. Since each v-for
    // fragment may contain different static bindings inside, we need to de-op
    // these children to force full diffs to ensure correct behavior.
    if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2 /* BAIL */;
        }
    }
    return ret;
}

// implementation, close to no-op
function runtime_core_esm_bundler_defineComponent(options) {
    return shared_esm_bundler_isFunction(options) ? { setup: options, name: options.name } : options;
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if (isFunction(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest =
                loader()
                    .catch(err => {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                        return new Promise((resolve, reject) => {
                            const userRetry = () => resolve(retry());
                            const userFail = () => reject(err);
                            userOnError(err, userRetry, userFail, retries + 1);
                        });
                    }
                    else {
                        throw err;
                    }
                })
                    .then((comp) => {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                        return pendingRequest;
                    }
                    if (false) {}
                    // interop module default
                    if (comp &&
                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                        comp = comp.default;
                    }
                    if (false) {}
                    resolvedComp = comp;
                    return comp;
                })));
    };
    return runtime_core_esm_bundler_defineComponent({
        name: 'AsyncComponentWrapper',
        __asyncLoader: load,
        get __asyncResolved() {
            return resolvedComp;
        },
        setup() {
            const instance = currentInstance;
            // already resolved
            if (resolvedComp) {
                return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
                pendingRequest = null;
                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);
            };
            // suspense-controlled or SSR.
            if ((suspensible && instance.suspense) ||
                (isInSSRComponentSetup)) {
                return load()
                    .then(comp => {
                    return () => createInnerComp(comp, instance);
                })
                    .catch(err => {
                    onError(err);
                    return () => errorComponent
                        ? runtime_core_esm_bundler_createVNode(errorComponent, {
                            error: err
                        })
                        : null;
                });
            }
            const loaded = ref(false);
            const error = ref();
            const delayed = ref(!!delay);
            if (delay) {
                setTimeout(() => {
                    delayed.value = false;
                }, delay);
            }
            if (timeout != null) {
                setTimeout(() => {
                    if (!loaded.value && !error.value) {
                        const err = new Error(`Async component timed out after ${timeout}ms.`);
                        onError(err);
                        error.value = err;
                    }
                }, timeout);
            }
            load()
                .then(() => {
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                    // parent is keep-alive, force update so the loaded component's
                    // name is taken into account
                    queueJob(instance.parent.update);
                }
            })
                .catch(err => {
                onError(err);
                error.value = err;
            });
            return () => {
                if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance);
                }
                else if (error.value && errorComponent) {
                    return runtime_core_esm_bundler_createVNode(errorComponent, {
                        error: error.value
                    });
                }
                else if (loadingComponent && !delayed.value) {
                    return runtime_core_esm_bundler_createVNode(loadingComponent);
                }
            };
        }
    });
}
function createInnerComp(comp, { vnode: { ref, props, children } }) {
    const vnode = runtime_core_esm_bundler_createVNode(comp, props, children);
    // ensure inner component inherits the async wrapper's ref owner
    vnode.ref = ref;
    return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(props, { slots }) {
        const instance = runtime_core_esm_bundler_getCurrentInstance();
        // KeepAlive communicates with the instantiated renderer via the
        // ctx where the renderer passes in its internals,
        // and the KeepAlive instance exposes activate/deactivate implementations.
        // The whole point of this is to avoid importing KeepAlive directly in the
        // renderer to facilitate tree-shaking.
        const sharedContext = instance.ctx;
        // if the internal renderer is not registered, it indicates that this is server-side rendering,
        // for KeepAlive, we just need to render its children
        if (!sharedContext.renderer) {
            return slots.default;
        }
        const cache = new Map();
        const keys = new Set();
        let current = null;
        if (false) {}
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement('div');
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance = vnode.component;
            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
            // in case props have changed
            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(() => {
                instance.isDeactivated = false;
                if (instance.a) {
                    invokeArrayFns(instance.a);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
            }, parentSuspense);
            if (false) {}
        };
        sharedContext.deactivate = (vnode) => {
            const instance = vnode.component;
            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
            queuePostRenderEffect(() => {
                if (instance.da) {
                    invokeArrayFns(instance.da);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
                instance.isDeactivated = true;
            }, parentSuspense);
            if (false) {}
        };
        function unmount(vnode) {
            // reset the shapeFlag so it can be properly unmounted
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key) => {
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key);
                }
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) {
                unmount(cached);
            }
            else if (current) {
                // current active instance should no longer be kept-alive.
                // we can't unmount it now but it might be later, so reset its flag now.
                resetShapeFlag(current);
            }
            cache.delete(key);
            keys.delete(key);
        }
        // prune cache on include/exclude prop change
        watch(() => [props.include, props.exclude], ([include, exclude]) => {
            include && pruneCache(name => matches(include, name));
            exclude && pruneCache(name => !matches(exclude, name));
        }, 
        // prune post-render after `current` has been updated
        { flush: 'post', deep: true });
        // cache sub tree after render
        let pendingCacheKey = null;
        const cacheSubtree = () => {
            // fix #1621, the pendingCacheKey could be 0
            if (pendingCacheKey != null) {
                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
        };
        runtime_core_esm_bundler_onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
            cache.forEach(cached => {
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type) {
                    // current instance will be unmounted as part of keep-alive's unmount
                    resetShapeFlag(vnode);
                    // but invoke its deactivated hook here
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return () => {
            pendingCacheKey = null;
            if (!slots.default) {
                return null;
            }
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                if ((false)) {}
                current = null;
                return children;
            }
            else if (!isVNode(rawVNode) ||
                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&
                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            // for async components, name check should be based in its loaded
            // inner component if available
            const name = getComponentName(isAsyncWrapper(vnode)
                ? vnode.type.__asyncResolved || {}
                : comp);
            const { include, exclude, max } = props;
            if ((include && (!name || !matches(include, name))) ||
                (exclude && name && matches(exclude, name))) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            // clone vnode if it's reused because we are going to mutate it
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {
                    rawVNode.ssContent = vnode;
                }
            }
            // #1513 it's possible for the returned vnode to be cloned due to attr
            // fallthrough or scopeId, so the vnode here may not be the final vnode
            // that is mounted. Instead of caching it directly, we store the pending
            // key and cache `instance.subTree` (the normalized vnode) in
            // beforeMount/beforeUpdate hooks.
            pendingCacheKey = key;
            if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition);
                }
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
            }
            else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(keys.values().next().value);
                }
            }
            // avoid vnode being unmounted
            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
            current = vnode;
            return rawVNode;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const KeepAlive = (/* unused pure expression or super */ null && (KeepAliveImpl));
function matches(pattern, name) {
    if (shared_esm_bundler_isArray(pattern)) {
        return pattern.some((p) => matches(p, name));
    }
    else if (shared_esm_bundler_isString(pattern)) {
        return pattern.split(',').includes(name);
    }
    else if (pattern.test) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    // cache the deactivate branch check wrapper for injected hooks so the same
    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
    // deactivation check".
    const wrappedHook = hook.__wdc ||
        (hook.__wdc = () => {
            // only fire the hook if the target instance is NOT in a deactivated branch.
            let current = target;
            while (current) {
                if (current.isDeactivated) {
                    return;
                }
                current = current.parent;
            }
            return hook();
        });
    injectHook(type, wrappedHook, target);
    // In addition to registering it on the target instance, we walk up the parent
    // chain and register it on all ancestor instances that are keep-alive roots.
    // This avoids the need to walk the entire component tree when invoking these
    // hooks, and more importantly, avoids the need to track child components in
    // arrays.
    if (target) {
        let current = target.parent;
        while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    // injectHook wraps the original for error handling, so make sure to remove
    // the wrapped version.
    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);
    runtime_core_esm_bundler_onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    let shapeFlag = vnode.shapeFlag;
    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
    }
    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;
    }
    vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        // cache the error handling wrapper for injected hooks so the same hook
        // can be properly deduped by the scheduler. "__weh" stands for "with error
        // handling".
        const wrappedHook = hook.__weh ||
            (hook.__weh = (...args) => {
                if (target.isUnmounted) {
                    return;
                }
                // disable tracking inside all lifecycle hooks
                // since they can potentially be called inside effects.
                pauseTracking();
                // Set currentInstance during hook invocation.
                // This assumes the hook does not synchronously trigger other hooks, which
                // can only be false when the user does something really funky.
                setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(hook, target, type, args);
                unsetCurrentInstance();
                resetTracking();
                return res;
            });
        if (prepend) {
            hooks.unshift(wrappedHook);
        }
        else {
            hooks.push(wrappedHook);
        }
        return wrappedHook;
    }
    else if ((false)) {}
}
const createHook = (lifecycle) => (hook, target = currentInstance) => 
// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
(!isInSSRComponentSetup || lifecycle === "sp" /* SERVER_PREFETCH */) &&
    injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
const runtime_core_esm_bundler_onMounted = createHook("m" /* MOUNTED */);
const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
const onUpdated = createHook("u" /* UPDATED */);
const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
const runtime_core_esm_bundler_onUnmounted = createHook("um" /* UNMOUNTED */);
const onServerPrefetch = createHook("sp" /* SERVER_PREFETCH */);
const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec" /* ERROR_CAPTURED */, hook, target);
}

function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type, key) => {
        if (cache[key]) {
            runtime_core_esm_bundler_warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        }
        else {
            cache[key] = type;
        }
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    // do not cache property access on public proxy during state initialization
    shouldCacheAccess = false;
    // call beforeCreate first before accessing other options since
    // the hook may mutate resolved options (#2791)
    if (options.beforeCreate) {
        callHook(options.beforeCreate, instance, "bc" /* BEFORE_CREATE */);
    }
    const { 
    // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
    // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, 
    // public API
    expose, inheritAttrs, 
    // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = ( false) ? 0 : null;
    if ((false)) {}
    // options initialization order (to be consistent with Vue 2):
    // - props (already done outside of this function)
    // - inject
    // - methods
    // - data (deferred since it relies on `this` access)
    // - computed
    // - watch (deferred since it relies on `this` access)
    if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
    }
    if (methods) {
        for (const key in methods) {
            const methodHandler = methods[key];
            if (isFunction(methodHandler)) {
                // In dev mode, we use the `createRenderContext` function to define
                // methods to the proxy target, and those are read-only but
                // reconfigurable, so it needs to be redefined here
                if ((false)) {}
                else {
                    ctx[key] = methodHandler.bind(publicThis);
                }
                if ((false)) {}
            }
            else if ((false)) {}
        }
    }
    if (dataOptions) {
        if (false) {}
        const data = dataOptions.call(publicThis, publicThis);
        if (false) {}
        if (!isObject(data)) {
            ( false) && 0;
        }
        else {
            instance.data = reactive(data);
            if ((false)) {}
        }
    }
    // state initialization complete at this point - start caching access
    shouldCacheAccess = true;
    if (computedOptions) {
        for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = isFunction(opt)
                ? opt.bind(publicThis, publicThis)
                : isFunction(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : NOOP;
            if (false) {}
            const set = !isFunction(opt) && isFunction(opt.set)
                ? opt.set.bind(publicThis)
                : ( false)
                    ? 0
                    : NOOP;
            const c = runtime_core_esm_bundler_computed({
                get,
                set
            });
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c.value,
                set: v => (c.value = v)
            });
            if ((false)) {}
        }
    }
    if (watchOptions) {
        for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
        }
    }
    if (provideOptions) {
        const provides = isFunction(provideOptions)
            ? provideOptions.call(publicThis)
            : provideOptions;
        Reflect.ownKeys(provides).forEach(key => {
            provide(key, provides[key]);
        });
    }
    if (created) {
        callHook(created, instance, "c" /* CREATED */);
    }
    function registerLifecycleHook(register, hook) {
        if (isArray(hook)) {
            hook.forEach(_hook => register(_hook.bind(publicThis)));
        }
        else if (hook) {
            register(hook.bind(publicThis));
        }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(runtime_core_esm_bundler_onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(runtime_core_esm_bundler_onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach(key => {
                Object.defineProperty(exposed, key, {
                    get: () => publicThis[key],
                    set: val => (publicThis[key] = val)
                });
            });
        }
        else if (!instance.exposed) {
            instance.exposed = {};
        }
    }
    // options that are handled when creating the instance but also need to be
    // applied from mixins
    if (render && instance.render === NOOP) {
        instance.render = render;
    }
    if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
    }
    // asset options.
    if (components)
        instance.components = components;
    if (directives)
        instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
    if (isArray(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject(opt)) {
            if ('default' in opt) {
                injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);
            }
            else {
                injected = inject(opt.from || key);
            }
        }
        else {
            injected = inject(opt);
        }
        if (isRef(injected)) {
            // TODO remove the check in 3.3
            if (unwrapRef) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    get: () => injected.value,
                    set: v => (injected.value = v)
                });
            }
            else {
                if ((false)) {}
                ctx[key] = injected;
            }
        }
        else {
            ctx[key] = injected;
        }
        if ((false)) {}
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling(isArray(hook)
        ? hook.map(h => h.bind(instance.proxy))
        : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes('.')
        ? createPathGetter(publicThis, key)
        : () => publicThis[key];
    if (isString(raw)) {
        const handler = ctx[raw];
        if (isFunction(handler)) {
            watch(getter, handler);
        }
        else if ((false)) {}
    }
    else if (isFunction(raw)) {
        watch(getter, raw.bind(publicThis));
    }
    else if (isObject(raw)) {
        if (isArray(raw)) {
            raw.forEach(r => createWatcher(r, ctx, publicThis, key));
        }
        else {
            const handler = isFunction(raw.handler)
                ? raw.handler.bind(publicThis)
                : ctx[raw.handler];
            if (isFunction(handler)) {
                watch(getter, handler, raw);
            }
            else if ((false)) {}
        }
    }
    else if ((false)) {}
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
        resolved = cached;
    }
    else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
            resolved = base;
        }
    }
    else {
        resolved = {};
        if (globalMixins.length) {
            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
        }
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
        mixins.forEach((m) => mergeOptions(to, m, strats, true));
    }
    for (const key in from) {
        if (asMixin && key === 'expose') {
            ( false) &&
                0;
        }
        else {
            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);
            to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) {
        return to;
    }
    if (!to) {
        return from;
    }
    return function mergedDataFn() {
        return (shared_esm_bundler_extend)(shared_esm_bundler_isFunction(to) ? to.call(this, this) : to, shared_esm_bundler_isFunction(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if (shared_esm_bundler_isArray(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
        }
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
    return to ? shared_esm_bundler_extend(shared_esm_bundler_extend(Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
    if (!to)
        return from;
    if (!from)
        return to;
    const merged = shared_esm_bundler_extend(Object.create(null), to);
    for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
}

function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
isSSR = false) {
    const props = {};
    const attrs = {};
    def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    // ensure all declared prop keys are present
    for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
            props[key] = undefined;
        }
    }
    // validation
    if ((false)) {}
    if (isStateful) {
        // stateful
        instance.props = isSSR ? props : shallowReactive(props);
    }
    else {
        if (!instance.type.props) {
            // functional w/ optional props, props === attrs
            instance.props = attrs;
        }
        else {
            // functional w/ declared props
            instance.props = props;
        }
    }
    instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = reactivity_esm_bundler_toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
     true &&
        (optimized || patchFlag > 0) &&
        !(patchFlag & 16 /* FULL_PROPS */)) {
        if (patchFlag & 8 /* PROPS */) {
            // Compiler-generated props & no keys change, just set the updated
            // the props.
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
                let key = propsToUpdate[i];
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if (shared_esm_bundler_hasOwn(attrs, key)) {
                        if (value !== attrs[key]) {
                            attrs[key] = value;
                            hasAttrsChanged = true;
                        }
                    }
                    else {
                        const camelizedKey = camelize(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);
                    }
                }
                else {
                    if (value !== attrs[key]) {
                        attrs[key] = value;
                        hasAttrsChanged = true;
                    }
                }
            }
        }
    }
    else {
        // full props update.
        if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
        }
        // in case of dynamic props, check if we need to delete keys from
        // the props object
        let kebabKey;
        for (const key in rawCurrentProps) {
            if (!rawProps ||
                // for camelCase
                (!shared_esm_bundler_hasOwn(rawProps, key) &&
                    // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = shared_esm_bundler_hyphenate(key)) === key || !shared_esm_bundler_hasOwn(rawProps, kebabKey)))) {
                if (options) {
                    if (rawPrevProps &&
                        // for camelCase
                        (rawPrevProps[key] !== undefined ||
                            // for kebab-case
                            rawPrevProps[kebabKey] !== undefined)) {
                        props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);
                    }
                }
                else {
                    delete props[key];
                }
            }
        }
        // in the case of functional component w/o props declaration, props and
        // attrs point to the same object so it should already have been updated.
        if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
                if (!rawProps ||
                    (!shared_esm_bundler_hasOwn(rawProps, key) &&
                        (!false ))) {
                    delete attrs[key];
                    hasAttrsChanged = true;
                }
            }
        }
    }
    // trigger updates for $attrs in case it's used in component slots
    if (hasAttrsChanged) {
        trigger(instance, "set" /* SET */, '$attrs');
    }
    if ((false)) {}
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
        for (let key in rawProps) {
            // key, ref are reserved and never passed down
            if (shared_esm_bundler_isReservedProp(key)) {
                continue;
            }
            const value = rawProps[key];
            // prop option names are camelized during normalization, so to support
            // kebab -> camel conversion here we need to camelize the key.
            let camelKey;
            if (options && shared_esm_bundler_hasOwn(options, (camelKey = camelize(key)))) {
                if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                    props[camelKey] = value;
                }
                else {
                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                }
            }
            else if (!isEmitListener(instance.emitsOptions, key)) {
                if (!(key in attrs) || value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                }
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = reactivity_esm_bundler_toRaw(props);
        const castValues = rawCastValues || shared_esm_bundler_EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !shared_esm_bundler_hasOwn(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = shared_esm_bundler_hasOwn(opt, 'default');
        // default values
        if (hasDefault && value === undefined) {
            const defaultValue = opt.default;
            if (opt.type !== Function && shared_esm_bundler_isFunction(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) {
                    value = propsDefaults[key];
                }
                else {
                    setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(null, props);
                    unsetCurrentInstance();
                }
            }
            else {
                value = defaultValue;
            }
        }
        // boolean casting
        if (opt[0 /* shouldCast */]) {
            if (isAbsent && !hasDefault) {
                value = false;
            }
            else if (opt[1 /* shouldCastTrue */] &&
                (value === '' || value === shared_esm_bundler_hyphenate(key))) {
                value = true;
            }
        }
    }
    return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
        return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    // apply mixin/extends props
    let hasExtends = false;
    if (false) {}
    if (!raw && !hasExtends) {
        cache.set(comp, EMPTY_ARR);
        return EMPTY_ARR;
    }
    if (shared_esm_bundler_isArray(raw)) {
        for (let i = 0; i < raw.length; i++) {
            if (false) {}
            const normalizedKey = camelize(raw[i]);
            if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = shared_esm_bundler_EMPTY_OBJ;
            }
        }
    }
    else if (raw) {
        if (false) {}
        for (const key in raw) {
            const normalizedKey = camelize(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = (normalized[normalizedKey] =
                    shared_esm_bundler_isArray(opt) || shared_esm_bundler_isFunction(opt) ? { type: opt } : opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */] =
                        stringIndex < 0 || booleanIndex < stringIndex;
                    // if the prop needs boolean casting or default value
                    if (booleanIndex > -1 || shared_esm_bundler_hasOwn(prop, 'default')) {
                        needCastKeys.push(normalizedKey);
                    }
                }
            }
        }
    }
    const res = [normalized, needCastKeys];
    cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== '$') {
        return true;
    }
    else if ((false)) {}
    return false;
}
// use function string name to check type constructors
// so that it works across vms / iframes.
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ctor === null ? 'null' : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if (shared_esm_bundler_isArray(expectedTypes)) {
        return expectedTypes.findIndex(t => isSameType(t, type));
    }
    else if (shared_esm_bundler_isFunction(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
}
/**
 * dev only
 */
function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
        let opt = options[key];
        if (opt == null)
            continue;
        validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
    }
}
/**
 * dev only
 */
function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    // required!
    if (required && isAbsent) {
        runtime_core_esm_bundler_warn('Missing required prop: "' + name + '"');
        return;
    }
    // missing but optional
    if (value == null && !prop.required) {
        return;
    }
    // type check
    if (type != null && type !== true) {
        let isValid = false;
        const types = isArray(type) ? type : [type];
        const expectedTypes = [];
        // value is valid as long as one of the specified types match
        for (let i = 0; i < types.length && !isValid; i++) {
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || '');
            isValid = valid;
        }
        if (!isValid) {
            runtime_core_esm_bundler_warn(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    // custom validator
    if (validator && !validator(value)) {
        runtime_core_esm_bundler_warn('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
}
const isSimpleType = /*#__PURE__*/ (/* unused pure expression or super */ null && (makeMap('String,Number,Boolean,Function,Symbol,BigInt')));
/**
 * dev only
 */
function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = isObject(value);
    }
    else if (expectedType === 'Array') {
        valid = isArray(value);
    }
    else if (expectedType === 'null') {
        valid = value === null;
    }
    else {
        valid = value instanceof type;
    }
    return {
        valid,
        expectedType
    };
}
/**
 * dev only
 */
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(capitalize).join(' | ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
    }
    return message;
}
/**
 * dev only
 */
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
/**
 * dev only
 */
function isExplicable(type) {
    const explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(elem => type.toLowerCase() === elem);
}
/**
 * dev only
 */
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

const isInternalKey = (key) => key[0] === '_' || key === '$stable';
const normalizeSlotValue = (value) => shared_esm_bundler_isArray(value)
    ? value.map(normalizeVNode)
    : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
    const normalized = withCtx((...args) => {
        if (false) {}
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
        if (isInternalKey(key))
            continue;
        const value = rawSlots[key];
        if (shared_esm_bundler_isFunction(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
        }
        else if (value != null) {
            if (false) {}
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children) => {
    if (false) {}
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // users can get the shallow readonly version of the slots object through `this.$slots`,
            // we should avoid the proxy object polluting the slots of the internal instance
            instance.slots = reactivity_esm_bundler_toRaw(children);
            // make compiler marker non-enumerable
            def(children, '_', type);
        }
        else {
            normalizeObjectSlots(children, (instance.slots = {}));
        }
    }
    else {
        instance.slots = {};
        if (children) {
            normalizeVNodeSlots(instance, children);
        }
    }
    def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = shared_esm_bundler_EMPTY_OBJ;
    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // compiled slots.
            if (false) {}
            else if (optimized && type === 1 /* STABLE */) {
                // compiled AND stable.
                // no need to update, and skip stale slots removal.
                needDeletionCheck = false;
            }
            else {
                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                // normalization.
                shared_esm_bundler_extend(slots, children);
                // #2893
                // when rendering the optimized slots by manually written render function,
                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
                // i.e. let the `renderSlot` create the bailed Fragment
                if (!optimized && type === 1 /* STABLE */) {
                    delete slots._;
                }
            }
        }
        else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    }
    else if (children) {
        // non slot object children (direct value) passed to a component
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
    }
    // delete stale slots
    if (needDeletionCheck) {
        for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                delete slots[key];
            }
        }
    }
};

/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
        runtime_core_esm_bundler_warn('Do not use built-in directive ids as custom directive id: ' + name);
    }
}
/**
 * Adds directives to a VNode.
 */
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        ( false) && 0;
        return vnode;
    }
    const instance = internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = shared_esm_bundler_EMPTY_OBJ] = directives[i];
        if (shared_esm_bundler_isFunction(dir)) {
            dir = {
                mounted: dir,
                updated: dir
            };
        }
        if (dir.deep) {
            traverse(value);
        }
        bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
        });
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
            // disable tracking inside all lifecycle hooks
            // since they can potentially be called inside effects.
            pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            resetTracking();
        }
    }
}

function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: shared_esm_bundler_NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: undefined,
            warnHandler: undefined,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap()
    };
}
let uid = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (rootProps != null && !shared_esm_bundler_isObject(rootProps)) {
            ( false) && 0;
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = new Set();
        let isMounted = false;
        const app = (context.app = {
            _uid: uid++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
                return context.config;
            },
            set config(v) {
                if ((false)) {}
            },
            use(plugin, ...options) {
                if (installedPlugins.has(plugin)) {
                    ( false) && 0;
                }
                else if (plugin && shared_esm_bundler_isFunction(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                }
                else if (shared_esm_bundler_isFunction(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                }
                else if ((false)) {}
                return app;
            },
            mixin(mixin) {
                if (false) {}
                else if ((false)) {}
                return app;
            },
            component(name, component) {
                if ((false)) {}
                if (!component) {
                    return context.components[name];
                }
                if (false) {}
                context.components[name] = component;
                return app;
            },
            directive(name, directive) {
                if ((false)) {}
                if (!directive) {
                    return context.directives[name];
                }
                if (false) {}
                context.directives[name] = directive;
                return app;
            },
            mount(rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    const vnode = runtime_core_esm_bundler_createVNode(rootComponent, rootProps);
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context;
                    // HMR root reload
                    if ((false)) {}
                    if (isHydrate && hydrate) {
                        hydrate(vnode, rootContainer);
                    }
                    else {
                        render(vnode, rootContainer, isSVG);
                    }
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    if (false) {}
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                }
                else if ((false)) {}
            },
            unmount() {
                if (isMounted) {
                    render(null, app._container);
                    if (false) {}
                    delete app._container.__vue_app__;
                }
                else if ((false)) {}
            },
            provide(key, value) {
                if (false) {}
                // TypeScript doesn't allow symbols as index type
                // https://github.com/Microsoft/TypeScript/issues/24587
                context.provides[key] = value;
                return app;
            }
        });
        return app;
    };
}

/**
 * Function for handling a template ref
 */
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (shared_esm_bundler_isArray(rawRef)) {
        rawRef.forEach((r, i) => setRef(r, oldRawRef && (shared_esm_bundler_isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
        // when mounting async components, nothing needs to be done,
        // because the template ref is forwarded to inner component
        return;
    }
    const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */
        ? getExposeProxy(vnode.component) || vnode.component.proxy
        : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (false) {}
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === shared_esm_bundler_EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
    const setupState = owner.setupState;
    // dynamic ref changed. unset old ref
    if (oldRef != null && oldRef !== ref) {
        if (shared_esm_bundler_isString(oldRef)) {
            refs[oldRef] = null;
            if (shared_esm_bundler_hasOwn(setupState, oldRef)) {
                setupState[oldRef] = null;
            }
        }
        else if (reactivity_esm_bundler_isRef(oldRef)) {
            oldRef.value = null;
        }
    }
    if (shared_esm_bundler_isFunction(ref)) {
        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);
    }
    else {
        const _isString = shared_esm_bundler_isString(ref);
        const _isRef = reactivity_esm_bundler_isRef(ref);
        if (_isString || _isRef) {
            const doSet = () => {
                if (rawRef.f) {
                    const existing = _isString ? refs[ref] : ref.value;
                    if (isUnmount) {
                        shared_esm_bundler_isArray(existing) && shared_esm_bundler_remove(existing, refValue);
                    }
                    else {
                        if (!shared_esm_bundler_isArray(existing)) {
                            if (_isString) {
                                refs[ref] = [refValue];
                            }
                            else {
                                ref.value = [refValue];
                                if (rawRef.k)
                                    refs[rawRef.k] = ref.value;
                            }
                        }
                        else if (!existing.includes(refValue)) {
                            existing.push(refValue);
                        }
                    }
                }
                else if (_isString) {
                    refs[ref] = value;
                    if (shared_esm_bundler_hasOwn(setupState, ref)) {
                        setupState[ref] = value;
                    }
                }
                else if (reactivity_esm_bundler_isRef(ref)) {
                    ref.value = value;
                    if (rawRef.k)
                        refs[rawRef.k] = value;
                }
                else if ((false)) {}
            };
            if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            }
            else {
                doSet();
            }
        }
        else if ((false)) {}
    }
}

let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
const isComment = (node) => node.nodeType === 8 /* COMMENT */;
// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container) => {
        if (!container.hasChildNodes()) {
            ( false) &&
                0;
            patch(null, vnode, container);
            flushPostFlushCbs();
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        if (hasMismatch && !false) {
            // this error should show up in production
            console.error(`Hydration completed but contains mismatches.`);
        }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
        const isFragmentStart = isComment(node) && node.data === '[';
        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag } = vnode;
        const domType = node.nodeType;
        vnode.el = node;
        let nextNode = null;
        switch (type) {
            case Text:
                if (domType !== 3 /* TEXT */) {
                    nextNode = onMismatch();
                }
                else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        ( false) &&
                            0;
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = nextSibling(node);
                }
                break;
            case runtime_core_esm_bundler_Static:
                if (domType !== 1 /* ELEMENT */) {
                    nextNode = onMismatch();
                }
                else {
                    // determine anchor, adopt content
                    nextNode = node;
                    // if the static vnode has its content stripped during build,
                    // adopt it from the server-rendered HTML.
                    const needToAdoptContent = !vnode.children.length;
                    for (let i = 0; i < vnode.staticCount; i++) {
                        if (needToAdoptContent)
                            vnode.children += nextNode.outerHTML;
                        if (i === vnode.staticCount - 1) {
                            vnode.anchor = nextNode;
                        }
                        nextNode = nextSibling(nextNode);
                    }
                    return nextNode;
                }
                break;
            case runtime_core_esm_bundler_Fragment:
                if (!isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                }
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    if (domType !== 1 /* ELEMENT */ ||
                        vnode.type.toLowerCase() !==
                            node.tagName.toLowerCase()) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                    }
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    nextNode = isFragmentStart
                        ? locateClosingAsyncAnchor(node)
                        : nextSibling(node);
                    // #3787
                    // if component is async, it may get moved / unmounted before its
                    // inner component is loaded, so we need to give it a placeholder
                    // vnode that matches its adopted DOM.
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = runtime_core_esm_bundler_createVNode(runtime_core_esm_bundler_Fragment);
                            subTree.anchor = nextNode
                                ? nextNode.previousSibling
                                : container.lastChild;
                        }
                        else {
                            subTree =
                                node.nodeType === 3 ? createTextVNode('') : runtime_core_esm_bundler_createVNode('div');
                        }
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    if (domType !== 8 /* COMMENT */) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                    }
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                }
                else if ((false)) {}
        }
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode);
        }
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
        // #4006 for form elements with non-string v-model value bindings
        // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
        const forcePatchValue = (type === 'input' && dirs) || type === 'option';
        // skip props & children if this is hoisted static nodes
        // #5405 in dev, always hydrate children for HMR
        if (( false) || forcePatchValue || patchFlag !== -1 /* HOISTED */) {
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                if (forcePatchValue ||
                    !optimized ||
                    patchFlag & (16 /* FULL_PROPS */ | 32 /* HYDRATE_EVENTS */)) {
                    for (const key in props) {
                        if ((forcePatchValue && key.endsWith('value')) ||
                            (isOn(key) && !isReservedProp(key))) {
                            patchProp(el, key, null, props[key], false, undefined, parentComponent);
                        }
                    }
                }
                else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);
                }
            }
            // vnode / directive hooks
            let vnodeHooks;
            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                queueEffectWithSuspense(() => {
                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
                }, parentSuspense);
            }
            // children
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                // skip if element has innerHTML / textContent
                !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while (next) {
                    hasMismatch = true;
                    if (false) {}
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            }
            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    ( false) &&
                        0;
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for (let i = 0; i < l; i++) {
            const vnode = optimized
                ? children[i]
                : (children[i] = normalizeVNode(children[i]));
            if (node) {
                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            else if (vnode.type === Text && !vnode.children) {
                continue;
            }
            else {
                hasMismatch = true;
                if (false) {}
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === ']') {
            return nextSibling((vnode.anchor = next));
        }
        else {
            // fragment didn't hydrate successfully, since we didn't get a end anchor
            // back. This should have led to node/children mismatch warnings.
            hasMismatch = true;
            // since the anchor is missing, we need to create one and insert it
            insert((vnode.anchor = createComment(`]`)), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
        hasMismatch = true;
        ( false) &&
            0;
        vnode.el = null;
        if (isFragment) {
            // remove excessive fragment nodes
            const end = locateClosingAsyncAnchor(node);
            while (true) {
                const next = nextSibling(node);
                if (next && next !== end) {
                    remove(next);
                }
                else {
                    break;
                }
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node) => {
        let match = 0;
        while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === '[')
                    match++;
                if (node.data === ']') {
                    if (match === 0) {
                        return nextSibling(node);
                    }
                    else {
                        match--;
                    }
                }
            }
        }
        return node;
    };
    return [hydrate, hydrateNode];
}

/* eslint-disable no-restricted-globals */
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (false) {}
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    if (false) {}
}
function isSupported() {
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else {
        supported = false;
    }
    return supported;
}

/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */
function initFeatureFlags() {
    const needWarn = [];
    if (false) {}
    if (false) {}
    if (false) {}
}

const queuePostRenderEffect = queueEffectWithSuspense
    ;
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */
function createRenderer(options) {
    return baseCreateRenderer(options);
}
// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function runtime_core_esm_bundler_createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
// implementation
function baseCreateRenderer(options, createHydrationFns) {
    // compile-time feature flags check
    {
        initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    if (false) {}
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = shared_esm_bundler_NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    // Note: functions inside this closure should use `const xxx = () => {}`
    // style in order to prevent being inlined by minifiers.
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized =  false ? 0 : !!n2.dynamicChildren) => {
        if (n1 === n2) {
            return;
        }
        // patching & not same type, unmount old tree
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2 /* BAIL */) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch (type) {
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case runtime_core_esm_bundler_Static:
                if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG);
                }
                else if ((false)) {}
                break;
            case runtime_core_esm_bundler_Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if ((false)) {}
        }
        // set ref
        if (ref != null && parentComponent) {
            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
    };
    const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
        }
        else {
            const el = (n2.el = n1.el);
            if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
            }
        }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
        }
        else {
            // there's no support for dynamic comments
            n2.el = n1.el;
        }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    /**
     * Dev / HMR only
     */
    const patchStaticNode = (n1, n2, container, isSVG) => {
        // static nodes are only patched during dev for HMR
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            // remove existing
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        }
        else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        isSVG = isSVG || n2.type === 'svg';
        if (n1 == null) {
            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
        if ( true &&
            vnode.el &&
            hostCloneNode !== undefined &&
            patchFlag === -1 /* HOISTED */) {
            // If a vnode has non-null el, it means it's being reused.
            // Only static vnodes can be reused, so its mounted DOM nodes should be
            // exactly the same, and we can simply do a clone here.
            // only do this in production since cloned trees cannot be HMR updated.
            el = vnode.el = hostCloneNode(vnode.el);
        }
        else {
            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
            // mount children first, since some props may rely on child content
            // being already rendered, e.g. `<select value>`
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                hostSetElementText(el, vnode.children);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                for (const key in props) {
                    if (key !== 'value' && !shared_esm_bundler_isReservedProp(key)) {
                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
                /**
                 * Special case for setting value on DOM elements:
                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
                 * - it needs to be forced (#1471)
                 * #2353 proposes adding another renderer option to configure this, but
                 * the properties affects are so finite it is worth special casing it
                 * here to reduce the complexity. (Special casing it also should not
                 * affect non-DOM renderers)
                 */
                if ('value' in props) {
                    hostPatchProp(el, 'value', null, props.value);
                }
                if ((vnodeHook = props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
            }
            // scopeId
            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        }
        if (false) {}
        if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        }
        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
        // #1689 For inside suspense + suspense resolved case, just call it
        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
            transition &&
            !transition.persisted;
        if (needCallTransitionHooks) {
            transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) ||
            needCallTransitionHooks ||
            dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
            }, parentSuspense);
        }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
            hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
                hostSetScopeId(el, slotScopeIds[i]);
            }
        }
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (false /* DEV_ROOT_FRAGMENT */) {}
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
            const child = (children[i] = optimized
                ? cloneIfMounted(children[i])
                : normalizeVNode(children[i]));
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const el = (n2.el = n1.el);
        let { patchFlag, dynamicChildren, dirs } = n2;
        // #1426 take the old vnode's patch flag into account since user may clone a
        // compiler-generated vnode, which de-opts to FULL_PROPS
        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;
        const oldProps = n1.props || shared_esm_bundler_EMPTY_OBJ;
        const newProps = n2.props || shared_esm_bundler_EMPTY_OBJ;
        let vnodeHook;
        // disable recurse in beforeUpdate hooks
        parentComponent && toggleRecurse(parentComponent, false);
        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (false) {}
        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            if (false) {}
        }
        else if (!optimized) {
            // full diff
            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        }
        if (patchFlag > 0) {
            // the presence of a patchFlag means this element's render code was
            // generated by the compiler and can take the fast path.
            // in this path old node and new node are guaranteed to have the same shape
            // (i.e. at the exact same position in the source template)
            if (patchFlag & 16 /* FULL_PROPS */) {
                // element props contain dynamic keys, full diff needed
                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            }
            else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* CLASS */) {
                    if (oldProps.class !== newProps.class) {
                        hostPatchProp(el, 'class', null, newProps.class, isSVG);
                    }
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* STYLE */) {
                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                }
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PROPS */) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        // #1471 force patch value
                        if (next !== prev || key === 'value') {
                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                        }
                    }
                }
            }
            // text
            // This flag is matched when the element has only dynamic text children.
            if (patchFlag & 1 /* TEXT */) {
                if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children);
                }
            }
        }
        else if (!optimized && dynamicChildren == null) {
            // unoptimized, full diff
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
            }, parentSuspense);
        }
    };
    // The fast path for blocks.
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            // Determine the container (parent element) for the patch.
            const container = 
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el &&
                // - In the case of a Fragment, we need to provide the actual parent
                // of the Fragment itself so it can move its children.
                (oldVNode.type === runtime_core_esm_bundler_Fragment ||
                    // - In the case of different nodes, there is going to be a replacement
                    // which also requires the correct parent container
                    !isSameVNodeType(oldVNode, newVNode) ||
                    // - In the case of a component, it could contain anything.
                    oldVNode.shapeFlag & (6 /* COMPONENT */ | 64 /* TELEPORT */))
                ? hostParentNode(oldVNode.el)
                : // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
            for (const key in newProps) {
                // empty string is not valid prop
                if (shared_esm_bundler_isReservedProp(key))
                    continue;
                const next = newProps[key];
                const prev = oldProps[key];
                // defer patching value
                if (next !== prev && key !== 'value') {
                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
            }
            if (oldProps !== shared_esm_bundler_EMPTY_OBJ) {
                for (const key in oldProps) {
                    if (!shared_esm_bundler_isReservedProp(key) && !(key in newProps)) {
                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            if ('value' in newProps) {
                hostPatchProp(el, 'value', oldProps.value, newProps.value);
            }
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (false) {}
        // check if this is a slot fragment with :slotted scope ids
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            // a fragment can only have array children
            // since they are either generated by the compiler, or implicitly created
            // from arrays.
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            if (patchFlag > 0 &&
                patchFlag & 64 /* STABLE_FRAGMENT */ &&
                dynamicChildren &&
                // #2715 the previous fragment could've been a BAILed one as a result
                // of renderSlot() with no valid children
                n1.dynamicChildren) {
                // a stable fragment (template root or <template v-for>) doesn't need to
                // patch children order, but it may contain dynamicChildren.
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
                if (false) {}
                else if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null ||
                    (parentComponent && n2 === parentComponent.subTree)) {
                    traverseStaticChildren(n1, n2, true /* shallow */);
                }
            }
            else {
                // keyed / unkeyed, or manual fragments.
                // for keyed & unkeyed, since they are compiler generated from v-for,
                // each child is guaranteed to be a block so the fragment will never
                // have dynamicChildren.
                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
        }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            }
            else {
                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
        else {
            updateComponent(n1, n2, optimized);
        }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
        if (false) {}
        if ((false)) {}
        // inject renderer internals for keepAlive
        if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
        }
        // resolve props and slots for setup context
        {
            if ((false)) {}
            setupComponent(instance);
            if ((false)) {}
        }
        // setup() is async. This component relies on async logic to be resolved
        // before proceeding
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            // Give it a placeholder if this is not hydration
            // TODO handle self-defined fallback
            if (!initialVNode.el) {
                const placeholder = (instance.subTree = runtime_core_esm_bundler_createVNode(Comment));
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        if ((false)) {}
    };
    const updateComponent = (n1, n2, optimized) => {
        const instance = (n2.component = n1.component);
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep &&
                !instance.asyncResolved) {
                // async & still pending - just update props and slots
                // since the component's reactive effect for render isn't set-up yet
                if ((false)) {}
                updateComponentPreRender(instance, n2, optimized);
                if ((false)) {}
                return;
            }
            else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect.
                instance.update();
            }
        }
        else {
            // no update needed. just copy over properties
            n2.component = n1.component;
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        const componentUpdateFn = () => {
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                // beforeMount hook
                if (bm) {
                    invokeArrayFns(bm);
                }
                // onVnodeBeforeMount
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    // vnode has adopted host node - perform hydration instead of mount.
                    const hydrateSubTree = () => {
                        if ((false)) {}
                        instance.subTree = renderComponentRoot(instance);
                        if ((false)) {}
                        if ((false)) {}
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        if ((false)) {}
                    };
                    if (isAsyncWrapperVNode) {
                        initialVNode.type.__asyncLoader().then(
                        // note: we are moving the render call into an async callback,
                        // which means it won't track dependencies - but it's ok because
                        // a server-rendered async wrapper is already in resolved state
                        // and it will never need to change.
                        () => !instance.isUnmounted && hydrateSubTree());
                    }
                    else {
                        hydrateSubTree();
                    }
                }
                else {
                    if ((false)) {}
                    const subTree = (instance.subTree = renderComponentRoot(instance));
                    if ((false)) {}
                    if ((false)) {}
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    if ((false)) {}
                    initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) {
                    queuePostRenderEffect(m, parentSuspense);
                }
                // onVnodeMounted
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                // activated hook for keep-alive roots.
                // #1742 activated hook must be accessed after first render
                // since the hook may be injected by a child keep-alive
                if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                }
                instance.isMounted = true;
                if (false) {}
                // #2458: deference mount-only object parameters to prevent memleaks
                initialVNode = container = anchor = null;
            }
            else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                if ((false)) {}
                // Disallow component effect recursion during pre-lifecycle hooks.
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                }
                else {
                    next = vnode;
                }
                // beforeUpdate hook
                if (bu) {
                    invokeArrayFns(bu);
                }
                // onVnodeBeforeUpdate
                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                toggleRecurse(instance, true);
                // render
                if ((false)) {}
                const nextTree = renderComponentRoot(instance);
                if ((false)) {}
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                if ((false)) {}
                patch(prevTree, nextTree, 
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), 
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                if ((false)) {}
                next.el = nextTree.el;
                if (originNext === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el);
                }
                // updated hook
                if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                }
                // onVnodeUpdated
                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                }
                if (false) {}
                if ((false)) {}
            }
        };
        // create reactive effect for rendering
        const effect = (instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope // track it in component's effect scope
        ));
        const update = (instance.update = effect.run.bind(effect));
        update.id = instance.uid;
        // allowRecurse
        // #1801, #2043 component render effects should allow recursive updates
        toggleRecurse(instance, true);
        if ((false)) {}
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        // props update may have triggered pre-flush watchers.
        // flush them before the render update.
        flushPreFlushCbs(undefined, instance.update);
        resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        // fast path
        if (patchFlag > 0) {
            if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                // unkeyed
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        // children has 3 possibilities: text, array or no children.
        if (shapeFlag & 8 /* TEXT_CHILDREN */) {
            // text children fast path
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
                hostSetElementText(container, c2);
            }
        }
        else {
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                // prev children was array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                }
            }
            else {
                // prev children was text OR null
                // new children is array OR null
                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                    hostSetElementText(container, '');
                }
                // mount new if array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            }
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
            const nextChild = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) {
            // remove old
            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        }
        else {
            // mount new
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
        }
    };
    // can be all-keyed or mixed
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1; // prev ending index
        let e2 = l2 - 1; // next ending index
        // 1. sync from start
        // (a b) c
        // (a b) d e
        while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            i++;
        }
        // 2. sync from end
        // a (b c)
        // d e (b c)
        while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = (c2[e2] = optimized
                ? cloneIfMounted(c2[e2])
                : normalizeVNode(c2[e2]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            e1--;
            e2--;
        }
        // 3. common sequence + mount
        // (a b)
        // (a b) c
        // i = 2, e1 = 1, e2 = 2
        // (a b)
        // c (a b)
        // i = 0, e1 = -1, e2 = 0
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                    patch(null, (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        }
        // 4. common sequence + unmount
        // (a b) c
        // (a b)
        // i = 2, e1 = 2, e2 = 1
        // a (b c)
        // (b c)
        // i = 0, e1 = 0, e2 = -1
        else if (i > e2) {
            while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
            }
        }
        // 5. unknown sequence
        // [i ... e1 + 1]: a b [c d e] f g
        // [i ... e2 + 1]: a b [e d c h] f g
        // i = 2, e1 = 4, e2 = 5
        else {
            const s1 = i; // prev starting index
            const s2 = i; // next starting index
            // 5.1 build key:index map for newChildren
            const keyToNewIndexMap = new Map();
            for (i = s2; i <= e2; i++) {
                const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                if (nextChild.key != null) {
                    if (false) {}
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            // 5.2 loop through old children left to be patched and try to patch
            // matching nodes & remove nodes that are no longer present
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            // used to track whether any node has moved
            let maxNewIndexSoFar = 0;
            // works as Map<newIndex, oldIndex>
            // Note that oldIndex is offset by +1
            // and oldIndex = 0 is a special value indicating the new node has
            // no corresponding old node.
            // used for determining longest stable subsequence
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
                newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                }
                else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                        if (newIndexToOldIndexMap[j - s2] === 0 &&
                            isSameVNodeType(prevChild, c2[j])) {
                            newIndex = j;
                            break;
                        }
                    }
                }
                if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                }
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                        maxNewIndexSoFar = newIndex;
                    }
                    else {
                        moved = true;
                    }
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            // 5.3 move and mount
            // generate longest stable subsequence only when nodes have moved
            const increasingNewIndexSequence = moved
                ? getSequence(newIndexToOldIndexMap)
                : EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            // looping backwards so that we can use last patched node as anchor
            for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                        move(nextChild, container, anchor, 2 /* REORDER */);
                    }
                    else {
                        j--;
                    }
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6 /* COMPONENT */) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128 /* SUSPENSE */) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64 /* TELEPORT */) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === runtime_core_esm_bundler_Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === runtime_core_esm_bundler_Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        // single nodes
        const needTransition = moveType !== 2 /* REORDER */ &&
            shapeFlag & 1 /* ELEMENT */ &&
            transition;
        if (needTransition) {
            if (moveType === 0 /* ENTER */) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            }
            else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove = () => hostInsert(el, container, anchor);
                const performLeave = () => {
                    leave(el, () => {
                        remove();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) {
                    delayLeave(el, remove, performLeave);
                }
                else {
                    performLeave();
                }
            }
        }
        else {
            hostInsert(el, container, anchor);
        }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        // unset ref
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6 /* COMPONENT */) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
        }
        else {
            if (shapeFlag & 128 /* SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
            }
            if (shapeFlag & 64 /* TELEPORT */) {
                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            }
            else if (dynamicChildren &&
                // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== runtime_core_esm_bundler_Fragment ||
                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            }
            else if ((type === runtime_core_esm_bundler_Fragment &&
                patchFlag &
                    (128 /* KEYED_FRAGMENT */ | 256 /* UNKEYED_FRAGMENT */)) ||
                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
                remove(vnode);
            }
        }
        if ((shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeUnmounted)) ||
            shouldInvokeDirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
            }, parentSuspense);
        }
    };
    const remove = vnode => {
        const { type, el, anchor, transition } = vnode;
        if (type === runtime_core_esm_bundler_Fragment) {
            removeFragment(el, anchor);
            return;
        }
        if (type === runtime_core_esm_bundler_Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
            }
        };
        if (vnode.shapeFlag & 1 /* ELEMENT */ &&
            transition &&
            !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
            }
            else {
                performLeave();
            }
        }
        else {
            performRemove();
        }
    };
    const removeFragment = (cur, end) => {
        // For fragments, directly remove all contained DOM nodes.
        // (fragment child nodes cannot have transition)
        let next;
        while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (false) {}
        const { bum, scope, update, subTree, um } = instance;
        // beforeUnmount hook
        if (bum) {
            invokeArrayFns(bum);
        }
        // stop effects in component scope
        scope.stop();
        // update may be null if a component is unmounted before its async
        // setup has resolved.
        if (update) {
            // so that scheduler will no longer invoke it
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        // unmounted hook
        if (um) {
            queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
            instance.isUnmounted = true;
        }, parentSuspense);
        // A component with async dep inside a pending suspense is unmounted before
        // its async dep resolves. This should remove the dep from the suspense, and
        // cause the suspense to resolve immediately if that was the last dep.
        if (parentSuspense &&
            parentSuspense.pendingBranch &&
            !parentSuspense.isUnmounted &&
            instance.asyncDep &&
            !instance.asyncResolved &&
            instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
            }
        }
        if (false) {}
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
    };
    const getNextHostNode = vnode => {
        if (vnode.shapeFlag & 6 /* COMPONENT */) {
            return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128 /* SUSPENSE */) {
            return vnode.suspense.next();
        }
        return hostNextSibling((vnode.anchor || vnode.el));
    };
    const render = (vnode, container, isSVG) => {
        if (vnode == null) {
            if (container._vnode) {
                unmount(container._vnode, null, null, true);
            }
        }
        else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        }
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always be moved. Therefore, in order to ensure correct move
 * position, el should be inherited from previous nodes.
 */
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (shared_esm_bundler_isArray(ch1) && shared_esm_bundler_isArray(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
            // this is only called in the optimized path so array children are
            // guaranteed to be vnodes
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i]);
                    c2.el = c1.el;
                }
                if (!shallow)
                    traverseStaticChildren(c1, c2);
            }
            // also inherit for comment nodes, but not placeholders (e.g. v-if which
            // would have received .el during block patch)
            if (false) {}
        }
    }
}
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
                c = (u + v) >> 1;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}

const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
const isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;
const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (shared_esm_bundler_isString(targetSelector)) {
        if (!select) {
            ( false) &&
                0;
            return null;
        }
        else {
            const target = select(targetSelector);
            if (!target) {
                ( false) &&
                    0;
            }
            return target;
        }
    }
    else {
        if (false) {}
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        // #3302
        // HMR updated, force full diff
        if (false) {}
        if (n1 == null) {
            // insert anchors in the main view
            const placeholder = (n2.el = ( false)
                ? 0
                : createText(''));
            const mainAnchor = (n2.anchor = ( false)
                ? 0
                : createText(''));
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = (n2.target = resolveTarget(n2.props, querySelector));
            const targetAnchor = (n2.targetAnchor = createText(''));
            if (target) {
                insert(targetAnchor, target);
                // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                isSVG = isSVG || isTargetSVG(target);
            }
            else if (false) {}
            const mount = (container, anchor) => {
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            };
            if (disabled) {
                mount(container, mainAnchor);
            }
            else if (target) {
                mount(target, targetAnchor);
            }
        }
        else {
            // update content
            n2.el = n1.el;
            const mainAnchor = (n2.anchor = n1.anchor);
            const target = (n2.target = n1.target);
            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                // even in block tree mode we need to make sure all root-level nodes
                // in the teleport inherit previous DOM references so that they can
                // be moved in future patches.
                traverseStaticChildren(n1, n2, true);
            }
            else if (!optimized) {
                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            }
            if (disabled) {
                if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);
                }
            }
            else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
                    if (nextTarget) {
                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);
                    }
                    else if ((false)) {}
                }
                else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);
                }
            }
        }
    },
    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
            hostRemove(targetAnchor);
        }
        // an unmounted teleport should always remove its children if not disabled
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
                }
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {
    // move target anchor if this is a target change.
    if (moveType === 0 /* TARGET_CHANGE */) {
        insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2 /* REORDER */;
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(el, container, parentAnchor);
    }
    // if this is a re-order and teleport is enabled (content is in target)
    // do not move children. So the opposite is: only move children if this
    // is not a reorder, or the teleport is disabled
    if (!isReorder || isTeleportDisabled(props)) {
        // Teleport has either Array children or no children.
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2 /* REORDER */);
            }
        }
    }
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(anchor, container, parentAnchor);
    }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = (vnode.target = resolveTarget(vnode.props, querySelector));
    if (target) {
        // if multiple teleports rendered to the same target element, we need to
        // pick up from where the last teleport finished instead of the first node
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            }
            else {
                vnode.anchor = nextSibling(node);
                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            target._lpa =
                vnode.targetAnchor && nextSibling(vnode.targetAnchor);
        }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
// Force-casted public typing for h and TSX props inference
const Teleport = (/* unused pure expression or super */ null && (TeleportImpl));

const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
/**
 * @private
 */
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */
function resolveDynamicComponent(component) {
    if (shared_esm_bundler_isString(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
    }
    else {
        // invalid types will fallthrough to createVNode and raise warning
        return (component || NULL_DYNAMIC_COMPONENT);
    }
}
/**
 * @private
 */
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
// implementation
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        // explicit self name has highest priority
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component);
            if (selfName &&
                (selfName === name ||
                    selfName === camelize(name) ||
                    selfName === shared_esm_bundler_capitalize(camelize(name)))) {
                return Component;
            }
        }
        const res = 
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) ||
            // global registration
            resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) {
            // fallback to implicit self-reference
            return Component;
        }
        if (false) {}
        return res;
    }
    else if ((false)) {}
}
function resolve(registry, name) {
    return (registry &&
        (registry[name] ||
            registry[camelize(name)] ||
            registry[shared_esm_bundler_capitalize(camelize(name))]));
}

const runtime_core_esm_bundler_Fragment = Symbol(( false) ? 0 : undefined);
const Text = Symbol(( false) ? 0 : undefined);
const Comment = Symbol(( false) ? 0 : undefined);
const runtime_core_esm_bundler_Static = Symbol(( false) ? 0 : undefined);
// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */
function openBlock(disableTracking = false) {
    blockStack.push((currentBlock = disableTracking ? null : []));
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
let isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */
function setBlockTracking(value) {
    isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
    // save current block children on the block vnode
    vnode.dynamicChildren =
        isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    // close block
    closeBlock();
    // a block is always going to be patched, so track it as a child of its
    // parent block
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
    }
    return vnode;
}
/**
 * @private
 */
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(runtime_core_esm_bundler_createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (false) {}
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...(vnodeArgsTransformer
        ? vnodeArgsTransformer(args, currentRenderingInstance)
        : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for }) => {
    return (ref != null
        ? shared_esm_bundler_isString(ref) || reactivity_esm_bundler_isRef(ref) || shared_esm_bundler_isFunction(ref)
            ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }
            : ref
        : null);
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === runtime_core_esm_bundler_Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        // normalize suspense children
        if (shapeFlag & 128 /* SUSPENSE */) {
            type.normalize(vnode);
        }
    }
    else if (children) {
        // compiled element vnode - if children is passed, only possible types are
        // string or Array.
        vnode.shapeFlag |= shared_esm_bundler_isString(children)
            ? 8 /* TEXT_CHILDREN */
            : 16 /* ARRAY_CHILDREN */;
    }
    // validate key
    if (false) {}
    // track vnode for block tree
    if (isBlockTreeEnabled > 0 &&
        // avoid a block node from tracking itself
        !isBlockNode &&
        // has current parent block
        currentBlock &&
        // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&
        // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32 /* HYDRATE_EVENTS */) {
        currentBlock.push(vnode);
    }
    return vnode;
}
const runtime_core_esm_bundler_createVNode = (( false) ? 0 : _createVNode);
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (false) {}
        type = Comment;
    }
    if (isVNode(type)) {
        // createVNode receiving an existing vnode. This happens in cases like
        // <component :is="vnode"/>
        // #2078 make sure to merge refs during the clone instead of overwriting it
        const cloned = cloneVNode(type, props, true /* mergeRef: true */);
        if (children) {
            normalizeChildren(cloned, children);
        }
        return cloned;
    }
    // class component normalization.
    if (isClassComponent(type)) {
        type = type.__vccOpts;
    }
    // class & style normalization.
    if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !shared_esm_bundler_isString(klass)) {
            props.class = normalizeClass(klass);
        }
        if (shared_esm_bundler_isObject(style)) {
            // reactive state objects need to be cloned since they are likely to be
            // mutated
            if (isProxy(style) && !shared_esm_bundler_isArray(style)) {
                style = shared_esm_bundler_extend({}, style);
            }
            props.style = normalizeStyle(style);
        }
    }
    // encode the vnode type information into a bitmap
    const shapeFlag = shared_esm_bundler_isString(type)
        ? 1 /* ELEMENT */
        : isSuspense(type)
            ? 128 /* SUSPENSE */
            : isTeleport(type)
                ? 64 /* TELEPORT */
                : shared_esm_bundler_isObject(type)
                    ? 4 /* STATEFUL_COMPONENT */
                    : shared_esm_bundler_isFunction(type)
                        ? 2 /* FUNCTIONAL_COMPONENT */
                        : 0;
    if (false) {}
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props)
        return null;
    return isProxy(props) || InternalObjectKey in props
        ? shared_esm_bundler_extend({}, props)
        : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref
            ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                // if the vnode itself already has a ref, cloneVNode will need to merge
                // the refs so the single vnode can be set on multiple refs
                mergeRef && ref
                    ? shared_esm_bundler_isArray(ref)
                        ? ref.concat(normalizeRef(extraProps))
                        : [ref, normalizeRef(extraProps)]
                    : normalizeRef(extraProps)
            : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children:  false
            ? 0
            : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== runtime_core_esm_bundler_Fragment
            ? patchFlag === -1 // hoisted node
                ? 16 /* FULL_PROPS */
                : patchFlag | 16 /* FULL_PROPS */
            : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor
    };
    return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
}
/**
 * @private
 */
function createTextVNode(text = ' ', flag = 0) {
    return runtime_core_esm_bundler_createVNode(Text, null, text, flag);
}
/**
 * @private
 */
function createStaticVNode(content, numberOfNodes) {
    // A static vnode can contain multiple stringified elements, and the number
    // of elements is necessary for hydration.
    const vnode = runtime_core_esm_bundler_createVNode(runtime_core_esm_bundler_Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
/**
 * @private
 */
function createCommentVNode(text = '', 
// when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
    return asBlock
        ? (openBlock(), createBlock(Comment, null, text))
        : runtime_core_esm_bundler_createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === 'boolean') {
        // empty placeholder
        return runtime_core_esm_bundler_createVNode(Comment);
    }
    else if (shared_esm_bundler_isArray(child)) {
        // fragment
        return runtime_core_esm_bundler_createVNode(runtime_core_esm_bundler_Fragment, null, 
        // #3666, avoid reference pollution when reusing vnode
        child.slice());
    }
    else if (typeof child === 'object') {
        // already vnode, this should be the most common since compiled templates
        // always produce all-vnode children arrays
        return cloneIfMounted(child);
    }
    else {
        // strings and numbers
        return runtime_core_esm_bundler_createVNode(Text, null, String(child));
    }
}
// optimized normalization for template-compiled render fns
function cloneIfMounted(child) {
    return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
        children = null;
    }
    else if (shared_esm_bundler_isArray(children)) {
        type = 16 /* ARRAY_CHILDREN */;
    }
    else if (typeof children === 'object') {
        if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {
            // Normalize slot to plain children for plain element and Teleport
            const slot = children.default;
            if (slot) {
                // _c marker is added by withCtx() indicating this is a compiled slot
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        }
        else {
            type = 32 /* SLOTS_CHILDREN */;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
                children._ctx = currentRenderingInstance;
            }
            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {
                // a child component receives forwarded slots from the parent.
                // its slot type is determined by its parent's slot type.
                if (currentRenderingInstance.slots._ === 1 /* STABLE */) {
                    children._ = 1 /* STABLE */;
                }
                else {
                    children._ = 2 /* DYNAMIC */;
                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
            }
        }
    }
    else if (shared_esm_bundler_isFunction(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32 /* SLOTS_CHILDREN */;
    }
    else {
        children = String(children);
        // force teleport children to array so it can be moved around
        if (shapeFlag & 64 /* TELEPORT */) {
            type = 16 /* ARRAY_CHILDREN */;
            children = [createTextVNode(children)];
        }
        else {
            type = 8 /* TEXT_CHILDREN */;
        }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
            if (key === 'class') {
                if (ret.class !== toMerge.class) {
                    ret.class = normalizeClass([ret.class, toMerge.class]);
                }
            }
            else if (key === 'style') {
                ret.style = normalizeStyle([ret.style, toMerge.style]);
            }
            else if (shared_esm_bundler_isOn(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming &&
                    existing !== incoming &&
                    !(shared_esm_bundler_isArray(existing) && existing.includes(incoming))) {
                    ret[key] = existing
                        ? [].concat(existing, incoming)
                        : incoming;
                }
            }
            else if (key !== '') {
                ret[key] = toMerge[key];
            }
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
        vnode,
        prevVNode
    ]);
}

/**
 * Actual implementation
 */
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = (cache && cache[index]);
    if (shared_esm_bundler_isArray(source) || shared_esm_bundler_isString(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
        }
    }
    else if (typeof source === 'number') {
        if (false) {}
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);
        }
    }
    else if (shared_esm_bundler_isObject(source)) {
        if (source[Symbol.iterator]) {
            ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));
        }
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    }
    else {
        ret = [];
    }
    if (cache) {
        cache[index] = ret;
    }
    return ret;
}

/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */
function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        // array of dynamic slot generated by <template v-for="..." #[...]>
        if (isArray(slot)) {
            for (let j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
            }
        }
        else if (slot) {
            // conditional single slot generated by <template v-if="..." #foo>
            slots[slot.name] = slot.fn;
        }
    }
    return slots;
}

/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */
function renderSlot(slots, name, props = {}, 
// this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback, noSlotted) {
    if (currentRenderingInstance.isCE) {
        return runtime_core_esm_bundler_createVNode('slot', name === 'default' ? null : { name }, fallback && fallback());
    }
    let slot = slots[name];
    if (false) {}
    // a compiled slot disables block tracking by default to avoid manual
    // invocation interfering with template-based block tracking, but in
    // `renderSlot` we can be sure that it's template-based so we can force
    // enable it.
    if (slot && slot._c) {
        slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(runtime_core_esm_bundler_Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */
        ? 64 /* STABLE_FRAGMENT */
        : -2 /* BAIL */);
    if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + '-s'];
    }
    if (slot && slot._c) {
        slot._d = true;
    }
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some(child => {
        if (!isVNode(child))
            return true;
        if (child.type === Comment)
            return false;
        if (child.type === runtime_core_esm_bundler_Fragment &&
            !ensureValidVNode(child.children))
            return false;
        return true;
    })
        ? vnodes
        : null;
}

/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */
function toHandlers(obj) {
    const ret = {};
    if (false) {}
    for (const key in obj) {
        ret[toHandlerKey(key)] = obj[key];
    }
    return ret;
}

/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */
const getPublicInstance = (i) => {
    if (!i)
        return null;
    if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = shared_esm_bundler_extend(Object.create(null), {
    $: i => i,
    $el: i => i.vnode.el,
    $data: i => i.data,
    $props: i => (( false) ? 0 : i.props),
    $attrs: i => (( false) ? 0 : i.attrs),
    $slots: i => (( false) ? 0 : i.slots),
    $refs: i => (( false) ? 0 : i.refs),
    $parent: i => getPublicInstance(i.parent),
    $root: i => getPublicInstance(i.root),
    $emit: i => i.emit,
    $options: i => ( false ? 0 : i.type),
    $forceUpdate: i => () => queueJob(i.update),
    $nextTick: i => runtime_core_esm_bundler_nextTick.bind(i.proxy),
    $watch: i => ( false ? 0 : shared_esm_bundler_NOOP)
});
const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        // for internal formatters to know that this is a Vue instance
        if (false) {}
        // prioritize <script setup> bindings during dev.
        // this allows even properties that start with _ or $ to be used - so that
        // it aligns with the production behavior where the render fn is inlined and
        // indeed has access to all declared variables.
        if (false) {}
        // data / props / ctx
        // This getter gets called for every property access on the render context
        // during render and is a major hotspot. The most expensive part of this
        // is the multiple hasOwn() calls. It's much faster to do a simple property
        // access on a plain object, so we use an accessCache object (with null
        // prototype) to memoize what access type a key corresponds to.
        let normalizedProps;
        if (key[0] !== '$') {
            const n = accessCache[key];
            if (n !== undefined) {
                switch (n) {
                    case 1 /* SETUP */:
                        return setupState[key];
                    case 2 /* DATA */:
                        return data[key];
                    case 4 /* CONTEXT */:
                        return ctx[key];
                    case 3 /* PROPS */:
                        return props[key];
                    // default: just fallthrough
                }
            }
            else if (setupState !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(setupState, key)) {
                accessCache[key] = 1 /* SETUP */;
                return setupState[key];
            }
            else if (data !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(data, key)) {
                accessCache[key] = 2 /* DATA */;
                return data[key];
            }
            else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) &&
                shared_esm_bundler_hasOwn(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */;
                return props[key];
            }
            else if (ctx !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */;
                return ctx[key];
            }
            else if (true) {
                accessCache[key] = 0 /* OTHER */;
            }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        // public $xxx properties
        if (publicGetter) {
            if (key === '$attrs') {
                track(instance, "get" /* GET */, key);
                ( false) && 0;
            }
            return publicGetter(instance);
        }
        else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) &&
            (cssModule = cssModule[key])) {
            return cssModule;
        }
        else if (ctx !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(ctx, key)) {
            // user may set custom properties to `this` that start with `$`
            accessCache[key] = 4 /* CONTEXT */;
            return ctx[key];
        }
        else if (
        // global properties
        ((globalProperties = appContext.config.globalProperties),
            shared_esm_bundler_hasOwn(globalProperties, key))) {
            {
                return globalProperties[key];
            }
        }
        else if (false) {}
    },
    set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (setupState !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(setupState, key)) {
            setupState[key] = value;
            return true;
        }
        else if (data !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(data, key)) {
            data[key] = value;
            return true;
        }
        else if (shared_esm_bundler_hasOwn(instance.props, key)) {
            ( false) &&
                0;
            return false;
        }
        if (key[0] === '$' && key.slice(1) in instance) {
            ( false) &&
                0;
            return false;
        }
        else {
            if (false) {}
            else {
                ctx[key] = value;
            }
        }
        return true;
    },
    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return (!!accessCache[key] ||
            (data !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(data, key)) ||
            (setupState !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(setupState, key)) ||
            ((normalizedProps = propsOptions[0]) && shared_esm_bundler_hasOwn(normalizedProps, key)) ||
            shared_esm_bundler_hasOwn(ctx, key) ||
            shared_esm_bundler_hasOwn(publicPropertiesMap, key) ||
            shared_esm_bundler_hasOwn(appContext.config.globalProperties, key));
    },
    defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
            this.set(target, key, descriptor.get(), null);
        }
        else if (descriptor.value != null) {
            this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
    }
};
if (false) {}
const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ shared_esm_bundler_extend({}, PublicInstanceProxyHandlers, {
    get(target, key) {
        // fast path for unscopables when using `with` block
        if (key === Symbol.unscopables) {
            return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
        const has = key[0] !== '_' && !isGloballyWhitelisted(key);
        if (false) {}
        return has;
    }
});
// dev only
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createDevRenderContext(instance) {
    const target = {};
    // expose internal instance for proxy handlers
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
    });
    // expose public properties
    Object.keys(publicPropertiesMap).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: NOOP
        });
    });
    return target;
}
// dev only
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
        Object.keys(propsOptions).forEach(key => {
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => instance.props[key],
                set: NOOP
            });
        });
    }
}
// dev only
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach(key => {
        if (!setupState.__isScriptSetup) {
            if (key[0] === '$' || key[0] === '_') {
                runtime_core_esm_bundler_warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +
                    `which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => setupState[key],
                set: NOOP
            });
        }
    });
}

const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    // inherit parent app context - or - if root, adopt from root vnode
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid$1++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new EffectScope(true /* detached */),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resovled assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        emitted: null,
        // props default value
        propsDefaults: shared_esm_bundler_EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: shared_esm_bundler_EMPTY_OBJ,
        data: shared_esm_bundler_EMPTY_OBJ,
        props: shared_esm_bundler_EMPTY_OBJ,
        attrs: shared_esm_bundler_EMPTY_OBJ,
        slots: shared_esm_bundler_EMPTY_OBJ,
        refs: shared_esm_bundler_EMPTY_OBJ,
        setupState: shared_esm_bundler_EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    if ((false)) {}
    else {
        instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit$1.bind(null, instance);
    // apply custom element special handling
    if (vnode.ce) {
        vnode.ce(instance);
    }
    return instance;
}
let currentInstance = null;
const runtime_core_esm_bundler_getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
    currentInstance = instance;
    instance.scope.on();
};
const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    currentInstance = null;
};
const isBuiltInTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (makeMap('slot,component')));
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
        runtime_core_esm_bundler_warn('Do not use built-in or reserved HTML elements as component id: ' + name);
    }
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful
        ? setupStatefulComponent(instance, isSSR)
        : undefined;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    if ((false)) {}
    // 0. create render proxy property access cache
    instance.accessCache = Object.create(null);
    // 1. create public instance / render proxy
    // also mark it raw so it's never observed
    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if ((false)) {}
    // 2. call setup()
    const { setup } = Component;
    if (setup) {
        const setupContext = (instance.setupContext =
            setup.length > 1 ? createSetupContext(instance) : null);
        setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( false) ? 0 : instance.props, setupContext]);
        resetTracking();
        unsetCurrentInstance();
        if (shared_esm_bundler_isPromise(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
                // return the promise so server-renderer can wait on it
                return setupResult
                    .then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult, isSSR);
                })
                    .catch(e => {
                    handleError(e, instance, 0 /* SETUP_FUNCTION */);
                });
            }
            else {
                // async setup returned Promise.
                // bail here and wait for re-entry.
                instance.asyncDep = setupResult;
            }
        }
        else {
            handleSetupResult(instance, setupResult, isSSR);
        }
    }
    else {
        finishComponentSetup(instance, isSSR);
    }
}
function handleSetupResult(instance, setupResult, isSSR) {
    if (shared_esm_bundler_isFunction(setupResult)) {
        // setup returned an inline render function
        if (instance.type.__ssrInlineRender) {
            // when the function's name is `ssrRender` (compiled by SFC inline mode),
            // set it as ssrRender instead.
            instance.ssrRender = setupResult;
        }
        else {
            instance.render = setupResult;
        }
    }
    else if (shared_esm_bundler_isObject(setupResult)) {
        if (false) {}
        // setup returned bindings.
        // assuming a render function compiled from template is present.
        if (false) {}
        instance.setupState = proxyRefs(setupResult);
        if ((false)) {}
    }
    else if (false) {}
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = i => {
        if (i.render._rc) {
            i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
    };
}
// dev only
const runtime_core_esm_bundler_isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    // template / render function normalization
    // could be already set when returned from setup()
    if (!instance.render) {
        // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
        // is done by server-renderer
        if (!isSSR && compile && !Component.render) {
            const template = Component.template;
            if (template) {
                if ((false)) {}
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = shared_esm_bundler_extend(shared_esm_bundler_extend({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                if ((false)) {}
            }
        }
        instance.render = (Component.render || shared_esm_bundler_NOOP);
        // for runtime-compiled render functions using `with` blocks, the render
        // proxy used needs a different `has` handler which is more performant and
        // also only allows a whitelist of globals to fallthrough.
        if (installWithProxy) {
            installWithProxy(instance);
        }
    }
    // support for 2.x options
    if (false) {}
    // warn missing template/render
    // the runtime compilation of template in SSR is done by server-render
    if (false) {}
}
function createAttrsProxy(instance) {
    return new Proxy(instance.attrs, ( false)
        ? 0
        : {
            get(target, key) {
                track(instance, "get" /* GET */, '$attrs');
                return target[key];
            }
        });
}
function createSetupContext(instance) {
    const expose = exposed => {
        if (false) {}
        instance.exposed = exposed || {};
    };
    let attrs;
    if ((false)) {}
    else {
        return {
            get attrs() {
                return attrs || (attrs = createAttrsProxy(instance));
            },
            slots: instance.slots,
            emit: instance.emit,
            expose
        };
    }
}
function getExposeProxy(instance) {
    if (instance.exposed) {
        return (instance.exposeProxy ||
            (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
                get(target, key) {
                    if (key in target) {
                        return target[key];
                    }
                    else if (key in publicPropertiesMap) {
                        return publicPropertiesMap[key](instance);
                    }
                }
            })));
    }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
function getComponentName(Component) {
    return shared_esm_bundler_isFunction(Component)
        ? Component.displayName || Component.name
        : Component.name;
}
/* istanbul ignore next */
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
            name = match[1];
        }
    }
    if (!name && instance && instance.parent) {
        // try to infer the name based on reverse resolution
        const inferFromRegistry = (registry) => {
            for (const key in registry) {
                if (registry[key] === Component) {
                    return key;
                }
            }
        };
        name =
            inferFromRegistry(instance.components ||
                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return shared_esm_bundler_isFunction(value) && '__vccOpts' in value;
}

const runtime_core_esm_bundler_computed = ((getterOrOptions, debugOptions) => {
    // @ts-ignore
    return computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
});

// dev only
const warnRuntimeUsage = (method) => runtime_core_esm_bundler_warn(`${method}() is a compiler-hint helper that is only usable inside ` +
    `<script setup> of a single file component. Its arguments should be ` +
    `compiled away and passing it at runtime has no effect.`);
// implementation
function defineProps() {
    if ((false)) {}
    return null;
}
// implementation
function defineEmits() {
    if ((false)) {}
    return null;
}
/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. variables inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */
function defineExpose(exposed) {
    if ((false)) {}
}
/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` declaration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */
function withDefaults(props, defaults) {
    if ((false)) {}
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function getContext() {
    const i = runtime_core_esm_bundler_getCurrentInstance();
    if (false) {}
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(raw, defaults) {
    const props = isArray(raw)
        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})
        : raw;
    for (const key in defaults) {
        const opt = props[key];
        if (opt) {
            if (isArray(opt) || isFunction(opt)) {
                props[key] = { type: opt, default: defaults[key] };
            }
            else {
                opt.default = defaults[key];
            }
        }
        else if (opt === null) {
            props[key] = { default: defaults[key] };
        }
        else if ((false)) {}
    }
    return props;
}
/**
 * Used to create a proxy for the rest element when destructuring props with
 * defineProps().
 * @internal
 */
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for (const key in props) {
        if (!excludedKeys.includes(key)) {
            Object.defineProperty(ret, key, {
                enumerable: true,
                get: () => props[key]
            });
        }
    }
    return ret;
}
/**
 * `<script setup>` helper for persisting the current instance context over
 * async/await flows.
 *
 * `@vue/compiler-sfc` converts the following:
 *
 * ```ts
 * const x = await foo()
 * ```
 *
 * into:
 *
 * ```ts
 * let __temp, __restore
 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
 * ```
 * @internal
 */
function withAsyncContext(getAwaitable) {
    const ctx = runtime_core_esm_bundler_getCurrentInstance();
    if (false) {}
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if (isPromise(awaitable)) {
        awaitable = awaitable.catch(e => {
            setCurrentInstance(ctx);
            throw e;
        });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
}

// Actual implementation
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if (shared_esm_bundler_isObject(propsOrChildren) && !shared_esm_bundler_isArray(propsOrChildren)) {
            // single vnode without props
            if (isVNode(propsOrChildren)) {
                return runtime_core_esm_bundler_createVNode(type, null, [propsOrChildren]);
            }
            // props without children
            return runtime_core_esm_bundler_createVNode(type, propsOrChildren);
        }
        else {
            // omit props
            return runtime_core_esm_bundler_createVNode(type, null, propsOrChildren);
        }
    }
    else {
        if (l > 3) {
            children = Array.prototype.slice.call(arguments, 2);
        }
        else if (l === 3 && isVNode(children)) {
            children = [children];
        }
        return runtime_core_esm_bundler_createVNode(type, propsOrChildren, children);
    }
}

const ssrContextKey = Symbol(( false) ? 0 : ``);
const useSSRContext = () => {
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
            runtime_core_esm_bundler_warn(`Server rendering context not provided. Make sure to only call ` +
                `useSSRContext() conditionally in the server build.`);
        }
        return ctx;
    }
};

function runtime_core_esm_bundler_isShallow(value) {
    return !!(value && value["__v_isShallow" /* IS_SHALLOW */]);
}

function initCustomFormatter() {
    /* eslint-disable no-restricted-globals */
    if (true) {
        return;
    }
    const vueStyle = { style: 'color:#3ba776' };
    const numberStyle = { style: 'color:#0b1bc9' };
    const stringStyle = { style: 'color:#b62e24' };
    const keywordStyle = { style: 'color:#9d288c' };
    // custom formatter for Chrome
    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
    const formatter = {
        header(obj) {
            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
            if (!isObject(obj)) {
                return null;
            }
            if (obj.__isVue) {
                return ['div', vueStyle, `VueInstance`];
            }
            else if (isRef(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, genRefFlag(obj)],
                    '<',
                    formatValue(obj.value),
                    `>`
                ];
            }
            else if (isReactive(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, runtime_core_esm_bundler_isShallow(obj) ? 'ShallowReactive' : 'Reactive'],
                    '<',
                    formatValue(obj),
                    `>${isReadonly(obj) ? ` (readonly)` : ``}`
                ];
            }
            else if (isReadonly(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, runtime_core_esm_bundler_isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],
                    '<',
                    formatValue(obj),
                    '>'
                ];
            }
            return null;
        },
        hasBody(obj) {
            return obj && obj.__isVue;
        },
        body(obj) {
            if (obj && obj.__isVue) {
                return [
                    'div',
                    {},
                    ...formatInstance(obj.$)
                ];
            }
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
            blocks.push(createInstanceBlock('props', toRaw(instance.props)));
        }
        if (instance.setupState !== EMPTY_OBJ) {
            blocks.push(createInstanceBlock('setup', instance.setupState));
        }
        if (instance.data !== EMPTY_OBJ) {
            blocks.push(createInstanceBlock('data', toRaw(instance.data)));
        }
        const computed = extractKeys(instance, 'computed');
        if (computed) {
            blocks.push(createInstanceBlock('computed', computed));
        }
        const injected = extractKeys(instance, 'inject');
        if (injected) {
            blocks.push(createInstanceBlock('injected', injected));
        }
        blocks.push([
            'div',
            {},
            [
                'span',
                {
                    style: keywordStyle.style + ';opacity:0.66'
                },
                '$ (internal): '
            ],
            ['object', { object: instance }]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = extend({}, target);
        if (!Object.keys(target).length) {
            return ['span', {}];
        }
        return [
            'div',
            { style: 'line-height:1.25em;margin-bottom:0.6em' },
            [
                'div',
                {
                    style: 'color:#476582'
                },
                type
            ],
            [
                'div',
                {
                    style: 'padding-left:1.25em'
                },
                ...Object.keys(target).map(key => {
                    return [
                        'div',
                        {},
                        ['span', keywordStyle, key + ': '],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v, asRaw = true) {
        if (typeof v === 'number') {
            return ['span', numberStyle, v];
        }
        else if (typeof v === 'string') {
            return ['span', stringStyle, JSON.stringify(v)];
        }
        else if (typeof v === 'boolean') {
            return ['span', keywordStyle, v];
        }
        else if (isObject(v)) {
            return ['object', { object: asRaw ? toRaw(v) : v }];
        }
        else {
            return ['span', stringStyle, String(v)];
        }
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if (isFunction(Comp)) {
            return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
            if (isKeyOfType(Comp, key, type)) {
                extracted[key] = instance.ctx[key];
            }
        }
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if ((isArray(opts) && opts.includes(key)) ||
            (isObject(opts) && key in opts)) {
            return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
            return true;
        }
        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
            return true;
        }
    }
    function genRefFlag(v) {
        if (runtime_core_esm_bundler_isShallow(v)) {
            return `ShallowRef`;
        }
        if (v.effect) {
            return `ComputedRef`;
        }
        return `Ref`;
    }
    if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
    }
    else {
        window.devtoolsFormatters = [formatter];
    }
}

function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) {
        return cached;
    }
    const ret = render();
    // shallow clone
    ret.memo = memo.slice();
    return (cache[index] = ret);
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) {
        return false;
    }
    for (let i = 0; i < prev.length; i++) {
        if (prev[i] !== memo[i]) {
            return false;
        }
    }
    // make sure to let parent block track it when returning cached
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(cached);
    }
    return true;
}

// Core API ------------------------------------------------------------------
const version = "3.2.31";
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode,
    normalizeVNode
};
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */
const ssrUtils = ((/* unused pure expression or super */ null && (_ssrUtils)) );
/**
 * @internal only exposed in compat builds
 */
const resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */
const compatUtils = (null);



;// CONCATENATED MODULE: ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js




const svgNS = 'http://www.w3.org/2000/svg';
const doc = (typeof document !== 'undefined' ? document : null);
const templateContainer = doc && doc.createElement('template');
const nodeOps = {
    insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
    },
    remove: child => {
        const parent = child.parentNode;
        if (parent) {
            parent.removeChild(child);
        }
    },
    createElement: (tag, isSVG, is, props) => {
        const el = isSVG
            ? doc.createElementNS(svgNS, tag)
            : doc.createElement(tag, is ? { is } : undefined);
        if (tag === 'select' && props && props.multiple != null) {
            el.setAttribute('multiple', props.multiple);
        }
        return el;
    },
    createText: text => doc.createTextNode(text),
    createComment: text => doc.createComment(text),
    setText: (node, text) => {
        node.nodeValue = text;
    },
    setElementText: (el, text) => {
        el.textContent = text;
    },
    parentNode: node => node.parentNode,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector),
    setScopeId(el, id) {
        el.setAttribute(id, '');
    },
    cloneNode(el) {
        const cloned = el.cloneNode(true);
        // #3072
        // - in `patchDOMProp`, we store the actual value in the `el._value` property.
        // - normally, elements using `:value` bindings will not be hoisted, but if
        //   the bound value is a constant, e.g. `:value="true"` - they do get
        //   hoisted.
        // - in production, hoisted nodes are cloned when subsequent inserts, but
        //   cloneNode() does not copy the custom property we attached.
        // - This may need to account for other custom DOM properties we attach to
        //   elements in addition to `_value` in the future.
        if (`_value` in el) {
            cloned._value = el._value;
        }
        return cloned;
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, isSVG, start, end) {
        // <parent> before | first ... last | anchor </parent>
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        // #5308 can only take cached path if:
        // - has a single root node
        // - nextSibling info is still available
        if (start && (start === end || start.nextSibling)) {
            // cached
            while (true) {
                parent.insertBefore(start.cloneNode(true), anchor);
                if (start === end || !(start = start.nextSibling))
                    break;
            }
        }
        else {
            // fresh insert
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
                // remove outer svg wrapper
                const wrapper = template.firstChild;
                while (wrapper.firstChild) {
                    template.appendChild(wrapper.firstChild);
                }
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};

// compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]
function patchClass(el, value, isSVG) {
    // directly setting className should be faster than setAttribute in theory
    // if this is an element during a transition, take the temporary transition
    // classes into account.
    const transitionClasses = el._vtc;
    if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');
    }
    if (value == null) {
        el.removeAttribute('class');
    }
    else if (isSVG) {
        el.setAttribute('class', value);
    }
    else {
        el.className = value;
    }
}

function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = shared_esm_bundler_isString(next);
    if (next && !isCssString) {
        for (const key in next) {
            setStyle(style, key, next[key]);
        }
        if (prev && !shared_esm_bundler_isString(prev)) {
            for (const key in prev) {
                if (next[key] == null) {
                    setStyle(style, key, '');
                }
            }
        }
    }
    else {
        const currentDisplay = style.display;
        if (isCssString) {
            if (prev !== next) {
                style.cssText = next;
            }
        }
        else if (prev) {
            el.removeAttribute('style');
        }
        // indicates that the `display` of the element is controlled by `v-show`,
        // so we always keep the current `display` value regardless of the `style`
        // value, thus handing over control to `v-show`.
        if ('_vod' in el) {
            style.display = currentDisplay;
        }
    }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if (shared_esm_bundler_isArray(val)) {
        val.forEach(v => setStyle(style, name, v));
    }
    else {
        if (name.startsWith('--')) {
            // custom property definition
            style.setProperty(name, val);
        }
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
                // !important
                style.setProperty(shared_esm_bundler_hyphenate(prefixed), val.replace(importantRE, ''), 'important');
            }
            else {
                style[prefixed] = val;
            }
        }
    }
}
const prefixes = ['Webkit', 'Moz', 'ms'];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
        return cached;
    }
    let name = camelize(rawName);
    if (name !== 'filter' && name in style) {
        return (prefixCache[rawName] = name);
    }
    name = shared_esm_bundler_capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
            return (prefixCache[rawName] = prefixed);
        }
    }
    return rawName;
}

const xlinkNS = 'http://www.w3.org/1999/xlink';
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith('xlink:')) {
        if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        // note we are only checking boolean attributes that don't have a
        // corresponding dom prop of the same name here.
        const isBoolean = isSpecialBooleanAttr(key);
        if (value == null || (isBoolean && !includeBooleanAttr(value))) {
            el.removeAttribute(key);
        }
        else {
            el.setAttribute(key, isBoolean ? '' : value);
        }
    }
}

// __UNSAFE__
// functions. The user is responsible for using them with only trusted content.
function patchDOMProp(el, key, value, 
// the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === 'innerHTML' || key === 'textContent') {
        if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = icibaUserscriptTrustedHTML(value == null ? '' : value);
        return;
    }
    if (key === 'value' &&
        el.tagName !== 'PROGRESS' &&
        // custom elements may use _value internally
        !el.tagName.includes('-')) {
        // store value as _value as well since
        // non-string values will be stringified.
        el._value = value;
        const newValue = value == null ? '' : value;
        if (el.value !== newValue ||
            // #4956: always set for OPTION elements because its value falls back to
            // textContent if no value attribute is present. And setting .value for
            // OPTION has no side effect
            el.tagName === 'OPTION') {
            el.value = newValue;
        }
        if (value == null) {
            el.removeAttribute(key);
        }
        return;
    }
    if (value === '' || value == null) {
        const type = typeof el[key];
        if (type === 'boolean') {
            // e.g. <select multiple> compiles to { multiple: '' }
            el[key] = includeBooleanAttr(value);
            return;
        }
        else if (value == null && type === 'string') {
            // e.g. <div :id="null">
            el[key] = '';
            el.removeAttribute(key);
            return;
        }
        else if (type === 'number') {
            // e.g. <img :width="null">
            // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
            try {
                el[key] = 0;
            }
            catch (_a) { }
            el.removeAttribute(key);
            return;
        }
    }
    // some properties perform value validation and throw
    try {
        el[key] = value;
    }
    catch (e) {
        if ((false)) {}
    }
}

// Async edge case fix requires storing an event listener's attach timestamp.
let _getNow = Date.now;
let skipTimestampCheck = false;
if (typeof window !== 'undefined') {
    // Determine what event timestamp the browser is using. Annoyingly, the
    // timestamp can either be hi-res (relative to page load) or low-res
    // (relative to UNIX epoch), so in order to compare time we have to use the
    // same timestamp type when saving the flush timestamp.
    if (_getNow() > document.createEvent('Event').timeStamp) {
        // if the low-res timestamp which is bigger than the event timestamp
        // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
        // and we need to use the hi-res version for event listeners as well.
        _getNow = () => performance.now();
    }
    // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
    // and does not fire microtasks in between event propagation, so safe to exclude.
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
}
// To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.
let cachedNow = 0;
const p = Promise.resolve();
const runtime_dom_esm_bundler_reset = () => {
    cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(runtime_dom_esm_bundler_reset), (cachedNow = _getNow()));
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    // vei = vue event invokers
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
        // patch
        existingInvoker.value = nextValue;
    }
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            // add
            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
            addEventListener(el, name, invoker, options);
        }
        else if (existingInvoker) {
            // remove
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = undefined;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while ((m = name.match(optionsModifierRE))) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    return [shared_esm_bundler_hyphenate(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
    const invoker = (e) => {
        // async edge case #6566: inner click event triggers patch, event handler
        // attached to outer element during patch, and triggered again. This
        // happens because browsers fire microtask ticks between event propagation.
        // the solution is simple: we save the timestamp when a handler is attached,
        // and the handler would only fire if the event passed to it was fired
        // AFTER it was attached.
        const timeStamp = e.timeStamp || _getNow();
        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
            callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
        }
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if (shared_esm_bundler_isArray(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map(fn => (e) => !e._stopped && fn && fn(e));
    }
    else {
        return value;
    }
}

const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    if (key === 'class') {
        patchClass(el, nextValue, isSVG);
    }
    else if (key === 'style') {
        patchStyle(el, prevValue, nextValue);
    }
    else if (shared_esm_bundler_isOn(key)) {
        // ignore v-model listeners
        if (!isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
    }
    else if (key[0] === '.'
        ? ((key = key.slice(1)), true)
        : key[0] === '^'
            ? ((key = key.slice(1)), false)
            : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    }
    else {
        // special case for <input v-model type="checkbox"> with
        // :true-value & :false-value
        // store value as dom properties since non-string values will be
        // stringified.
        if (key === 'true-value') {
            el._trueValue = nextValue;
        }
        else if (key === 'false-value') {
            el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        // most keys must be set as attribute on svg elements to work
        // ...except innerHTML & textContent
        if (key === 'innerHTML' || key === 'textContent') {
            return true;
        }
        // or native onclick with function values
        if (key in el && nativeOnRE.test(key) && shared_esm_bundler_isFunction(value)) {
            return true;
        }
        return false;
    }
    // spellcheck and draggable are numerated attrs, however their
    // corresponding DOM properties are actually booleans - this leads to
    // setting it with a string "false" value leading it to be coerced to
    // `true`, so we need to always treat them as attributes.
    // Note that `contentEditable` doesn't have this problem: its DOM
    // property is also enumerated string values.
    if (key === 'spellcheck' || key === 'draggable') {
        return false;
    }
    // #1787, #2840 form property on form elements is readonly and must be set as
    // attribute.
    if (key === 'form') {
        return false;
    }
    // #1526 <input list> must be set as attribute
    if (key === 'list' && el.tagName === 'INPUT') {
        return false;
    }
    // #2766 <textarea type> must be set as attribute
    if (key === 'type' && el.tagName === 'TEXTAREA') {
        return false;
    }
    // native onclick with string value, must be set as attribute
    if (nativeOnRE.test(key) && shared_esm_bundler_isString(value)) {
        return false;
    }
    return key in el;
}

function defineCustomElement(options, hydate) {
    const Comp = defineComponent(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps) {
            super(Comp, initialProps, hydate);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
const defineSSRCustomElement = ((options) => {
    // @ts-ignore
    return defineCustomElement(options, hydrate);
});
const BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {
});
class VueElement extends (/* unused pure expression or super */ null && (BaseClass)) {
    constructor(_def, _props = {}, hydrate) {
        super();
        this._def = _def;
        this._props = _props;
        /**
         * @internal
         */
        this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate) {
            hydrate(this._createVNode(), this.shadowRoot);
        }
        else {
            if (false) {}
            this.attachShadow({ mode: 'open' });
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) {
            this._resolveDef();
        }
    }
    disconnectedCallback() {
        this._connected = false;
        nextTick(() => {
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */
    _resolveDef() {
        if (this._resolved) {
            return;
        }
        this._resolved = true;
        // set initial attrs
        for (let i = 0; i < this.attributes.length; i++) {
            this._setAttr(this.attributes[i].name);
        }
        // watch future attr changes
        new MutationObserver(mutations => {
            for (const m of mutations) {
                this._setAttr(m.attributeName);
            }
        }).observe(this, { attributes: true });
        const resolve = (def) => {
            const { props, styles } = def;
            const hasOptions = !isArray(props);
            const rawKeys = props ? (hasOptions ? Object.keys(props) : props) : [];
            // cast Number-type props set before resolve
            let numberProps;
            if (hasOptions) {
                for (const key in this._props) {
                    const opt = props[key];
                    if (opt === Number || (opt && opt.type === Number)) {
                        this._props[key] = toNumber(this._props[key]);
                        (numberProps || (numberProps = Object.create(null)))[key] = true;
                    }
                }
            }
            this._numberProps = numberProps;
            // check if there are props set pre-upgrade or connect
            for (const key of Object.keys(this)) {
                if (key[0] !== '_') {
                    this._setProp(key, this[key], true, false);
                }
            }
            // defining getter/setters on prototype
            for (const key of rawKeys.map(camelize$1)) {
                Object.defineProperty(this, key, {
                    get() {
                        return this._getProp(key);
                    },
                    set(val) {
                        this._setProp(key, val);
                    }
                });
            }
            // apply CSS
            this._applyStyles(styles);
            // initial render
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
            asyncDef().then(resolve);
        }
        else {
            resolve(this._def);
        }
    }
    _setAttr(key) {
        let value = this.getAttribute(key);
        if (this._numberProps && this._numberProps[key]) {
            value = toNumber(value);
        }
        this._setProp(camelize$1(key), value, false);
    }
    /**
     * @internal
     */
    _getProp(key) {
        return this._props[key];
    }
    /**
     * @internal
     */
    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) {
                this._update();
            }
            // reflect
            if (shouldReflect) {
                if (val === true) {
                    this.setAttribute(hyphenate(key), '');
                }
                else if (typeof val === 'string' || typeof val === 'number') {
                    this.setAttribute(hyphenate(key), val + '');
                }
                else if (!val) {
                    this.removeAttribute(hyphenate(key));
                }
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = createVNode(this._def, extend({}, this._props));
        if (!this._instance) {
            vnode.ce = instance => {
                this._instance = instance;
                instance.isCE = true;
                // HMR
                if ((false)) {}
                // intercept emit
                instance.emit = (event, ...args) => {
                    this.dispatchEvent(new CustomEvent(event, {
                        detail: args
                    }));
                };
                // locate nearest Vue custom element parent for provide/inject
                let parent = this;
                while ((parent =
                    parent && (parent.parentNode || parent.host))) {
                    if (parent instanceof VueElement) {
                        instance.parent = parent._instance;
                        break;
                    }
                }
            };
        }
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) {
            styles.forEach(css => {
                const s = document.createElement('style');
                s.textContent = css;
                this.shadowRoot.appendChild(s);
                // record for HMR
                if ((false)) {}
            });
        }
    }
}

function useCssModule(name = '$style') {
    /* istanbul ignore else */
    {
        const instance = getCurrentInstance();
        if (!instance) {
            ( false) && 0;
            return EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            ( false) && 0;
            return EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            ( false) &&
                0;
            return EMPTY_OBJ;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    const instance = getCurrentInstance();
    /* istanbul ignore next */
    if (!instance) {
        ( false) &&
            0;
        return;
    }
    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
    watchPostEffect(setVars);
    onMounted(() => {
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        onUnmounted(() => ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
            suspense.effects.push(() => {
                setVarsOnVNode(suspense.activeBranch, vars);
            });
        }
    }
    // drill down HOCs until it's a non-component vnode
    while (vnode.component) {
        vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {
        setVarsOnNode(vnode.el, vars);
    }
    else if (vnode.type === Fragment) {
        vnode.children.forEach(c => setVarsOnVNode(c, vars));
    }
    else if (vnode.type === Static) {
        let { el, anchor } = vnode;
        while (el) {
            setVarsOnNode(el, vars);
            if (el === anchor)
                break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for (const key in vars) {
            style.setProperty(`--${key}`, vars[key]);
        }
    }
}

const TRANSITION = 'transition';
const ANIMATION = 'animation';
// DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = 'Transition';
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = (Transition.props =
    /*#__PURE__*/ shared_esm_bundler_extend({}, BaseTransition.props, DOMTransitionPropsValidators));
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */
const runtime_dom_esm_bundler_callHook = (hook, args = []) => {
    if (shared_esm_bundler_isArray(hook)) {
        hook.forEach(h => h(...args));
    }
    else if (hook) {
        hook(...args);
    }
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */
const hasExplicitCallback = (hook) => {
    return hook
        ? shared_esm_bundler_isArray(hook)
            ? hook.some(h => h.length > 1)
            : hook.length > 1
        : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
        }
    }
    if (rawProps.css === false) {
        return baseProps;
    }
    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done) => {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear) => {
        return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve = () => finishEnter(el, isAppear, done);
            runtime_dom_esm_bundler_callHook(hook, [el, resolve]);
            nextFrame(() => {
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) {
                    whenTransitionEnds(el, type, enterDuration, resolve);
                }
            });
        };
    };
    return shared_esm_bundler_extend(baseProps, {
        onBeforeEnter(el) {
            runtime_dom_esm_bundler_callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
            runtime_dom_esm_bundler_callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
            const resolve = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            // force reflow so *-leave-from classes immediately take effect (#2593)
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve);
                }
            });
            runtime_dom_esm_bundler_callHook(onLeave, [el, resolve]);
        },
        onEnterCancelled(el) {
            finishEnter(el, false);
            runtime_dom_esm_bundler_callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
            finishEnter(el, true);
            runtime_dom_esm_bundler_callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
            finishLeave(el);
            runtime_dom_esm_bundler_callHook(onLeaveCancelled, [el]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) {
        return null;
    }
    else if (shared_esm_bundler_isObject(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
    }
    else {
        const n = NumberOf(duration);
        return [n, n];
    }
}
function NumberOf(val) {
    const res = shared_esm_bundler_toNumber(val);
    if ((false))
        {}
    return res;
}
function validateDuration(val) {
    if (typeof val !== 'number') {
        warn(`<transition> explicit duration is not a valid number - ` +
            `got ${(__webpack_require__(8334)/* .stringify */ .P)(val)}.`);
    }
    else if (isNaN(val)) {
        warn(`<transition> explicit duration is NaN - ` +
            'the duration expression might be incorrect.');
    }
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.add(c));
    (el._vtc ||
        (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
            el._vtc = undefined;
        }
    }
}
function nextFrame(cb) {
    requestAnimationFrame(() => {
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = (el._endId = ++endId);
    const resolveIfNotStale = () => {
        if (id === el._endId) {
            resolve();
        }
    };
    if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
        return resolve();
    }
    const endEvent = type + 'end';
    let ended = 0;
    const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
            end();
        }
    };
    setTimeout(() => {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const getStyleProperties = (key) => (styles[key] || '').split(', ');
    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + 'Delay');
    const animationDurations = getStyleProperties(ANIMATION + 'Duration');
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    const hasTransform = type === TRANSITION &&
        /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
// synchronously force layout to put elements into a certain state
function forceReflow() {
    return document.body.offsetHeight;
}

const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
    name: 'TransitionGroup',
    props: /*#__PURE__*/ shared_esm_bundler_extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup(props, { slots }) {
        const instance = runtime_core_esm_bundler_getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
            // children is guaranteed to exist after initial render
            if (!prevChildren.length) {
                return;
            }
            const moveClass = props.moveClass || `${props.name || 'v'}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                return;
            }
            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            // force reflow to put everything in position
            forceReflow();
            movedChildren.forEach(c => {
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = '';
                const cb = (el._moveCb = (e) => {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener('transitionend', cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                });
                el.addEventListener('transitionend', cb);
            });
        });
        return () => {
            const rawProps = reactivity_esm_bundler_toRaw(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || runtime_core_esm_bundler_Fragment;
            prevChildren = children;
            children = slots.default ? getTransitionRawChildren(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.key != null) {
                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                }
                else if ((false)) {}
            }
            if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                    const child = prevChildren[i];
                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                }
            }
            return runtime_core_esm_bundler_createVNode(tag, null, children);
        };
    }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) {
        el._moveCb();
    }
    if (el._enterCb) {
        el._enterCb();
    }
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    // Detect whether an element with the move class applied has
    // CSS transitions. Since the element may be inside an entering
    // transition at this very moment, we make a clone of it and remove
    // all other transition classes applied to ensure only the move class
    // is applied.
    const clone = el.cloneNode();
    if (el._vtc) {
        el._vtc.forEach(cls => {
            cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
        });
    }
    moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
    clone.style.display = 'none';
    const container = (root.nodeType === 1 ? root : root.parentNode);
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}

const getModelAssigner = (vnode) => {
    const fn = vnode.props['onUpdate:modelValue'];
    return shared_esm_bundler_isArray(fn) ? value => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        runtime_dom_esm_bundler_trigger(target, 'input');
    }
}
function runtime_dom_esm_bundler_trigger(el, type) {
    const e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}
// We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.
const vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || (vnode.props && vnode.props.type === 'number');
        addEventListener(el, lazy ? 'change' : 'input', e => {
            if (e.target.composing)
                return;
            let domValue = el.value;
            if (trim) {
                domValue = domValue.trim();
            }
            else if (castToNumber) {
                domValue = shared_esm_bundler_toNumber(domValue);
            }
            el._assign(domValue);
        });
        if (trim) {
            addEventListener(el, 'change', () => {
                el.value = el.value.trim();
            });
        }
        if (!lazy) {
            addEventListener(el, 'compositionstart', onCompositionStart);
            addEventListener(el, 'compositionend', onCompositionEnd);
            // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.
            addEventListener(el, 'change', onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
        el.value = value == null ? '' : value;
    },
    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        // avoid clearing unresolved text. #2302
        if (el.composing)
            return;
        if (document.activeElement === el) {
            if (lazy) {
                return;
            }
            if (trim && el.value.trim() === value) {
                return;
            }
            if ((number || el.type === 'number') && shared_esm_bundler_toNumber(el.value) === value) {
                return;
            }
        }
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) {
            el.value = newValue;
        }
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created(el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if (shared_esm_bundler_isArray(modelValue)) {
                const index = shared_esm_bundler_looseIndexOf(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) {
                    assign(modelValue.concat(elementValue));
                }
                else if (!checked && found) {
                    const filtered = [...modelValue];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            }
            else if (shared_esm_bundler_isSet(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) {
                    cloned.add(elementValue);
                }
                else {
                    cloned.delete(elementValue);
                }
                assign(cloned);
            }
            else {
                assign(getCheckboxValue(el, checked));
            }
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if (shared_esm_bundler_isArray(value)) {
        el.checked = shared_esm_bundler_looseIndexOf(value, vnode.props.value) > -1;
    }
    else if (shared_esm_bundler_isSet(value)) {
        el.checked = value.has(vnode.props.value);
    }
    else if (value !== oldValue) {
        el.checked = shared_esm_bundler_looseEqual(value, getCheckboxValue(el, true));
    }
}
const vModelRadio = {
    created(el, { value }, vnode) {
        el.checked = shared_esm_bundler_looseEqual(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            el._assign(getValue(el));
        });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
            el.checked = shared_esm_bundler_looseEqual(value, vnode.props.value);
        }
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = shared_esm_bundler_isSet(value);
        addEventListener(el, 'change', () => {
            const selectedVal = Array.prototype.filter
                .call(el.options, (o) => o.selected)
                .map((o) => number ? shared_esm_bundler_toNumber(getValue(o)) : getValue(o));
            el._assign(el.multiple
                ? isSetModel
                    ? new Set(selectedVal)
                    : selectedVal
                : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated(el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !shared_esm_bundler_isArray(value) && !shared_esm_bundler_isSet(value)) {
        ( false) &&
            0;
        return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if (shared_esm_bundler_isArray(value)) {
                option.selected = shared_esm_bundler_looseIndexOf(value, optionValue) > -1;
            }
            else {
                option.selected = value.has(optionValue);
            }
        }
        else {
            if (shared_esm_bundler_looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i)
                    el.selectedIndex = i;
                return;
            }
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
    }
}
// retrieve raw value set via :value bindings
function getValue(el) {
    return '_value' in el ? el._value : el.value;
}
// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
function getCheckboxValue(el, checked) {
    const key = checked ? '_trueValue' : '_falseValue';
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'created');
    },
    mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'mounted');
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
    },
    updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'updated');
    }
};
function callModelHook(el, binding, vnode, prevVNode, hook) {
    let modelToUse;
    switch (el.tagName) {
        case 'SELECT':
            modelToUse = vModelSelect;
            break;
        case 'TEXTAREA':
            modelToUse = vModelText;
            break;
        default:
            switch (vnode.props && vnode.props.type) {
                case 'checkbox':
                    modelToUse = vModelCheckbox;
                    break;
                case 'radio':
                    modelToUse = vModelRadio;
                    break;
                default:
                    modelToUse = vModelText;
            }
    }
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value }) => ({ value });
    vModelRadio.getSSRProps = ({ value }, vnode) => {
        if (vnode.props && looseEqual(vnode.props.value, value)) {
            return { checked: true };
        }
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode) => {
        if (isArray(value)) {
            if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
                return { checked: true };
            }
        }
        else if (isSet(value)) {
            if (vnode.props && value.has(vnode.props.value)) {
                return { checked: true };
            }
        }
        else if (value) {
            return { checked: true };
        }
    };
}

const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
const modifierGuards = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => 'button' in e && e.button !== 0,
    middle: e => 'button' in e && e.button !== 1,
    right: e => 'button' in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
/**
 * @private
 */
const withModifiers = (fn, modifiers) => {
    return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
                return;
        }
        return fn(event, ...args);
    };
};
// Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.
const keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
};
/**
 * @private
 */
const withKeys = (fn, modifiers) => {
    return (event) => {
        if (!('key' in event)) {
            return;
        }
        const eventKey = shared_esm_bundler_hyphenate(event.key);
        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
            return fn(event);
        }
    };
};

const vShow = {
    beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === 'none' ? '' : el.style.display;
        if (transition && value) {
            transition.beforeEnter(el);
        }
        else {
            setDisplay(el, value);
        }
    },
    mounted(el, { value }, { transition }) {
        if (transition && value) {
            transition.enter(el);
        }
    },
    updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
            return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            }
            else {
                transition.leave(el, () => {
                    setDisplay(el, false);
                });
            }
        }
        else {
            setDisplay(el, value);
        }
    },
    beforeUnmount(el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : 'none';
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVShowForSSR() {
    vShow.getSSRProps = ({ value }) => {
        if (!value) {
            return { style: { display: 'none' } };
        }
    };
}

const rendererOptions = shared_esm_bundler_extend({ patchProp }, nodeOps);
// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return (renderer ||
        (renderer = createRenderer(rendererOptions)));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration
        ? renderer
        : createHydrationRenderer(rendererOptions);
    enabledHydration = true;
    return renderer;
}
// use explicit type casts here to avoid import() calls in rolled-up d.ts
const render = ((...args) => {
    ensureRenderer().render(...args);
});
const hydrate = ((...args) => {
    ensureHydrationRenderer().hydrate(...args);
});
const createApp = ((...args) => {
    const app = ensureRenderer().createApp(...args);
    if ((false)) {}
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
            return;
        const component = app._component;
        if (!shared_esm_bundler_isFunction(component) && !component.render && !component.template) {
            // __UNSAFE__
            // Reason: potential execution of JS expressions in in-DOM template.
            // The user must make sure the in-DOM template is trusted. If it's
            // rendered by the server, the template should not contain any user data.
            component.template = container.innerHTML;
        }
        // clear content before mounting
        container.childNodes.forEach(v => container.removeChild(v))
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute('v-cloak');
            container.setAttribute('data-v-app', '');
        }
        return proxy;
    };
    return app;
});
const createSSRApp = ((...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    if ((false)) {}
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
            return mount(container, true, container instanceof SVGElement);
        }
    };
    return app;
});
function injectNativeTagCheck(app) {
    // Inject `isNativeTag`
    // this is used for component name validation (dev only)
    Object.defineProperty(app.config, 'isNativeTag', {
        value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
        writable: false
    });
}
// dev only
function injectCompilerOptionsCheck(app) {
    if (isRuntimeOnly()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, 'isCustomElement', {
            get() {
                return isCustomElement;
            },
            set() {
                warn(`The \`isCustomElement\` config option is deprecated. Use ` +
                    `\`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using ` +
            `a build of Vue.js that includes the runtime compiler (aka "full build"). ` +
            `Since you are using the runtime-only build, \`compilerOptions\` ` +
            `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` +
            `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` +
            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` +
            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
        Object.defineProperty(app.config, 'compilerOptions', {
            get() {
                warn(msg);
                return compilerOptions;
            },
            set() {
                warn(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if (shared_esm_bundler_isString(container)) {
        const res = document.querySelector(container);
        if (false) {}
        return res;
    }
    if (false) {}
    return container;
}
let ssrDirectiveInitialized = false;
/**
 * @internal
 */
const initDirectivesForSSR = () => {
        if (!ssrDirectiveInitialized) {
            ssrDirectiveInitialized = true;
            initVModelForSSR();
            initVShowForSSR();
        }
    }
    ;



// EXTERNAL MODULE: ./src/assets/styles/tailwind.sass
var tailwind = __webpack_require__(8769);
;// CONCATENATED MODULE: ./src/util/diretives/ripple.js
/* eslint-disable */
function transform(el, value) {
  el.style['transform'] = value;
  el.style['webkitTransform'] = value;
}

function opacity(el, value) {
  el.style['opacity'] = value.toString();
}

function isTouchEvent(e) {
  return e.constructor.name === 'TouchEvent';
}

var calculate = function calculate(e, el) {
  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var offset = el.getBoundingClientRect();
  var target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
  var localX = target.clientX - offset.left;
  var localY = target.clientY - offset.top;
  var radius = 0;
  var scale = 0.3;

  if (el._ripple && el._ripple.circle) {
    scale = 0.15;
    radius = el.clientWidth / 2;
    radius = value.center ? radius : radius + Math.sqrt(Math.pow(localX - radius, 2) + Math.pow(localY - radius, 2)) / 4;
  } else {
    radius = Math.sqrt(Math.pow(el.clientWidth, 2) + Math.pow(el.clientHeight, 2)) / 2;
  }

  var centerX = (el.clientWidth - radius * 2) / 2 + 'px';
  var centerY = (el.clientHeight - radius * 2) / 2 + 'px';
  var x = value.center ? centerX : localX - radius + 'px';
  var y = value.center ? centerY : localY - radius + 'px';
  return {
    radius: radius,
    scale: scale,
    x: x,
    y: y,
    centerX: centerX,
    centerY: centerY
  };
};

var ripple = {
  /* eslint-disable max-statements */
  show: function show(e, el) {
    var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!el._ripple || !el._ripple.enabled) {
      return;
    }

    var container = document.createElement('span');
    var animation = document.createElement('span');
    container.appendChild(animation);
    container.className = 'v-ripple__container';

    if (value.class) {
      container.className += ' ' + value.class;
    }

    var _calculate = calculate(e, el, value),
        radius = _calculate.radius,
        scale = _calculate.scale,
        x = _calculate.x,
        y = _calculate.y,
        centerX = _calculate.centerX,
        centerY = _calculate.centerY;

    var size = radius * 2 + 'px';
    animation.className = 'v-ripple__animation';
    animation.style.width = size;
    animation.style.height = size;
    el.appendChild(container);
    var computed = window.getComputedStyle(el);

    if (computed && computed.position === 'static') {
      el.style.position = 'relative';
      el.dataset.previousPosition = 'static';
    }

    animation.classList.add('v-ripple__animation--enter');
    animation.classList.add('v-ripple__animation--visible');
    transform(animation, 'translate(' + x + ', ' + y + ') scale3d(' + scale + ',' + scale + ',' + scale + ')');
    opacity(animation, 0);
    animation.dataset.activated = String(performance.now());
    setTimeout(function () {
      animation.classList.remove('v-ripple__animation--enter');
      animation.classList.add('v-ripple__animation--in');
      transform(animation, 'translate(' + centerX + ', ' + centerY + ') scale3d(1,1,1)');
      opacity(animation, 0.25);
    }, 0);
  },
  hide: function hide(el) {
    if (!el || !el._ripple || !el._ripple.enabled) return;
    var ripples = el.getElementsByClassName('v-ripple__animation');
    if (ripples.length === 0) return;
    var animation = ripples[ripples.length - 1];
    if (animation.dataset.isHiding) return;else animation.dataset.isHiding = 'true';
    var diff = performance.now() - Number(animation.dataset.activated);
    var delay = Math.max(250 - diff, 0);
    setTimeout(function () {
      animation.classList.remove('v-ripple__animation--in');
      animation.classList.add('v-ripple__animation--out');
      opacity(animation, 0);
      setTimeout(function () {
        var ripples = el.getElementsByClassName('v-ripple__animation');

        if (ripples.length === 1 && el.dataset.previousPosition) {
          el.style.position = el.dataset.previousPosition;
          delete el.dataset.previousPosition;
        }

        animation.parentNode && el.removeChild(animation.parentNode);
      }, 300);
    }, delay);
  }
};

function isRippleEnabled(value) {
  return typeof value === 'undefined' || !!value;
}

function rippleShow(e) {
  var value = {};
  var element = e.currentTarget;
  if (!element || !element._ripple || element._ripple.touched) return;

  if (isTouchEvent(e)) {
    element._ripple.touched = true;
  }

  value.center = element._ripple.centered;

  if (element._ripple.class) {
    value.class = element._ripple.class;
  }

  ripple.show(e, element, value);
}

function rippleHide(e) {
  var element = e.currentTarget;
  if (!element) return;
  window.setTimeout(function () {
    if (element._ripple) {
      element._ripple.touched = false;
    }
  });
  ripple.hide(element);
}

function updateRipple(el, binding, wasEnabled) {
  var enabled = isRippleEnabled(binding.value);

  if (!enabled) {
    ripple.hide(el);
  }

  el._ripple = el._ripple || {};
  el._ripple.enabled = enabled;
  var value = binding.value || {};

  if (value.center) {
    el._ripple.centered = true;
  }

  if (value.class) {
    el._ripple.class = binding.value.class;
  }

  if (value.circle) {
    el._ripple.circle = value.circle;
  }

  if (enabled && !wasEnabled) {
    el.addEventListener('touchstart', rippleShow, {
      passive: true
    });
    el.addEventListener('touchend', rippleHide, {
      passive: true
    });
    el.addEventListener('touchcancel', rippleHide);
    el.addEventListener('mousedown', rippleShow);
    el.addEventListener('mouseup', rippleHide);
    el.addEventListener('mouseleave', rippleHide); // Anchor tags can be dragged, causes other hides to fail - #1537

    el.addEventListener('dragstart', rippleHide, {
      passive: true
    });
  } else if (!enabled && wasEnabled) {
    removeListeners(el);
  }
}

function removeListeners(el) {
  el.removeEventListener('mousedown', rippleShow);
  el.removeEventListener('touchstart', rippleHide);
  el.removeEventListener('touchend', rippleHide);
  el.removeEventListener('touchcancel', rippleHide);
  el.removeEventListener('mouseup', rippleHide);
  el.removeEventListener('mouseleave', rippleHide);
  el.removeEventListener('dragstart', rippleHide);
}

function directive(el, binding, node) {
  updateRipple(el, binding, false); // warn if an inline element is used, waiting for el to be in the DOM first

  node.context && node.context.$nextTick(function () {
    var computed = window.getComputedStyle(el);

    if (computed && computed.display === 'inline') {
      var context = node.fnOptions ? [node.fnOptions, node.context] : [node.componentInstance];
      console.warn(['v-ripple can only be used on block-level elements'].concat(context));
    }
  });
}

function unbind(el) {
  delete el._ripple;
  removeListeners(el);
}

function update(el, binding) {
  if (binding.value === binding.oldValue) {
    return;
  }

  var wasEnabled = isRippleEnabled(binding.oldValue);
  updateRipple(el, binding, wasEnabled);
}

/* harmony default export */ const diretives_ripple = ({
  mounted: directive,
  unmounted: unbind,
  updated: update
});
;// CONCATENATED MODULE: ./src/util/diretives/no-overscroll.ts
const handleScroll = _e => {
  const e = _e;
  const el = e.currentTarget;

  if (!el) {
    return;
  }

  const scrollBox = el;

  if (scrollBox) {
    // scroll down
    if (e.deltaY > 0 && scrollBox.scrollTop >= scrollBox.scrollHeight - scrollBox.clientHeight) {
      e.preventDefault();
    } // scroll up


    if (e.deltaY < 0 && scrollBox.scrollTop === 0) {
      e.preventDefault();
    }
  }
};

/* harmony default export */ const no_overscroll = ({
  mounted(el) {
    el.addEventListener('wheel', handleScroll);
  },

  unmounted(el) {
    el.removeEventListener('wheel', handleScroll);
  }

});
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/checkbox/checkbox.vue?vue&type=template&id=5a9d8295&scoped=true&ts=true


const _withScopeId = n => (pushScopeId("data-v-5a9d8295"), n = n(), popScopeId(), n);

const _hoisted_1 = /*#__PURE__*/_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "ripple-trigger absolute"
}, null, -1));

const _hoisted_2 = [_hoisted_1];
const _hoisted_3 = {
  class: "label text-grey-700"
};
function checkboxvue_type_template_id_5a9d8295_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("div", {
    class: "checkbox flex items-center select-none cursor-pointer",
    onClick: _cache[0] || (_cache[0] = //@ts-ignore
    (...args) => _ctx.toggle && _ctx.toggle(...args))
  }, [createBaseVNode("div", {
    class: normalizeClass(["icon relative", {
      checked: _ctx.props.modelValue,
      'mr-2': !!_ctx.label
    }])
  }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
    size: "100%",
    svg: _ctx.props.modelValue ? _ctx.icon.checked : _ctx.icon.unchecked
  }, null, 8, ["svg"]), withDirectives((openBlock(), createElementBlock("div", {
    class: normalizeClass(["ripple absolute rounded-full", {
      checked: _ctx.props.modelValue
    }])
  }, _hoisted_2, 2)), [[_directive_ripple, {
    center: true
  }]])], 2), createBaseVNode("div", _hoisted_3, toDisplayString(_ctx.label), 1)]);
}
;// CONCATENATED MODULE: ./src/components/checkbox/checkbox.vue?vue&type=template&id=5a9d8295&scoped=true&ts=true

;// CONCATENATED MODULE: ./src/assets/img/mdi/baseline-check_box-24px.svg
/* harmony default export */ const baseline_check_box_24px = ("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0z\" fill=\"none\"/><path fill=\"#1976D2\" d=\"M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/mdi/baseline-check_box_outline_blank-24px.svg
/* harmony default export */ const baseline_check_box_outline_blank_24px = ("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path fill=\"#777\" d=\"M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z\"/><path d=\"M0 0h24v24H0z\" fill=\"none\"/></svg>\n");
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/checkbox/checkbox.ts?vue&type=script&lang=ts



/* harmony default export */ const checkboxvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'Checkbox',
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    label: {
      type: String,
      default: ''
    }
  },
  setup: (props, ctx) => {
    const toggle = () => {
      ctx.emit('update:modelValue', !props.modelValue);
    };

    return {
      props,
      icon: {
        checked: baseline_check_box_24px,
        unchecked: baseline_check_box_outline_blank_24px
      },
      toggle
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/checkbox/checkbox.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/checkbox/checkbox.sass?vue&type=style&index=0&id=5a9d8295&lang=sass&scoped=true
var checkboxvue_type_style_index_0_id_5a9d8295_lang_sass_scoped_true = __webpack_require__(685);
;// CONCATENATED MODULE: ./src/components/checkbox/checkbox.sass?vue&type=style&index=0&id=5a9d8295&lang=sass&scoped=true

// EXTERNAL MODULE: ./node_modules/vue-loader/dist/exportHelper.js
var exportHelper = __webpack_require__(3721);
;// CONCATENATED MODULE: ./src/components/checkbox/checkbox.vue




;


const __exports__ = /*#__PURE__*/(0,exportHelper/* default */.Z)(checkboxvue_type_script_lang_ts, [['render',checkboxvue_type_template_id_5a9d8295_scoped_true_ts_true_render],['__scopeId',"data-v-5a9d8295"]])

/* harmony default export */ const checkbox_checkbox = (__exports__);
;// CONCATENATED MODULE: ./src/components/checkboxLine/checkboxLine.tsx


/* harmony default export */ const checkboxLine = (runtime_core_esm_bundler_defineComponent({
  name: 'CheckboxLine',
  props: {
    modelValue: Boolean,
    text: {
      type: String,
      default: ''
    },
    label: {
      type: String,
      default: ''
    },
    nomt: Boolean
  },
  setup: (props, ctx) => {
    const handleInput = v => {
      ctx.emit('update:modelValue', v);
    };

    return () => {
      var _props$label, _ctx$slots$default, _ctx$slots;

      return runtime_core_esm_bundler_createVNode("div", {
        "class": [!props.nomt && 'mt-6']
      }, [runtime_core_esm_bundler_createVNode(resolveComponent("i-checkbox"), mergeProps({
        "label": (_props$label = props.label) !== null && _props$label !== void 0 ? _props$label : '',
        "modelValue": props.modelValue
      }, {
        'onUpdate:modelValue': handleInput
      }), null), runtime_core_esm_bundler_createVNode("p", {
        "class": "text-14 text-grey-400 mt-1 mb-0"
      }, [(_ctx$slots$default = (_ctx$slots = ctx.slots).default) === null || _ctx$slots$default === void 0 ? void 0 : _ctx$slots$default.call(_ctx$slots), !ctx.slots.default && (props.text || '')])]);
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/radioGroup/radioGroup.tsx


/* harmony default export */ const radioGroup = (runtime_core_esm_bundler_defineComponent({
  props: {
    modelValue: {
      type: null,
      required: true
    }
  },
  setup: (props, ctx) => {
    const handleRadioClick = value => {
      ctx.emit('update:modelValue', value);
    };

    provide('radio-group-handle-radio-click', handleRadioClick);
    provide('radio-group-value', runtime_core_esm_bundler_computed(() => props.modelValue));
    return () => {
      var _ctx$slots$default, _ctx$slots;

      return runtime_core_esm_bundler_createVNode("div", {
        "class": 'radio-group flex-col items-start'
      }, [(_ctx$slots$default = (_ctx$slots = ctx.slots).default) === null || _ctx$slots$default === void 0 ? void 0 : _ctx$slots$default.call(_ctx$slots)]);
    };
  }
}));
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/radio/radio.vue?vue&type=template&id=86d4bb56&scoped=true&ts=true


const radiovue_type_template_id_86d4bb56_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-86d4bb56"), n = n(), popScopeId(), n);

const radiovue_type_template_id_86d4bb56_scoped_true_ts_true_hoisted_1 = /*#__PURE__*/radiovue_type_template_id_86d4bb56_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "ripple-trigger absolute"
}, null, -1));

const radiovue_type_template_id_86d4bb56_scoped_true_ts_true_hoisted_2 = [radiovue_type_template_id_86d4bb56_scoped_true_ts_true_hoisted_1];
const radiovue_type_template_id_86d4bb56_scoped_true_ts_true_hoisted_3 = {
  class: "label text-grey-600"
};
function radiovue_type_template_id_86d4bb56_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  const _directive_ripple = resolveDirective("ripple");

  return openBlock(), createElementBlock("div", {
    class: "radio flex justify-center grow-0 select-none cursor-pointer mr-4 mt-1 mb-1",
    onClick: _cache[0] || (_cache[0] = //@ts-ignore
    (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [createBaseVNode("div", {
    class: normalizeClass(["icon relative mr-2", {
      checked: _ctx.checked
    }])
  }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
    size: "100%",
    svg: _ctx.checked ? _ctx.icon.checked : _ctx.icon.unchecked
  }, null, 8, ["svg"]), withDirectives((openBlock(), createElementBlock("div", {
    class: normalizeClass(["ripple absolute rounded-full", {
      checked: _ctx.checked
    }])
  }, radiovue_type_template_id_86d4bb56_scoped_true_ts_true_hoisted_2, 2)), [[_directive_ripple, {
    center: true
  }]])], 2), createBaseVNode("div", radiovue_type_template_id_86d4bb56_scoped_true_ts_true_hoisted_3, toDisplayString(_ctx.props.label), 1)]);
}
;// CONCATENATED MODULE: ./src/components/radio/radio.vue?vue&type=template&id=86d4bb56&scoped=true&ts=true

;// CONCATENATED MODULE: ./src/assets/img/mdi/baseline-radio_button_checked-24px.svg
/* harmony default export */ const baseline_radio_button_checked_24px = ("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\"><path fill=\"#1976D2\" d=\"M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z\"/><path d=\"M0 0h24v24H0z\" fill=\"none\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/mdi/baseline-radio_button_unchecked-24px.svg
/* harmony default export */ const baseline_radio_button_unchecked_24px = ("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\"><path fill=\"#777\" d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z\"/><path d=\"M0 0h24v24H0z\" fill=\"none\"/></svg>\n");
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/radio/radio.ts?vue&type=script&lang=ts



const icon = {
  checked: baseline_radio_button_checked_24px,
  unchecked: baseline_radio_button_unchecked_24px
};
/* harmony default export */ const radiovue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  props: {
    value: {
      type: null,
      required: true
    },
    label: {
      type: String,
      default: ''
    }
  },
  setup: (props, ctx) => {
    const handleRadioClick = inject('radio-group-handle-radio-click');
    const currentValue = inject('radio-group-value');

    const handleClick = () => {
      ctx.emit('update:modelValue', props.value);

      if (handleRadioClick) {
        handleRadioClick(props.value);
      }
    };

    const checked = runtime_core_esm_bundler_computed(() => {
      if (!currentValue) {
        return false;
      }

      return props.value === currentValue.value;
    });
    return {
      handleClick,
      icon,
      props,
      checked
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/radio/radio.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/radio/radio.sass?vue&type=style&index=0&id=86d4bb56&lang=sass&scoped=true
var radiovue_type_style_index_0_id_86d4bb56_lang_sass_scoped_true = __webpack_require__(9346);
;// CONCATENATED MODULE: ./src/components/radio/radio.sass?vue&type=style&index=0&id=86d4bb56&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/components/radio/radio.vue




;


const radio_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(radiovue_type_script_lang_ts, [['render',radiovue_type_template_id_86d4bb56_scoped_true_ts_true_render],['__scopeId',"data-v-86d4bb56"]])

/* harmony default export */ const radio_radio = (radio_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/slider/slider.vue?vue&type=template&id=629e59a4&scoped=true&ts=true


const slidervue_type_template_id_629e59a4_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-629e59a4"), n = n(), _popScopeId(), n);

const slidervue_type_template_id_629e59a4_scoped_true_ts_true_hoisted_1 = {
  class: "slider select-none"
};
const slidervue_type_template_id_629e59a4_scoped_true_ts_true_hoisted_2 = {
  class: "text text-white text-12"
};
function slidervue_type_template_id_629e59a4_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", slidervue_type_template_id_629e59a4_scoped_true_ts_true_hoisted_1, [createBaseVNode("div", {
    class: "track flex items-center relative",
    ref: _ctx.refs.track,
    onClick: _cache[1] || (_cache[1] = //@ts-ignore
    (...args) => _ctx.handleTrackClick && _ctx.handleTrackClick(...args))
  }, [createBaseVNode("div", {
    class: "track-left bg-blue-700",
    style: normalizeStyle({
      width: `${_ctx.position}%`
    })
  }, null, 4), createBaseVNode("div", {
    class: "track-right bg-grey-400",
    style: normalizeStyle({
      width: `${100 - _ctx.position}%`
    })
  }, null, 4), createBaseVNode("div", {
    class: normalizeClass(["notch absolute bg-blue-700 rounded-full ease-in-out duration-300", {
      dragging: _ctx.state.drag.dragging
    }]),
    style: normalizeStyle({
      left: `${_ctx.position}%`
    }),
    ref: _ctx.refs.notch,
    onMousedown: _cache[0] || (_cache[0] = //@ts-ignore
    (...args) => _ctx.handleNotchMouseDown && _ctx.handleNotchMouseDown(...args))
  }, null, 38), createBaseVNode("div", {
    class: normalizeClass(["bubble flex flex-center bg-blue-700 absolute ease-in-out duration-300 transition-transform", {
      dragging: _ctx.state.drag.dragging
    }]),
    style: normalizeStyle({
      left: `${_ctx.position}%`
    })
  }, [createBaseVNode("div", slidervue_type_template_id_629e59a4_scoped_true_ts_true_hoisted_2, toDisplayString(_ctx.state.cachedValue), 1)], 6)], 512)]);
}
;// CONCATENATED MODULE: ./src/components/slider/slider.vue?vue&type=template&id=629e59a4&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/slider/slider.ts?vue&type=script&lang=ts

/* harmony default export */ const slidervue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'Slider',
  props: {
    modelValue: {
      type: Number,
      required: true
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1
    }
  },
  setup: (props, ctx) => {
    const refs = {
      track: reactivity_esm_bundler_ref(),
      notch: reactivity_esm_bundler_ref()
    };
    const state = reactivity_esm_bundler_reactive({
      drag: {
        startX: 0,
        dragging: false,
        afterDragging: false
      },
      cachedValue: 0
    });

    const getValueFromPercentage = percentage => {
      let newValue = percentage * (props.max - props.min) + props.min;
      const mod = (newValue - props.min) % props.step;

      if (mod) {
        if (mod < props.step / 2) {
          newValue -= mod;
        } else {
          newValue += props.step - mod;
        }
      }

      return newValue;
    };

    const getValueFromDeltaPercentage = percentage => {
      // return this.getValueFromPercentage(props.value / (props.max - props.min) + percentage)
      let newValue = props.modelValue + percentage * (props.max - props.min);
      newValue = newValue < props.min ? props.min : newValue;
      newValue = newValue > props.max ? props.max : newValue;
      const mod = (newValue - props.min) % props.step;

      if (mod) {
        if (mod < props.step / 2) {
          newValue -= mod;
        } else {
          newValue += props.step - mod;
        }
      }

      return newValue;
    };

    const handleNotchMouseDown = e => {
      state.drag.dragging = true;
      state.drag.afterDragging = true;
      state.drag.startX = e.clientX;
    };

    const handleMouseMove = e => {
      if (!state.drag.dragging || !refs.track.value) {
        return;
      }

      const deltaX = e.clientX - state.drag.startX;
      const width = refs.track.value.getBoundingClientRect().width;
      const deltaPercentage = deltaX / width;
      state.cachedValue = getValueFromDeltaPercentage(deltaPercentage);
    };

    const handleMouseUp = () => {
      state.drag.dragging = false;
      setTimeout(() => {
        state.drag.afterDragging = false;
      });
      ctx.emit('update:modelValue', state.cachedValue);
    };

    const handleTrackClick = e => {
      if (e.target === refs.notch.value || state.drag.afterDragging || !refs.track.value) {
        return;
      }

      const position = e.clientX - refs.track.value.getBoundingClientRect().left;
      const width = refs.track.value.getBoundingClientRect().width;
      const percentage = position / width;
      ctx.emit('update:modelValue', getValueFromPercentage(percentage));
    };

    const position = runtime_core_esm_bundler_computed(() => (state.cachedValue - props.min) / (props.max - props.min) * 100);
    watch(() => props.modelValue, () => {
      state.cachedValue = props.modelValue;
    }, {
      immediate: true
    });
    runtime_core_esm_bundler_onMounted(() => {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
      state.cachedValue = props.modelValue;
    });
    runtime_core_esm_bundler_onUnmounted(() => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    });
    return {
      state,
      refs,
      position,
      handleNotchMouseDown,
      handleTrackClick
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/slider/slider.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/slider/slider.sass?vue&type=style&index=0&id=629e59a4&lang=sass&scoped=true
var slidervue_type_style_index_0_id_629e59a4_lang_sass_scoped_true = __webpack_require__(993);
;// CONCATENATED MODULE: ./src/components/slider/slider.sass?vue&type=style&index=0&id=629e59a4&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/components/slider/slider.vue




;


const slider_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(slidervue_type_script_lang_ts, [['render',slidervue_type_template_id_629e59a4_scoped_true_ts_true_render],['__scopeId',"data-v-629e59a4"]])

/* harmony default export */ const slider = (slider_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/hotkeyInput/hotkeyInput.vue?vue&type=template&id=3651d216&scoped=true&ts=true


const hotkeyInputvue_type_template_id_3651d216_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-3651d216"), n = n(), _popScopeId(), n);

const hotkeyInputvue_type_template_id_3651d216_scoped_true_ts_true_hoisted_1 = ["value"];
function hotkeyInputvue_type_template_id_3651d216_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [createBaseVNode("input", {
    class: "input py-5px px-2 bg-grey-200 text-grey-800 m-2px",
    type: "text",
    value: _ctx.inputString,
    onKeydown: _cache[0] || (_cache[0] = withModifiers( //@ts-ignore
    (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args), ["prevent", "stop"]))
  }, null, 40, hotkeyInputvue_type_template_id_3651d216_scoped_true_ts_true_hoisted_1)]);
}
// EXTERNAL MODULE: ./node_modules/core-js-pure/stable/instance/keys.js
var keys = __webpack_require__(1748);
var keys_default = /*#__PURE__*/__webpack_require__.n(keys);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/hotkeyInput/hotkeyInput.ts?vue&type=script&lang=ts



const hotkeyInputvue_type_script_lang_ts_normalizeKey = key => key >= 'a' && key <= 'z' ? key.toUpperCase() : key;

/* harmony default export */ const hotkeyInputvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'HotkeyInput',
  props: {
    modelValue: {
      type: null,
      required: true
    }
  },
  setup: (props, ctx) => {
    var _props$modelValue;

    const state = reactivity_esm_bundler_reactive({
      keys: (_props$modelValue = props.modelValue) !== null && _props$modelValue !== void 0 ? _props$modelValue : [],
      setKeys: []
    });

    const handleKeyDown = e => {
      const key = hotkeyInputvue_type_script_lang_ts_normalizeKey(e.key);

      if (e.repeat) {
        return;
      }

      if (key === 'Backspace') {
        state.keys = [];
        state.setKeys = [];
        return;
      }

      if (!keys_default()(state).includes(key)) {
        keys_default()(state).push(key);
      }

      state.setKeys = [...keys_default()(state)];
    };

    const handleKeyUp = e => {
      const key = hotkeyInputvue_type_script_lang_ts_normalizeKey(e.key);

      const index = keys_default()(state).indexOf(key);

      if (index !== -1) {
        keys_default()(state).splice(index, 1);
      }
    };

    const handleClear = () => {
      state.keys = [];
    };

    const sortedKeys = runtime_core_esm_bundler_computed(() => {
      const keys = state.setKeys;
      const hasCtrl = keys.includes('Control');
      const hasAlt = keys.includes('Alt');
      const hasShift = keys.includes('Shift');
      const inputs = [hasCtrl && 'Control', hasAlt && 'Alt', hasShift && 'Shift', ...keys.filter(v => !['Control', 'Alt', 'Shift'].includes(v))].filter(Boolean);
      return inputs;
    });
    const inputDisplayString = runtime_core_esm_bundler_computed(() => {
      if (!sortedKeys.value.length) {
        return '无';
      }

      return sortedKeys.value.map(v => v === 'Control' ? 'Ctrl' : v).join(' + ');
    });
    watch(() => sortedKeys.value, () => {
      ctx.emit('update:modelValue', sortedKeys.value);
    });
    watch(() => props.modelValue, () => {
      if (!props.modelValue) {
        return;
      }

      if (props.modelValue.every((v, i) => v === state.setKeys[i])) {
        return;
      }

      state.setKeys = [...props.modelValue];
    }, {
      immediate: true
    });
    runtime_core_esm_bundler_onMounted(() => {
      window.addEventListener('keyup', handleKeyUp);
      window.addEventListener('blur', handleClear);
      window.addEventListener('focus', handleClear);
    });
    runtime_core_esm_bundler_onUnmounted(() => {
      window.removeEventListener('keyup', handleKeyUp);
      window.removeEventListener('blur', handleClear);
      window.removeEventListener('focus', handleClear);
    });
    return {
      props,
      state,
      inputString: inputDisplayString,
      handleKeyDown,
      handleKeyUp
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/hotkeyInput/hotkeyInput.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/hotkeyInput/hotkeyInput.sass?vue&type=style&index=0&id=3651d216&lang=sass&scoped=true
var hotkeyInputvue_type_style_index_0_id_3651d216_lang_sass_scoped_true = __webpack_require__(4259);
;// CONCATENATED MODULE: ./src/components/hotkeyInput/hotkeyInput.sass?vue&type=style&index=0&id=3651d216&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/components/hotkeyInput/hotkeyInput.vue




;


const hotkeyInput_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(hotkeyInputvue_type_script_lang_ts, [['render',hotkeyInputvue_type_template_id_3651d216_scoped_true_ts_true_render],['__scopeId',"data-v-3651d216"]])

/* harmony default export */ const hotkeyInput = (hotkeyInput_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/IIcon/IIcon.vue?vue&type=template&id=4a9ea35f&ts=true

const IIconvue_type_template_id_4a9ea35f_ts_true_hoisted_1 = ["src"];
function IIconvue_type_template_id_4a9ea35f_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "i-icon flex flex-center",
    style: normalizeStyle({
      height: _ctx.computedSize,
      width: _ctx.computedSize
    })
  }, [createBaseVNode("img", {
    class: "svg-img flex-1 w-0",
    src: _ctx.svgUrl,
    alt: ""
  }, null, 8, IIconvue_type_template_id_4a9ea35f_ts_true_hoisted_1)], 4);
}
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/IIcon/IIcon.ts?vue&type=script&lang=ts

/* harmony default export */ const IIconvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  props: {
    svg: {
      type: String,
      default: ''
    },
    size: {
      type: null,
      default: 16
    },
    color: {
      type: String,
      default: ''
    }
  },
  setup: props => {
    const computedSize = runtime_core_esm_bundler_computed(() => {
      if (!props.size) {
        return undefined;
      }

      const size = parseInt(`${props.size}`, 10);

      if (`${size}` === `${props.size}`) {
        return `${size}px`;
      }

      return props.size;
    });
    const svgContent = runtime_core_esm_bundler_computed(() => props.color ? props.svg.replace(/(fill="#[a-fA-F0-9]{6}")/g, `fill="${props.color}"`) : props.svg);
    const svgUrl = runtime_core_esm_bundler_computed(() => `data:image/svg+xml;base64,${window.btoa(svgContent.value)}`);
    return {
      computedSize,
      svgContent,
      svgUrl
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/IIcon/IIcon.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/components/IIcon/IIcon.vue




;
const IIcon_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(IIconvue_type_script_lang_ts, [['render',IIconvue_type_template_id_4a9ea35f_ts_true_render]])

/* harmony default export */ const IIcon = (IIcon_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/textInput/textInput.vue?vue&type=template&id=16445f67&scoped=true&ts=true


const textInputvue_type_template_id_16445f67_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-16445f67"), n = n(), _popScopeId(), n);

const textInputvue_type_template_id_16445f67_scoped_true_ts_true_hoisted_1 = ["value", "type", "placeholder"];
function textInputvue_type_template_id_16445f67_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [createBaseVNode("input", {
    value: _ctx.props.modelValue,
    class: "input py-5px px-2 m-2px",
    type: _ctx.props.inputType,
    placeholder: _ctx.props.placeholder,
    onInput: _cache[0] || (_cache[0] = $event => _ctx.handleInput($event)),
    onKeydownCapture: _cache[1] || (_cache[1] = withModifiers(() => {}, ["stop"]))
  }, null, 40, textInputvue_type_template_id_16445f67_scoped_true_ts_true_hoisted_1)]);
}
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/textInput/textInput.ts?vue&type=script&lang=ts

/* harmony default export */ const textInputvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'TextInput',
  props: {
    modelValue: {
      type: String,
      required: true
    },
    inputType: {
      type: String,
      required: true,
      default: 'text'
    },
    placeholder: String
  },
  setup: (props, ctx) => {
    const handleInput = e => {
      e.stopPropagation();
      const target = e.target;
      ctx.emit('update:modelValue', target.value);
    };

    return {
      props,
      handleInput
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/textInput/textInput.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/textInput/textInput.sass?vue&type=style&index=0&id=16445f67&lang=sass&scoped=true
var textInputvue_type_style_index_0_id_16445f67_lang_sass_scoped_true = __webpack_require__(9902);
;// CONCATENATED MODULE: ./src/components/textInput/textInput.sass?vue&type=style&index=0&id=16445f67&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/components/textInput/textInput.vue




;


const textInput_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(textInputvue_type_script_lang_ts, [['render',textInputvue_type_template_id_16445f67_scoped_true_ts_true_render],['__scopeId',"data-v-16445f67"]])

/* harmony default export */ const textInput = (textInput_exports_);
;// CONCATENATED MODULE: ./src/components/textInputLine/textInputLine.tsx


/* harmony default export */ const textInputLine = (runtime_core_esm_bundler_defineComponent({
  name: 'TextInputLine',
  props: {
    modelValue: {
      type: String,
      required: true
    },
    inputType: {
      type: String,
      default: 'text'
    },
    placeholder: String,
    label: {
      type: String,
      default: ''
    }
  },
  setup: (props, ctx) => {
    const handleInput = v => {
      ctx.emit('update:modelValue', v);
    };

    return () => {
      var _props$label;

      return runtime_core_esm_bundler_createVNode("div", {
        "class": 'flex mt-4'
      }, [runtime_core_esm_bundler_createVNode("label", {
        "class": 'label text-grey-700 py-5px pr-10px my-2px'
      }, [(_props$label = props.label) !== null && _props$label !== void 0 ? _props$label : '']), runtime_core_esm_bundler_createVNode(resolveComponent("i-text-input"), mergeProps({
        "inputType": props.inputType,
        "placeholder": props.placeholder,
        "modelValue": props.modelValue
      }, {
        'onUpdate:modelValue': handleInput
      }), null)]);
    };
  }
}));
;// CONCATENATED MODULE: ./node_modules/fp-ts/es6/ChainRec.js
/**
 * @since 2.0.0
 */
var tailRec = function (startWith, f) {
    var ab = f(startWith);
    while (ab._tag === 'Left') {
        ab = f(ab.left);
    }
    return ab.right;
};

;// CONCATENATED MODULE: ./node_modules/fp-ts/es6/function.js
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 2.10.0
 */
var getBooleanAlgebra = function (B) { return function () { return ({
    meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },
    join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },
    zero: function () { return B.zero; },
    one: function () { return B.one; },
    implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },
    not: function (x) { return function (a) { return B.not(x(a)); }; }
}); }; };
/**
 * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.
 *
 * @example
 * import { Predicate, getSemigroup } from 'fp-ts/function'
 * import * as B from 'fp-ts/boolean'
 *
 * const f: Predicate<number> = (n) => n <= 2
 * const g: Predicate<number> = (n) => n >= 0
 *
 * const S1 = getSemigroup(B.SemigroupAll)<number>()
 *
 * assert.deepStrictEqual(S1.concat(f, g)(1), true)
 * assert.deepStrictEqual(S1.concat(f, g)(3), false)
 *
 * const S2 = getSemigroup(B.SemigroupAny)<number>()
 *
 * assert.deepStrictEqual(S2.concat(f, g)(1), true)
 * assert.deepStrictEqual(S2.concat(f, g)(3), true)
 *
 * @category instances
 * @since 2.10.0
 */
var getSemigroup = function (S) { return function () { return ({
    concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }
}); }; };
/**
 * Unary functions form a monoid as long as you can provide a monoid for the codomain.
 *
 * @example
 * import { Predicate } from 'fp-ts/Predicate'
 * import { getMonoid } from 'fp-ts/function'
 * import * as B from 'fp-ts/boolean'
 *
 * const f: Predicate<number> = (n) => n <= 2
 * const g: Predicate<number> = (n) => n >= 0
 *
 * const M1 = getMonoid(B.MonoidAll)<number>()
 *
 * assert.deepStrictEqual(M1.concat(f, g)(1), true)
 * assert.deepStrictEqual(M1.concat(f, g)(3), false)
 *
 * const M2 = getMonoid(B.MonoidAny)<number>()
 *
 * assert.deepStrictEqual(M2.concat(f, g)(1), true)
 * assert.deepStrictEqual(M2.concat(f, g)(3), true)
 *
 * @category instances
 * @since 2.10.0
 */
var getMonoid = function (M) {
    var getSemigroupM = getSemigroup(M);
    return function () { return ({
        concat: getSemigroupM().concat,
        empty: function () { return M.empty; }
    }); };
};
/**
 * @category instances
 * @since 2.10.0
 */
var getSemiring = function (S) { return ({
    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },
    zero: function () { return S.zero; },
    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },
    one: function () { return S.one; }
}); };
/**
 * @category instances
 * @since 2.10.0
 */
var getRing = function (R) {
    var S = getSemiring(R);
    return {
        add: S.add,
        mul: S.mul,
        one: S.one,
        zero: S.zero,
        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }
    };
};
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */
var apply = function (a) { return function (f) { return f(a); }; };
/**
 * @since 2.0.0
 */
function function_identity(a) {
    return a;
}
/**
 * @since 2.0.0
 */
var unsafeCoerce = (/* unused pure expression or super */ null && (function_identity));
/**
 * @since 2.0.0
 */
function constant(a) {
    return function () { return a; };
}
/**
 * A thunk that returns always `true`.
 *
 * @since 2.0.0
 */
var constTrue = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (constant(true)));
/**
 * A thunk that returns always `false`.
 *
 * @since 2.0.0
 */
var constFalse = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (constant(false)));
/**
 * A thunk that returns always `null`.
 *
 * @since 2.0.0
 */
var constNull = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (constant(null)));
/**
 * A thunk that returns always `undefined`.
 *
 * @since 2.0.0
 */
var constUndefined = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (constant(undefined)));
/**
 * A thunk that returns always `void`.
 *
 * @since 2.0.0
 */
var constVoid = (/* unused pure expression or super */ null && (constUndefined));
/**
 * Flips the order of the arguments of a function of two arguments.
 *
 * @since 2.0.0
 */
function flip(f) {
    return function (b, a) { return f(a, b); };
}
function function_flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
    switch (arguments.length) {
        case 1:
            return ab;
        case 2:
            return function () {
                return bc(ab.apply(this, arguments));
            };
        case 3:
            return function () {
                return cd(bc(ab.apply(this, arguments)));
            };
        case 4:
            return function () {
                return de(cd(bc(ab.apply(this, arguments))));
            };
        case 5:
            return function () {
                return ef(de(cd(bc(ab.apply(this, arguments)))));
            };
        case 6:
            return function () {
                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
            };
        case 7:
            return function () {
                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
            };
        case 8:
            return function () {
                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
            };
        case 9:
            return function () {
                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
            };
    }
    return;
}
/**
 * @since 2.0.0
 */
function tuple() {
    var t = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        t[_i] = arguments[_i];
    }
    return t;
}
/**
 * @since 2.0.0
 */
function increment(n) {
    return n + 1;
}
/**
 * @since 2.0.0
 */
function decrement(n) {
    return n - 1;
}
/**
 * @since 2.0.0
 */
function absurd(_) {
    throw new Error('Called `absurd` function which should be uncallable');
}
/**
 * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.
 *
 * @example
 * import { tupled } from 'fp-ts/function'
 *
 * const add = tupled((x: number, y: number): number => x + y)
 *
 * assert.strictEqual(add([1, 2]), 3)
 *
 * @since 2.4.0
 */
function tupled(f) {
    return function (a) { return f.apply(void 0, a); };
}
/**
 * Inverse function of `tupled`
 *
 * @since 2.4.0
 */
function untupled(f) {
    return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return f(a);
    };
}
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
    switch (arguments.length) {
        case 1:
            return a;
        case 2:
            return ab(a);
        case 3:
            return bc(ab(a));
        case 4:
            return cd(bc(ab(a)));
        case 5:
            return de(cd(bc(ab(a))));
        case 6:
            return ef(de(cd(bc(ab(a)))));
        case 7:
            return fg(ef(de(cd(bc(ab(a))))));
        case 8:
            return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default:
            var ret = arguments[0];
            for (var i = 1; i < arguments.length; i++) {
                ret = arguments[i](ret);
            }
            return ret;
    }
}
/**
 * Type hole simulation
 *
 * @since 2.7.0
 */
var hole = (/* unused pure expression or super */ null && (absurd));
/**
 * @since 2.11.0
 */
var SK = function (_, b) { return b; };
/**
 * Use `Predicate` module instead.
 *
 * @since 2.0.0
 * @deprecated
 */
function not(predicate) {
    return function (a) { return !predicate(a); };
}
/**
 * Use `Endomorphism` module instead.
 *
 * @category instances
 * @since 2.10.0
 * @deprecated
 */
var getEndomorphismMonoid = function () { return ({
    concat: function (first, second) { return function_flow(first, second); },
    empty: function_identity
}); };

;// CONCATENATED MODULE: ./node_modules/fp-ts/es6/internal.js
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
// -------------------------------------------------------------------------------------
// Option
// -------------------------------------------------------------------------------------
/** @internal */
var isNone = function (fa) { return fa._tag === 'None'; };
/** @internal */
var isSome = function (fa) { return fa._tag === 'Some'; };
/** @internal */
var none = { _tag: 'None' };
/** @internal */
var some = function (a) { return ({ _tag: 'Some', value: a }); };
// -------------------------------------------------------------------------------------
// Either
// -------------------------------------------------------------------------------------
/** @internal */
var internal_isLeft = function (ma) { return ma._tag === 'Left'; };
/** @internal */
var isRight = function (ma) { return ma._tag === 'Right'; };
/** @internal */
var left = function (e) { return ({ _tag: 'Left', left: e }); };
/** @internal */
var internal_right = function (a) { return ({ _tag: 'Right', right: a }); };
// -------------------------------------------------------------------------------------
// ReadonlyNonEmptyArray
// -------------------------------------------------------------------------------------
/** @internal */
var singleton = function (a) { return [a]; };
/** @internal */
var isNonEmpty = function (as) { return as.length > 0; };
/** @internal */
var head = function (as) { return as[0]; };
/** @internal */
var tail = function (as) { return as.slice(1); };
// -------------------------------------------------------------------------------------
// empty
// -------------------------------------------------------------------------------------
/** @internal */
var emptyReadonlyArray = [];
/** @internal */
var emptyRecord = {};
// -------------------------------------------------------------------------------------
// Record
// -------------------------------------------------------------------------------------
/** @internal */
var internal_has = Object.prototype.hasOwnProperty;
// -------------------------------------------------------------------------------------
// NonEmptyArray
// -------------------------------------------------------------------------------------
/** @internal */
var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1)); };

;// CONCATENATED MODULE: ./node_modules/fp-ts/es6/Either.js










// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this
 * structure.
 *
 * @category constructors
 * @since 2.0.0
 */
var Either_left = left;
/**
 * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias
 * of this structure.
 *
 * @category constructors
 * @since 2.0.0
 */
var Either_right = internal_right;
// -------------------------------------------------------------------------------------
// non-pipeables
// -------------------------------------------------------------------------------------
var _map = function (fa, f) { return pipe(fa, Either_map(f)); };
var _ap = function (fab, fa) { return pipe(fab, ap(fa)); };
/* istanbul ignore next */
var _chain = function (ma, f) { return pipe(ma, chain(f)); };
/* istanbul ignore next */
var _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };
/* istanbul ignore next */
var _foldMap = function (M) { return function (fa, f) {
    var foldMapM = foldMap(M);
    return pipe(fa, foldMapM(f));
}; };
/* istanbul ignore next */
var _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };
var _traverse = function (F) {
    var traverseF = Either_traverse(F);
    return function (ta, f) { return pipe(ta, traverseF(f)); };
};
var _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };
var _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };
/* istanbul ignore next */
var _alt = function (fa, that) { return pipe(fa, alt(that)); };
/* istanbul ignore next */
var _extend = function (wa, f) { return pipe(wa, Either_extend(f)); };
var _chainRec = function (a, f) {
    return tailRec(f(a), function (e) {
        return Either_isLeft(e) ? Either_right(Either_left(e.left)) : Either_isLeft(e.right) ? Either_left(f(e.right.left)) : Either_right(Either_right(e.right.right));
    });
};
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 2.0.0
 */
var URI = 'Either';
/**
 * @category instances
 * @since 2.0.0
 */
var getShow = function (SE, SA) { return ({
    show: function (ma) { return (Either_isLeft(ma) ? "left(" + SE.show(ma.left) + ")" : "right(" + SA.show(ma.right) + ")"); }
}); };
/**
 * @category instances
 * @since 2.0.0
 */
var getEq = function (EL, EA) { return ({
    equals: function (x, y) {
        return x === y || (Either_isLeft(x) ? Either_isLeft(y) && EL.equals(x.left, y.left) : Either_isRight(y) && EA.equals(x.right, y.right));
    }
}); };
/**
 * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are
 * concatenated using the provided `Semigroup`
 *
 * @example
 * import { getSemigroup, left, right } from 'fp-ts/Either'
 * import { SemigroupSum } from 'fp-ts/number'
 *
 * const S = getSemigroup<string, number>(SemigroupSum)
 * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))
 * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))
 * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))
 * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))
 *
 * @category instances
 * @since 2.0.0
 */
var Either_getSemigroup = function (S) { return ({
    concat: function (x, y) { return (Either_isLeft(y) ? x : Either_isLeft(x) ? y : Either_right(S.concat(x.right, y.right))); }
}); };
/**
 * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.
 *
 * @category instances
 * @since 2.10.0
 */
var getCompactable = function (M) {
    var empty = Either_left(M.empty);
    return {
        URI: URI,
        _E: undefined,
        compact: function (ma) { return (Either_isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : Either_right(ma.right.value)); },
        separate: function (ma) {
            return Either_isLeft(ma)
                ? separated(ma, ma)
                : Either_isLeft(ma.right)
                    ? separated(Either_right(ma.right.left), empty)
                    : separated(empty, Either_right(ma.right.right));
        }
    };
};
/**
 * Builds a `Filterable` instance for `Either` given `Monoid` for the left side
 *
 * @category instances
 * @since 2.10.0
 */
var getFilterable = function (M) {
    var empty = Either_left(M.empty);
    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;
    var filter = function (ma, predicate) {
        return Either_isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;
    };
    var partition = function (ma, p) {
        return Either_isLeft(ma)
            ? separated(ma, ma)
            : p(ma.right)
                ? separated(empty, Either_right(ma.right))
                : separated(Either_right(ma.right), empty);
    };
    return {
        URI: URI,
        _E: undefined,
        map: _map,
        compact: compact,
        separate: separate,
        filter: filter,
        filterMap: function (ma, f) {
            if (Either_isLeft(ma)) {
                return ma;
            }
            var ob = f(ma.right);
            return ob._tag === 'None' ? empty : Either_right(ob.value);
        },
        partition: partition,
        partitionMap: function (ma, f) {
            if (Either_isLeft(ma)) {
                return separated(ma, ma);
            }
            var e = f(ma.right);
            return Either_isLeft(e) ? separated(Either_right(e.left), empty) : separated(empty, Either_right(e.right));
        }
    };
};
/**
 * Builds `Witherable` instance for `Either` given `Monoid` for the left side
 *
 * @category instances
 * @since 2.0.0
 */
var getWitherable = function (M) {
    var F_ = getFilterable(M);
    var C = getCompactable(M);
    return {
        URI: URI,
        _E: undefined,
        map: _map,
        compact: F_.compact,
        separate: F_.separate,
        filter: F_.filter,
        filterMap: F_.filterMap,
        partition: F_.partition,
        partitionMap: F_.partitionMap,
        traverse: _traverse,
        sequence: sequence,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        wither: witherDefault(Traversable, C),
        wilt: wiltDefault(Traversable, C)
    };
};
/**
 * @category instances
 * @since 2.7.0
 */
var getApplicativeValidation = function (SE) { return ({
    URI: URI,
    _E: undefined,
    map: _map,
    ap: function (fab, fa) {
        return Either_isLeft(fab)
            ? Either_isLeft(fa)
                ? Either_left(SE.concat(fab.left, fa.left))
                : fab
            : Either_isLeft(fa)
                ? fa
                : Either_right(fab.right(fa.right));
    },
    of: of
}); };
/**
 * @category instances
 * @since 2.7.0
 */
var getAltValidation = function (SE) { return ({
    URI: URI,
    _E: undefined,
    map: _map,
    alt: function (me, that) {
        if (Either_isRight(me)) {
            return me;
        }
        var ea = that();
        return Either_isLeft(ea) ? Either_left(SE.concat(me.left, ea.left)) : ea;
    }
}); };
/**
 * @category instance operations
 * @since 2.0.0
 */
var Either_map = function (f) { return function (fa) {
    return Either_isLeft(fa) ? fa : Either_right(f(fa.right));
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Functor = {
    URI: URI,
    map: _map
};
/**
 * @category instance operations
 * @since 2.7.0
 */
var of = Either_right;
/**
 * @category instances
 * @since 2.10.0
 */
var Pointed = {
    URI: URI,
    of: of
};
/**
 * Less strict version of [`ap`](#ap).
 *
 * @category instance operations
 * @since 2.8.0
 */
var apW = function (fa) { return function (fab) { return (Either_isLeft(fab) ? fab : Either_isLeft(fa) ? fa : Either_right(fab.right(fa.right))); }; };
/**
 * Apply a function to an argument under a type constructor.
 *
 * @category instance operations
 * @since 2.0.0
 */
var ap = apW;
/**
 * @category instances
 * @since 2.10.0
 */
var Apply = {
    URI: URI,
    map: _map,
    ap: _ap
};
/**
 * @category instances
 * @since 2.7.0
 */
var Applicative = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of
};
/**
 * Less strict version of [`chain`](#chain).
 *
 * @category instance operations
 * @since 2.6.0
 */
var chainW = function (f) { return function (ma) {
    return Either_isLeft(ma) ? ma : f(ma.right);
}; };
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation.
 *
 * @category instance operations
 * @since 2.0.0
 */
var chain = chainW;
/**
 * @category instances
 * @since 2.10.0
 */
var Chain = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: _chain
};
/**
 * @category instances
 * @since 2.7.0
 */
var Monad = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    chain: _chain
};
/**
 * Left-associative fold of a structure.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as E from 'fp-ts/Either'
 *
 * const startWith = 'prefix'
 * const concat = (a: string, b: string) => `${a}:${b}`
 *
 * assert.deepStrictEqual(
 *   pipe(E.right('a'), E.reduce(startWith, concat)),
 *   'prefix:a'
 * )
 *
 * assert.deepStrictEqual(
 *   pipe(E.left('e'), E.reduce(startWith, concat)),
 *   'prefix'
 * )
 *
 * @category instance operations
 * @since 2.0.0
 */
var reduce = function (b, f) { return function (fa) {
    return Either_isLeft(fa) ? b : f(b, fa.right);
}; };
/**
 * Map each element of the structure to a monoid, and combine the results.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as E from 'fp-ts/Either'
 * import * as S from 'fp-ts/string'
 *
 * const yell = (a: string) => `${a}!`
 *
 * assert.deepStrictEqual(
 *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),
 *   'a!'
 * )
 *
 * assert.deepStrictEqual(
 *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),
 *   S.Monoid.empty
 * )
 *
 * @category instance operations
 * @since 2.0.0
 */
var foldMap = function (M) { return function (f) { return function (fa) {
    return Either_isLeft(fa) ? M.empty : f(fa.right);
}; }; };
/**
 * Right-associative fold of a structure.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as E from 'fp-ts/Either'
 *
 * const startWith = 'postfix'
 * const concat = (a: string, b: string) => `${a}:${b}`
 *
 * assert.deepStrictEqual(
 *   pipe(E.right('a'), E.reduceRight(startWith, concat)),
 *   'a:postfix'
 * )
 *
 * assert.deepStrictEqual(
 *   pipe(E.left('e'), E.reduceRight(startWith, concat)),
 *   'postfix'
 * )
 *
 * @category instance operations
 * @since 2.0.0
 */
var reduceRight = function (b, f) { return function (fa) {
    return Either_isLeft(fa) ? b : f(fa.right, b);
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Foldable = {
    URI: URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight
};
/**
 * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import * as E from 'fp-ts/Either'
 * import * as O from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(
 *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),
 *   O.some(E.right('a'))
 *  )
 *
 * assert.deepStrictEqual(
 *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),
 *   O.none
 * )
 *
 * @category instance operations
 * @since 2.6.3
 */
var Either_traverse = function (F) { return function (f) { return function (ta) { return (Either_isLeft(ta) ? F.of(Either_left(ta.left)) : F.map(f(ta.right), Either_right)); }; }; };
/**
 * Evaluate each monadic action in the structure from left to right, and collect the results.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as E from 'fp-ts/Either'
 * import * as O from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(
 *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),
 *   O.some(E.right('a'))
 *  )
 *
 * assert.deepStrictEqual(
 *   pipe(E.right(O.none), E.sequence(O.Applicative)),
 *   O.none
 * )
 *
 * @category instance operations
 * @since 2.6.3
 */
var sequence = function (F) { return function (ma) {
    return Either_isLeft(ma) ? F.of(Either_left(ma.left)) : F.map(ma.right, Either_right);
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Traversable = {
    URI: URI,
    map: _map,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence
};
/**
 * Map a pair of functions over the two type arguments of the bifunctor.
 *
 * @category instance operations
 * @since 2.0.0
 */
var bimap = function (f, g) { return function (fa) { return (Either_isLeft(fa) ? Either_left(f(fa.left)) : Either_right(g(fa.right))); }; };
/**
 * Map a function over the first type argument of a bifunctor.
 *
 * @category instance operations
 * @since 2.0.0
 */
var mapLeft = function (f) { return function (fa) {
    return Either_isLeft(fa) ? Either_left(f(fa.left)) : fa;
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Bifunctor = {
    URI: URI,
    bimap: _bimap,
    mapLeft: _mapLeft
};
/**
 * Less strict version of [`alt`](#alt).
 *
 * @category instance operations
 * @since 2.9.0
 */
var altW = function (that) { return function (fa) { return (Either_isLeft(fa) ? that() : fa); }; };
/**
 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
 * types of kind `* -> *`.
 *
 * @category instance operations
 * @since 2.0.0
 */
var alt = altW;
/**
 * @category instances
 * @since 2.7.0
 */
var Alt = {
    URI: URI,
    map: _map,
    alt: _alt
};
/**
 * @category instance operations
 * @since 2.0.0
 */
var Either_extend = function (f) { return function (wa) {
    return Either_isLeft(wa) ? wa : Either_right(f(wa));
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Extend = {
    URI: URI,
    map: _map,
    extend: _extend
};
/**
 * @category instances
 * @since 2.7.0
 */
var ChainRec = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: _chain,
    chainRec: _chainRec
};
/**
 * @category instance operations
 * @since 2.6.3
 */
var throwError = Either_left;
/**
 * @category instances
 * @since 2.7.0
 */
var MonadThrow = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    chain: _chain,
    throwError: throwError
};
/**
 * @category instances
 * @since 2.10.0
 */
var FromEither = {
    URI: URI,
    fromEither: function_identity
};
/**
 * @example
 * import { fromPredicate, left, right } from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     1,
 *     fromPredicate(
 *       (n) => n > 0,
 *       () => 'error'
 *     )
 *   ),
 *   right(1)
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     -1,
 *     fromPredicate(
 *       (n) => n > 0,
 *       () => 'error'
 *     )
 *   ),
 *   left('error')
 * )
 *
 * @category constructors
 * @since 2.0.0
 */
var fromPredicate = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (fromPredicate_(FromEither)));
// -------------------------------------------------------------------------------------
// natural transformations
// -------------------------------------------------------------------------------------
/**
 * @example
 * import * as E from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 * import * as O from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     O.some(1),
 *     E.fromOption(() => 'error')
 *   ),
 *   E.right(1)
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     O.none,
 *     E.fromOption(() => 'error')
 *   ),
 *   E.left('error')
 * )
 *
 * @category natural transformations
 * @since 2.0.0
 */
var fromOption = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (fromOption_(FromEither)));
// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * Returns `true` if the either is an instance of `Left`, `false` otherwise.
 *
 * @category refinements
 * @since 2.0.0
 */
var Either_isLeft = internal_isLeft;
/**
 * Returns `true` if the either is an instance of `Right`, `false` otherwise.
 *
 * @category refinements
 * @since 2.0.0
 */
var Either_isRight = isRight;
// -------------------------------------------------------------------------------------
// destructors
// -------------------------------------------------------------------------------------
/**
 * Less strict version of [`match`](#match).
 *
 * @category destructors
 * @since 2.10.0
 */
var matchW = function (onLeft, onRight) { return function (ma) {
    return Either_isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);
}; };
/**
 * Alias of [`matchW`](#matchw).
 *
 * @category destructors
 * @since 2.10.0
 */
var foldW = (/* unused pure expression or super */ null && (matchW));
/**
 * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,
 * if the value is a `Right` the inner value is applied to the second function.
 *
 * @example
 * import { match, left, right } from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 *
 * function onLeft(errors: Array<string>): string {
 *   return `Errors: ${errors.join(', ')}`
 * }
 *
 * function onRight(value: number): string {
 *   return `Ok: ${value}`
 * }
 *
 * assert.strictEqual(
 *   pipe(
 *     right(1),
 *     match(onLeft, onRight)
 *   ),
 *   'Ok: 1'
 * )
 * assert.strictEqual(
 *   pipe(
 *     left(['error 1', 'error 2']),
 *     match(onLeft, onRight)
 *   ),
 *   'Errors: error 1, error 2'
 * )
 *
 * @category destructors
 * @since 2.10.0
 */
var match = (/* unused pure expression or super */ null && (matchW));
/**
 * Alias of [`match`](#match).
 *
 * @category destructors
 * @since 2.0.0
 */
var fold = (/* unused pure expression or super */ null && (match));
/**
 * Less strict version of [`getOrElse`](#getorelse).
 *
 * @category destructors
 * @since 2.6.0
 */
var getOrElseW = function (onLeft) { return function (ma) {
    return Either_isLeft(ma) ? onLeft(ma.left) : ma.right;
}; };
/**
 * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.
 *
 * @example
 * import { getOrElse, left, right } from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     right(1),
 *     getOrElse(() => 0)
 *   ),
 *   1
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     left('error'),
 *     getOrElse(() => 0)
 *   ),
 *   0
 * )
 *
 * @category destructors
 * @since 2.0.0
 */
var getOrElse = (/* unused pure expression or super */ null && (getOrElseW));
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * Derivable from `Functor`.
 *
 * @category combinators
 * @since 2.10.0
 */
var flap = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (flap_(Functor)));
/**
 * Combine two effectful actions, keeping only the result of the first.
 *
 * Derivable from `Apply`.
 *
 * @category combinators
 * @since 2.0.0
 */
var apFirst = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (apFirst_(Apply)));
/**
 * Combine two effectful actions, keeping only the result of the second.
 *
 * Derivable from `Apply`.
 *
 * @category combinators
 * @since 2.0.0
 */
var apSecond = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (apSecond_(Apply)));
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation and
 * keeping only the result of the first.
 *
 * Derivable from `Chain`.
 *
 * @category combinators
 * @since 2.0.0
 */
var chainFirst = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (chainFirst_(Chain)));
/**
 * Less strict version of [`chainFirst`](#chainfirst)
 *
 * Derivable from `Chain`.
 *
 * @category combinators
 * @since 2.8.0
 */
var chainFirstW = (/* unused pure expression or super */ null && (chainFirst));
/**
 * Less strict version of [`flatten`](#flatten).
 *
 * @category combinators
 * @since 2.11.0
 */
var flattenW = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (chainW(identity)));
/**
 * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.
 *
 * Derivable from `Chain`.
 *
 * @example
 * import * as E from 'fp-ts/Either'
 *
 * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))
 * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))
 * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))
 *
 * @category combinators
 * @since 2.0.0
 */
var flatten = (/* unused pure expression or super */ null && (flattenW));
/**
 * Derivable from `Extend`.
 *
 * @category combinators
 * @since 2.0.0
 */
var duplicate = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (Either_extend(identity)));
/**
 * @category combinators
 * @since 2.10.0
 */
var fromOptionK = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (fromOptionK_(FromEither)));
/**
 * @category combinators
 * @since 2.11.0
 */
var chainOptionK = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (chainOptionK_(FromEither, Chain)));
/**
 * @example
 * import * as E from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     E.right(1),
 *     E.filterOrElse(
 *       (n) => n > 0,
 *       () => 'error'
 *     )
 *   ),
 *   E.right(1)
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     E.right(-1),
 *     E.filterOrElse(
 *       (n) => n > 0,
 *       () => 'error'
 *     )
 *   ),
 *   E.left('error')
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     E.left('a'),
 *     E.filterOrElse(
 *       (n) => n > 0,
 *       () => 'error'
 *     )
 *   ),
 *   E.left('a')
 * )
 *
 * @category combinators
 * @since 2.0.0
 */
var filterOrElse = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (filterOrElse_(FromEither, Chain)));
/**
 * Less strict version of [`filterOrElse`](#filterorelse).
 *
 * @category combinators
 * @since 2.9.0
 */
var filterOrElseW = (/* unused pure expression or super */ null && (filterOrElse));
/**
 * Returns a `Right` if is a `Left` (and vice versa).
 *
 * @category combinators
 * @since 2.0.0
 */
var swap = function (ma) { return (Either_isLeft(ma) ? Either_right(ma.left) : Either_left(ma.right)); };
/**
 * Less strict version of [`orElse`](#orelse).
 *
 * @category combinators
 * @since 2.10.0
 */
var orElseW = function (onLeft) { return function (ma) {
    return Either_isLeft(ma) ? onLeft(ma.left) : ma;
}; };
/**
 * Useful for recovering from errors.
 *
 * @category combinators
 * @since 2.0.0
 */
var orElse = (/* unused pure expression or super */ null && (orElseW));
// -------------------------------------------------------------------------------------
// interop
// -------------------------------------------------------------------------------------
/**
 * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use
 * the provided default as a `Left`.
 *
 * @example
 * import { fromNullable, left, right } from 'fp-ts/Either'
 *
 * const parse = fromNullable('nully')
 *
 * assert.deepStrictEqual(parse(1), right(1))
 * assert.deepStrictEqual(parse(null), left('nully'))
 *
 * @category interop
 * @since 2.0.0
 */
var fromNullable = function (e) { return function (a) {
    return a == null ? Either_left(e) : Either_right(a);
}; };
/**
 * Constructs a new `Either` from a function that might throw.
 *
 * See also [`tryCatchK`](#trycatchk).
 *
 * @example
 * import * as E from 'fp-ts/Either'
 *
 * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {
 *   if (as.length > 0) {
 *     return as[0]
 *   } else {
 *     throw new Error('empty array')
 *   }
 * }
 *
 * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>
 *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))
 *
 * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))
 * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))
 *
 * @category interop
 * @since 2.0.0
 */
var tryCatch = function (f, onThrow) {
    try {
        return Either_right(f());
    }
    catch (e) {
        return Either_left(onThrow(e));
    }
};
/**
 * Converts a function that may throw to one returning a `Either`.
 *
 * @category interop
 * @since 2.10.0
 */
var tryCatchK = function (f, onThrow) { return function () {
    var a = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        a[_i] = arguments[_i];
    }
    return tryCatch(function () { return f.apply(void 0, a); }, onThrow);
}; };
/**
 * @category interop
 * @since 2.9.0
 */
var fromNullableK = function (e) {
    var from = fromNullable(e);
    return function (f) { return flow(f, from); };
};
/**
 * @category interop
 * @since 2.9.0
 */
var chainNullableK = function (e) {
    var from = fromNullableK(e);
    return function (f) { return chain(from(f)); };
};
/**
 * @category interop
 * @since 2.10.0
 */
var toUnion = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (foldW(identity, identity)));
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * Default value for the `onError` argument of `tryCatch`
 *
 * @since 2.0.0
 */
function toError(e) {
    return e instanceof Error ? e : new Error(String(e));
}
function elem(E) {
    return function (a, ma) {
        if (ma === undefined) {
            var elemE_1 = elem(E);
            return function (ma) { return elemE_1(a, ma); };
        }
        return Either_isLeft(ma) ? false : E.equals(a, ma.right);
    };
}
/**
 * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.
 *
 * @example
 * import { exists, left, right } from 'fp-ts/Either'
 *
 * const gt2 = exists((n: number) => n > 2)
 *
 * assert.strictEqual(gt2(left('a')), false)
 * assert.strictEqual(gt2(right(1)), false)
 * assert.strictEqual(gt2(right(3)), true)
 *
 * @since 2.0.0
 */
var exists = function (predicate) { return function (ma) {
    return Either_isLeft(ma) ? false : predicate(ma.right);
}; };
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * @since 2.9.0
 */
var Do = 
/*#__PURE__*/
of(emptyRecord);
/**
 * @since 2.8.0
 */
var bindTo = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (bindTo_(Functor)));
/**
 * @since 2.8.0
 */
var bind = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (bind_(Chain)));
/**
 * @since 2.8.0
 */
var bindW = (/* unused pure expression or super */ null && (bind));
// -------------------------------------------------------------------------------------
// pipeable sequence S
// -------------------------------------------------------------------------------------
/**
 * @since 2.8.0
 */
var apS = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (apS_(Apply)));
/**
 * @since 2.8.0
 */
var apSW = (/* unused pure expression or super */ null && (apS));
// -------------------------------------------------------------------------------------
// sequence T
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */
var ApT = 
/*#__PURE__*/
of(emptyReadonlyArray);
// -------------------------------------------------------------------------------------
// array utils
// -------------------------------------------------------------------------------------
/**
 * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
 *
 * @since 2.11.0
 */
var traverseReadonlyNonEmptyArrayWithIndex = function (f) { return function (as) {
    var e = f(0, _.head(as));
    if (Either_isLeft(e)) {
        return e;
    }
    var out = [e.right];
    for (var i = 1; i < as.length; i++) {
        var e_1 = f(i, as[i]);
        if (Either_isLeft(e_1)) {
            return e_1;
        }
        out.push(e_1.right);
    }
    return Either_right(out);
}; };
/**
 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
 *
 * @since 2.11.0
 */
var traverseReadonlyArrayWithIndex = function (f) {
    var g = traverseReadonlyNonEmptyArrayWithIndex(f);
    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };
};
/**
 * @since 2.9.0
 */
var traverseArrayWithIndex = (/* unused pure expression or super */ null && (traverseReadonlyArrayWithIndex));
/**
 * @since 2.9.0
 */
var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };
/**
 * @since 2.9.0
 */
var sequenceArray = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (traverseArray(identity)));
/**
 * Use [`parse`](./Json.ts.html#parse) instead.
 *
 * @category constructors
 * @since 2.0.0
 * @deprecated
 */
function parseJSON(s, onError) {
    return tryCatch(function () { return JSON.parse(s); }, onError);
}
/**
 * Use [`stringify`](./Json.ts.html#stringify) instead.
 *
 * @category constructors
 * @since 2.0.0
 * @deprecated
 */
var stringifyJSON = function (u, onError) {
    return tryCatch(function () {
        var s = (__webpack_require__(8334)/* .stringify */ .P)(u);
        if (typeof s !== 'string') {
            throw new Error('Converting unsupported structure to JSON');
        }
        return s;
    }, onError);
};
/**
 * Use small, specific instances instead.
 *
 * @category instances
 * @since 2.0.0
 * @deprecated
 */
var either = {
    URI: URI,
    map: _map,
    of: of,
    ap: _ap,
    chain: _chain,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    bimap: _bimap,
    mapLeft: _mapLeft,
    alt: _alt,
    extend: _extend,
    chainRec: _chainRec,
    throwError: throwError
};
/**
 * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
 *
 * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values
 * are concatenated using the provided `Semigroup`
 *
 * @category instances
 * @since 2.0.0
 * @deprecated
 */
var getApplySemigroup = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (getApplySemigroup_(Apply)));
/**
 * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
 *
 * @category instances
 * @since 2.0.0
 * @deprecated
 */
var getApplyMonoid = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (getApplicativeMonoid(Applicative)));
/**
 * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
 *
 * @category instances
 * @since 2.0.0
 * @deprecated
 */
var getValidationSemigroup = function (SE, SA) {
    return getApplySemigroup_(getApplicativeValidation(SE))(SA);
};
/**
 * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
 *
 * @category instances
 * @since 2.0.0
 * @deprecated
 */
var getValidationMonoid = function (SE, MA) {
    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);
};
/**
 * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.
 *
 * @category instances
 * @since 2.0.0
 * @deprecated
 */
function getValidation(SE) {
    var ap = getApplicativeValidation(SE).ap;
    var alt = getAltValidation(SE).alt;
    return {
        URI: URI,
        _E: undefined,
        map: _map,
        of: of,
        chain: _chain,
        bimap: _bimap,
        mapLeft: _mapLeft,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        extend: _extend,
        traverse: _traverse,
        sequence: sequence,
        chainRec: _chainRec,
        throwError: throwError,
        ap: ap,
        alt: alt
    };
}

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function defineProperty_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// EXTERNAL MODULE: ./node_modules/core-js-pure/stable/promise/index.js
var stable_promise = __webpack_require__(2436);
var promise_default = /*#__PURE__*/__webpack_require__.n(stable_promise);
;// CONCATENATED MODULE: ./src/util/gmapi/index.ts


function gmapi_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? gmapi_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : gmapi_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



/* eslint-disable camelcase */

const gmapi_getValue = (name, def) => {
  var _GM;

  if ((_GM = GM) !== null && _GM !== void 0 && _GM.getValue) {
    return promise_default().resolve(GM.getValue(name, def));
  }

  if (GM_getValue) {
    return promise_default().resolve(GM_getValue(name, def));
  }

  return promise_default().resolve(def);
};
const setValue = (name, value) => {
  var _GM2;

  if ((_GM2 = GM) !== null && _GM2 !== void 0 && _GM2.setValue) {
    return promise_default().resolve(GM.setValue(name, value));
  }

  if (GM_setValue) {
    GM_setValue(name, value);
    return promise_default().resolve();
  }

  return promise_default().resolve();
};
class GMXMLError extends Error {
  constructor(m, res) {
    super(m);

    _defineProperty(this, "response", void 0);

    if (res) {
      this.response = res;
    }
  }

}
const got = params => {
  var _GM$xmlHttpRequest, _GM3;

  const api = (_GM$xmlHttpRequest = (_GM3 = GM) === null || _GM3 === void 0 ? void 0 : _GM3.xmlHttpRequest) !== null && _GM$xmlHttpRequest !== void 0 ? _GM$xmlHttpRequest : GM_xmlhttpRequest;

  if (!api) {
    throw new Error('not running in greasymonkey or tampermonkey enviroment');
  }

  return new (promise_default())(rs => {
    const option = _objectSpread({
      timeout: 10000,
      ontimeout: res => rs(Either_left({
        type: 'timeout',
        res
      })),
      onerror: res => rs(Either_left({
        type: 'error',
        res
      })),
      onload: res => {
        if (res.status < 200 || res.status >= 300) {
          rs(Either_left({
            type: 'statuscode',
            res
          }));
        }

        rs(Either_right(res));
      }
    }, params);

    api(option);
  });
};
const registerMenuCommand = (name, fn) => {
  if (GM_registerMenuCommand) {
    GM_registerMenuCommand(name, fn);
  }
};
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/googleTranslate/type_1_translate_281759.svg
/* harmony default export */ const type_1_translate_281759 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path d=\"M479 96H262.8l-22.5 87.1-8 57.2 43.3 120.9 7 146.6H479a33 33 0 0 0 32.9-33V129A33 33 0 0 0 479 96z\" fill=\"#e6e6e6\"/><path fill=\"#3a5bbc\" d=\"M368.7 416l-86.3 91.8L252 416l12.4-33.5z\"/><path d=\"M469.6 244.2v-20.9h-79.3v-29.2h-21v29.2H298v20.9h116a458.7 458.7 0 0 1-33 58c-14.2-17.6-23.1-30-23.2-30l-6.2-8.5-16.9 12.2 6.2 8.5c.4.6 10.8 15 27.3 35.3a800.7 800.7 0 0 1-42.6 47l14.7 14.7a861 861 0 0 0 41.4-45.3 836.8 836.8 0 0 0 47.9 52.5l7.4 7.4 14.7-14.8-7.4-7.4a828.1 828.1 0 0 1-49.6-54.8c22.1-31.8 36.5-62 42.2-74.8h32.8z\" fill=\"gray\"/><path d=\"M349.3 357.5l19.4 58.5H32.9A33 33 0 0 1 0 383V37.2a33 33 0 0 1 33-33h199.3L262.7 96l45.7 137.7 41 123.8z\" fill=\"#518ef8\"/><path d=\"M149.3 287.4A77.7 77.7 0 1 1 204.1 155l-14.7 14.7a56.8 56.8 0 1 0 15.6 50.5h-55.7v-20.8h77.6v10.4a77.7 77.7 0 0 1-77.6 77.6z\" fill=\"#fff\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/googleTranslate/type_3_google_814137.svg
/* harmony default export */ const type_3_google_814137 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path d=\"M256 0C114.8 0 0 114.8 0 256s114.8 256 256 256 256-114.8 256-256S397.2 0 256 0z\" fill=\"#303c42\"/><path d=\"M21.3 256A235 235 0 0 1 204.1 27.3l147.6 442.8a233 233 0 0 1-95.7 20.6A235 235 0 0 1 21.3 256z\" fill=\"#42a5f5\"/><g fill=\"#fff\"><path d=\"M392.5 192c-5 17-19.6 45-39.6 70.4a142.9 142.9 0 0 1-23-31.7c-2.2-5.5-8.5-8.1-14-6-5.4 2.3-8 8.5-5.8 14 4.3 10.5 15.6 25.1 28.6 40-6.9 7.2-14 14-21.8 19.7L281.5 192h111z\"/><path d=\"M371 460.4l-47.1-141.2 2.3-1.2c9.3-6.6 18.2-15 26.7-23.9a980.5 980.5 0 0 0 45.2 44.4 10.6 10.6 0 0 0 15.1-.6c4-4.4 3.7-11.1-.7-15.1a973 973 0 0 1-45.4-44.7c24.3-30 42.4-64.3 47.3-86.1h23a10.7 10.7 0 1 0 0-21.3h-74.7V160a10.7 10.7 0 1 0-21.4 0v10.7h-67l-49-147.1c10-1.3 20.3-2.3 30.7-2.3A235 235 0 0 1 490.7 256c0 87.6-48.4 164-119.8 204.4zM245.3 245.3h-74.6a10.7 10.7 0 1 0 0 21.4h63a64.1 64.1 0 0 1-127-10.7 64 64 0 0 1 105.5-48.6 10.7 10.7 0 1 0 14-16.3A85.4 85.4 0 1 0 256 256c0-5.9-4.8-10.7-10.7-10.7z\"/></g><path d=\"M53.5 374A234.6 234.6 0 0 0 256 490.7c34 0 66.4-7.5 95.7-20.6l-21.4-64.3A233 233 0 0 1 53.5 374zM415.9 84.7c16 27.4 26.7 58.3 30.5 91.3 1 1.6 1.6 3.3 1.6 5.3 0 1.5-.3 3-.9 4.2.4 5.7.9 11.4.9 17.2 0 44.5-12.7 86-34.4 121.6a10.5 10.5 0 0 1-8.3 17c-.9 0-1.8-.2-2.7-.5a236.3 236.3 0 0 1-53.8 53.2l22.1 66.4a233.8 233.8 0 0 0 45-375.7z\" opacity=\".1\"/><linearGradient id=\"a\" gradientUnits=\"userSpaceOnUse\" x1=\"-45.6\" y1=\"639.6\" x2=\"-23.8\" y2=\"629.4\" gradientTransform=\"matrix(21.3333 0 0 -21.3333 996.3 13791.7)\"><stop offset=\"0\" stop-color=\"#fff\" stop-opacity=\".2\"/><stop offset=\"1\" stop-color=\"#fff\" stop-opacity=\"0\"/></linearGradient><path d=\"M256 0C114.8 0 0 114.8 0 256s114.8 256 256 256 256-114.8 256-256S397.2 0 256 0z\" fill=\"url(#a)\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/translate_2406387.svg
/* harmony default export */ const translate_2406387 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path d=\"M56.6 73.2c-14 17.1-22.8 37.9-25.4 59.9-9.5 81.7-9.5 164.2 0 245.8 6.3 53.5 48.4 95.6 101.9 101.9 81.7 9.5 164.2 9.5 245.8 0 22-2.6 42.8-11.4 59.9-25.4L56.6 73.2z\" fill=\"#518ef8\"/><path d=\"M438 458.5c14-17.1 39.9-57.7 42.4-79.7 9.5-81.7 9.5-164.2 0-245.8-6.3-53.5-48.4-95.6-101.9-101.9-81.7-9.5-164.2-9.5-245.8 0-22 2.5-59.1 29.9-76.2 43.9L438 458.5z\" fill=\"#fff\"/><path d=\"M133.3 388H213l12.2 24.3 28.6-14.3-66.3-132.6h-28.6L92.5 398l28.6 14.3 12.2-24.3zm39.8-79.7L197 356h-47.7l23.8-47.7zm166.3-218v17.1h-50.3v32h9.2l36 42-40.7 47.6 24.3 20.8 37.6-43.8 37.6 43.8 24.3-20.8-40.8-47.6 36-42h9.2v-32h-50.3V90.3h-32.1zm16 66.5l-14.9-17.4h29.8l-14.9 17.4z\"/><path d=\"M496.8 131.2c-6.9-61-55-109.1-116-116-82.9-9.7-166.7-9.7-249.6 0-17.2 2-33.8 7.4-48.9 15.8l23.9 23.9c9.1-4 18.8-6.7 28.7-7.8 80.4-9.4 161.7-9.4 242.2 0 46.2 5.2 82.6 41.7 87.9 87.9 9.4 80.4 9.4 161.7 0 242.2-2.4 20.9-11.5 40.6-25.8 56L67.9 61.8c-6.2-6.2-16.4-6.2-22.6 0-.4.4-.7.8-1.1 1.2-16 19.5-26 43.1-29 68.2-9.7 82.9-9.7 166.7 0 249.6 6.9 61 55 109.1 116 116 82.9 9.7 166.7 9.7 249.6 0 60.8-7.2 108.8-55.2 116-116 9.7-82.9 9.7-166.7 0-249.6zM377.1 465c-80.4 9.4-161.7 9.4-242.2 0-46.2-5.2-82.6-41.7-87.9-87.9-9.4-80.4-9.4-161.7 0-242.2 1.5-12.9 5.5-25.4 11.9-36.8l355 355c-11.4 6.3-23.9 10.4-36.8 11.9z\"/></svg>");
;// CONCATENATED MODULE: ./src/assets/img/magnify_929469.svg
/* harmony default export */ const magnify_929469 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path d=\"M295.3 361.5L432 498.3c18.3 18.3 47.9 18.3 66.2 0 18.3-18.3 18.3-47.9 0-66.2L361.5 295.3l-66.2 66.2z\" fill=\"#5a5a5a\"/><path d=\"M295.3 361.5l33.1-33.1 169.8 169.8c-18.3 18.3-47.9 18.3-66.2 0L295.3 361.5z\" fill=\"#444\"/><path d=\"M218.5 0c-60 0-115 24.5-154.5 64S0 158.5 0 218.5C0 339 98 437 218.5 437c60 0 115-24.5 154.5-64s64-94.5 64-154.5C437.1 98 339.1 0 218.5 0z\" fill=\"#00abe9\"/><path d=\"M64 64l309.1 309.1c-39.5 39.5-94.5 64-154.5 64C98 437.1 0 339.1 0 218.5c0-60 24.5-115 64-154.5z\" fill=\"#0095ff\"/><path d=\"M218.8 62.5c-43-.2-82.1 17.7-110.4 45.9-28.3 28.3-45.9 67.1-45.7 110.2-.2 85.9 70 156.1 156.1 156.1 42.8 0 81.9-17.4 110.2-45.7 28.3-28.3 45.9-67.6 45.9-110.4-.1-86.1-70.3-156.3-156.1-156.1z\" fill=\"#e7e7e7\"/><path d=\"M108.4 108.4l220.5 220.5c-28.3 28.3-67.3 45.7-110.2 45.7-86.1 0-156.3-70.2-156.1-156.1-.1-43 17.5-81.9 45.8-110.1z\" fill=\"#d3d3d8\"/></svg>");
;// CONCATENATED MODULE: ./src/constants/index.ts




var ICIBA_CIRCLE_ICON;

(function (ICIBA_CIRCLE_ICON) {
  ICIBA_CIRCLE_ICON["DEFAULT"] = "default";
  ICIBA_CIRCLE_ICON["GOOGLE_TRANSLATE_SQUARE"] = "gtsquare";
  ICIBA_CIRCLE_ICON["GOOGLE_TRANSLATE_CIRCLE"] = "gtcircle";
  ICIBA_CIRCLE_ICON["GOOGLE_TRANSLATE_TEXT"] = "gttext";
  ICIBA_CIRCLE_ICON["MAG_ICON"] = "icondic";
})(ICIBA_CIRCLE_ICON || (ICIBA_CIRCLE_ICON = {}));

const ICIBA_CIRCLE_ICON_MAP = {
  [ICIBA_CIRCLE_ICON.DEFAULT]: '',
  [ICIBA_CIRCLE_ICON.GOOGLE_TRANSLATE_SQUARE]: type_1_translate_281759,
  [ICIBA_CIRCLE_ICON.GOOGLE_TRANSLATE_CIRCLE]: type_3_google_814137,
  [ICIBA_CIRCLE_ICON.GOOGLE_TRANSLATE_TEXT]: translate_2406387,
  [ICIBA_CIRCLE_ICON.MAG_ICON]: magnify_929469
};
const ICIBA_CIRCLE_ICON_TYPE_MAP = {
  [ICIBA_CIRCLE_ICON.DEFAULT]: 'circle',
  [ICIBA_CIRCLE_ICON.GOOGLE_TRANSLATE_SQUARE]: 'square',
  [ICIBA_CIRCLE_ICON.GOOGLE_TRANSLATE_CIRCLE]: 'circle',
  [ICIBA_CIRCLE_ICON.GOOGLE_TRANSLATE_TEXT]: 'square',
  [ICIBA_CIRCLE_ICON.MAG_ICON]: 'square'
};
var GM_STORE_KEY;

(function (GM_STORE_KEY) {
  GM_STORE_KEY["STORE"] = "iciba_store";
  GM_STORE_KEY["SOUGOU_SECCODE"] = "sougou_seccode";
  GM_STORE_KEY["HISTORY"] = "history";
})(GM_STORE_KEY || (GM_STORE_KEY = {}));
;// CONCATENATED MODULE: ./node_modules/io-ts/es6/index.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
/**
 * @since 1.0.0
 */

/**
 * @category Decode error
 * @since 1.0.0
 */
var failures = Either_left;
/**
 * @category Decode error
 * @since 1.0.0
 */
var failure = function (value, context, message) {
    return failures([{ value: value, context: context, message: message }]);
};
/**
 * @category Decode error
 * @since 1.0.0
 */
var success = Either_right;
/**
 * @category Codec
 * @since 1.0.0
 */
var Type = /** @class */ (function () {
    function Type(
    /** a unique name for this codec */
    name, 
    /** a custom type guard */
    is, 
    /** succeeds if a value of type I can be decoded to a value of type A */
    validate, 
    /** converts a value of type A to a value of type O */
    encode) {
        this.name = name;
        this.is = is;
        this.validate = validate;
        this.encode = encode;
        this.decode = this.decode.bind(this);
    }
    /**
     * @since 1.0.0
     */
    Type.prototype.pipe = function (ab, name) {
        var _this = this;
        if (name === void 0) { name = "pipe(" + this.name + ", " + ab.name + ")"; }
        return new Type(name, ab.is, function (i, c) {
            var e = _this.validate(i, c);
            if (Either_isLeft(e)) {
                return e;
            }
            return ab.validate(e.right, c);
        }, this.encode === es6_identity && ab.encode === es6_identity ? es6_identity : function (b) { return _this.encode(ab.encode(b)); });
    };
    /**
     * @since 1.0.0
     */
    Type.prototype.asDecoder = function () {
        return this;
    };
    /**
     * @since 1.0.0
     */
    Type.prototype.asEncoder = function () {
        return this;
    };
    /**
     * a version of `validate` with a default context
     * @since 1.0.0
     */
    Type.prototype.decode = function (i) {
        return this.validate(i, [{ key: '', type: this, actual: i }]);
    };
    return Type;
}());

// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 1.0.0
 */
var es6_identity = function (a) { return a; };
/**
 * @since 1.0.0
 */
function getFunctionName(f) {
    return f.displayName || f.name || "<function" + f.length + ">";
}
/**
 * @since 1.0.0
 */
function getContextEntry(key, decoder) {
    return { key: key, type: decoder };
}
/**
 * @since 1.0.0
 */
function appendContext(c, key, decoder, actual) {
    var len = c.length;
    var r = Array(len + 1);
    for (var i = 0; i < len; i++) {
        r[i] = c[i];
    }
    r[len] = { key: key, type: decoder, actual: actual };
    return r;
}
function pushAll(xs, ys) {
    var l = ys.length;
    for (var i = 0; i < l; i++) {
        xs.push(ys[i]);
    }
}
var es6_hasOwnProperty = Object.prototype.hasOwnProperty;
function getNameFromProps(props) {
    return Object.keys(props)
        .map(function (k) { return k + ": " + props[k].name; })
        .join(', ');
}
function useIdentity(codecs) {
    for (var i = 0; i < codecs.length; i++) {
        if (codecs[i].encode !== es6_identity) {
            return false;
        }
    }
    return true;
}
function getInterfaceTypeName(props) {
    return "{ " + getNameFromProps(props) + " }";
}
function getPartialTypeName(inner) {
    return "Partial<" + inner + ">";
}
function enumerableRecord(keys, domain, codomain, name) {
    if (name === void 0) { name = "{ [K in " + domain.name + "]: " + codomain.name + " }"; }
    var len = keys.length;
    return new DictionaryType(name, function (u) { return UnknownRecord.is(u) && keys.every(function (k) { return codomain.is(u[k]); }); }, function (u, c) {
        var e = UnknownRecord.validate(u, c);
        if (isLeft(e)) {
            return e;
        }
        var o = e.right;
        var a = {};
        var errors = [];
        var changed = false;
        for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ok = o[k];
            var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
            if (isLeft(codomainResult)) {
                pushAll(errors, codomainResult.left);
            }
            else {
                var vok = codomainResult.right;
                changed = changed || vok !== ok;
                a[k] = vok;
            }
        }
        return errors.length > 0 ? failures(errors) : success((changed || Object.keys(o).length !== len ? a : o));
    }, codomain.encode === es6_identity
        ? es6_identity
        : function (a) {
            var s = {};
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                s[k] = codomain.encode(a[k]);
            }
            return s;
        }, domain, codomain);
}
/**
 * @internal
 */
function getDomainKeys(domain) {
    var _a;
    if (isLiteralC(domain)) {
        var literal_1 = domain.value;
        if (string.is(literal_1)) {
            return _a = {}, _a[literal_1] = null, _a;
        }
    }
    else if (isKeyofC(domain)) {
        return domain.keys;
    }
    else if (isUnionC(domain)) {
        var keys = domain.types.map(function (type) { return getDomainKeys(type); });
        return keys.some(undefinedType.is) ? undefined : Object.assign.apply(Object, __spreadArrays([{}], keys));
    }
    return undefined;
}
function nonEnumerableRecord(domain, codomain, name) {
    if (name === void 0) { name = "{ [K in " + domain.name + "]: " + codomain.name + " }"; }
    return new DictionaryType(name, function (u) {
        if (UnknownRecord.is(u)) {
            return Object.keys(u).every(function (k) { return domain.is(k) && codomain.is(u[k]); });
        }
        return isAnyC(codomain) && Array.isArray(u);
    }, function (u, c) {
        if (UnknownRecord.is(u)) {
            var a = {};
            var errors = [];
            var keys = Object.keys(u);
            var len = keys.length;
            var changed = false;
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                var ok = u[k];
                var domainResult = domain.validate(k, appendContext(c, k, domain, k));
                if (isLeft(domainResult)) {
                    pushAll(errors, domainResult.left);
                }
                else {
                    var vk = domainResult.right;
                    changed = changed || vk !== k;
                    k = vk;
                    var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
                    if (isLeft(codomainResult)) {
                        pushAll(errors, codomainResult.left);
                    }
                    else {
                        var vok = codomainResult.right;
                        changed = changed || vok !== ok;
                        a[k] = vok;
                    }
                }
            }
            return errors.length > 0 ? failures(errors) : success((changed ? a : u));
        }
        if (isAnyC(codomain) && Array.isArray(u)) {
            return success(u);
        }
        return failure(u, c);
    }, domain.encode === es6_identity && codomain.encode === es6_identity
        ? es6_identity
        : function (a) {
            var s = {};
            var keys = Object.keys(a);
            var len = keys.length;
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                s[String(domain.encode(k))] = codomain.encode(a[k]);
            }
            return s;
        }, domain, codomain);
}
function getUnionName(codecs) {
    return '(' + codecs.map(function (type) { return type.name; }).join(' | ') + ')';
}
/**
 * @internal
 */
function mergeAll(base, us) {
    var equal = true;
    var primitive = true;
    var baseIsNotADictionary = !UnknownRecord.is(base);
    for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {
        var u = us_1[_i];
        if (u !== base) {
            equal = false;
        }
        if (UnknownRecord.is(u)) {
            primitive = false;
        }
    }
    if (equal) {
        return base;
    }
    else if (primitive) {
        return us[us.length - 1];
    }
    var r = {};
    for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {
        var u = us_2[_a];
        for (var k in u) {
            if (!r.hasOwnProperty(k) || baseIsNotADictionary || u[k] !== base[k]) {
                r[k] = u[k];
            }
        }
    }
    return r;
}
function getProps(codec) {
    switch (codec._tag) {
        case 'RefinementType':
        case 'ReadonlyType':
            return getProps(codec.type);
        case 'InterfaceType':
        case 'StrictType':
        case 'PartialType':
            return codec.props;
        case 'IntersectionType':
            return codec.types.reduce(function (props, type) { return Object.assign(props, getProps(type)); }, {});
    }
}
function stripKeys(o, props) {
    var keys = Object.getOwnPropertyNames(o);
    var shouldStrip = false;
    var r = {};
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!es6_hasOwnProperty.call(props, key)) {
            shouldStrip = true;
        }
        else {
            r[key] = o[key];
        }
    }
    return shouldStrip ? r : o;
}
function getExactTypeName(codec) {
    if (isTypeC(codec)) {
        return "{| " + getNameFromProps(codec.props) + " |}";
    }
    else if (isPartialC(codec)) {
        return getPartialTypeName("{| " + getNameFromProps(codec.props) + " |}");
    }
    return "Exact<" + codec.name + ">";
}
function es6_isNonEmpty(as) {
    return as.length > 0;
}
/**
 * @internal
 */
var emptyTags = {};
function intersect(a, b) {
    var r = [];
    for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
        var v = a_1[_i];
        if (b.indexOf(v) !== -1) {
            r.push(v);
        }
    }
    return r;
}
function mergeTags(a, b) {
    if (a === emptyTags) {
        return b;
    }
    if (b === emptyTags) {
        return a;
    }
    var r = Object.assign({}, a);
    for (var k in b) {
        if (a.hasOwnProperty(k)) {
            var intersection_1 = intersect(a[k], b[k]);
            if (es6_isNonEmpty(intersection_1)) {
                r[k] = intersection_1;
            }
            else {
                r = emptyTags;
                break;
            }
        }
        else {
            r[k] = b[k];
        }
    }
    return r;
}
function intersectTags(a, b) {
    if (a === emptyTags || b === emptyTags) {
        return emptyTags;
    }
    var r = emptyTags;
    for (var k in a) {
        if (b.hasOwnProperty(k)) {
            var intersection_2 = intersect(a[k], b[k]);
            if (intersection_2.length === 0) {
                if (r === emptyTags) {
                    r = {};
                }
                r[k] = a[k].concat(b[k]);
            }
        }
    }
    return r;
}
// tslint:disable-next-line: deprecation
function isAnyC(codec) {
    return codec._tag === 'AnyType';
}
function isLiteralC(codec) {
    return codec._tag === 'LiteralType';
}
function isKeyofC(codec) {
    return codec._tag === 'KeyofType';
}
function isTypeC(codec) {
    return codec._tag === 'InterfaceType';
}
function isPartialC(codec) {
    return codec._tag === 'PartialType';
}
// tslint:disable-next-line: deprecation
function isStrictC(codec) {
    return codec._tag === 'StrictType';
}
function isExactC(codec) {
    return codec._tag === 'ExactType';
}
// tslint:disable-next-line: deprecation
function isRefinementC(codec) {
    return codec._tag === 'RefinementType';
}
function isIntersectionC(codec) {
    return codec._tag === 'IntersectionType';
}
function isUnionC(codec) {
    return codec._tag === 'UnionType';
}
function isRecursiveC(codec) {
    return codec._tag === 'RecursiveType';
}
var lazyCodecs = (/* unused pure expression or super */ null && ([]));
/**
 * @internal
 */
function getTags(codec) {
    if (lazyCodecs.indexOf(codec) !== -1) {
        return emptyTags;
    }
    if (isTypeC(codec) || isStrictC(codec)) {
        var index = emptyTags;
        // tslint:disable-next-line: forin
        for (var k in codec.props) {
            var prop = codec.props[k];
            if (isLiteralC(prop)) {
                if (index === emptyTags) {
                    index = {};
                }
                index[k] = [prop.value];
            }
        }
        return index;
    }
    else if (isExactC(codec) || isRefinementC(codec)) {
        return getTags(codec.type);
    }
    else if (isIntersectionC(codec)) {
        return codec.types.reduce(function (tags, codec) { return mergeTags(tags, getTags(codec)); }, emptyTags);
    }
    else if (isUnionC(codec)) {
        return codec.types.slice(1).reduce(function (tags, codec) { return intersectTags(tags, getTags(codec)); }, getTags(codec.types[0]));
    }
    else if (isRecursiveC(codec)) {
        lazyCodecs.push(codec);
        var tags = getTags(codec.type);
        lazyCodecs.pop();
        return tags;
    }
    return emptyTags;
}
/**
 * @internal
 */
function getIndex(codecs) {
    var tags = getTags(codecs[0]);
    var keys = Object.keys(tags);
    var len = codecs.length;
    var _loop_1 = function (k) {
        var all = tags[k].slice();
        var index = [tags[k]];
        for (var i = 1; i < len; i++) {
            var codec = codecs[i];
            var ctags = getTags(codec);
            var values = ctags[k];
            // tslint:disable-next-line: strict-type-predicates
            if (values === undefined) {
                return "continue-keys";
            }
            else {
                if (values.some(function (v) { return all.indexOf(v) !== -1; })) {
                    return "continue-keys";
                }
                else {
                    all.push.apply(all, values);
                    index.push(values);
                }
            }
        }
        return { value: [k, index] };
    };
    keys: for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var k = keys_1[_i];
        var state_1 = _loop_1(k);
        if (typeof state_1 === "object")
            return state_1.value;
        switch (state_1) {
            case "continue-keys": continue keys;
        }
    }
    return undefined;
}
// -------------------------------------------------------------------------------------
// primitives
// -------------------------------------------------------------------------------------
/**
 * @since 1.0.0
 */
var NullType = /** @class */ (function (_super) {
    __extends(NullType, _super);
    function NullType() {
        var _this = _super.call(this, 'null', function (u) { return u === null; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'NullType';
        return _this;
    }
    return NullType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 */
var nullType = new NullType();
/**
 * @since 1.0.0
 */
var UndefinedType = /** @class */ (function (_super) {
    __extends(UndefinedType, _super);
    function UndefinedType() {
        var _this = _super.call(this, 'undefined', function (u) { return u === void 0; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'UndefinedType';
        return _this;
    }
    return UndefinedType;
}(Type));

var undefinedType = new UndefinedType();
/**
 * @since 1.2.0
 */
var VoidType = /** @class */ (function (_super) {
    __extends(VoidType, _super);
    function VoidType() {
        var _this = _super.call(this, 'void', undefinedType.is, undefinedType.validate, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'VoidType';
        return _this;
    }
    return VoidType;
}(Type));

/**
 * @category primitives
 * @since 1.2.0
 */
var voidType = new VoidType();
/**
 * @since 1.5.0
 */
var UnknownType = /** @class */ (function (_super) {
    __extends(UnknownType, _super);
    function UnknownType() {
        var _this = _super.call(this, 'unknown', function (_) { return true; }, success, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'UnknownType';
        return _this;
    }
    return UnknownType;
}(Type));

/**
 * @category primitives
 * @since 1.5.0
 */
var unknown = new UnknownType();
/**
 * @since 1.0.0
 */
var StringType = /** @class */ (function (_super) {
    __extends(StringType, _super);
    function StringType() {
        var _this = _super.call(this, 'string', function (u) { return typeof u === 'string'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'StringType';
        return _this;
    }
    return StringType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 */
var string = new StringType();
/**
 * @since 1.0.0
 */
var NumberType = /** @class */ (function (_super) {
    __extends(NumberType, _super);
    function NumberType() {
        var _this = _super.call(this, 'number', function (u) { return typeof u === 'number'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'NumberType';
        return _this;
    }
    return NumberType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 */
var number = new NumberType();
/**
 * @since 2.1.0
 */
var BigIntType = /** @class */ (function (_super) {
    __extends(BigIntType, _super);
    function BigIntType() {
        var _this = _super.call(this, 'bigint', 
        // tslint:disable-next-line: valid-typeof
        function (u) { return typeof u === 'bigint'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'BigIntType';
        return _this;
    }
    return BigIntType;
}(Type));

/**
 * @category primitives
 * @since 2.1.0
 */
var bigint = new BigIntType();
/**
 * @since 1.0.0
 */
var BooleanType = /** @class */ (function (_super) {
    __extends(BooleanType, _super);
    function BooleanType() {
        var _this = _super.call(this, 'boolean', function (u) { return typeof u === 'boolean'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'BooleanType';
        return _this;
    }
    return BooleanType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 */
var es6_boolean = new BooleanType();
/**
 * @since 1.0.0
 */
var AnyArrayType = /** @class */ (function (_super) {
    __extends(AnyArrayType, _super);
    function AnyArrayType() {
        var _this = _super.call(this, 'UnknownArray', Array.isArray, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'AnyArrayType';
        return _this;
    }
    return AnyArrayType;
}(Type));

/**
 * @category primitives
 * @since 1.7.1
 */
var UnknownArray = new AnyArrayType();
/**
 * @since 1.0.0
 */
var AnyDictionaryType = /** @class */ (function (_super) {
    __extends(AnyDictionaryType, _super);
    function AnyDictionaryType() {
        var _this = _super.call(this, 'UnknownRecord', function (u) {
            var s = Object.prototype.toString.call(u);
            return s === '[object Object]' || s === '[object Window]';
        }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'AnyDictionaryType';
        return _this;
    }
    return AnyDictionaryType;
}(Type));

/**
 * @category primitives
 * @since 1.7.1
 */
var UnknownRecord = new AnyDictionaryType();

/**
 * @since 1.0.0
 */
var LiteralType = /** @class */ (function (_super) {
    __extends(LiteralType, _super);
    function LiteralType(name, is, validate, encode, value) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.value = value;
        /**
         * @since 1.0.0
         */
        _this._tag = 'LiteralType';
        return _this;
    }
    return LiteralType;
}(Type));

/**
 * @category constructors
 * @since 1.0.0
 */
function literal(value, name) {
    if (name === void 0) { name = (__webpack_require__(8334)/* .stringify */ .P)(value); }
    var is = function (u) { return u === value; };
    return new LiteralType(name, is, function (u, c) { return (is(u) ? success(value) : failure(u, c)); }, es6_identity, value);
}
/**
 * @since 1.0.0
 */
var KeyofType = /** @class */ (function (_super) {
    __extends(KeyofType, _super);
    function KeyofType(name, is, validate, encode, keys) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.keys = keys;
        /**
         * @since 1.0.0
         */
        _this._tag = 'KeyofType';
        return _this;
    }
    return KeyofType;
}(Type));

/**
 * @category constructors
 * @since 1.0.0
 */
function keyof(keys, name) {
    if (name === void 0) { name = Object.keys(keys)
        .map(function (k) { return JSON.stringify(k); })
        .join(' | '); }
    var is = function (u) { return string.is(u) && es6_hasOwnProperty.call(keys, u); };
    return new KeyofType(name, is, function (u, c) { return (is(u) ? success(u) : failure(u, c)); }, es6_identity, keys);
}
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @since 1.0.0
 */
var RefinementType = /** @class */ (function (_super) {
    __extends(RefinementType, _super);
    function RefinementType(name, is, validate, encode, type, predicate) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type;
        _this.predicate = predicate;
        /**
         * @since 1.0.0
         */
        _this._tag = 'RefinementType';
        return _this;
    }
    return RefinementType;
}(Type));

/**
 * @category combinators
 * @since 1.8.1
 */
function brand(codec, predicate, name) {
    // tslint:disable-next-line: deprecation
    return refinement(codec, predicate, name);
}
/**
 * A branded codec representing an integer
 *
 * @category primitives
 * @since 1.8.1
 */
var Int = brand(number, function (n) { return Number.isInteger(n); }, 'Int');
/**
 * @since 1.0.0
 */
var RecursiveType = /** @class */ (function (_super) {
    __extends(RecursiveType, _super);
    function RecursiveType(name, is, validate, encode, runDefinition) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.runDefinition = runDefinition;
        /**
         * @since 1.0.0
         */
        _this._tag = 'RecursiveType';
        return _this;
    }
    return RecursiveType;
}(Type));

Object.defineProperty(RecursiveType.prototype, 'type', {
    get: function () {
        return this.runDefinition();
    },
    enumerable: true,
    configurable: true
});
/**
 * @category combinators
 * @since 1.0.0
 */
function recursion(name, definition) {
    var cache;
    var runDefinition = function () {
        if (!cache) {
            cache = definition(Self);
            cache.name = name;
        }
        return cache;
    };
    var Self = new RecursiveType(name, function (u) { return runDefinition().is(u); }, function (u, c) { return runDefinition().validate(u, c); }, function (a) { return runDefinition().encode(a); }, runDefinition);
    return Self;
}
/**
 * @since 1.0.0
 */
var ArrayType = /** @class */ (function (_super) {
    __extends(ArrayType, _super);
    function ArrayType(name, is, validate, encode, type) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type;
        /**
         * @since 1.0.0
         */
        _this._tag = 'ArrayType';
        return _this;
    }
    return ArrayType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function array(item, name) {
    if (name === void 0) { name = "Array<" + item.name + ">"; }
    return new ArrayType(name, function (u) { return UnknownArray.is(u) && u.every(item.is); }, function (u, c) {
        var e = UnknownArray.validate(u, c);
        if (Either_isLeft(e)) {
            return e;
        }
        var us = e.right;
        var len = us.length;
        var as = us;
        var errors = [];
        for (var i = 0; i < len; i++) {
            var ui = us[i];
            var result = item.validate(ui, appendContext(c, String(i), item, ui));
            if (Either_isLeft(result)) {
                pushAll(errors, result.left);
            }
            else {
                var ai = result.right;
                if (ai !== ui) {
                    if (as === us) {
                        as = us.slice();
                    }
                    as[i] = ai;
                }
            }
        }
        return errors.length > 0 ? failures(errors) : success(as);
    }, item.encode === es6_identity ? es6_identity : function (a) { return a.map(item.encode); }, item);
}
/**
 * @since 1.0.0
 */
var InterfaceType = /** @class */ (function (_super) {
    __extends(InterfaceType, _super);
    function InterfaceType(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        /**
         * @since 1.0.0
         */
        _this._tag = 'InterfaceType';
        return _this;
    }
    return InterfaceType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function type(props, name) {
    if (name === void 0) { name = getInterfaceTypeName(props); }
    var keys = Object.keys(props);
    var types = keys.map(function (key) { return props[key]; });
    var len = keys.length;
    return new InterfaceType(name, function (u) {
        if (UnknownRecord.is(u)) {
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                var uk = u[k];
                if ((uk === undefined && !es6_hasOwnProperty.call(u, k)) || !types[i].is(uk)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }, function (u, c) {
        var e = UnknownRecord.validate(u, c);
        if (Either_isLeft(e)) {
            return e;
        }
        var o = e.right;
        var a = o;
        var errors = [];
        for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ak = a[k];
            var type_1 = types[i];
            var result = type_1.validate(ak, appendContext(c, k, type_1, ak));
            if (Either_isLeft(result)) {
                pushAll(errors, result.left);
            }
            else {
                var vak = result.right;
                if (vak !== ak || (vak === undefined && !es6_hasOwnProperty.call(a, k))) {
                    /* istanbul ignore next */
                    if (a === o) {
                        a = __assign({}, o);
                    }
                    a[k] = vak;
                }
            }
        }
        return errors.length > 0 ? failures(errors) : success(a);
    }, useIdentity(types)
        ? es6_identity
        : function (a) {
            var s = __assign({}, a);
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                var encode = types[i].encode;
                if (encode !== es6_identity) {
                    s[k] = encode(a[k]);
                }
            }
            return s;
        }, props);
}
/**
 * @since 1.0.0
 */
var PartialType = /** @class */ (function (_super) {
    __extends(PartialType, _super);
    function PartialType(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        /**
         * @since 1.0.0
         */
        _this._tag = 'PartialType';
        return _this;
    }
    return PartialType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function partial(props, name) {
    if (name === void 0) { name = getPartialTypeName(getInterfaceTypeName(props)); }
    var keys = Object.keys(props);
    var types = keys.map(function (key) { return props[key]; });
    var len = keys.length;
    return new PartialType(name, function (u) {
        if (UnknownRecord.is(u)) {
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                var uk = u[k];
                if (uk !== undefined && !props[k].is(uk)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }, function (u, c) {
        var e = UnknownRecord.validate(u, c);
        if (isLeft(e)) {
            return e;
        }
        var o = e.right;
        var a = o;
        var errors = [];
        for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ak = a[k];
            var type_2 = props[k];
            var result = type_2.validate(ak, appendContext(c, k, type_2, ak));
            if (isLeft(result)) {
                if (ak !== undefined) {
                    pushAll(errors, result.left);
                }
            }
            else {
                var vak = result.right;
                if (vak !== ak) {
                    /* istanbul ignore next */
                    if (a === o) {
                        a = __assign({}, o);
                    }
                    a[k] = vak;
                }
            }
        }
        return errors.length > 0 ? failures(errors) : success(a);
    }, useIdentity(types)
        ? es6_identity
        : function (a) {
            var s = __assign({}, a);
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                var ak = a[k];
                if (ak !== undefined) {
                    s[k] = types[i].encode(ak);
                }
            }
            return s;
        }, props);
}
/**
 * @since 1.0.0
 */
var DictionaryType = /** @class */ (function (_super) {
    __extends(DictionaryType, _super);
    function DictionaryType(name, is, validate, encode, domain, codomain) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.domain = domain;
        _this.codomain = codomain;
        /**
         * @since 1.0.0
         */
        _this._tag = 'DictionaryType';
        return _this;
    }
    return DictionaryType;
}(Type));

/**
 * @category combinators
 * @since 1.7.1
 */
function record(domain, codomain, name) {
    var keys = getDomainKeys(domain);
    return keys
        ? enumerableRecord(Object.keys(keys), domain, codomain, name)
        : nonEnumerableRecord(domain, codomain, name);
}
/**
 * @since 1.0.0
 */
var UnionType = /** @class */ (function (_super) {
    __extends(UnionType, _super);
    function UnionType(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        /**
         * @since 1.0.0
         */
        _this._tag = 'UnionType';
        return _this;
    }
    return UnionType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function union(codecs, name) {
    if (name === void 0) { name = getUnionName(codecs); }
    var index = getIndex(codecs);
    if (index !== undefined && codecs.length > 0) {
        var tag_1 = index[0], groups_1 = index[1];
        var len_1 = groups_1.length;
        var find_1 = function (value) {
            for (var i = 0; i < len_1; i++) {
                if (groups_1[i].indexOf(value) !== -1) {
                    return i;
                }
            }
            return undefined;
        };
        // tslint:disable-next-line: deprecation
        return new TaggedUnionType(name, function (u) {
            if (UnknownRecord.is(u)) {
                var i = find_1(u[tag_1]);
                return i !== undefined ? codecs[i].is(u) : false;
            }
            return false;
        }, function (u, c) {
            var e = UnknownRecord.validate(u, c);
            if (isLeft(e)) {
                return e;
            }
            var r = e.right;
            var i = find_1(r[tag_1]);
            if (i === undefined) {
                return failure(u, c);
            }
            var codec = codecs[i];
            return codec.validate(r, appendContext(c, String(i), codec, r));
        }, useIdentity(codecs)
            ? es6_identity
            : function (a) {
                var i = find_1(a[tag_1]);
                if (i === undefined) {
                    // https://github.com/gcanti/io-ts/pull/305
                    throw new Error("no codec found to encode value in union codec " + name);
                }
                else {
                    return codecs[i].encode(a);
                }
            }, codecs, tag_1);
    }
    else {
        return new UnionType(name, function (u) { return codecs.some(function (type) { return type.is(u); }); }, function (u, c) {
            var errors = [];
            for (var i = 0; i < codecs.length; i++) {
                var codec = codecs[i];
                var result = codec.validate(u, appendContext(c, String(i), codec, u));
                if (isLeft(result)) {
                    pushAll(errors, result.left);
                }
                else {
                    return success(result.right);
                }
            }
            return failures(errors);
        }, useIdentity(codecs)
            ? es6_identity
            : function (a) {
                for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {
                    var codec = codecs_1[_i];
                    if (codec.is(a)) {
                        return codec.encode(a);
                    }
                }
                // https://github.com/gcanti/io-ts/pull/305
                throw new Error("no codec found to encode value in union type " + name);
            }, codecs);
    }
}
/**
 * @since 1.0.0
 */
var IntersectionType = /** @class */ (function (_super) {
    __extends(IntersectionType, _super);
    function IntersectionType(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        /**
         * @since 1.0.0
         */
        _this._tag = 'IntersectionType';
        return _this;
    }
    return IntersectionType;
}(Type));

function intersection(codecs, name) {
    if (name === void 0) { name = "(" + codecs.map(function (type) { return type.name; }).join(' & ') + ")"; }
    var len = codecs.length;
    return new IntersectionType(name, function (u) { return codecs.every(function (type) { return type.is(u); }); }, codecs.length === 0
        ? success
        : function (u, c) {
            var us = [];
            var errors = [];
            for (var i = 0; i < len; i++) {
                var codec = codecs[i];
                var result = codec.validate(u, appendContext(c, String(i), codec, u));
                if (isLeft(result)) {
                    pushAll(errors, result.left);
                }
                else {
                    us.push(result.right);
                }
            }
            return errors.length > 0 ? failures(errors) : success(mergeAll(u, us));
        }, codecs.length === 0
        ? es6_identity
        : function (a) {
            return mergeAll(a, codecs.map(function (codec) { return codec.encode(a); }));
        }, codecs);
}
/**
 * @since 1.0.0
 */
var TupleType = /** @class */ (function (_super) {
    __extends(TupleType, _super);
    function TupleType(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        /**
         * @since 1.0.0
         */
        _this._tag = 'TupleType';
        return _this;
    }
    return TupleType;
}(Type));

function es6_tuple(codecs, name) {
    if (name === void 0) { name = "[" + codecs.map(function (type) { return type.name; }).join(', ') + "]"; }
    var len = codecs.length;
    return new TupleType(name, function (u) { return UnknownArray.is(u) && u.length === len && codecs.every(function (type, i) { return type.is(u[i]); }); }, function (u, c) {
        var e = UnknownArray.validate(u, c);
        if (isLeft(e)) {
            return e;
        }
        var us = e.right;
        var as = us.length > len ? us.slice(0, len) : us; // strip additional components
        var errors = [];
        for (var i = 0; i < len; i++) {
            var a = us[i];
            var type_3 = codecs[i];
            var result = type_3.validate(a, appendContext(c, String(i), type_3, a));
            if (isLeft(result)) {
                pushAll(errors, result.left);
            }
            else {
                var va = result.right;
                if (va !== a) {
                    /* istanbul ignore next */
                    if (as === us) {
                        as = us.slice();
                    }
                    as[i] = va;
                }
            }
        }
        return errors.length > 0 ? failures(errors) : success(as);
    }, useIdentity(codecs) ? es6_identity : function (a) { return codecs.map(function (type, i) { return type.encode(a[i]); }); }, codecs);
}
/**
 * @since 1.0.0
 */
var ReadonlyType = /** @class */ (function (_super) {
    __extends(ReadonlyType, _super);
    function ReadonlyType(name, is, validate, encode, type) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type;
        /**
         * @since 1.0.0
         */
        _this._tag = 'ReadonlyType';
        return _this;
    }
    return ReadonlyType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function es6_readonly(codec, name) {
    if (name === void 0) { name = "Readonly<" + codec.name + ">"; }
    return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);
}
/**
 * @since 1.0.0
 */
var ReadonlyArrayType = /** @class */ (function (_super) {
    __extends(ReadonlyArrayType, _super);
    function ReadonlyArrayType(name, is, validate, encode, type) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type;
        /**
         * @since 1.0.0
         */
        _this._tag = 'ReadonlyArrayType';
        return _this;
    }
    return ReadonlyArrayType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function readonlyArray(item, name) {
    if (name === void 0) { name = "ReadonlyArray<" + item.name + ">"; }
    var codec = array(item);
    return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);
}
/**
 * Strips additional properties, equivalent to `exact(type(props))`.
 *
 * @category combinators
 * @since 1.0.0
 */
var strict = function (props, name) { return exact(type(props), name); };
/**
 * @since 1.1.0
 */
var ExactType = /** @class */ (function (_super) {
    __extends(ExactType, _super);
    function ExactType(name, is, validate, encode, type) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type;
        /**
         * @since 1.0.0
         */
        _this._tag = 'ExactType';
        return _this;
    }
    return ExactType;
}(Type));

/**
 * Strips additional properties.
 *
 * @category combinators
 * @since 1.1.0
 */
function exact(codec, name) {
    if (name === void 0) { name = getExactTypeName(codec); }
    var props = getProps(codec);
    return new ExactType(name, codec.is, function (u, c) {
        var e = UnknownRecord.validate(u, c);
        if (isLeft(e)) {
            return e;
        }
        var ce = codec.validate(u, c);
        if (isLeft(ce)) {
            return ce;
        }
        return right(stripKeys(ce.right, props));
    }, function (a) { return codec.encode(stripKeys(a, props)); }, codec);
}
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * @since 1.0.0
 * @deprecated
 */
var FunctionType = /** @class */ (function (_super) {
    __extends(FunctionType, _super);
    function FunctionType() {
        var _this = _super.call(this, 'Function', 
        // tslint:disable-next-line:strict-type-predicates
        function (u) { return typeof u === 'function'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'FunctionType';
        return _this;
    }
    return FunctionType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 * @deprecated
 */
// tslint:disable-next-line: deprecation
var es6_Function = new FunctionType();
/**
 * @since 1.3.0
 * @deprecated
 */
var TaggedUnionType = /** @class */ (function (_super) {
    __extends(TaggedUnionType, _super);
    function TaggedUnionType(name, 
    // tslint:disable-next-line: deprecation
    is, 
    // tslint:disable-next-line: deprecation
    validate, 
    // tslint:disable-next-line: deprecation
    encode, codecs, tag) {
        var _this = _super.call(this, name, is, validate, encode, codecs) /* istanbul ignore next */ // <= workaround for https://github.com/Microsoft/TypeScript/issues/13455
         || this;
        _this.tag = tag;
        return _this;
    }
    return TaggedUnionType;
}(UnionType));

/**
 * Use `union` instead.
 *
 * @category combinators
 * @since 1.3.0
 * @deprecated
 */
var taggedUnion = function (tag, codecs, name
// tslint:disable-next-line: deprecation
) {
    if (name === void 0) { name = getUnionName(codecs); }
    var U = union(codecs, name);
    // tslint:disable-next-line: deprecation
    if (U instanceof TaggedUnionType) {
        return U;
    }
    else {
        console.warn("[io-ts] Cannot build a tagged union for " + name + ", returning a de-optimized union");
        // tslint:disable-next-line: deprecation
        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);
    }
};


/**
 * @since 1.0.0
 * @deprecated
 */
var getValidationError /* istanbul ignore next */ = function (value, context) { return ({
    value: value,
    context: context
}); };
/**
 * @since 1.0.0
 * @deprecated
 */
var getDefaultContext /* istanbul ignore next */ = function (decoder) { return [
    { key: '', type: decoder }
]; };
/**
 * @since 1.0.0
 * @deprecated
 */
var NeverType = /** @class */ (function (_super) {
    __extends(NeverType, _super);
    function NeverType() {
        var _this = _super.call(this, 'never', function (_) { return false; }, function (u, c) { return failure(u, c); }, 
        /* istanbul ignore next */
        function () {
            throw new Error('cannot encode never');
        }) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'NeverType';
        return _this;
    }
    return NeverType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 * @deprecated
 */
// tslint:disable-next-line: deprecation
var never = new NeverType();
/**
 * @since 1.0.0
 * @deprecated
 */
var AnyType = /** @class */ (function (_super) {
    __extends(AnyType, _super);
    function AnyType() {
        var _this = _super.call(this, 'any', function (_) { return true; }, success, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'AnyType';
        return _this;
    }
    return AnyType;
}(Type));

/**
 * Use `unknown` instead.
 *
 * @category primitives
 * @since 1.0.0
 * @deprecated
 */
// tslint:disable-next-line: deprecation
var any = new AnyType();
/**
 * Use `UnknownRecord` instead.
 *
 * @category primitives
 * @since 1.0.0
 * @deprecated
 */
var Dictionary = (/* unused pure expression or super */ null && (UnknownRecord));
/**
 * @since 1.0.0
 * @deprecated
 */
var ObjectType = /** @class */ (function (_super) {
    __extends(ObjectType, _super);
    function ObjectType() {
        var _this = _super.call(this, 'object', function (u) { return u !== null && typeof u === 'object'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, es6_identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'ObjectType';
        return _this;
    }
    return ObjectType;
}(Type));

/**
 * Use `UnknownRecord` instead.
 *
 * @category primitives
 * @since 1.0.0
 * @deprecated
 */
// tslint:disable-next-line: deprecation
var object = new ObjectType();
/**
 * Use `brand` instead.
 *
 * @category combinators
 * @since 1.0.0
 * @deprecated
 */
function refinement(codec, predicate, name) {
    if (name === void 0) { name = "(" + codec.name + " | " + getFunctionName(predicate) + ")"; }
    return new RefinementType(name, function (u) { return codec.is(u) && predicate(u); }, function (i, c) {
        var e = codec.validate(i, c);
        if (Either_isLeft(e)) {
            return e;
        }
        var a = e.right;
        return predicate(a) ? success(a) : failure(a, c);
    }, codec.encode, codec, predicate);
}
/**
 * Use `Int` instead.
 *
 * @category primitives
 * @since 1.0.0
 * @deprecated
 */
// tslint:disable-next-line: deprecation
var Integer = refinement(number, Number.isInteger, 'Integer');
/**
 * Use `record` instead.
 *
 * @category combinators
 * @since 1.0.0
 * @deprecated
 */
var dictionary = (/* unused pure expression or super */ null && (record));
/**
 * @since 1.0.0
 * @deprecated
 */
var StrictType = /** @class */ (function (_super) {
    __extends(StrictType, _super);
    function StrictType(name, 
    // tslint:disable-next-line: deprecation
    is, 
    // tslint:disable-next-line: deprecation
    validate, 
    // tslint:disable-next-line: deprecation
    encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        /**
         * @since 1.0.0
         */
        _this._tag = 'StrictType';
        return _this;
    }
    return StrictType;
}(Type));

/**
 * Drops the codec "kind".
 *
 * @category combinators
 * @since 1.1.0
 * @deprecated
 */
function clean(codec) {
    return codec;
}
function alias(codec) {
    return function () { return codec; };
}

;// CONCATENATED MODULE: ./src/util/extendIoTs/enum.ts



class EnumType extends Type {
  constructor(e, name) {
    super(name !== null && name !== void 0 ? name : 'enum', u => {
      if (!Object.values(this.enumObject).find(v => v === u)) {
        return false;
      }

      if (typeof this.enumObject[u] === 'number') {
        return false;
      }

      return true;
    }, (u, c) => this.is(u) ? success(u) : failure(u, c), es6_identity);

    defineProperty_defineProperty(this, "_tag", 'EnumType');

    defineProperty_defineProperty(this, "enumObject", void 0);

    this.enumObject = e;
  }

}
/**
 *
 * @param name - optional enum name
 */


const enumType = (e, name) => new EnumType(e, name);
// EXTERNAL MODULE: ./node_modules/core-js-pure/stable/object/from-entries.js
var from_entries = __webpack_require__(5239);
var from_entries_default = /*#__PURE__*/__webpack_require__.n(from_entries);
;// CONCATENATED MODULE: ./src/util/extendIoTs/fallback.ts



/* eslint-disable @typescript-eslint/no-unsafe-return */
// eslint-disable-next-line max-classes-per-file


class FallbackType extends Type {
  constructor(p, defaultValue) {
    super(p.name, _u => true, (u, c) => {
      const report = p.validate(u, c);

      if (Either_isRight(report)) {
        return report;
      }

      return success(typeof this.defaultValue === 'function' ? this.defaultValue() : this.defaultValue);
    }, p.encode);

    defineProperty_defineProperty(this, "defaultValue", void 0);

    this.defaultValue = defaultValue;
  }

  get defaultData() {
    const data = typeof this.defaultValue === 'function' ? this.defaultValue() : this.defaultValue;
    return data;
  }

}
const fallback = (p, dValue) => new FallbackType(p, typeof dValue === 'function' ? dValue() : dValue);
class FallbackInterface extends Type {
  constructor(p) {
    const tp = type(p);
    super('', _u => true, (u, c) => {
      const report = tp.validate(u, c);

      if (Either_isLeft(report)) {
        const data = from_entries_default()(Object.entries(p).map(([k, v]) => [k, v.defaultData]));

        return success(data);
      }

      return report;
    }, tp.encode);

    defineProperty_defineProperty(this, "p", void 0);

    this.p = p;
  }

  get defaultData() {
    const data = from_entries_default()(Object.entries(this.p).map(([k, v]) => [k, v.defaultData]));

    return data;
  }

}
const fallbackInterface = t => new FallbackInterface(t);
;// CONCATENATED MODULE: ./src/provider/create.ts


function create_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function create_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? create_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : create_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

const createProvider = params => create_objectSpread(create_objectSpread({}, params), {}, {
  get store() {
    return this.storeWrapper.data;
  }

});
// EXTERNAL MODULE: ./node_modules/md5/md5.js
var md5 = __webpack_require__(5377);
var md5_default = /*#__PURE__*/__webpack_require__.n(md5);
;// CONCATENATED MODULE: ./src/util/copy.ts
const copy = p => typeof p === 'object' ? JSON.parse((__webpack_require__(8334)/* .stringify */ .P)(p)) : p;

/* harmony default export */ const util_copy = (copy);
;// CONCATENATED MODULE: ./src/provider/Iciba/container/data.ts

const containerData = reactivity_esm_bundler_reactive({
  data: null
});
;// CONCATENATED MODULE: ./src/service/store/provider.ts


function provider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function provider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? provider_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : provider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



const providerCommonStore = {
  enableHotkey: fallback(es6_boolean, false),
  hotkey: fallback(array(string), () => [])
};
const apiProviderCommonStore = provider_objectSpread(provider_objectSpread({}, providerCommonStore), {}, {
  appId: fallback(string, ''),
  appKey: fallback(string, '')
});
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/iciba/search.svg
/* harmony default export */ const search = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 57 57\"><path d=\"M55.1 51.9L41.6 37.8A23 23 0 0 0 24 0a23 23 0 1 0 13.2 41.8L50.8 56a3 3 0 0 0 4.3.1 3 3 0 0 0 0-4.2zM24 6a17 17 0 1 1 0 34 17 17 0 0 1 0-34z\" fill=\"#aaa\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/iciba/iciba_1362193.svg
/* harmony default export */ const iciba_1362193 = ("<svg height=\"640\" viewBox=\"-52 0 480 480\" width=\"640\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M48 48h320v424H48zm0 0\" fill=\"#ffeb99\"/><path d=\"M8 48h40v424H8zm0 0\" fill=\"#9f886a\"/><path d=\"M128 80h160v96H128zm0 0\" fill=\"#ffda44\"/><path d=\"M8 8v40h344V8zm0 0\" fill=\"#605240\"/><path d=\"M16 8h336v16H16zm0 0\" fill=\"#3c3328\"/><path d=\"M8 48h16v424H8zm0 0\" fill=\"#504435\"/><g fill=\"#231f20\"><path d=\"M296 72H120v112h176zm-16 96H136V88h144zm0 0\"/><path d=\"M152 104h112v16H152zm0 0M152 136h32v16h-32zm0 0M200 136h64v16h-64zm0 0\"/><path d=\"M376 16V0H0v480h376V40h-16V16zM16 464V56h24v408zm344 0H56V56h304zM16 40V16h328v24zm0 0\"/><path d=\"M88 352v-48h48v48h16v-72c0-22.089844-17.910156-40-40-40s-40 17.910156-40 40v72zm24-96c13.253906 0 24 10.746094 24 24v8H88v-8c0-13.253906 10.746094-24 24-24zm0 0M248 272c0-17.671875-14.328125-32-32-32h-48v112h48c13.34375.058594 25.3125-8.203125 29.984375-20.703125 4.675781-12.496094 1.066406-26.585937-9.039063-35.296875C243.9375 289.984375 247.972656 281.226562 248 272zm-16 48c0 8.835938-7.164062 16-16 16h-32v-32h32c8.835938 0 16 7.164062 16 16zm-48-32v-32h32c8.835938 0 16 7.164062 16 16s-7.164062 16-16 16zm0 0M264 280v32c0 22.089844 17.910156 40 40 40s40-17.910156 40-40h-16c0 13.253906-10.746094 24-24 24s-24-10.746094-24-24v-32c0-13.253906 10.746094-24 24-24s24 10.746094 24 24h16c0-22.089844-17.910156-40-40-40s-40 17.910156-40 40zm0 0\"/></g></svg>\n");
;// CONCATENATED MODULE: ./src/provider/Iciba/icons.ts


const icons = {
  searchIcon: search,
  iciba_1362193: iciba_1362193
};
;// CONCATENATED MODULE: ./src/provider/Iciba/store/index.ts


function store_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function store_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? store_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : store_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }





const storeType = fallbackInterface(store_objectSpread(store_objectSpread({}, providerCommonStore), {}, {
  display: fallback(es6_boolean, true),
  icon: fallback(keyof(icons), 'searchIcon'),
  lowerCaseCapital: fallback(es6_boolean, false)
}));
const defaultStore = storeType.defaultData;
const store = {
  data: null
};
;// CONCATENATED MODULE: ./src/provider/Iciba/translate.ts






 // e.params = {client: 6, key: 1000006, timestamp: 1611974079765, word: "lead"}

const translate = async p => {
  const rawWord = p.word;
  const now = Date.now();
  const wordCapital = store.data.lowerCaseCapital ? rawWord.substring(0, 1).toLowerCase() : rawWord.substring(0, 1);
  const word = `${wordCapital}${rawWord.substring(1)}`; // hard code in http://www.iciba.com/_next/static/chunks/8caea17ae752a5965491f530aed3596fce3ca5a9.f4f0c70d4f1b9d4253e3.js

  const hashKey = '7ece94d9f9c202b0d2ec557dg4r9bc';
  const hashMessageBody = `61000006${now}${word}`;
  const hashMessage = `/dictionary/word/query/web${hashMessageBody}${hashKey}`;
  const signature = md5_default()(hashMessage);
  const query = ['client=6', 'key=1000006', `timestamp=${now}`, `word=${encodeURIComponent(word)}`, `signature=${signature}`];
  const apiUrl = `https://dict.iciba.com/dictionary/word/query/web?${query.join('&')}`;
  const response = await got({
    method: 'GET',
    url: apiUrl,
    timeout: 5000
  });

  if (Either_isLeft(response)) {
    throw new Error(response.left.type);
  }

  const content = response.right.responseText;
  const result = tryCatch(() => JSON.parse(content).message, function_identity);

  if (Either_isLeft(result)) {
    return Either_left({
      message: '数据错误！'
    });
  }

  const message = result.right; // fix iciba api typo

  if ('baesInfo' in message) {
    message.baseInfo = message.baesInfo;
    delete message.baesInfo;
  }

  if ('bidce' in message) {
    message.bidec = message.bidce;
    delete message.bidce;
  } // dev only check


  if (false) {}

  return Either_right(() => {
    containerData.data = util_copy(message);
  });
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/Iciba/container/index.vue?vue&type=template&id=08018802&scoped=true&ts=true


const containervue_type_template_id_08018802_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-08018802"), n = n(), _popScopeId(), n);

const containervue_type_template_id_08018802_scoped_true_ts_true_hoisted_1 = {
  class: "r-container flex-col relative text-grey-900"
};
const containervue_type_template_id_08018802_scoped_true_ts_true_hoisted_2 = {
  key: 0,
  class: "symbols-box flex-col items-stretch"
};
const containervue_type_template_id_08018802_scoped_true_ts_true_hoisted_3 = {
  class: "pronunciation-box flex-col flex-none items-stretch"
};
const _hoisted_4 = {
  key: 0,
  class: "part-item-part pr-6px text-grey-600 flex-none"
};
const _hoisted_5 = {
  class: "part-item-meaning-box flex-auto"
};
const _hoisted_6 = {
  key: 1,
  class: "chinese-zi-box mt-1"
};
const _hoisted_7 = {
  key: 2,
  class: "chinese-ci-box mt-1 leading-normal"
};
const _hoisted_8 = {
  class: "ciyi-box"
};
const _hoisted_9 = {
  class: "type-text text-grey-600 pr-1"
};
const _hoisted_10 = {
  key: 0,
  class: "pr-1 text-grey-500"
};
const _hoisted_11 = {
  key: 1,
  class: "translation-box flex-col items-stretch"
};
const _hoisted_12 = {
  class: "translate-content"
};
const _hoisted_13 = {
  class: "translate-tip mt-1 text-right text-12 text-grey-500"
};

const _hoisted_14 = /*#__PURE__*/createTextVNode(" do you mean? ");

const _hoisted_15 = {
  key: 0,
  class: "suggest-box flex flex-wrap items-stretch"
};
const _hoisted_16 = ["onClick"];
function containervue_type_template_id_08018802_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_iciba_pronunciation = resolveComponent("iciba-pronunciation");

  const _component_scrollable = resolveComponent("scrollable");

  return openBlock(), createElementBlock("div", containervue_type_template_id_08018802_scoped_true_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_scrollable, {
    class: "scroll-container"
  }, {
    default: withCtx(({
      scrollBar
    }) => [_ctx.result ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["main-box flex-col flex-auto text-14 break-words", [scrollBar && 'py-10px pl-10px pr-14px', !scrollBar && 'p-10px']])
    }, [_ctx.isBaseInfoBaseInfoNormal(_ctx.result.baseInfo) ? (openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, {
      key: 0
    }, [_ctx.result.baseInfo && _ctx.result.baseInfo.symbols && _ctx.result.baseInfo.symbols.length ? (openBlock(), createElementBlock("div", containervue_type_template_id_08018802_scoped_true_ts_true_hoisted_2, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.result.baseInfo.symbols, (symbolItem, index) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["symbol-item flex-col items-stretch w-full", {
          'mt-6px': index !== 0
        }]),
        key: index
      }, [createBaseVNode("div", containervue_type_template_id_08018802_scoped_true_ts_true_hoisted_3, [_ctx.isSymbolCN(symbolItem) && symbolItem.word_symbol ? (openBlock(), createBlock(_component_iciba_pronunciation, {
        key: 0,
        ipa: symbolItem.word_symbol,
        onPlay: $event => _ctx.handlePlay(symbolItem.symbol_mp3)
      }, null, 8, ["ipa", "onPlay"])) : createCommentVNode("", true), _ctx.isSymbolEN(symbolItem) ? (openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, {
        key: 1
      }, [symbolItem.ph_en_mp3 ? (openBlock(), createBlock(_component_iciba_pronunciation, {
        key: 0,
        type: "英",
        ipa: `[${symbolItem.ph_en}]`,
        onPlay: $event => _ctx.handlePlay(symbolItem.ph_en_mp3)
      }, null, 8, ["ipa", "onPlay"])) : createCommentVNode("", true), symbolItem.ph_am_mp3 ? (openBlock(), createBlock(_component_iciba_pronunciation, {
        key: 1,
        type: "美",
        ipa: `[${symbolItem.ph_am}]`,
        onPlay: $event => _ctx.handlePlay(symbolItem.ph_am_mp3)
      }, null, 8, ["ipa", "onPlay"])) : createCommentVNode("", true), symbolItem.ph_tts_mp3 && !symbolItem.ph_en_mp3 && !symbolItem.ph_am_mp3 ? (openBlock(), createBlock(_component_iciba_pronunciation, {
        key: 2,
        type: "TTS",
        ipa: `[${symbolItem.ph_other}]`,
        onPlay: $event => _ctx.handlePlay(symbolItem.ph_tts_mp3)
      }, null, 8, ["ipa", "onPlay"])) : createCommentVNode("", true)], 64)) : createCommentVNode("", true)]), symbolItem.parts && symbolItem.parts.length ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["part-box flex-col flex-none items-stretch", {
          'mt-1': symbolItem.symbol_mp3 || symbolItem.word_symbol
        }])
      }, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(symbolItem.parts, (partItem, partItemIndex) => {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["part-item flex", {
            'mt-3px': partItemIndex !== 0
          }]),
          key: partItemIndex
        }, [partItem.part ? (openBlock(), createElementBlock("div", _hoisted_4, toDisplayString(partItem.part), 1)) : createCommentVNode("", true), createBaseVNode("div", _hoisted_5, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(partItem.means, (meanItem, meanItemIndex) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["meaning-item inline", {
              'pr-3px': meanItemIndex !== partItem.means.length - 1
            }]),
            key: meanItemIndex
          }, [meanItemIndex === partItem.means.length - 1 ? (openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, {
            key: 0
          }, [createTextVNode(toDisplayString(meanItem), 1)], 64)) : (openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, {
            key: 1
          }, [createTextVNode(toDisplayString(meanItem) + "; ", 1)], 64))], 2);
        }), 128))])], 2);
      }), 128))], 2)) : createCommentVNode("", true)], 2);
    }), 128))])) : createCommentVNode("", true), (!_ctx.result.baseInfo || !_ctx.result.baseInfo.symbols || !_ctx.result.baseInfo.symbols.length) && _ctx.result.chinese && _ctx.result.chinese.zi ? (openBlock(), createElementBlock("div", _hoisted_6, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.result.chinese.zi, (ziItem, ziIndex) => {
      return openBlock(), createElementBlock("div", {
        class: "zi-item",
        key: ziIndex
      }, toDisplayString(ziItem.hanzi) + " " + toDisplayString(ziItem.pinyin) + " " + toDisplayString(ziItem.jieshi), 1);
    }), 128))])) : createCommentVNode("", true), _ctx.result.chinese && _ctx.result.chinese.ci && _ctx.result.chinese.ci.ciyi && _ctx.result.chinese.ci.ciyi.length ? (openBlock(), createElementBlock("div", _hoisted_7, [createBaseVNode("div", _hoisted_8, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.normalizeCiyi(_ctx.result.chinese.ci.ciyi), (item, ciyiIndex) => {
      return openBlock(), createElementBlock("div", {
        class: "ciyi-item",
        key: ciyiIndex
      }, [createBaseVNode("span", _hoisted_9, toDisplayString(ciyiIndex + 1) + ". ", 1), _ctx.seperateChineseJieshi(item)[0] ? (openBlock(), createElementBlock("span", _hoisted_10, "[" + toDisplayString(_ctx.seperateChineseJieshi(item)[0]) + "]", 1)) : createCommentVNode("", true), createBaseVNode("span", null, toDisplayString(_ctx.seperateChineseJieshi(item)[1]), 1)]);
    }), 128))])])) : createCommentVNode("", true)], 64)) : createCommentVNode("", true), _ctx.isBaseInfoTranslate(_ctx.result.baseInfo) && _ctx.result.baseInfo.translate_type === 2 && _ctx.result.baseInfo.translate_result ? (openBlock(), createElementBlock("div", _hoisted_11, [createBaseVNode("div", _hoisted_12, toDisplayString(_ctx.result.baseInfo.translate_result), 1), createBaseVNode("div", _hoisted_13, toDisplayString(_ctx.result.baseInfo.translate_msg.replace(/。$/, '')), 1)])) : createCommentVNode("", true), _ctx.isBaseInfoSuggestion(_ctx.result.baseInfo) && _ctx.result.baseInfo.suggest.length ? (openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, {
      key: 2
    }, [_hoisted_14, _ctx.isBaseInfoSuggestion(_ctx.result.baseInfo) ? (openBlock(), createElementBlock("div", _hoisted_15, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.result.baseInfo.suggest, (item, index) => {
      return openBlock(), createElementBlock("span", {
        class: "text-blue-500 mr-1 cursor-pointer",
        onClick: $event => _ctx.handleSuggestionClick(item.key),
        key: index
      }, toDisplayString(item.key), 9, _hoisted_16);
    }), 128))])) : createCommentVNode("", true)], 64)) : createCommentVNode("", true)], 2)) : createCommentVNode("", true)]),
    _: 1
  })]);
}
;// CONCATENATED MODULE: ./src/provider/Iciba/container/index.vue?vue&type=template&id=08018802&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/Scrollable/Scrollable.vue?vue&type=template&id=5ec67402&scoped=true&ts=true


const Scrollablevue_type_template_id_5ec67402_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-5ec67402"), n = n(), _popScopeId(), n);

const Scrollablevue_type_template_id_5ec67402_scoped_true_ts_true_hoisted_1 = {
  class: "scrollable relative flex"
};
const Scrollablevue_type_template_id_5ec67402_scoped_true_ts_true_hoisted_2 = {
  class: "scroll-content flex-col flex-auto overflow-hidden"
};
function Scrollablevue_type_template_id_5ec67402_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_no_overscroll = resolveDirective("no-overscroll");

  return openBlock(), createElementBlock("div", Scrollablevue_type_template_id_5ec67402_scoped_true_ts_true_hoisted_1, [createBaseVNode("div", {
    class: normalizeClass(["scroll-bar-track absolute right-0", {
      moving: _ctx.state.drag.start,
      'hidden': _ctx.state.noScrollBar
    }])
  }, [!_ctx.state.noScrollBar ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "scroll-bar-thumb rounded-full flex justify-center absolute ease-in-out duration-100",
    style: normalizeStyle(_ctx.thumbStyle),
    onWheel: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"])),
    onMousedown: _cache[1] || (_cache[1] = //@ts-ignore
    (...args) => _ctx.handleScrollbarThumbClick && _ctx.handleScrollbarThumbClick(...args))
  }, null, 36)) : createCommentVNode("", true)], 2), createBaseVNode("div", Scrollablevue_type_template_id_5ec67402_scoped_true_ts_true_hoisted_2, [withDirectives((openBlock(), createElementBlock("div", {
    class: "scroll-box flex flex-auto overflow-x-hidden overflow-y-scroll",
    style: normalizeStyle(_ctx.scrollBoxStyle),
    onScroll: _cache[2] || (_cache[2] = //@ts-ignore
    (...args) => _ctx.calcScrollbar && _ctx.calcScrollbar(...args)),
    onMouseenter: _cache[3] || (_cache[3] = //@ts-ignore
    (...args) => _ctx.calcScrollbar && _ctx.calcScrollbar(...args)),
    ref: _ctx.refs.container
  }, [createBaseVNode("div", {
    class: "w-full flex-col",
    ref: _ctx.refs.scrollBox
  }, [renderSlot(_ctx.$slots, "default", {
    scrollBar: !_ctx.state.noScrollBar
  }, undefined, true)], 512)], 36)), [[_directive_no_overscroll]])])]);
}
;// CONCATENATED MODULE: ./src/components/Scrollable/Scrollable.vue?vue&type=template&id=5ec67402&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {
        return __webpack_require__.g;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ const ResizeObserver_es = (index);

;// CONCATENATED MODULE: ./src/util/scrollbar-width.ts

const getScrollBarWidth = () => {
  const outer = document.createElement('div');
  const outerStyle = outer.style;
  outerStyle.overflow = 'scroll';
  outerStyle.height = '100%';
  outerStyle.visibility = 'hidden';
  outerStyle.width = '100px';
  outerStyle.position = 'absolute';
  outerStyle.top = '-9999px';
  shadowRoot.append(outer);
  const widthNoScroll = outer.offsetWidth;
  outerStyle.overflow = 'scroll';
  const inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);
  const widthWithScroll = inner.offsetWidth;
  shadowRoot.removeChild(outer);
  return widthNoScroll - widthWithScroll;
};
;// CONCATENATED MODULE: ./src/service/scrollBarWidth/index.tsx


const state = reactivity_esm_bundler_reactive({
  scrollBarWidth: 0,
  devicePixelRatio: null
});

const handleCalc = () => {
  const devicePixelRatio = window.devicePixelRatio;

  if (devicePixelRatio !== null && state.devicePixelRatio === devicePixelRatio) {
    return;
  }

  const w = getScrollBarWidth();
  state.scrollBarWidth = w;
};

const init = () => {
  window.addEventListener('resize', handleCalc);
  handleCalc();
};

const scrollBarWidthService = {
  state,
  init
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/Scrollable/Scrollable.ts?vue&type=script&lang=ts



/* harmony default export */ const Scrollablevue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  setup: props => {
    const refs = {
      container: reactivity_esm_bundler_ref(),
      scrollBox: reactivity_esm_bundler_ref()
    };
    const state = reactivity_esm_bundler_reactive({
      drag: {
        start: false,
        startY: 0,
        startScrollTop: 0
      },
      noScrollBar: true,
      scrollbar: {
        track: {
          top: 0
        },
        thumb: {
          size: '0',
          position: '0'
        }
      }
    });

    const handleScrollbarThumbClick = e => {
      e.preventDefault();

      if (!refs.container.value) {
        return;
      }

      state.drag.start = true;
      state.drag.startY = e.clientY;
      state.drag.startScrollTop = refs.container.value.scrollTop;
    };

    const handleScrollbarThumbMousemove = e => {
      if (!refs.container.value) {
        return;
      }

      if (state.drag.start) {
        e.preventDefault();
        const {
          scrollHeight,
          clientHeight
        } = refs.container.value;
        const scrollSpacePixel = scrollHeight - clientHeight;
        const mouseMovePixel = e.clientY - state.drag.startY;
        const moveDeltaPercentage = mouseMovePixel / clientHeight;
        const scrollDelta = scrollHeight * moveDeltaPercentage;
        let destScrollTop = state.drag.startScrollTop + scrollDelta;

        if (destScrollTop > scrollSpacePixel) {
          destScrollTop = scrollSpacePixel;
        }

        if (destScrollTop < 0) {
          destScrollTop = 0;
        }

        refs.container.value.scrollTop = destScrollTop;
      }
    };

    const handleScrollbarThumbMouseup = () => {
      state.drag.start = false;
    };

    const calcScrollbar = () => {
      if (!refs.container.value) {
        return;
      }

      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = refs.container.value;
      const sizePercentage = clientHeight / scrollHeight;
      const avaliableScrollSpace = scrollHeight - clientHeight;
      const currentScrollPercentage = scrollTop / avaliableScrollSpace;
      const thumbMaxHeightPercentage = 1 - sizePercentage;
      const thumbTop = thumbMaxHeightPercentage * currentScrollPercentage * 100;
      state.noScrollBar = sizePercentage >= 1;
      const thumbSize = (sizePercentage * 100).toFixed(4);
      const thumbPosition = thumbTop.toFixed(4); // prevent infinite update

      if (state.scrollbar.track.top !== scrollTop) {
        state.scrollbar.track.top = scrollTop;
      }

      if (state.scrollbar.thumb.size !== thumbSize) {
        state.scrollbar.thumb.size = thumbSize;
      }

      if (state.scrollbar.thumb.position !== thumbPosition) {
        state.scrollbar.thumb.position = thumbPosition;
      }
    };

    const thumbStyle = runtime_core_esm_bundler_computed(() => ({
      height: `${state.scrollbar.thumb.size}%`,
      top: `${state.scrollbar.thumb.position}%`
    }));
    const scrollBoxStyle = runtime_core_esm_bundler_computed(() => ({
      'margin-right': `${-scrollBarWidthService.state.scrollBarWidth}px`
    }));
    runtime_core_esm_bundler_onMounted(() => {
      window.addEventListener('mousemove', handleScrollbarThumbMousemove, false);
      window.addEventListener('mouseup', handleScrollbarThumbMouseup, false);
      const ro = new ResizeObserver_es(calcScrollbar);
      window.setTimeout(() => {
        if (refs.container.value) {
          ro.observe(refs.container.value);
        }

        if (refs.scrollBox.value) {
          ro.observe(refs.scrollBox.value);
        }
      });
      calcScrollbar();
      runtime_core_esm_bundler_onUnmounted(() => {
        window.removeEventListener('mousemove', handleScrollbarThumbMousemove, false);
        window.removeEventListener('mouseup', handleScrollbarThumbMouseup, false);
        ro.disconnect();
      });
    });
    onUpdated(() => {
      calcScrollbar();
    });
    return {
      state,
      refs,
      props,
      thumbStyle,
      scrollBoxStyle,
      calcScrollbar,
      handleScrollbarThumbClick
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/Scrollable/Scrollable.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/Scrollable/Scrollable.sass?vue&type=style&index=0&id=5ec67402&lang=sass&scoped=true
var Scrollablevue_type_style_index_0_id_5ec67402_lang_sass_scoped_true = __webpack_require__(5428);
;// CONCATENATED MODULE: ./src/components/Scrollable/Scrollable.sass?vue&type=style&index=0&id=5ec67402&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/components/Scrollable/Scrollable.vue




;


const Scrollable_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Scrollablevue_type_script_lang_ts, [['render',Scrollablevue_type_template_id_5ec67402_scoped_true_ts_true_render],['__scopeId',"data-v-5ec67402"]])

/* harmony default export */ const Scrollable = (Scrollable_exports_);
;// CONCATENATED MODULE: ./src/assets/img/play/speaker-filled-audio-tool_59284.svg
/* harmony default export */ const speaker_filled_audio_tool_59284 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"512\" viewBox=\"0 0 93.038 93.038\"><path d=\"M46.547 75.521c0 1.639-.947 3.128-2.429 3.823-.573.271-1.187.402-1.797.402-.966 0-1.923-.332-2.696-.973l-23.098-19.14H4.225C1.892 59.635 0 57.742 0 55.409V38.576c0-2.334 1.892-4.226 4.225-4.226h12.303l23.098-19.14c1.262-1.046 3.012-1.269 4.493-.569 1.481.695 2.429 2.185 2.429 3.823l-.001 57.057zm16.237-6.602c-.103.007-.202.011-.304.011-1.116 0-2.192-.441-2.987-1.237l-.565-.567c-1.482-1.479-1.656-3.822-.408-5.504 3.164-4.266 4.834-9.323 4.834-14.628 0-5.706-1.896-11.058-5.484-15.478-1.366-1.68-1.24-4.12.291-5.65l.564-.565c.844-.844 1.975-1.304 3.199-1.231 1.192.06 2.305.621 3.061 1.545 4.977 6.09 7.606 13.484 7.606 21.38 0 7.354-2.325 14.354-6.725 20.24-.735.981-1.859 1.597-3.082 1.684zm17.468 13.057c-.764.903-1.869 1.445-3.052 1.495-.058.002-.117.004-.177.004-1.119 0-2.193-.442-2.988-1.237l-.555-.555c-1.551-1.55-1.656-4.029-.246-5.707 6.814-8.104 10.568-18.396 10.568-28.982 0-11.011-4.019-21.611-11.314-29.847-1.479-1.672-1.404-4.203.17-5.783l.554-.555c.822-.826 1.89-1.281 3.115-1.242 1.163.033 2.263.547 3.036 1.417 8.818 9.928 13.675 22.718 13.675 36.01.002 12.789-4.539 25.213-12.786 34.982z\"/></svg>\n");
;// CONCATENATED MODULE: ./src/util/events.ts

class EventEmitter {
  constructor() {
    defineProperty_defineProperty(this, "m", {});
  }

  on(e, l) {
    var _this$m$e;

    this.m[e] = (_this$m$e = this.m[e]) !== null && _this$m$e !== void 0 ? _this$m$e : [];
    this.m[e].push(l);
  }

  off(e, l) {
    if (this.m[e]) {
      const index = this.m[e].indexOf(l);

      if (index !== -1) {
        this.m[e].splice(index, 1);
      }
    }
  }

  emit(e, payload) {
    if (this.m[e]) {
      this.m[e].forEach(l => l(payload));
    }
  }

}
;// CONCATENATED MODULE: ./src/service/globalBus/types.ts
var EVENTS;

(function (EVENTS) {
  EVENTS[EVENTS["TRANSLATE"] = 0] = "TRANSLATE";
  EVENTS[EVENTS["HOTKEY_SHOW"] = 1] = "HOTKEY_SHOW";
  EVENTS[EVENTS["HOTKEY_TRANSLATE"] = 2] = "HOTKEY_TRANSLATE";
  EVENTS[EVENTS["OPEN_SETTING"] = 3] = "OPEN_SETTING";
  EVENTS[EVENTS["OPEN_HISTORY"] = 4] = "OPEN_HISTORY";
  EVENTS[EVENTS["OPEN_GOOGLE_DICT_MODAL"] = 5] = "OPEN_GOOGLE_DICT_MODAL";
  EVENTS[EVENTS["HIDE_CIRCLE"] = 6] = "HIDE_CIRCLE";
})(EVENTS || (EVENTS = {}));
;// CONCATENATED MODULE: ./src/service/globalBus/index.ts


/* eslint-disable max-classes-per-file */



class Bus {
  constructor() {
    defineProperty_defineProperty(this, "bus", new EventEmitter());
  }

  on(p) {
    this.bus.on(`${p.event}`, p.listener);
  }

  off(p) {
    this.bus.off(`${p.event}`, p.listener);
  }

  emit(action) {
    this.bus.emit(`${action.type}`, action);
  }

}

const bus = new Bus();
;// CONCATENATED MODULE: ./node_modules/fp-ts/es6/These.js





// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * Returns `true` if the these is an instance of `Left`, `false` otherwise
 *
 * @category refinements
 * @since 2.0.0
 */
var These_isLeft = function (fa) { return fa._tag === 'Left'; };
/**
 * Returns `true` if the these is an instance of `Right`, `false` otherwise
 *
 * @category refinements
 * @since 2.0.0
 */
var These_isRight = function (fa) { return fa._tag === 'Right'; };
/**
 * Returns `true` if the these is an instance of `Both`, `false` otherwise
 *
 * @category refinements
 * @since 2.0.0
 */
function isBoth(fa) {
    return fa._tag === 'Both';
}
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.0.0
 */
function These_left(left) {
    return { _tag: 'Left', left: left };
}
/**
 * @category constructors
 * @since 2.0.0
 */
function These_right(right) {
    return { _tag: 'Right', right: right };
}
/**
 * @category constructors
 * @since 2.0.0
 */
function both(left, right) {
    return { _tag: 'Both', left: left, right: right };
}
/**
 * Less strict version of [`match`](#match).
 *
 * @category destructors
 * @since 2.10.0
 */
var These_matchW = function (onLeft, onRight, onBoth) { return function (fa) {
    switch (fa._tag) {
        case 'Left':
            return onLeft(fa.left);
        case 'Right':
            return onRight(fa.right);
        case 'Both':
            return onBoth(fa.left, fa.right);
    }
}; };
/**
 * Alias of [`matchW`](#matchw).
 *
 * @category destructors
 * @since 2.10.0
 */
var These_foldW = (/* unused pure expression or super */ null && (These_matchW));
/**
 * @category destructors
 * @since 2.10.0
 */
var These_match = These_matchW;
/**
 * Alias of [`match`](#match).
 *
 * @category destructors
 * @since 2.0.0
 */
var These_fold = (/* unused pure expression or super */ null && (These_match));
/**
 * @category combinators
 * @since 2.4.0
 */
var These_swap = These_match(These_right, These_left, function (e, a) { return both(a, e); });
/**
 * @category instances
 * @since 2.0.0
 */
function These_getShow(SE, SA) {
    return {
        show: These_match(function (l) { return "left(" + SE.show(l) + ")"; }, function (a) { return "right(" + SA.show(a) + ")"; }, function (l, a) { return "both(" + SE.show(l) + ", " + SA.show(a) + ")"; })
    };
}
/**
 * @category instances
 * @since 2.0.0
 */
function These_getEq(EE, EA) {
    return fromEquals(function (x, y) {
        return These_isLeft(x)
            ? These_isLeft(y) && EE.equals(x.left, y.left)
            : These_isRight(x)
                ? These_isRight(y) && EA.equals(x.right, y.right)
                : isBoth(y) && EE.equals(x.left, y.left) && EA.equals(x.right, y.right);
    });
}
/**
 * @category instances
 * @since 2.0.0
 */
function These_getSemigroup(SE, SA) {
    return {
        concat: function (x, y) {
            return These_isLeft(x)
                ? These_isLeft(y)
                    ? These_left(SE.concat(x.left, y.left))
                    : These_isRight(y)
                        ? both(x.left, y.right)
                        : both(SE.concat(x.left, y.left), y.right)
                : These_isRight(x)
                    ? These_isLeft(y)
                        ? both(y.left, x.right)
                        : These_isRight(y)
                            ? These_right(SA.concat(x.right, y.right))
                            : both(y.left, SA.concat(x.right, y.right))
                    : These_isLeft(y)
                        ? both(SE.concat(x.left, y.left), x.right)
                        : These_isRight(y)
                            ? both(x.left, SA.concat(x.right, y.right))
                            : both(SE.concat(x.left, y.left), SA.concat(x.right, y.right));
        }
    };
}
/**
 * @category instances
 * @since 2.10.0
 */
var getApply = function (S) { return ({
    URI: These_URI,
    _E: undefined,
    map: These_map,
    ap: function (fab, fa) {
        return These_isLeft(fab)
            ? These_isLeft(fa)
                ? These_left(S.concat(fab.left, fa.left))
                : These_isRight(fa)
                    ? These_left(fab.left)
                    : These_left(S.concat(fab.left, fa.left))
            : These_isRight(fab)
                ? These_isLeft(fa)
                    ? These_left(fa.left)
                    : These_isRight(fa)
                        ? These_right(fab.right(fa.right))
                        : both(fa.left, fab.right(fa.right))
                : These_isLeft(fa)
                    ? These_left(S.concat(fab.left, fa.left))
                    : These_isRight(fa)
                        ? both(fab.left, fab.right(fa.right))
                        : both(S.concat(fab.left, fa.left), fab.right(fa.right));
    }
}); };
/**
 * @category instances
 * @since 2.7.0
 */
function getApplicative(S) {
    var A = getApply(S);
    return {
        URI: These_URI,
        _E: undefined,
        map: These_map,
        ap: A.ap,
        of: These_of
    };
}
/**
 * @category instances
 * @since 2.10.0
 */
function getChain(S) {
    var A = getApply(S);
    var chain = function (ma, f) {
        if (These_isLeft(ma)) {
            return ma;
        }
        if (These_isRight(ma)) {
            return f(ma.right);
        }
        var fb = f(ma.right);
        return These_isLeft(fb)
            ? These_left(S.concat(ma.left, fb.left))
            : These_isRight(fb)
                ? both(ma.left, fb.right)
                : both(S.concat(ma.left, fb.left), fb.right);
    };
    return {
        URI: These_URI,
        _E: undefined,
        map: These_map,
        ap: A.ap,
        chain: chain
    };
}
/**
 * @category instances
 * @since 2.0.0
 */
function getMonad(S) {
    var C = getChain(S);
    return {
        URI: These_URI,
        _E: undefined,
        map: These_map,
        of: These_of,
        ap: C.ap,
        chain: C.chain,
        throwError: These_left
    };
}
/**
 * Returns an `E` value if possible
 *
 * @example
 * import { getLeft, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getLeft(left('a')), some('a'))
 * assert.deepStrictEqual(getLeft(right(1)), none)
 * assert.deepStrictEqual(getLeft(both('a', 1)), some('a'))
 *
 * @category destructors
 * @since 2.0.0
 */
function getLeft(fa) {
    return These_isLeft(fa) ? _.some(fa.left) : These_isRight(fa) ? _.none : _.some(fa.left);
}
/**
 * Returns an `A` value if possible
 *
 * @example
 * import { getRight, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getRight(left('a')), none)
 * assert.deepStrictEqual(getRight(right(1)), some(1))
 * assert.deepStrictEqual(getRight(both('a', 1)), some(1))
 *
 * @category destructors
 * @since 2.0.0
 */
function getRight(fa) {
    return These_isLeft(fa) ? _.none : These_isRight(fa) ? _.some(fa.right) : _.some(fa.right);
}
// TODO: make lazy in v3
/**
 * @example
 * import { leftOrBoth, left, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(leftOrBoth('a')(none), left('a'))
 * assert.deepStrictEqual(leftOrBoth('a')(some(1)), both('a', 1))
 *
 * @category constructors
 * @since 2.0.0
 */
function leftOrBoth(e) {
    return function (ma) { return (_.isNone(ma) ? These_left(e) : both(e, ma.value)); };
}
// TODO: make lazy in v3
/**
 * @example
 * import { rightOrBoth, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(rightOrBoth(1)(none), right(1))
 * assert.deepStrictEqual(rightOrBoth(1)(some('a')), both('a', 1))
 *
 * @category constructors
 * @since 2.0.0
 */
function rightOrBoth(a) {
    return function (me) { return (_.isNone(me) ? These_right(a) : both(me.value, a)); };
}
/**
 * Returns the `E` value if and only if the value is constructed with `Left`
 *
 * @example
 * import { getLeftOnly, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getLeftOnly(left('a')), some('a'))
 * assert.deepStrictEqual(getLeftOnly(right(1)), none)
 * assert.deepStrictEqual(getLeftOnly(both('a', 1)), none)
 *
 * @category destructors
 * @since 2.0.0
 */
function getLeftOnly(fa) {
    return These_isLeft(fa) ? _.some(fa.left) : _.none;
}
/**
 * Returns the `A` value if and only if the value is constructed with `Right`
 *
 * @example
 * import { getRightOnly, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getRightOnly(left('a')), none)
 * assert.deepStrictEqual(getRightOnly(right(1)), some(1))
 * assert.deepStrictEqual(getRightOnly(both('a', 1)), none)
 *
 * @category destructors
 * @since 2.0.0
 */
function getRightOnly(fa) {
    return These_isRight(fa) ? _.some(fa.right) : _.none;
}
/**
 * Takes a pair of `Option`s and attempts to create a `These` from them
 *
 * @example
 * import { fromOptions, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(fromOptions(none, none), none)
 * assert.deepStrictEqual(fromOptions(some('a'), none), some(left('a')))
 * assert.deepStrictEqual(fromOptions(none, some(1)), some(right(1)))
 * assert.deepStrictEqual(fromOptions(some('a'), some(1)), some(both('a', 1)))
 *
 * @category constructors
 * @since 2.0.0
 */
var fromOptions = function (fe, fa) {
    return _.isNone(fe)
        ? _.isNone(fa)
            ? _.none
            : _.some(These_right(fa.value))
        : _.isNone(fa)
            ? _.some(These_left(fe.value))
            : _.some(both(fe.value, fa.value));
};
// -------------------------------------------------------------------------------------
// non-pipeables
// -------------------------------------------------------------------------------------
var These_map = function (fa, f) { return pipe(fa, es6_These_map(f)); };
/* istanbul ignore next */
var These_bimap = function (fa, f, g) { return pipe(fa, es6_These_bimap(f, g)); };
/* istanbul ignore next */
var These_mapLeft = function (fa, f) { return pipe(fa, es6_These_mapLeft(f)); };
/* istanbul ignore next */
var These_reduce = function (fa, b, f) { return pipe(fa, es6_These_reduce(b, f)); };
/* istanbul ignore next */
var These_foldMap = function (M) {
    var foldMapM = es6_These_foldMap(M);
    return function (fa, f) { return pipe(fa, foldMapM(f)); };
};
/* istanbul ignore next */
var These_reduceRight = function (fa, b, f) { return pipe(fa, es6_These_reduceRight(b, f)); };
/* istanbul ignore next */
var These_traverse = function (F) {
    var traverseF = es6_These_traverse(F);
    return function (ta, f) { return pipe(ta, traverseF(f)); };
};
// -------------------------------------------------------------------------------------
// type class members
// -------------------------------------------------------------------------------------
/**
 * Map a pair of functions over the two type arguments of the bifunctor.
 *
 * @category Bifunctor
 * @since 2.0.0
 */
var es6_These_bimap = function (f, g) { return function (fa) {
    return These_isLeft(fa) ? These_left(f(fa.left)) : These_isRight(fa) ? These_right(g(fa.right)) : both(f(fa.left), g(fa.right));
}; };
/**
 * Map a function over the first type argument of a bifunctor.
 *
 * @category Bifunctor
 * @since 2.0.0
 */
var es6_These_mapLeft = function (f) { return function (fa) {
    return These_isLeft(fa) ? These_left(f(fa.left)) : isBoth(fa) ? both(f(fa.left), fa.right) : fa;
}; };
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @category Functor
 * @since 2.0.0
 */
var es6_These_map = function (f) { return function (fa) {
    return These_isLeft(fa) ? fa : These_isRight(fa) ? These_right(f(fa.right)) : both(fa.left, f(fa.right));
}; };
/**
 * @category Foldable
 * @since 2.0.0
 */
var es6_These_reduce = function (b, f) { return function (fa) {
    return These_isLeft(fa) ? b : f(b, fa.right);
}; };
/**
 * @category Foldable
 * @since 2.0.0
 */
var es6_These_foldMap = function (M) { return function (f) { return function (fa) {
    return These_isLeft(fa) ? M.empty : f(fa.right);
}; }; };
/**
 * @category Foldable
 * @since 2.0.0
 */
var es6_These_reduceRight = function (b, f) { return function (fa) {
    return These_isLeft(fa) ? b : f(fa.right, b);
}; };
/**
 * @since 2.6.3
 */
var es6_These_traverse = function (F) { return function (f) { return function (ta) {
    return These_isLeft(ta) ? F.of(ta) : These_isRight(ta) ? F.map(f(ta.right), These_right) : F.map(f(ta.right), function (b) { return both(ta.left, b); });
}; }; };
/**
 * @since 2.6.3
 */
var These_sequence = function (F) { return function (ta) {
    return These_isLeft(ta) ? F.of(ta) : These_isRight(ta) ? F.map(ta.right, These_right) : F.map(ta.right, function (b) { return both(ta.left, b); });
}; };
/**
 * @category Pointed
 * @since 2.0.0
 */
var These_of = These_right;
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 2.0.0
 */
var These_URI = 'These';
/**
 * @category instances
 * @since 2.7.0
 */
var These_Functor = {
    URI: These_URI,
    map: These_map
};
/**
 * Derivable from `Functor`.
 *
 * @category combinators
 * @since 2.10.0
 */
var These_flap = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (flap_(These_Functor)));
/**
 * @category instances
 * @since 2.10.0
 */
var These_Pointed = {
    URI: These_URI,
    of: These_of
};
/**
 * @category instances
 * @since 2.7.0
 */
var These_Bifunctor = {
    URI: These_URI,
    bimap: These_bimap,
    mapLeft: These_mapLeft
};
/**
 * @category instances
 * @since 2.11.0
 */
var FromThese = {
    URI: These_URI,
    fromThese: function_identity
};
/**
 * @category instances
 * @since 2.7.0
 */
var These_Foldable = {
    URI: These_URI,
    reduce: These_reduce,
    foldMap: These_foldMap,
    reduceRight: These_reduceRight
};
/**
 * @category instances
 * @since 2.7.0
 */
var These_Traversable = {
    URI: These_URI,
    map: These_map,
    reduce: These_reduce,
    foldMap: These_foldMap,
    reduceRight: These_reduceRight,
    traverse: These_traverse,
    sequence: These_sequence
};
/**
 * @category instances
 * @since 2.10.0
 */
var These_FromEither = {
    URI: These_URI,
    fromEither: function_identity
};
/**
 * @category natural transformations
 * @since 2.10.0
 */
var These_fromOption = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (fromOption_(These_FromEither)));
/**
 * @category combinators
 * @since 2.10.0
 */
var These_fromOptionK = 
/*#__PURE__*/
(/* unused pure expression or super */ null && (fromOptionK_(These_FromEither)));
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */
var These_elem = function (E) { return function (a) { return function (ma) {
    return These_isLeft(ma) ? false : E.equals(a, ma.right);
}; }; };
/**
 * @since 2.11.0
 */
var These_exists = function (predicate) { return function (ma) {
    return These_isLeft(ma) ? false : predicate(ma.right);
}; };
/**
 * @example
 * import { toTuple2, left, right, both } from 'fp-ts/These'
 *
 * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(left('b')), ['b', 1])
 * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(right(2)), ['a', 2])
 * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(both('b', 2)), ['b', 2])
 *
 * @since 2.10.0
 */
var toTuple2 = function (e, a) { return function (fa) {
    return These_isLeft(fa) ? [fa.left, a()] : These_isRight(fa) ? [e(), fa.right] : [fa.left, fa.right];
}; };
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use [`toTuple2`](#totuple2) instead.
 *
 * @since 2.0.0
 * @deprecated
 */
var toTuple = function (e, a) {
    return toTuple2(function () { return e; }, function () { return a; });
};
// -------------------------------------------------------------------------------------
// sequence T
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */
var These_ApT = 
/*#__PURE__*/
These_of(emptyReadonlyArray);
// -------------------------------------------------------------------------------------
// array utils
// -------------------------------------------------------------------------------------
/**
 * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(getApplicative(S))`.
 *
 * @since 2.11.0
 */
var These_traverseReadonlyNonEmptyArrayWithIndex = function (S) { return function (f) { return function (as) {
    var e = _.none;
    var t = f(0, _.head(as));
    if (These_isLeft(t)) {
        return t;
    }
    if (isBoth(t)) {
        e = _.some(t.left);
    }
    var out = [t.right];
    for (var i = 1; i < as.length; i++) {
        var t_1 = f(i, as[i]);
        if (These_isLeft(t_1)) {
            return t_1;
        }
        if (isBoth(t_1)) {
            e = _.isNone(e) ? _.some(t_1.left) : _.some(S.concat(e.value, t_1.left));
        }
        out.push(t_1.right);
    }
    return _.isNone(e) ? These_right(out) : both(e.value, out);
}; }; };
/**
 * Equivalent to `ReadonlyArray#traverseWithIndex(getApplicative(S))`.
 *
 * @since 2.11.0
 */
var These_traverseReadonlyArrayWithIndex = function (S) { return function (f) {
    var g = These_traverseReadonlyNonEmptyArrayWithIndex(S)(f);
    return function (as) { return (_.isNonEmpty(as) ? g(as) : These_ApT); };
}; };
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use small, specific instances instead.
 *
 * @category instances
 * @since 2.0.0
 * @deprecated
 */
var these = {
    URI: These_URI,
    map: These_map,
    bimap: These_bimap,
    mapLeft: These_mapLeft,
    reduce: These_reduce,
    foldMap: These_foldMap,
    reduceRight: These_reduceRight,
    traverse: These_traverse,
    sequence: These_sequence
};

;// CONCATENATED MODULE: ./src/util/playAudio.ts
// using web audio api play sound
let context;

const playAudio = async (arrayBuffer, volume = 1) => {
  // https://goo.gl/7K7WLu
  context = context || new AudioContext();

  if (context.state === 'suspended') {
    await context.resume();
  } // make a copy because decodeAudioData detaches arrayBuffer


  const arrayBufferCopy = arrayBuffer.slice(0);
  const audioBuffer = await context.decodeAudioData(arrayBufferCopy); // decode source

  const source = context.createBufferSource();
  source.buffer = audioBuffer; // volumn filter

  const volumnGainNode = context.createGain();
  volumnGainNode.gain.value = volume; // connect them

  source.connect(volumnGainNode);
  volumnGainNode.connect(context.destination);
  source.start();
};

/* harmony default export */ const util_playAudio = (playAudio);
;// CONCATENATED MODULE: ./src/service/audioCache/index.ts

const audioMap = new Map();

const audioCache_has = key => audioMap.has(key);

const play = (key, p1, p2) => {
  const buffer = p1 instanceof ArrayBuffer ? p1 : null;
  const volume = typeof p1 === 'number' ? p1 : p2 !== null && p2 !== void 0 ? p2 : 1;

  if (buffer) {
    audioMap.set(key, buffer);
    util_playAudio(buffer, volume);
    return true;
  }

  const cachedBuffer = audioMap.get(key);

  if (cachedBuffer) {
    util_playAudio(cachedBuffer, volume);
    return true;
  }

  return false;
};

const audioCacheService = {
  has: audioCache_has,
  play
};
;// CONCATENATED MODULE: ./src/provider/Iciba/playAudio.ts



const playAudio_playAudio = async url => {
  if (!url) {
    return;
  }

  const volume = 0.6;

  if (audioCacheService.has(url)) {
    audioCacheService.play(url, volume);
    return;
  }

  const response = await got({
    method: 'GET',
    responseType: 'arraybuffer',
    url
  });

  if (These_isRight(response)) {
    audioCacheService.play(url, response.right.response, volume);
  }
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/Iciba/container/components/pronunciation-item.vue?vue&type=template&id=267555b4&scoped=true&ts=true


const pronunciation_itemvue_type_template_id_267555b4_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-267555b4"), n = n(), _popScopeId(), n);

const pronunciation_itemvue_type_template_id_267555b4_scoped_true_ts_true_hoisted_1 = {
  class: "pronunciation-item flex items-center"
};
const pronunciation_itemvue_type_template_id_267555b4_scoped_true_ts_true_hoisted_2 = [".textContent"];
const pronunciation_itemvue_type_template_id_267555b4_scoped_true_ts_true_hoisted_3 = {
  key: 1,
  class: "ipa text-grey-700 text-12 mr-1"
};
function pronunciation_itemvue_type_template_id_267555b4_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  return openBlock(), createElementBlock("div", pronunciation_itemvue_type_template_id_267555b4_scoped_true_ts_true_hoisted_1, [_ctx.type ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "ipa-type-name text-grey-600 mr-1 text-12",
    ".textContent": _ctx.type
  }, null, 8, pronunciation_itemvue_type_template_id_267555b4_scoped_true_ts_true_hoisted_2)) : createCommentVNode("", true), _ctx.ipa !== '[]' ? (openBlock(), createElementBlock("div", pronunciation_itemvue_type_template_id_267555b4_scoped_true_ts_true_hoisted_3, toDisplayString(_ctx.ipa), 1)) : createCommentVNode("", true), createBaseVNode("div", {
    class: "play-sound flex flex-center",
    onClick: _cache[0] || (_cache[0] = //@ts-ignore
    (...args) => _ctx.handlePlay && _ctx.handlePlay(...args))
  }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
    svg: _ctx.icon.play
  }, null, 8, ["svg"])])]);
}
;// CONCATENATED MODULE: ./src/provider/Iciba/container/components/pronunciation-item.vue?vue&type=template&id=267555b4&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/Iciba/container/components/pronunciation-item.ts?vue&type=script&lang=ts



/* harmony default export */ const pronunciation_itemvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'IcibaPronunciation',
  components: {
    Scrollable: Scrollable
  },
  props: {
    ipa: {
      type: String,
      required: true
    },
    type: {
      type: String,
      default: ''
    }
  },
  setup: (props, ctx) => {
    const handlePlay = () => {
      ctx.emit('play');
    };

    return {
      props,
      handlePlay,
      icon: {
        play: speaker_filled_audio_tool_59284
      }
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/Iciba/container/components/pronunciation-item.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/Iciba/container/components/pronunciation-item.sass?vue&type=style&index=0&id=267555b4&lang=sass&scoped=true
var pronunciation_itemvue_type_style_index_0_id_267555b4_lang_sass_scoped_true = __webpack_require__(8122);
;// CONCATENATED MODULE: ./src/provider/Iciba/container/components/pronunciation-item.sass?vue&type=style&index=0&id=267555b4&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/Iciba/container/components/pronunciation-item.vue




;


const pronunciation_item_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(pronunciation_itemvue_type_script_lang_ts, [['render',pronunciation_itemvue_type_template_id_267555b4_scoped_true_ts_true_render],['__scopeId',"data-v-267555b4"]])

/* harmony default export */ const pronunciation_item = (pronunciation_item_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/Iciba/container/index.ts?vue&type=script&lang=ts









const isBaseInfoBaseInfoNormal = p => !!p && 'translate_type' in p && !('translate_result' in p);

const isBaseInfoTranslate = p => !!p && 'translate_type' in p && 'translate_result' in p;

const isBaseInfoSuggestion = p => !!p && 'translate_type' in p && 'suggest' in p;

const normalizeCiyi = p => typeof p === 'string' ? [p] : p;

const isSymbolCN = p => 'word_symbol' in p;

const isSymbolEN = p => !('word_symbol' in p);

/* harmony default export */ const containervue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'IcibaContainer',
  components: {
    IcibaPronunciation: pronunciation_item,
    Scrollable: Scrollable
  },
  setup: () => {
    const seperateChineseJieshi = s => {
      const match = /[（(](.{1,3})[）)](.+)/.exec(s);

      if (match) {
        return [match[1], match[2]];
      }

      return ['', s];
    };

    const handleSuggestionClick = word => {
      bus.emit({
        type: EVENTS.TRANSLATE,
        word,
        param: {
          provider: IcibaProvider.id
        }
      });
    };

    const handlePlay = url => {
      if (!url) {
        return;
      }

      playAudio_playAudio(url);
    };

    return {
      icon: {
        play_speaker_filled_audio_tool_59284: speaker_filled_audio_tool_59284
      },
      isBaseInfoBaseInfoNormal,
      isBaseInfoTranslate,
      isBaseInfoSuggestion,
      isSymbolCN,
      isSymbolEN,
      handlePlay,
      handleSuggestionClick,
      result: runtime_core_esm_bundler_computed(() => containerData.data),
      seperateChineseJieshi,
      normalizeCiyi
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/Iciba/container/index.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/Iciba/container/index.sass?vue&type=style&index=0&id=08018802&lang=sass&scoped=true
var containervue_type_style_index_0_id_08018802_lang_sass_scoped_true = __webpack_require__(5112);
;// CONCATENATED MODULE: ./src/provider/Iciba/container/index.sass?vue&type=style&index=0&id=08018802&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/Iciba/container/index.vue




;


const container_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(containervue_type_script_lang_ts, [['render',containervue_type_template_id_08018802_scoped_true_ts_true_render],['__scopeId',"data-v-08018802"]])

/* harmony default export */ const container = (container_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/Iciba/settings/index.vue?vue&type=template&id=7b4ed053&ts=true

const settingsvue_type_template_id_7b4ed053_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};
function settingsvue_type_template_id_7b4ed053_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_provider_common = resolveComponent("provider-common");

  const _component_i_checkbox_line = resolveComponent("i-checkbox-line");

  return openBlock(), createElementBlock("div", settingsvue_type_template_id_7b4ed053_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_provider_common, {
    icon: _ctx.form.icon,
    "onUpdate:icon": _cache[0] || (_cache[0] = $event => _ctx.form.icon = $event),
    display: _ctx.form.display,
    "onUpdate:display": _cache[1] || (_cache[1] = $event => _ctx.form.display = $event),
    "enable-hotkey": _ctx.form.enableHotkey,
    "onUpdate:enable-hotkey": _cache[2] || (_cache[2] = $event => _ctx.form.enableHotkey = $event),
    hotkey: _ctx.form.hotkey,
    "onUpdate:hotkey": _cache[3] || (_cache[3] = $event => _ctx.form.hotkey = $event),
    name: "iciba",
    icons: _ctx.iconOptions
  }, null, 8, ["icon", "display", "enable-hotkey", "hotkey", "icons"]), runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
    modelValue: _ctx.form.lowerCaseCapital,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => _ctx.form.lowerCaseCapital = $event),
    label: "查词首字母转换小写",
    text: "查词的单词首字母自动转换为小写"
  }, null, 8, ["modelValue"])]);
}
;// CONCATENATED MODULE: ./src/provider/Iciba/settings/index.vue?vue&type=template&id=7b4ed053&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/providerCommon/providerCommon.vue?vue&type=template&id=69ebbc9e&ts=true

const providerCommonvue_type_template_id_69ebbc9e_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};

const providerCommonvue_type_template_id_69ebbc9e_ts_true_hoisted_2 = /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-1 mb-0"
}, " 按钮图标 ", -1);

const providerCommonvue_type_template_id_69ebbc9e_ts_true_hoisted_3 = {
  class: "text-14 text-grey-400 mb-0"
};
function providerCommonvue_type_template_id_69ebbc9e_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_radio_group = resolveComponent("icon-radio-group");

  const _component_i_checkbox_line = resolveComponent("i-checkbox-line");

  const _component_i_hotkey_input = resolveComponent("i-hotkey-input");

  const _component_foldable = resolveComponent("foldable");

  return openBlock(), createElementBlock("div", providerCommonvue_type_template_id_69ebbc9e_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_icon_radio_group, {
    "model-value": _ctx.props.icon,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.handleUpdateIcon($event)),
    icons: _ctx.props.icons
  }, null, 8, ["model-value", "icons"]), providerCommonvue_type_template_id_69ebbc9e_ts_true_hoisted_2, runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
    "model-value": _ctx.props.display,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => _ctx.handleUpdateDisplay($event)),
    label: "显示按钮",
    text: "输入框右侧显示按钮图标"
  }, null, 8, ["model-value"]), runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
    "model-value": _ctx.props.enableHotkey,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => _ctx.handleUpdateEnableHotkey($event)),
    label: "启用热键翻译",
    text: ""
  }, null, 8, ["model-value"]), runtime_core_esm_bundler_createVNode(_component_foldable, {
    fold: !_ctx.props.enableHotkey
  }, {
    default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_i_hotkey_input, {
      class: "my-1",
      "model-value": _ctx.props.hotkey,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => _ctx.handleUpdateHotkey($event))
    }, null, 8, ["model-value"])]),
    _: 1
  }, 8, ["fold"]), createBaseVNode("p", providerCommonvue_type_template_id_69ebbc9e_ts_true_hoisted_3, " 选中文本后按下热键使用 " + toDisplayString(_ctx.props.name) + " 查词 ", 1)]);
}
;// CONCATENATED MODULE: ./src/components/providerCommon/providerCommon.vue?vue&type=template&id=69ebbc9e&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/Foldable/Foldable.vue?vue&type=template&id=6ee37b54&ts=true

function Foldablevue_type_template_id_6ee37b54_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "w-full overflow-hidden",
    ref: _ctx.refs.root,
    style: normalizeStyle({
      height: _ctx.state.height
    })
  }, [createBaseVNode("div", {
    class: "flex-col",
    ref: _ctx.refs.wrapper
  }, [renderSlot(_ctx.$slots, "default")], 512)], 4);
}
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/Foldable/Foldable.ts?vue&type=script&lang=ts

/* harmony default export */ const Foldablevue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GFoldable',
  props: {
    fold: {
      type: Boolean,
      default: false
    },
    duration: {
      type: Number,
      default: 300
    }
  },
  setup: props => {
    const refs = {
      root: reactivity_esm_bundler_ref(),
      wrapper: reactivity_esm_bundler_ref()
    };
    const state = reactivity_esm_bundler_reactive({
      height: props.fold ? '0' : 'auto'
    });

    const doFold = () => {
      if (!refs.root.value || !refs.wrapper.value) {
        return;
      }

      state.height = 'auto';
      refs.root.value.animate([{
        height: `${refs.wrapper.value.clientHeight}px`
      }, {
        height: '0'
      }], {
        duration: props.duration,
        easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
      });
      state.height = '0';
    };

    const doExpand = () => {
      if (!refs.root.value || !refs.wrapper.value) {
        return;
      }

      state.height = 'auto';
      const full = refs.wrapper.value.clientHeight;
      state.height = '0';
      refs.root.value.animate([{
        height: '0px'
      }, {
        height: `${full}px`
      }], {
        duration: props.duration,
        easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
      });
      state.height = 'auto';
    };

    watch(() => props.fold, () => {
      if (props.fold) {
        doFold();
      } else {
        doExpand();
      }
    });
    return {
      props,
      refs,
      state
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/Foldable/Foldable.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/components/Foldable/Foldable.vue




;
const Foldable_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Foldablevue_type_script_lang_ts, [['render',Foldablevue_type_template_id_6ee37b54_ts_true_render]])

/* harmony default export */ const Foldable_Foldable = (Foldable_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/IconRadioGroup/IconRadioGroup.vue?vue&type=template&id=fc866c20&scoped=true&ts=true


const IconRadioGroupvue_type_template_id_fc866c20_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-fc866c20"), n = n(), _popScopeId(), n);

const IconRadioGroupvue_type_template_id_fc866c20_scoped_true_ts_true_hoisted_1 = {
  class: "icon-radio flex select-none"
};
const IconRadioGroupvue_type_template_id_fc866c20_scoped_true_ts_true_hoisted_2 = ["onClick"];
const IconRadioGroupvue_type_template_id_fc866c20_scoped_true_ts_true_hoisted_3 = {
  key: 1,
  class: "check-icon absolute rounded-full bg-white text-20"
};
function IconRadioGroupvue_type_template_id_fc866c20_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  return openBlock(), createElementBlock("div", IconRadioGroupvue_type_template_id_fc866c20_scoped_true_ts_true_hoisted_1, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.props.icons, icon => {
    return openBlock(), createElementBlock("div", {
      class: "icon-box flex relative p-2 grow-0",
      key: icon.key,
      onClick: $event => _ctx.handleSelect(icon.key)
    }, [icon.icon ? (openBlock(), createBlock(_component_i_icon, {
      key: 0,
      size: "100%",
      svg: icon.icon
    }, null, 8, ["svg"])) : createCommentVNode("", true), renderSlot(_ctx.$slots, icon.key, {}, undefined, true), icon.key === _ctx.props.modelValue ? (openBlock(), createElementBlock("div", IconRadioGroupvue_type_template_id_fc866c20_scoped_true_ts_true_hoisted_3, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
      size: "20",
      svg: _ctx.checkedIconSvg
    }, null, 8, ["svg"])])) : createCommentVNode("", true)], 8, IconRadioGroupvue_type_template_id_fc866c20_scoped_true_ts_true_hoisted_2);
  }), 128))]);
}
;// CONCATENATED MODULE: ./src/components/IconRadioGroup/IconRadioGroup.vue?vue&type=template&id=fc866c20&scoped=true&ts=true

;// CONCATENATED MODULE: ./src/assets/img/checked_291201.svg
/* harmony default export */ const checked_291201 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 426.667 426.667\"><path d=\"M213.333 0C95.518 0 0 95.514 0 213.333s95.518 213.333 213.333 213.333c117.828 0 213.333-95.514 213.333-213.333S331.157 0 213.333 0zm-39.134 322.918l-93.935-93.931 31.309-31.309 62.626 62.622 140.894-140.898 31.309 31.309-172.203 172.207z\" fill=\"#80bf40\"/></svg>\n");
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/IconRadioGroup/IconRadioGroup.ts?vue&type=script&lang=ts


/* harmony default export */ const IconRadioGroupvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  props: {
    modelValue: {
      type: String,
      required: true
    },
    icons: {
      type: null,
      required: true
    }
  },
  setup: (props, context) => {
    const handleSelect = key => {
      context.emit('update:modelValue', key);
    };

    return {
      props,
      handleSelect,
      checkedIconSvg: checked_291201
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/IconRadioGroup/IconRadioGroup.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/IconRadioGroup/IconRadioGroup.sass?vue&type=style&index=0&id=fc866c20&lang=sass&scoped=true
var IconRadioGroupvue_type_style_index_0_id_fc866c20_lang_sass_scoped_true = __webpack_require__(3959);
;// CONCATENATED MODULE: ./src/components/IconRadioGroup/IconRadioGroup.sass?vue&type=style&index=0&id=fc866c20&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/components/IconRadioGroup/IconRadioGroup.vue




;


const IconRadioGroup_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(IconRadioGroupvue_type_script_lang_ts, [['render',IconRadioGroupvue_type_template_id_fc866c20_scoped_true_ts_true_render],['__scopeId',"data-v-fc866c20"]])

/* harmony default export */ const IconRadioGroup = (IconRadioGroup_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/providerCommon/providerCommon.ts?vue&type=script&lang=ts



/* harmony default export */ const providerCommonvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'ProviderCommon',
  components: {
    Foldable: Foldable_Foldable,
    IconRadioGroup: IconRadioGroup
  },
  props: {
    display: Boolean,
    enableHotkey: Boolean,
    icon: null,
    hotkey: null,
    name: {
      type: String,
      required: true
    },
    icons: {
      type: null,
      required: true
    }
  },
  setup: (props, ctx) => {
    const handleUpdateIcon = icon => {
      ctx.emit('update:icon', icon);
    };

    const handleUpdateDisplay = display => {
      ctx.emit('update:display', display);
    };

    const handleUpdateEnableHotkey = enableHotkey => {
      ctx.emit('update:enableHotkey', enableHotkey);
    };

    const handleUpdateHotkey = hotkey => {
      ctx.emit('update:hotkey', hotkey);
    };

    return {
      props,
      handleUpdateIcon,
      handleUpdateDisplay,
      handleUpdateEnableHotkey,
      handleUpdateHotkey
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/providerCommon/providerCommon.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/components/providerCommon/providerCommon.vue




;
const providerCommon_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(providerCommonvue_type_script_lang_ts, [['render',providerCommonvue_type_template_id_69ebbc9e_ts_true_render]])

/* harmony default export */ const providerCommon = (providerCommon_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/Iciba/settings/index.ts?vue&type=script&lang=ts




const iconOptions = Object.entries(icons).map(([k, v]) => ({
  icon: v,
  key: k
}));
/* harmony default export */ const settingsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'IcibaSettings',
  components: {
    ProviderCommon: providerCommon
  },
  setup: () => ({
    form: store.data,
    iconOptions
  })
}));
;// CONCATENATED MODULE: ./src/provider/Iciba/settings/index.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/Iciba/settings/index.vue




;
const settings_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(settingsvue_type_script_lang_ts, [['render',settingsvue_type_template_id_7b4ed053_ts_true_render]])

/* harmony default export */ const settings = (settings_exports_);
;// CONCATENATED MODULE: ./src/provider/Iciba/index.ts






const IcibaProvider = createProvider({
  id: 'ICIBA',
  label: 'Iciba',
  translate: translate,
  translateView: container,
  settingView: settings,
  icons: icons,
  storeWrapper: store,
  storeType: storeType,
  defaultStore: defaultStore
});
// EXTERNAL MODULE: ./node_modules/core-js-pure/stable/url-search-params/index.js
var url_search_params = __webpack_require__(5765);
var url_search_params_default = /*#__PURE__*/__webpack_require__.n(url_search_params);
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/data.ts

const data_containerData = reactivity_esm_bundler_reactive({
  data: null,
  word: ''
});
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/container/data.ts

const data = {
  data: null,
  inputText: ''
};
/* harmony default export */ const container_data = (reactivity_esm_bundler_reactive(data));
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/googleLanguages.ts
var GOOGLE_LANGUAGES;

(function (GOOGLE_LANGUAGES) {
  GOOGLE_LANGUAGES["de"] = "de";
  GOOGLE_LANGUAGES["es"] = "es";
  GOOGLE_LANGUAGES["fr"] = "fr";
  GOOGLE_LANGUAGES["it"] = "it";
  GOOGLE_LANGUAGES["ja"] = "ja";
  GOOGLE_LANGUAGES["ru"] = "ru";
  GOOGLE_LANGUAGES["zh"] = "zh-CN";
  GOOGLE_LANGUAGES["en"] = "en";
})(GOOGLE_LANGUAGES || (GOOGLE_LANGUAGES = {}));

const GOOGLE_LANGUAGE_MAP = {
  [GOOGLE_LANGUAGES.de]: '德语',
  [GOOGLE_LANGUAGES.es]: '西班牙语',
  [GOOGLE_LANGUAGES.fr]: '法语',
  [GOOGLE_LANGUAGES.it]: '意大利语',
  [GOOGLE_LANGUAGES.ja]: '日语',
  [GOOGLE_LANGUAGES.ru]: '俄语',
  [GOOGLE_LANGUAGES.en]: '英语',
  [GOOGLE_LANGUAGES.zh]: '中文'
};
const googleLanguagesOptions = Object.entries(GOOGLE_LANGUAGE_MAP).map(([k, v]) => ({
  text: v,
  key: k
})); // languages
// [
//   {
//     key: 'af',
//     text: 'Afrikaans',
//   },
//   {
//     key: 'sq',
//     text: 'Albanian',
//   },
//   {
//     key: 'am',
//     text: 'Amharic',
//   },
//   {
//     key: 'ar',
//     text: 'Arabic',
//   },
//   {
//     key: 'hy',
//     text: 'Armenian',
//   },
//   {
//     key: 'az',
//     text: 'Azerbaijani',
//   },
//   {
//     key: 'eu',
//     text: 'Basque',
//   },
//   {
//     key: 'be',
//     text: 'Belarusian',
//   },
//   {
//     key: 'bn',
//     text: 'Bengali',
//   },
//   {
//     key: 'bs',
//     text: 'Bosnian',
//   },
//   {
//     key: 'bg',
//     text: 'Bulgarian',
//   },
//   {
//     key: 'ca',
//     text: 'Catalan',
//   },
//   {
//     key: 'ceb',
//     text: 'Cebuano',
//   },
//   {
//     key: 'ny',
//     text: 'Chichewa',
//   },
//   {
//     key: 'zh-CN',
//     text: 'Chinese',
//   },
//   {
//     key: 'co',
//     text: 'Corsican',
//   },
//   {
//     key: 'hr',
//     text: 'Croatian',
//   },
//   {
//     key: 'cs',
//     text: 'Czech',
//   },
//   {
//     key: 'da',
//     text: 'Danish',
//   },
//   {
//     key: 'nl',
//     text: 'Dutch',
//   },
//   {
//     key: 'en',
//     text: 'English',
//   },
//   {
//     key: 'eo',
//     text: 'Esperanto',
//   },
//   {
//     key: 'et',
//     text: 'Estonian',
//   },
//   {
//     key: 'tl',
//     text: 'Filipino',
//   },
//   {
//     key: 'fi',
//     text: 'Finnish',
//   },
//   {
//     key: 'fr',
//     text: 'French',
//   },
//   {
//     key: 'fy',
//     text: 'Frisian',
//   },
//   {
//     key: 'gl',
//     text: 'Galician',
//   },
//   {
//     key: 'ka',
//     text: 'Georgian',
//   },
//   {
//     key: 'de',
//     text: 'German',
//   },
//   {
//     key: 'el',
//     text: 'Greek',
//   },
//   {
//     key: 'gu',
//     text: 'Gujarati',
//   },
//   {
//     key: 'ht',
//     text: 'Haitian Creole',
//   },
//   {
//     key: 'ha',
//     text: 'Hausa',
//   },
//   {
//     key: 'haw',
//     text: 'Hawaiian',
//   },
//   {
//     key: 'iw',
//     text: 'Hebrew',
//   },
//   {
//     key: 'hi',
//     text: 'Hindi',
//   },
//   {
//     key: 'hmn',
//     text: 'Hmong',
//   },
//   {
//     key: 'hu',
//     text: 'Hungarian',
//   },
//   {
//     key: 'is',
//     text: 'Icelandic',
//   },
//   {
//     key: 'ig',
//     text: 'Igbo',
//   },
//   {
//     key: 'id',
//     text: 'Indonesian',
//   },
//   {
//     key: 'ga',
//     text: 'Irish',
//   },
//   {
//     key: 'it',
//     text: 'Italian',
//   },
//   {
//     key: 'ja',
//     text: 'Japanese',
//   },
//   {
//     key: 'jw',
//     text: 'Javanese',
//   },
//   {
//     key: 'kn',
//     text: 'Kannada',
//   },
//   {
//     key: 'kk',
//     text: 'Kazakh',
//   },
//   {
//     key: 'km',
//     text: 'Khmer',
//   },
//   {
//     key: 'ko',
//     text: 'Korean',
//   },
//   {
//     key: 'ku',
//     text: 'Kurdish (Kurmanji)',
//   },
//   {
//     key: 'ky',
//     text: 'Kyrgyz',
//   },
//   {
//     key: 'lo',
//     text: 'Lao',
//   },
//   {
//     key: 'la',
//     text: 'Latin',
//   },
//   {
//     key: 'lv',
//     text: 'Latvian',
//   },
//   {
//     key: 'lt',
//     text: 'Lithuanian',
//   },
//   {
//     key: 'lb',
//     text: 'Luxembourgish',
//   },
//   {
//     key: 'mk',
//     text: 'Macedonian',
//   },
//   {
//     key: 'mg',
//     text: 'Malagasy',
//   },
//   {
//     key: 'ms',
//     text: 'Malay',
//   },
//   {
//     key: 'ml',
//     text: 'Malayalam',
//   },
//   {
//     key: 'mt',
//     text: 'Maltese',
//   },
//   {
//     key: 'mi',
//     text: 'Maori',
//   },
//   {
//     key: 'mr',
//     text: 'Marathi',
//   },
//   {
//     key: 'mn',
//     text: 'Mongolian',
//   },
//   {
//     key: 'my',
//     text: 'Myanmar (Burmese)',
//   },
//   {
//     key: 'ne',
//     text: 'Nepali',
//   },
//   {
//     key: 'no',
//     text: 'Norwegian',
//   },
//   {
//     key: 'ps',
//     text: 'Pashto',
//   },
//   {
//     key: 'fa',
//     text: 'Persian',
//   },
//   {
//     key: 'pl',
//     text: 'Polish',
//   },
//   {
//     key: 'pt',
//     text: 'Portuguese',
//   },
//   {
//     key: 'pa',
//     text: 'Punjabi',
//   },
//   {
//     key: 'ro',
//     text: 'Romanian',
//   },
//   {
//     key: 'ru',
//     text: 'Russian',
//   },
//   {
//     key: 'sm',
//     text: 'Samoan',
//   },
//   {
//     key: 'gd',
//     text: 'Scots Gaelic',
//   },
//   {
//     key: 'sr',
//     text: 'Serbian',
//   },
//   {
//     key: 'st',
//     text: 'Sesotho',
//   },
//   {
//     key: 'sn',
//     text: 'Shona',
//   },
//   {
//     key: 'sd',
//     text: 'Sindhi',
//   },
//   {
//     key: 'si',
//     text: 'Sinhala',
//   },
//   {
//     key: 'sk',
//     text: 'Slovak',
//   },
//   {
//     key: 'sl',
//     text: 'Slovenian',
//   },
//   {
//     key: 'so',
//     text: 'Somali',
//   },
//   {
//     key: 'es',
//     text: 'Spanish',
//   },
//   {
//     key: 'su',
//     text: 'Sundanese',
//   },
//   {
//     key: 'sw',
//     text: 'Swahili',
//   },
//   {
//     key: 'sv',
//     text: 'Swedish',
//   },
//   {
//     key: 'tg',
//     text: 'Tajik',
//   },
//   {
//     key: 'ta',
//     text: 'Tamil',
//   },
//   {
//     key: 'te',
//     text: 'Telugu',
//   },
//   {
//     key: 'th',
//     text: 'Thai',
//   },
//   {
//     key: 'tr',
//     text: 'Turkish',
//   },
//   {
//     key: 'uk',
//     text: 'Ukrainian',
//   },
//   {
//     key: 'ur',
//     text: 'Urdu',
//   },
//   {
//     key: 'uz',
//     text: 'Uzbek',
//   },
//   {
//     key: 'vi',
//     text: 'Vietnamese',
//   },
//   {
//     key: 'cy',
//     text: 'Welsh',
//   },
//   {
//     key: 'xh',
//     text: 'Xhosa',
//   },
//   {
//     key: 'yi',
//     text: 'Yiddish',
//   },
//   {
//     key: 'yo',
//     text: 'Yoruba',
//   },
//   {
//     key: 'zu',
//     text: 'Zulu',
//   },
// ]
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/googleTranslate/type_2_translate_281776.svg
/* harmony default export */ const type_2_translate_281776 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><g fill=\"#e6e6e6\"><path d=\"M376.5 317c-9 12.5-19.4 25-30.8 36.5l-39.4-118.9H423.1s-16.5 41-46.6 82.5z\"/><path d=\"M376.5 317c30.1-41.4 46.6-82.4 46.6-82.4H306.3l-43.8-132.3h207.8a31.6 31.6 0 0 1 31.7 31.6v332.4a31.6 31.6 0 0 1-31.7 31.7H281.4l82.9-88.3-18.6-56.2c11.4-11.4 21.8-24 30.8-36.4z\"/></g><path fill=\"#3a5bbc\" d=\"M364.3 409.7L281.4 498 252 409.7z\"/><path d=\"M345.7 353.5l18.6 56.2H41.7A31.6 31.6 0 0 1 10 378.1V45.7A31.6 31.6 0 0 1 41.7 14h191.6l29.2 88.3 43.8 132.3 39.4 119z\" fill=\"#518ef8\"/><path d=\"M153.5 286.1A74.6 74.6 0 1 1 206.2 159a10 10 0 0 1-14.2 14.2 54.5 54.5 0 1 0 15 48.5h-53.5a10 10 0 0 1 0-20H218a10 10 0 0 1 10 10c0 41.1-33.4 74.5-74.5 74.5z\" fill=\"#fff\"/><path d=\"M470.3 92.2H269.7l-27-81.3a10 10 0 0 0-9.4-6.9H41.7C18.7 4 0 22.7 0 45.7V378c0 23 18.7 41.7 41.7 41.7h203.1l27 81.3a10 10 0 0 0 9.6 6.9h189c23 0 41.6-18.7 41.6-41.7V134c0-23-18.7-41.7-41.7-41.7zM20.1 378.1V45.7c0-12 9.6-21.6 21.6-21.6H226l110 332.3 14.4 43.3H41.7c-12 0-21.6-9.7-21.6-21.6zm387.5-133.5a442 442 0 0 1-31.7 55.8 859.6 859.6 0 0 1-22.2-28.9 10 10 0 1 0-16.2 11.8c.4.6 10.4 14.4 26.3 34-4.6 6-9.2 11.7-14 17l-29.6-89.7h87.4zM266 419.8h75.2l-55.5 59-19.7-59zm226 46.5c0 12-9.6 21.6-21.6 21.6H304.6l67-71.3a9.9 9.9 0 0 0 2.2-10l-16.7-50.4a312 312 0 0 0 19.8-23 803 803 0 0 0 45.8 50.2c2 2 4.5 3 7 3s5.2-1 7.2-3c3.9-4 3.9-10.3 0-14.2a795.9 795.9 0 0 1-47.7-52.6c21.2-30.6 35-59.6 40.5-72h21.5a10 10 0 0 0 0-20H385v-18a10 10 0 0 0-20 0v18h-51.5l-37.1-112.3h194c11.9 0 21.5 9.7 21.5 21.6v332.4z\" fill=\"#333\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/googleTranslate/type_2_translate_324121.svg
/* harmony default export */ const type_2_translate_324121 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path d=\"M185.8 105.7h277a38.7 38.7 0 0 1 38.7 38.7v318.5a38.7 38.7 0 0 1-38.6 38.7H280.5l-94.7-396z\" fill=\"#fff\"/><path fill=\"#0084ff\" d=\"M361.1 406.3l-80.6 95.2-31.7-95.2z\"/><path d=\"M361.1 406.3h-312a38.7 38.7 0 0 1-38.7-38.7V49.1a38.7 38.7 0 0 1 38.7-38.7h182.4l129.6 396z\" fill=\"#10bafc\"/><path d=\"M462.9 95.2H270.3l-28.8-88a10.5 10.5 0 0 0-10-7.2H49.1C22.1 0 0 22 0 49.1v318.5c0 27.1 22 49.2 49.1 49.2h192.2l29.3 88c1.4 4.3 5.4 7.2 9.9 7.2h182.4c27 0 49.1-22 49.1-49.1V144.4c0-27.1-22-49.2-49.1-49.2zm-442 272.4V49.1A28.3 28.3 0 0 1 49.1 21H224l122.7 375H49.1A28.3 28.3 0 0 1 21 367.6zm390.5-126.2a273 273 0 0 1-31.1 51 285.2 285.2 0 0 1-31.1-51h62.2zm-85 0a268 268 0 0 0 24 45.1c4.5 6.9 10 14.5 16.3 22.5-6 6.7-12.6 13.5-19.8 20.2l-28.8-87.8h8.3zm-63.1 175.4h75.3l-54 63.8-21.3-63.8zm227.8 46a28.3 28.3 0 0 1-28.2 28.3H303l66-77.8a10.4 10.4 0 0 0 1.9-10.9L354 351c9.8-8.5 18.5-17.2 26.3-25.8 17.6 19.4 40.5 40 69.8 57.9a10.4 10.4 0 0 0 14.4-3.5c3-4.9 1.5-11.3-3.5-14.3a297.9 297.9 0 0 1-67-56.2 282.2 282.2 0 0 0 40.2-67.6H465a10.4 10.4 0 0 0 0-21h-75v-17.7a10.4 10.4 0 0 0-20.8 0v17.8h-58l-34-104.4h185.7a28.3 28.3 0 0 1 28.2 28.3v318.5z\"/><path d=\"M147 286.4a77 77 0 0 0 77-77c0-5.7-4.6-10.4-10.4-10.4h-59.2a10.4 10.4 0 1 0 0 21h47.8a56.2 56.2 0 1 1-18.8-53.2 10.4 10.4 0 1 0 13.6-16 77 77 0 1 0-50 135.6zM201.6 351.4H197a10.4 10.4 0 0 0 0 21h4.7a10.4 10.4 0 0 0 0-21zM163.1 351.4H61.6a10.4 10.4 0 0 0 0 21h101.5a10.4 10.4 0 0 0 0-21z\"/></svg>\n");
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/icons.ts




const icons_icons = {
  type_1_translate_281759: type_1_translate_281759,
  type_2_translate_281776: type_2_translate_281776,
  type_2_translate_324121: type_2_translate_324121,
  type_3_google_814137: type_3_google_814137
};
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/store/index.ts


function GoogleTranslate_store_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function GoogleTranslate_store_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? GoogleTranslate_store_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : GoogleTranslate_store_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







const googleLanguage = enumType(GOOGLE_LANGUAGES, 'GOOGLE_LANGUAGES');
const store_storeType = fallbackInterface(GoogleTranslate_store_objectSpread(GoogleTranslate_store_objectSpread({}, providerCommonStore), {}, {
  icon: fallback(keyof(icons_icons), 'type_1_translate_281759'),
  display: fallback(es6_boolean, true),
  targetLanguage: fallback(googleLanguage, GOOGLE_LANGUAGES.zh),
  secondTargetLanguage: fallback(googleLanguage, GOOGLE_LANGUAGES.en),
  xsrfToken: fallback(string, '')
}));
const store_defaultStore = store_storeType.defaultData;
const store_store = {
  data: null
};
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/translate.ts


function translate_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function translate_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? translate_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : translate_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







const getGoogleTranslateResult = async p => {
  var _p$payload$sl, _p$payload, _p$payload$tl, _p$payload2, _p$payload3;

  const sourceLanguage = (_p$payload$sl = (_p$payload = p.payload) === null || _p$payload === void 0 ? void 0 : _p$payload.sl) !== null && _p$payload$sl !== void 0 ? _p$payload$sl : 'auto';
  const targetLanguage = (_p$payload$tl = (_p$payload2 = p.payload) === null || _p$payload2 === void 0 ? void 0 : _p$payload2.tl) !== null && _p$payload$tl !== void 0 ? _p$payload$tl : store_store.data.targetLanguage;

  const req = (__webpack_require__(8334)/* .stringify */ .P)([[['MkEWBc', JSON.stringify([[p.word, sourceLanguage, targetLanguage, true], [null]]), null, 'generic']]]);

  const apiDomain = 'translate.google.com';

  const doRequest = async (getToken = false) => {
    var _data$;

    const result = await got({
      url: `https://${apiDomain}/_/TranslateWebserverUi/data/batchexecute`,
      method: 'POST',
      headers: {
        'Referer': `https://${apiDomain}/`,
        'Cache-Control': 'max-age=0',
        'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'
      },
      data: new (url_search_params_default())(translate_objectSpread({
        'f.req': req
      }, getToken ? {} : {
        at: store_store.data.xsrfToken
      })).toString(),
      timeout: 5000 // responseType: '', // force auto json parse

    });

    if (Either_isLeft(result)) {
      try {
        const body = JSON.parse(result.left.res.responseText.substring(4));
        const err = body.find(v => v && v[0] === 'er');
        const errDetail = err[10][0][48448350];

        if (errDetail[0] === 'xsrf') {
          const xsrfToken = errDetail[1];
          store_store.data.xsrfToken = xsrfToken;
          return Either_left({
            type: 'xsrf',
            res: result.left.res
          });
        }
      } catch (e) {
        console.error(e);
      }

      return Either_left({
        type: result.left.type,
        res: result.left.res
      });
    }

    const data = JSON.parse(result.right.responseText.substring(4));

    if (((_data$ = data[0]) === null || _data$ === void 0 ? void 0 : _data$[1]) === 'MkEWBc') {
      return Either_right(JSON.parse(data[0][2]));
    }

    return Either_left({
      type: 'unknown',
      res: result.right
    });
  };

  let result = await doRequest();

  if (Either_isLeft(result) && result.left.res.status === 400) {
    await doRequest(true);
    result = await doRequest();
  }

  if (Either_isLeft(result)) {
    throw new Error(result.left.type);
  }

  const data = result.right;
  const o = {
    sourceLanguage,
    targetLanguage,
    detectedLanguage: data[0][2] || sourceLanguage,
    phon: data[0][0],
    // eslint-disable-next-line
    translate: data[1][0][0][5].map(v => ({
      text: v[0],
      variations: v[1]
    })),
    translatePhonetics: data[1][0][0][1],
    fromDict: !!((_p$payload3 = p.payload) !== null && _p$payload3 !== void 0 && _p$payload3.fromDict)
  };
  return o;
};

const translate_translate = async p => {
  try {
    let data = await getGoogleTranslateResult(p); // autodetected and fallback to secondTargetLanguage

    if (!p.payload && data.detectedLanguage === store_store.data.targetLanguage) {
      var _p$payload4;

      data = await getGoogleTranslateResult(translate_objectSpread(translate_objectSpread({}, p), {}, {
        payload: translate_objectSpread(translate_objectSpread({}, (_p$payload4 = p.payload) !== null && _p$payload4 !== void 0 ? _p$payload4 : {}), {}, {
          tl: store_store.data.secondTargetLanguage
        })
      }));
    }

    return Either_right(() => {
      container_data.data = data;
      container_data.inputText = p.word;
    });
  } catch (e) {
    return Either_left({
      message: e.message
    });
  }
}; // export const translate = async (p: GoogleTranslateParams) => {
//   const url = [
//     `https://translate.google.com/translate_a/single`,
//     '?client=at',
//     '&dt=t',  // return sentences
//     '&dt=rm', // add translit to sentences
//     '&dj=1',  // result as pretty json instead of deep nested arrays
//   ].join('');
//   const result = await got<any>({
//     url,
//     method: 'POST',
//     headers: {
//       'Referer': `https://translate.google.com/`,
//       'Cache-Control': 'max-age=0',
//       'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8',
//     },
//     data: new URLSearchParams({
//       'f.req': req,
//       ...getToken ? {} : {
//         at: store.data.xsrfToken,
//       },
//     }).toString(),
//     timeout: 5000,
//     // responseType: '', // force auto json parse
//   } as any)
// }
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleTranslate/container/index.vue?vue&type=template&id=29b37c76&scoped=true&ts=true


const containervue_type_template_id_29b37c76_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-29b37c76"), n = n(), popScopeId(), n);

const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_1 = {
  key: 0,
  class: "google-translate-box flex-col relative text-grey-900"
};
const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_2 = {
  class: "language-select-box w-full select-none"
};
const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_3 = {
  class: "flex justify-between"
};
const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_4 = {
  class: "items-box flex flex-wrap mt-1"
};
const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_5 = ["onClick"];
const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_6 = {
  class: "translate-content mb-2px"
};
const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_7 = {
  key: 0,
  class: "google-dict-tip mt-2px mb-3px text-12 text-right text-grey-400"
};
const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_8 = {
  class: "bottom-info-box flex justify-between"
};
const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_9 = {
  class: "tts-box flex select-none"
};

const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_10 = /*#__PURE__*/createTextVNode(" 源 ");

const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_11 = /*#__PURE__*/createTextVNode(" 译 ");

const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_12 = {
  class: "flex select-none text-grey-400"
};

const containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_13 = /*#__PURE__*/containervue_type_template_id_29b37c76_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "px-1"
}, " -> ", -1));

function containervue_type_template_id_29b37c76_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  const _component_Scrollable = resolveComponent("Scrollable");

  return _ctx.data ? (openBlock(), createElementBlock("div", containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_Scrollable, {
    class: "scroll-container"
  }, {
    default: withCtx(({
      scrollBar
    }) => [createBaseVNode("div", {
      class: normalizeClass(["content-box flex-col flex-auto text-14 break-words", [scrollBar && 'py-10px pl-10px pr-14px', !scrollBar && 'p-10px']])
    }, [withDirectives(createBaseVNode("div", containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_2, [createBaseVNode("div", containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_3, [withDirectives(createBaseVNode("div", null, "源语言", 512), [[vShow, _ctx.state.type === 'source']]), withDirectives(createBaseVNode("div", null, "翻译到", 512), [[vShow, _ctx.state.type === 'target']]), createBaseVNode("div", {
      class: "text-center text-grey-600 py-px px-6px cursor-pointer hover:bg-bg-2",
      onClick: _cache[0] || (_cache[0] = $event => _ctx.state.visible = false)
    }, " 取消 ")]), withDirectives(createBaseVNode("div", containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_4, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.languages, v => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass({
          'language-item text-center text-grey-600 cursor-pointer': true,
          'active text-grey-800': _ctx.state.type === 'source' ? v.id === _ctx.data.sourceLanguage : v.id === _ctx.data.targetLanguage
        }),
        key: v.id,
        onClick: $event => _ctx.handleLanguageSelect(v.id)
      }, toDisplayString(v.name), 11, containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_5);
    }), 128)), _ctx.state.type === 'source' ? (openBlock(), createElementBlock("div", {
      class: normalizeClass({
        'language-item text-center text-grey-600': true,
        'active text-grey-800': _ctx.data.sourceLanguage === 'auto'
      }),
      key: "auto",
      onClick: _cache[1] || (_cache[1] = $event => _ctx.handleLanguageSelect('auto'))
    }, " 自动检测 ", 2)) : createCommentVNode("", true)], 512), [[vShow, _ctx.state.visible]])], 512), [[vShow, _ctx.state.visible]]), withDirectives(createBaseVNode("div", containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_6, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.translateText, (text, index) => {
      return openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, null, [text ? (openBlock(), createElementBlock("span", {
        key: index
      }, toDisplayString(text), 1)) : createCommentVNode("", true), !text ? (openBlock(), createElementBlock("br", {
        key: index
      })) : createCommentVNode("", true)], 64);
    }), 256))], 512), [[vShow, !_ctx.state.visible]]), _ctx.data.fromDict ? (openBlock(), createElementBlock("div", containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_7, " google字典无结果，以上内容来自谷歌翻译 ")) : createCommentVNode("", true), withDirectives(createBaseVNode("div", containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_8, [createBaseVNode("div", containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_9, [createBaseVNode("div", {
      class: "play-sound flex flex-center cursor-pointer",
      onClick: _cache[2] || (_cache[2] = $event => _ctx.handlePlay('source'))
    }, [containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_10, runtime_core_esm_bundler_createVNode(_component_i_icon, {
      class: "audio-icon",
      svg: _ctx.icon.play_speaker_filled_audio_tool_59284
    }, null, 8, ["svg"])]), createBaseVNode("div", {
      class: "play-sound flex flex-center ml-2 cursor-pointer",
      onClick: _cache[3] || (_cache[3] = $event => _ctx.handlePlay('target'))
    }, [containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_11, runtime_core_esm_bundler_createVNode(_component_i_icon, {
      class: "audio-icon",
      svg: _ctx.icon.play_speaker_filled_audio_tool_59284
    }, null, 8, ["svg"])])]), createBaseVNode("div", containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_12, [createBaseVNode("div", {
      class: "cursor-pointer hover:text-primary",
      onClick: _cache[4] || (_cache[4] = $event => _ctx.showLanguageSelect('source'))
    }, toDisplayString(_ctx.getLanguage(_ctx.data.detectedLanguage)) + " " + toDisplayString(_ctx.data.sourceLanguage === 'auto' ? '(自动检测)' : ''), 1), containervue_type_template_id_29b37c76_scoped_true_ts_true_hoisted_13, createBaseVNode("div", {
      class: "cursor-pointer hover:text-primary",
      onClick: _cache[5] || (_cache[5] = $event => _ctx.showLanguageSelect('target'))
    }, toDisplayString(_ctx.getLanguage(_ctx.data.targetLanguage)), 1)])], 512), [[vShow, !_ctx.state.visible]])], 2)]),
    _: 1
  })])) : createCommentVNode("", true);
}
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/container/index.vue?vue&type=template&id=29b37c76&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js
/*
 * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
var encode = function (arraybuffer) {
    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    }
    else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
var decode = function (base64) {
    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return arraybuffer;
};



;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/playAudio.ts


function playAudio_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function playAudio_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? playAudio_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : playAudio_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







const GoogleTranslate_playAudio_playAudio = async (word, tl) => {
  const volume = 0.8;

  const req = (__webpack_require__(8334)/* .stringify */ .P)([[['jQ1olc', JSON.stringify([word, tl, // null: normal speed; true: slow mode
  null, 'null']), null, 'generic']]]);

  const doRequest = async (getToken = false) => {
    var _data$;

    const apiDomain = 'translate.google.com';
    const result = await got({
      url: `https://${apiDomain}/_/TranslateWebserverUi/data/batchexecute`,
      method: 'POST',
      headers: {
        'Referer': `https://${apiDomain}/`,
        'Cache-Control': 'max-age=0',
        'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'
      },
      data: new (url_search_params_default())(playAudio_objectSpread({
        'f.req': req
      }, getToken ? {} : {
        at: GoogleTranslateProvider.store.xsrfToken
      })).toString(),
      timeout: 5000 // responseType: '', // force auto json parse

    });

    if (Either_isLeft(result)) {
      const body = JSON.parse(result.left.res.responseText.substring(4));
      const err = body.find(v => v && v[0] === 'er');
      const errDetail = err[4];

      if (errDetail && errDetail[0] === 'xsrf') {
        const xsrfToken = errDetail[1];
        GoogleTranslateProvider.store.xsrfToken = xsrfToken;
        return Either_left({
          type: 'xsrf',
          res: result.left.res
        });
      }

      return Either_left({
        type: result.left.type,
        res: result.left.res
      });
    }

    const data = JSON.parse(result.right.responseText.substring(4));

    if (((_data$ = data[0]) === null || _data$ === void 0 ? void 0 : _data$[1]) === 'jQ1olc') {
      return Either_right(JSON.parse(data[0][2]));
    }

    return Either_left({
      type: 'unknown',
      res: result.right
    });
  };

  let result = await doRequest();

  if (Either_isLeft(result) && result.left.res.status === 400) {
    await doRequest(true);
    result = await doRequest();
  }

  if (Either_isRight(result)) {
    const base64Data = result.right[0];
    const audioBuffer = decode(base64Data);
    audioCacheService.play(`googletranslatetts-${word}-${tl}`, audioBuffer, volume);
  }
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleTranslate/container/index.ts?vue&type=script&lang=ts








const languages = Object.entries(GOOGLE_LANGUAGE_MAP).map(([id, name]) => ({
  id: id,
  name
}));
const containervue_type_script_lang_ts_icon = {
  play_speaker_filled_audio_tool_59284: speaker_filled_audio_tool_59284
};
/* harmony default export */ const GoogleTranslate_containervue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GoogleTranslateContainer',
  components: {
    Scrollable: Scrollable
  },
  setup: () => {
    const state = reactivity_esm_bundler_reactive({
      visible: false,
      type: 'source'
    });

    const getLanguage = language => GOOGLE_LANGUAGE_MAP[language] || language;

    const handleLanguageSelect = language => {
      bus.emit({
        type: EVENTS.TRANSLATE,
        word: container_data.inputText,
        param: {
          provider: GoogleTranslateProvider.id,
          param: {
            sl: state.type === 'source' ? language : container_data.data.sourceLanguage,
            tl: state.type === 'target' ? language : container_data.data.targetLanguage
          }
        }
      });
      state.visible = false;
    };

    const showLanguageSelect = type => {
      state.type = type;
      state.visible = true;
    };

    const handlePlay = type => {
      const word = type === 'source' ? container_data.inputText : container_data.data.translate.map(v => v.text).join('');
      const tl = type === 'source' ? container_data.data.detectedLanguage : container_data.data.targetLanguage;
      GoogleTranslate_playAudio_playAudio(word, tl);
    };

    return {
      state,
      data: runtime_core_esm_bundler_computed(() => container_data.data),
      translateText: runtime_core_esm_bundler_computed(() => {
        var _containerData$data$t, _containerData$data;

        return (_containerData$data$t = (_containerData$data = container_data.data) === null || _containerData$data === void 0 ? void 0 : _containerData$data.translate.map(v => v.text).join('').split('\n')) !== null && _containerData$data$t !== void 0 ? _containerData$data$t : [];
      }),
      languages,
      icon: containervue_type_script_lang_ts_icon,
      getLanguage,
      handleLanguageSelect,
      showLanguageSelect,
      handlePlay
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/container/index.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleTranslate/container/index.sass?vue&type=style&index=0&id=29b37c76&lang=sass&scoped=true
var containervue_type_style_index_0_id_29b37c76_lang_sass_scoped_true = __webpack_require__(7183);
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/container/index.sass?vue&type=style&index=0&id=29b37c76&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/container/index.vue




;


const GoogleTranslate_container_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(GoogleTranslate_containervue_type_script_lang_ts, [['render',containervue_type_template_id_29b37c76_scoped_true_ts_true_render],['__scopeId',"data-v-29b37c76"]])

/* harmony default export */ const GoogleTranslate_container = (GoogleTranslate_container_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleTranslate/settings/index.vue?vue&type=template&id=9db7d096&ts=true

const settingsvue_type_template_id_9db7d096_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};
const settingsvue_type_template_id_9db7d096_ts_true_hoisted_2 = {
  class: "flex mt-6 pt-1"
};
const settingsvue_type_template_id_9db7d096_ts_true_hoisted_3 = {
  class: "flex-col items-start grow-0 pr-12"
};

const settingsvue_type_template_id_9db7d096_ts_true_hoisted_4 = /*#__PURE__*/createBaseVNode("div", {
  class: "text-grey-600 pr-6 mb-2"
}, "语言", -1);

const settingsvue_type_template_id_9db7d096_ts_true_hoisted_5 = {
  class: "flex-col items-center grow-0"
};

const settingsvue_type_template_id_9db7d096_ts_true_hoisted_6 = /*#__PURE__*/createBaseVNode("div", {
  class: "text-grey-600 pr-6 mb-1"
}, "首选语言", -1);

const settingsvue_type_template_id_9db7d096_ts_true_hoisted_7 = {
  class: "flex-col items-center grow-0"
};

const settingsvue_type_template_id_9db7d096_ts_true_hoisted_8 = /*#__PURE__*/createBaseVNode("div", {
  class: "text-grey-600 pr-6 mb-1"
}, "备选语言", -1);

const settingsvue_type_template_id_9db7d096_ts_true_hoisted_9 = {
  key: 0,
  class: "text-14 text-red-500 mt-2 mb-0"
};

const settingsvue_type_template_id_9db7d096_ts_true_hoisted_10 = /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-1 mb-0"
}, [/*#__PURE__*/createTextVNode(" 首选语言：默认翻译到的语言 "), /*#__PURE__*/createBaseVNode("br"), /*#__PURE__*/createTextVNode(" 备选语言：当检测到翻译文本语言为首选语言时，翻译到备选语言 ")], -1);

const settingsvue_type_template_id_9db7d096_ts_true_hoisted_11 = /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-6 mb-0"
}, " ps：当出现 response with status code 503 时，有可能是触发了验证码。请手动打开google翻译点击验证码。 ", -1);

function settingsvue_type_template_id_9db7d096_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_provider_common = resolveComponent("provider-common");

  const _component_i_radio = resolveComponent("i-radio");

  const _component_i_radio_group = resolveComponent("i-radio-group");

  return openBlock(), createElementBlock("div", settingsvue_type_template_id_9db7d096_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_provider_common, {
    icon: _ctx.form.icon,
    "onUpdate:icon": _cache[0] || (_cache[0] = $event => _ctx.form.icon = $event),
    display: _ctx.form.display,
    "onUpdate:display": _cache[1] || (_cache[1] = $event => _ctx.form.display = $event),
    "enable-hotkey": _ctx.form.enableHotkey,
    "onUpdate:enable-hotkey": _cache[2] || (_cache[2] = $event => _ctx.form.enableHotkey = $event),
    hotkey: _ctx.form.hotkey,
    "onUpdate:hotkey": _cache[3] || (_cache[3] = $event => _ctx.form.hotkey = $event),
    name: "google翻译",
    icons: _ctx.iconOptions
  }, null, 8, ["icon", "display", "enable-hotkey", "hotkey", "icons"]), createBaseVNode("div", settingsvue_type_template_id_9db7d096_ts_true_hoisted_2, [createBaseVNode("div", settingsvue_type_template_id_9db7d096_ts_true_hoisted_3, [settingsvue_type_template_id_9db7d096_ts_true_hoisted_4, (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.languageOptions, n => {
    return openBlock(), createElementBlock("div", {
      class: "language-option text-16 text-grey-600 mb-2",
      key: n.key
    }, toDisplayString(n.text), 1);
  }), 128))]), createBaseVNode("div", settingsvue_type_template_id_9db7d096_ts_true_hoisted_5, [settingsvue_type_template_id_9db7d096_ts_true_hoisted_6, runtime_core_esm_bundler_createVNode(_component_i_radio_group, {
    class: "mt-0 grow-0",
    modelValue: _ctx.form.targetLanguage,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => _ctx.form.targetLanguage = $event)
  }, {
    default: withCtx(() => [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.languageOptions, n => {
      return openBlock(), createBlock(_component_i_radio, {
        key: n.key,
        label: "",
        value: n.key
      }, null, 8, ["value"]);
    }), 128))]),
    _: 1
  }, 8, ["modelValue"])]), createBaseVNode("div", settingsvue_type_template_id_9db7d096_ts_true_hoisted_7, [settingsvue_type_template_id_9db7d096_ts_true_hoisted_8, runtime_core_esm_bundler_createVNode(_component_i_radio_group, {
    class: "mt-0",
    modelValue: _ctx.form.secondTargetLanguage,
    "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => _ctx.form.secondTargetLanguage = $event)
  }, {
    default: withCtx(() => [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.languageOptions, n => {
      return openBlock(), createBlock(_component_i_radio, {
        key: n.key,
        label: "",
        value: n.key
      }, null, 8, ["value"]);
    }), 128))]),
    _: 1
  }, 8, ["modelValue"])])]), _ctx.form.targetLanguage === _ctx.form.secondTargetLanguage ? (openBlock(), createElementBlock("p", settingsvue_type_template_id_9db7d096_ts_true_hoisted_9, " 首选语言和备选语言请选择不同的选项 ")) : createCommentVNode("", true), settingsvue_type_template_id_9db7d096_ts_true_hoisted_10, settingsvue_type_template_id_9db7d096_ts_true_hoisted_11]);
}
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/settings/index.vue?vue&type=template&id=9db7d096&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleTranslate/settings/index.ts?vue&type=script&lang=ts





const settingsvue_type_script_lang_ts_iconOptions = Object.entries(icons_icons).map(([k, v]) => ({
  icon: v,
  key: k
}));
/* harmony default export */ const GoogleTranslate_settingsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GoogleTranslateSettings',
  components: {
    ProviderCommon: providerCommon
  },
  props: {
    active: Boolean
  },
  setup: props => {
    const form = store_store.data;
    let reset = null;
    watch(() => [form.targetLanguage, form.secondTargetLanguage], (n, o) => {
      reset = o && n[0] === n[1] ? o : null;
    });

    const doReset = () => {
      if (props.active && reset) {
        form.targetLanguage = reset[0];
        form.secondTargetLanguage = reset[1];
      }
    };

    watch(() => props.active, doReset);
    runtime_core_esm_bundler_onUnmounted(doReset);
    return {
      form,
      iconOptions: settingsvue_type_script_lang_ts_iconOptions,
      languageOptions: googleLanguagesOptions
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/settings/index.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/settings/index.vue




;
const GoogleTranslate_settings_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(GoogleTranslate_settingsvue_type_script_lang_ts, [['render',settingsvue_type_template_id_9db7d096_ts_true_render]])

/* harmony default export */ const GoogleTranslate_settings = (GoogleTranslate_settings_exports_);
;// CONCATENATED MODULE: ./src/provider/GoogleTranslate/index.ts






const GoogleTranslateProvider = createProvider({
  id: 'GOOGLE_TRANSLATE',
  label: '谷歌翻译',
  translate: translate_translate,
  translateView: GoogleTranslate_container,
  settingView: GoogleTranslate_settings,
  icons: icons_icons,
  storeWrapper: store_store,
  storeType: store_storeType,
  defaultStore: store_defaultStore
});
;// CONCATENATED MODULE: ./src/provider/GoogleDict/translate.ts



function GoogleDict_translate_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function GoogleDict_translate_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? GoogleDict_translate_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : GoogleDict_translate_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }





const wordErrorCache = {};

const fetchGoogleDict = async (word, lang = 'uk') => {
  // const apiUrlBase = 'https://content.googleapis.com/dictionaryextension/v1/knowledge/search?'
  const apiUrlBase = 'https://content-dictionaryextension-pa.googleapis.com/v1/dictionaryExtensionData?';

  const query = GoogleDict_translate_objectSpread(GoogleDict_translate_objectSpread({
    term: word,
    language: 'en'
  }, lang === 'uk' ? {
    corpus: 'en',
    country: 'UK'
  } : {
    corpus: 'en-US',
    country: 'US'
  }), {}, {
    // this key is hard coded in background.min.js
    // https://chrome.google.com/webstore/detail/google-dictionary-by-goog/mgijmajocgfcbeboacabfgobmjgjcoja
    // key: 'AIzaSyC9PDwo2wgENKuI8DSFOfqFqKP2cKAxxso',
    key: 'AIzaSyA6EEtrDCfBkHV8uU2lgGY-N383ZgAOo7Y'
  });

  const apiUrl = `${apiUrlBase}${new (url_search_params_default())(query).toString()}`;
  const response = await got({
    method: 'GET',
    headers: {
      // 'accept': '*/*',
      // 'accept-encoding': 'gzip, deflate, br',
      // 'accept-language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7,zh-TW;q=0.6',
      // 'cache-control': 'no-cache',
      // 'pragma': 'no-cache',
      // 'user-agent': window.navigator.userAgent,
      // 'x-goog-encode-response-if-executable': 'base64',
      // 'x-javascript-user-agent': 'google-api-javascript-client/1.1.0',
      'x-origin': 'chrome-extension://mgijmajocgfcbeboacabfgobmjgjcoja',
      'x-referer': 'chrome-extension://mgijmajocgfcbeboacabfgobmjgjcoja' // 'x-requested-with': 'XMLHttpRequest',

    },
    url: apiUrl,
    timeout: 10000
  });

  if (Either_isLeft(response)) {
    const responseText = response.left.res.responseText;

    if (responseText) {
      var _result$error;

      const result = JSON.parse(responseText);

      if (result !== null && result !== void 0 && (_result$error = result.error) !== null && _result$error !== void 0 && _result$error.message) {
        throw new Error(result.error.message);
      }
    }

    throw new Error(`遇到错误: ${response.left.type} ${response.left.res.status}`);
  }

  const data = JSON.parse(response.right.responseText);

  if (Object.getOwnPropertyNames(data).length === 0) {
    throw new Error('无查询结果！');
  }

  return data;
};

const GoogleDict_translate_translate = async ({
  word
}) => {
  if (wordErrorCache[word]) {
    return Either_left({
      redirect: GoogleTranslateProvider.id,
      redirectParams: {
        fromDict: true
      }
    });
  }

  let googleDictData;

  try {
    googleDictData = await fetchGoogleDict(word, 'uk');
  } catch (e) {
    if (e.message === 'Backend Error') {
      // try googletranslate
      wordErrorCache[word] = true;
      return Either_left({
        redirect: GoogleTranslateProvider.id
      });
    }

    if (false) {}

    return Either_left({
      message: e.message
    });
  }

  if (googleDictData.status !== 200) {
    return Either_left({
      redirect: GoogleTranslateProvider.id,
      redirectParams: {
        fromDict: true
      }
    });
  } // dev only check


  if (false) {}

  return Either_right(() => {
    data_containerData.data = googleDictData.dictionaryData;
    data_containerData.word = word;
  });
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/GoogleDictContainer.vue?vue&type=template&id=21539aa9&scoped=true&ts=true


const GoogleDictContainervue_type_template_id_21539aa9_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-21539aa9"), n = n(), _popScopeId(), n);

const GoogleDictContainervue_type_template_id_21539aa9_scoped_true_ts_true_hoisted_1 = {
  class: "google-dict-box flex-col relative break-words text-grey-900"
};
const GoogleDictContainervue_type_template_id_21539aa9_scoped_true_ts_true_hoisted_2 = {
  class: "google-content-box text-13"
};
const GoogleDictContainervue_type_template_id_21539aa9_scoped_true_ts_true_hoisted_3 = {
  key: 0,
  class: "dictionary-data-box flex-col items-stretch"
};
const GoogleDictContainervue_type_template_id_21539aa9_scoped_true_ts_true_hoisted_4 = {
  key: 0,
  class: "entry-box flex-col items-stretch"
};
function GoogleDictContainervue_type_template_id_21539aa9_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  const _component_simple_entry = resolveComponent("simple-entry");

  const _component_scrollable = resolveComponent("scrollable");

  return openBlock(), createElementBlock("div", GoogleDictContainervue_type_template_id_21539aa9_scoped_true_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_scrollable, {
    class: "scroll-container"
  }, {
    default: withCtx(ctx => [createBaseVNode("div", {
      class: normalizeClass(["google-content-simple relative flex-auto", [ctx.scrollBar && 'py-10px pl-10px pr-14px', !ctx.scrollBar && 'p-10px']])
    }, [_ctx.containerData.data && _ctx.containerData.data.length ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["expand-button flex flex-center absolute", {
        'with-scroll-bar': ctx.scrollBar
      }]),
      title: "展开",
      onClick: _cache[0] || (_cache[0] = //@ts-ignore
      (...args) => _ctx.handleOpenModal && _ctx.handleOpenModal(...args))
    }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
      svg: _ctx.icon.expand_128456
    }, null, 8, ["svg"])], 2)) : createCommentVNode("", true), createBaseVNode("div", GoogleDictContainervue_type_template_id_21539aa9_scoped_true_ts_true_hoisted_2, [_ctx.containerData.data && _ctx.containerData.data.length ? (openBlock(), createElementBlock("div", GoogleDictContainervue_type_template_id_21539aa9_scoped_true_ts_true_hoisted_3, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.containerData.data, (dicDataItem, index) => {
      return openBlock(), createElementBlock("div", {
        class: "dictionary-data-item",
        key: index
      }, [dicDataItem.entries && dicDataItem.entries.length ? (openBlock(), createElementBlock("div", GoogleDictContainervue_type_template_id_21539aa9_scoped_true_ts_true_hoisted_4, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(dicDataItem.entries, (entry, entryIndex) => {
        return openBlock(), createBlock(_component_simple_entry, {
          class: normalizeClass(["entry-item", {
            '-mt-2px': entryIndex === 0,
            'border-t border-grey-400 pt-1 mt-4': entryIndex !== 0
          }]),
          entry: entry,
          key: entryIndex
        }, null, 8, ["class", "entry"]);
      }), 128))])) : createCommentVNode("", true)]);
    }), 128))])) : createCommentVNode("", true)])], 2)]),
    _: 1
  })]);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/GoogleDictContainer.vue?vue&type=template&id=21539aa9&scoped=true&ts=true

;// CONCATENATED MODULE: ./src/assets/img/expand_128456.svg
/* harmony default export */ const expand_128456 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 26.1 26.1\" width=\"512\" height=\"512\"><path d=\"M16 25.042v-2c0-.6.4-1 1-1h1c.4 0 .7-.5.4-.9l-4-4c-.4-.4-.4-1 0-1.4l1.4-1.4c.4-.4 1-.4 1.4 0l4 4c.3.3.9.1.9-.4v-1c0-.6.4-1 1-1h2c.6 0 1 .4 1 1v8c0 .6-.4 1-1 1h-8c-.7.1-1.1-.3-1.1-.9zm-7.1-13.3l-4-4c-.3-.3-.9-.1-.9.4v1c0 .6-.4 1-1 1H1c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1h8c.6 0 1 .4 1 1v2c0 .6-.4 1-1 1H8c-.4 0-.7.5-.4.9l4 4c.4.4.4 1 0 1.4l-1.4 1.4c-.3.3-.9.3-1.3-.1z\"/></svg>\n");
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/container/simpleEntry/simpleEntry.vue?vue&type=template&id=13c640e0&scoped=true&ts=true


const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-13c640e0"), n = n(), _popScopeId(), n);

const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_1 = {
  class: "entry-item flex-col items-stretch leading-snug"
};
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_2 = {
  class: "headword flex flex-wrap leading-normal"
};
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_3 = {
  class: "headword-word text-16"
};
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_4 = {
  key: 0,
  class: "headword-graph-index text-12 ml-2px"
};
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_5 = {
  key: 1,
  class: "sense-list mt-2px flex-col items-stretch"
};
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_6 = {
  class: "sense-item-number text-right"
};
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_7 = {
  class: "definition-box flex-auto"
};
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_8 = {
  key: 2,
  class: "sense-family-box flex-col items-stretch"
};
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_9 = ["title"];
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_10 = {
  key: 2,
  class: "sense-list mt-2px flex-col items-stretch"
};
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_11 = {
  class: "sense-item-number text-right pr-2 font-bold"
};
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_12 = {
  class: "definition-box flex-auto"
};
const simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_13 = {
  key: 3,
  class: "sub-entry-box"
};
function simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_phonetics = resolveComponent("phonetics");

  const _component_fragment = resolveComponent("fragment");

  const _component_g_simple_entry = resolveComponent("g-simple-entry");

  return openBlock(), createElementBlock("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_1, [createBaseVNode("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_2, [createBaseVNode("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_3, toDisplayString(_ctx.props.entry.syllabifiedHeadword || _ctx.props.entry.headword), 1), _ctx.props.entry.homographIndex ? (openBlock(), createElementBlock("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_4, toDisplayString(_ctx.props.entry.homographIndex), 1)) : createCommentVNode("", true)]), _ctx.props.entry.phonetics ? (openBlock(), createBlock(_component_phonetics, {
    key: 0,
    class: "phonetics-box mb-2px",
    phonetics: _ctx.props.entry.phonetics
  }, null, 8, ["phonetics"])) : createCommentVNode("", true), _ctx.props.isSubentry && _ctx.props.entry.senseFamily && _ctx.props.entry.senseFamily.senses && _ctx.props.entry.senseFamily.senses.length ? (openBlock(), createElementBlock("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_5, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.props.entry.senseFamily.senses, (sense, index) => {
    return withDirectives((openBlock(), createElementBlock("div", {
      class: "sense-item flex",
      key: index
    }, [createBaseVNode("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_6, toDisplayString(index + 1) + ".", 1), createBaseVNode("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_7, [runtime_core_esm_bundler_createVNode(_component_fragment, {
      class: "sense-frag",
      fragment: sense.definition.fragments
    }, null, 8, ["fragment"])])])), [[vShow, index < 2]]);
  }), 128))])) : createCommentVNode("", true), !_ctx.props.isSubentry && _ctx.props.entry.senseFamilies && _ctx.props.entry.senseFamilies.length ? (openBlock(), createElementBlock("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_8, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.props.entry.senseFamilies, (senseFamilyItem, senseFamilyItemIndex) => {
    return openBlock(), createElementBlock("div", {
      class: normalizeClass(["sense-family-item flex-col items-stretch", {
        'mt-6px': senseFamilyItemIndex !== 0
      }]),
      key: senseFamilyItemIndex
    }, [senseFamilyItem.partsOfSpeechs ? (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, {
      key: 0
    }, renderList(senseFamilyItem.partsOfSpeechs, (item, index) => {
      return openBlock(), createElementBlock("div", {
        title: item.qualifier,
        class: "poss italic flex flex-wrap text-grey-600",
        key: index
      }, toDisplayString(item.value), 9, simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_9);
    }), 128)) : createCommentVNode("", true), senseFamilyItem.phonetics ? (openBlock(), createBlock(_component_phonetics, {
      key: 1,
      class: "phonetics-box mb-2px",
      phonetics: senseFamilyItem.phonetics
    }, null, 8, ["phonetics"])) : createCommentVNode("", true), senseFamilyItem.senses && senseFamilyItem.senses.length ? (openBlock(), createElementBlock("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_10, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(senseFamilyItem.senses, (sense, index) => {
      return withDirectives((openBlock(), createElementBlock("div", {
        class: "sense-item flex",
        key: index
      }, [createBaseVNode("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_11, toDisplayString(index + 1) + ". ", 1), createBaseVNode("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_12, [runtime_core_esm_bundler_createVNode(_component_fragment, {
        class: "sense-frag",
        fragment: sense.definition.fragments
      }, null, 8, ["fragment"])])])), [[vShow, index < 2]]);
    }), 128))])) : createCommentVNode("", true)], 2);
  }), 128))])) : createCommentVNode("", true), _ctx.props.entry.subentries && _ctx.props.entry.subentries.length ? (openBlock(), createElementBlock("div", simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_hoisted_13, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.props.entry.subentries, (subentry, index) => {
    return openBlock(), createBlock(_component_g_simple_entry, {
      class: "sub-entry",
      entry: subentry,
      "is-subentry": true,
      key: index
    }, null, 8, ["entry"]);
  }), 128))])) : createCommentVNode("", true)]);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/container/simpleEntry/simpleEntry.vue?vue&type=template&id=13c640e0&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/common/phonetics/phonetics.vue?vue&type=template&id=80abc988&scoped=true&ts=true


const phoneticsvue_type_template_id_80abc988_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-80abc988"), n = n(), _popScopeId(), n);

const phoneticsvue_type_template_id_80abc988_scoped_true_ts_true_hoisted_1 = {
  key: 0,
  class: "phonetics-box flex items-center text-grey-700"
};
const phoneticsvue_type_template_id_80abc988_scoped_true_ts_true_hoisted_2 = {
  class: "phonetics flex"
};
const phoneticsvue_type_template_id_80abc988_scoped_true_ts_true_hoisted_3 = ["onClick"];
function phoneticsvue_type_template_id_80abc988_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  return _ctx.props.phonetics && _ctx.props.phonetics.length ? (openBlock(), createElementBlock("div", phoneticsvue_type_template_id_80abc988_scoped_true_ts_true_hoisted_1, [createBaseVNode("div", phoneticsvue_type_template_id_80abc988_scoped_true_ts_true_hoisted_2, toDisplayString(`${_ctx.props.phonetics.map(v => `/${v.text}/`).join(' ')}`), 1), (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.props.phonetics.filter(v => v.oxfordAudio), item => {
    return openBlock(), createElementBlock("div", {
      class: "pl-1 play-button flex flex-center",
      key: item.oxfordAudio,
      onClick: $event => _ctx.handlePlay(item.oxfordAudio)
    }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
      svg: _ctx.icon.play_speaker_filled_audio_tool_59284
    }, null, 8, ["svg"])], 8, phoneticsvue_type_template_id_80abc988_scoped_true_ts_true_hoisted_3);
  }), 128))])) : createCommentVNode("", true);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/common/phonetics/phonetics.vue?vue&type=template&id=80abc988&scoped=true&ts=true

;// CONCATENATED MODULE: ./src/provider/GoogleDict/playAudio.ts



/** 播放音频 */

const GoogleDict_playAudio_playAudio = async url => {
  const volume = 0.7;
  const mp3Url = `https:${url}`;

  if (audioCacheService.has(mp3Url)) {
    audioCacheService.play(mp3Url, volume);
    return;
  }

  const response = await got({
    method: 'GET',
    headers: {
      // 'Accept': '*/*',
      // 'Accept-Encoding': 'gzip, deflate, br',
      // 'Accept-Language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7,zh-TW;q=0.6',
      // 'Cache-Control': 'no-cache',
      // 'Pragma': 'no-cache',
      'upgrade-insecure-requests': '1' // 'User-Agent': window.navigator.userAgent,

    },
    responseType: 'arraybuffer',
    url: mp3Url,
    timeout: 5000
  });

  if (Either_isRight(response)) {
    audioCacheService.play(mp3Url, response.right.response, volume);
  }
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/common/phonetics/phonetics.ts?vue&type=script&lang=ts



/* harmony default export */ const phoneticsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GPhonetics',
  props: {
    phonetics: {
      type: null,
      required: true
    }
  },
  setup: props => {
    const handlePlay = url => {
      GoogleDict_playAudio_playAudio(url);
    };

    return {
      icon: {
        play_speaker_filled_audio_tool_59284: speaker_filled_audio_tool_59284
      },
      props,
      handlePlay
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/common/phonetics/phonetics.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/common/phonetics/phonetics.sass?vue&type=style&index=0&id=80abc988&lang=sass&scoped=true
var phoneticsvue_type_style_index_0_id_80abc988_lang_sass_scoped_true = __webpack_require__(9255);
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/common/phonetics/phonetics.sass?vue&type=style&index=0&id=80abc988&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/common/phonetics/phonetics.vue




;


const phonetics_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(phoneticsvue_type_script_lang_ts, [['render',phoneticsvue_type_template_id_80abc988_scoped_true_ts_true_render],['__scopeId',"data-v-80abc988"]])

/* harmony default export */ const phonetics = (phonetics_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/common/fragment/fragment.vue?vue&type=template&id=ac18c5ae&ts=true

const fragmentvue_type_template_id_ac18c5ae_ts_true_hoisted_1 = {
  key: 0,
  class: "fragment-box inline"
};
const fragmentvue_type_template_id_ac18c5ae_ts_true_hoisted_2 = ["onClick", "innerHTML"];
const fragmentvue_type_template_id_ac18c5ae_ts_true_hoisted_3 = ["innerHTML"];
function fragmentvue_type_template_id_ac18c5ae_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.props.fragment && _ctx.props.fragment.length ? (openBlock(), createElementBlock("div", fragmentvue_type_template_id_ac18c5ae_ts_true_hoisted_1, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.props.fragment, (frag, fIndex) => {
    return openBlock(), createElementBlock("div", {
      class: "inline fragment-item",
      key: fIndex
    }, [frag.isEntryLink ? (openBlock(), createElementBlock("a", {
      key: 0,
      class: "text-link cursor-pointer",
      onClick: $event => _ctx.handleEntryLinkClick($event, frag.text),
      innerHTML: frag.text
    }, null, 8, fragmentvue_type_template_id_ac18c5ae_ts_true_hoisted_2)) : (openBlock(), createElementBlock("div", {
      key: 1,
      class: "inline",
      innerHTML: frag.text
    }, null, 8, fragmentvue_type_template_id_ac18c5ae_ts_true_hoisted_3))]);
  }), 128))])) : createCommentVNode("", true);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/common/fragment/fragment.vue?vue&type=template&id=ac18c5ae&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/common/fragment/fragment.ts?vue&type=script&lang=ts
 // import googleDictBus from '~/provider/GoogleDict/bus'



/* harmony default export */ const fragmentvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GFragment',
  props: {
    fragment: {
      type: null,
      required: true
    }
  },
  setup: props => {
    const handleEntryLinkClick = (event, word) => {
      bus.emit({
        type: EVENTS.TRANSLATE,
        word,
        mouseEvent: event,
        param: {
          provider: GoogleDictProvider.id
        }
      });
    };

    return {
      props,
      handleEntryLinkClick
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/common/fragment/fragment.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/common/fragment/fragment.vue




;
const fragment_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(fragmentvue_type_script_lang_ts, [['render',fragmentvue_type_template_id_ac18c5ae_ts_true_render]])

/* harmony default export */ const fragment = (fragment_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/container/simpleEntry/simpleEntry.ts?vue&type=script&lang=ts



/* harmony default export */ const simpleEntryvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GSimpleEntry',
  components: {
    phonetics: phonetics,
    fragment: fragment
  },
  props: {
    entry: {
      type: null,
      required: true
    },
    isSubentry: {
      type: Boolean,
      default: false
    }
  },
  setup: props => ({
    props
  })
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/container/simpleEntry/simpleEntry.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/container/simpleEntry/simpleEntry.sass?vue&type=style&index=0&id=13c640e0&lang=sass&scoped=true
var simpleEntryvue_type_style_index_0_id_13c640e0_lang_sass_scoped_true = __webpack_require__(5044);
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/container/simpleEntry/simpleEntry.sass?vue&type=style&index=0&id=13c640e0&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/container/simpleEntry/simpleEntry.vue




;


const simpleEntry_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(simpleEntryvue_type_script_lang_ts, [['render',simpleEntryvue_type_template_id_13c640e0_scoped_true_ts_true_render],['__scopeId',"data-v-13c640e0"]])

/* harmony default export */ const simpleEntry = (simpleEntry_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/GoogleDictContainer.ts?vue&type=script&lang=ts






/* harmony default export */ const GoogleDictContainervue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GoogleDictContainer',
  components: {
    simpleEntry: simpleEntry,
    Scrollable: Scrollable
  },
  setup: () => {
    const handleOpenModal = () => {
      bus.emit({
        type: EVENTS.OPEN_GOOGLE_DICT_MODAL,
        googleDictData: data_containerData.data
      });
    };

    return {
      containerData: data_containerData,
      icon: {
        expand_128456: expand_128456
      },
      handleOpenModal
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/GoogleDictContainer.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/GoogleDictContainer.sass?vue&type=style&index=0&id=21539aa9&lang=sass&scoped=true
var GoogleDictContainervue_type_style_index_0_id_21539aa9_lang_sass_scoped_true = __webpack_require__(2750);
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/GoogleDictContainer.sass?vue&type=style&index=0&id=21539aa9&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/GoogleDictContainer.vue




;


const GoogleDictContainer_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(GoogleDictContainervue_type_script_lang_ts, [['render',GoogleDictContainervue_type_template_id_21539aa9_scoped_true_ts_true_render],['__scopeId',"data-v-21539aa9"]])

/* harmony default export */ const GoogleDictContainer = (GoogleDictContainer_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/settings/index.vue?vue&type=template&id=81d791aa&ts=true

const settingsvue_type_template_id_81d791aa_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};

const settingsvue_type_template_id_81d791aa_ts_true_hoisted_2 = /*#__PURE__*/createStaticVNode("<p class=\"text-14 text-grey-400 mt-1 mb-0\"> 查词详细结果默认折叠状态 </p><p class=\"text-14 text-grey-400 mt-12 mb-0\"> 如果你经常出现 request failed 0，这不是脚本出问题也不是网络问题。 </p><p class=\"text-14 text-grey-400 mt-1 mb-0\"> google 的 api 会在查不到结果时返回 500，而 chrome 检测到 500 后会自动启动 ddos 防御，所有相同的请求会被拦截。 </p><p class=\"text-14 text-grey-400 mt-1 mb-0\"> 添加 chrome 启动参数 --disable-extensions-http-throttling 可以关闭此功能。 </p><p class=\"text-14 text-grey-400 mt-1 mb-0\"> 解决方案是，过一段时间再使用 google 字典，或者避免使用 google 字典查询查不到的单词。 </p>", 5);

const settingsvue_type_template_id_81d791aa_ts_true_hoisted_7 = /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-1 mb-0"
}, [/*#__PURE__*/createBaseVNode("a", {
  href: "http://dev.chromium.org/throttling",
  _target: "blank"
}, "http://dev.chromium.org/throttling")], -1);

function settingsvue_type_template_id_81d791aa_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_provider_common = resolveComponent("provider-common");

  const _component_i_radio = resolveComponent("i-radio");

  const _component_i_radio_group = resolveComponent("i-radio-group");

  return openBlock(), createElementBlock("div", settingsvue_type_template_id_81d791aa_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_provider_common, {
    icon: _ctx.form.icon,
    "onUpdate:icon": _cache[0] || (_cache[0] = $event => _ctx.form.icon = $event),
    display: _ctx.form.display,
    "onUpdate:display": _cache[1] || (_cache[1] = $event => _ctx.form.display = $event),
    "enable-hotkey": _ctx.form.enableHotkey,
    "onUpdate:enable-hotkey": _cache[2] || (_cache[2] = $event => _ctx.form.enableHotkey = $event),
    hotkey: _ctx.form.hotkey,
    "onUpdate:hotkey": _cache[3] || (_cache[3] = $event => _ctx.form.hotkey = $event),
    name: "google字典",
    icons: _ctx.iconOptions
  }, null, 8, ["icon", "display", "enable-hotkey", "hotkey", "icons"]), runtime_core_esm_bundler_createVNode(_component_i_radio_group, {
    class: "mt-6",
    modelValue: _ctx.form.foldStatus,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => _ctx.form.foldStatus = $event)
  }, {
    default: withCtx(() => [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.foldOptions, n => {
      return openBlock(), createBlock(_component_i_radio, {
        key: n.key,
        label: n.label,
        value: n.key
      }, null, 8, ["label", "value"]);
    }), 128))]),
    _: 1
  }, 8, ["modelValue"]), settingsvue_type_template_id_81d791aa_ts_true_hoisted_2, settingsvue_type_template_id_81d791aa_ts_true_hoisted_7]);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/settings/index.vue?vue&type=template&id=81d791aa&ts=true

;// CONCATENATED MODULE: ./src/assets/img/providerIcon/googleDict/type_0_google.svg
/* harmony default export */ const type_0_google = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 70 70\"><path fill=\"#4285F4\" d=\"M35.29 41.41V32H67c.31 1.64.47 3.58.47 5.68 0 7.06-1.93 15.79-8.15 22.01-6.05 6.3-13.78 9.66-24.02 9.66C16.32 69.35.36 53.89.36 34.91.36 15.93 16.32.47 35.3.47c10.5 0 17.98 4.12 23.6 9.49l-6.64 6.64c-4.03-3.78-9.49-6.72-16.97-6.72-13.86 0-24.7 11.17-24.7 25.03 0 13.86 10.84 25.03 24.7 25.03 8.99 0 14.11-3.61 17.39-6.89 2.66-2.66 4.41-6.46 5.1-11.65l-22.49.01z\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/googleDict/type_2_search_281764.svg
/* harmony default export */ const type_2_search_281764 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path d=\"M113.5 309.4L95.6 376l-65 1.4A254.9 254.9 0 0 1 0 256c0-42.5 10.3-82.5 28.6-117.7l58 10.6 25.4 57.6a152.2 152.2 0 0 0 1.5 103z\" fill=\"#fbbb00\"/><path d=\"M507.5 208.2a256.3 256.3 0 0 1-91.2 247.4l-73-3.7-10.4-64.5c29.9-17.6 53.3-45 65.6-78H261.6V208.3h246z\" fill=\"#518ef8\"/><path d=\"M416.3 455.6a256 256 0 0 1-385.8-78.3l83-67.9a152.2 152.2 0 0 0 219.4 78l83.4 68.2z\" fill=\"#28b446\"/><path d=\"M419.4 59l-83 67.8A152.3 152.3 0 0 0 112 206.5l-83.4-68.2a256 256 0 0 1 390.8-79.4z\" fill=\"#f14336\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/googleDict/type_3_search_281781.svg
/* harmony default export */ const type_3_search_281781 = ("<svg version=\"1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path d=\"M410 448a245 245 0 0 1-371-75l80-66a146 146 0 0 0 211 75l80 66z\" fill=\"#28b446\"/><path d=\"M498 210a246 246 0 0 1-88 238l-80-66c29-17 51-43 63-75H261v-97h237z\" fill=\"#518ef8\"/><path d=\"M413 67l-80 65a146 146 0 0 0-216 77l-79-66a246 246 0 0 1 375-76z\" fill=\"#f14336\"/><path d=\"M119 307l-80 66a245 245 0 0 1-1-230l80 66a146 146 0 0 0 1 98z\" fill=\"#fbbb00\"/><path d=\"M508 208c-1-5-6-8-10-8H261c-5 0-10 4-10 10v97c0 6 5 10 10 10h116a137 137 0 0 1-121 75 137 137 0 0 1-129-180 136 136 0 0 1 201-71c4 2 8 2 12-1l79-65a10 10 0 0 0 0-16 256 256 0 1 0-3 397 257 257 0 0 0 92-248zM256 20c51 0 100 17 141 47l-65 53a156 156 0 0 0-219 72l-62-52C92 66 170 20 256 20zM20 256c0-34 7-67 21-97l65 53a156 156 0 0 0 1 92l-64 53c-15-32-23-66-23-101zm32 119l63-51a156 156 0 0 0 214 70l65 53a236 236 0 0 1-341-72zm435-70c-11 50-38 96-77 130l-63-52c25-18 45-43 55-72a10 10 0 0 0-9-14H272v-77h217a238 238 0 0 1-2 85z\" fill=\"#333\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/googleDict/type_4_google_356049.svg
/* harmony default export */ const type_4_google_356049 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><circle cx=\"256.7\" cy=\"256\" r=\"247.9\" fill=\"#ece5dd\"/><path d=\"M256.7 8c-11 0-21.7.8-32.3 2.2a248 248 0 0 1 0 491.6A248 248 0 1 0 256.7 8.1z\" fill=\"#d9cbbd\"/><path d=\"M361.5 182A127.2 127.2 0 0 0 256 127.3c-35.2 0-68 14-92.6 39.3l-5.6 5.9-49.9-42.8 6.2-6.6a194.3 194.3 0 0 1 303.5 24.6l2.3 3.5c1.5 2.2.8 5.3-1.5 6.7l-48.6 28.6a4.7 4.7 0 0 1-6.2-1.4l-2.1-3z\" fill=\"#cd2900\"/><path d=\"M86.2 351a194.3 194.3 0 0 1 16.9-215.2l5.5-7 49.9 42.7-5 6.5a128.7 128.7 0 0 0-11 139.1l4 7.2-55.8 34.5-4.5-7.8z\" fill=\"#ffce00\"/><path d=\"M256 450.6a194.7 194.7 0 0 1-160.8-85.2l-5.1-7.5 55.9-34.5 4.6 6.6A129.1 129.1 0 0 0 256 384.8c34.7 0 68.5-14.4 92.7-39.4l5.7-5.9 49.8 42.8-6.2 6.5a194.3 194.3 0 0 1-142 61.8z\" fill=\"#40a459\"/><path d=\"M353.7 340.4l4.9-6.5a128 128 0 0 0 18.6-34.2h-95.4a4.7 4.7 0 0 1-4.8-4.8v-56.3c0-2.6 2.1-4.7 4.8-4.7h164.1c2.3 0 4.1 1.8 4.2 4l.5 18.2c0 44-14.4 85.4-41.5 119.9l-5.6 7-49.8-42.6z\" fill=\"#1d81ce\"/><path d=\"M458.1 255.8l-.5-21.6a8 8 0 0 0-8.1-7.8h-172a8 8 0 0 0-8 8v64.7a8 8 0 0 0 8 8.1H366a121.4 121.4 0 0 1-231.2-50.5 121.6 121.6 0 0 1 132.8-121.4 8 8 0 0 0 6.4-2.3l.1-.2a8 8 0 0 0-4.8-13.6 137 137 0 0 0-112 41.3L120.4 129c34-36.2 82.2-58.8 135.6-58.8 62.7 0 119.8 30.6 154.5 82.3l-42 24.7a136.8 136.8 0 0 0-53.2-45.2 8 8 0 0 0-9 1.6l-.1.1a8 8 0 0 0 2.1 12.9 121 121 0 0 1 50.9 45.8 8 8 0 0 0 11 2.7l55.7-32.9a8 8 0 0 0 2.8-11.2 202.1 202.1 0 1 0-288.2 270.8 8 8 0 0 0 10.2-.9l.1-.1a8 8 0 0 0-1-12.2 187.5 187.5 0 0 1-47.5-48l41.3-25.5a137.4 137.4 0 0 0 211.3 16.4l36.8 31.5A185.5 185.5 0 0 1 184 427.4a8 8 0 0 0-8.8 1.7l-.1.1a8 8 0 0 0 2.6 13.1A202.3 202.3 0 0 0 458 256v-.2zm-364.3 91a185 185 0 0 1 16-205.6l37 31.6A136.7 136.7 0 0 0 135 321.2l-41.3 25.6zm308.5 23.9L365.5 339a136.8 136.8 0 0 0 20.1-37.3A8 8 0 0 0 378 291h-92.4v-48.5h156l.3 13.6a185 185 0 0 1-39.6 114.6z\"/><path d=\"M437 75C388.7 26.6 324.4 0 256 0S123.3 26.6 75 75C26.6 123.3 0 187.6 0 256s26.6 132.7 75 181c48.3 48.4 112.6 75 181 75s132.7-26.6 181-75c48.4-48.3 75-112.6 75-181s-26.6-132.7-75-181zM256 495.8C123.8 495.8 16.2 388.2 16.2 256S123.8 16.2 256 16.2 495.8 123.8 495.8 256 388.2 495.8 256 495.8z\"/></svg>\n");
;// CONCATENATED MODULE: ./src/provider/GoogleDict/icons.ts




const GoogleDict_icons_icons = {
  type_0_google: type_0_google,
  type_2_search_281764: type_2_search_281764,
  type_3_search_281781: type_3_search_281781,
  type_4_google_356049: type_4_google_356049
};
;// CONCATENATED MODULE: ./src/provider/GoogleDict/constant.ts
var GOOGLE_DICT_FOLD_STATUS;

(function (GOOGLE_DICT_FOLD_STATUS) {
  GOOGLE_DICT_FOLD_STATUS["UNFOLD"] = "0";
  GOOGLE_DICT_FOLD_STATUS["FOLD_THESAURUS"] = "1";
  GOOGLE_DICT_FOLD_STATUS["FOLD_EXAMPLES"] = "2";
  GOOGLE_DICT_FOLD_STATUS["FOLD_SUBSENSE"] = "3";
})(GOOGLE_DICT_FOLD_STATUS || (GOOGLE_DICT_FOLD_STATUS = {}));

const GOOGLE_DICT_FOLD_STATUS_NEXT_MAP = {
  [GOOGLE_DICT_FOLD_STATUS.UNFOLD]: GOOGLE_DICT_FOLD_STATUS.FOLD_THESAURUS,
  [GOOGLE_DICT_FOLD_STATUS.FOLD_THESAURUS]: GOOGLE_DICT_FOLD_STATUS.FOLD_EXAMPLES,
  [GOOGLE_DICT_FOLD_STATUS.FOLD_EXAMPLES]: GOOGLE_DICT_FOLD_STATUS.FOLD_SUBSENSE,
  [GOOGLE_DICT_FOLD_STATUS.FOLD_SUBSENSE]: GOOGLE_DICT_FOLD_STATUS.FOLD_SUBSENSE
};
const GOOGLE_DICT_FOLD_STATUS_PREV_MAP = {
  [GOOGLE_DICT_FOLD_STATUS.UNFOLD]: GOOGLE_DICT_FOLD_STATUS.UNFOLD,
  [GOOGLE_DICT_FOLD_STATUS.FOLD_THESAURUS]: GOOGLE_DICT_FOLD_STATUS.UNFOLD,
  [GOOGLE_DICT_FOLD_STATUS.FOLD_EXAMPLES]: GOOGLE_DICT_FOLD_STATUS.FOLD_THESAURUS,
  [GOOGLE_DICT_FOLD_STATUS.FOLD_SUBSENSE]: GOOGLE_DICT_FOLD_STATUS.FOLD_EXAMPLES
};
const GOOGLE_DICT_FOLD_STATUS_MAP = {
  [GOOGLE_DICT_FOLD_STATUS.UNFOLD]: '展开',
  [GOOGLE_DICT_FOLD_STATUS.FOLD_SUBSENSE]: '折叠释义子项',
  [GOOGLE_DICT_FOLD_STATUS.FOLD_EXAMPLES]: '折叠子项和例句',
  [GOOGLE_DICT_FOLD_STATUS.FOLD_THESAURUS]: '折叠子项、例句和同反义词'
};
;// CONCATENATED MODULE: ./src/provider/GoogleDict/store/index.ts


function GoogleDict_store_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function GoogleDict_store_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? GoogleDict_store_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : GoogleDict_store_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







const foldStatus = enumType(GOOGLE_DICT_FOLD_STATUS, 'GOOGLE_DICT_FOLD_STATUS');
const GoogleDict_store_storeType = fallbackInterface(GoogleDict_store_objectSpread(GoogleDict_store_objectSpread({}, providerCommonStore), {}, {
  display: fallback(es6_boolean, true),
  icon: fallback(keyof(GoogleDict_icons_icons), 'type_0_google'),
  foldStatus: fallback(foldStatus, GOOGLE_DICT_FOLD_STATUS.UNFOLD)
}));
const GoogleDict_store_defaultStore = GoogleDict_store_storeType.defaultData;
const GoogleDict_store_store = {
  data: null
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/settings/index.ts?vue&type=script&lang=ts





const foldOptions = [GOOGLE_DICT_FOLD_STATUS.UNFOLD, GOOGLE_DICT_FOLD_STATUS.FOLD_SUBSENSE, GOOGLE_DICT_FOLD_STATUS.FOLD_EXAMPLES, GOOGLE_DICT_FOLD_STATUS.FOLD_THESAURUS].map(v => ({
  label: GOOGLE_DICT_FOLD_STATUS_MAP[v],
  key: v
}));
const GoogleDict_settingsvue_type_script_lang_ts_iconOptions = Object.entries(GoogleDict_icons_icons).map(([k, v]) => ({
  icon: v,
  key: k
}));
/* harmony default export */ const GoogleDict_settingsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GoogleDictSettings',
  components: {
    ProviderCommon: providerCommon
  },
  setup: () => reactivity_esm_bundler_reactive({
    get form() {
      return GoogleDict_store_store.data;
    },

    iconOptions: GoogleDict_settingsvue_type_script_lang_ts_iconOptions,
    foldOptions
  })
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/settings/index.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/GoogleDict/settings/index.vue




;
const GoogleDict_settings_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(GoogleDict_settingsvue_type_script_lang_ts, [['render',settingsvue_type_template_id_81d791aa_ts_true_render]])

/* harmony default export */ const GoogleDict_settings = (GoogleDict_settings_exports_);
;// CONCATENATED MODULE: ./src/provider/GoogleDict/index.ts






const GoogleDictProvider = createProvider({
  id: 'GOOGLE_DICT',
  label: 'google字典',
  translate: GoogleDict_translate_translate,
  translateView: GoogleDictContainer,
  settingView: GoogleDict_settings,
  icons: GoogleDict_icons_icons,
  storeWrapper: GoogleDict_store_store,
  storeType: GoogleDict_store_storeType,
  defaultStore: GoogleDict_store_defaultStore
});
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/helpers/calcToken.js
/* eslint-disable */
var gtk = '0';
var calcToken_i = null;

function a(r) {
  if (Array.isArray(r)) {
    for (var o = 0, t = Array(r.length); o < r.length; o++) t[o] = r[o];

    return t;
  }

  return Array.from(r);
}

function n(r, o) {
  for (var t = 0; t < o.length - 2; t += 3) {
    var a = o.charAt(t + 2);
    a = a >= "a" ? a.charCodeAt(0) - 87 : Number(a), a = "+" === o.charAt(t + 1) ? r >>> a : r << a, r = "+" === o.charAt(t) ? r + a & 4294967295 : r ^ a;
  }

  return r;
}

function e(r) {
  var o = r.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g);

  if (null === o) {
    var t = r.length;
    t > 30 && (r = "" + r.substr(0, 10) + r.substr(Math.floor(t / 2) - 5, 10) + r.substr(-10, 10));
  } else {
    for (var e = r.split(/[\uD800-\uDBFF][\uDC00-\uDFFF]/), C = 0, h = e.length, f = []; h > C; C++) "" !== e[C] && f.push.apply(f, a(e[C].split(""))), C !== h - 1 && f.push(o[C]);

    var g = f.length;
    g > 30 && (r = f.slice(0, 10).join("") + f.slice(Math.floor(g / 2) - 5, Math.floor(g / 2) + 5).join("") + f.slice(-10).join(""));
  }

  var u = void 0,
      l = "" + String.fromCharCode(103) + String.fromCharCode(116) + String.fromCharCode(107);
  u = null !== calcToken_i ? calcToken_i : (calcToken_i = gtk || "") || "";

  for (var d = u.split("."), m = Number(d[0]) || 0, s = Number(d[1]) || 0, S = [], c = 0, v = 0; v < r.length; v++) {
    var A = r.charCodeAt(v);
    128 > A ? S[c++] = A : (2048 > A ? S[c++] = A >> 6 | 192 : (55296 === (64512 & A) && v + 1 < r.length && 56320 === (64512 & r.charCodeAt(v + 1)) ? (A = 65536 + ((1023 & A) << 10) + (1023 & r.charCodeAt(++v)), S[c++] = A >> 18 | 240, S[c++] = A >> 12 & 63 | 128) : S[c++] = A >> 12 | 224, S[c++] = A >> 6 & 63 | 128), S[c++] = 63 & A | 128);
  }

  for (var p = m, F = "" + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(97) + ("" + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(54)), D = "" + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(51) + ("" + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(98)) + ("" + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(102)), b = 0; b < S.length; b++) p += S[b], p = n(p, F);

  return p = n(p, D), p ^= s, 0 > p && (p = (2147483647 & p) + 2147483648), p %= 1e6, p.toString() + "." + (p ^ m);
}
/* eslint-enable */

/**
 * @param  {string} word
 * @param  {string} _gtk
 * @return {string}
 */


const calcToken = (word, _gtk) => {
  gtk = _gtk;
  const sign = e(word);
  return sign;
};

/* harmony default export */ const helpers_calcToken = (calcToken);
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/helpers/token.ts
/**
 * https://www.jianshu.com/p/2c333f7ae1c2
 * https://www.jianshu.com/p/38a65d8d3e80
 */



let commonToken = '0';
let token_gtk = '';

const updateGTK = async force => {
  if (!force && token_gtk) {
    return;
  }

  const response = await got({
    method: 'GET',
    url: 'https://fanyi.baidu.com/',
    timeout: 5000
  });

  if (Either_isLeft(response)) {
    throw new Error(response.left.type);
  }

  const responseText = response.right.responseText;
  const gtkMatch = /window\.gtk = ['"](.*?)['"]/.exec(responseText);
  const commonTokenMatch = /token: ['"](.*?)['"],/.exec(responseText);

  if (!gtkMatch) {
    throw new Error('failed to get gtk');
  }

  if (!commonTokenMatch) {
    throw new Error('failed to get common token');
  }

  const newGtk = gtkMatch[1];
  const newCommonToken = commonTokenMatch[1];

  if (typeof newGtk !== 'undefined') {
    token_gtk = newGtk;
  }

  if (typeof newCommonToken !== 'undefined') {
    commonToken = newCommonToken;
  }
};

const getToken = async (word, force) => {
  await updateGTK(force);
  const token = helpers_calcToken(word, token_gtk);
  return {
    sign: token,
    token: commonToken
  };
};

/* harmony default export */ const helpers_token = (getToken);
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/container/data.ts

const data_data = {
  data: [],
  inputText: '',
  autoMode: false,
  sourceLanguage: '',
  targetLanguage: ''
};
/* harmony default export */ const BaiduTranslate_container_data = (reactivity_esm_bundler_reactive(data_data));
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/baiduLanguages.ts
var BAIDU_LANGUAGES;

(function (BAIDU_LANGUAGES) {
  BAIDU_LANGUAGES["de"] = "de";
  BAIDU_LANGUAGES["fra"] = "fra";
  BAIDU_LANGUAGES["it"] = "it";
  BAIDU_LANGUAGES["jp"] = "jp";
  BAIDU_LANGUAGES["ru"] = "ru";
  BAIDU_LANGUAGES["spa"] = "spa";
  BAIDU_LANGUAGES["zh"] = "zh";
  BAIDU_LANGUAGES["en"] = "en";
})(BAIDU_LANGUAGES || (BAIDU_LANGUAGES = {}));

const BAIDU_LANGUAGE_MAP = {
  [BAIDU_LANGUAGES.de]: '德语',
  [BAIDU_LANGUAGES.fra]: '法语',
  [BAIDU_LANGUAGES.it]: '意大利语',
  [BAIDU_LANGUAGES.jp]: '日语',
  [BAIDU_LANGUAGES.ru]: '俄语',
  [BAIDU_LANGUAGES.spa]: '西班牙语',
  [BAIDU_LANGUAGES.zh]: '中文',
  [BAIDU_LANGUAGES.en]: '英语'
};
const baiduLanguagesOptions = Object.entries(BAIDU_LANGUAGE_MAP).map(([k, v]) => ({
  text: v,
  key: k
})); // languages
// [
//   {
//     text: '阿拉伯语',
//     key: 'ara',
//   },
//   {
//     text: '爱沙尼亚语',
//     key: 'est',
//   },
//   {
//     text: '保加利亚语',
//     key: 'bul',
//   },
//   {
//     text: '波兰语',
//     key: 'pl',
//   },
//   {
//     text: '丹麦语',
//     key: 'dan',
//   },
//   {
//     text: '德语',
//     key: 'de',
//   },
//   {
//     text: '俄语',
//     key: 'ru',
//   },
//   {
//     text: '法语',
//     key: 'fra',
//   },
//   {
//     text: '芬兰语',
//     key: 'fin',
//   },
//   {
//     text: '韩语',
//     key: 'kor',
//   },
//   {
//     text: '荷兰语',
//     key: 'nl',
//   },
//   {
//     text: '捷克语',
//     key: 'cs',
//   },
//   {
//     text: '罗马尼亚语',
//     key: 'rom',
//   },
//   {
//     text: '葡萄牙语',
//     key: 'pt',
//   },
//   {
//     text: '日语',
//     key: 'jp',
//   },
//   {
//     text: '瑞典语',
//     key: 'swe',
//   },
//   {
//     text: '斯洛文尼亚语',
//     key: 'slo',
//   },
//   {
//     text: '泰语',
//     key: 'th',
//   },
//   {
//     text: '文言文',
//     key: 'wyw',
//   },
//   {
//     text: '西班牙语',
//     key: 'spa',
//   },
//   {
//     text: '希腊语',
//     key: 'el',
//   },
//   {
//     text: '匈牙利语',
//     key: 'hu',
//   },
//   {
//     text: '中文',
//     key: 'zh',
//   },
//   {
//     text: '英语',
//     key: 'en',
//   },
//   {
//     text: '意大利语',
//     key: 'it',
//   },
//   {
//     text: '越南语',
//     key: 'vie',
//   },
//   {
//     text: '粤语',
//     key: 'yue',
//   },
//   {
//     text: '中文繁体',
//     key: 'cht',
//   },
// ]
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/baiduTranslate/baidu.svg
/* harmony default export */ const baidu = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 90 90\"><path d=\"M24.012 33.588c.535 7.65-3.611 14.173-9.264 14.57-5.651.397-10.667-5.483-11.202-13.135-.535-7.65 3.611-14.174 9.264-14.571 5.652-.396 10.668 5.485 11.202 13.136zM62.938 1.874C57.447.473 51.464 5.363 49.576 12.795c-1.895 7.432 1.023 14.592 6.514 15.993 5.49 1.4 11.476-3.488 13.365-10.921 2.459-9.673-5.202-15.659-6.517-15.993zm12.874 25.051c-5.775.086-10.359 5.579-10.232 14.088.127 8.508 4.904 12.387 10.685 12.301 5.772-.086 10.358-4.103 10.233-12.614-.168-11.074-9.303-13.795-10.686-13.775zM33.965 0c-5.496 0-9.951 6.16-9.951 13.756s4.455 13.753 9.951 13.753 9.952-6.157 9.952-13.753S39.461 0 33.965 0zm-1.272 42.72c-3.175 4.56-6.775 9.011-13.762 14.843-6.988 5.832-9.952 9.858-9.952 15.795 0 5.936 3.388 15.795 13.022 15.795s14.292-2.121 21.915-2.121c7.623 0 12.707 2.969 22.339 2.969 9.635 0 13.658-9.117 13.658-15.053 0-5.937-1.672-9.297-9.391-16.072-4.945-4.346-9.138-7.885-15.702-17.002-3.245-4.508-6.987-5.088-10.904-5.088-3.917-.001-8.046 1.377-11.223 5.934z\" fill=\"#2f7fda\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/baiduTranslate/baiduCircle.svg
/* harmony default export */ const baiduCircle = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 97.75 97.75\" width=\"97.75\" height=\"97.75\"><path d=\"M48.875 0C21.882 0 0 21.883 0 48.875S21.882 97.75 48.875 97.75 97.75 75.867 97.75 48.875 75.868 0 48.875 0zm3.443 25.67c.443-4.104 5.349-10.395 9.277-9.49 3.912.892 7.49 6.093 6.766 10.563-.709 4.477-4.258 10.385-9.799 9.66-5.531-.708-6.783-5.715-6.244-10.733zM40.726 14.393c4.138 0 7.481 4.76 7.481 10.652 0 5.89-3.344 10.657-7.481 10.657-4.141 0-7.493-4.768-7.493-10.657-.001-5.893 3.353-10.652 7.493-10.652zM17.361 39.626s.886-8.766 6.955-9.307c4.82-.422 8.373 4.855 8.742 7.878.22 1.96 1.243 10.928-6.253 12.537-7.482 1.616-10.266-7.048-9.444-11.108zm57.077 37.781c-4.097 9.671-19.086 4.645-19.086 4.645s-5.528-1.782-11.955-.352c-6.412 1.435-11.941.894-11.941.894s-7.503.182-9.642-9.305c-2.136-9.493 7.486-14.691 8.206-15.574.715-.902 5.703-4.297 8.912-9.672 3.218-5.362 12.847-9.662 19.63.896 4.998 7.162 13.561 13.785 13.561 13.785s6.416 5.018 2.315 14.683zm-1.247-22.023c-8.215.179-8.559-5.551-8.559-9.66 0-4.303.875-10.395 7.489-10.395 6.603 0 8.376 6.455 8.376 8.597.002 2.155.901 11.276-7.306 11.458z\" fill=\"#2f7fda\"/></svg>\n");
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/icons.ts


const BaiduTranslate_icons_icons = {
  baiduIcon: baidu,
  baiduCircle: baiduCircle
};
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/store/index.ts


function BaiduTranslate_store_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function BaiduTranslate_store_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? BaiduTranslate_store_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : BaiduTranslate_store_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







const baiduLanguage = enumType(BAIDU_LANGUAGES, 'BAIDU_LANGUAGES');
const BaiduTranslate_store_storeType = fallbackInterface(BaiduTranslate_store_objectSpread(BaiduTranslate_store_objectSpread({}, providerCommonStore), {}, {
  display: fallback(es6_boolean, true),
  icon: fallback(keyof(BaiduTranslate_icons_icons), 'baiduIcon'),
  targetLanguage: fallback(baiduLanguage, BAIDU_LANGUAGES.zh),
  secondTargetLanguage: fallback(baiduLanguage, BAIDU_LANGUAGES.en)
}));
const BaiduTranslate_store_defaultStore = BaiduTranslate_store_storeType.defaultData;
const BaiduTranslate_store_store = {
  data: null
};
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/translate.ts







const detectLang = async word => {
  const formdata = {
    query: Array.from(word).splice(0, 50).join('')
  };
  const response = await got({
    method: 'POST',
    headers: {
      'referer': 'https://fanyi.baidu.com',
      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
    },
    url: 'https://fanyi.baidu.com/langdetect',
    data: new (url_search_params_default())(formdata).toString(),
    timeout: 5000
  });

  if (Either_isRight(response)) {
    const result = JSON.parse(response.right.responseText);

    if (result.error === 0) {
      return result.lan;
    }
  }

  throw new Error('检测翻译文本语言失败！');
};

const fetchTranslation = async ({
  word,
  sl,
  tl
}) => {
  let token;

  try {
    token = await helpers_token(word);
  } catch (e) {
    token = await helpers_token(word, true);
  }

  const query = {
    from: sl,
    to: tl,
    query: word,
    transtype: 'translang',
    simple_means_flag: '3',
    sign: token.sign,
    token: token.token
  };
  const response = await got({
    method: 'POST',
    headers: {
      'referer': 'https://fanyi.baidu.com',
      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
      'User-Agent': window.navigator.userAgent
    },
    url: 'https://fanyi.baidu.com/v2transapi',
    data: new (url_search_params_default())(query).toString(),
    timeout: 5000
  });

  if (Either_isRight(response)) {
    const result = JSON.parse(response.right.responseText);
    const trans_result = result.trans_result;

    if (trans_result && trans_result.type === 2 && trans_result.status === 0) {
      return trans_result.data.map(v => v.dst);
    }
  }

  throw new Error('翻译出错！');
};

const BaiduTranslate_translate_translate = async p => {
  try {
    const auto = !p.payload || p.payload.sl === 'auto';
    const sl = !p.payload || auto ? await detectLang(p.word) : p.payload.sl; // eslint-disable-next-line no-nested-ternary

    const tl = p.payload ? p.payload.tl : BaiduTranslate_store_store.data.targetLanguage !== sl ? BaiduTranslate_store_store.data.targetLanguage : BaiduTranslate_store_store.data.secondTargetLanguage;
    const result = await fetchTranslation({
      word: p.word,
      sl,
      tl
    });
    return Either_right(() => {
      BaiduTranslate_container_data.data = result;
      BaiduTranslate_container_data.inputText = p.word;
      BaiduTranslate_container_data.autoMode = auto;
      BaiduTranslate_container_data.sourceLanguage = sl;
      BaiduTranslate_container_data.targetLanguage = tl;
    });
  } catch (e) {
    return Either_left({
      message: e.message
    });
  }
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/BaiduTranslate/container/index.vue?vue&type=template&id=27d91445&scoped=true&ts=true


const containervue_type_template_id_27d91445_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-27d91445"), n = n(), popScopeId(), n);

const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_1 = {
  class: "baidu-translate-box flex-col relative text-grey-900"
};
const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_2 = {
  class: "language-select-box select-none w-full"
};
const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_3 = {
  class: "title-box flex justify-between"
};
const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_4 = {
  class: "items-box flex flex-wrap mt-1"
};
const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_5 = ["onClick"];
const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_6 = {
  class: "content mb-2px flex-col"
};
const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_7 = {
  class: "bottom-info-box flex justify-between"
};
const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_8 = {
  class: "tts-box flex"
};

const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_9 = /*#__PURE__*/createTextVNode(" 源 ");

const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_10 = /*#__PURE__*/createTextVNode(" 译 ");

const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_11 = {
  class: "language-info-box flex"
};

const containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_12 = /*#__PURE__*/containervue_type_template_id_27d91445_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "px-1"
}, " -> ", -1));

function containervue_type_template_id_27d91445_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  const _component_scrollable = resolveComponent("scrollable");

  return openBlock(), createElementBlock("div", containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_scrollable, {
    class: "scroll-container"
  }, {
    default: withCtx(({
      scrollBar
    }) => [createBaseVNode("div", {
      class: normalizeClass(["content-box flex-col flex-auto text-14 break-words", [scrollBar && 'py-10px pl-10px pr-14px', !scrollBar && 'p-10px']])
    }, [withDirectives(createBaseVNode("div", containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_2, [createBaseVNode("div", containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_3, [withDirectives(createBaseVNode("div", null, "源语言", 512), [[vShow, _ctx.state.type === 'source']]), withDirectives(createBaseVNode("div", null, "翻译到", 512), [[vShow, _ctx.state.type === 'target']]), createBaseVNode("div", {
      class: "cancel-button text-center text-grey-600",
      onClick: _cache[0] || (_cache[0] = $event => _ctx.state.visible = false)
    }, "取消")]), withDirectives(createBaseVNode("div", containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_4, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.languages, v => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass({
          'language-item text-center text-grey-600': true,
          'active text-grey-800': _ctx.state.type === 'source' ? v.id === _ctx.containerData.sourceLanguage && !_ctx.containerData.autoMode : v.id === _ctx.containerData.targetLanguage
        }),
        key: v.id,
        onClick: $event => _ctx.handleLanguageSelect(v.id)
      }, toDisplayString(v.name), 11, containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_5);
    }), 128)), _ctx.state.type === 'source' ? (openBlock(), createElementBlock("div", {
      class: normalizeClass({
        'language-item text-center text-grey-600': true,
        'active text-grey-800': _ctx.containerData.autoMode
      }),
      key: "auto",
      onClick: _cache[1] || (_cache[1] = $event => _ctx.handleLanguageSelect('auto'))
    }, " 自动检测 ", 2)) : createCommentVNode("", true)], 512), [[vShow, _ctx.state.visible]])], 512), [[vShow, _ctx.state.visible]]), withDirectives(createBaseVNode("div", containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_6, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.containerData.data, row => {
      return openBlock(), createElementBlock("div", {
        class: "row",
        key: row
      }, toDisplayString(row), 1);
    }), 128))], 512), [[vShow, !_ctx.state.visible]]), withDirectives(createBaseVNode("div", containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_7, [createBaseVNode("div", containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_8, [createBaseVNode("div", {
      class: "play-sound flex flex-center",
      onClick: _cache[2] || (_cache[2] = $event => _ctx.handlePlay('source'))
    }, [containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_9, runtime_core_esm_bundler_createVNode(_component_i_icon, {
      class: "audio-icon",
      svg: _ctx.icon.play_speaker_filled_audio_tool_59284
    }, null, 8, ["svg"])]), createBaseVNode("div", {
      class: "play-sound flex flex-center ml-2",
      onClick: _cache[3] || (_cache[3] = $event => _ctx.handlePlay('target'))
    }, [containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_10, runtime_core_esm_bundler_createVNode(_component_i_icon, {
      class: "audio-icon",
      svg: _ctx.icon.play_speaker_filled_audio_tool_59284
    }, null, 8, ["svg"])])]), createBaseVNode("div", containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_11, [createBaseVNode("div", {
      class: "language",
      onClick: _cache[4] || (_cache[4] = $event => _ctx.showLanguageSelect('source'))
    }, toDisplayString(_ctx.getLanguage(_ctx.containerData.sourceLanguage)) + " " + toDisplayString(_ctx.containerData.autoMode ? '(自动检测)' : ''), 1), containervue_type_template_id_27d91445_scoped_true_ts_true_hoisted_12, createBaseVNode("div", {
      class: "language",
      onClick: _cache[5] || (_cache[5] = $event => _ctx.showLanguageSelect('target'))
    }, toDisplayString(_ctx.getLanguage(_ctx.containerData.targetLanguage)), 1)])], 512), [[vShow, !_ctx.state.visible]])], 2)]),
    _: 1
  })]);
}
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/container/index.vue?vue&type=template&id=27d91445&scoped=true&ts=true

;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/playAudio.ts




const BaiduTranslate_playAudio_playAudio = async (word, tl) => {
  const volume = 0.7;
  const query = {
    lan: tl,
    text: word,
    spd: tl === 'zh' ? '5' : '3',
    source: 'web'
  };
  const url = `https://fanyi.baidu.com/gettts?${new (url_search_params_default())(query).toString()}`;

  if (audioCacheService.play(url, volume)) {
    return;
  }

  const response = await got({
    method: 'GET',
    headers: {
      'Referer': 'https://fanyi.baidu.com/',
      'Accept': '*/*',
      'Cache-Control': 'no-cache',
      'Pragma': 'no-cache',
      'upgrade-insecure-requests': '1'
    },
    responseType: 'arraybuffer',
    url,
    timeout: 5000
  });

  if (Either_isRight(response)) {
    audioCacheService.play(url, response.right.response, volume);
  }
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/BaiduTranslate/container/index.ts?vue&type=script&lang=ts








const containervue_type_script_lang_ts_languages = Object.entries(BAIDU_LANGUAGE_MAP).map(([id, name]) => ({
  id: id,
  name
}));
const BaiduTranslate_containervue_type_script_lang_ts_icon = {
  play_speaker_filled_audio_tool_59284: speaker_filled_audio_tool_59284
};
/* harmony default export */ const BaiduTranslate_containervue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'BaiduTranslateContainer',
  components: {
    Scrollable: Scrollable
  },
  setup: () => {
    const state = reactivity_esm_bundler_reactive({
      visible: false,
      type: 'source'
    });

    const getLanguage = language => BAIDU_LANGUAGE_MAP[language] || language;

    const handleLanguageSelect = language => {
      let sl = state.type === 'source' ? language : BaiduTranslate_container_data.sourceLanguage;
      let tl = state.type === 'target' ? language : BaiduTranslate_container_data.targetLanguage;

      if (state.type === 'source' && language === BaiduTranslate_container_data.targetLanguage || state.type === 'target' && language === BaiduTranslate_container_data.sourceLanguage) {
        sl = BaiduTranslate_container_data.targetLanguage;
        tl = BaiduTranslate_container_data.sourceLanguage;
      }

      bus.emit({
        type: EVENTS.TRANSLATE,
        word: BaiduTranslate_container_data.inputText,
        param: {
          provider: BaiduTranslateProvider.id,
          param: {
            sl,
            tl
          }
        }
      });
      state.visible = false;
    };

    const showLanguageSelect = type => {
      state.type = type;
      state.visible = true;
    };

    const handlePlay = type => {
      const word = type === 'source' ? BaiduTranslate_container_data.inputText : BaiduTranslate_container_data.data.join();
      const tl = type === 'source' ? BaiduTranslate_container_data.sourceLanguage : BaiduTranslate_container_data.targetLanguage;
      BaiduTranslate_playAudio_playAudio(word, tl);
    };

    return {
      state,
      languages: containervue_type_script_lang_ts_languages,
      icon: BaiduTranslate_containervue_type_script_lang_ts_icon,
      containerData: BaiduTranslate_container_data,
      getLanguage,
      handleLanguageSelect,
      showLanguageSelect,
      handlePlay
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/container/index.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/BaiduTranslate/container/index.sass?vue&type=style&index=0&id=27d91445&lang=sass&scoped=true
var containervue_type_style_index_0_id_27d91445_lang_sass_scoped_true = __webpack_require__(881);
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/container/index.sass?vue&type=style&index=0&id=27d91445&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/container/index.vue




;


const BaiduTranslate_container_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(BaiduTranslate_containervue_type_script_lang_ts, [['render',containervue_type_template_id_27d91445_scoped_true_ts_true_render],['__scopeId',"data-v-27d91445"]])

/* harmony default export */ const BaiduTranslate_container = (BaiduTranslate_container_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/BaiduTranslate/settings/index.vue?vue&type=template&id=bfc643c4&ts=true

const settingsvue_type_template_id_bfc643c4_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};
const settingsvue_type_template_id_bfc643c4_ts_true_hoisted_2 = {
  class: "flex mt-6 pt-1"
};
const settingsvue_type_template_id_bfc643c4_ts_true_hoisted_3 = {
  class: "flex-col items-start grow-0 pr-12"
};

const settingsvue_type_template_id_bfc643c4_ts_true_hoisted_4 = /*#__PURE__*/createBaseVNode("div", {
  class: "text-grey-600 pr-6 mb-2"
}, "语言", -1);

const settingsvue_type_template_id_bfc643c4_ts_true_hoisted_5 = {
  class: "flex-col items-center grow-0"
};

const settingsvue_type_template_id_bfc643c4_ts_true_hoisted_6 = /*#__PURE__*/createBaseVNode("div", {
  class: "text-grey-600 pr-6 mb-1"
}, "首选语言", -1);

const settingsvue_type_template_id_bfc643c4_ts_true_hoisted_7 = {
  class: "flex-col items-center grow-0"
};

const settingsvue_type_template_id_bfc643c4_ts_true_hoisted_8 = /*#__PURE__*/createBaseVNode("div", {
  class: "text-grey-600 pr-6 mb-1"
}, "备选语言", -1);

const settingsvue_type_template_id_bfc643c4_ts_true_hoisted_9 = {
  key: 0,
  class: "text-14 text-red-500 mt-2 mb-0"
};

const settingsvue_type_template_id_bfc643c4_ts_true_hoisted_10 = /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-1 mb-0"
}, [/*#__PURE__*/createTextVNode(" 首选语言：默认翻译到的语言 "), /*#__PURE__*/createBaseVNode("br"), /*#__PURE__*/createTextVNode(" 备选语言：当检测到翻译文本语言为首选语言时，翻译到备选语言 ")], -1);

function settingsvue_type_template_id_bfc643c4_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_provider_common = resolveComponent("provider-common");

  const _component_i_radio = resolveComponent("i-radio");

  const _component_i_radio_group = resolveComponent("i-radio-group");

  return openBlock(), createElementBlock("div", settingsvue_type_template_id_bfc643c4_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_provider_common, {
    icon: _ctx.form.icon,
    "onUpdate:icon": _cache[0] || (_cache[0] = $event => _ctx.form.icon = $event),
    display: _ctx.form.display,
    "onUpdate:display": _cache[1] || (_cache[1] = $event => _ctx.form.display = $event),
    "enable-hotkey": _ctx.form.enableHotkey,
    "onUpdate:enable-hotkey": _cache[2] || (_cache[2] = $event => _ctx.form.enableHotkey = $event),
    hotkey: _ctx.form.hotkey,
    "onUpdate:hotkey": _cache[3] || (_cache[3] = $event => _ctx.form.hotkey = $event),
    name: "百度翻译",
    icons: _ctx.iconOptions
  }, null, 8, ["icon", "display", "enable-hotkey", "hotkey", "icons"]), createBaseVNode("div", settingsvue_type_template_id_bfc643c4_ts_true_hoisted_2, [createBaseVNode("div", settingsvue_type_template_id_bfc643c4_ts_true_hoisted_3, [settingsvue_type_template_id_bfc643c4_ts_true_hoisted_4, (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.languageOptions, n => {
    return openBlock(), createElementBlock("div", {
      class: "language-option text-16 text-grey-600 mb-2",
      key: n.key
    }, toDisplayString(n.text), 1);
  }), 128))]), createBaseVNode("div", settingsvue_type_template_id_bfc643c4_ts_true_hoisted_5, [settingsvue_type_template_id_bfc643c4_ts_true_hoisted_6, runtime_core_esm_bundler_createVNode(_component_i_radio_group, {
    class: "mt-0 grow-0",
    modelValue: _ctx.form.targetLanguage,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => _ctx.form.targetLanguage = $event)
  }, {
    default: withCtx(() => [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.languageOptions, n => {
      return openBlock(), createBlock(_component_i_radio, {
        key: n.key,
        label: "",
        value: n.key
      }, null, 8, ["value"]);
    }), 128))]),
    _: 1
  }, 8, ["modelValue"])]), createBaseVNode("div", settingsvue_type_template_id_bfc643c4_ts_true_hoisted_7, [settingsvue_type_template_id_bfc643c4_ts_true_hoisted_8, runtime_core_esm_bundler_createVNode(_component_i_radio_group, {
    class: "mt-0",
    modelValue: _ctx.form.secondTargetLanguage,
    "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => _ctx.form.secondTargetLanguage = $event)
  }, {
    default: withCtx(() => [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.languageOptions, n => {
      return openBlock(), createBlock(_component_i_radio, {
        key: n.key,
        label: "",
        value: n.key
      }, null, 8, ["value"]);
    }), 128))]),
    _: 1
  }, 8, ["modelValue"])])]), _ctx.form.targetLanguage === _ctx.form.secondTargetLanguage ? (openBlock(), createElementBlock("p", settingsvue_type_template_id_bfc643c4_ts_true_hoisted_9, " 首选语言和备选语言请选择不同的选项 ")) : createCommentVNode("", true), settingsvue_type_template_id_bfc643c4_ts_true_hoisted_10]);
}
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/settings/index.vue?vue&type=template&id=bfc643c4&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/BaiduTranslate/settings/index.ts?vue&type=script&lang=ts





const BaiduTranslate_settingsvue_type_script_lang_ts_iconOptions = Object.entries(BaiduTranslate_icons_icons).map(([k, v]) => ({
  icon: v,
  key: k
}));
/* harmony default export */ const BaiduTranslate_settingsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'BaiduTranslateSettings',
  components: {
    ProviderCommon: providerCommon
  },
  props: {
    active: Boolean
  },
  setup: props => {
    const form = BaiduTranslate_store_store.data;
    let reset = null;
    watch(() => [form.targetLanguage, form.secondTargetLanguage], (n, o) => {
      reset = o && n[0] === n[1] ? o : null;
    });

    const doReset = () => {
      if (props.active && reset) {
        form.targetLanguage = reset[0];
        form.secondTargetLanguage = reset[1];
      }
    };

    watch(() => props.active, doReset);
    runtime_core_esm_bundler_onUnmounted(doReset);
    return {
      iconOptions: BaiduTranslate_settingsvue_type_script_lang_ts_iconOptions,
      form,
      languageOptions: baiduLanguagesOptions
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/settings/index.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/settings/index.vue




;
const BaiduTranslate_settings_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(BaiduTranslate_settingsvue_type_script_lang_ts, [['render',settingsvue_type_template_id_bfc643c4_ts_true_render]])

/* harmony default export */ const BaiduTranslate_settings = (BaiduTranslate_settings_exports_);
;// CONCATENATED MODULE: ./src/provider/BaiduTranslate/index.ts






const BaiduTranslateProvider = createProvider({
  id: 'BAIDU_TRANSLATE',
  label: '百度翻译',
  translate: BaiduTranslate_translate_translate,
  translateView: BaiduTranslate_container,
  settingView: BaiduTranslate_settings,
  icons: BaiduTranslate_icons_icons,
  storeWrapper: BaiduTranslate_store_store,
  storeType: BaiduTranslate_store_storeType,
  defaultStore: BaiduTranslate_store_defaultStore
});
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/container/data.ts

const container_data_data = {
  data: null
};
/* harmony default export */ const UrbanDictionary_container_data = (reactivity_esm_bundler_reactive(container_data_data));
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/translate.ts





const UrbanDictionary_translate_translate = async ({
  word
}) => {
  try {
    /* https://api.urbandictionary.com/v0/define?term={word} */
    const url = `https://api.urbandictionary.com/v0/define?${new (url_search_params_default())({
      term: word
    }).toString()}`;
    const response = await got({
      method: 'GET',
      url,
      timeout: 5000
    });

    if (Either_isLeft(response)) {
      throw new Error(response.left.type);
    }

    const result = JSON.parse(response.right.responseText);

    if (false) {}

    return Either_right(() => {
      UrbanDictionary_container_data.data = util_copy(result);
    });
  } catch (e) {
    return Either_left({
      message: e.message
    });
  }
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/UrbanDictionary/container/index.vue?vue&type=template&id=4129bac5&scoped=true&ts=true


const containervue_type_template_id_4129bac5_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-4129bac5"), n = n(), _popScopeId(), n);

const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_1 = {
  class: "row flex-col"
};
const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_2 = {
  class: "index font-bold"
};
const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_3 = {
  class: "definition"
};
const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_4 = [".textContent"];
const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_5 = {
  class: "text-12 text-grey-500 mt-1"
};
const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_6 = [".textContent"];
const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_7 = {
  class: "flex mt-1 items-center text-12 text-grey-500"
};
const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_8 = {
  class: "mr-2 pr-1 flex flex-none"
};
const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_9 = {
  class: "flex mr-3 flex-none"
};
const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_10 = {
  class: "truncate"
};
const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_11 = ["innerHTML"];
const containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_12 = {
  key: 1,
  class: "inner-content flex flex-center"
};
function containervue_type_template_id_4129bac5_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_UKeyword = resolveComponent("UKeyword");

  const _component_i_icon = resolveComponent("i-icon");

  const _component_scrollable = resolveComponent("scrollable");

  return openBlock(), createElementBlock("div", {
    class: "urban-dictionary-box flex-col relative text-grey-900",
    ref: _ctx.refs.container
  }, [runtime_core_esm_bundler_createVNode(_component_scrollable, {
    class: "scroll-container"
  }, {
    default: withCtx(({
      scrollBar
    }) => [createBaseVNode("div", {
      class: normalizeClass(["content-box flex-col flex-auto text-14 break-words", [scrollBar && 'py-10px pl-10px pr-14px', !scrollBar && 'p-10px']])
    }, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.list, (item, index) => {
      return openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, {
        key: index
      }, [createBaseVNode("div", containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_1, [createBaseVNode("div", containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_2, toDisplayString(index + 1) + ". " + toDisplayString(item.word), 1), createBaseVNode("div", containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_3, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.extractDefinition(item.definition), (definitionItem, definitionIndex) => {
        return openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, null, [definitionItem.isTag ? (openBlock(), createBlock(_component_UKeyword, {
          content: definitionItem.text,
          class: "keyword definition-keyword",
          key: definitionIndex
        }, null, 8, ["content"])) : createCommentVNode("", true), !definitionItem.isTag ? (openBlock(), createElementBlock("span", {
          ".textContent": definitionItem.text,
          key: definitionIndex
        }, null, 8, containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_4)) : createCommentVNode("", true)], 64);
      }), 256))]), createBaseVNode("div", containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_5, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.extractDefinition(item.example), (exampleItem, exampleIndex) => {
        return openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, null, [exampleItem.isTag ? (openBlock(), createBlock(_component_UKeyword, {
          content: exampleItem.text,
          class: "keyword example-keyword",
          key: exampleIndex
        }, null, 8, ["content"])) : createCommentVNode("", true), !exampleItem.isTag ? (openBlock(), createElementBlock("span", {
          ".textContent": exampleItem.text,
          key: exampleIndex
        }, null, 8, containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_6)) : createCommentVNode("", true)], 64);
      }), 256))]), createBaseVNode("div", containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_7, [createBaseVNode("div", containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_8, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
        size: "14",
        class: "thumb-up thumb mr-1",
        svg: _ctx.icon.like_179655
      }, null, 8, ["svg"]), createTextVNode(" " + toDisplayString(item.thumbs_up), 1)]), createBaseVNode("div", containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_9, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
        size: "14",
        color: "#E64C3D",
        class: "thumb thumb-down mr-1",
        svg: _ctx.icon.like_179655
      }, null, 8, ["svg"]), createTextVNode(" " + toDisplayString(item.thumbs_down), 1)]), createBaseVNode("div", containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_10, toDisplayString(_ctx.getTime(item.written_on)), 1)])]), index !== _ctx.list.length - 1 ? (openBlock(), createElementBlock("div", {
        class: "divider my-2 bg-grey-300",
        key: `${index}-divider`
      })) : createCommentVNode("", true)], 64);
    }), 128))], 2)]),
    _: 1
  }), (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.state.tooltips, item => {
    return openBlock(), createElementBlock("div", {
      class: "u-toolip absolute bg-white w-full",
      key: item.id,
      style: normalizeStyle({
        top: `${item.top}px`,
        left: `${item.left}px`
      })
    }, [item.text ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "inner-content",
      innerHTML: item.text
    }, null, 8, containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_11)) : createCommentVNode("", true), !item.text ? (openBlock(), createElementBlock("div", containervue_type_template_id_4129bac5_scoped_true_ts_true_hoisted_12, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
      class: "loadin-spinner rotate",
      size: "24",
      color: "#79d",
      svg: _ctx.icon.loading
    }, null, 8, ["svg"])])) : createCommentVNode("", true)], 4);
  }), 128))], 512);
}
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/container/index.vue?vue&type=template&id=4129bac5&scoped=true&ts=true

// EXTERNAL MODULE: ./node_modules/core-js-pure/features/instance/match-all.js
var match_all = __webpack_require__(7611);
var match_all_default = /*#__PURE__*/__webpack_require__.n(match_all);
;// CONCATENATED MODULE: ./src/assets/img/loading.svg
/* harmony default export */ const loading = ("<svg class=\"icon\" viewBox=\"0 0 1024 1024\"\n  xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"200\">\n  <path fill=\"#000000\" d=\"M512.511 21.483c-271.163 0-491.028 219.86-491.028 491.028 0 271.173 219.856 491.03 491.028 491.03 26.554 0 48.08-21.527 48.08-48.08 0-26.554-21.526-48.08-48.08-48.08-218.065 0-394.869-176.804-394.869-394.87 0-218.06 176.813-394.869 394.87-394.869 218.065 0 394.869 176.804 394.869 394.87 0 26.553 21.526 48.08 48.08 48.08 26.553 0 48.08-21.527 48.08-48.08 0-271.173-219.857-491.03-491.03-491.03z\"/>\n</svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/like_179655.svg
/* harmony default export */ const like_179655 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 485.027 485.027\"><path fill=\"#3C92CA\" d=\"M109.4 459.991H13c-2.1 0-3.9-1.8-3.9-3.9v-248.4c0-2.1 1.8-3.9 3.9-3.9h96.4c2.1 0 3.9 1.8 3.9 3.9v248.4c0 2.1-1.7 3.9-3.9 3.9z\"/><path d=\"M284.6 20.391c-28.2-20.7-67.2-8.8-68.8-8.3-3.8 1.2-6.3 4.7-6.3 8.6v85.8c0 29.1-13.8 53.7-41.1 73.2-21.1 15.1-42.7 21.3-42.9 21.4-.2 0-.3.1-.5.2l-5.1 1.7c-3-4.9-8.3-8.2-14.5-8.2H16.9c-9.3 0-16.9 7.6-16.9 16.9v240.5c0 9.3 7.6 16.9 16.9 16.9h88.6c8 0 14.7-5.6 16.4-13 11.9 12.7 28.8 20.7 47.6 20.7h209.8c44.6 0 73.1-23.3 78.1-64l26.8-170.2c3.9-24.7-6.2-49.7-25.8-63.7-11.1-8-24.2-12.2-37.9-12.2H311.4v-79.6c0-31.2-9-53.6-26.8-66.7zm-180.4 430.5H18.1v-238h86.1v238zm316.3-266.1c9.9 0 19.3 3 27.3 8.8 14 10.1 21.3 28.2 18.4 46.2l-26.7 170.3v.3c-4.9 39.8-35.4 48.2-60.2 48.2H169.5c-26 0-47.1-21.1-47.1-47.1v-190.2l8.3-2.8c2.9-.8 25.2-7.6 47.8-23.7 32.1-22.8 49.1-53.3 49.1-88.2v-78.6c10.4-2 31.3-4 46.4 7.1 12.8 9.4 19.3 26.9 19.3 52v88.7c0 5 4.1 9.1 9.1 9.1h118.1v-.1z\"/></svg>\n");
;// CONCATENATED MODULE: ./src/util/cachePromise.ts


/**
 * 返回原函数，但该函数在连续多次调用时，首次调用未resolve时，返回缓存的 promise
 */
const cachePromiseHof = fn => {
  let promise = null;
  return (...args) => {
    if (promise) {
      return promise;
    }

    promise = promise_default().resolve(fn(...args));
    promise.finally(() => {
      promise = null;
    });
    return promise;
  };
};
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/getApiKey.ts



const apiKeyState = {
  apiKey: ''
};
const getApiKey = cachePromiseHof(async () => {
  if (apiKeyState.apiKey) {
    return;
  }

  const res = await got({
    method: 'GET',
    url: 'https://www.urbandictionary.com/',
    timeout: 5000
  });

  if (Either_isLeft(res)) {
    throw new Error(res.left.type);
  }

  const apiKeyMatch = /"api_key":"([0-9a-f]{32})"/.exec(res.right.responseText);

  if (!apiKeyMatch) {
    return;
  }

  apiKeyState.apiKey = apiKeyMatch[1];
});
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/container/bus.ts


var NAMES;

(function (NAMES) {
  NAMES[NAMES["SHOW_TOOLTIP"] = 0] = "SHOW_TOOLTIP";
  NAMES[NAMES["HIDE_TOOLTIP"] = 1] = "HIDE_TOOLTIP";
})(NAMES || (NAMES = {}));

class UrbanDictionaryBus {
  constructor() {
    defineProperty_defineProperty(this, "id", 0);

    defineProperty_defineProperty(this, "bus", new EventEmitter());
  }

  on(e, h) {
    this.bus.on(String(e), h);
  }

  off(e, h) {
    this.bus.off(String(e), h);
  }

  emit(e, h) {
    this.bus.emit(String(e), h);
  }

  genId() {
    this.id += 1;
    return this.id;
  }

}

const urbanDictionaryBus = new UrbanDictionaryBus();
/* harmony default export */ const container_bus = (urbanDictionaryBus);
// EXTERNAL MODULE: ./node_modules/core-js-pure/stable/instance/trim.js
var trim = __webpack_require__(7995);
var trim_default = /*#__PURE__*/__webpack_require__.n(trim);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/UrbanDictionary/container/component/UKeyword/UKeyword.vue?vue&type=template&id=37ab3860&ts=true


function UKeywordvue_type_template_id_37ab3860_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  var _context;

  return openBlock(), createElementBlock("span", {
    class: "u-keyword relative",
    ref: _ctx.refs.span,
    onClick: _cache[0] || (_cache[0] = //@ts-ignore
    (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onMouseenter: _cache[1] || (_cache[1] = //@ts-ignore
    (...args) => _ctx.showTooltip && _ctx.showTooltip(...args)),
    onMouseleave: _cache[2] || (_cache[2] = //@ts-ignore
    (...args) => _ctx.hideTooltip && _ctx.hideTooltip(...args))
  }, toDisplayString(trim_default()(_context = _ctx.props.content).call(_context)), 545);
}
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/container/component/UKeyword/UKeyword.vue?vue&type=template&id=37ab3860&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/UrbanDictionary/container/component/UKeyword/UKeyword.ts?vue&type=script&lang=ts




/* harmony default export */ const UKeywordvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'UrbanDictionaryKeyword',
  props: {
    content: {
      type: String,
      default: ''
    }
  },
  setup: props => {
    const refs = {
      span: reactivity_esm_bundler_ref()
    };
    const state = reactivity_esm_bundler_reactive({
      id: 0,
      visible: false,
      visibleTimeout: 0
    });

    const handleClick = () => {
      bus.emit({
        type: EVENTS.TRANSLATE,
        word: props.content,
        param: {
          provider: UrbanDictionaryProvider.id
        }
      });
    };

    const showTooltip = () => {
      if (state.visibleTimeout) {
        window.clearTimeout(state.visibleTimeout);
      }

      state.visibleTimeout = window.setTimeout(() => {
        state.visible = true;
      }, 200);
    };

    const hideTooltip = () => {
      window.clearTimeout(state.visibleTimeout);
      state.visibleTimeout = 0;
      state.visible = false;
    };

    runtime_core_esm_bundler_onMounted(() => {
      state.id = container_bus.genId();
    });
    watch(() => state.visible, () => {
      if (state.visible) {
        if (refs.span.value) {
          const rect = refs.span.value.getBoundingClientRect();
          container_bus.emit(NAMES.SHOW_TOOLTIP, {
            top: rect.bottom,
            left: rect.right,
            id: state.id,
            text: props.content
          });
        }
      } else {
        container_bus.emit(NAMES.HIDE_TOOLTIP, {
          id: state.id
        });
      }
    });
    return {
      props,
      refs,
      handleClick,
      showTooltip,
      hideTooltip
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/container/component/UKeyword/UKeyword.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/container/component/UKeyword/UKeyword.vue




;
const UKeyword_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(UKeywordvue_type_script_lang_ts, [['render',UKeywordvue_type_template_id_37ab3860_ts_true_render]])

/* harmony default export */ const UKeyword = (UKeyword_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/UrbanDictionary/container/index.ts?vue&type=script&lang=ts












const keywordCache = new Map();
const UrbanDictionary_containervue_type_script_lang_ts_icon = {
  loading: loading,
  like_179655: like_179655
};
/* harmony default export */ const UrbanDictionary_containervue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'UrbanDictionaryContainer',
  components: {
    Scrollable: Scrollable,
    UKeyword: UKeyword
  },
  setup: () => {
    const refs = {
      container: reactivity_esm_bundler_ref()
    };
    const state = reactivity_esm_bundler_reactive({
      tooltips: []
    });

    const extractDefinition = s => {
      const array = [];

      const groups = match_all_default()(s).call(s, /\[.+?\]/g);

      let start = 0;

      for (const item of groups) {
        if (item.index !== start) {
          array.push({
            text: s.substring(start, item.index),
            isTag: false
          });
        }

        array.push({
          text: item[0].slice(1, -1),
          isTag: true
        });
        start = item.index + item[0].length;
      }

      if (start !== s.length - 1) {
        array.push({
          text: s.substring(start),
          isTag: false
        });
      }

      return array;
    };

    const getTime = time => time.slice(0, time.indexOf('T'));

    const showTooltip = p => {
      if (!refs.container.value) {
        return;
      }

      const rect = refs.container.value.getBoundingClientRect();

      if (state.tooltips.find(v => v.id === p.id)) {
        return;
      }

      const cacheResult = keywordCache.get(p.text);
      const tooltipItem = reactivity_esm_bundler_reactive({
        id: p.id,
        text: '',
        top: p.top - rect.top,
        left: p.left - rect.left
      });
      state.tooltips.push(tooltipItem);

      if (cacheResult) {
        promise_default().resolve(cacheResult).then(d => {
          tooltipItem.text = d;
        });

        return;
      }

      const run = async () => {
        await getApiKey(); // load tooltip

        const res = await got({
          method: 'GET',
          url: `https://api.urbandictionary.com/v0/tooltip?term=${encodeURIComponent(p.text)}&key=${apiKeyState.apiKey}`,
          timeout: 5000,
          responseType: 'json'
        });

        if (Either_isLeft(res)) {
          throw new Error(res.left.type);
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


        return JSON.parse(res.right.responseText).string;
      };

      const promise = run();
      promise.then(d => {
        tooltipItem.text = d;
      });
      keywordCache.set(p.text, promise);
    };

    const hideTooltip = p => {
      const item = state.tooltips.find(v => v.id === p.id);

      if (item) {
        state.tooltips.splice(state.tooltips.indexOf(item), 1);
      }
    };

    const list = runtime_core_esm_bundler_computed(() => {
      var _containerData$data$l, _containerData$data;

      return (_containerData$data$l = (_containerData$data = UrbanDictionary_container_data.data) === null || _containerData$data === void 0 ? void 0 : _containerData$data.list) !== null && _containerData$data$l !== void 0 ? _containerData$data$l : [];
    });
    runtime_core_esm_bundler_onMounted(() => {
      container_bus.on(NAMES.SHOW_TOOLTIP, showTooltip);
      container_bus.on(NAMES.HIDE_TOOLTIP, hideTooltip);
    });
    runtime_core_esm_bundler_onUnmounted(() => {
      container_bus.off(NAMES.SHOW_TOOLTIP, showTooltip);
      container_bus.off(NAMES.HIDE_TOOLTIP, hideTooltip);
    });
    return {
      state,
      list,
      refs,
      icon: UrbanDictionary_containervue_type_script_lang_ts_icon,
      extractDefinition,
      getTime,
      showTooltip,
      hideTooltip
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/container/index.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/UrbanDictionary/container/index.sass?vue&type=style&index=0&id=4129bac5&lang=sass&scoped=true
var containervue_type_style_index_0_id_4129bac5_lang_sass_scoped_true = __webpack_require__(1855);
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/container/index.sass?vue&type=style&index=0&id=4129bac5&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/container/index.vue




;


const UrbanDictionary_container_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(UrbanDictionary_containervue_type_script_lang_ts, [['render',containervue_type_template_id_4129bac5_scoped_true_ts_true_render],['__scopeId',"data-v-4129bac5"]])

/* harmony default export */ const UrbanDictionary_container = (UrbanDictionary_container_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/UrbanDictionary/settings/index.vue?vue&type=template&id=72c125e6&ts=true

const settingsvue_type_template_id_72c125e6_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};
function settingsvue_type_template_id_72c125e6_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_provider_common = resolveComponent("provider-common");

  return openBlock(), createElementBlock("div", settingsvue_type_template_id_72c125e6_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_provider_common, {
    icon: _ctx.form.icon,
    "onUpdate:icon": _cache[0] || (_cache[0] = $event => _ctx.form.icon = $event),
    display: _ctx.form.display,
    "onUpdate:display": _cache[1] || (_cache[1] = $event => _ctx.form.display = $event),
    "enable-hotkey": _ctx.form.enableHotkey,
    "onUpdate:enable-hotkey": _cache[2] || (_cache[2] = $event => _ctx.form.enableHotkey = $event),
    hotkey: _ctx.form.hotkey,
    "onUpdate:hotkey": _cache[3] || (_cache[3] = $event => _ctx.form.hotkey = $event),
    name: "urban dictionary",
    icons: _ctx.iconOptions
  }, null, 8, ["icon", "display", "enable-hotkey", "hotkey", "icons"])]);
}
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/settings/index.vue?vue&type=template&id=72c125e6&ts=true

;// CONCATENATED MODULE: ./src/assets/img/providerIcon/urbanDictionary/urbanDictionary.svg
/* harmony default export */ const urbanDictionary = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 500 500\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"#445588\" d=\"M77.37 92.08s16.13 16.13 19.36 32.27v45.18c0 12.91-6.45 35.49-6.45 51.63 0 19.36 3.23 25.81 6.45 35.49 3.23 9.68 3.23 9.68 3.23 25.81s-3.23 77.44-3.23 77.44l-3.23 48.4 9.68 22.59 12.91-12.91s3.23 9.68 9.68 19.36c6.45 9.68 32.27 19.36 32.27 19.36l32.27 9.68 103.26-41.95s12.91 9.68 22.59 12.91c9.68 3.23 41.95 19.36 58.08 22.59s25.81 6.45 38.72 6.45 25.81-3.23 38.72-9.68c12.91-3.23 29.04-9.68 29.04-9.68l6.45-38.72-77.44-51.63-16.13 12.91s-6.45-54.86-9.68-83.9c-3.23-29.04-9.68-67.76-9.68-67.76l9.68-6.45s-6.45-51.63-9.68-64.54c0-12.91 6.45-45.18 6.45-51.63 0-6.45 3.23-25.81 3.23-25.81V53.36l-22.59-9.68-25.81 9.68L290.34 34l-41.95 22.59 3.23 25.81h70.99l29.04 19.36v19.36l-9.68 9.68s-3.23 32.27-3.23 54.86c-3.23 22.59-3.23 48.4-6.45 74.22-3.23 32.27-9.68 61.31-19.36 87.12 0 0-38.72 22.59-58.08 32.27-29.04 9.68-54.86 9.68-54.86 9.68l-45.18-19.36c-6.45-41.95-12.91-77.44-16.13-106.48-3.23-9.68-3.23-12.91 0-25.81 0-9.68 6.45-45.18 6.45-45.18l-9.68-9.68s6.45-38.72 9.68-51.63c3.23-12.91 3.23-25.81 6.45-35.49 0-9.68 3.23-19.36 3.23-19.36l-6.45-22.59s-25.81-9.68-38.72-12.91C99.96 37.23 83.83 34 83.83 34H58.02c-9.68 0-25.81 3.23-25.81 3.23L12.84 56.59s3.23 9.68 6.45 12.91l3.23 6.45 9.68 3.23 12.91 16.13s12.91 0 22.59-3.23c-.01 3.23 9.67 0 9.67 0\"/></svg>\n");
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/icons.ts

const UrbanDictionary_icons_icons = {
  urbanDictionary: urbanDictionary
};
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/store/index.ts


function UrbanDictionary_store_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function UrbanDictionary_store_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? UrbanDictionary_store_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : UrbanDictionary_store_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }





const UrbanDictionary_store_storeType = fallbackInterface(UrbanDictionary_store_objectSpread(UrbanDictionary_store_objectSpread({}, providerCommonStore), {}, {
  display: fallback(es6_boolean, false),
  icon: fallback(keyof(UrbanDictionary_icons_icons), 'urbanDictionary')
}));
const UrbanDictionary_store_defaultStore = UrbanDictionary_store_storeType.defaultData;
const UrbanDictionary_store_store = {
  data: null
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/UrbanDictionary/settings/index.ts?vue&type=script&lang=ts




const UrbanDictionary_settingsvue_type_script_lang_ts_iconOptions = Object.entries(UrbanDictionary_icons_icons).map(([k, v]) => ({
  icon: v,
  key: k
}));
/* harmony default export */ const UrbanDictionary_settingsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'UrbanDictionarySettings',
  components: {
    ProviderCommon: providerCommon
  },
  setup: () => ({
    form: UrbanDictionary_store_store.data,
    iconOptions: UrbanDictionary_settingsvue_type_script_lang_ts_iconOptions
  })
}));
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/settings/index.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/settings/index.vue




;
const UrbanDictionary_settings_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(UrbanDictionary_settingsvue_type_script_lang_ts, [['render',settingsvue_type_template_id_72c125e6_ts_true_render]])

/* harmony default export */ const UrbanDictionary_settings = (UrbanDictionary_settings_exports_);
;// CONCATENATED MODULE: ./src/provider/UrbanDictionary/index.ts






const UrbanDictionaryProvider = createProvider({
  id: 'URBAN_DICTIONARY',
  label: 'Urban Dictionary',
  translate: UrbanDictionary_translate_translate,
  translateView: UrbanDictionary_container,
  settingView: UrbanDictionary_settings,
  icons: UrbanDictionary_icons_icons,
  storeWrapper: UrbanDictionary_store_store,
  storeType: UrbanDictionary_store_storeType,
  defaultStore: UrbanDictionary_store_defaultStore
});
;// CONCATENATED MODULE: ./src/util/trustedHTMLHack.ts
// eslint-disable-next-line @typescript-eslint/no-unsafe-call
const escapeHTMLPolicy = window.trustedTypes ? trustedTypes.createPolicy('myEscapePolicy', {
  createHTML: string => string
}) : null;
const trustedHTMLHack = (...args) => {
  if (escapeHTMLPolicy) {
    return escapeHTMLPolicy.createHTML(...args);
  }

  return args[0];
};
unsafeWindow.icibaUserscriptTrustedHTML = trustedHTMLHack;
;// CONCATENATED MODULE: ./src/provider/Vocabulary/container/data.ts

const Vocabulary_container_data_data = {
  data: null
};
/* harmony default export */ const Vocabulary_container_data = (reactivity_esm_bundler_reactive(Vocabulary_container_data_data));
;// CONCATENATED MODULE: ./src/provider/Vocabulary/translate.ts







const nonNull = p => {
  if (!p) {
    throw new Error();
  }

  return p;
};

const getAutocomplete = async word => {
  const result = await got({
    method: 'GET',
    url: `https://www.vocabulary.com/dictionary/autocomplete?search=${encodeURIComponent(word)}`,
    headers: {
      Accept: '*/*',
      Host: 'www.vocabulary.com'
    }
  });

  if (Either_isLeft(result)) {
    throw new Error(result.left.type);
  }

  const html = result.right.responseText;
  const div = document.createElement('div');
  div.innerHTML = trustedHTMLHack(html);
  const data = Array.from(div.querySelectorAll('.suggestions > li')).map(li => {
    var _li$getAttribute, _li$getAttribute2, _li$getAttribute3, _li$getAttribute4;

    return {
      lang: (_li$getAttribute = li.getAttribute('lang')) !== null && _li$getAttribute !== void 0 ? _li$getAttribute : '',
      synsetid: (_li$getAttribute2 = li.getAttribute('synsetid')) !== null && _li$getAttribute2 !== void 0 ? _li$getAttribute2 : '',
      word: (_li$getAttribute3 = li.getAttribute('word')) !== null && _li$getAttribute3 !== void 0 ? _li$getAttribute3 : '',
      freq: (_li$getAttribute4 = li.getAttribute('freq')) !== null && _li$getAttribute4 !== void 0 ? _li$getAttribute4 : ''
    };
  });
  return data;
}; // const getExamples = async (word: string) => {
//   const result = await got<ExampleResult>({
//     method: 'GET',
//     url: `https://corpus.vocabulary.com/api/1.0/examples.json?query=${encodeURIComponent(word)}&maxResults=24&startOffset=0&filter=0`,
//     responseType: 'json',
//     headers: {
//       'Accept': '*/*',
//       'Host': 'www.vocabulary.com',
//     },
//   })
//   const data = result.response
//   return data
// }


const getDefinition = async word => {
  var _div$querySelector$te, _div$querySelector, _div$querySelector$te2, _div$querySelector$te3, _div$querySelector2, _div$querySelector2$t;

  const result = await got({
    method: 'GET',
    url: `https://www.vocabulary.com/dictionary/definition.ajax?search=${encodeURIComponent(word)}&lang=en`,
    headers: {
      Accept: '*/*',
      Host: 'www.vocabulary.com'
    }
  });

  if (Either_isLeft(result)) {
    throw new Error(result.left.type);
  }

  const html = result.right.responseText;
  const div = document.createElement('div');
  div.innerHTML = trustedHTMLHack(html);
  const data = {
    short: (_div$querySelector$te = (_div$querySelector = div.querySelector('.word-area .short')) === null || _div$querySelector === void 0 ? void 0 : (_div$querySelector$te2 = _div$querySelector.textContent) === null || _div$querySelector$te2 === void 0 ? void 0 : trim_default()(_div$querySelector$te2).call(_div$querySelector$te2)) !== null && _div$querySelector$te !== void 0 ? _div$querySelector$te : undefined,
    long: (_div$querySelector$te3 = (_div$querySelector2 = div.querySelector('.word-area .long')) === null || _div$querySelector2 === void 0 ? void 0 : (_div$querySelector2$t = _div$querySelector2.textContent) === null || _div$querySelector2$t === void 0 ? void 0 : trim_default()(_div$querySelector2$t).call(_div$querySelector2$t)) !== null && _div$querySelector$te3 !== void 0 ? _div$querySelector$te3 : undefined,
    audio: nonNull(div.querySelector('.word-area .audio')).getAttribute('data-audio') // groups: Array.from(div.querySelectorAll('.definitions .section.definition .group')).map((group, index) => ({
    //   index,
    //   group: Array.from(group.querySelectorAll('.ordinal .sense')).map((sense) => ({
    //     type: nonNull(sense.querySelector('.anchor')).textContent,
    //     definition: (nonNull(nonNull(sense.querySelector('.anchor')).nextSibling).textContent ?? '').trim(),
    //   })),
    //   family: JSON.parse(nonNull(div.querySelector('.section.family vcom\\:wordfamily')).getAttribute('data') ?? ''),
    // })),

  };
  return data;
};

const Vocabulary_translate_translate = async ({
  word
}) => {
  try {
    const autocomplete = await getAutocomplete(word);
    const newWord = autocomplete.some(v => v.word === word) ? word : autocomplete[0].word;
    const definition = await getDefinition(newWord);
    return Either_right(() => {
      Vocabulary_container_data.data = util_copy({
        word: newWord,
        autocomplete,
        definition
      });
    });
  } catch (e) {
    return Either_left({
      message: e.message
    });
  }
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/Vocabulary/container/index.vue?vue&type=template&id=45930c7a&scoped=true&ts=true


const containervue_type_template_id_45930c7a_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-45930c7a"), n = n(), _popScopeId(), n);

const containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_1 = {
  class: "flex-col relative text-grey-900"
};
const containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_2 = {
  class: "word flex items-center"
};
const containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_3 = ["href"];
const containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_4 = {
  key: 0,
  class: "short-def mt-1"
};
const containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_5 = {
  key: 1,
  class: "long-def mt-1 pt-2px text-13"
};
const containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_6 = {
  class: "text-grey-500"
};
const containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_7 = {
  class: "group-index mt-2px mr-1 flex-none text-grey-700 font-bold"
};
const containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_8 = {
  class: "group-item-box"
};
function containervue_type_template_id_45930c7a_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  const _component_scrollable = resolveComponent("scrollable");

  return openBlock(), createElementBlock("div", containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_scrollable, {
    class: "scroll-container"
  }, {
    default: withCtx(({
      scrollBar
    }) => [_ctx.data ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["main-box flex-col flex-auto text-14 text-grey-800 break-words", [scrollBar && 'py-10px pl-10px pr-14px', !scrollBar && 'p-10px']])
    }, [createBaseVNode("div", containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_2, [createBaseVNode("a", {
      class: "text-15 no-underline text-link",
      href: `https://www.vocabulary.com/dictionary/${_ctx.data.word}`,
      target: "_blank",
      rel: "noopener"
    }, toDisplayString(_ctx.data.word), 9, containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_3), _ctx.data.definition.audio ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "play-sound flex flex-center mt-2px ml-1",
      onClick: _cache[0] || (_cache[0] = $event => _ctx.handlePlay(_ctx.data.definition.audio))
    }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
      svg: _ctx.icon.play
    }, null, 8, ["svg"])])) : createCommentVNode("", true)]), _ctx.data.definition.short ? (openBlock(), createElementBlock("div", containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_4, toDisplayString(_ctx.data.definition.short), 1)) : createCommentVNode("", true), _ctx.data.definition.long ? (openBlock(), createElementBlock("div", containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_5, [createBaseVNode("span", containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_6, toDisplayString(_ctx.data.definition.long), 1)])) : createCommentVNode("", true), (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.data.definition.groups, group => {
      return openBlock(), createElementBlock("div", {
        class: "group-item mt-1 flex text-13",
        key: group.index
      }, [createBaseVNode("div", containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_7, toDisplayString(group.index + 1) + ". ", 1), createBaseVNode("div", containervue_type_template_id_45930c7a_scoped_true_ts_true_hoisted_8, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(group.group, (subGroup, index) => {
        return openBlock(), createElementBlock("div", {
          class: "group-def-item flex mt-2px",
          key: index
        }, [createBaseVNode("div", {
          class: normalizeClass(["group-type px-1 mr-1 self-start flex-none", {
            'text-blue-500': subGroup.type === 'adv',
            'text-orange-400': subGroup.type === 'adj',
            'text-green-600': subGroup.type === 'v',
            'text-red-400': subGroup.type === 'n'
          }])
        }, toDisplayString(subGroup.type) + ".  ", 3), createBaseVNode("div", null, toDisplayString(subGroup.definition), 1)]);
      }), 128))])]);
    }), 128))], 2)) : createCommentVNode("", true)]),
    _: 1
  })]);
}
;// CONCATENATED MODULE: ./src/provider/Vocabulary/container/index.vue?vue&type=template&id=45930c7a&scoped=true&ts=true

;// CONCATENATED MODULE: ./src/provider/Vocabulary/playAudio.ts



/*
https://audio.vocab.com/1.0/us/B/RQGAHF8JUGF9.mp3
https://audio.vocab.com/1.0/us/${data-audio}.mp3
*/

const Vocabulary_playAudio_playAudio = async key => {
  if (!key) {
    return;
  }

  const url = `https://audio.vocab.com/1.0/us/${key}.mp3`;
  const volume = 0.65;

  if (audioCacheService.play(url, volume)) {
    return;
  }

  const response = await got({
    method: 'GET',
    headers: {
      Referer: 'https://www.vocabulary.com'
    },
    responseType: 'arraybuffer',
    url,
    timeout: 5000
  });

  if (Either_isRight(response)) {
    audioCacheService.play(url, response.right.response, volume);
  }
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/Vocabulary/container/index.ts?vue&type=script&lang=ts





/* harmony default export */ const Vocabulary_containervue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'VocabularyContainer',
  components: {
    Scrollable: Scrollable
  },
  setup: () => {
    const data = runtime_core_esm_bundler_computed(() => Vocabulary_container_data.data);

    const handlePlay = key => {
      if (!key) {
        return;
      }

      Vocabulary_playAudio_playAudio(key);
    };

    return {
      icon: {
        play: speaker_filled_audio_tool_59284
      },
      data,
      handlePlay
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/Vocabulary/container/index.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/Vocabulary/container/index.sass?vue&type=style&index=0&id=45930c7a&lang=sass&scoped=true
var containervue_type_style_index_0_id_45930c7a_lang_sass_scoped_true = __webpack_require__(6446);
;// CONCATENATED MODULE: ./src/provider/Vocabulary/container/index.sass?vue&type=style&index=0&id=45930c7a&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/Vocabulary/container/index.vue




;


const Vocabulary_container_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Vocabulary_containervue_type_script_lang_ts, [['render',containervue_type_template_id_45930c7a_scoped_true_ts_true_render],['__scopeId',"data-v-45930c7a"]])

/* harmony default export */ const Vocabulary_container = (Vocabulary_container_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/Vocabulary/settings/index.vue?vue&type=template&id=3d7263e0&ts=true

const settingsvue_type_template_id_3d7263e0_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};
function settingsvue_type_template_id_3d7263e0_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_provider_common = resolveComponent("provider-common");

  return openBlock(), createElementBlock("div", settingsvue_type_template_id_3d7263e0_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_provider_common, {
    icon: _ctx.form.icon,
    "onUpdate:icon": _cache[0] || (_cache[0] = $event => _ctx.form.icon = $event),
    display: _ctx.form.display,
    "onUpdate:display": _cache[1] || (_cache[1] = $event => _ctx.form.display = $event),
    "enable-hotkey": _ctx.form.enableHotkey,
    "onUpdate:enable-hotkey": _cache[2] || (_cache[2] = $event => _ctx.form.enableHotkey = $event),
    hotkey: _ctx.form.hotkey,
    "onUpdate:hotkey": _cache[3] || (_cache[3] = $event => _ctx.form.hotkey = $event),
    name: "vocabulary.com",
    icons: _ctx.iconOptions
  }, null, 8, ["icon", "display", "enable-hotkey", "hotkey", "icons"])]);
}
;// CONCATENATED MODULE: ./src/provider/Vocabulary/settings/index.vue?vue&type=template&id=3d7263e0&ts=true

;// CONCATENATED MODULE: ./src/assets/img/providerIcon/vocabulary/logo.svg
/* harmony default export */ const logo = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 500 500\"><linearGradient id=\"a\" gradientUnits=\"userSpaceOnUse\" x1=\"108.3592\" y1=\"300.9078\" x2=\"213.5802\" y2=\"491.5423\"><stop offset=\"0\" stop-color=\"#69ac1d\"/><stop offset=\".1934\" stop-color=\"#599a1c\"/><stop offset=\".5835\" stop-color=\"#316a19\"/><stop offset=\"1\" stop-color=\"#003016\"/></linearGradient><linearGradient id=\"b\" gradientUnits=\"userSpaceOnUse\" x1=\"170.5128\" y1=\"250\" x2=\"426.0599\" y2=\"250\"><stop offset=\"0\" stop-color=\"#add099\"/><stop offset=\".1919\" stop-color=\"#a4cb88\"/><stop offset=\".572\" stop-color=\"#8bbe5c\"/><stop offset=\"1\" stop-color=\"#6cae23\"/></linearGradient><path d=\"M30 240.753L98.718 200.713 265.984 500 170.513 500z\" fill=\"url(#a)\"/><path d=\"M405.385,0L470,48.253C334.615,250.507,265.984,500,265.984,500h-95.471 C170.513,500,260.769,193.013,405.385,0z\" fill=\"url(#b)\"/></svg>\n");
;// CONCATENATED MODULE: ./src/provider/Vocabulary/icons.ts

const Vocabulary_icons_icons = {
  logo: logo
};
;// CONCATENATED MODULE: ./src/provider/Vocabulary/store/index.ts


function Vocabulary_store_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function Vocabulary_store_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? Vocabulary_store_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Vocabulary_store_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }





const Vocabulary_store_storeType = fallbackInterface(Vocabulary_store_objectSpread(Vocabulary_store_objectSpread({}, providerCommonStore), {}, {
  display: fallback(es6_boolean, false),
  icon: fallback(keyof(Vocabulary_icons_icons), 'logo')
}));
const Vocabulary_store_defaultStore = Vocabulary_store_storeType.defaultData;
const Vocabulary_store_store = {
  data: null
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/Vocabulary/settings/index.ts?vue&type=script&lang=ts




const Vocabulary_settingsvue_type_script_lang_ts_iconOptions = Object.entries(Vocabulary_icons_icons).map(([k, v]) => ({
  icon: v,
  key: k
}));
/* harmony default export */ const Vocabulary_settingsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'VocabularySettings',
  components: {
    ProviderCommon: providerCommon
  },
  setup: () => ({
    form: Vocabulary_store_store.data,
    iconOptions: Vocabulary_settingsvue_type_script_lang_ts_iconOptions
  })
}));
;// CONCATENATED MODULE: ./src/provider/Vocabulary/settings/index.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/Vocabulary/settings/index.vue




;
const Vocabulary_settings_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Vocabulary_settingsvue_type_script_lang_ts, [['render',settingsvue_type_template_id_3d7263e0_ts_true_render]])

/* harmony default export */ const Vocabulary_settings = (Vocabulary_settings_exports_);
;// CONCATENATED MODULE: ./src/provider/Vocabulary/index.ts






const VocabularyProvider = createProvider({
  id: 'VOCABULARY',
  label: 'Vocabulary',
  translate: Vocabulary_translate_translate,
  translateView: Vocabulary_container,
  settingView: Vocabulary_settings,
  icons: Vocabulary_icons_icons,
  storeWrapper: Vocabulary_store_store,
  storeType: Vocabulary_store_storeType,
  defaultStore: Vocabulary_store_defaultStore
});
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js
/* harmony default export */ const regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js


function validate(uuid) {
  return typeof uuid === 'string' && regex.test(uuid);
}

/* harmony default export */ const esm_browser_validate = (validate);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var stringify_i = 0; stringify_i < 256; ++stringify_i) {
  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!esm_browser_validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const esm_browser_stringify = (stringify);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return esm_browser_stringify(rnds);
}

/* harmony default export */ const esm_browser_v4 = (v4);
// EXTERNAL MODULE: ./node_modules/crypto-js/hmac-sha1.js
var hmac_sha1 = __webpack_require__(7334);
var hmac_sha1_default = /*#__PURE__*/__webpack_require__.n(hmac_sha1);
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/container/data.ts

const AliApiTranslate_container_data_data = {
  data: null,
  inputText: '',
  autoMode: false,
  sourceLanguage: '',
  targetLanguage: ''
};
/* harmony default export */ const AliApiTranslate_container_data = (reactivity_esm_bundler_reactive(AliApiTranslate_container_data_data));
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/aliApiLanguages.ts
var ALI_API_LANGUAGES;

(function (ALI_API_LANGUAGES) {
  ALI_API_LANGUAGES["zh"] = "zh";
  ALI_API_LANGUAGES["en"] = "en";
  ALI_API_LANGUAGES["ja"] = "ja";
  ALI_API_LANGUAGES["ko"] = "ko";
  ALI_API_LANGUAGES["fr"] = "fr";
  ALI_API_LANGUAGES["es"] = "es";
  ALI_API_LANGUAGES["it"] = "it";
  ALI_API_LANGUAGES["tr"] = "tr";
  ALI_API_LANGUAGES["ru"] = "ru";
  ALI_API_LANGUAGES["pt"] = "pt";
  ALI_API_LANGUAGES["vi"] = "vi";
  ALI_API_LANGUAGES["id"] = "id";
  ALI_API_LANGUAGES["th"] = "th";
  ALI_API_LANGUAGES["ms"] = "ms";
})(ALI_API_LANGUAGES || (ALI_API_LANGUAGES = {}));

const ALI_API_LANGUAGE_MAP = {
  [ALI_API_LANGUAGES.zh]: '中文',
  [ALI_API_LANGUAGES.en]: '英语',
  [ALI_API_LANGUAGES.ja]: '日语',
  [ALI_API_LANGUAGES.ko]: '韩语',
  [ALI_API_LANGUAGES.fr]: '法语',
  [ALI_API_LANGUAGES.es]: '西班牙语',
  [ALI_API_LANGUAGES.it]: '意大利语',
  [ALI_API_LANGUAGES.tr]: '土耳其语',
  [ALI_API_LANGUAGES.ru]: '俄语',
  [ALI_API_LANGUAGES.pt]: '葡萄牙语',
  [ALI_API_LANGUAGES.vi]: '越南语',
  [ALI_API_LANGUAGES.id]: '印尼语',
  [ALI_API_LANGUAGES.th]: '泰语',
  [ALI_API_LANGUAGES.ms]: '马来语'
};
const aliApiLanguagesOptions = Object.entries(ALI_API_LANGUAGE_MAP).map(([k, v]) => ({
  text: v,
  key: k
}));
;// CONCATENATED MODULE: ./src/assets/img/providerIcon/aliApiTranslate/aliApi.svg
/* harmony default export */ const aliApi = ("<svg width=\"202\" height=\"173\" xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMidYMid meet\">\n\n <g>\n  <title>background</title>\n  <rect fill=\"none\" id=\"canvas_background\" height=\"175\" width=\"204\" y=\"-1\" x=\"-1\"/>\n </g>\n <g>\n  <title>Layer 1</title>\n  <g id=\"svg_1\" fill=\"#000000\" transform=\"translate(0,173) scale(0.10000000149011612,-0.10000000149011612) \">\n   <path fill=\"#595bd4\" id=\"svg_2\" d=\"m844,1723c-12,-2 -33,-16 -46,-31c-40,-43 -798,-1544 -798,-1580c0,-17 5,-43 12,-57c23,-51 47,-55 297,-55l229,0l377,160c207,88 380,162 384,165c5,2 35,-69 68,-158l60,-162l265,-3l266,-2l31,29c29,27 36,48 31,96c-2,25 -219,627 -229,638c-5,5 -920,-377 -1245,-521c-40,-18 -68,-22 -153,-22c-58,0 -103,4 -101,8c2,5 147,293 322,640l320,632l179,-2l179,-3l73,-200c40,-110 72,-201 72,-201c-17,-14 -313,-132 -317,-126c-4,4 -15,29 -24,55c-10,27 -19,47 -21,45c-11,-14 -236,-460 -233,-463c3,-3 867,360 874,368c7,6 -249,694 -264,711c-40,44 -58,46 -329,45c-142,-1 -268,-4 -279,-6zm830,-1279c42,-116 76,-214 76,-218c0,-3 -88,-6 -195,-6l-195,0l112,225c62,123 115,221 119,217c3,-4 41,-102 83,-218z\"/>\n   <path fill=\"#595bd4\" id=\"svg_3\" d=\"m2400,1195l0,-535l70,0l70,0l0,490l0,490l59,0l59,0l-29,-112c-16,-62 -29,-119 -29,-125c0,-8 13,-13 30,-13l30,0l0,-250l0,-250l-30,0c-26,0 -33,-7 -55,-50l-25,-50l74,0c66,0 78,3 107,27c55,47 59,67 59,338l0,245l-31,0c-24,0 -30,4 -25,15c25,67 66,232 66,269l0,46l-200,0l-200,0l0,-535z\"/>\n   <path fill=\"#595bd4\" id=\"svg_4\" d=\"m2832,1683l3,-48l253,-3l252,-2l0,-406c0,-502 8,-474 -141,-474l-79,0l-20,-40c-11,-21 -20,-42 -20,-45c0,-4 69,-5 154,-3c177,3 193,10 234,88c22,44 22,48 22,462l0,418l35,0l35,0l0,50l0,50l-366,0l-365,0l3,-47z\"/>\n   <path fill=\"#595bd4\" id=\"svg_5\" d=\"m3760,1410l0,-320l225,0l225,0l0,-60l0,-60l-225,0l-225,0l0,-50l0,-50l225,0l225,0l0,-60l0,-60l-260,0l-260,0l0,-45l0,-45l598,2l597,3l3,43l3,42l-265,0l-266,0l0,60l0,60l240,0l240,0l0,50l0,50l-240,0l-240,0l0,60l0,60l168,0c195,0 221,8 262,81c25,43 25,48 28,302l3,257l-530,0l-531,0l0,-320zm450,145l0,-85l-155,0l-155,0l0,85l0,85l155,0l155,0l0,-85zm470,0l0,-85l-160,0l-160,0l0,85l0,85l160,0l160,0l0,-85zm-470,-275l0,-90l-155,0l-155,0l0,90l0,90l155,0l155,0l0,-90zm470,50c0,-52 -21,-103 -51,-124c-19,-13 -49,-16 -146,-16l-123,0l0,90l0,90l160,0l160,0l0,-40z\"/>\n   <path fill=\"#595bd4\" id=\"svg_6\" d=\"m5020,1685l0,-45l120,0l120,0l0,-80c0,-77 -1,-80 -24,-80c-20,0 -25,8 -37,53l-14,52l-68,3c-75,3 -75,2 -52,-63c8,-22 15,-41 15,-42c0,-2 -13,-3 -30,-3c-29,0 -30,-2 -30,-44c0,-42 2,-45 29,-48l29,-3l-28,-72c-15,-40 -25,-74 -22,-77c3,-3 35,-6 72,-6l67,0l30,77c18,49 35,79 45,81c15,3 18,-8 20,-75l3,-78l73,-3l72,-3l0,81c0,77 1,81 21,78c17,-2 27,-19 48,-78l26,-75l63,-3c72,-3 73,-1 42,80c-27,70 -26,78 10,78c29,0 30,2 30,45c0,45 0,45 -35,45l-34,0l14,41c24,68 23,70 -47,67l-61,-3l-15,-52c-12,-45 -18,-53 -38,-53c-23,0 -24,3 -24,80l0,79l97,3l98,3l17,35c9,19 17,38 18,43c0,4 -139,7 -310,7l-310,0l0,-45z\"/>\n   <path fill=\"#595bd4\" id=\"svg_7\" d=\"m5690,1685l0,-45l50,0l50,0l0,-80l0,-80l-50,0l-50,0l0,-45l0,-45l50,0l50,0l0,-119l0,-118l-50,-31c-49,-31 -50,-32 -50,-82c0,-27 2,-50 4,-50c2,0 24,12 50,26l46,26l0,-130c0,-129 0,-131 -26,-151c-15,-12 -37,-21 -50,-21c-25,0 -44,-26 -44,-59c0,-19 6,-21 70,-21c81,0 128,16 158,55c22,28 22,30 22,521l0,494l-115,0l-115,0l0,-45z\"/>\n   <path fill=\"#595bd4\" id=\"svg_8\" d=\"m5960,1685l0,-45l50,0l50,0l0,-80l0,-80l-50,0l-50,0l0,-45l0,-45l50,0l50,0l0,-119l0,-118l-50,-31c-49,-31 -50,-32 -50,-82c0,-27 2,-50 4,-50c2,0 24,12 50,26l46,26l0,-136c0,-128 -1,-136 -22,-150c-12,-9 -35,-16 -51,-16c-23,0 -31,-7 -43,-35c-7,-19 -14,-37 -14,-40c0,-3 36,-5 80,-5c93,0 148,21 168,65c9,19 12,157 12,515l0,490l-115,0l-115,0l0,-45z\"/>\n   <path fill=\"#595bd4\" id=\"svg_9\" d=\"m6340,1685l0,-45l120,0l120,0l0,45l0,45l-120,0l-120,0l0,-45z\"/>\n   <path fill=\"#595bd4\" id=\"svg_10\" d=\"m6680,1685l0,-45l345,0c373,0 367,1 325,-53c-18,-23 -185,-97 -220,-97c-7,0 -49,23 -92,50l-80,51l-96,-3l-97,-3l110,-74c60,-41 105,-76 100,-78c-6,-3 -71,-26 -145,-51l-135,-47l-3,-62c-2,-44 1,-63 9,-63c7,0 103,29 215,65l203,65l193,-81c106,-45 196,-83 201,-86c4,-2 7,25 7,60l0,64l-116,54l-115,53l68,34c122,61 163,118 163,227l0,65l-420,0l-420,0l0,-45z\"/>\n   <path fill=\"#595bd4\" id=\"svg_11\" d=\"m6340,1525c0,-45 0,-45 35,-45l35,0l0,-342c0,-189 5,-361 10,-382c5,-22 20,-51 35,-65c24,-25 32,-26 143,-29l117,-4l18,36c9,20 17,41 17,46c0,6 -31,10 -68,10c-39,0 -75,5 -85,13c-15,11 -17,50 -19,407l-3,395l-117,3l-118,3l0,-46z\"/>\n   <path fill=\"#595bd4\" id=\"svg_12\" d=\"m2850,1214l0,-325l180,3c156,3 182,5 197,21c16,16 18,46 21,322l3,305l-201,0l-200,0l0,-326zm260,8c0,-156 -3,-221 -12,-230c-7,-7 -34,-12 -60,-12l-48,0l0,230l0,230l60,0l60,0l0,-218z\"/>\n   <path fill=\"#595bd4\" id=\"svg_13\" d=\"m7028,1168l-3,-73l-147,-3l-148,-3l0,-44l0,-45l150,0l151,0l-3,-62l-3,-63l-167,-3l-168,-2l0,-45l0,-45l170,0l170,0l0,-60l0,-60l85,0l85,0l0,60l0,60l160,0l160,0l0,45l0,45l-160,0l-160,0l0,65l0,65l140,0l140,0l0,45l0,45l-140,0l-140,0l0,75l0,75l-85,0l-84,0l-3,-72z\"/>\n   <path fill=\"#595bd4\" id=\"svg_14\" d=\"m5020,915l0,-255l250,0c302,0 319,4 356,84c22,48 24,62 24,239l0,187l-315,0l-315,0l0,-255zm240,125l0,-60l-50,0l-50,0l0,60l0,60l50,0l50,0l0,-60zm250,0l0,-60l-50,0l-50,0l0,60l0,60l50,0l50,0l0,-60zm-250,-225l0,-65l-50,0l-50,0l0,65l0,65l50,0l50,0l0,-65zm247,23c-6,-47 -43,-88 -78,-88c-17,0 -19,7 -19,65l0,65l51,0l52,0l-6,-42z\"/>\n   <path fill=\"#595bd4\" id=\"svg_15\" d=\"m2470,160c-38,-77 -70,-142 -70,-145c0,-3 11,-5 25,-5c19,0 29,9 42,35l17,35l86,0l86,0l17,-35c13,-26 23,-35 42,-35c14,0 25,2 25,5c0,3 -32,68 -70,145c-67,133 -72,140 -100,140c-28,0 -33,-7 -100,-140zm134,24c14,-31 26,-58 26,-60c0,-2 -27,-4 -60,-4c-33,0 -60,2 -60,4c0,14 52,116 59,116c5,0 21,-25 35,-56z\"/>\n   <path fill=\"#595bd4\" id=\"svg_16\" d=\"m2770,155l0,-145l131,0c119,0 130,2 127,18c-3,15 -17,17 -106,20l-102,3l0,124l0,125l-25,0l-25,0l0,-145z\"/>\n   <path fill=\"#595bd4\" id=\"svg_17\" d=\"m3070,155l0,-145l25,0l25,0l0,145l0,145l-25,0l-25,0l0,-145z\"/>\n   <path fill=\"#595bd4\" id=\"svg_18\" d=\"m3180,155l0,-145l105,0c139,0 175,17 175,84c0,12 -11,33 -25,46l-24,23l19,25c27,33 25,48 -9,83c-29,28 -32,29 -135,29l-106,0l0,-145zm208,93c16,-16 15,-33 -4,-52c-11,-12 -35,-16 -85,-16l-69,0l0,40l0,40l73,0c43,0 78,-5 85,-12zm0,-124c25,-17 29,-46 8,-64c-8,-6 -49,-14 -90,-17l-76,-6l0,52l0,51l68,0c45,0 75,-5 90,-16z\"/>\n   <path fill=\"#595bd4\" id=\"svg_19\" d=\"m3612,287c-13,-15 -132,-259 -132,-269c0,-5 10,-8 23,-8c17,0 28,10 40,35l17,35l88,0l88,0l15,-33c10,-23 22,-33 42,-35c15,-2 27,-1 27,2c0,4 -32,69 -70,146c-66,131 -73,140 -99,140c-16,0 -33,-6 -39,-13zm68,-97c17,-33 29,-60 28,-61c-19,-5 -110,-4 -114,2c-4,7 46,119 53,119c1,0 16,-27 33,-60z\"/>\n   <path fill=\"#595bd4\" id=\"svg_20\" d=\"m3850,154l0,-146l119,4c100,2 122,6 140,22c29,27 28,76 -3,105l-25,23l21,28c14,20 19,36 14,54c-10,42 -52,56 -166,56l-100,0l0,-146zm208,94c16,-16 15,-33 -4,-52c-11,-12 -35,-16 -85,-16l-69,0l0,40l0,40l73,0c43,0 78,-5 85,-12zm0,-124c26,-18 29,-46 7,-64c-9,-7 -49,-15 -90,-18l-75,-5l0,52l0,51l68,0c45,0 75,-5 90,-16z\"/>\n   <path fill=\"#595bd4\" id=\"svg_21\" d=\"m4200,161c-38,-78 -70,-143 -70,-146c0,-3 11,-5 25,-5c19,0 29,9 42,35l17,35l88,0l88,0l14,-35c12,-27 21,-35 40,-35c15,0 26,6 26,13c0,6 -31,70 -68,142c-63,123 -69,130 -99,133c-32,3 -33,3 -103,-137zm156,-29c-6,-5 -100,-10 -108,-5c-4,2 3,25 15,51c39,82 38,82 69,17c15,-32 26,-61 24,-63z\"/>\n   <path fill=\"#595bd4\" id=\"svg_22\" d=\"m4640,275c0,-24 2,-25 60,-25l60,0l0,-120l0,-120l25,0l25,0l0,120l0,119l63,3c54,3 62,5 62,23c0,19 -8,20 -147,23l-148,3l0,-26z\"/>\n   <path fill=\"#595bd4\" id=\"svg_23\" d=\"m4977,293c-4,-3 -7,-69 -7,-145l0,-138l25,0c24,0 25,3 25,60l0,60l49,0c61,0 107,-34 117,-86c6,-31 9,-34 40,-34c32,0 34,2 28,28c-9,37 -19,54 -43,76l-20,19l29,27c53,49 31,113 -45,130c-46,11 -188,13 -198,3zm178,-43c37,-14 43,-39 16,-62c-17,-13 -40,-18 -87,-18l-64,0l0,45l0,45l54,0c30,0 66,-4 81,-10z\"/>\n   <path fill=\"#595bd4\" id=\"svg_24\" d=\"m5362,155l-72,-145l29,0c25,0 31,6 41,35l12,35l89,0l89,0l17,-35c13,-28 23,-35 45,-35l28,0l-72,145c-70,139 -74,145 -103,145c-29,0 -33,-6 -103,-145zm131,35l26,-60l-60,0c-32,0 -59,2 -59,5c0,11 55,115 60,115c4,0 18,-27 33,-60z\"/>\n   <path fill=\"#595bd4\" id=\"svg_25\" d=\"m5667,293c-4,-3 -7,-69 -7,-145l0,-138l25,0c24,0 24,1 27,105l3,106l90,-106c80,-94 94,-105 123,-105l33,0l-3,143l-3,142l-25,0c-25,0 -25,-1 -30,-103l-5,-102l-93,105c-85,96 -115,118 -135,98z\"/>\n   <path fill=\"#595bd4\" id=\"svg_26\" d=\"m6065,286c-41,-18 -57,-40 -53,-72c4,-38 41,-61 128,-79c80,-17 104,-32 94,-58c-17,-47 -148,-40 -181,9c-10,16 -23,24 -36,22c-33,-5 -31,-26 5,-62c27,-27 45,-35 89,-41c102,-13 184,30 177,91c-4,39 -51,68 -136,83c-85,15 -108,34 -73,62c34,28 93,25 129,-6c30,-25 72,-34 72,-14c0,60 -133,101 -215,65z\"/>\n   <path fill=\"#595bd4\" id=\"svg_27\" d=\"m6357,293c-4,-3 -7,-69 -7,-145l0,-138l116,0c105,0 115,2 112,18c-3,14 -17,17 -91,20l-87,3l0,124c0,115 -2,125 -18,125c-10,0 -22,-3 -25,-7z\"/>\n   <path fill=\"#595bd4\" id=\"svg_28\" d=\"m6662,155l-72,-145l29,0c25,0 32,6 42,35l13,35l88,0l88,0l17,-35c13,-28 23,-35 45,-35l28,0l-72,145c-70,139 -74,145 -103,145c-29,0 -33,-6 -103,-145zm131,40c15,-31 27,-58 27,-60c0,-3 -27,-5 -60,-5c-33,0 -60,2 -60,5c0,10 55,115 60,115c3,0 18,-25 33,-55z\"/>\n   <path fill=\"#595bd4\" id=\"svg_29\" d=\"m7237,294c-4,-4 -7,-70 -7,-146l0,-138l146,0c133,0 145,1 142,18c-3,15 -18,17 -116,20l-112,3l0,44l0,45l100,0c93,0 100,1 100,20c0,19 -7,20 -100,20l-100,0l0,35l0,34l113,3c104,3 112,4 112,23c0,19 -8,20 -136,23c-74,1 -138,-1 -142,-4z\"/>\n   <path fill=\"#595bd4\" id=\"svg_30\" d=\"m6900,270c0,-18 7,-20 60,-20l60,0l0,-120l0,-120l25,0l25,0l0,120l0,120l65,0c58,0 65,2 65,20c0,19 -7,20 -150,20c-143,0 -150,-1 -150,-20z\"/>\n  </g>\n </g>\n</svg>");
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/icons.ts

const AliApiTranslate_icons_icons = {
  aliApiIcon: aliApi
};
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/store/index.ts


function AliApiTranslate_store_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function AliApiTranslate_store_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AliApiTranslate_store_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AliApiTranslate_store_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







const aliApiLanguage = enumType(ALI_API_LANGUAGES, 'ALI_API_LANGUAGES');
const AliApiTranslate_store_storeType = fallbackInterface(AliApiTranslate_store_objectSpread(AliApiTranslate_store_objectSpread({}, apiProviderCommonStore), {}, {
  display: fallback(es6_boolean, true),
  icon: fallback(keyof(AliApiTranslate_icons_icons), 'aliApiIcon'),
  targetLanguage: fallback(aliApiLanguage, ALI_API_LANGUAGES.zh)
}));
const AliApiTranslate_store_defaultStore = AliApiTranslate_store_storeType.defaultData;
const AliApiTranslate_store_store = {
  data: null
};
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/translate.ts










const hexToUint8Array = hexString => Uint8Array.from(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));

const MD5Base64 = str => {
  if (str === '') {
    return '';
  }

  const md5Hex = md5_default()(str);
  const md5Uint8Arr = hexToUint8Array(md5Hex);
  const md5Base64 = encode(md5Uint8Arr);
  return md5Base64;
};

const HMACSha1 = (str, key) => {
  if (str === '') {
    return '';
  }

  const sign = encode(hexToUint8Array(hmac_sha1_default()(str, key).toString()));
  sign.toString();
  return sign;
};

function trimIndent(str) {
  return str.split('\n').map(s => trim_default()(s).call(s)).join('\n');
}

const doRequest = async (body, appId, appKey) => {
  const apiDomain = 'mt.aliyuncs.com';
  const apiPath = '/api/translate/web/general';
  const method = 'POST';
  const accept = 'application/json';
  const contentType = 'application/json; charset=UTF-8'; // const date = formatInTimeZone(new Date(), 'Etc/GMT+0', 'E, dd MMM yyyy HH:mm:ss z', { locale: enUS })

  const date = new Date().toUTCString();
  const uuid = esm_browser_v4();
  const version = '2019-01-02';
  const bodyMD5 = MD5Base64(body);
  const stringToSign = `${method}
    ${accept}
    ${bodyMD5}
    ${contentType}
    ${date}
    x-acs-signature-method:HMAC-SHA1
    x-acs-signature-nonce:${uuid}
    x-acs-version:${version}
    ${apiPath}`;
  const signature = HMACSha1(trimIndent(stringToSign), appKey);
  const authorization = `acs ${appId}:${signature}`;

  const sendPost = async () => {
    const response = await got({
      url: `https://${apiDomain}${apiPath}`,
      method,
      headers: {
        'Accept': accept,
        'Content-Type': contentType,
        'Content-MD5': bodyMD5,
        'Date': date,
        'Host': apiDomain,
        'Authorization': authorization,
        'x-acs-signature-nonce': uuid,
        'x-acs-signature-method': 'HMAC-SHA1',
        'x-acs-version': version,
        'Accept-Encoding': 'gzip'
      },
      data: body,
      timeout: 5000
    });

    if (Either_isLeft(response)) {
      throw new Error(response.left.type);
    }

    const result = JSON.parse(response.right.responseText);

    if (result.Code === '200') {
      return Either_right(result);
    }

    return Either_left({
      type: 'unknown',
      res: response.right
    });
  };

  const result = await sendPost();

  if (Either_isLeft(result)) {
    throw new Error(result.left.type);
  }

  return result.right;
};

const getAliApiTranslateResult = async (p, sl, tl) => {
  const appId = AliApiTranslate_store_store.data.appId;
  const appKey = AliApiTranslate_store_store.data.appKey;

  const body = (__webpack_require__(8334)/* .stringify */ .P)({
    'FormatType': 'text',
    'SourceLanguage': sl,
    'TargetLanguage': tl,
    'SourceText': p.word,
    'Scene': 'general'
  });

  return doRequest(body, appId, appKey);
};

const AliApiTranslate_translate_translate = async p => {
  try {
    var _p$payload$sl, _p$payload, _p$payload$tl, _p$payload2;

    const auto = !p.payload || p.payload.sl === 'auto';
    const sl = (_p$payload$sl = (_p$payload = p.payload) === null || _p$payload === void 0 ? void 0 : _p$payload.sl) !== null && _p$payload$sl !== void 0 ? _p$payload$sl : 'auto';
    const tl = (_p$payload$tl = (_p$payload2 = p.payload) === null || _p$payload2 === void 0 ? void 0 : _p$payload2.tl) !== null && _p$payload$tl !== void 0 ? _p$payload$tl : AliApiTranslate_store_store.data.targetLanguage;
    const data = await getAliApiTranslateResult(p, sl, tl);
    return Either_right(() => {
      AliApiTranslate_container_data.data = data;
      AliApiTranslate_container_data.inputText = p.word;
      AliApiTranslate_container_data.autoMode = auto;
      AliApiTranslate_container_data.sourceLanguage = sl;
      AliApiTranslate_container_data.targetLanguage = tl;
    });
  } catch (e) {
    return Either_left({
      message: e.message
    });
  }
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/AliApiTranslate/container/index.vue?vue&type=template&id=97a84f04&scoped=true&ts=true


const containervue_type_template_id_97a84f04_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-97a84f04"), n = n(), popScopeId(), n);

const containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_1 = {
  class: "ali-api-translate-box flex-col relative text-grey-900"
};
const containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_2 = {
  class: "language-select-box select-none w-full"
};
const containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_3 = {
  class: "title-box flex justify-between"
};
const containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_4 = {
  class: "items-box flex flex-wrap mt-1"
};
const containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_5 = ["onClick"];
const containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_6 = {
  class: "bottom-info-box flex justify-between"
};
const containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_7 = {
  class: "language-info-box flex"
};

const containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_8 = /*#__PURE__*/containervue_type_template_id_97a84f04_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "px-1"
}, " -> ", -1));

function containervue_type_template_id_97a84f04_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_scrollable = resolveComponent("scrollable");

  return openBlock(), createElementBlock("div", containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_scrollable, {
    class: "scroll-container"
  }, {
    default: withCtx(({
      scrollBar
    }) => [createBaseVNode("div", {
      class: normalizeClass(["content-box flex-col flex-auto text-14 break-words", [scrollBar && 'py-10px pl-10px pr-14px', !scrollBar && 'p-10px']])
    }, [withDirectives(createBaseVNode("div", containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_2, [createBaseVNode("div", containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_3, [withDirectives(createBaseVNode("div", null, "源语言", 512), [[vShow, _ctx.state.type === 'source']]), withDirectives(createBaseVNode("div", null, "翻译到", 512), [[vShow, _ctx.state.type === 'target']]), createBaseVNode("div", {
      class: "cancel-button text-center text-grey-600",
      onClick: _cache[0] || (_cache[0] = $event => _ctx.state.visible = false)
    }, "取消")]), withDirectives(createBaseVNode("div", containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_4, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.languages, v => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass({
          'language-item text-center text-grey-600': true,
          'active text-grey-800': _ctx.state.type === 'source' ? v.id === _ctx.containerData.sourceLanguage && !_ctx.containerData.autoMode : v.id === _ctx.containerData.targetLanguage
        }),
        key: v.id,
        onClick: $event => _ctx.handleLanguageSelect(v.id)
      }, toDisplayString(v.name), 11, containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_5);
    }), 128)), _ctx.state.type === 'source' ? (openBlock(), createElementBlock("div", {
      class: normalizeClass({
        'language-item text-center text-grey-600': true,
        'active text-grey-800': _ctx.containerData.autoMode
      }),
      key: "auto",
      onClick: _cache[1] || (_cache[1] = $event => _ctx.handleLanguageSelect('auto'))
    }, " 自动检测 ", 2)) : createCommentVNode("", true)], 512), [[vShow, _ctx.state.visible]])], 512), [[vShow, _ctx.state.visible]]), withDirectives(createBaseVNode("div", {
      class: "content mb-2px flex-col"
    }, toDisplayString(_ctx.containerData.data.Data.Translated), 513), [[vShow, !_ctx.state.visible]]), withDirectives(createBaseVNode("div", containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_6, [createBaseVNode("div", containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_7, [createBaseVNode("div", {
      class: "language",
      onClick: _cache[2] || (_cache[2] = $event => _ctx.showLanguageSelect('source'))
    }, toDisplayString(_ctx.containerData.autoMode ? '自动检测' : _ctx.getLanguage(_ctx.containerData.sourceLanguage)), 1), containervue_type_template_id_97a84f04_scoped_true_ts_true_hoisted_8, createBaseVNode("div", {
      class: "language",
      onClick: _cache[3] || (_cache[3] = $event => _ctx.showLanguageSelect('target'))
    }, toDisplayString(_ctx.getLanguage(_ctx.containerData.targetLanguage)), 1)])], 512), [[vShow, !_ctx.state.visible]])], 2)]),
    _: 1
  })]);
}
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/container/index.vue?vue&type=template&id=97a84f04&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/AliApiTranslate/container/index.ts?vue&type=script&lang=ts






const AliApiTranslate_containervue_type_script_lang_ts_languages = Object.entries(ALI_API_LANGUAGE_MAP).map(([id, name]) => ({
  id: id,
  name
}));
/* harmony default export */ const AliApiTranslate_containervue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'AliApiTranslateContainer',
  components: {
    Scrollable: Scrollable
  },
  setup: () => {
    const state = reactivity_esm_bundler_reactive({
      visible: false,
      type: 'source'
    });

    const getLanguage = language => ALI_API_LANGUAGE_MAP[language] || language;

    const handleLanguageSelect = language => {
      let sl = state.type === 'source' ? language : AliApiTranslate_container_data.sourceLanguage;
      let tl = state.type === 'target' ? language : AliApiTranslate_container_data.targetLanguage;

      if (state.type === 'source' && language === AliApiTranslate_container_data.targetLanguage || state.type === 'target' && language === AliApiTranslate_container_data.sourceLanguage) {
        sl = AliApiTranslate_container_data.targetLanguage;
        tl = AliApiTranslate_container_data.sourceLanguage;
      }

      bus.emit({
        type: EVENTS.TRANSLATE,
        word: AliApiTranslate_container_data.inputText,
        param: {
          provider: AliApiTranslateProvider.id,
          param: {
            sl,
            tl
          }
        }
      });
      state.visible = false;
    };

    const showLanguageSelect = type => {
      state.type = type;
      state.visible = true;
    };

    return {
      state,
      languages: AliApiTranslate_containervue_type_script_lang_ts_languages,
      containerData: AliApiTranslate_container_data,
      getLanguage,
      handleLanguageSelect,
      showLanguageSelect
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/container/index.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/AliApiTranslate/container/index.sass?vue&type=style&index=0&id=97a84f04&lang=sass&scoped=true
var containervue_type_style_index_0_id_97a84f04_lang_sass_scoped_true = __webpack_require__(5421);
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/container/index.sass?vue&type=style&index=0&id=97a84f04&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/container/index.vue




;


const AliApiTranslate_container_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(AliApiTranslate_containervue_type_script_lang_ts, [['render',containervue_type_template_id_97a84f04_scoped_true_ts_true_render],['__scopeId',"data-v-97a84f04"]])

/* harmony default export */ const AliApiTranslate_container = (AliApiTranslate_container_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/AliApiTranslate/settings/index.vue?vue&type=template&id=1f52d4ff&ts=true

const settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};
const settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_2 = {
  class: "flex mt-6 pt-1"
};
const settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_3 = {
  class: "flex-col items-start grow-0 pr-12"
};

const settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_4 = /*#__PURE__*/createBaseVNode("div", {
  class: "text-grey-600 pr-6 mb-2"
}, "语言", -1);

const settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_5 = {
  class: "flex-col items-center grow-0"
};

const settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_6 = /*#__PURE__*/createBaseVNode("div", {
  class: "text-grey-600 pr-6 mb-1"
}, "目标语言", -1);

const settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_7 = /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-1 mb-0"
}, " 目标语言：默认翻译到的语言 ", -1);

function settingsvue_type_template_id_1f52d4ff_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_provider_common = resolveComponent("provider-common");

  const _component_ali_api_app_key = resolveComponent("ali-api-app-key");

  const _component_i_radio = resolveComponent("i-radio");

  const _component_i_radio_group = resolveComponent("i-radio-group");

  return openBlock(), createElementBlock("div", settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_provider_common, {
    icon: _ctx.form.icon,
    "onUpdate:icon": _cache[0] || (_cache[0] = $event => _ctx.form.icon = $event),
    display: _ctx.form.display,
    "onUpdate:display": _cache[1] || (_cache[1] = $event => _ctx.form.display = $event),
    "enable-hotkey": _ctx.form.enableHotkey,
    "onUpdate:enable-hotkey": _cache[2] || (_cache[2] = $event => _ctx.form.enableHotkey = $event),
    hotkey: _ctx.form.hotkey,
    "onUpdate:hotkey": _cache[3] || (_cache[3] = $event => _ctx.form.hotkey = $event),
    name: "阿里API翻译",
    icons: _ctx.iconOptions
  }, null, 8, ["icon", "display", "enable-hotkey", "hotkey", "icons"]), runtime_core_esm_bundler_createVNode(_component_ali_api_app_key, {
    "app-id": _ctx.form.appId,
    "onUpdate:app-id": _cache[4] || (_cache[4] = $event => _ctx.form.appId = $event),
    "app-key": _ctx.form.appKey,
    "onUpdate:app-key": _cache[5] || (_cache[5] = $event => _ctx.form.appKey = $event),
    "product-url": "https://www.aliyun.com/product/ai/base_alimt"
  }, null, 8, ["app-id", "app-key"]), createBaseVNode("div", settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_2, [createBaseVNode("div", settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_3, [settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_4, (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.languageOptions, n => {
    return openBlock(), createElementBlock("div", {
      class: "language-option text-16 text-grey-600 mb-2",
      key: n.key
    }, toDisplayString(n.text), 1);
  }), 128))]), createBaseVNode("div", settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_5, [settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_6, runtime_core_esm_bundler_createVNode(_component_i_radio_group, {
    class: "mt-0 grow-0",
    modelValue: _ctx.form.targetLanguage,
    "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => _ctx.form.targetLanguage = $event)
  }, {
    default: withCtx(() => [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.languageOptions, n => {
      return openBlock(), createBlock(_component_i_radio, {
        key: n.key,
        label: "",
        value: n.key
      }, null, 8, ["value"]);
    }), 128))]),
    _: 1
  }, 8, ["modelValue"])])]), settingsvue_type_template_id_1f52d4ff_ts_true_hoisted_7]);
}
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/settings/index.vue?vue&type=template&id=1f52d4ff&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/AliApiTranslate/settings/aliApiAppKey/aliApiAppKey.vue?vue&type=template&id=529beb18&scoped=true&ts=true


const aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-529beb18"), n = n(), _popScopeId(), n);

const aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};
const aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_2 = {
  class: "mt-2"
};
const aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_3 = {
  class: "text-14 text-grey-400 mt-1 mb-0"
};

const aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_4 = /*#__PURE__*/createTextVNode(" 如果没有应用程序ID和密钥， ");

const aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_5 = ["href"];

const aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_6 = /*#__PURE__*/createTextVNode(" 注册并开通相应服务 ");

function aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_text_input_line = resolveComponent("i-text-input-line");

  return openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, null, [createBaseVNode("div", aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_i_text_input_line, {
    class: "app-info-text-input",
    "model-value": _ctx.props.appId,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.handleUpdateAppId($event)),
    label: "应用程序 ID",
    placeholder: "请输入应用程序 ID"
  }, null, 8, ["model-value"]), runtime_core_esm_bundler_createVNode(_component_i_text_input_line, {
    class: "app-info-text-input",
    "model-value": _ctx.props.appKey,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => _ctx.handleUpdateAppKey($event)),
    label: "应用程序密钥",
    "input-type": "password",
    placeholder: "请输入应用程序密钥"
  }, null, 8, ["model-value"])]), createBaseVNode("div", aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_2, [createBaseVNode("p", aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_3, [aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_4, createBaseVNode("a", {
    href: _ctx.props.productUrl,
    target: "_blank",
    rel: "noopener"
  }, "点我", 8, aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_5), aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_hoisted_6])])], 64);
}
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/settings/aliApiAppKey/aliApiAppKey.vue?vue&type=template&id=529beb18&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/AliApiTranslate/settings/aliApiAppKey/aliApiAppKey.ts?vue&type=script&lang=ts

/* harmony default export */ const aliApiAppKeyvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'AliApiAppKey',
  props: {
    appId: String,
    appKey: String,
    productUrl: String
  },
  setup: (props, ctx) => {
    const handleUpdateAppId = appId => {
      ctx.emit('update:appId', appId);
    };

    const handleUpdateAppKey = appKey => {
      ctx.emit('update:appKey', appKey);
    };

    return {
      props,
      handleUpdateAppId,
      handleUpdateAppKey
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/settings/aliApiAppKey/aliApiAppKey.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/AliApiTranslate/settings/aliApiAppKey/aliApiAppKey.sass?vue&type=style&index=0&id=529beb18&lang=sass&scoped=true
var aliApiAppKeyvue_type_style_index_0_id_529beb18_lang_sass_scoped_true = __webpack_require__(2661);
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/settings/aliApiAppKey/aliApiAppKey.sass?vue&type=style&index=0&id=529beb18&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/settings/aliApiAppKey/aliApiAppKey.vue




;


const aliApiAppKey_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(aliApiAppKeyvue_type_script_lang_ts, [['render',aliApiAppKeyvue_type_template_id_529beb18_scoped_true_ts_true_render],['__scopeId',"data-v-529beb18"]])

/* harmony default export */ const aliApiAppKey = (aliApiAppKey_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/AliApiTranslate/settings/index.ts?vue&type=script&lang=ts






const AliApiTranslate_settingsvue_type_script_lang_ts_iconOptions = Object.entries(AliApiTranslate_icons_icons).map(([k, v]) => ({
  icon: v,
  key: k
}));
/* harmony default export */ const AliApiTranslate_settingsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'AliApiTranslateSettings',
  components: {
    ProviderCommon: providerCommon,
    AliApiAppKey: aliApiAppKey
  },
  props: {
    active: Boolean
  },
  setup: props => {
    const form = AliApiTranslate_store_store.data;
    let reset = null;
    watch(() => [form.targetLanguage], (n, o) => {
      reset = o && n[0] === n[1] ? o : null;
    });

    const doReset = () => {
      if (props.active && reset) {
        form.targetLanguage = reset[0];
      }
    };

    watch(() => props.active, doReset);
    runtime_core_esm_bundler_onUnmounted(doReset);
    return {
      iconOptions: AliApiTranslate_settingsvue_type_script_lang_ts_iconOptions,
      form,
      languageOptions: aliApiLanguagesOptions
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/settings/index.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/settings/index.vue




;
const AliApiTranslate_settings_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(AliApiTranslate_settingsvue_type_script_lang_ts, [['render',settingsvue_type_template_id_1f52d4ff_ts_true_render]])

/* harmony default export */ const AliApiTranslate_settings = (AliApiTranslate_settings_exports_);
;// CONCATENATED MODULE: ./src/provider/AliApiTranslate/index.ts






const AliApiTranslateProvider = createProvider({
  id: 'ALI_API_TRANSLATE',
  label: '阿里API翻译',
  translate: AliApiTranslate_translate_translate,
  translateView: AliApiTranslate_container,
  settingView: AliApiTranslate_settings,
  icons: AliApiTranslate_icons_icons,
  storeWrapper: AliApiTranslate_store_store,
  storeType: AliApiTranslate_store_storeType,
  defaultStore: AliApiTranslate_store_defaultStore
});
;// CONCATENATED MODULE: ./src/provider/index.ts







const providers = [IcibaProvider, GoogleDictProvider, GoogleTranslateProvider, BaiduTranslateProvider, UrbanDictionaryProvider, VocabularyProvider, AliApiTranslateProvider];
const getIcon = _provider => {
  const provider = typeof _provider === 'string' ? providers.find(v => v.id === _provider) : _provider;
  const iconsKey = provider.store.icon;
  return provider.icons[iconsKey];
};
;// CONCATENATED MODULE: ./src/util/extendIoTs/provider.ts




class ProviderType extends Type {
  constructor() {
    super('provider', u => providers.some(v => v.id === u), (u, c) => this.is(u) ? success(u) : failure(u, c), es6_identity);

    defineProperty_defineProperty(this, "_tag", 'EnumType');
  }

}

const providerType = new ProviderType();
;// CONCATENATED MODULE: ./src/service/store/core.ts






const icibaCircleIcon = enumType(ICIBA_CIRCLE_ICON, 'ICIBA_CIRCLE_ICON');
const providerIds = providers.map(v => v.id);
const looseProviderArray = new Type('provider-array', u => UnknownArray.is(u), (u, c) => {
  if (!UnknownArray.is(u)) {
    return failure(u, c);
  }

  let newArr = u.filter(v => providerIds.includes(v));
  newArr = newArr.filter((v, i) => newArr.indexOf(v) === i);
  newArr = newArr.concat(providerIds.filter(v => !newArr.includes(v)));
  return success(newArr);
}, es6_identity);
const core_storeType = fallbackInterface({
  providerOrder: fallback(looseProviderArray, () => [...providerIds]),
  defaultProvider: fallback(providerType, 'ICIBA'),
  icibaCircleRightClick: fallback(es6_boolean, true),
  icibaCircleRightClickProvider: fallback(providerType, 'GOOGLE_TRANSLATE'),
  icibaCircleNoCJK: fallback(es6_boolean, false),
  useIcibaCircle: fallback(es6_boolean, true),
  icibaCircleIcon: fallback(icibaCircleIcon, ICIBA_CIRCLE_ICON.DEFAULT),
  pressCtrlToDrag: fallback(es6_boolean, true),
  pressCtrlToShowCircle: fallback(es6_boolean, false),
  mouseOverTranslate: fallback(es6_boolean, false),
  icibaMainInputAutoFocus: fallback(es6_boolean, false),
  history: fallback(es6_boolean, false),
  showPin: fallback(es6_boolean, false),
  pinned: fallback(es6_boolean, false),
  selectionMaxLengthCut: fallback(es6_boolean, false),
  selectionMaxLength: fallback(number, 150),
  icibaMainWidth: fallback(number, 300),
  icibaCircleSize: fallback(number, 22),
  icibaCircleOffsetX: fallback(number, 7),
  icibaCircleOffsetY: fallback(number, 7),
  providerHotkeyAutoFocus: fallback(es6_boolean, false),
  useHotkeyShowUp: fallback(es6_boolean, false),
  hotkeyIcibaMainInputAutoFocus: fallback(es6_boolean, true),
  showUpHotkey: fallback(array(string), () => [])
});
;// CONCATENATED MODULE: ./src/service/store/index.ts






const service_store_store = {};

const store_decode = (type, data) => {
  const report = type.decode(data);

  if (Either_isRight(report)) {
    return report.right;
  }

  return type.defaultData;
};

const initStore = async providers => {
  const dataString = await gmapi_getValue(GM_STORE_KEY.STORE, '');
  const data = pipe(tryCatch(() => JSON.parse(dataString), function_identity), v => Either_isLeft(v) ? {} : v.right, v => {
    if (typeof v !== 'object' || Array.isArray(v)) {
      return {};
    }

    return v;
  });
  providers.forEach(p => {
    const providerStore = store_decode(p.storeType, data[p.id]);
    const reactiveData = reactivity_esm_bundler_reactive(providerStore);
    p.storeWrapper.data = reactiveData;
    data[p.id] = reactiveData;
  });
  const coreStore = store_decode(core_storeType, data.core);
  data.core = reactivity_esm_bundler_reactive(coreStore);
  const newStore = reactivity_esm_bundler_reactive(data);
  watch(newStore, () => {
    const dataString = (__webpack_require__(8334)/* .stringify */ .P)(newStore);

    setValue(GM_STORE_KEY.STORE, dataString);
  }, {
    deep: true
  });
  Object.assign(service_store_store, newStore);
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/App.vue?vue&type=template&id=63465bcb&scoped=true&ts=true


const Appvue_type_template_id_63465bcb_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-63465bcb"), n = n(), _popScopeId(), n);

const Appvue_type_template_id_63465bcb_scoped_true_ts_true_hoisted_1 = {
  class: "the-app"
};
function Appvue_type_template_id_63465bcb_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_iciba_circle = resolveComponent("iciba-circle");

  const _component_iciba_main = resolveComponent("iciba-main");

  const _component_setting_page = resolveComponent("setting-page");

  const _component_google_dict_modal = resolveComponent("google-dict-modal");

  const _component_history_modal = resolveComponent("history-modal");

  return openBlock(), createElementBlock("div", Appvue_type_template_id_63465bcb_scoped_true_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_iciba_circle, {
    ref: _ctx.refs.icibaCircle
  }, null, 512), runtime_core_esm_bundler_createVNode(_component_iciba_main, {
    "get-iciba-circle": () => _ctx.refs.icibaCircle.value
  }, null, 8, ["get-iciba-circle"]), runtime_core_esm_bundler_createVNode(_component_setting_page), runtime_core_esm_bundler_createVNode(_component_google_dict_modal), runtime_core_esm_bundler_createVNode(_component_history_modal)]);
}
;// CONCATENATED MODULE: ./src/App.vue?vue&type=template&id=63465bcb&scoped=true&ts=true

;// CONCATENATED MODULE: ./src/util/lazyLoadHoc.tsx


const lazyLoadHoc = (Component, event) => runtime_core_esm_bundler_defineComponent({
  name: `LazyLoadHoc${Component.name ? `_${Component.name}` : ''}`,
  setup: (_props, setupContext) => {
    const state = reactivity_esm_bundler_reactive({
      load: false
    });
    runtime_core_esm_bundler_onMounted(() => {
      const events = Array.isArray(event) ? event : [event];

      const cb = action => {
        if (state.load) {
          return;
        }

        state.load = true;
        events.forEach(e => {
          bus.off({
            event: e,
            listener: cb
          });
        });
        runtime_core_esm_bundler_nextTick(() => {
          bus.emit(action);
        });
      };

      events.forEach(e => {
        bus.on({
          event: e,
          listener: cb
        });
      });
    });
    return () => state.load && h(Component, {
      props: setupContext.attrs
    });
  }
});
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/view/IcibaMain/IcibaMain.vue?vue&type=template&id=becc6b2c&scoped=true&ts=true


const IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-becc6b2c"), n = n(), popScopeId(), n);

const IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_1 = {
  class: "input-box flex relative flex-none bg-white"
};
const IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_2 = {
  class: "provider-box flex border-b border-grey-350"
};

const IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_3 = /*#__PURE__*/IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "split border-l border-grey-350"
}, null, -1));

const IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_4 = ["onKeydown", "onClick"];
const IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_5 = {
  class: "content-box relative"
};
const IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_6 = {
  key: 1,
  class: "loading-tip content-item text-grey-900"
};
const IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_7 = {
  key: 2,
  class: "provider-error-message content-item text-grey-900"
};
const IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_8 = {
  key: 3,
  class: "show-up-tip content-item text-grey-500"
};
const IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_9 = {
  key: 0,
  class: "stick-box absolute border-l border-grey-350"
};
function IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  const _component_LoadingText = resolveComponent("LoadingText");

  return openBlock(), createElementBlock("div", null, [createBaseVNode("div", {
    class: "iciba-size-helper fixed top-auto left-auto bottom-0 right-0 w-0 h-0 overflow-hidden",
    ref: _ctx.refs.sizeHelper
  }, null, 512), runtime_core_esm_bundler_createVNode(Transition, {
    name: "m"
  }, {
    default: withCtx(() => [withDirectives(createBaseVNode("div", {
      class: "iciba-main-wrap absolute overflow-visible ease-in-out duration-150 transition-opacity",
      ref: _ctx.refs.icibaMainWrap
    }, [createBaseVNode("div", {
      class: "iciba-main absolute flex-col items-stretch h-auto text-14 ease-in-out duration-150 transition-transform",
      onMouseenter: _cache[9] || (_cache[9] = $event => _ctx.state.stickBoxVisible = true),
      onMouseleave: _cache[10] || (_cache[10] = $event => _ctx.state.stickBoxVisible = false),
      style: normalizeStyle(_ctx.mainStyle),
      ref: _ctx.refs.icibaMain
    }, [createBaseVNode("div", IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_1, [createBaseVNode("div", {
      class: normalizeClass(["iciba-input-box flex relative flex-auto border-b border-grey-350", {
        'focused': _ctx.state.inputFocused
      }])
    }, [withDirectives(createBaseVNode("input", {
      class: "search-input flex-auto text-grey-900",
      ref: _ctx.refs.icibaSearchInput,
      size: "1",
      type: "text",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.state.inputText = $event),
      onFocus: _cache[1] || (_cache[1] = $event => _ctx.state.inputFocused = true),
      onBlur: _cache[2] || (_cache[2] = $event => _ctx.state.inputFocused = false),
      onKeydownCapture: _cache[3] || (_cache[3] = withModifiers(() => {}, ["stop"])),
      onKeypress: _cache[4] || (_cache[4] = withKeys( //@ts-ignore
      (...args) => _ctx.m.handleInputEnter && _ctx.m.handleInputEnter(...args), ["enter"]))
    }, null, 544), [[vModelText, _ctx.state.inputText]]), _ctx.store.core.history ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "input-button flex flex-center cursor-pointer",
      onClick: _cache[5] || (_cache[5] = //@ts-ignore
      (...args) => _ctx.m.handleOpenHistory && _ctx.m.handleOpenHistory(...args))
    }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
      size: 21,
      svg: _ctx.icon.historyIcon,
      color: "#aaa"
    }, null, 8, ["svg"])])) : createCommentVNode("", true), createBaseVNode("div", {
      class: "input-button flex flex-center cursor-pointer",
      onClick: _cache[6] || (_cache[6] = //@ts-ignore
      (...args) => _ctx.m.handleOpenSetting && _ctx.m.handleOpenSetting(...args))
    }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
      svg: _ctx.icon.settingsIcon
    }, null, 8, ["svg"])])], 2), createBaseVNode("div", IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_2, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.showButtonProviders, provider => {
      return openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, {
        key: provider.id
      }, [IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_3, createBaseVNode("button", {
        onKeydown: withKeys($event => _ctx.m.handleTranslateWithProvider(provider.id), ["enter"]),
        onClick: $event => _ctx.m.handleTranslateWithProvider(provider.id),
        class: "provider-button flex flex-center relative flex-none"
      }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
        svg: _ctx.m.getIcon(provider)
      }, null, 8, ["svg"])], 40, IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_4)], 64);
    }), 128))])]), createBaseVNode("div", IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_5, [!_ctx.translateLoading && !_ctx.errorMessage && _ctx.activeProvider ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeProvider.translateView), {
      class: "provider-container",
      key: _ctx.activeProvider.id
    })) : createCommentVNode("", true), _ctx.translateLoading ? (openBlock(), createElementBlock("div", IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_6, [runtime_core_esm_bundler_createVNode(_component_LoadingText)])) : createCommentVNode("", true), !_ctx.translateLoading && _ctx.errorMessage ? (openBlock(), createElementBlock("div", IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_7, toDisplayString(_ctx.errorMessage), 1)) : createCommentVNode("", true), !_ctx.activeProvider && !_ctx.translateLoading && !_ctx.errorMessage ? (openBlock(), createElementBlock("div", IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_8, " 等待输入查词 ")) : createCommentVNode("", true)]), runtime_core_esm_bundler_createVNode(Transition, {
      name: "s"
    }, {
      default: withCtx(() => [_ctx.store.core.showPin ? withDirectives((openBlock(), createElementBlock("div", IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_hoisted_9, [createBaseVNode("div", {
        class: "drag flex flex-center border-b border-grey-350",
        onMousedown: _cache[7] || (_cache[7] = //@ts-ignore
        (...args) => _ctx.m.pinDrag.handlePinDragStart && _ctx.m.pinDrag.handlePinDragStart(...args))
      }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
        svg: _ctx.icon.dragIcon
      }, null, 8, ["svg"])], 32), createBaseVNode("div", {
        class: normalizeClass(["stick flex flex-center relative", {
          pinned: _ctx.store.core.pinned
        }]),
        onClick: _cache[8] || (_cache[8] = //@ts-ignore
        (...args) => _ctx.m.pinDrag.handleTogglePinned && _ctx.m.pinDrag.handleTogglePinned(...args))
      }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
        svg: _ctx.icon.pinIcon
      }, null, 8, ["svg"])], 2)], 512)), [[vShow, _ctx.store.core.pinned || _ctx.state.stickBoxVisible]]) : createCommentVNode("", true)]),
      _: 1
    })], 36)], 512), [[vShow, _ctx.visible]])]),
    _: 1
  })]);
}
;// CONCATENATED MODULE: ./src/view/IcibaMain/IcibaMain.vue?vue&type=template&id=becc6b2c&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}
;// CONCATENATED MODULE: ./src/assets/img/settings_149837.svg
/* harmony default export */ const settings_149837 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 54 54\" width=\"512\" height=\"512\"><path d=\"M51.22 21h-5.052c-.812 0-1.481-.447-1.792-1.197s-.153-1.54.42-2.114l3.572-3.571c.525-.525.814-1.224.814-1.966 0-.743-.289-1.441-.814-1.967l-4.553-4.553c-1.05-1.05-2.881-1.052-3.933 0l-3.571 3.571c-.475.475-.997.574-1.352.574-.5 0-.997-.196-1.364-.539-.271-.254-.595-.704-.595-1.406V2.78C33 1.247 31.753 0 30.22 0h-6.44C22.247 0 21 1.247 21 2.78v5.052c0 1.218-.997 1.945-1.961 1.945-.354 0-.876-.1-1.351-.574l-3.571-3.571c-1.052-1.052-2.883-1.05-3.933 0l-4.553 4.553c-.525.525-.814 1.224-.814 1.967 0 .742.289 1.44.814 1.966l3.572 3.571c.573.574.73 1.364.42 2.114S8.644 21 7.832 21H2.78C1.247 21 0 22.247 0 23.78v6.438C0 31.752 1.247 33 2.78 33h5.052c.812 0 1.481.447 1.792 1.197s.153 1.54-.42 2.114l-3.572 3.571c-.525.525-.814 1.224-.814 1.966 0 .743.289 1.441.814 1.967l4.553 4.553c1.051 1.051 2.881 1.053 3.933 0l3.571-3.571c.475-.475.997-.574 1.352-.574.963 0 1.96.728 1.96 1.945v5.051C21 52.752 22.247 54 23.78 54h6.439c1.533 0 2.78-1.248 2.78-2.781v-5.051c0-1.218.997-1.945 1.96-1.945.354 0 .877.1 1.352.574l3.571 3.571c1.052 1.052 2.883 1.05 3.933 0l4.553-4.553c.525-.525.814-1.224.814-1.967 0-.742-.289-1.44-.814-1.966l-3.572-3.571c-.573-.574-.73-1.364-.42-2.114S45.356 33 46.168 33h5.052c1.533 0 2.78-1.248 2.78-2.781V23.78c0-1.533-1.247-2.78-2.78-2.78zM34 27c0 3.859-3.141 7-7 7s-7-3.141-7-7 3.141-7 7-7 7 3.141 7 7z\" fill=\"#AAA\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/drag_462998.svg
/* harmony default export */ const drag_462998 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path fill=\"#aaa\" d=\"M491.318 235.318H20.682C9.26 235.318 0 244.577 0 256s9.26 20.682 20.682 20.682h470.636c11.423 0 20.682-9.259 20.682-20.682 0-11.422-9.259-20.682-20.682-20.682zM491.318 78.439H20.682C9.26 78.439 0 87.699 0 99.121c0 11.422 9.26 20.682 20.682 20.682h470.636c11.423 0 20.682-9.26 20.682-20.682 0-11.422-9.259-20.682-20.682-20.682zM491.318 392.197H20.682C9.26 392.197 0 401.456 0 412.879s9.26 20.682 20.682 20.682h470.636c11.423 0 20.682-9.259 20.682-20.682s-9.259-20.682-20.682-20.682z\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/pin_25474.svg
/* harmony default export */ const pin_25474 = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 475.085 475.085\" width=\"475.085\" height=\"475.085\"><path fill=\"#aaa\" d=\"M379.577 247.395c-14.944-18.75-31.833-28.12-50.679-28.12V73.092c9.896 0 18.47-3.616 25.693-10.848 7.238-7.233 10.858-15.802 10.858-25.697 0-9.9-3.62-18.464-10.858-25.697C347.368 3.617 338.795 0 328.898 0H146.179c-9.9 0-18.464 3.617-25.697 10.85-7.234 7.233-10.85 15.796-10.85 25.697 0 9.899 3.616 18.464 10.85 25.697 7.233 7.232 15.8 10.848 25.697 10.848v146.179c-18.844 0-35.734 9.374-50.677 28.123-14.941 18.75-22.414 39.824-22.414 63.242 0 4.948 1.809 9.232 5.426 12.847 3.619 3.613 7.901 5.421 12.85 5.421h115.344l21.698 138.474c.95 5.141 3.996 7.707 9.135 7.707h.291c2.274 0 4.235-.808 5.851-2.423 1.615-1.619 2.614-3.572 2.994-5.855l14.558-137.902h122.482c4.948 0 9.236-1.808 12.847-5.421 3.621-3.614 5.432-7.898 5.432-12.847.003-23.415-7.477-44.492-22.419-63.242zM210.132 210.14c0 2.662-.855 4.849-2.57 6.565-1.713 1.714-3.903 2.57-6.567 2.57-2.662 0-4.853-.855-6.567-2.57-1.713-1.713-2.568-3.903-2.568-6.565V82.233c0-2.664.855-4.858 2.568-6.567 1.714-1.711 3.905-2.568 6.567-2.568 2.664 0 4.854.854 6.567 2.568 1.714 1.712 2.57 3.903 2.57 6.567V210.14z\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/history.svg
/* harmony default export */ const img_history = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n  <path fill=\"#000000\" d=\"M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z\"></path>\n</svg>\n");
;// CONCATENATED MODULE: ./src/util/useIncrement.ts
const useIncrement = (id = 0) => {
  let v = id;
  return () => {
    v += 1;
    return v;
  };
};
// EXTERNAL MODULE: ./node_modules/core-js-pure/stable/instance/reduce.js
var instance_reduce = __webpack_require__(1458);
var reduce_default = /*#__PURE__*/__webpack_require__.n(instance_reduce);
;// CONCATENATED MODULE: ./src/util/extendIoTs/excess.ts



/* eslint-disable consistent-return */

/* eslint-disable default-case */

/* eslint-disable @typescript-eslint/no-parameter-properties */

/* eslint-disable max-classes-per-file */



const getIsCodec = tag => codec => codec._tag === tag;

const isInterfaceCodec = getIsCodec('InterfaceType');
const isPartialCodec = getIsCodec('PartialType');

const excess_getProps = codec => {
  var _context;

  switch (codec._tag) {
    case 'RefinementType':
    case 'ReadonlyType':
      return excess_getProps(codec.type);

    case 'InterfaceType':
    case 'StrictType':
    case 'PartialType':
      return codec.props;

    case 'IntersectionType':
      return reduce_default()(_context = codec.types).call(_context, (props, type) => Object.assign(props, excess_getProps(type)), {});
  }
};

const excess_getNameFromProps = props => Object.keys(props).map(k => `${k}: ${props[k].name}`).join(', ');

const excess_getPartialTypeName = inner => `Partial<${inner}>`;

const getExcessTypeName = codec => {
  if (isInterfaceCodec(codec)) {
    return `{| ${excess_getNameFromProps(codec.props)} |}`;
  }

  if (isPartialCodec(codec)) {
    return excess_getPartialTypeName(`{| ${excess_getNameFromProps(codec.props)} |}`);
  }

  return `Excess<${codec.name}>`;
};

const excess_stripKeys = (o, props) => {
  const keys = Object.getOwnPropertyNames(o);
  const propsKeys = Object.getOwnPropertyNames(props);
  propsKeys.forEach(pk => {
    const index = keys.indexOf(pk);

    if (index !== -1) {
      keys.splice(index, 1);
    }
  });
  return keys.length ? Either_left(keys) : Either_right(o);
};

const excess = (codec, name = getExcessTypeName(codec)) => {
  const props = excess_getProps(codec);
  return new ExcessType(name, u => Either_isRight(excess_stripKeys(u, props)) && codec.is(u), (u, c) => either.chain(UnknownRecord.validate(u, c), () => either.chain(codec.validate(u, c), a => either.mapLeft(excess_stripKeys(a, props), keys => keys.map(k => ({
    value: a[k],
    context: c,
    message: `excess key "${k}" found`
  }))))), // eslint-disable-next-line @typescript-eslint/no-unsafe-return
  a => codec.encode(excess_stripKeys(a, props).right), codec);
};
class ExcessType extends Type {
  constructor(name, is, validate, encode, type) {
    super(name, is, validate, encode);

    defineProperty_defineProperty(this, "type", void 0);

    defineProperty_defineProperty(this, "_tag", 'ExcessType');

    this.type = type;
  }

}
;// CONCATENATED MODULE: ./src/service/history/type.ts



const historyItem = excess(type({
  word: string,
  time: number,
  provider: providerType
}));
;// CONCATENATED MODULE: ./src/service/history/index.ts


function history_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function history_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? history_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : history_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







const MAX_SIZE = 100;
const history_state = reactivity_esm_bundler_reactive({
  list: []
});

const saveHistory = async () => {
  history_state.list.length = Math.min(history_state.list.length, MAX_SIZE);
  await setValue(GM_STORE_KEY.HISTORY, (__webpack_require__(8334)/* .stringify */ .P)(history_state.list));
};

const loadHistory = async () => {
  const raw = await gmapi_getValue(GM_STORE_KEY.HISTORY, '');
  const parsedList = pipe(tryCatch(() => JSON.parse(raw), function_identity), v => Either_isRight(v) && Array.isArray(v.right) ? v.right : []).map(item => historyItem.decode(item)).map(v => Either_isRight(v) ? v.right : null).filter(v => !!v).filter((_, i) => i < MAX_SIZE);
  history_state.list = parsedList;
  await saveHistory();
};

const clearHistory = async () => {
  history_state.list = [];
  await saveHistory();
};

const addItem = async item => {
  await loadHistory();
  const now = Date.now();
  const dupItem = history_state.list.find(v => v.word === item.word && now - v.time < 1000 * 60 * 10);

  if (dupItem) {
    history_state.list.splice(history_state.list.indexOf(dupItem), 1);
  }

  const mostRecentItem = history_state.list[0];

  if (mostRecentItem && mostRecentItem.word === item.word) {
    history_state.list.shift();
  }

  history_state.list.unshift(history_objectSpread(history_objectSpread({}, item), {}, {
    time: now
  }));
  await saveHistory();
};

const historyService = {
  state: history_state,
  loadHistory,
  clearHistory,
  addItem
};
;// CONCATENATED MODULE: ./src/service/translate/index.ts








const translate_state = reactivity_esm_bundler_reactive({
  loading: false,
  activeTask: null,
  activeProviderId: null,
  lastUsedProvider: 'ICIBA',
  errorMessage: ''
});
const getTaskId = useIncrement(0);
/** 查词 */

const service_translate_translate = async action => {
  var _ref, _ref2, _param$param, _context, _state$activeTask;

  const param = action.param;
  const provider = (_ref = (_ref2 = param && providers.find(p => p.id === param.provider)) !== null && _ref2 !== void 0 ? _ref2 : providers.find(v => v.id === service_store_store.core.defaultProvider)) !== null && _ref !== void 0 ? _ref : providers[0];
  const payload = (_param$param = param === null || param === void 0 ? void 0 : param.param) !== null && _param$param !== void 0 ? _param$param : null;

  const word = trim_default()(_context = action.word).call(_context);

  if (!word) {
    translate_state.errorMessage = '查询不能为空！';
    return;
  }

  translate_state.activeProviderId = null;
  const newTask = {
    word,
    provider: provider.id,
    id: getTaskId()
  }; // ignore if task was exactly same as active task

  if (translate_state.activeTask && translate_state.activeTask.word === newTask.word && translate_state.activeTask.provider === newTask.provider) {
    return;
  }

  translate_state.activeTask = newTask;
  translate_state.loading = true;
  translate_state.errorMessage = '';
  const result = await provider.translate({
    word,
    payload
  });

  if (((_state$activeTask = translate_state.activeTask) === null || _state$activeTask === void 0 ? void 0 : _state$activeTask.id) !== newTask.id) {
    return;
  }

  if (Either_isLeft(result)) {
    var _result$left$message;

    translate_state.errorMessage = `${provider.id} 错误: ${(_result$left$message = result.left.message) !== null && _result$left$message !== void 0 ? _result$left$message : ''}`;
    translate_state.loading = false;

    if (result.left.redirect) {
      await service_translate_translate({
        type: EVENTS.TRANSLATE,
        word,
        param: {
          provider: result.left.redirect,
          param: result.left.redirectParams
        }
      });
      return;
    }
  }

  if (Either_isRight(result)) {
    translate_state.activeProviderId = provider.id;
    result.right();
    historyService.addItem({
      word: newTask.word,
      provider: newTask.provider
    });
    translate_state.loading = false;
    translate_state.activeTask = null;
  }
};

const clearActiveProvider = () => {
  translate_state.activeProviderId = null;
  translate_state.errorMessage = '';
};

const removeSelection = () => {
  const selection = window.getSelection();

  if (selection !== null && selection !== void 0 && selection.toString()) {
    selection.removeAllRanges();
    return;
  }

  const active = document.activeElement;

  if (active instanceof HTMLInputElement || active instanceof HTMLTextAreaElement) {
    active.setSelectionRange(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  }
};

const translateService = {
  state: translate_state,
  providers: providers,
  activeProvider: runtime_core_esm_bundler_computed(() => {
    var _providers$find;

    return (_providers$find = providers.find(v => v.id === translate_state.activeProviderId)) !== null && _providers$find !== void 0 ? _providers$find : null;
  }),
  translate: service_translate_translate,
  clearActiveProvider,
  removeSelection
};
;// CONCATENATED MODULE: ./src/service/zIndex/index.ts
var Z_INDEX_KEY;

(function (Z_INDEX_KEY) {
  Z_INDEX_KEY["GENERAL"] = "GENERAL";
  Z_INDEX_KEY["GOOGLE_DICT_MODAL"] = "GOOGLE_DICT_MODAL";
})(Z_INDEX_KEY || (Z_INDEX_KEY = {}));

const useZIndexService = () => {
  // https://stackoverflow.com/questions/491052/minimum-and-maximum-value-of-z-index
  let zIndex = 2147483647 - 100000;
  const zIndexUseMap = new Map();

  const gen = key => {
    zIndex += 1;
    const newZIndex = zIndex;
    zIndexUseMap.set(key, newZIndex);
    return newZIndex;
  };

  const get = key => {
    var _zIndexUseMap$get;

    return (_zIndexUseMap$get = zIndexUseMap.get(key)) !== null && _zIndexUseMap$get !== void 0 ? _zIndexUseMap$get : 0;
  };

  const isTop = z => z === zIndex;

  return {
    gen,
    get,
    isTop
  };
};

const zIndexService = useZIndexService();
;// CONCATENATED MODULE: ./src/service/view/index.ts

const view_state = reactivity_esm_bundler_reactive({
  icibaMain: false,
  setting: false,
  history: false,
  googleDictModal: false
});
const Statekeys = Object.keys(view_state);

const openIcibaMain = () => {
  view_state.icibaMain = true;
};

const closeIcibaMain = () => {
  view_state.icibaMain = false;
};

const openSettings = () => {
  view_state.setting = true;
};

const closeSettings = () => {
  view_state.setting = false;
};

const openHistory = () => {
  view_state.history = true;
};

const closeHistory = () => {
  view_state.history = false;
};

const openGoogleDictModal = () => {
  view_state.googleDictModal = true;
};

const closeGoogleDictModal = () => {
  view_state.googleDictModal = false;
};

const closeExcept = key => {
  Statekeys.forEach(k => {
    if (key === k) {
      return;
    }

    view_state[k] = false;
  });
};

Statekeys.forEach(key => {
  watch(() => view_state[key], () => {
    if (key === 'icibaMain') {
      return;
    }

    if (view_state[key]) {
      closeExcept(key);
    }
  });
});
const viewService = {
  state: view_state,
  openIcibaMain,
  closeIcibaMain,
  openSettings,
  closeSettings,
  openHistory,
  closeHistory,
  openGoogleDictModal,
  closeGoogleDictModal
};
;// CONCATENATED MODULE: ./src/util/insideOf.ts
/* harmony default export */ const insideOf = ((thetarget, parent) => {
  let target = thetarget;

  if (!target || !parent) {
    return false;
  }

  while (target && target !== parent) {
    target = target.parentNode;
  }

  if (target === parent) {
    return true;
  }

  return false;
});
;// CONCATENATED MODULE: ./src/util/calcMouseEventPosition.ts
/* harmony default export */ const calcMouseEventPosition = (e => {
  const bodyStyle = window.getComputedStyle(document.body);
  let marginLeft = 0;
  let marginTop = 0;

  if (bodyStyle.position !== 'static') {
    if (bodyStyle.marginLeft && bodyStyle.marginLeft !== '0px') {
      marginLeft = Number(bodyStyle.marginLeft.replace('px', ''));
    }

    if (bodyStyle.marginTop && bodyStyle.marginTop !== '0px') {
      marginTop = Number(bodyStyle.marginTop.replace('px', ''));
    }
  }

  return {
    top: e.pageY - marginTop,
    left: e.pageX - marginLeft
  };
});
;// CONCATENATED MODULE: ./src/view/IcibaMain/LoadingText/LoadingText.tsx


/* harmony default export */ const LoadingText = (runtime_core_esm_bundler_defineComponent({
  setup: () => {
    let intervalId = 0;
    const state = reactivity_esm_bundler_reactive({
      dots: 3
    });
    runtime_core_esm_bundler_onMounted(() => {
      intervalId = window.setInterval(() => {
        state.dots = state.dots > 10 ? 3 : state.dots + 1;
      }, 300);
    });
    runtime_core_esm_bundler_onUnmounted(() => {
      window.clearInterval(intervalId);
    });
    return () => runtime_core_esm_bundler_createVNode("div", null, [createTextVNode("\u52A0\u8F7D\u4E2D"), '.'.repeat(state.dots)]);
  }
}));
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/IcibaMain/IcibaMain.ts?vue&type=script&lang=ts


const _excluded = ["translateX", "translateY"];

function IcibaMainvue_type_script_lang_ts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function IcibaMainvue_type_script_lang_ts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? IcibaMainvue_type_script_lang_ts_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : IcibaMainvue_type_script_lang_ts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
















/* harmony default export */ const IcibaMainvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'IcibaMain',
  components: {
    LoadingText: LoadingText
  },
  props: {
    getIcibaCircle: {
      type: null,
      required: true
    }
  },
  setup: props => {
    const refs = {
      icibaMainWrap: reactivity_esm_bundler_ref(),
      icibaMain: reactivity_esm_bundler_ref(),
      icibaSearchInput: reactivity_esm_bundler_ref(),
      sizeHelper: reactivity_esm_bundler_ref()
    };
    const state = reactivity_esm_bundler_reactive({
      inputFocused: false,
      inputText: '',
      stickBoxVisible: false,
      drag: {
        dragging: false,
        ignoreCtrl: false,
        startPoint: {
          x: 0,
          y: 0
        },
        startTransform: {
          x: 0,
          y: 0
        }
      },
      mainStyle: {
        top: 'auto',
        bottom: 'auto',
        left: 'auto',
        right: 'auto'
      },
      wrapperStyle: {
        top: 'auto',
        bottom: 'auto',
        left: 'auto',
        right: 'auto',
        translateX: 0,
        translateY: 0,
        zIndex: 0
      }
    });

    const focusInput = (selectAll = false) => {
      runtime_core_esm_bundler_nextTick(() => {
        const input = refs.icibaSearchInput.value;

        if (input) {
          const textLength = state.inputText.length;
          input.focus();
          input.selectionStart = selectAll ? 0 : textLength;
          input.selectionEnd = textLength;
        }
      });
    };
    /** 设置 IcibaMain position */


    const setPosition = e => {
      if (!refs.sizeHelper.value) {
        return;
      }

      const sizeHelperBounding = refs.sizeHelper.value.getBoundingClientRect();
      const availableSpace = {
        x: sizeHelperBounding.left - e.clientX,
        y: sizeHelperBounding.top - e.clientY
      };
      state.mainStyle = IcibaMainvue_type_script_lang_ts_objectSpread({
        top: 'auto',
        bottom: 'auto',
        left: 'auto',
        right: 'auto'
      }, IcibaMainvue_type_script_lang_ts_objectSpread(IcibaMainvue_type_script_lang_ts_objectSpread({}, availableSpace.x < service_store_store.core.icibaMainWidth ? {
        right: '0'
      } : {
        left: '0'
      }), availableSpace.y < 250 ? {
        bottom: '0'
      } : {
        top: '0'
      }));
      const calcedPosition = calcMouseEventPosition(e);
      state.wrapperStyle = {
        top: `${calcedPosition.top}px`,
        left: `${calcedPosition.left}px`,
        bottom: 'auto',
        right: 'auto',
        translateX: 0,
        translateY: 0,
        zIndex: zIndexService.gen(Z_INDEX_KEY.GENERAL)
      };
    };

    const showIcibaMain = (e, autoFocus) => {
      if (!viewService.state.icibaMain) {
        setPosition(e);
        viewService.openIcibaMain();

        if (autoFocus) {
          focusInput();
        }

        return;
      } // reset if out of bound


      const container = refs.icibaMain.value;

      if (container) {
        const rect = container.getBoundingClientRect();

        if (rect.bottom < 0 || rect.top > window.innerHeight) {
          setPosition(e);
        }
      }
    };

    const listeners = {
      /** 查词事件 */
      onTranslate: action => {
        if (action.mouseEvent) {
          showIcibaMain(action.mouseEvent, service_store_store.core.icibaMainInputAutoFocus);
        }

        state.inputText = action.word;
        translateService.translate(action);
      },

      /** 热键显示 */
      onHotKeyShowUp: action => {
        setPosition(action.mouseEvent);
        state.inputText = action.word;
        translateService.clearActiveProvider();
        showIcibaMain(action.mouseEvent, service_store_store.core.hotkeyIcibaMainInputAutoFocus);
      },

      /** 热键查词 */
      onHotkeyTranslate: action => {
        if (!viewService.state.icibaMain) {
          if (!action.word) {
            return;
          }

          showIcibaMain(action.mouseEvent, service_store_store.core.providerHotkeyAutoFocus);
        }

        state.inputText = action.word || state.inputText;
        translateService.translate({
          type: EVENTS.TRANSLATE,
          word: state.inputText,
          mouseEvent: action.mouseEvent,
          param: {
            provider: action.provider
          }
        });

        if (service_store_store.core.providerHotkeyAutoFocus) {
          focusInput();
        }
      },
      onGoogleDictModalOpen: () => {
        viewService.closeIcibaMain();
      },
      onWindowClick: e => {
        // outside shadow-root
        if (e.target !== icibaRoot && (!service_store_store.core.showPin || !service_store_store.core.pinned)) {
          viewService.closeIcibaMain();
        }
      },
      onShadowRootClick: e => {
        if (!refs.icibaMainWrap.value) {
          return;
        }

        const ignoreCondition = [insideOf(e.target, refs.icibaMainWrap.value), insideOf(e.target, props.getIcibaCircle().$el), service_store_store.core.showPin && service_store_store.core.pinned];

        if (ignoreCondition.some(v => v)) {
          return;
        }

        viewService.closeIcibaMain();
      }
    };
    const methods = {
      handleOpenSetting: () => {
        viewService.openSettings();
      },
      handleOpenHistory: () => {
        viewService.openHistory();
      },
      handleTranslateWithProvider: provider => {
        translateService.translate({
          type: EVENTS.TRANSLATE,
          word: state.inputText,
          param: {
            provider
          }
        });
      },
      handleInputEnter: () => {
        translateService.translate({
          type: EVENTS.TRANSLATE,
          word: state.inputText,
          param: {
            provider: translateService.state.lastUsedProvider
          }
        });
      }
    };
    /** 图钉 拖拽 */

    const pinDrag = {
      /** 切换固定状态 */
      handleTogglePinned: () => {
        service_store_store.core.pinned = !service_store_store.core.pinned;
      },

      /** 图钉拖拽 */
      handlePinDragStart: e => {
        e.preventDefault();
        translateService.removeSelection();
        state.drag = {
          dragging: true,
          ignoreCtrl: true,
          startPoint: {
            x: e.screenX,
            y: e.screenY
          },
          startTransform: {
            x: state.wrapperStyle.translateX,
            y: state.wrapperStyle.translateY
          }
        };
      },

      /** 窗体拖拽 */
      handleDragStart: _e => {
        if (!refs.icibaMainWrap.value) {
          return;
        }

        const e = _e;
        state.drag.ignoreCtrl = false;

        if (!insideOf(e.target, refs.icibaMainWrap.value) || !e.ctrlKey) {
          return;
        }

        if (!service_store_store.core.pressCtrlToDrag) {
          return;
        }

        translateService.removeSelection();
        e.preventDefault();
        state.drag = {
          dragging: true,
          ignoreCtrl: false,
          startPoint: {
            x: e.screenX,
            y: e.screenY
          },
          startTransform: {
            x: state.wrapperStyle.translateX,
            y: state.wrapperStyle.translateY
          }
        };
      },
      handleDragMove: _e => {
        const e = _e;

        if (!state.drag.dragging || !state.drag.ignoreCtrl && !e.ctrlKey) {
          return;
        }

        const deltaX = e.screenX - state.drag.startPoint.x;
        const deltaY = e.screenY - state.drag.startPoint.y;
        state.wrapperStyle.translateX = state.drag.startTransform.x + deltaX;
        state.wrapperStyle.translateY = state.drag.startTransform.y + deltaY;
      },
      handleDragEnd: () => {
        state.drag.dragging = false;
      }
    };
    const wrapperStyle = runtime_core_esm_bundler_computed(() => {
      const _state$wrapperStyle = state.wrapperStyle,
            {
        translateX,
        translateY
      } = _state$wrapperStyle,
            rest = _objectWithoutProperties(_state$wrapperStyle, _excluded);

      return IcibaMainvue_type_script_lang_ts_objectSpread(IcibaMainvue_type_script_lang_ts_objectSpread({}, rest), {}, {
        transform: `translate(${state.wrapperStyle.translateX}px, ${state.wrapperStyle.translateY}px)`
      });
    });
    const mainStyle = runtime_core_esm_bundler_computed(() => IcibaMainvue_type_script_lang_ts_objectSpread(IcibaMainvue_type_script_lang_ts_objectSpread({}, state.mainStyle), {}, {
      width: `${service_store_store.core.icibaMainWidth}px`
    }));
    const showButtonProviders = runtime_core_esm_bundler_computed(() => service_store_store.core.providerOrder.map(id => providers.find(p => p.id === id)).filter(p => p.store.display));
    const visible = runtime_core_esm_bundler_computed(() => viewService.state.icibaMain);
    watch(() => wrapperStyle.value, style => {
      if (refs.icibaMainWrap.value) {
        Object.assign(refs.icibaMainWrap.value.style, style);
      }
    }, {
      deep: true,
      immediate: true
    });
    runtime_core_esm_bundler_onMounted(() => {
      window.addEventListener('mousedown', listeners.onWindowClick, true);
      window.addEventListener('mousemove', pinDrag.handleDragMove, true);
      window.addEventListener('mouseup', pinDrag.handleDragEnd, true);
      shadowRoot.addEventListener('mousedown', pinDrag.handleDragStart, true);
      shadowRoot.addEventListener('mousedown', listeners.onShadowRootClick, false);
      shadowRoot.addEventListener('keyup', pinDrag.handleDragEnd, true);
      bus.on({
        event: EVENTS.TRANSLATE,
        listener: listeners.onTranslate
      });
      bus.on({
        event: EVENTS.OPEN_GOOGLE_DICT_MODAL,
        listener: listeners.onGoogleDictModalOpen
      });
      bus.on({
        event: EVENTS.HOTKEY_SHOW,
        listener: listeners.onHotKeyShowUp
      });
      bus.on({
        event: EVENTS.HOTKEY_TRANSLATE,
        listener: listeners.onHotkeyTranslate
      });
    }); // no need to unmounted since it never unmount

    if (false) {}

    return {
      icon: {
        settingsIcon: settings_149837,
        dragIcon: drag_462998,
        pinIcon: pin_25474,
        historyIcon: img_history
      },
      state,
      visible,
      refs,
      store: service_store_store,
      mainStyle,
      translateLoading: runtime_core_esm_bundler_computed(() => translateService.state.loading),
      activeProvider: translateService.activeProvider,
      showButtonProviders,
      errorMessage: runtime_core_esm_bundler_computed(() => translateService.state.errorMessage),
      m: IcibaMainvue_type_script_lang_ts_objectSpread({
        getIcon: getIcon,
        pinDrag
      }, methods)
    };
  }
}));
;// CONCATENATED MODULE: ./src/view/IcibaMain/IcibaMain.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/IcibaMain/IcibaMain.sass?vue&type=style&index=0&id=becc6b2c&lang=sass&scoped=true
var IcibaMainvue_type_style_index_0_id_becc6b2c_lang_sass_scoped_true = __webpack_require__(4558);
;// CONCATENATED MODULE: ./src/view/IcibaMain/IcibaMain.sass?vue&type=style&index=0&id=becc6b2c&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/view/IcibaMain/IcibaMain.vue




;


const IcibaMain_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(IcibaMainvue_type_script_lang_ts, [['render',IcibaMainvue_type_template_id_becc6b2c_scoped_true_ts_true_render],['__scopeId',"data-v-becc6b2c"]])

/* harmony default export */ const IcibaMain = (IcibaMain_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/view/IcibaCircle/IcibaCircle.vue?vue&type=template&id=b769a32c&scoped=true&ts=true

function IcibaCirclevue_type_template_id_b769a32c_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  return openBlock(), createBlock(Transition, {
    name: "c"
  }, {
    default: withCtx(() => [withDirectives(createBaseVNode("div", {
      class: normalizeClass(["iciba-circle absolute select-none overflow-hidden flex flex-center", {
        'has-icon': !!_ctx.iconUrl,
        [_ctx.iconType]: true
      }]),
      ref: _ctx.refs.circle,
      style: normalizeStyle(_ctx.computedStyle),
      onContextmenu: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"])),
      onMouseover: _cache[1] || (_cache[1] = //@ts-ignore
      (...args) => _ctx.m.handleSelfMouseover && _ctx.m.handleSelfMouseover(...args)),
      onMouseup: _cache[2] || (_cache[2] = //@ts-ignore
      (...args) => _ctx.m.handleSelfMouseUp && _ctx.m.handleSelfMouseUp(...args))
    }, [_ctx.iconUrl ? (openBlock(), createBlock(_component_i_icon, {
      key: 0,
      class: "flex-1",
      size: false,
      svg: _ctx.iconUrl
    }, null, 8, ["svg"])) : createCommentVNode("", true)], 38), [[vShow, _ctx.state.visible]])]),
    _: 1
  });
}
;// CONCATENATED MODULE: ./src/util/getSelectionText.ts

const getSelectionText = () => {
  const selection = window.getSelection();

  if (selection && String(selection)) {
    var _context;

    return trim_default()(_context = selection.toString()).call(_context);
  }

  const active = document.activeElement;

  if (active instanceof HTMLInputElement || active instanceof HTMLTextAreaElement) {
    const start = active.selectionStart;
    const end = active.selectionEnd;

    if (typeof start === 'number' && typeof end === 'number') {
      const s = active.value.substring(start, end);
      return trim_default()(s).call(s);
    }
  }

  return '';
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/IcibaCircle/IcibaCircle.ts?vue&type=script&lang=ts


function IcibaCirclevue_type_script_lang_ts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function IcibaCirclevue_type_script_lang_ts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? IcibaCirclevue_type_script_lang_ts_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : IcibaCirclevue_type_script_lang_ts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }













/* harmony default export */ const IcibaCirclevue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  setup: () => {
    const refs = {
      circle: reactivity_esm_bundler_ref()
    };
    const state = reactivity_esm_bundler_reactive({
      visible: false,
      word: '',
      currentWord: '',
      zIndex: 0,
      style: {
        top: '0',
        left: '0',
        bottom: 'auto',
        right: 'auto'
      }
    });

    const showIcibaCircle = (e, word) => {
      state.visible = true;
      state.word = word;
      state.zIndex = zIndexService.gen(Z_INDEX_KEY.GENERAL);
      const calcedPosition = calcMouseEventPosition(e);
      state.style = {
        top: `${calcedPosition.top + service_store_store.core.icibaCircleOffsetY}px`,
        left: `${calcedPosition.left + service_store_store.core.icibaCircleOffsetX}px`
      };
    };

    const handleSelfMouseUp = event => {
      // have to wait handleContextmenu trigger
      setTimeout(() => {
        state.visible = false;
        let provider = IcibaProvider.id;

        if (event.button === 2 && service_store_store.core.icibaCircleRightClick) {
          // 备选 provider
          provider = service_store_store.core.icibaCircleRightClickProvider;
        } else {
          // 默认 provider
          provider = service_store_store.core.defaultProvider;
        }

        bus.emit({
          type: EVENTS.TRANSLATE,
          mouseEvent: event,
          word: state.word,
          param: {
            provider
          }
        });
        translateService.removeSelection();
      });
    };

    const handleSelfMouseover = event => {
      if (!service_store_store.core.mouseOverTranslate) {
        return;
      }

      state.visible = false;
      bus.emit({
        type: EVENTS.TRANSLATE,
        mouseEvent: event,
        word: state.word,
        param: {
          provider: service_store_store.core.defaultProvider
        }
      });
    };

    const handleMouseUp = async (e, proxied = false) => {
      // let handleShadowRootClick handle
      if (!proxied && e.target === icibaRoot) {
        return;
      }

      if (proxied && e.target === refs.circle.value) {
        return;
      }

      const hide = () => {
        state.visible = false;
      }; // Wait for next frame. If user clicks on selection text, it will be
      // cleared on next frame


      await new (promise_default())(rs => requestAnimationFrame(rs));
      const selectionString = getSelectionText();
      state.currentWord = selectionString;

      if (!selectionString) {
        hide();
        return;
      }

      if (service_store_store.core.pressCtrlToShowCircle && !e.ctrlKey) {
        hide();
        return;
      }

      if (service_store_store.core.selectionMaxLengthCut && selectionString.length > service_store_store.core.selectionMaxLength) {
        hide();
        return;
      } // dummy proof


      const hasShowUpHotkey = service_store_store.core.useHotkeyShowUp && !!service_store_store.core.showUpHotkey.length;
      const hasProviderUsingHotkey = providers.some(p => p.store.enableHotkey && p.store.hotkey.length);
      const hasHotkey = hasShowUpHotkey || hasProviderUsingHotkey;

      if (!service_store_store.core.useIcibaCircle && hasHotkey) {
        return;
      }

      if (service_store_store.core.icibaCircleNoCJK) {
        // 669 is last of Latin Extended Additional
        // https://en.wikipedia.org/wiki/List_of_Unicode_characters#Latin_Extended_Additional
        const hasCJK = Array.from(selectionString).some(v => v.charCodeAt(0) > 669);

        if (hasCJK) {
          hide();
          return;
        }
      }

      showIcibaCircle(e, selectionString);
    };

    const handleShadowRootMouseUp = e => {
      handleMouseUp(e, true);
    };

    const computedStyle = runtime_core_esm_bundler_computed(() => IcibaCirclevue_type_script_lang_ts_objectSpread(IcibaCirclevue_type_script_lang_ts_objectSpread({}, state.style), {}, {
      zIndex: state.zIndex,
      width: `${service_store_store.core.icibaCircleSize}px`,
      height: `${service_store_store.core.icibaCircleSize}px`
    }));
    const iconUrl = runtime_core_esm_bundler_computed(() => ICIBA_CIRCLE_ICON_MAP[service_store_store.core.icibaCircleIcon]);
    const iconType = runtime_core_esm_bundler_computed(() => ICIBA_CIRCLE_ICON_TYPE_MAP[service_store_store.core.icibaCircleIcon]);
    runtime_core_esm_bundler_onMounted(() => {
      window.addEventListener('mouseup', handleMouseUp, true);
      shadowRoot.addEventListener('mouseup', handleShadowRootMouseUp, true);
    });

    if (false) {}

    return {
      state,
      refs,
      iconUrl,
      iconType,
      computedStyle,
      m: {
        handleSelfMouseover,
        handleSelfMouseUp
      }
    };
  }
}));
;// CONCATENATED MODULE: ./src/view/IcibaCircle/IcibaCircle.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/IcibaCircle/IcibaCircle.sass?vue&type=style&index=0&id=b769a32c&lang=sass&scoped=true
var IcibaCirclevue_type_style_index_0_id_b769a32c_lang_sass_scoped_true = __webpack_require__(4632);
;// CONCATENATED MODULE: ./src/view/IcibaCircle/IcibaCircle.sass?vue&type=style&index=0&id=b769a32c&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/view/IcibaCircle/IcibaCircle.vue




;


const IcibaCircle_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(IcibaCirclevue_type_script_lang_ts, [['render',IcibaCirclevue_type_template_id_b769a32c_scoped_true_ts_true_render],['__scopeId',"data-v-b769a32c"]])

/* harmony default export */ const IcibaCircle = (IcibaCircle_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/view/SettingPage/SettingPage.vue?vue&type=template&id=52c940b4&scoped=true&ts=true


const SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-52c940b4"), n = n(), popScopeId(), n);

const SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_1 = {
  class: "setting-window relative flex bg-white shadow-8 ease-in-out duration-300 overflow-hidden"
};
const SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_2 = {
  class: "bg-indigo-500 flex-none items-center"
};

const SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_3 = /*#__PURE__*/createTextVNode("设置");

const SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_4 = /*#__PURE__*/createTextVNode("core");

const SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_5 = /*#__PURE__*/createTextVNode("热键");

const SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_6 = /*#__PURE__*/createTextVNode("Urban");

const SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_7 = /*#__PURE__*/SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("br", null, null, -1));

const SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_8 = /*#__PURE__*/createTextVNode("Dictionary");

function SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_tab = resolveComponent("i-tab");

  const _component_i_tabs = resolveComponent("i-tabs");

  const _component_about = resolveComponent("about");

  const _component_i_tab_item = resolveComponent("i-tab-item");

  const _component_core_setting = resolveComponent("core-setting");

  const _component_hot_key = resolveComponent("hot-key");

  const _component_i_tabs_items = resolveComponent("i-tabs-items");

  const _component_modal_component = resolveComponent("modal-component");

  const _directive_no_overscroll = resolveDirective("no-overscroll");

  return openBlock(), createBlock(_component_modal_component, {
    open: _ctx.visible,
    onClose: _ctx.handleCloseSetting
  }, {
    default: withCtx(() => [createBaseVNode("div", SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_1, [createBaseVNode("div", SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_2, [runtime_core_esm_bundler_createVNode(_component_i_tabs, {
      modelValue: _ctx.state.tab,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.state.tab = $event),
      dark: "",
      "slider-color": "rgba(255,255,255,0.8)"
    }, {
      default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_i_tab, null, {
        default: withCtx(() => [SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_3]),
        _: 1
      }), runtime_core_esm_bundler_createVNode(_component_i_tab, null, {
        default: withCtx(() => [SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_4]),
        _: 1
      }), runtime_core_esm_bundler_createVNode(_component_i_tab, null, {
        default: withCtx(() => [SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_5]),
        _: 1
      }), (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.providersLabel, (c, i) => {
        return openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, {
          key: i
        }, [c === 'Urban Dictionary' ? (openBlock(), createBlock(_component_i_tab, {
          key: 0
        }, {
          default: withCtx(() => [SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_6, SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_7, SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_hoisted_8]),
          _: 1
        })) : (openBlock(), createBlock(_component_i_tab, {
          key: 1
        }, {
          default: withCtx(() => [createTextVNode(toDisplayString(c), 1)]),
          _: 2
        }, 1024))], 64);
      }), 128))]),
      _: 1
    }, 8, ["modelValue"])]), withDirectives((openBlock(), createBlock(_component_i_tabs_items, {
      class: "tabs-box flex-auto overflow-auto",
      modelValue: _ctx.state.tab,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => _ctx.state.tab = $event)
    }, {
      default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_i_tab_item, {
        class: "p-4"
      }, {
        default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_about)]),
        _: 1
      }), runtime_core_esm_bundler_createVNode(_component_i_tab_item, {
        class: "p-4"
      }, {
        default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_core_setting)]),
        _: 1
      }), runtime_core_esm_bundler_createVNode(_component_i_tab_item, {
        class: "p-4"
      }, {
        default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_hot_key)]),
        _: 1
      }), (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.providersPage, (c, i) => {
        return openBlock(), createBlock(_component_i_tab_item, {
          key: i,
          class: "p-4"
        }, {
          default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(c)))]),
          _: 2
        }, 1024);
      }), 128))]),
      _: 1
    }, 8, ["modelValue"])), [[_directive_no_overscroll]])])]),
    _: 1
  }, 8, ["open", "onClose"]);
}
;// CONCATENATED MODULE: ./src/view/SettingPage/SettingPage.vue?vue&type=template&id=52c940b4&scoped=true&ts=true

// EXTERNAL MODULE: ./node_modules/core-js-pure/stable/instance/flat-map.js
var flat_map = __webpack_require__(5302);
var flat_map_default = /*#__PURE__*/__webpack_require__.n(flat_map);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/tabs/tabs.tsx?vue&type=script&lang=ts



function tabsvue_type_script_lang_ts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function tabsvue_type_script_lang_ts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? tabsvue_type_script_lang_ts_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : tabsvue_type_script_lang_ts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




/* harmony default export */ const tabsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'Tabs',
  props: {
    modelValue: {
      type: Number,
      required: true
    },
    sliderColor: {
      type: String,
      default: ''
    }
  },
  setup: (props, ctx) => {
    const tabs = reactivity_esm_bundler_reactive([]);
    const state = reactivity_esm_bundler_reactive({
      slider: {
        top: 0,
        height: 0
      },
      hasArrowButton: false
    });
    const tabModel = runtime_core_esm_bundler_computed({
      get: () => props.modelValue,
      set: value => ctx.emit('update:modelValue', value)
    });

    const updateSlider = () => {
      var _context;

      const height = tabs[tabModel.value].clientHeight;

      const top = reduce_default()(_context = tabs.filter((_v, i) => i < tabModel.value).map(v => v.clientHeight)).call(_context, (p, c) => p + c, 0);

      state.slider = {
        top,
        height
      };
    };

    const sliderStyle = runtime_core_esm_bundler_computed(() => tabsvue_type_script_lang_ts_objectSpread({
      top: `${state.slider.top}px`,
      height: `${state.slider.height}px`
    }, props.sliderColor ? {
      color: props.sliderColor
    } : {}));
    runtime_core_esm_bundler_onMounted(() => {
      watch(() => props.modelValue, () => {
        updateSlider();
      }, {
        immediate: true
      });
    });
    return () => {
      var _context2, _ctx$slots$default, _ctx$slots$default2, _ctx$slots;

      const VNodes = flat_map_default()(_context2 = (_ctx$slots$default = (_ctx$slots$default2 = (_ctx$slots = ctx.slots).default) === null || _ctx$slots$default2 === void 0 ? void 0 : _ctx$slots$default2.call(_ctx$slots)) !== null && _ctx$slots$default !== void 0 ? _ctx$slots$default : []).call(_context2, v => {
        if (v.type === runtime_core_esm_bundler_Fragment) {
          return v.children;
        }

        return v;
      });

      return runtime_core_esm_bundler_createVNode("div", {
        "class": "i-tabs flex-col flex-wrap relative items-stretch"
      }, [runtime_core_esm_bundler_createVNode("div", {
        "class": "slider absolute ease-in-out duration-300",
        "style": sliderStyle.value
      }, null), VNodes.map((tab, index) => withDirectives(runtime_core_esm_bundler_createVNode("div", {
        "ref": el => {
          if (el) {
            tabs[index] = el;
          }
        },
        "class": {
          'tab flex flex-center text-14': true,
          'active': tabModel.value === index
        },
        "onClick": () => {
          tabModel.value = index;
        },
        "key": index
      }, [tab]), [[resolveDirective("ripple"), {
        class: tabModel.value === index ? 'active-ripple' : 'inactive-ripple'
      }]]))]);
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/tabs/tabs.tsx?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/tabs/tabs.sass?vue&type=style&index=0&lang=sass
var tabsvue_type_style_index_0_lang_sass = __webpack_require__(8375);
;// CONCATENATED MODULE: ./src/components/tabs/tabs.sass?vue&type=style&index=0&lang=sass

;// CONCATENATED MODULE: ./src/components/tabs/tabs.vue



;

const tabs_exports_ = tabsvue_type_script_lang_ts;

/* harmony default export */ const tabs = (tabs_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-2.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/tab/tab.vue?vue&type=template&id=162513bc

const tabvue_type_template_id_162513bc_hoisted_1 = {
  class: "i-tab__div text-center"
};
function tabvue_type_template_id_162513bc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", tabvue_type_template_id_162513bc_hoisted_1, [renderSlot(_ctx.$slots, "default")]);
}
;// CONCATENATED MODULE: ./src/components/tab/tab.vue?vue&type=template&id=162513bc

;// CONCATENATED MODULE: ./src/components/tab/tab.vue

const script = {}

;
const tab_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(script, [['render',tabvue_type_template_id_162513bc_render]])

/* harmony default export */ const tab = (tab_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/tabsItems/tabsItems.tsx?vue&type=script&lang=ts



/* harmony default export */ const tabsItemsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  props: {
    modelValue: {
      type: Number,
      required: true
    },
    windowClass: {
      type: String,
      default: ''
    }
  },
  setup: (props, ctx) => {
    const refs = {
      windows: reactivity_esm_bundler_reactive([]),
      windowContainer: reactivity_esm_bundler_ref(),
      container: reactivity_esm_bundler_ref()
    };
    const state = reactivity_esm_bundler_reactive({
      beforeValue: 0,
      height: 0,
      animating: false,
      animatingTimeout: 0,
      windowState: [],
      scrollTopInterupt: null
    });

    const scrollToTop = () => {
      const container = refs.container.value;

      if (!container) {
        return;
      }

      const start = container.scrollTop;

      if (!start) {
        return;
      }

      if (state.scrollTopInterupt) {
        state.scrollTopInterupt();
      }

      const startTime = performance.now();

      const ease = pos => (Math.cos(Math.PI * pos) - 1) * -0.5;

      let stop = false;

      const scroll = () => {
        const time = performance.now() - startTime;

        if (time > 300 || stop) {
          return;
        }

        if (container.scrollTop === 0) {
          return;
        }

        container.scrollTop = start - ease(time / 300) * start;
        window.requestAnimationFrame(scroll);
      };

      state.scrollTopInterupt = () => {
        stop = true;
        state.scrollTopInterupt = null;
      };

      window.requestAnimationFrame(scroll);
    };

    const transform = async () => {
      const windowContainer = refs.windowContainer.value;
      const windows = refs.windows;

      if (!windowContainer || !windows) {
        return;
      }

      if (state.animating) {
        window.clearTimeout(state.animatingTimeout);
      }

      state.animating = true; // before animate state

      const outIndex = state.beforeValue;
      const inIndex = props.modelValue;
      const containerHeight = windowContainer.getBoundingClientRect().height; // reset style

      state.windowState.forEach(v => {
        v.display = 'none';
        v.position = undefined;
        v.transform = '';
      });
      state.height = Math.max(windows[outIndex].getBoundingClientRect().height, containerHeight); // set pre position

      state.windowState[outIndex] = {
        position: 'absolute',
        display: '',
        transform: '',
        animating: false
      };
      state.windowState[inIndex] = {
        position: 'absolute',
        display: '',
        transform: inIndex < outIndex ? 'translate(-100%, 0)' : 'translate(100%, 0)',
        animating: false
      }; // await render

      await runtime_core_esm_bundler_nextTick();
      scrollToTop();
      state.height = Math.max(windows[outIndex].getBoundingClientRect().height, containerHeight);
      state.windowState[outIndex] = {
        position: 'absolute',
        display: '',
        transform: outIndex < inIndex ? 'translate(-100%, 0)' : 'translate(100%, 0)',
        animating: true
      };
      state.windowState[inIndex] = {
        position: 'absolute',
        display: '',
        transform: '',
        animating: true
      };
      state.animatingTimeout = window.setTimeout(() => {
        state.animating = false;
        state.windowState[outIndex] = {
          position: undefined,
          display: 'none',
          transform: '',
          animating: false
        };
        state.windowState[inIndex] = {
          position: undefined,
          display: '',
          transform: '',
          animating: false
        };
        state.height = 0;
      }, 300);
    };

    const initStyle = length => {
      if (length === state.windowState.length) {
        return;
      }

      state.windowState = Array(length).fill(0).map((_v, i) => ({
        position: undefined,
        transform: '',
        display: props.modelValue === i ? '' : 'none',
        animating: false
      }));
    };

    runtime_core_esm_bundler_onMounted(() => {
      watch(() => props.modelValue, (_value, old) => {
        state.beforeValue = old !== null && old !== void 0 ? old : 0;

        if (old !== undefined) {
          transform();
        }
      }, {
        immediate: true
      });
    });
    return () => {
      var _context, _ctx$slots$default, _ctx$slots$default2, _ctx$slots;

      const VNodes = flat_map_default()(_context = (_ctx$slots$default = (_ctx$slots$default2 = (_ctx$slots = ctx.slots).default) === null || _ctx$slots$default2 === void 0 ? void 0 : _ctx$slots$default2.call(_ctx$slots)) !== null && _ctx$slots$default !== void 0 ? _ctx$slots$default : []).call(_context, v => {
        if (v.type === runtime_core_esm_bundler_Fragment) {
          return v.children;
        }

        return v;
      });

      initStyle(VNodes.length);
      return runtime_core_esm_bundler_createVNode("div", {
        "class": "i-tabs-items",
        "ref": refs.container
      }, [runtime_core_esm_bundler_createVNode("div", {
        "class": "window-container flex relative ease-in-out duration-300",
        "ref": refs.windowContainer,
        "style": {
          height: state.height ? `${state.height}px` : 'auto'
        }
      }, [...VNodes.map((vnode, i) => {
        var _props$windowClass;

        if (vnode.props) {
          const pd = vnode.props;
          pd.index = i;
          pd.current = props.modelValue;
        }

        return runtime_core_esm_bundler_createVNode("div", {
          "ref": el => {
            if (el) refs.windows[i] = el;
          },
          "style": {
            position: state.windowState[i].position,
            display: state.windowState[i].display,
            transform: state.windowState[i].transform
          },
          "key": i,
          "class": {
            [(_props$windowClass = props.windowClass) !== null && _props$windowClass !== void 0 ? _props$windowClass : '']: true,
            'vnode-window': true,
            'animating': state.windowState[i].animating
          }
        }, [vnode]);
      })])]);
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/tabsItems/tabsItems.tsx?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/tabsItems/tabsItems.sass?vue&type=style&index=0&lang=sass
var tabsItemsvue_type_style_index_0_lang_sass = __webpack_require__(1783);
;// CONCATENATED MODULE: ./src/components/tabsItems/tabsItems.sass?vue&type=style&index=0&lang=sass

;// CONCATENATED MODULE: ./src/components/tabsItems/tabsItems.vue



;

const tabsItems_exports_ = tabsItemsvue_type_script_lang_ts;

/* harmony default export */ const tabsItems = (tabsItems_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/tabItem/tabItem.tsx?vue&type=script&lang=ts


/* harmony default export */ const tabItemvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  props: {
    index: Number,
    current: Number
  },
  setup: (props, ctx) => () => {
    var _ctx$slots$default, _ctx$slots$default2, _ctx$slots;

    const VNodes = (_ctx$slots$default = (_ctx$slots$default2 = (_ctx$slots = ctx.slots).default) === null || _ctx$slots$default2 === void 0 ? void 0 : _ctx$slots$default2.call(_ctx$slots)) !== null && _ctx$slots$default !== void 0 ? _ctx$slots$default : [];
    return runtime_core_esm_bundler_createVNode("div", null, [VNodes.map(v => {
      if (v.props) {
        const pd = v.props;
        pd.active = props.index === props.current;
      }

      return v;
    })]);
  }
}));
;// CONCATENATED MODULE: ./src/components/tabItem/tabItem.tsx?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/components/tabItem/tabItem.vue



const tabItem_exports_ = tabItemvue_type_script_lang_ts;

/* harmony default export */ const tabItem = (tabItem_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/components/modal/modal.vue?vue&type=template&id=76591e7d&scoped=true&ts=true


const modalvue_type_template_id_76591e7d_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-76591e7d"), n = n(), _popScopeId(), n);

const modalvue_type_template_id_76591e7d_scoped_true_ts_true_hoisted_1 = {
  class: "modal-container flex-col ease-in-out duration-300"
};
function modalvue_type_template_id_76591e7d_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "m"
  }, {
    default: withCtx(() => [_ctx.state.visible ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "modal-component flex flex-center fixed inset-0 ease-in-out duration-300",
      style: normalizeStyle(_ctx.modalStyle),
      onClick: _cache[0] || (_cache[0] = withModifiers( //@ts-ignore
      (...args) => _ctx.handleCloseModal && _ctx.handleCloseModal(...args), ["self"]))
    }, [createBaseVNode("div", modalvue_type_template_id_76591e7d_scoped_true_ts_true_hoisted_1, [renderSlot(_ctx.$slots, "default", {}, undefined, true)])], 4)) : createCommentVNode("", true)]),
    _: 3
  });
}
;// CONCATENATED MODULE: ./src/components/modal/modal.vue?vue&type=template&id=76591e7d&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/modal/modal.ts?vue&type=script&lang=ts


/* harmony default export */ const modalvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'ModalComponent',
  props: {
    open: {
      type: Boolean,
      required: true
    },
    onClose: {
      type: null,
      required: true
    }
  },
  setup: props => {
    const state = reactivity_esm_bundler_reactive({
      visible: false,
      zIndex: 0,
      bodyOverflowXValue: '',
      bodyOverflowYValue: ''
    });

    const handleCloseModal = e => {
      if (e.target !== e.currentTarget) {
        return;
      }

      props.onClose();
      document.body.style.overflowX = state.bodyOverflowXValue;
      document.body.style.overflowY = state.bodyOverflowYValue;
    };

    watch(() => props.open, () => {
      if (props.open) {
        state.bodyOverflowXValue = document.body.style.overflowX || '';
        state.bodyOverflowYValue = document.body.style.overflowY || '';
        state.zIndex = zIndexService.gen(Z_INDEX_KEY.GENERAL);
      }

      state.visible = props.open;
    });
    const modalStyle = runtime_core_esm_bundler_computed(() => ({
      zIndex: state.zIndex
    }));
    return {
      state,
      modalStyle,
      handleCloseModal
    };
  }
}));
;// CONCATENATED MODULE: ./src/components/modal/modal.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/components/modal/modal.sass?vue&type=style&index=0&id=76591e7d&lang=sass&scoped=true
var modalvue_type_style_index_0_id_76591e7d_lang_sass_scoped_true = __webpack_require__(5660);
;// CONCATENATED MODULE: ./src/components/modal/modal.sass?vue&type=style&index=0&id=76591e7d&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/components/modal/modal.vue




;


const modal_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(modalvue_type_script_lang_ts, [['render',modalvue_type_template_id_76591e7d_scoped_true_ts_true_render],['__scopeId',"data-v-76591e7d"]])

/* harmony default export */ const modal = (modal_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/view/SettingPage/subpage/about/about.vue?vue&type=template&id=015a74ca&ts=true

const aboutvue_type_template_id_015a74ca_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};

const aboutvue_type_template_id_015a74ca_ts_true_hoisted_2 = /*#__PURE__*/createStaticVNode("<h1 class=\"text-20 mt-1\">iciba划词翻译</h1><div class=\"text-14 mt-6\"><div> 修改设置会自动保存。其他已打开的标签页需要刷新后才会加载新设置。 </div><div class=\"mt-4\"> Greasyfork: <br><a target=\"_blank\" rel=\"noopener\" href=\"https://greasyfork.org/zh-CN/scripts/6303-iciba%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91\"> https://greasyfork.org/zh-CN/scripts/6303-iciba划词翻译 </a></div><div class=\"mt-4\"> Github: <br><a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/Firefox-Pro-Coding/iciba-translate-userscript\"> https://github.com/Firefox-Pro-Coding/iciba-translate-userscript </a></div><div class=\"mt-4\"> Changelog: <br><a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/Firefox-Pro-Coding/iciba-translate-userscript/releases\"> Github Release </a></div><div class=\"mt-4\"> 支持: <br> 如果您喜欢该项目，可以在 <a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/Firefox-Pro-Coding/iciba-translate-userscript\">github repo</a> 点 star，或者把它推荐给其他人 </div><div class=\"mt-4\"> 遇到了任何问题或者错误，有其他建议？打开 <a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/Firefox-Pro-Coding/iciba-translate-userscript\">github repo</a> 提交 <a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/Firefox-Pro-Coding/iciba-translate-userscript/issues\">issue</a></div></div>", 2);

const aboutvue_type_template_id_015a74ca_ts_true_hoisted_4 = [aboutvue_type_template_id_015a74ca_ts_true_hoisted_2];
function aboutvue_type_template_id_015a74ca_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", aboutvue_type_template_id_015a74ca_ts_true_hoisted_1, aboutvue_type_template_id_015a74ca_ts_true_hoisted_4);
}
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/about/about.vue?vue&type=template&id=015a74ca&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/SettingPage/subpage/about/about.ts?vue&type=script&lang=ts

/* harmony default export */ const aboutvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'AboutPage'
}));
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/about/about.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/about/about.vue




;
const about_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(aboutvue_type_script_lang_ts, [['render',aboutvue_type_template_id_015a74ca_ts_true_render]])

/* harmony default export */ const about = (about_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/view/SettingPage/subpage/coreSetting/coreSetting.vue?vue&type=template&id=d6c1cc28&scoped=true&ts=true


const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-d6c1cc28"), n = n(), popScopeId(), n);

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_2 = /*#__PURE__*/createTextVNode(" 选中文字后显示小圆圈 （关闭后");

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_3 = /*#__PURE__*/coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("span", {
  class: "font-bold"
}, "仅能使用热键", -1));

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_4 = /*#__PURE__*/createTextVNode("查词） ");

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_5 = /*#__PURE__*/coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "flex-1 default-iciba-circle"
}, null, -1));

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_6 = /*#__PURE__*/coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-1 mb-0"
}, " 自定义小圆圈图标 ", -1));

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_7 = /*#__PURE__*/createTextVNode(" 选择文字时，只有 ");

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_8 = /*#__PURE__*/coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("span", {
  class: "font-bold"
}, "同时按住ctrl键", -1));

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_9 = /*#__PURE__*/createTextVNode(" 时才显示小圆圈 ");

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_10 = {
  class: "flex mt-6"
};
const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_11 = {
  class: "flex-col grow-0 pr-12"
};

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_12 = /*#__PURE__*/coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "text-grey-600 pr-6 mb-2"
}, "接口", -1));

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_13 = {
  class: "flex-col items-center grow-0"
};

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_14 = /*#__PURE__*/coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "text-grey-600 pr-6 mb-1"
}, "默认接口", -1));

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_15 = {
  class: "flex-col items-center grow-0"
};

const coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_16 = /*#__PURE__*/coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "text-grey-600 pr-6 mb-1"
}, "备选接口", -1));

const _hoisted_17 = {
  key: 0,
  class: "text-14 text-red-500 mt-2 mb-0"
};

const _hoisted_18 = /*#__PURE__*/coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-1 mb-0"
}, [/*#__PURE__*/createTextVNode(" 默认接口：左键点击小圆圈查词接口 "), /*#__PURE__*/createBaseVNode("br"), /*#__PURE__*/createTextVNode(" 备选接口：启用时，右键键点击小圆圈使用此查词接口 ")], -1));

const _hoisted_19 = {
  class: "text-14 text-grey-400"
};
const _hoisted_20 = {
  class: "flex self-stretch items-center mr-1 mt-6"
};
const _hoisted_21 = {
  class: "mr-4 text-grey-600"
};

const _hoisted_22 = /*#__PURE__*/coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-1 mb-0"
}, " 小圆圈大小（默认22px） ", -1));

const _hoisted_23 = {
  class: "flex mt-6"
};
const _hoisted_24 = {
  class: "flex-col justify-around flex-none"
};
const _hoisted_25 = {
  class: "mr-4 text-grey-600"
};
const _hoisted_26 = {
  class: "mr-4 text-grey-600"
};
const _hoisted_27 = {
  class: "flex-col justify-around flex-auto"
};

const _hoisted_28 = /*#__PURE__*/coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-1 mb-0"
}, [/*#__PURE__*/createTextVNode(" 小圆圈位置偏移（单位：px） "), /*#__PURE__*/createBaseVNode("br"), /*#__PURE__*/createTextVNode(" 选择文字时，小圆圈偏移鼠标指针右下方的位置。默认 x=7 y=7 ")], -1));

const _hoisted_29 = {
  class: "flex items-center mr-1 mt-6 self-stretch"
};
const _hoisted_30 = {
  class: "mr-4 text-grey-600"
};

const _hoisted_31 = /*#__PURE__*/coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-1 mb-0"
}, " 查词框宽度（单位：px）（默认300px） ", -1));

function coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_provider_sort = resolveComponent("provider-sort");

  const _component_i_checkbox_line = resolveComponent("i-checkbox-line");

  const _component_icon_radio_group = resolveComponent("icon-radio-group");

  const _component_i_radio = resolveComponent("i-radio");

  const _component_i_radio_group = resolveComponent("i-radio-group");

  const _component_foldable = resolveComponent("foldable");

  const _component_i_slider = resolveComponent("i-slider");

  return openBlock(), createElementBlock("div", coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_provider_sort), runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
    modelValue: _ctx.form.useIcibaCircle,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.form.useIcibaCircle = $event),
    label: "显示小圆圈"
  }, {
    default: withCtx(() => [coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_2, coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_3, coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_4]),
    _: 1
  }, 8, ["modelValue"]), runtime_core_esm_bundler_createVNode(_component_foldable, {
    fold: !_ctx.form.useIcibaCircle
  }, {
    default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_icon_radio_group, {
      class: "mt-6",
      modelValue: _ctx.form.icibaCircleIcon,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => _ctx.form.icibaCircleIcon = $event),
      icons: _ctx.icibaCircleIconOptions
    }, {
      [_ctx.defaultIconKey]: withCtx(() => [coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_5]),
      _: 2
    }, 1032, ["modelValue", "icons"]), coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_6, runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
      modelValue: _ctx.form.pressCtrlToShowCircle,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => _ctx.form.pressCtrlToShowCircle = $event),
      label: "仅按住 ctrl 时显示小圆圈"
    }, {
      default: withCtx(() => [coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_7, coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_8, coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_9]),
      _: 1
    }, 8, ["modelValue"]), runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
      modelValue: _ctx.form.mouseOverTranslate,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => _ctx.form.mouseOverTranslate = $event),
      label: "hover 小圆圈自动点击",
      text: "鼠标移到小圆圈上自动点击并打开查词窗口"
    }, null, 8, ["modelValue"]), runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
      modelValue: _ctx.form.icibaMainInputAutoFocus,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => _ctx.form.icibaMainInputAutoFocus = $event),
      label: "自动聚焦输入框",
      text: "点击小圆圈查词后，自动聚焦到输入框"
    }, null, 8, ["modelValue"]), runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
      modelValue: _ctx.form.icibaCircleRightClick,
      "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => _ctx.form.icibaCircleRightClick = $event),
      label: "右击小圆圈使用备选接口",
      text: "右击小圆圈，使用备选接口查词"
    }, null, 8, ["modelValue"]), createBaseVNode("div", coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_10, [createBaseVNode("div", coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_11, [coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_12, (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.providerOptions, n => {
      return openBlock(), createElementBlock("div", {
        class: "option-item text-16 text-grey-600 mb-2",
        key: n.key
      }, toDisplayString(n.label), 1);
    }), 128))]), createBaseVNode("div", coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_13, [coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_14, runtime_core_esm_bundler_createVNode(_component_i_radio_group, {
      class: "mt-0 grow-0",
      modelValue: _ctx.form.defaultProvider,
      "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => _ctx.form.defaultProvider = $event)
    }, {
      default: withCtx(() => [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.providerOptions, n => {
        return openBlock(), createBlock(_component_i_radio, {
          key: n.key,
          label: "",
          value: n.key
        }, null, 8, ["value"]);
      }), 128))]),
      _: 1
    }, 8, ["modelValue"])]), createBaseVNode("div", coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_15, [coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_hoisted_16, runtime_core_esm_bundler_createVNode(_component_i_radio_group, {
      class: "mt-0",
      modelValue: _ctx.form.icibaCircleRightClickProvider,
      "onUpdate:modelValue": _cache[7] || (_cache[7] = $event => _ctx.form.icibaCircleRightClickProvider = $event)
    }, {
      default: withCtx(() => [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.providerOptions, n => {
        return openBlock(), createBlock(_component_i_radio, {
          key: n.key,
          label: "",
          value: n.key
        }, null, 8, ["value"]);
      }), 128))]),
      _: 1
    }, 8, ["modelValue"])])]), _ctx.form.defaultProvider === _ctx.form.icibaCircleRightClickProvider ? (openBlock(), createElementBlock("p", _hoisted_17, " 默认接口和备选接口请选择不同的选项 ")) : createCommentVNode("", true), _hoisted_18, runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
      modelValue: _ctx.form.icibaCircleNoCJK,
      "onUpdate:modelValue": _cache[8] || (_cache[8] = $event => _ctx.form.icibaCircleNoCJK = $event),
      label: "非英语（拉丁）字符不显示小圆圈",
      text: "划去文字包含中文、日文、韩文等字符时不显示小圆圈"
    }, null, 8, ["modelValue"])]),
    _: 1
  }, 8, ["fold"]), runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
    modelValue: _ctx.form.history,
    "onUpdate:modelValue": _cache[9] || (_cache[9] = $event => _ctx.form.history = $event),
    label: "显示历史记录按钮",
    text: "在设置按钮旁边显示历史查词记录按钮"
  }, null, 8, ["modelValue"]), runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
    modelValue: _ctx.form.pressCtrlToDrag,
    "onUpdate:modelValue": _cache[10] || (_cache[10] = $event => _ctx.form.pressCtrlToDrag = $event),
    label: "按住 Ctrl 拖拽查词框",
    text: "按住 Ctrl 键可拖拽移动查词框位置"
  }, null, 8, ["modelValue"]), runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
    modelValue: _ctx.form.showPin,
    "onUpdate:modelValue": _cache[11] || (_cache[11] = $event => _ctx.form.showPin = $event),
    label: "启用固定图钉",
    text: "显示固定图钉，可固定查词框使其不自动关闭"
  }, null, 8, ["modelValue"]), runtime_core_esm_bundler_createVNode(_component_foldable, {
    fold: !_ctx.form.useIcibaCircle
  }, {
    default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
      modelValue: _ctx.form.selectionMaxLengthCut,
      "onUpdate:modelValue": _cache[12] || (_cache[12] = $event => _ctx.form.selectionMaxLengthCut = $event),
      label: "限制最大查词长度",
      text: "当选择文字超过长度时不显示小圆圈"
    }, null, 8, ["modelValue"]), runtime_core_esm_bundler_createVNode(_component_foldable, {
      fold: !_ctx.form.selectionMaxLengthCut
    }, {
      default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_i_slider, {
        class: "mr-1 mt-2px self-stretch",
        step: 10,
        min: 50,
        max: 500,
        modelValue: _ctx.form.selectionMaxLength,
        "onUpdate:modelValue": _cache[13] || (_cache[13] = $event => _ctx.form.selectionMaxLength = $event)
      }, null, 8, ["modelValue"]), createBaseVNode("p", _hoisted_19, " 最大查词长度: " + toDisplayString(_ctx.form.selectionMaxLength) + " （默认值: 150） ", 1)]),
      _: 1
    }, 8, ["fold"]), createBaseVNode("div", _hoisted_20, [createBaseVNode("div", _hoisted_21, toDisplayString(_ctx.form.icibaCircleSize) + "px", 1), runtime_core_esm_bundler_createVNode(_component_i_slider, {
      class: "grow",
      min: 10,
      max: 30,
      step: 1,
      modelValue: _ctx.form.icibaCircleSize,
      "onUpdate:modelValue": _cache[14] || (_cache[14] = $event => _ctx.form.icibaCircleSize = $event),
      "thumb-label": ""
    }, null, 8, ["modelValue"])]), _hoisted_22, createBaseVNode("div", _hoisted_23, [createBaseVNode("div", _hoisted_24, [createBaseVNode("div", _hoisted_25, "x: " + toDisplayString(_ctx.form.icibaCircleOffsetX), 1), createBaseVNode("div", _hoisted_26, "y: " + toDisplayString(_ctx.form.icibaCircleOffsetY), 1)]), createBaseVNode("div", _hoisted_27, [runtime_core_esm_bundler_createVNode(_component_i_slider, {
      class: "grow",
      min: 0,
      max: 30,
      modelValue: _ctx.form.icibaCircleOffsetX,
      "onUpdate:modelValue": _cache[15] || (_cache[15] = $event => _ctx.form.icibaCircleOffsetX = $event),
      "thumb-label": ""
    }, null, 8, ["modelValue"]), runtime_core_esm_bundler_createVNode(_component_i_slider, {
      class: "grow",
      min: 0,
      max: 30,
      modelValue: _ctx.form.icibaCircleOffsetY,
      "onUpdate:modelValue": _cache[16] || (_cache[16] = $event => _ctx.form.icibaCircleOffsetY = $event),
      "thumb-label": ""
    }, null, 8, ["modelValue"])])]), _hoisted_28]),
    _: 1
  }, 8, ["fold"]), createBaseVNode("div", _hoisted_29, [createBaseVNode("div", _hoisted_30, toDisplayString(_ctx.form.icibaMainWidth) + "px", 1), runtime_core_esm_bundler_createVNode(_component_i_slider, {
    class: "grow",
    min: 200,
    max: 500,
    step: 10,
    modelValue: _ctx.form.icibaMainWidth,
    "onUpdate:modelValue": _cache[17] || (_cache[17] = $event => _ctx.form.icibaMainWidth = $event),
    "thumb-label": ""
  }, null, 8, ["modelValue"])]), _hoisted_31]);
}
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/coreSetting/coreSetting.vue?vue&type=template&id=d6c1cc28&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/view/SettingPage/subpage/coreSetting/providerSort/providerSort.vue?vue&type=template&id=be105b76&scoped=true&ts=true


const providerSortvue_type_template_id_be105b76_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-be105b76"), n = n(), popScopeId(), n);

const providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_1 = ["onMousedown", "onContextmenu"];
const providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_2 = {
  class: "mask-box absolute ease-in-out duration-200"
};
const providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_3 = {
  key: 0,
  class: "icon-box absolute rounded-3px flex flex-center"
};
const providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_4 = {
  class: "text-14 text-grey-400 mt-6px mb-0"
};

const providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_5 = /*#__PURE__*/createTextVNode(" 拖拽调整顺序，右键切换显示隐藏");

const providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_6 = /*#__PURE__*/providerSortvue_type_template_id_be105b76_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("br", null, null, -1));

const providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_7 = /*#__PURE__*/createTextVNode(" 点击 ");

function providerSortvue_type_template_id_be105b76_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  return openBlock(), createElementBlock("div", {
    class: "icon-box-wrapper relative",
    ref: _ctx.refs.container
  }, [runtime_core_esm_bundler_createVNode(TransitionGroup, {
    class: "icon-box-container flex ease-linear",
    name: "icon",
    tag: "div"
  }, {
    default: withCtx(() => [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.state.list, iconItem => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["icon-item relative select-none", {
          mask: iconItem.mask
        }]),
        style: normalizeStyle({
          zIndex: iconItem.z
        }),
        onDragstart: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"])),
        onMousedown: withModifiers($event => _ctx.handleDragStart(iconItem), ["left"]),
        onContextmenu: withModifiers($event => _ctx.handleToggleVisibility(iconItem.id), ["right", "prevent"]),
        key: iconItem.id
      }, [runtime_core_esm_bundler_createVNode(Transition, {
        name: "mask"
      }, {
        default: withCtx(() => [withDirectives(createBaseVNode("div", providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_2, null, 512), [[vShow, iconItem.mask]])]),
        _: 2
      }, 1024), !iconItem.mask || true ? (openBlock(), createElementBlock("div", providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_3, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
        class: normalizeClass(["icon", {
          inactive: !_ctx.isProviderVisible(iconItem.id)
        }]),
        size: "32",
        svg: iconItem.icon
      }, null, 8, ["class", "svg"])])) : 0], 46, providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_1);
    }), 128))]),
    _: 1
  }), createBaseVNode("p", providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_4, [providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_5, providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_6, providerSortvue_type_template_id_be105b76_scoped_true_ts_true_hoisted_7, createBaseVNode("span", {
    class: "cursor-pointer hover:text-grey-600 hover:underline",
    onClick: _cache[1] || (_cache[1] = //@ts-ignore
    (...args) => _ctx.handleReset && _ctx.handleReset(...args))
  }, " 恢复默认排序 ")])], 512);
}
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/coreSetting/providerSort/providerSort.vue?vue&type=template&id=be105b76&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/SettingPage/subpage/coreSetting/providerSort/providerSort.ts?vue&type=script&lang=ts




/* harmony default export */ const providerSortvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'ProviderSort',
  setup: () => {
    const refs = {
      container: reactivity_esm_bundler_ref()
    };

    const loadList = () => service_store_store.core.providerOrder.map(id => {
      const provider = providers.find(p => p.id === id);
      return {
        id,
        icon: getIcon(provider),
        mask: false,
        z: 0
      };
    });

    const state = reactivity_esm_bundler_reactive({
      list: loadList()
    });
    const drag = {
      item: null,
      rects: [],
      cIndex: 0
    };
    const threshold = 1;

    const calcCenter = () => {
      if (!refs.container.value) {
        return;
      }

      drag.rects = Array.from(refs.container.value.firstElementChild.children).map(v => {
        const b = v.getBoundingClientRect();
        return {
          left: b.left + (1 - threshold) * b.width * 0.5,
          right: b.right - (1 - threshold) * b.width * 0.5,
          width: b.width
        };
      });
    };

    const handleDragStart = icon => {
      icon.mask = true;
      drag.item = icon;
      state.list.forEach(v => {
        v.z = 1;
      });
      icon.z = 3;
      calcCenter();
      drag.cIndex = state.list.indexOf(icon);
    };

    const handleMouseMove = e => {
      if (!drag.item) {
        return;
      }

      const cX = e.clientX;
      const cIndex = drag.cIndex;
      const c = drag.rects;
      let newIndex = 0;

      for (; newIndex < c.length; newIndex += 1) {
        if (newIndex === cIndex) {
          // eslint-disable-next-line no-continue
          continue;
        }

        const item = c[newIndex];

        if (newIndex < cIndex) {
          if (item.right > cX) {
            break;
          }
        } else if (item.left > cX) {
          break;
        }
      }

      if (newIndex > cIndex) {
        newIndex -= 1;
      }

      if (newIndex !== cIndex) {
        const item = state.list.splice(cIndex, 1);
        state.list.splice(newIndex, 0, item[0]);
        drag.cIndex = newIndex;
      }
    };

    const handleDragEnd = () => {
      if (!drag.item) {
        return;
      }

      drag.item.mask = false;
      drag.item = null;
      service_store_store.core.providerOrder = state.list.map(v => v.id);
    };

    const handleToggleVisibility = key => {
      const provider = providers.find(p => p.id === key);
      provider.store.display = !provider.store.display;
    };

    const handleReset = () => {
      service_store_store.core.providerOrder = [...core_storeType.defaultData.providerOrder];
      state.list = loadList();
    };

    const isProviderVisible = key => {
      const provider = providers.find(p => p.id === key);
      return provider.store.display;
    };

    runtime_core_esm_bundler_onMounted(() => {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleDragEnd);
    });
    runtime_core_esm_bundler_onUnmounted(() => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleDragEnd);
    });
    return {
      state,
      refs,
      handleDragStart,
      handleToggleVisibility,
      handleReset,
      isProviderVisible
    };
  }
}));
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/coreSetting/providerSort/providerSort.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/SettingPage/subpage/coreSetting/providerSort/providerSort.sass?vue&type=style&index=0&id=be105b76&lang=sass&scoped=true
var providerSortvue_type_style_index_0_id_be105b76_lang_sass_scoped_true = __webpack_require__(3922);
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/coreSetting/providerSort/providerSort.sass?vue&type=style&index=0&id=be105b76&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/coreSetting/providerSort/providerSort.vue




;


const providerSort_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(providerSortvue_type_script_lang_ts, [['render',providerSortvue_type_template_id_be105b76_scoped_true_ts_true_render],['__scopeId',"data-v-be105b76"]])

/* harmony default export */ const providerSort = (providerSort_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/SettingPage/subpage/coreSetting/coreSetting.ts?vue&type=script&lang=ts








const icibaCircleIconOptions = Object.entries(ICIBA_CIRCLE_ICON_MAP).map(([k, v]) => ({
  icon: v,
  key: k
}));
const providerOptions = providers.map(p => ({
  label: p.label,
  key: p.id
}));
/* harmony default export */ const coreSettingvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'CoreSettings',
  components: {
    ProviderSort: providerSort,
    IconRadioGroup: IconRadioGroup,
    Foldable: Foldable_Foldable
  },
  props: {
    active: Boolean
  },
  setup: props => {
    const state = reactivity_esm_bundler_reactive({
      keys: [],
      setKeys: []
    });
    const form = service_store_store.core;
    let reset = null;
    watch(() => [form.defaultProvider, form.icibaCircleRightClickProvider], (n, o) => {
      reset = o && n[0] === n[1] ? o : null;
    });

    const doReset = () => {
      if (props.active && reset) {
        form.defaultProvider = reset[0];
        form.icibaCircleRightClickProvider = reset[1];
      }
    };

    const normalizeKey = key => key >= 'a' && key <= 'z' ? key.toUpperCase() : key;

    const handleKeyDown = e => {
      const key = normalizeKey(e.key);

      if (!e.repeat && !keys_default()(state).includes(key)) {
        keys_default()(state).push(key);
      }

      state.setKeys = [...keys_default()(state)];
    };

    const handleKeyUp = e => {
      const key = normalizeKey(e.key);

      const index = keys_default()(state).indexOf(key);

      if (index !== -1) {
        keys_default()(state).splice(index, 1);
      }
    };

    watch(() => props.active, doReset);
    runtime_core_esm_bundler_onUnmounted(doReset);
    const input = runtime_core_esm_bundler_computed(() => {
      const keys = state.setKeys;
      const hasCtrl = keys.includes('Control');
      const hasAlt = keys.includes('Alt');
      const hasShift = keys.includes('Shift');
      const inputs = [hasCtrl && 'Ctrl', hasAlt && 'Alt', hasShift && 'Shift', ...keys.filter(v => !['Control', 'Alt', 'Shift'].includes(v)).map(v => v.toUpperCase())].filter(Boolean);
      return inputs.join(' + ');
    });
    runtime_core_esm_bundler_onMounted(() => {
      window.addEventListener('keyup', handleKeyUp);
    });
    runtime_core_esm_bundler_onUnmounted(() => {
      window.removeEventListener('keyup', handleKeyUp);
    });
    return {
      state,
      input,
      form,
      defaultIconKey: ICIBA_CIRCLE_ICON.DEFAULT,
      icibaCircleIconOptions,
      providerOptions,
      handleKeyDown,
      handleKeyUp
    };
  }
}));
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/coreSetting/coreSetting.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/SettingPage/subpage/coreSetting/coreSetting.sass?vue&type=style&index=0&id=d6c1cc28&lang=sass&scoped=true
var coreSettingvue_type_style_index_0_id_d6c1cc28_lang_sass_scoped_true = __webpack_require__(7981);
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/coreSetting/coreSetting.sass?vue&type=style&index=0&id=d6c1cc28&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/coreSetting/coreSetting.vue




;


const coreSetting_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(coreSettingvue_type_script_lang_ts, [['render',coreSettingvue_type_template_id_d6c1cc28_scoped_true_ts_true_render],['__scopeId',"data-v-d6c1cc28"]])

/* harmony default export */ const coreSetting = (coreSetting_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/view/SettingPage/subpage/hotKey/hotKey.vue?vue&type=template&id=620a04da&ts=true

const hotKeyvue_type_template_id_620a04da_ts_true_hoisted_1 = {
  class: "flex-col items-start"
};

const hotKeyvue_type_template_id_620a04da_ts_true_hoisted_2 = /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mb-0"
}, " 热键显示查词框 ", -1);

const hotKeyvue_type_template_id_620a04da_ts_true_hoisted_3 = /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-8 mb-0"
}, " 快速查词热键（选中文本 或在输入框 快速查词） ", -1);

const hotKeyvue_type_template_id_620a04da_ts_true_hoisted_4 = {
  class: ""
};

const hotKeyvue_type_template_id_620a04da_ts_true_hoisted_5 = /*#__PURE__*/createTextVNode(" 使用 快速查词热键后，自动聚焦到输入框 ");

const hotKeyvue_type_template_id_620a04da_ts_true_hoisted_6 = /*#__PURE__*/createBaseVNode("p", {
  class: "text-14 text-grey-400 mt-6 mb-0"
}, " tips: ", -1);

function hotKeyvue_type_template_id_620a04da_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_checkbox_line = resolveComponent("i-checkbox-line");

  const _component_i_hotkey_input = resolveComponent("i-hotkey-input");

  const _component_foldable = resolveComponent("foldable");

  const _component_i_checkbox = resolveComponent("i-checkbox");

  return openBlock(), createElementBlock("div", hotKeyvue_type_template_id_620a04da_ts_true_hoisted_1, [runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
    class: "mt-1",
    nomt: "",
    modelValue: _ctx.core.useHotkeyShowUp,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.core.useHotkeyShowUp = $event),
    label: "呼出查词框热键",
    text: ""
  }, null, 8, ["modelValue"]), runtime_core_esm_bundler_createVNode(_component_foldable, {
    fold: !_ctx.core.useHotkeyShowUp
  }, {
    default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_i_hotkey_input, {
      class: "my-1",
      modelValue: _ctx.core.showUpHotkey,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => _ctx.core.showUpHotkey = $event)
    }, null, 8, ["modelValue"])]),
    _: 1
  }, 8, ["fold"]), hotKeyvue_type_template_id_620a04da_ts_true_hoisted_2, runtime_core_esm_bundler_createVNode(_component_foldable, {
    fold: !_ctx.core.useHotkeyShowUp
  }, {
    default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
      modelValue: _ctx.core.hotkeyIcibaMainInputAutoFocus,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => _ctx.core.hotkeyIcibaMainInputAutoFocus = $event),
      label: "呼出查词框时聚焦输入",
      text: "呼出查词框 后，聚焦到输入框"
    }, null, 8, ["modelValue"])]),
    _: 1
  }, 8, ["fold"]), hotKeyvue_type_template_id_620a04da_ts_true_hoisted_3, createBaseVNode("div", hotKeyvue_type_template_id_620a04da_ts_true_hoisted_4, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.providers, provider => {
    return openBlock(), createElementBlock("div", {
      class: "mt-2",
      key: provider.id
    }, [runtime_core_esm_bundler_createVNode(_component_i_checkbox, {
      modelValue: provider.store.enableHotkey,
      "onUpdate:modelValue": $event => provider.store.enableHotkey = $event,
      label: provider.label
    }, null, 8, ["modelValue", "onUpdate:modelValue", "label"]), runtime_core_esm_bundler_createVNode(_component_foldable, {
      fold: !provider.store.enableHotkey
    }, {
      default: withCtx(() => [runtime_core_esm_bundler_createVNode(_component_i_hotkey_input, {
        class: "my-1",
        modelValue: provider.store.hotkey,
        "onUpdate:modelValue": $event => provider.store.hotkey = $event
      }, null, 8, ["modelValue", "onUpdate:modelValue"])]),
      _: 2
    }, 1032, ["fold"])]);
  }), 128))]), runtime_core_esm_bundler_createVNode(_component_i_checkbox_line, {
    class: "mt-6",
    nomt: "",
    modelValue: _ctx.core.providerHotkeyAutoFocus,
    "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => _ctx.core.providerHotkeyAutoFocus = $event),
    label: "快速查词热键聚焦输入框"
  }, {
    default: withCtx(() => [hotKeyvue_type_template_id_620a04da_ts_true_hoisted_5]),
    _: 1
  }, 8, ["modelValue"]), hotKeyvue_type_template_id_620a04da_ts_true_hoisted_6, (openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(['选中文字 按下热键查词。', '或在输入框输入文字，按下热键使用对应的接口查词。', '至少指定一种能打开查词框的方式（小圆圈或热键），否则你会无法打开查词框。', '请避免使用和浏览器或操作系统产生冲突的热键。'], (line, index) => {
    return createBaseVNode("p", {
      class: "text-14 text-grey-400 mt-1 mb-0",
      key: index
    }, toDisplayString(index + 1) + ". " + toDisplayString(line), 1);
  }), 64))]);
}
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/hotKey/hotKey.vue?vue&type=template&id=620a04da&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/SettingPage/subpage/hotKey/hotKey.ts?vue&type=script&lang=ts




/* harmony default export */ const hotKeyvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'HotKeySetting',
  components: {
    Foldable: Foldable_Foldable
  },
  props: {
    active: Boolean
  },
  setup: () => ({
    core: service_store_store.core,
    providers: providers
  })
}));
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/hotKey/hotKey.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/view/SettingPage/subpage/hotKey/hotKey.vue




;
const hotKey_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(hotKeyvue_type_script_lang_ts, [['render',hotKeyvue_type_template_id_620a04da_ts_true_render]])

/* harmony default export */ const hotKey = (hotKey_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/SettingPage/SettingPage.ts?vue&type=script&lang=ts










 // import Iciba from './subpage/iciba/iciba.vue'
// import GoogleDict from './subpage/googleDict/googleDict.vue'
// import GoogleTranslate from './subpage/googleTranslate/googleTranslate.vue'
// import BaiduTranslate from './subpage/baiduTranslate/baiduTranslate.vue'
// import SougouTranslate from './subpage/sougouTranslate/sougouTranslate.vue'
// import UrbanDictionary from './subpage/urbanDictionary/urbanDictionary.vue'
// import BingTranslate from './subpage/bingTranslate/bingTranslate.vue'
// import Vocabulary from './subpage/vocabulary/vocabulary.vue'

/* harmony default export */ const SettingPagevue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'SettingPage',
  components: {
    ITabs: tabs,
    ITab: tab,
    ITabsItems: tabsItems,
    ITabItem: tabItem,
    ModalComponent: modal,
    About: about,
    CoreSetting: coreSetting,
    HotKey: hotKey // Iciba,
    // GoogleDict,
    // GoogleTranslate,
    // BaiduTranslate,
    // SougouTranslate,
    // UrbanDictionary,
    // BingTranslate,
    // Vocabulary,

  },
  setup: () => {
    const state = reactivity_esm_bundler_reactive({
      tab: 1
    });

    const handleCloseSetting = () => {
      viewService.closeSettings();
    };

    const visible = runtime_core_esm_bundler_computed(() => viewService.state.setting);
    return {
      state,
      visible,
      providersPage: providers.map(v => v.settingView),
      providersLabel: providers.map(v => v.label),
      handleCloseSetting
    };
  }
}));
;// CONCATENATED MODULE: ./src/view/SettingPage/SettingPage.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/SettingPage/SettingPage.sass?vue&type=style&index=0&id=52c940b4&lang=sass&scoped=true
var SettingPagevue_type_style_index_0_id_52c940b4_lang_sass_scoped_true = __webpack_require__(7908);
;// CONCATENATED MODULE: ./src/view/SettingPage/SettingPage.sass?vue&type=style&index=0&id=52c940b4&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/view/SettingPage/SettingPage.vue




;


const SettingPage_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(SettingPagevue_type_script_lang_ts, [['render',SettingPagevue_type_template_id_52c940b4_scoped_true_ts_true_render],['__scopeId',"data-v-52c940b4"]])

/* harmony default export */ const SettingPage = (SettingPage_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/view/HistoryModal/HistoryModal.vue?vue&type=template&id=2d428882&scoped=true&ts=true


const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-2d428882"), n = n(), popScopeId(), n);

const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_1 = {
  class: "history-window flex-col bg-white shadow-8"
};

const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_2 = /*#__PURE__*/HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "px-4 py-3 border-b border-grey-300 font-medium"
}, " 查词历史记录 ", -1));

const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_3 = {
  class: "flex-col flex-1"
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_4 = {
  key: 0,
  class: "px-4 py-4 text-grey-400 text-14"
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_5 = {
  key: 1,
  class: "pt-2"
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_6 = {
  class: "flex items-center flex-1 w-0"
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_7 = {
  class: "text-grey-500 w-6 flex-none"
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_8 = ["onClick"];
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_9 = {
  class: "flex items-center text-gray-800 text-16 mt-2px truncate"
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_10 = {
  class: "bg-grey-200 group-hover:bg-grey-300 px-2 rounded-4 truncate leading-relaxed"
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_11 = {
  class: "flex items-center flex-none text-grey-400 text-14 ml-1"
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_12 = {
  class: "ml-2"
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_13 = {
  class: "ml-2"
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_14 = ["title"];

const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_15 = /*#__PURE__*/HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "flex-1 w-full"
}, null, -1));

const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_16 = {
  class: "text-grey-400 text-14 p-4"
};

const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_17 = /*#__PURE__*/createTextVNode(" 这里保存了最近的50条查词记录。 ");

const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_18 = /*#__PURE__*/HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", null, " 10分钟内相同的记录会合并为一条。 ", -1));

const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_19 = {
  key: 0
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_20 = {
  key: 0
};
const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_21 = {
  key: 1
};

const HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_22 = /*#__PURE__*/createTextVNode(" 确定要清空历史记录？ ");

function HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  const _component_Scrollable = resolveComponent("Scrollable");

  const _component_modal_component = resolveComponent("modal-component");

  return openBlock(), createBlock(_component_modal_component, {
    open: _ctx.visible,
    onClose: _ctx.handleClose
  }, {
    default: withCtx(() => [createBaseVNode("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_1, [HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_2, runtime_core_esm_bundler_createVNode(_component_Scrollable, {
      class: "flex-1 h-0"
    }, {
      default: withCtx(({
        scrollBar
      }) => [createBaseVNode("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_3, [!_ctx.list.length ? (openBlock(), createElementBlock("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_4, " 暂无查词历史记录 ")) : createCommentVNode("", true), !!_ctx.list.length ? (openBlock(), createElementBlock("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_5)) : createCommentVNode("", true), (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.list, (item, index) => {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["group flex justify-between items-center mx-2 my-px px-3 py-1 rounded-6 hover:bg-grey-100", {
            'mr-4': scrollBar
          }]),
          key: index
        }, [createBaseVNode("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_6, [createBaseVNode("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_7, toDisplayString(index + 1) + ". ", 1), createBaseVNode("div", {
          class: "hover:bg-grey-300 p-2 rounded-4 mr-2 ml-1 cursor-pointer",
          onClick: $event => _ctx.handleItemClick($event, item)
        }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
          class: "flex-none",
          svg: _ctx.getIcon(item.provider),
          size: 24
        }, null, 8, ["svg"])], 8, HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_8), createBaseVNode("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_9, [createBaseVNode("span", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_10, toDisplayString(item.word), 1)])]), createBaseVNode("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_11, [createBaseVNode("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_12, toDisplayString(_ctx.getProviderName(item.provider)), 1), createBaseVNode("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_13, [createBaseVNode("span", {
          title: _ctx.formatTimeFull(item.time)
        }, toDisplayString(_ctx.formatTime(item.time)), 9, HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_14)])])], 2);
      }), 128)), HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_15, createBaseVNode("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_16, [createBaseVNode("div", null, [HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_17, createBaseVNode("button", {
        class: "outline-none text-primary hover:underline",
        onClick: _cache[0] || (_cache[0] = //@ts-ignore
        (...args) => _ctx.handleExport && _ctx.handleExport(...args))
      }, " 导出到控制台 ")]), HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_18, !!_ctx.list.length ? (openBlock(), createElementBlock("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_19, [!_ctx.state.showClearConfirm ? (openBlock(), createElementBlock("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_20, [createBaseVNode("button", {
        class: "outline-none text-primary hover:underline",
        onClick: _cache[1] || (_cache[1] = //@ts-ignore
        (...args) => _ctx.handleClear && _ctx.handleClear(...args))
      }, " 清空历史记录 ")])) : createCommentVNode("", true), _ctx.state.showClearConfirm ? (openBlock(), createElementBlock("div", HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_21, [HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_hoisted_22, createBaseVNode("button", {
        class: "outline-none text-primary hover:underline",
        onClick: _cache[2] || (_cache[2] = //@ts-ignore
        (...args) => _ctx.handleClearCancel && _ctx.handleClearCancel(...args))
      }, " 取消 "), createBaseVNode("button", {
        class: "outline-none text-primary hover:underline ml-2",
        onClick: _cache[3] || (_cache[3] = //@ts-ignore
        (...args) => _ctx.handleClearConfirm && _ctx.handleClearConfirm(...args))
      }, " 确定 ")])) : createCommentVNode("", true)])) : createCommentVNode("", true)])])]),
      _: 1
    })])]),
    _: 1
  }, 8, ["open", "onClose"]);
}
;// CONCATENATED MODULE: ./src/view/HistoryModal/HistoryModal.vue?vue&type=template&id=2d428882&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/service/toast/Toast/index.vue?vue&type=template&id=22ad7e37&scoped=true&ts=true


const Toastvue_type_template_id_22ad7e37_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-22ad7e37"), n = n(), _popScopeId(), n);

const Toastvue_type_template_id_22ad7e37_scoped_true_ts_true_hoisted_1 = {
  key: 0,
  class: "toast-box fixed flex flex-center text-white ease-in-out duration-300"
};
function Toastvue_type_template_id_22ad7e37_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "t"
  }, {
    default: withCtx(() => [_ctx.state.visible ? (openBlock(), createElementBlock("div", Toastvue_type_template_id_22ad7e37_scoped_true_ts_true_hoisted_1, toDisplayString(_ctx.props.text), 1)) : createCommentVNode("", true)]),
    _: 1
  });
}
;// CONCATENATED MODULE: ./src/service/toast/Toast/index.vue?vue&type=template&id=22ad7e37&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/service/toast/Toast/index.ts?vue&type=script&lang=ts

const Toast = runtime_core_esm_bundler_defineComponent({
  props: {
    text: {
      type: String,
      default: ''
    },
    timeout: {
      type: Number,
      default: 3000
    },
    destroy: {
      type: Function,
      required: true
    }
  },
  setup: props => {
    const state = reactivity_esm_bundler_reactive({
      visible: false
    });
    runtime_core_esm_bundler_onMounted(() => {
      state.visible = true;
      setTimeout(() => {
        state.visible = false;
        setTimeout(() => {
          props.destroy();
        }, 3000);
      }, props.timeout);
    });
    return {
      state,
      props
    };
  }
});
/* harmony default export */ const Toastvue_type_script_lang_ts = (Toast);
;// CONCATENATED MODULE: ./src/service/toast/Toast/index.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/service/toast/Toast/index.sass?vue&type=style&index=0&id=22ad7e37&lang=sass&scoped=true
var Toastvue_type_style_index_0_id_22ad7e37_lang_sass_scoped_true = __webpack_require__(1853);
;// CONCATENATED MODULE: ./src/service/toast/Toast/index.sass?vue&type=style&index=0&id=22ad7e37&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/service/toast/Toast/index.vue




;


const Toast_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Toastvue_type_script_lang_ts, [['render',Toastvue_type_template_id_22ad7e37_scoped_true_ts_true_render],['__scopeId',"data-v-22ad7e37"]])

/* harmony default export */ const toast_Toast = (Toast_exports_);
;// CONCATENATED MODULE: ./src/service/toast/index.tsx





const toast_getId = useIncrement();
const toast_state = reactivity_esm_bundler_reactive({
  toasts: []
});
const ToastHack = toast_Toast;

const toast_init = () => {
  const ToastContainer = runtime_core_esm_bundler_defineComponent({
    setup: () => () => runtime_core_esm_bundler_createVNode("div", {
      "class": "toast-container"
    }, [toast_state.toasts.map(item => runtime_core_esm_bundler_createVNode(ToastHack, {
      "key": item.id,
      "text": item.text,
      "timeout": item.timeout,
      "destroy": item.destroy
    }, null))])
  });
  const toastContainer = createApp({
    render: () => h(ToastContainer)
  });
  const div = document.createElement('div');
  toastContainer.mount(div);
  shadowRoot.appendChild(div);
};

const toast = (params, timeout) => {
  var _params$timeout;

  const t = typeof params === 'string' ? timeout !== null && timeout !== void 0 ? timeout : 3000 : (_params$timeout = params.timeout) !== null && _params$timeout !== void 0 ? _params$timeout : 3000;
  const text = typeof params === 'string' ? params : params.text;
  const toastItem = {
    id: toast_getId(),
    timeout: t,
    text,
    destroy: () => {
      const index = toast_state.toasts.indexOf(toastItem);
      toast_state.toasts.splice(index, 1);
    }
  };
  toast_state.toasts.push(toastItem);
};
toast_init();
const toastService = {
  state: toast_state,
  toast
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/HistoryModal/HistoryModal.ts?vue&type=script&lang=ts








/* harmony default export */ const HistoryModalvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'HistoryModal',
  components: {
    ModalComponent: modal,
    Scrollable: Scrollable
  },
  setup: () => {
    const state = reactivity_esm_bundler_reactive({
      showClearConfirm: false
    });

    const handleClose = () => {
      viewService.closeHistory();
    };

    const handleExport = async () => {
      await historyService.loadHistory(); // eslint-disable-next-line no-console

      console.log((__webpack_require__(8334)/* .stringify */ .P)(historyService.state.list, null, 2));
      toastService.toast({
        text: '已导出到控制台（F12查看）'
      });
    };

    const handleItemClick = (e, item) => {
      bus.emit({
        type: EVENTS.TRANSLATE,
        mouseEvent: e,
        word: item.word,
        param: {
          provider: item.provider
        }
      });
    };

    const handleClear = () => {
      state.showClearConfirm = true;
    };

    const handleClearCancel = () => {
      state.showClearConfirm = false;
    };

    const handleClearConfirm = () => {
      state.showClearConfirm = false;
      historyService.clearHistory();
    };

    const getProviderName = id => providers.find(v => v.id === id).label;

    const padLeft = (value, pad, length) => {
      const text = String(value);
      const diff = text.length - length;

      if (diff <= 0) {
        return text;
      }

      return `${pad.repeat(diff)}${text}`;
    };

    const formatTimeFull = time => {
      const date = new Date(time);
      return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDay()} ${padLeft(date.getHours(), '0', 2)}:${padLeft(date.getMinutes(), '0', 2)}`;
    };

    const formatTime = time => {
      const now = Date.now();
      const diff = now - time;

      if (diff < 1000 * 60) {
        return `${Math.floor(diff / 1000)} 秒前`;
      }

      if (diff < 1000 * 60 * 60) {
        return `${Math.floor(diff / 1000 / 60)} 分钟前`;
      }

      if (diff < 1000 * 60 * 60 * 24) {
        return `${Math.floor(diff / 1000 / 60 / 60)} 小时前`;
      }

      return formatTimeFull(time);
    };

    watch(() => viewService.state.history, () => historyService.loadHistory());
    const list = runtime_core_esm_bundler_computed(() => historyService.state.list);
    const visible = runtime_core_esm_bundler_computed(() => viewService.state.history);
    return {
      getProviderName,
      state,
      visible,
      list,
      getIcon: getIcon,
      handleClose,
      handleExport,
      handleItemClick,
      handleClear,
      handleClearCancel,
      handleClearConfirm,
      formatTime,
      formatTimeFull
    };
  }
}));
;// CONCATENATED MODULE: ./src/view/HistoryModal/HistoryModal.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/view/HistoryModal/HistoryModal.sass?vue&type=style&index=0&id=2d428882&lang=sass&scoped=true
var HistoryModalvue_type_style_index_0_id_2d428882_lang_sass_scoped_true = __webpack_require__(6532);
;// CONCATENATED MODULE: ./src/view/HistoryModal/HistoryModal.sass?vue&type=style&index=0&id=2d428882&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/view/HistoryModal/HistoryModal.vue




;


const HistoryModal_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(HistoryModalvue_type_script_lang_ts, [['render',HistoryModalvue_type_template_id_2d428882_scoped_true_ts_true_render],['__scopeId',"data-v-2d428882"]])

/* harmony default export */ const HistoryModal = (HistoryModal_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/GoogleDictModal.vue?vue&type=template&id=ea3555cc&scoped=true&ts=true


const GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-ea3555cc"), n = n(), popScopeId(), n);

const GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_1 = {
  class: "google-dict-modal flex-col relative shadow-16"
};
const GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_2 = {
  class: "fold-control flex absolute select-none z-20 shadow-2 opacity-75 hover:opacity-100 duration-200 ease-in-out bg-bg-5"
};

const GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_3 = /*#__PURE__*/GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "tooltip"
}, " less ", -1));

const GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_4 = /*#__PURE__*/GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "split border-l border-grey-400"
}, null, -1));

const GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_5 = /*#__PURE__*/GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("div", {
  class: "tooltip"
}, " more ", -1));

const GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_6 = {
  class: "modal-box flex-col flex-1 h-0 relative text-14 bg-white"
};
const GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_7 = {
  key: 0,
  class: "dictionary-data-box flex-col items-stretch"
};
const GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_8 = {
  key: 0,
  class: "entry-box flex-col items-stretch"
};
function GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_icon = resolveComponent("i-icon");

  const _component_entry = resolveComponent("entry");

  const _component_usage_overtime = resolveComponent("usage-overtime");

  const _component_scrollable = resolveComponent("scrollable");

  const _component_modal_component = resolveComponent("modal-component");

  return openBlock(), createBlock(_component_modal_component, {
    open: _ctx.visible,
    onClose: _ctx.handleCloseModal
  }, {
    default: withCtx(() => [createBaseVNode("div", GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_1, [createBaseVNode("div", GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_2, [createBaseVNode("div", {
      class: normalizeClass([{
        disable: !_ctx.shrinkable
      }, "control-btn flex flex-center relative"]),
      onClick: _cache[0] || (_cache[0] = //@ts-ignore
      (...args) => _ctx.handleShrink && _ctx.handleShrink(...args))
    }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
      size: "20",
      svg: _ctx.icon.minus
    }, null, 8, ["svg"]), GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_3], 2), GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_4, createBaseVNode("div", {
      class: normalizeClass([{
        disable: !_ctx.expandable
      }, "control-btn flex flex-center"]),
      onClick: _cache[1] || (_cache[1] = //@ts-ignore
      (...args) => _ctx.handleExpand && _ctx.handleExpand(...args))
    }, [runtime_core_esm_bundler_createVNode(_component_i_icon, {
      size: "20",
      svg: _ctx.icon.plus
    }, null, 8, ["svg"]), GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_5], 2)]), createBaseVNode("div", GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_6, [runtime_core_esm_bundler_createVNode(_component_scrollable, {
      class: "flex-1 h-0"
    }, {
      default: withCtx(({
        scrollBar
      }) => [createBaseVNode("div", {
        class: normalizeClass(["content-box px-5 pt-5 pb-7", {
          'pr-5': !scrollBar,
          'pr-7': scrollBar
        }])
      }, [_ctx.state.containerData && _ctx.state.containerData.length ? (openBlock(), createElementBlock("div", GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_7, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.state.containerData, dicDataItem => {
        return openBlock(), createElementBlock("div", {
          class: "dictionary-data-item",
          key: _ctx.state.id + dicDataItem.queryTerm
        }, [dicDataItem.entries && dicDataItem.entries.length ? (openBlock(), createElementBlock("div", GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_hoisted_8, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(dicDataItem.entries, (entry, entryIndex) => {
          return openBlock(), createBlock(_component_entry, {
            class: normalizeClass({
              'mt-5': entryIndex !== 0
            }),
            entry: entry,
            key: entry.entrySeqNo
          }, null, 8, ["class", "entry"]);
        }), 128))])) : createCommentVNode("", true), dicDataItem.usageOverTimeImage ? (openBlock(), createBlock(_component_usage_overtime, {
          key: 1,
          image: dicDataItem.usageOverTimeImage,
          term: dicDataItem.queryTerm
        }, null, 8, ["image", "term"])) : createCommentVNode("", true)]);
      }), 128))])) : createCommentVNode("", true)], 2)]),
      _: 1
    })])])]),
    _: 1
  }, 8, ["open", "onClose"]);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/GoogleDictModal.vue?vue&type=template&id=ea3555cc&scoped=true&ts=true

;// CONCATENATED MODULE: ./src/assets/img/minus.svg
/* harmony default export */ const minus = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 500 500\"><path fill=\"none\" stroke=\"#777\" stroke-width=\"30\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" d=\"M74 247h353\"/></svg>\n");
;// CONCATENATED MODULE: ./src/assets/img/plus.svg
/* harmony default export */ const plus = ("<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 500 500\"><path fill=\"none\" stroke=\"#777\" stroke-width=\"30\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" d=\"M74 247h353M251 427V74\"/></svg>\n");
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/imageLoader/imageLoader.vue?vue&type=template&id=c0604a02&scoped=true&ts=true


const imageLoadervue_type_template_id_c0604a02_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-c0604a02"), n = n(), _popScopeId(), n);

const imageLoadervue_type_template_id_c0604a02_scoped_true_ts_true_hoisted_1 = {
  key: 0,
  class: "placeholder text-grey-400 font-mono"
};
const imageLoadervue_type_template_id_c0604a02_scoped_true_ts_true_hoisted_2 = ["src"];
function imageLoadervue_type_template_id_c0604a02_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["image-loader flex justify-center items-center", {
      loading: !_ctx.state.data
    }]),
    style: normalizeStyle({
      height: `${Number(_ctx.props.height) / 2}px`,
      width: `${Number(_ctx.props.width) / 2}px`
    })
  }, [!_ctx.state.data ? (openBlock(), createElementBlock("span", imageLoadervue_type_template_id_c0604a02_scoped_true_ts_true_hoisted_1, " loading.... ")) : createCommentVNode("", true), _ctx.state.data ? (openBlock(), createElementBlock("img", {
    key: 1,
    style: normalizeStyle({
      height: `${Number(_ctx.props.height) / 2}px`,
      width: `${Number(_ctx.props.width) / 2}px`
    }),
    src: _ctx.state.data
  }, null, 12, imageLoadervue_type_template_id_c0604a02_scoped_true_ts_true_hoisted_2)) : createCommentVNode("", true)], 6);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/imageLoader/imageLoader.vue?vue&type=template&id=c0604a02&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/imageLoader/imageLoader.ts?vue&type=script&lang=ts



/* harmony default export */ const imageLoadervue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GImageLoader',
  props: {
    url: {
      type: String,
      required: true
    },
    height: {
      type: [Number, String],
      required: true
    },
    width: {
      type: [Number, String],
      required: true
    }
  },
  setup: props => {
    const state = reactivity_esm_bundler_reactive({
      data: ''
    });

    const handleDraw = async url => {
      const response = await got({
        method: 'GET',
        headers: {
          'Accept': '*/*',
          'Accept-Encoding': 'gzip, deflate, br',
          'Accept-Language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7,zh-TW;q=0.6',
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache',
          'upgrade-insecure-requests': '1',
          'User-Agent': window.navigator.userAgent
        },
        responseType: 'blob',
        url,
        timeout: 5000
      });

      if (Either_isLeft(response)) {
        throw new Error(response.left.type);
      }

      const blob = response.right.response;
      const reader = new FileReader();
      reader.readAsDataURL(blob);

      reader.onloadend = () => {
        state.data = reader.result.replace('data:;base64,', 'data:image/png;base64,');
      };
    };

    const loadImage = () => {
      if (props.url) {
        state.data = '';
        handleDraw(props.url);
      }
    };

    runtime_core_esm_bundler_onMounted(() => {
      loadImage();
    });
    watch(() => props.url, () => {
      loadImage();
    });
    return {
      props,
      state
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/imageLoader/imageLoader.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/imageLoader/imageLoader.sass?vue&type=style&index=0&id=c0604a02&lang=sass&scoped=true
var imageLoadervue_type_style_index_0_id_c0604a02_lang_sass_scoped_true = __webpack_require__(2708);
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/imageLoader/imageLoader.sass?vue&type=style&index=0&id=c0604a02&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/imageLoader/imageLoader.vue




;


const imageLoader_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(imageLoadervue_type_script_lang_ts, [['render',imageLoadervue_type_template_id_c0604a02_scoped_true_ts_true_render],['__scopeId',"data-v-c0604a02"]])

/* harmony default export */ const imageLoader = (imageLoader_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/usageOvertime/usageOvertime.vue?vue&type=template&id=7d542e5a&ts=true

const usageOvertimevue_type_template_id_7d542e5a_ts_true_hoisted_1 = {
  key: 0,
  class: "usage-overtime mt-4 pt-4 flex-col items-stretch border-t border-grey-400"
};
const usageOvertimevue_type_template_id_7d542e5a_ts_true_hoisted_2 = {
  class: "usage-title text-grey-500 text-18"
};

const usageOvertimevue_type_template_id_7d542e5a_ts_true_hoisted_3 = /*#__PURE__*/createTextVNode(" Use over time for ");

const usageOvertimevue_type_template_id_7d542e5a_ts_true_hoisted_4 = {
  class: "bg-grey-500 text-white px-1"
};
function usageOvertimevue_type_template_id_7d542e5a_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_image_loader = resolveComponent("image-loader");

  return _ctx.m ? (openBlock(), createElementBlock("div", usageOvertimevue_type_template_id_7d542e5a_ts_true_hoisted_1, [createBaseVNode("div", usageOvertimevue_type_template_id_7d542e5a_ts_true_hoisted_2, [usageOvertimevue_type_template_id_7d542e5a_ts_true_hoisted_3, createBaseVNode("span", usageOvertimevue_type_template_id_7d542e5a_ts_true_hoisted_4, toDisplayString(_ctx.term), 1)]), createBaseVNode("div", {
    class: "usage-img-wrapper mt-2 overflow-hidden",
    style: normalizeStyle({
      height: `${_ctx.m.tablet.height / 2}px`,
      width: `${_ctx.m.tablet.width / 2}px`
    })
  }, [runtime_core_esm_bundler_createVNode(_component_image_loader, {
    height: _ctx.m.tablet.height,
    width: _ctx.m.tablet.width,
    url: `https://www.gstatic.com/onebox/dictionary/${_ctx.m.tablet.url}`
  }, null, 8, ["height", "width", "url"])], 4)])) : createCommentVNode("", true);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/usageOvertime/usageOvertime.vue?vue&type=template&id=7d542e5a&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/usageOvertime/usageOvertime.ts?vue&type=script&lang=ts


/* harmony default export */ const usageOvertimevue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GUsageOvertime',
  components: {
    imageLoader: imageLoader
  },
  props: {
    image: {
      type: null,
      required: true
    },
    term: {
      type: String,
      required: true
    }
  },
  setup: props => ({
    m: props.image
  })
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/usageOvertime/usageOvertime.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/usageOvertime/usageOvertime.vue




;
const usageOvertime_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(usageOvertimevue_type_script_lang_ts, [['render',usageOvertimevue_type_template_id_7d542e5a_ts_true_render]])

/* harmony default export */ const usageOvertime = (usageOvertime_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/entry/entry.vue?vue&type=template&id=184bced8&ts=true

const entryvue_type_template_id_184bced8_ts_true_hoisted_1 = {
  class: "entry-item"
};
const entryvue_type_template_id_184bced8_ts_true_hoisted_2 = {
  key: 0,
  class: "sub-entry-lemma"
};
const entryvue_type_template_id_184bced8_ts_true_hoisted_3 = {
  key: 1,
  class: "triggering-phrases text-grey-400"
};
const entryvue_type_template_id_184bced8_ts_true_hoisted_4 = {
  class: "headword flex flex-wrap items-center"
};
const entryvue_type_template_id_184bced8_ts_true_hoisted_5 = ["title"];
const entryvue_type_template_id_184bced8_ts_true_hoisted_6 = {
  key: 0,
  class: "headword-graph-index text-14 ml-2px"
};
const entryvue_type_template_id_184bced8_ts_true_hoisted_7 = {
  key: 2,
  class: "sub-sense-list mt-1 flex-col items-stretch"
};
const entryvue_type_template_id_184bced8_ts_true_hoisted_8 = {
  key: 3,
  class: "sense-family-box flex-col items-stretch"
};
const entryvue_type_template_id_184bced8_ts_true_hoisted_9 = {
  key: 0,
  class: "poss italic"
};
const entryvue_type_template_id_184bced8_ts_true_hoisted_10 = ["title"];
const entryvue_type_template_id_184bced8_ts_true_hoisted_11 = {
  key: 1,
  class: "sense-family-label-set-box mb-1"
};
const entryvue_type_template_id_184bced8_ts_true_hoisted_12 = {
  key: 3,
  class: "sense-list flex-col items-stretch mt-2px"
};
const entryvue_type_template_id_184bced8_ts_true_hoisted_13 = {
  key: 4,
  class: "sub-entry-box"
};
function entryvue_type_template_id_184bced8_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_labels = resolveComponent("labels");

  const _component_label_set = resolveComponent("label-set");

  const _component_phonetics = resolveComponent("phonetics");

  const _component_note = resolveComponent("note");

  const _component_sense_item = resolveComponent("sense-item");

  const _component_morph_unit = resolveComponent("morph-unit");

  const _component_etymology = resolveComponent("etymology");

  const _component_g_entry = resolveComponent("g-entry");

  return openBlock(), createElementBlock("div", entryvue_type_template_id_184bced8_ts_true_hoisted_1, [_ctx.isSub ? (openBlock(), createElementBlock("div", entryvue_type_template_id_184bced8_ts_true_hoisted_2, [createTextVNode(toDisplayString(_ctx.e.lemma) + " ", 1), runtime_core_esm_bundler_createVNode(_component_labels, {
    class: "entry-type-label-box",
    color: "plain",
    size: "medium",
    labels: [_ctx.e.type],
    type: "entry-type"
  }, null, 8, ["labels"])])) : createCommentVNode("", true), _ctx.e.triggeringPhrases ? (openBlock(), createElementBlock("div", entryvue_type_template_id_184bced8_ts_true_hoisted_3, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.e.triggeringPhrases, (phrase, pIndex) => {
    return openBlock(), createElementBlock("span", {
      class: "t-phrase-item",
      key: pIndex
    }, toDisplayString(phrase) + toDisplayString(pIndex !== _ctx.e.triggeringPhrases.length - 1 ? ',' : ''), 1);
  }), 128))])) : createCommentVNode("", true), createBaseVNode("div", entryvue_type_template_id_184bced8_ts_true_hoisted_4, [createBaseVNode("div", {
    class: "headword-word text-28",
    title: _ctx.e.locale
  }, toDisplayString(_ctx.e.syllabifiedHeadword || _ctx.e.headword), 9, entryvue_type_template_id_184bced8_ts_true_hoisted_5), _ctx.e.homographIndex ? (openBlock(), createElementBlock("div", entryvue_type_template_id_184bced8_ts_true_hoisted_6, toDisplayString(_ctx.e.homographIndex), 1)) : createCommentVNode("", true), _ctx.e.labelSet ? (openBlock(), createBlock(_component_label_set, {
    key: 1,
    class: "entry-label-set ml-2",
    size: "large",
    "label-set": _ctx.e.labelSet
  }, null, 8, ["label-set"])) : createCommentVNode("", true)]), runtime_core_esm_bundler_createVNode(_component_phonetics, {
    class: "phonetics-box mb-1",
    phonetics: _ctx.e.phonetics
  }, null, 8, ["phonetics"]), runtime_core_esm_bundler_createVNode(_component_note, {
    note: _ctx.e.note
  }, null, 8, ["note"]), _ctx.isSub && _ctx.e.senseFamily && _ctx.e.senseFamily.senses && _ctx.e.senseFamily.senses.length ? (openBlock(), createElementBlock("div", entryvue_type_template_id_184bced8_ts_true_hoisted_7, [runtime_core_esm_bundler_createVNode(_component_label_set, {
    class: "sense-item-label",
    size: "medium",
    "label-set": _ctx.e.senseFamily.labelSet
  }, null, 8, ["label-set"]), (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.e.senseFamily.senses, (sense, senseIndex) => {
    return openBlock(), createBlock(_component_sense_item, {
      class: normalizeClass(["sense-item", {
        'mt-2': senseIndex !== 0
      }]),
      sense: sense,
      index: senseIndex,
      key: senseIndex
    }, null, 8, ["class", "sense", "index"]);
  }), 128))])) : createCommentVNode("", true), !_ctx.isSub && _ctx.e.senseFamilies && _ctx.e.senseFamilies.length ? (openBlock(), createElementBlock("div", entryvue_type_template_id_184bced8_ts_true_hoisted_8, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.e.senseFamilies, (senseFamilyItem, index) => {
    return openBlock(), createElementBlock("div", {
      class: normalizeClass(["sense-family-item flex-col items-stretch", {
        'mt-4': index !== 0
      }]),
      key: index
    }, [runtime_core_esm_bundler_createVNode(_component_note, {
      note: senseFamilyItem.note
    }, null, 8, ["note"]), senseFamilyItem.partsOfSpeechs && senseFamilyItem.partsOfSpeechs.length ? (openBlock(), createElementBlock("div", entryvue_type_template_id_184bced8_ts_true_hoisted_9, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(senseFamilyItem.partsOfSpeechs, (poss, possIndex) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["pos flex flex-wrap font-bold", {
          'mt-5px': possIndex !== 0
        }]),
        title: poss.qualifier,
        key: poss.value + possIndex
      }, toDisplayString(poss.value), 11, entryvue_type_template_id_184bced8_ts_true_hoisted_10);
    }), 128))])) : createCommentVNode("", true), runtime_core_esm_bundler_createVNode(_component_phonetics, {
      class: "phonetics-box",
      phonetics: senseFamilyItem.phonetics
    }, null, 8, ["phonetics"]), senseFamilyItem.labelSet ? (openBlock(), createElementBlock("div", entryvue_type_template_id_184bced8_ts_true_hoisted_11, [runtime_core_esm_bundler_createVNode(_component_label_set, {
      class: "sense-family-label-set",
      size: "medium",
      "label-set": senseFamilyItem.labelSet
    }, null, 8, ["label-set"])])) : createCommentVNode("", true), senseFamilyItem.morphUnits && senseFamilyItem.morphUnits.length ? (openBlock(), createBlock(_component_morph_unit, {
      key: 2,
      "morph-units": senseFamilyItem.morphUnits
    }, null, 8, ["morph-units"])) : createCommentVNode("", true), senseFamilyItem.senses && senseFamilyItem.senses.length ? (openBlock(), createElementBlock("div", entryvue_type_template_id_184bced8_ts_true_hoisted_12, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(senseFamilyItem.senses, (sense, senseIndex) => {
      return openBlock(), createBlock(_component_sense_item, {
        class: "sense-item",
        sense: sense,
        index: senseIndex,
        key: senseIndex
      }, null, 8, ["sense", "index"]);
    }), 128))])) : createCommentVNode("", true)], 2);
  }), 128))])) : createCommentVNode("", true), runtime_core_esm_bundler_createVNode(_component_etymology, {
    etymology: _ctx.e.etymology
  }, null, 8, ["etymology"]), _ctx.e.subentries && _ctx.e.subentries.length ? (openBlock(), createElementBlock("div", entryvue_type_template_id_184bced8_ts_true_hoisted_13, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.e.subentries, (subentry, index) => {
    return openBlock(), createBlock(_component_g_entry, {
      class: "sub-entry",
      entry: subentry,
      "is-subentry": true,
      key: index
    }, null, 8, ["entry"]);
  }), 128))])) : createCommentVNode("", true)]);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/entry/entry.vue?vue&type=template&id=184bced8&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/labelSet/labelSet.vue?vue&type=template&id=bf2dbc5a&ts=true

const labelSetvue_type_template_id_bf2dbc5a_ts_true_hoisted_1 = {
  key: 0,
  class: "label-set-box text-0 inline"
};
function labelSetvue_type_template_id_bf2dbc5a_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_labels = resolveComponent("labels");

  return _ctx.isValid ? (openBlock(), createElementBlock("div", labelSetvue_type_template_id_bf2dbc5a_ts_true_hoisted_1, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(Object.keys(_ctx.props.labelSet), key => {
    return openBlock(), createBlock(_component_labels, {
      key: key,
      size: _ctx.props.size,
      class: "inner-label-box mr-5px",
      labels: _ctx.props.labelSet[key],
      type: key,
      color: _ctx.props.color || key
    }, null, 8, ["size", "labels", "type", "color"]);
  }), 128))])) : createCommentVNode("", true);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/labelSet/labelSet.vue?vue&type=template&id=bf2dbc5a&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/labels/labels.vue?vue&type=template&id=58734797&scoped=true&ts=true


const labelsvue_type_template_id_58734797_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-58734797"), n = n(), popScopeId(), n);

const labelsvue_type_template_id_58734797_scoped_true_ts_true_hoisted_1 = ["onMouseover", "onMouseleave"];

const labelsvue_type_template_id_58734797_scoped_true_ts_true_hoisted_2 = /*#__PURE__*/labelsvue_type_template_id_58734797_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("span", {
  class: "label-split",
  innerHTML: ' '
}, null, -1));

const labelsvue_type_template_id_58734797_scoped_true_ts_true_hoisted_3 = {
  key: 0,
  class: "tooltip rounded-5 absolute text-white select-none ease-in-out"
};

const labelsvue_type_template_id_58734797_scoped_true_ts_true_hoisted_4 = /*#__PURE__*/labelsvue_type_template_id_58734797_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("span", {
  class: "label-split text-0",
  innerHTML: ' '
}, null, -1));

function labelsvue_type_template_id_58734797_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.labels && _ctx.labels.length ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(["label-box inline text-0", [_ctx.colorClass, _ctx.sizeClass]])
  }, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.props.labels, (label, index) => {
    return openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, {
      key: index
    }, [createBaseVNode("div", {
      class: normalizeClass(["label relative inline-flex text-grey-700", [_ctx.labelClass, index === _ctx.labels.length - 1 ? 'last' : '']]),
      onMouseover: $event => _ctx.shopTip(label),
      onMouseleave: $event => _ctx.hideTip(label)
    }, [createTextVNode(toDisplayString(label) + " ", 1), labelsvue_type_template_id_58734797_scoped_true_ts_true_hoisted_2, runtime_core_esm_bundler_createVNode(Transition, {
      name: "p"
    }, {
      default: withCtx(() => [_ctx.state.tipMap[label] ? (openBlock(), createElementBlock("div", labelsvue_type_template_id_58734797_scoped_true_ts_true_hoisted_3, toDisplayString(_ctx.type), 1)) : createCommentVNode("", true)]),
      _: 2
    }, 1024)], 42, labelsvue_type_template_id_58734797_scoped_true_ts_true_hoisted_1), labelsvue_type_template_id_58734797_scoped_true_ts_true_hoisted_4], 64);
  }), 128))], 2)) : createCommentVNode("", true);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/labels/labels.vue?vue&type=template&id=58734797&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/labels/labels.ts?vue&type=script&lang=ts


/* harmony default export */ const labelsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GLabels',
  props: {
    labels: {
      type: Array,
      required: true
    },
    type: {
      type: String,
      default: 'default'
    },
    color: {
      type: String,
      default: 'plain'
    },
    size: {
      type: String,
      default: 'medium'
    }
  },
  setup: _props => {
    const props = _props;
    const state = reactivity_esm_bundler_reactive({
      tipMap: {}
    });
    /** 显示 popover */

    const shopTip = label => {
      state.tipMap[label] = true;
    };
    /** 隐藏 popover */


    const hideTip = label => {
      state.tipMap[label] = false;
    };

    const labelClass = runtime_core_esm_bundler_computed(() => `${props.type}-label`);
    const colorClass = runtime_core_esm_bundler_computed(() => `color-${props.color}`);
    const sizeClass = runtime_core_esm_bundler_computed(() => `size-${props.size}`);
    watch(() => props.labels, () => {
      state.tipMap = from_entries_default()(props.labels.map(v => [v, state.tipMap[v] || false]));
    }, {
      immediate: true
    });
    return {
      state,
      props,
      labelClass,
      colorClass,
      sizeClass,
      shopTip,
      hideTip
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/labels/labels.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/labels/labels.sass?vue&type=style&index=0&id=58734797&lang=sass&scoped=true
var labelsvue_type_style_index_0_id_58734797_lang_sass_scoped_true = __webpack_require__(7882);
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/labels/labels.sass?vue&type=style&index=0&id=58734797&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/labels/labels.vue




;


const labels_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(labelsvue_type_script_lang_ts, [['render',labelsvue_type_template_id_58734797_scoped_true_ts_true_render],['__scopeId',"data-v-58734797"]])

/* harmony default export */ const labels = (labels_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/labelSet/labelSet.ts?vue&type=script&lang=ts


/* harmony default export */ const labelSetvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GLabelSet',
  components: {
    labels: labels
  },
  props: {
    labelSet: {
      type: null,
      required: true
    },
    size: {
      type: String,
      default: 'medium'
    },
    color: {
      type: String,
      default: ''
    }
  },
  setup: props => {
    const isValid = runtime_core_esm_bundler_computed(() => {
      const l = props.labelSet;

      if (!l) {
        return false;
      }

      const values = Object.values(l);
      return values.length && values.some(arr => arr === null || arr === void 0 ? void 0 : arr.length);
    });
    return {
      props,
      isValid
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/labelSet/labelSet.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/labelSet/labelSet.vue




;
const labelSet_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(labelSetvue_type_script_lang_ts, [['render',labelSetvue_type_template_id_bf2dbc5a_ts_true_render]])

/* harmony default export */ const labelSet = (labelSet_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/etymology/etymology.vue?vue&type=template&id=4e60e540&ts=true

const etymologyvue_type_template_id_4e60e540_ts_true_hoisted_1 = {
  key: 0,
  class: "etymology-box mt-4 pt-4 flex-col items-stretch border-t border-grey-400"
};

const etymologyvue_type_template_id_4e60e540_ts_true_hoisted_2 = /*#__PURE__*/createBaseVNode("div", {
  class: "etymology-title text-grey-500 text-18"
}, "Origin", -1);

const etymologyvue_type_template_id_4e60e540_ts_true_hoisted_3 = {
  key: 0,
  class: "etymology-img-box mt-2"
};
const etymologyvue_type_template_id_4e60e540_ts_true_hoisted_4 = {
  class: "etymology-text mt-2 text-grey-500"
};
function etymologyvue_type_template_id_4e60e540_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_image_loader = resolveComponent("image-loader");

  const _component_fragment = resolveComponent("fragment");

  return _ctx.props.etymology ? (openBlock(), createElementBlock("div", etymologyvue_type_template_id_4e60e540_ts_true_hoisted_1, [etymologyvue_type_template_id_4e60e540_ts_true_hoisted_2, _ctx.props.etymology.images ? (openBlock(), createElementBlock("div", etymologyvue_type_template_id_4e60e540_ts_true_hoisted_3, [runtime_core_esm_bundler_createVNode(_component_image_loader, {
    height: _ctx.props.etymology.images.tablet.height,
    width: _ctx.props.etymology.images.tablet.width,
    url: `https://www.gstatic.com/onebox/dictionary/${_ctx.props.etymology.images.tablet.url}`
  }, null, 8, ["height", "width", "url"])])) : createCommentVNode("", true), createBaseVNode("div", etymologyvue_type_template_id_4e60e540_ts_true_hoisted_4, [runtime_core_esm_bundler_createVNode(_component_fragment, {
    class: "etymology-frag",
    fragment: _ctx.props.etymology.etymology.fragments
  }, null, 8, ["fragment"])])])) : createCommentVNode("", true);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/etymology/etymology.vue?vue&type=template&id=4e60e540&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/etymology/etymology.ts?vue&type=script&lang=ts



/* harmony default export */ const etymologyvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GEtymology',
  components: {
    fragment: fragment,
    imageLoader: imageLoader
  },
  props: {
    etymology: {
      type: null,
      required: true
    }
  },
  setup: props => ({
    props
  })
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/etymology/etymology.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/etymology/etymology.vue




;
const etymology_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(etymologyvue_type_script_lang_ts, [['render',etymologyvue_type_template_id_4e60e540_ts_true_render]])

/* harmony default export */ const etymology = (etymology_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/note/note.vue?vue&type=template&id=5c711633&ts=true

const notevue_type_template_id_5c711633_ts_true_hoisted_1 = {
  key: 0,
  class: "dict-note my-2 flex-col items-stretch"
};
const notevue_type_template_id_5c711633_ts_true_hoisted_2 = {
  class: "note-type-box flex mb-3px"
};
const notevue_type_template_id_5c711633_ts_true_hoisted_3 = ["innerHTML"];
function notevue_type_template_id_5c711633_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_labels = resolveComponent("labels");

  return _ctx.props.note ? (openBlock(), createElementBlock("div", notevue_type_template_id_5c711633_ts_true_hoisted_1, [createBaseVNode("div", notevue_type_template_id_5c711633_ts_true_hoisted_2, [runtime_core_esm_bundler_createVNode(_component_labels, {
    class: "note-label-box",
    color: "plain",
    size: "large",
    labels: [_ctx.props.note.type],
    type: "note"
  }, null, 8, ["labels"])]), createBaseVNode("div", {
    class: "note-text text-12 inline text-grey-500",
    innerHTML: _ctx.props.note.text
  }, null, 8, notevue_type_template_id_5c711633_ts_true_hoisted_3)])) : createCommentVNode("", true);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/note/note.vue?vue&type=template&id=5c711633&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/note/note.ts?vue&type=script&lang=ts


/* harmony default export */ const notevue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GNote',
  components: {
    labels: labels
  },
  props: {
    note: {
      type: null,
      required: true
    }
  },
  setup: props => ({
    props
  })
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/note/note.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/note/note.vue




;
const note_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(notevue_type_script_lang_ts, [['render',notevue_type_template_id_5c711633_ts_true_render]])

/* harmony default export */ const note = (note_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/senseItem/senseItem.vue?vue&type=template&id=b981c738&scoped=true&ts=true


const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_withScopeId = n => (pushScopeId("data-v-b981c738"), n = n(), popScopeId(), n);

const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_1 = {
  class: "sense-item flex"
};
const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_2 = {
  class: "sense-item-number text-right font-bold"
};
const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_3 = {
  class: "sense-item-box flex-col flex-auto items-stretch"
};
const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_4 = {
  class: "definition-box flex-auto flex-col items-stretch"
};
const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_5 = {
  class: "difinition"
};
const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_6 = {
  class: "sense-labels inline"
};
const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_7 = {
  key: 0,
  class: "subsense-box"
};
const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_8 = {
  class: "subsense-number pr-2 text-grey-600"
};
const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_9 = {
  class: "subsense-item-container flex-col flex-auto items-stretch"
};
const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_10 = {
  class: "subsense-definition"
};

const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_11 = /*#__PURE__*/senseItemvue_type_template_id_b981c738_scoped_true_ts_true_withScopeId(() => /*#__PURE__*/createBaseVNode("span", {
  class: "split text-0"
}, " ", -1));

const senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_12 = {
  key: 0,
  class: "subsense-labels inline"
};
function senseItemvue_type_template_id_b981c738_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_label_set = resolveComponent("label-set");

  const _component_fragment = resolveComponent("fragment");

  const _component_labels = resolveComponent("labels");

  const _component_example_groups = resolveComponent("example-groups");

  const _component_thesaurus = resolveComponent("thesaurus");

  const _component_etymology = resolveComponent("etymology");

  const _component_foldable = resolveComponent("foldable");

  return openBlock(), createElementBlock("div", senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_1, [createBaseVNode("div", senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_2, toDisplayString(_ctx.index + 1) + ". ", 1), createBaseVNode("div", senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_3, [createBaseVNode("div", senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_4, [createBaseVNode("div", senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_5, [runtime_core_esm_bundler_createVNode(_component_label_set, {
    class: "sense-item-label",
    size: "medium",
    "label-set": _ctx.s.labelSet
  }, null, 8, ["label-set"]), runtime_core_esm_bundler_createVNode(_component_fragment, {
    class: "difinition-text sense-frag",
    fragment: _ctx.s.definition.fragments
  }, null, 8, ["fragment"]), createBaseVNode("div", senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_6, [_ctx.s.domainClasses && _ctx.s.domainClasses.length ? (openBlock(), createBlock(_component_labels, {
    key: 0,
    class: "ml-5px",
    color: "lightpink",
    size: "small",
    labels: _ctx.s.domainClasses,
    type: "domain"
  }, null, 8, ["labels"])) : createCommentVNode("", true), _ctx.s.semanticClasses && _ctx.s.semanticClasses.length ? (openBlock(), createBlock(_component_labels, {
    key: 1,
    class: "ml-5px",
    color: "lightblue",
    size: "small",
    labels: _ctx.s.semanticClasses,
    type: "semantic"
  }, null, 8, ["labels"])) : createCommentVNode("", true)])]), runtime_core_esm_bundler_createVNode(_component_example_groups, {
    "example-groups": _ctx.combinedGroups
  }, null, 8, ["example-groups"]), runtime_core_esm_bundler_createVNode(_component_thesaurus, {
    "thesaurus-entries": _ctx.s.thesaurusEntries
  }, null, 8, ["thesaurus-entries"]), _ctx.s.subsenses && _ctx.s.subsenses.length ? (openBlock(), createBlock(_component_foldable, {
    key: 0,
    fold: _ctx.subSenseFolded
  }, {
    default: withCtx(() => [_ctx.s.subsenses && _ctx.s.subsenses.length ? (openBlock(), createElementBlock("div", senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_7, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.sense.subsenses, (subsense, subsenseIndex) => {
      return openBlock(), createElementBlock("div", {
        class: "subsense-item flex mt-2px",
        key: subsenseIndex
      }, [createBaseVNode("div", senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_8, toDisplayString(subsenseIndex + 1) + ") ", 1), createBaseVNode("div", senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_9, [createBaseVNode("div", senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_10, [runtime_core_esm_bundler_createVNode(_component_label_set, {
        class: "subsense-definition-label",
        size: "medium",
        "label-set": subsense.labelSet
      }, null, 8, ["label-set"]), senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_11, runtime_core_esm_bundler_createVNode(_component_fragment, {
        class: "subsense-frag",
        fragment: subsense.definition.fragments
      }, null, 8, ["fragment"]), runtime_core_esm_bundler_createVNode(_component_etymology, {
        etymology: subsense.etymology
      }, null, 8, ["etymology"]), subsense.domainClasses && subsense.domainClasses.length && subsense.semanticClasses && subsense.semanticClasses.length ? (openBlock(), createElementBlock("div", senseItemvue_type_template_id_b981c738_scoped_true_ts_true_hoisted_12, [subsense.domainClasses && subsense.domainClasses.length ? (openBlock(), createBlock(_component_labels, {
        key: 0,
        class: "ml-5px",
        color: "lightpink",
        size: "small",
        labels: subsense.domainClasses,
        type: "domain"
      }, null, 8, ["labels"])) : createCommentVNode("", true), subsense.semanticClasses && subsense.semanticClasses.length ? (openBlock(), createBlock(_component_labels, {
        key: 1,
        class: "ml-5px",
        color: "lightblue",
        size: "small",
        labels: subsense.semanticClasses,
        type: "semantic"
      }, null, 8, ["labels"])) : createCommentVNode("", true)])) : createCommentVNode("", true)]), runtime_core_esm_bundler_createVNode(_component_example_groups, {
        "example-groups": subsense.exampleGroups
      }, null, 8, ["example-groups"]), runtime_core_esm_bundler_createVNode(_component_thesaurus, {
        "thesaurus-entries": subsense.thesaurusEntries
      }, null, 8, ["thesaurus-entries"])])]);
    }), 128))])) : createCommentVNode("", true)]),
    _: 1
  }, 8, ["fold"])) : createCommentVNode("", true)]), runtime_core_esm_bundler_createVNode(_component_etymology, {
    etymology: _ctx.s.etymology
  }, null, 8, ["etymology"])])]);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/senseItem/senseItem.vue?vue&type=template&id=b981c738&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurus.vue?vue&type=template&id=2759b815&scoped=true&ts=true


const thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_withScopeId = n => (_pushScopeId("data-v-2759b815"), n = n(), _popScopeId(), n);

const thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_1 = {
  class: "thesaurus-box flex-col items-start"
};
const thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_2 = ["onClick"];
const thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_3 = {
  key: 0,
  class: "show-more-or-less inline cursor-pointer select-none"
};

const thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_4 = /*#__PURE__*/createTextVNode(" [less] ");

const thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_5 = /*#__PURE__*/createTextVNode(" [more] ");

const thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_6 = {
  class: "thesaurus-box ml-4"
};
function thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ThesaurusRow = resolveComponent("ThesaurusRow");

  const _component_foldable = resolveComponent("foldable");

  return openBlock(), createBlock(_component_foldable, {
    fold: _ctx.folded
  }, {
    default: withCtx(() => [createBaseVNode("div", thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_1, [(openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(['synonyms', 'antonyms'], type => {
      return openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, null, [_ctx.combined[type].length ? (openBlock(), createElementBlock("div", {
        class: "thesaurus-syn-ant",
        key: type
      }, [createBaseVNode("div", null, [createBaseVNode("span", {
        class: normalizeClass({
          [`type-${type}`]: true,
          'cursor-pointer': _ctx.combined[type].length > 1
        }),
        onClick: $event => _ctx.handleToggleMoreOrLess(_ctx.combined[type])
      }, [createTextVNode(toDisplayString(type) + " ", 1), _ctx.combined[type].length > 1 ? (openBlock(), createElementBlock("span", thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_3, [_ctx.getShowMoreExpanded(_ctx.combined[type]) ? (openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, {
        key: 0
      }, [thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_4], 64)) : createCommentVNode("", true), !_ctx.getShowMoreExpanded(_ctx.combined[type]) ? (openBlock(), createElementBlock(runtime_core_esm_bundler_Fragment, {
        key: 1
      }, [thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_5], 64)) : createCommentVNode("", true)])) : createCommentVNode("", true)], 10, thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_2)]), createBaseVNode("div", thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_hoisted_6, [runtime_core_esm_bundler_createVNode(_component_ThesaurusRow, {
        class: "mt-px",
        index: 0,
        item: _ctx.combined[type][0]
      }, null, 8, ["item"]), _ctx.combined[type].length > 1 ? (openBlock(), createBlock(_component_foldable, {
        key: 0,
        fold: !_ctx.getShowMoreExpanded(_ctx.combined[type])
      }, {
        default: withCtx(() => [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.combined[type].slice(1), (tItem, tIndex) => {
          return openBlock(), createBlock(_component_ThesaurusRow, {
            class: "mt-px",
            key: tIndex,
            index: tIndex + 1,
            item: tItem
          }, null, 8, ["index", "item"]);
        }), 128))]),
        _: 2
      }, 1032, ["fold"])) : createCommentVNode("", true)])])) : createCommentVNode("", true)], 64);
    }), 64))])]),
    _: 1
  }, 8, ["fold"]);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurus.vue?vue&type=template&id=2759b815&scoped=true&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurusRow/thesaurusRow.vue?vue&type=template&id=478b4d2e&ts=true

const thesaurusRowvue_type_template_id_478b4d2e_ts_true_hoisted_1 = {
  class: "thesaurus-row flex"
};
const thesaurusRowvue_type_template_id_478b4d2e_ts_true_hoisted_2 = {
  class: "tw-index text-grey-500 mr-1"
};
const thesaurusRowvue_type_template_id_478b4d2e_ts_true_hoisted_3 = ["onClick"];
const thesaurusRowvue_type_template_id_478b4d2e_ts_true_hoisted_4 = {
  key: 0,
  class: "nym-split inline pr-3px"
};
function thesaurusRowvue_type_template_id_478b4d2e_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_labels = resolveComponent("labels");

  return openBlock(), createElementBlock("div", thesaurusRowvue_type_template_id_478b4d2e_ts_true_hoisted_1, [createBaseVNode("div", thesaurusRowvue_type_template_id_478b4d2e_ts_true_hoisted_2, toDisplayString(_ctx.props.index + 1) + ". ", 1), createBaseVNode("div", null, [_ctx.props.item.register ? (openBlock(), createBlock(_component_labels, {
    key: 0,
    class: "nym-register mr-1",
    type: "register",
    size: "small",
    labels: [_ctx.props.item.register]
  }, null, 8, ["labels"])) : createCommentVNode("", true), (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.props.item.nyms, (nym, nymIndex) => {
    return openBlock(), createElementBlock("div", {
      class: normalizeClass(["nym-item inline-flex text-grey-400", {
        'is-core': nym.isCore
      }]),
      key: nymIndex
    }, [createBaseVNode("div", {
      onClick: $event => _ctx.handleNymClick($event, nym),
      class: normalizeClass([{
        'text-link cursor-pointer': nym.numEntries
      }, "nym-content inline"])
    }, toDisplayString(nym.nym), 11, thesaurusRowvue_type_template_id_478b4d2e_ts_true_hoisted_3), nymIndex !== _ctx.props.item.nyms.length - 1 ? (openBlock(), createElementBlock("div", thesaurusRowvue_type_template_id_478b4d2e_ts_true_hoisted_4, " , ")) : createCommentVNode("", true)], 2);
  }), 128))])]);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurusRow/thesaurusRow.vue?vue&type=template&id=478b4d2e&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurusRow/thesaurusRow.ts?vue&type=script&lang=ts





/* harmony default export */ const thesaurusRowvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GThesaurusRow',
  components: {
    Labels: labels,
    Foldable: Foldable_Foldable
  },
  props: {
    item: {
      type: null,
      required: true
    },
    index: {
      type: Number,
      required: true
    }
  },
  setup: props => {
    const handleNymClick = (event, nym) => {
      if (nym.numEntries) {
        bus.emit({
          type: EVENTS.TRANSLATE,
          word: nym.nym,
          param: {
            provider: GoogleDictProvider.id
          },
          mouseEvent: event
        });
      }
    };

    return {
      props,
      handleNymClick
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurusRow/thesaurusRow.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurusRow/thesaurusRow.vue




;
const thesaurusRow_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(thesaurusRowvue_type_script_lang_ts, [['render',thesaurusRowvue_type_template_id_478b4d2e_ts_true_render]])

/* harmony default export */ const thesaurusRow = (thesaurusRow_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurus.ts?vue&type=script&lang=ts







/* harmony default export */ const thesaurusvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GThesaurus',
  components: {
    Labels: labels,
    Foldable: Foldable_Foldable,
    ThesaurusRow: thesaurusRow
  },
  props: {
    thesaurusEntries: {
      type: null,
      default: () => []
    }
  },
  setup: props => {
    const state = reactivity_esm_bundler_reactive({
      showMoreSet: []
    });

    const getShowMoreExpanded = item => state.showMoreSet.includes(item);

    const handleToggleMoreOrLess = item => {
      const index = state.showMoreSet.indexOf(item);

      if (index === -1) {
        state.showMoreSet.push(item);
      } else {
        state.showMoreSet.splice(index, 1);
      }
    };

    const addQoute = text => `"${text}"`;

    watch(() => props.thesaurusEntries, () => {
      state.showMoreSet = [];
    }, {
      immediate: true
    });
    const combined = runtime_core_esm_bundler_computed(() => {
      var _context, _context2;

      const synonyms = flat_map_default()(_context = props.thesaurusEntries.map(v => v.synonyms).filter(Boolean)).call(_context, v => v);

      const antonyms = flat_map_default()(_context2 = props.thesaurusEntries.map(v => v.antonyms).filter(Boolean)).call(_context2, v => v);

      return {
        synonyms,
        antonyms
      };
    });
    const folded = runtime_core_esm_bundler_computed(() => GoogleDict_store_store.data.foldStatus >= GOOGLE_DICT_FOLD_STATUS.FOLD_THESAURUS);
    return {
      t: props.thesaurusEntries,
      state,
      combined,
      folded,
      addQoute,
      handleToggleMoreOrLess,
      getShowMoreExpanded
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurus.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurus.sass?vue&type=style&index=0&id=2759b815&lang=sass&scoped=true
var thesaurusvue_type_style_index_0_id_2759b815_lang_sass_scoped_true = __webpack_require__(6210);
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurus.sass?vue&type=style&index=0&id=2759b815&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/thesaurus/thesaurus.vue




;


const thesaurus_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(thesaurusvue_type_script_lang_ts, [['render',thesaurusvue_type_template_id_2759b815_scoped_true_ts_true_render],['__scopeId',"data-v-2759b815"]])

/* harmony default export */ const thesaurus = (thesaurus_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/exampleGroups/exampleGroups.vue?vue&type=template&id=fbe896f4&ts=true

const exampleGroupsvue_type_template_id_fbe896f4_ts_true_hoisted_1 = {
  key: 0,
  class: "example-group-box flex-col items-stretch"
};
const exampleGroupsvue_type_template_id_fbe896f4_ts_true_hoisted_2 = {
  key: 0,
  class: "example-item-box flex-col items-stretch"
};
const exampleGroupsvue_type_template_id_fbe896f4_ts_true_hoisted_3 = ["innerHTML"];
function exampleGroupsvue_type_template_id_fbe896f4_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_labels = resolveComponent("labels");

  const _component_foldable = resolveComponent("foldable");

  return openBlock(), createBlock(_component_foldable, {
    fold: _ctx.folded
  }, {
    default: withCtx(() => [_ctx.props.exampleGroups && _ctx.props.exampleGroups.length ? (openBlock(), createElementBlock("div", exampleGroupsvue_type_template_id_fbe896f4_ts_true_hoisted_1, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.props.exampleGroups, (exampleGroupItem, index) => {
      return openBlock(), createElementBlock("div", {
        class: "example-group-item flex-col items-stretch",
        key: index
      }, [exampleGroupItem.examples && exampleGroupItem.examples.length ? (openBlock(), createElementBlock("div", exampleGroupsvue_type_template_id_fbe896f4_ts_true_hoisted_2, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(exampleGroupItem.examples, (example, exampleIndex) => {
        return openBlock(), createElementBlock("div", {
          class: "example-item text-grey-500",
          key: exampleIndex
        }, [exampleGroupItem.registers && exampleGroupItem.registers.length ? (openBlock(), createBlock(_component_labels, {
          key: 0,
          class: "mr-1",
          color: "registers",
          labels: exampleGroupItem.registers
        }, null, 8, ["labels"])) : createCommentVNode("", true), createBaseVNode("span", {
          innerHTML: `"${example}"`
        }, null, 8, exampleGroupsvue_type_template_id_fbe896f4_ts_true_hoisted_3)]);
      }), 128))])) : createCommentVNode("", true)]);
    }), 128))])) : createCommentVNode("", true)]),
    _: 1
  }, 8, ["fold"]);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/exampleGroups/exampleGroups.vue?vue&type=template&id=fbe896f4&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/exampleGroups/exampleGroups.ts?vue&type=script&lang=ts





/* harmony default export */ const exampleGroupsvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GExampleGroups',
  components: {
    labels: labels,
    Foldable: Foldable_Foldable
  },
  props: {
    exampleGroups: {
      type: null,
      required: true
    }
  },
  setup: props => {
    const folded = runtime_core_esm_bundler_computed(() => GoogleDict_store_store.data.foldStatus >= GOOGLE_DICT_FOLD_STATUS.FOLD_EXAMPLES);
    return {
      props,
      folded
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/exampleGroups/exampleGroups.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/exampleGroups/exampleGroups.vue




;
const exampleGroups_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(exampleGroupsvue_type_script_lang_ts, [['render',exampleGroupsvue_type_template_id_fbe896f4_ts_true_render]])

/* harmony default export */ const exampleGroups = (exampleGroups_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/senseItem/senseItem.ts?vue&type=script&lang=ts










/* harmony default export */ const senseItemvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GSenseItem',
  components: {
    labels: labels,
    labelSet: labelSet,
    thesaurus: thesaurus,
    fragment: fragment,
    etymology: etymology,
    exampleGroups: exampleGroups,
    Foldable: Foldable_Foldable
  },
  props: {
    sense: {
      type: null,
      required: true
    },
    index: {
      type: Number,
      required: true
    }
  },
  setup: props => {
    const combinedGroups = runtime_core_esm_bundler_computed(() => {
      const eg = props.sense.exampleGroups;
      const th = props.sense.thesaurusEntries;
      const examples = eg !== null && eg !== void 0 ? eg : [];
      const thesaurusExamples = (th !== null && th !== void 0 ? th : []).map(v => v.examples).filter(Boolean).map(v => v.filter(l => !examples.find(u => !u.registers && u.examples.includes(l)))).filter(v => v.length).map(v => ({
        examples: v
      }));
      return [...examples, ...thesaurusExamples];
    });
    const subSenseFolded = runtime_core_esm_bundler_computed(() => GoogleDict_store_store.data.foldStatus >= GOOGLE_DICT_FOLD_STATUS.FOLD_SUBSENSE);
    return {
      s: props.sense,
      combinedGroups,
      subSenseFolded,
      store: GoogleDict_store_store
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/senseItem/senseItem.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/senseItem/senseItem.sass?vue&type=style&index=0&id=b981c738&lang=sass&scoped=true
var senseItemvue_type_style_index_0_id_b981c738_lang_sass_scoped_true = __webpack_require__(9731);
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/senseItem/senseItem.sass?vue&type=style&index=0&id=b981c738&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/senseItem/senseItem.vue




;


const senseItem_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(senseItemvue_type_script_lang_ts, [['render',senseItemvue_type_template_id_b981c738_scoped_true_ts_true_render],['__scopeId',"data-v-b981c738"]])

/* harmony default export */ const senseItem = (senseItem_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/provider/GoogleDict/container/components/modal/morphUnit/morphUnit.vue?vue&type=template&id=3028bb2e&ts=true

const morphUnitvue_type_template_id_3028bb2e_ts_true_hoisted_1 = {
  class: "morph-units-box"
};
const morphUnitvue_type_template_id_3028bb2e_ts_true_hoisted_2 = ["title"];
const morphUnitvue_type_template_id_3028bb2e_ts_true_hoisted_3 = {
  class: "morph-units-description inline"
};
const morphUnitvue_type_template_id_3028bb2e_ts_true_hoisted_4 = {
  class: "morph-units-word-form font-bold inline"
};

const morphUnitvue_type_template_id_3028bb2e_ts_true_hoisted_5 = /*#__PURE__*/createBaseVNode("div", {
  class: "morph-units-split inline"
}, "; ", -1);

function morphUnitvue_type_template_id_3028bb2e_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", morphUnitvue_type_template_id_3028bb2e_ts_true_hoisted_1, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(_ctx.props.morphUnits, (item, morphIndex) => {
    return openBlock(), createElementBlock("div", {
      class: "morph-units-item inline text-grey-500",
      title: item.formType.posTag,
      key: morphIndex
    }, [createBaseVNode("div", morphUnitvue_type_template_id_3028bb2e_ts_true_hoisted_3, toDisplayString(item.formType.description) + " ", 1), createBaseVNode("div", morphUnitvue_type_template_id_3028bb2e_ts_true_hoisted_4, toDisplayString(item.wordForm), 1), morphUnitvue_type_template_id_3028bb2e_ts_true_hoisted_5], 8, morphUnitvue_type_template_id_3028bb2e_ts_true_hoisted_2);
  }), 128))]);
}
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/morphUnit/morphUnit.vue?vue&type=template&id=3028bb2e&ts=true

;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/morphUnit/morphUnit.ts?vue&type=script&lang=ts

/* harmony default export */ const morphUnitvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GMorphUnits',
  props: {
    morphUnits: {
      type: null,
      required: true
    }
  },
  setup: props => ({
    props
  })
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/morphUnit/morphUnit.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/morphUnit/morphUnit.vue




;
const morphUnit_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(morphUnitvue_type_script_lang_ts, [['render',morphUnitvue_type_template_id_3028bb2e_ts_true_render]])

/* harmony default export */ const morphUnit = (morphUnit_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/components/modal/entry/entry.ts?vue&type=script&lang=ts








/* harmony default export */ const entryvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GEntry',
  components: {
    labels: labels,
    labelSet: labelSet,
    phonetics: phonetics,
    etymology: etymology,
    note: note,
    senseItem: senseItem,
    morphUnit: morphUnit
  },
  props: {
    entry: {
      type: null,
      required: true
    },
    isSubentry: {
      type: Boolean,
      required: true
    }
  },
  setup: props => ({
    e: props.entry,
    isSub: !!props.isSubentry
  })
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/entry/entry.ts?vue&type=script&lang=ts
 
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/components/modal/entry/entry.vue




;
const entry_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(entryvue_type_script_lang_ts, [['render',entryvue_type_template_id_184bced8_ts_true_render]])

/* harmony default export */ const entry = (entry_exports_);
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/GoogleDictModal.ts?vue&type=script&lang=ts













const GoogleDictModalvue_type_script_lang_ts_icon = {
  minus: minus,
  plus: plus
};
/* harmony default export */ const GoogleDictModalvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'GoogleDictModal',
  components: {
    ImageLoader: imageLoader,
    UsageOvertime: usageOvertime,
    Entry: entry,
    Scrollable: Scrollable,
    ModalComponent: modal
  },
  setup: () => {
    const state = reactivity_esm_bundler_reactive({
      containerData: null,
      id: 0
    });

    const handleOpenModal = p => {
      state.containerData = util_copy(p.googleDictData);
      state.id += 1;
      runtime_core_esm_bundler_nextTick(() => {
        viewService.openGoogleDictModal();
      });
    };

    const handleCloseModal = () => {
      viewService.closeGoogleDictModal();
    };

    const handleShrink = () => {
      const status = GoogleDict_store_store.data.foldStatus;
      GoogleDict_store_store.data.foldStatus = GOOGLE_DICT_FOLD_STATUS_NEXT_MAP[status];
    };

    const handleExpand = () => {
      const status = GoogleDict_store_store.data.foldStatus;
      GoogleDict_store_store.data.foldStatus = GOOGLE_DICT_FOLD_STATUS_PREV_MAP[status];
    };

    runtime_core_esm_bundler_onMounted(() => {
      bus.on({
        event: EVENTS.OPEN_GOOGLE_DICT_MODAL,
        listener: handleOpenModal
      });
    });
    const visible = runtime_core_esm_bundler_computed(() => viewService.state.googleDictModal);
    const shrinkable = runtime_core_esm_bundler_computed(() => GoogleDict_store_store.data.foldStatus < GOOGLE_DICT_FOLD_STATUS.FOLD_SUBSENSE);
    const expandable = runtime_core_esm_bundler_computed(() => GoogleDict_store_store.data.foldStatus > GOOGLE_DICT_FOLD_STATUS.UNFOLD);
    return {
      state,
      visible,
      icon: GoogleDictModalvue_type_script_lang_ts_icon,
      shrinkable,
      expandable,
      handleCloseModal,
      handleShrink,
      handleExpand
    };
  }
}));
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/GoogleDictModal.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/provider/GoogleDict/container/GoogleDictModal.sass?vue&type=style&index=0&id=ea3555cc&lang=sass&scoped=true
var GoogleDictModalvue_type_style_index_0_id_ea3555cc_lang_sass_scoped_true = __webpack_require__(5937);
;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/GoogleDictModal.sass?vue&type=style&index=0&id=ea3555cc&lang=sass&scoped=true

;// CONCATENATED MODULE: ./src/provider/GoogleDict/container/GoogleDictModal.vue




;


const GoogleDictModal_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(GoogleDictModalvue_type_script_lang_ts, [['render',GoogleDictModalvue_type_template_id_ea3555cc_scoped_true_ts_true_render],['__scopeId',"data-v-ea3555cc"]])

/* harmony default export */ const GoogleDictModal = (GoogleDictModal_exports_);
;// CONCATENATED MODULE: ./src/service/hotkey/index.ts


const hotkey_normalizeKey = key => key >= 'a' && key <= 'z' ? key.toUpperCase() : key;

const listeners = new Set();
const hotkey_keys = [];
let mouseEvent;

const handleClear = () => {
  hotkey_keys.length = 0;
};

const handleKeyDown = e => {
  const key = hotkey_normalizeKey(e.key);

  if (!e.repeat && !hotkey_keys.includes(key)) {
    hotkey_keys.push(key);

    if (mouseEvent) {
      Array.from(listeners).forEach(v => v([...hotkey_keys], mouseEvent, () => e.stopPropagation()));
    }
  }
};

const handleKeyUp = e => {
  const key = hotkey_normalizeKey(e.key);

  if (hotkey_keys.includes(key)) {
    hotkey_keys.splice(hotkey_keys.indexOf(key), 1);
  }
};

const handleMouseMove = e => {
  mouseEvent = e;
};

const list = [['keydown', handleKeyDown], ['keyup', handleKeyUp], ['blur', handleClear], ['focus', handleClear], ['mousemove', handleMouseMove]];
list.forEach(v => {
  window.addEventListener(v[0], v[1], true);
});

const onHotkeyPress = fn => {
  listeners.add(fn);
};

const offHotkeyPress = fn => {
  listeners.delete(fn);
};

const hotkey_match = (k1, k2) => k1.length === k2.length && k1.every(k => k2.includes(k));

const getHotkeyMatchedProvider = ks => {
  const provider = providers.find(p => {
    const providerConfig = p.store;
    return providerConfig.enableHotkey && hotkey_match(ks, providerConfig.hotkey);
  });
  return provider !== null && provider !== void 0 ? provider : null;
};

const hotkeyService = {
  onHotkeyPress,
  offHotkeyPress,
  match: hotkey_match,
  getHotkeyMatchedProvider
};
;// CONCATENATED MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-1.use[0]!./node_modules/babel-loader/lib/index.js!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[2]!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/App.ts?vue&type=script&lang=ts
// eslint-disable-next-line import/no-unassigned-import
















/* harmony default export */ const Appvue_type_script_lang_ts = (runtime_core_esm_bundler_defineComponent({
  name: 'IcibaAppRoot',
  components: {
    IcibaMain: lazyLoadHoc(IcibaMain, [EVENTS.TRANSLATE, EVENTS.HOTKEY_SHOW, EVENTS.HOTKEY_TRANSLATE]),
    IcibaCircle: IcibaCircle,
    HistoryModal: HistoryModal,
    SettingPage: SettingPage,
    GoogleDictModal: GoogleDictModal
  },
  setup: () => {
    const refs = {
      icibaCircle: reactivity_esm_bundler_ref()
    };
    let lastMouseUpEvent = null;
    let lastMouseMoveEvent = null;

    const handleMouseUp = e => {
      lastMouseUpEvent = e;
    };

    const handleMouseMove = e => {
      lastMouseMoveEvent = e;
    };

    const handleShowUpHotkeyPress = (keys, stop) => {
      if (!service_store_store.core.useHotkeyShowUp) {
        return;
      }

      const hotkeyMatch = hotkeyService.match(service_store_store.core.showUpHotkey, keys);

      if (!hotkeyMatch || !lastMouseMoveEvent) {
        return;
      }

      stop();
      bus.emit({
        type: EVENTS.HOTKEY_SHOW,
        mouseEvent: lastMouseMoveEvent,
        word: getSelectionText()
      });
    };

    const handleTranslateHotkeyPress = (keys, stop) => {
      const word = getSelectionText();

      if (!lastMouseUpEvent) {
        return;
      }

      const matchedProvider = hotkeyService.getHotkeyMatchedProvider(keys);

      if (matchedProvider) {
        const mouseEvent = lastMouseUpEvent;
        translateService.removeSelection();
        stop();
        bus.emit({
          type: EVENTS.HIDE_CIRCLE
        });
        bus.emit({
          type: EVENTS.HOTKEY_TRANSLATE,
          word,
          mouseEvent,
          provider: matchedProvider.id
        });
      }
    };

    const handleHotkeyPress = (keys, _e, stop) => {
      handleShowUpHotkeyPress(keys, stop);
      handleTranslateHotkeyPress(keys, stop);
    };

    runtime_core_esm_bundler_onMounted(() => {
      window.addEventListener('mouseup', handleMouseUp, true);
      window.addEventListener('mousemove', handleMouseMove, true);
      hotkeyService.onHotkeyPress(handleHotkeyPress);
      registerMenuCommand('打开iciba划词翻译设置', () => {
        viewService.openSettings();
      });
      scrollBarWidthService.init();
    });

    if (false) {}

    return {
      refs
    };
  }
}));
;// CONCATENATED MODULE: ./src/App.ts?vue&type=script&lang=ts
 
// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-4.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-4.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./src/assets/styles/global.sass?vue&type=style&index=0&lang=sass
var globalvue_type_style_index_0_lang_sass = __webpack_require__(3295);
;// CONCATENATED MODULE: ./src/assets/styles/global.sass?vue&type=style&index=0&lang=sass

// EXTERNAL MODULE: ./node_modules/thread-loader/dist/cjs.js??clonedRuleSet-3.use[0]!./utils/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-3.use[2]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/string-replace-loader/index.js??clonedRuleSet-6.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./src/App.vue?vue&type=style&index=1&id=63465bcb&scoped=true&lang=css
var Appvue_type_style_index_1_id_63465bcb_scoped_true_lang_css = __webpack_require__(2585);
;// CONCATENATED MODULE: ./src/App.vue?vue&type=style&index=1&id=63465bcb&scoped=true&lang=css

;// CONCATENATED MODULE: ./src/App.vue




;



const App_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(Appvue_type_script_lang_ts, [['render',Appvue_type_template_id_63465bcb_scoped_true_ts_true_render],['__scopeId',"data-v-63465bcb"]])

/* harmony default export */ const App = (App_exports_);
;// CONCATENATED MODULE: ./src/index.ts
/* eslint-disable import/no-unassigned-import, import/order */



















const main = async () => {
  await initStore(providers);
  const app = createApp({
    render() {
      return h(App);
    }

  });
  app.directive('ripple', diretives_ripple);
  app.directive('no-overscroll', no_overscroll);
  app.component('i-checkbox-line', checkboxLine);
  app.component('i-checkbox', checkbox_checkbox);
  app.component('i-radio-group', radioGroup);
  app.component('i-radio', radio_radio);
  app.component('i-slider', slider);
  app.component('i-hotkey-input', hotkeyInput);
  app.component('i-icon', IIcon);
  app.component('i-text-input', textInput);
  app.component('i-text-input-line', textInputLine);
  const appRoot = document.createElement('div');
  shadowRoot.appendChild(appRoot);
  app.mount(appRoot);
};

main();
})();

/******/ })()
;
}