// ==UserScript==
// @name       bilibili-cleanup
// @description 删除推送, 专心学习, 设置B站壁纸
// @version    202501201943.1.1
// @author     QQ2402398917
// @icon       https://i0.hdslb.com/bfs/static/jinkela/long/images/favicon.ico
// @match      https://www.bilibili.com/*
// @exclude    https://www.bilibili.com/*/*
// @exclude    https://www.bilibili.com/history*
// @require    https://cdn.jsdelivr.net/npm/vue@3.5.12/dist/vue.global.prod.js
// @grant      GM_addStyle
// @grant      GM_getValue
// @grant      GM_registerMenuCommand
// @grant      GM_setValue
// @license    MIT
// @namespace http://tampermonkey.net/
// @downloadURL https://update.greasyfork.org/scripts/488530/bilibili-cleanup.user.js
// @updateURL https://update.greasyfork.org/scripts/488530/bilibili-cleanup.meta.js
// ==/UserScript==

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const l=document.createElement("style");l.textContent=e,document.head.append(l)})(` @charset "UTF-8";.wallpaper-item[data-v-0166ab8b]{height:100vh;width:100%;position:absolute;top:0;z-index:23;background-repeat:no-repeat;background-color:var(--wallpaper-bg-color);background-size:var(--wallpaper-size);background-position:var(--wallpaper-pos-x) var(--wallpaper-pos-y);transition:translate var(--scroll-duration) var(--scroll-timing-function)}.wallpaper-item.hidden[data-v-0166ab8b]{translate:0 -100vh}:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645,.045,.355,1);--el-transition-function-fast-bezier:cubic-bezier(.23,1,.32,1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px;color-scheme:light;--el-color-primary:#409eff;--el-color-primary-light-3:rgb(121.3,187.1,255);--el-color-primary-light-5:rgb(159.5,206.5,255);--el-color-primary-light-7:rgb(197.7,225.9,255);--el-color-primary-light-8:rgb(216.8,235.6,255);--el-color-primary-light-9:rgb(235.9,245.3,255);--el-color-primary-dark-2:rgb(51.2,126.4,204);--el-color-success:#67c23a;--el-color-success-light-3:rgb(148.6,212.3,117.1);--el-color-success-light-5:rgb(179,224.5,156.5);--el-color-success-light-7:rgb(209.4,236.7,195.9);--el-color-success-light-8:rgb(224.6,242.8,215.6);--el-color-success-light-9:rgb(239.8,248.9,235.3);--el-color-success-dark-2:rgb(82.4,155.2,46.4);--el-color-warning:#e6a23c;--el-color-warning-light-3:rgb(237.5,189.9,118.5);--el-color-warning-light-5:rgb(242.5,208.5,157.5);--el-color-warning-light-7:rgb(247.5,227.1,196.5);--el-color-warning-light-8:rgb(250,236.4,216);--el-color-warning-light-9:rgb(252.5,245.7,235.5);--el-color-warning-dark-2:rgb(184,129.6,48);--el-color-danger:#f56c6c;--el-color-danger-light-3:rgb(248,152.1,152.1);--el-color-danger-light-5:rgb(250,181.5,181.5);--el-color-danger-light-7:rgb(252,210.9,210.9);--el-color-danger-light-8:rgb(253,225.6,225.6);--el-color-danger-light-9:rgb(254,240.3,240.3);--el-color-danger-dark-2:rgb(196,86.4,86.4);--el-color-error:#f56c6c;--el-color-error-light-3:rgb(248,152.1,152.1);--el-color-error-light-5:rgb(250,181.5,181.5);--el-color-error-light-7:rgb(252,210.9,210.9);--el-color-error-light-8:rgb(253,225.6,225.6);--el-color-error-light-9:rgb(254,240.3,240.3);--el-color-error-dark-2:rgb(196,86.4,86.4);--el-color-info:#909399;--el-color-info-light-3:rgb(177.3,179.4,183.6);--el-color-info-light-5:rgb(199.5,201,204);--el-color-info-light-7:rgb(221.7,222.6,224.4);--el-color-info-light-8:rgb(232.8,233.4,234.6);--el-color-info-light-9:rgb(243.9,244.2,244.8);--el-color-info-dark-2:rgb(115.2,117.6,122.4);--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0,0,0,.04),0px 8px 20px rgba(0,0,0,.08);--el-box-shadow-light:0px 0px 12px rgba(0,0,0,.12);--el-box-shadow-lighter:0px 0px 6px rgba(0,0,0,.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0,0,0,.08),0px 12px 32px rgba(0,0,0,.12),0px 8px 16px -8px rgba(0,0,0,.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0,0,0,.8);--el-overlay-color-light:rgba(0,0,0,.7);--el-overlay-color-lighter:rgba(0,0,0,.5);--el-mask-color:rgba(255,255,255,.9);--el-mask-color-extra-light:rgba(255,255,255,.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.el-icon-loading{animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.el-icon{--color:inherit;align-items:center;display:inline-flex;height:1em;justify-content:center;line-height:1em;position:relative;width:1em;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:16px;--el-dialog-border-radius:var(--el-border-radius-base);background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;margin:var(--el-dialog-margin-top,15vh) auto 50px;overflow-wrap:break-word;padding:var(--el-dialog-padding-primary);position:relative;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:none!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;height:100%;margin-bottom:0;overflow:auto}.el-dialog__wrapper{bottom:0;left:0;margin:0;overflow:auto;position:fixed;right:0;top:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-dialog__header{padding-bottom:var(--el-dialog-padding-primary)}.el-dialog__header.show-close{padding-right:calc(var(--el-dialog-padding-primary) + var(--el-message-close-size, 16px))}.el-dialog__headerbtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:48px;outline:none;padding:0;position:absolute;right:0;top:0;width:48px}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{color:var(--el-text-color-primary);font-size:var(--el-dialog-title-font-size);line-height:var(--el-dialog-font-line-height)}.el-dialog__body{color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{box-sizing:border-box;padding-top:var(--el-dialog-padding-primary);text-align:right}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{bottom:0;left:0;overflow:auto;position:fixed;right:0;top:0}.dialog-fade-enter-active{animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{animation:dialog-fade-out var(--el-transition-duration)}@keyframes dialog-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes dialog-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-overlay{background-color:var(--el-overlay-color-lighter);bottom:0;height:100%;left:0;overflow:auto;position:fixed;right:0;top:0;z-index:2000}.el-overlay .el-overlay-root{height:0}.el-tabs{--el-tabs-header-height:40px;display:flex}.el-tabs__header{align-items:center;display:flex;justify-content:space-between;margin:0 0 15px;padding:0;position:relative}.el-tabs__header-vertical{flex-direction:column}.el-tabs__active-bar{background-color:var(--el-color-primary);bottom:0;height:2px;left:0;list-style:none;position:absolute;transition:width var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),transform var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);z-index:1}.el-tabs__new-tab{align-items:center;border:1px solid var(--el-border-color);border-radius:3px;color:var(--el-text-color-primary);cursor:pointer;display:flex;font-size:12px;height:20px;justify-content:center;line-height:20px;margin:10px 0 10px 10px;text-align:center;transition:all .15s;width:20px}.el-tabs__new-tab .is-icon-plus{height:inherit;transform:scale(.8);width:inherit}.el-tabs__new-tab .is-icon-plus svg{vertical-align:middle}.el-tabs__new-tab:hover{color:var(--el-color-primary)}.el-tabs__new-tab-vertical{margin-left:0}.el-tabs__nav-wrap{flex:1 auto;margin-bottom:-1px;overflow:hidden;position:relative}.el-tabs__nav-wrap:after{background-color:var(--el-border-color-light);bottom:0;content:"";height:2px;left:0;position:absolute;width:100%;z-index:var(--el-index-normal)}.el-tabs__nav-wrap.is-scrollable{box-sizing:border-box;padding:0 20px}.el-tabs__nav-scroll{overflow:hidden}.el-tabs__nav-next,.el-tabs__nav-prev{color:var(--el-text-color-secondary);cursor:pointer;font-size:12px;line-height:44px;position:absolute;text-align:center;width:20px}.el-tabs__nav-next{right:0}.el-tabs__nav-prev{left:0}.el-tabs__nav{display:flex;float:left;position:relative;transition:transform var(--el-transition-duration);white-space:nowrap;z-index:calc(var(--el-index-normal) + 1)}.el-tabs__nav.is-stretch{display:flex;min-width:100%}.el-tabs__nav.is-stretch>*{flex:1;text-align:center}.el-tabs__item{align-items:center;box-sizing:border-box;color:var(--el-text-color-primary);display:flex;font-size:var(--el-font-size-base);font-weight:500;height:var(--el-tabs-header-height);justify-content:center;list-style:none;padding:0 20px;position:relative}.el-tabs__item:focus,.el-tabs__item:focus:active{outline:none}.el-tabs__item:focus-visible{border-radius:3px;box-shadow:0 0 2px 2px var(--el-color-primary) inset}.el-tabs__item .is-icon-close{border-radius:50%;margin-left:5px;text-align:center;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs__item .is-icon-close:before{display:inline-block;transform:scale(.9)}.el-tabs__item .is-icon-close:hover{background-color:var(--el-text-color-placeholder);color:#fff}.el-tabs__item.is-active,.el-tabs__item:hover{color:var(--el-color-primary)}.el-tabs__item:hover{cursor:pointer}.el-tabs__item.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-tabs__content{flex-grow:1;overflow:hidden;position:relative}.el-tabs--bottom>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:0}.el-tabs--bottom>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top>.el-tabs__header .el-tabs__item:last-child{padding-right:0}.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:20px}.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child{padding-right:20px}.el-tabs--card>.el-tabs__header{border-bottom:1px solid var(--el-border-color-light);height:var(--el-tabs-header-height)}.el-tabs--card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--card>.el-tabs__header .el-tabs__nav{border:1px solid var(--el-border-color-light);border-bottom:none;border-radius:4px 4px 0 0;box-sizing:border-box}.el-tabs--card>.el-tabs__header .el-tabs__active-bar{display:none}.el-tabs--card>.el-tabs__header .el-tabs__item .is-icon-close{font-size:12px;height:14px;overflow:hidden;position:relative;right:-2px;transform-origin:100% 50%;width:0}.el-tabs--card>.el-tabs__header .el-tabs__item{border-bottom:1px solid transparent;border-left:1px solid var(--el-border-color-light);transition:color var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),padding var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--card>.el-tabs__header .el-tabs__item:first-child{border-left:none}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover{padding-left:13px;padding-right:13px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover .is-icon-close{width:14px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active{border-bottom-color:var(--el-bg-color)}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable{padding-left:20px;padding-right:20px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable .is-icon-close{width:14px}.el-tabs--border-card{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color)}.el-tabs--border-card>.el-tabs__content{padding:15px}.el-tabs--border-card>.el-tabs__header{background-color:var(--el-fill-color-light);border-bottom:1px solid var(--el-border-color-light);margin:0}.el-tabs--border-card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--border-card>.el-tabs__header .el-tabs__item{border:1px solid transparent;color:var(--el-text-color-secondary);margin-top:-1px;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--border-card>.el-tabs__header .el-tabs__item+.el-tabs__item,.el-tabs--border-card>.el-tabs__header .el-tabs__item:first-child{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active{background-color:var(--el-bg-color-overlay);border-left-color:var(--el-border-color);border-right-color:var(--el-border-color);color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:not(.is-disabled):hover{color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-disabled{color:var(--el-disabled-text-color)}.el-tabs--border-card>.el-tabs__header .is-scrollable .el-tabs__item:first-child{margin-left:0}.el-tabs--bottom{flex-direction:column}.el-tabs--bottom .el-tabs__header.is-bottom{margin-bottom:0;margin-top:10px}.el-tabs--bottom.el-tabs--border-card .el-tabs__header.is-bottom{border-bottom:0;border-top:1px solid var(--el-border-color)}.el-tabs--bottom.el-tabs--border-card .el-tabs__nav-wrap.is-bottom{margin-bottom:0;margin-top:-1px}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom:not(.is-active){border:1px solid transparent}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom{margin:0 -1px -1px}.el-tabs--left,.el-tabs--right{overflow:hidden}.el-tabs--left .el-tabs__header.is-left,.el-tabs--left .el-tabs__header.is-right,.el-tabs--left .el-tabs__nav-scroll,.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__header.is-left,.el-tabs--right .el-tabs__header.is-right,.el-tabs--right .el-tabs__nav-scroll,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{height:100%}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__active-bar.is-right,.el-tabs--right .el-tabs__active-bar.is-left,.el-tabs--right .el-tabs__active-bar.is-right{bottom:auto;height:auto;top:0;width:2px}.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{margin-bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{cursor:pointer;height:30px;line-height:30px;text-align:center;width:100%}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i{transform:rotate(90deg)}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{left:auto;top:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next{bottom:0;right:auto}.el-tabs--left .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--left .el-tabs__nav-wrap.is-right.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-right.is-scrollable{padding:30px 0}.el-tabs--left .el-tabs__nav-wrap.is-left:after,.el-tabs--left .el-tabs__nav-wrap.is-right:after,.el-tabs--right .el-tabs__nav-wrap.is-left:after,.el-tabs--right .el-tabs__nav-wrap.is-right:after{bottom:auto;height:100%;top:0;width:2px}.el-tabs--left .el-tabs__nav.is-left,.el-tabs--left .el-tabs__nav.is-right,.el-tabs--right .el-tabs__nav.is-left,.el-tabs--right .el-tabs__nav.is-right{flex-direction:column}.el-tabs--left .el-tabs__item.is-left,.el-tabs--right .el-tabs__item.is-left{justify-content:flex-end}.el-tabs--left .el-tabs__item.is-right,.el-tabs--right .el-tabs__item.is-right{justify-content:flex-start}.el-tabs--left{flex-direction:row-reverse}.el-tabs--left .el-tabs__header.is-left{margin-bottom:0;margin-right:10px}.el-tabs--left .el-tabs__nav-wrap.is-left{margin-right:-1px}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__nav-wrap.is-left:after{left:auto;right:0}.el-tabs--left .el-tabs__item.is-left{text-align:right}.el-tabs--left.el-tabs--card .el-tabs__active-bar.is-left{display:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left{border-bottom:none;border-left:none;border-right:1px solid var(--el-border-color-light);border-top:1px solid var(--el-border-color-light);text-align:left}.el-tabs--left.el-tabs--card .el-tabs__item.is-left:first-child{border-right:1px solid var(--el-border-color-light);border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active{border:1px solid var(--el-border-color-light);border-bottom:none;border-left:none;border-right:1px solid #fff}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:first-child{border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:last-child{border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__nav{border-bottom:1px solid var(--el-border-color-light);border-radius:4px 0 0 4px;border-right:none}.el-tabs--left.el-tabs--card .el-tabs__new-tab{float:none}.el-tabs--left.el-tabs--border-card .el-tabs__header.is-left{border-right:1px solid var(--el-border-color)}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left{border:1px solid transparent;margin:-1px 0 -1px -1px}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left.is-active{border-color:rgb(209,219,229) transparent}.el-tabs--right .el-tabs__header.is-right{margin-bottom:0;margin-left:10px}.el-tabs--right .el-tabs__nav-wrap.is-right{margin-left:-1px}.el-tabs--right .el-tabs__nav-wrap.is-right:after{left:0;right:auto}.el-tabs--right .el-tabs__active-bar.is-right{left:0}.el-tabs--right.el-tabs--card .el-tabs__active-bar.is-right{display:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right{border-bottom:none;border-top:1px solid var(--el-border-color-light)}.el-tabs--right.el-tabs--card .el-tabs__item.is-right:first-child{border-left:1px solid var(--el-border-color-light);border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active{border:1px solid var(--el-border-color-light);border-bottom:none;border-left:1px solid #fff;border-right:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:first-child{border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:last-child{border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__nav{border-bottom:1px solid var(--el-border-color-light);border-left:none;border-radius:0 4px 4px 0}.el-tabs--right.el-tabs--border-card .el-tabs__header.is-right{border-left:1px solid var(--el-border-color)}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right{border:1px solid transparent;margin:-1px -1px -1px 0}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right.is-active{border-color:rgb(209,219,229) transparent}.el-tabs--top{flex-direction:column-reverse}.slideInLeft-transition,.slideInRight-transition{display:inline-block}.slideInRight-enter{animation:slideInRight-enter var(--el-transition-duration)}.slideInRight-leave{animation:slideInRight-leave var(--el-transition-duration);left:0;position:absolute;right:0}.slideInLeft-enter{animation:slideInLeft-enter var(--el-transition-duration)}.slideInLeft-leave{animation:slideInLeft-leave var(--el-transition-duration);left:0;position:absolute;right:0}@keyframes slideInRight-enter{0%{opacity:0;transform:translate(100%);transform-origin:0 0}to{opacity:1;transform:translate(0);transform-origin:0 0}}@keyframes slideInRight-leave{0%{opacity:1;transform:translate(0);transform-origin:0 0}to{opacity:0;transform:translate(100%);transform-origin:0 0}}@keyframes slideInLeft-enter{0%{opacity:0;transform:translate(-100%);transform-origin:0 0}to{opacity:1;transform:translate(0);transform-origin:0 0}}@keyframes slideInLeft-leave{0%{opacity:1;transform:translate(0);transform-origin:0 0}to{opacity:0;transform:translate(-100%);transform-origin:0 0}}.el-upload{--el-upload-dragger-padding-horizontal:40px;--el-upload-dragger-padding-vertical:10px;align-items:center;cursor:pointer;display:inline-flex;justify-content:center;outline:none}.el-upload.is-disabled{cursor:not-allowed}.el-upload.is-disabled:focus{color:inherit}.el-upload.is-disabled:focus,.el-upload.is-disabled:focus .el-upload-dragger{border-color:var(--el-border-color-darker)}.el-upload.is-disabled .el-upload-dragger{background-color:var(--el-disabled-bg-color);cursor:not-allowed}.el-upload.is-disabled .el-upload-dragger .el-upload__text{color:var(--el-text-color-placeholder)}.el-upload.is-disabled .el-upload-dragger .el-upload__text em{color:var(--el-disabled-text-color)}.el-upload.is-disabled .el-upload-dragger:hover{border-color:var(--el-border-color-darker)}.el-upload__input{display:none}.el-upload__tip{color:var(--el-text-color-regular);font-size:12px;margin-top:7px}.el-upload iframe{filter:alpha(opacity=0);left:0;opacity:0;position:absolute;top:0;z-index:-1}.el-upload--picture-card{--el-upload-picture-card-size:148px;align-items:center;background-color:var(--el-fill-color-lighter);border:1px dashed var(--el-border-color-darker);border-radius:6px;box-sizing:border-box;cursor:pointer;display:inline-flex;height:var(--el-upload-picture-card-size);justify-content:center;vertical-align:top;width:var(--el-upload-picture-card-size)}.el-upload--picture-card>i{color:var(--el-text-color-secondary);font-size:28px}.el-upload--picture-card:hover{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload.is-drag{display:block}.el-upload:focus{color:var(--el-color-primary)}.el-upload:focus,.el-upload:focus .el-upload-dragger{border-color:var(--el-color-primary)}.el-upload-dragger{background-color:var(--el-fill-color-blank);border:1px dashed var(--el-border-color);border-radius:6px;box-sizing:border-box;cursor:pointer;overflow:hidden;padding:var(--el-upload-dragger-padding-horizontal) var(--el-upload-dragger-padding-vertical);position:relative;text-align:center}.el-upload-dragger .el-icon--upload{color:var(--el-text-color-placeholder);font-size:67px;line-height:50px;margin-bottom:16px}.el-upload-dragger+.el-upload__tip{text-align:center}.el-upload-dragger~.el-upload__files{border-top:var(--el-border);margin-top:7px;padding-top:5px}.el-upload-dragger .el-upload__text{color:var(--el-text-color-regular);font-size:14px;text-align:center}.el-upload-dragger .el-upload__text em{color:var(--el-color-primary);font-style:normal}.el-upload-dragger:hover{border-color:var(--el-color-primary)}.el-upload-dragger.is-dragover{background-color:var(--el-color-primary-light-9);border:2px dashed var(--el-color-primary);padding:calc(var(--el-upload-dragger-padding-horizontal) - 1px) calc(var(--el-upload-dragger-padding-vertical) - 1px)}.el-upload-list{list-style:none;margin:10px 0 0;padding:0;position:relative}.el-upload-list__item{border-radius:4px;box-sizing:border-box;color:var(--el-text-color-regular);font-size:14px;margin-bottom:5px;position:relative;transition:all .5s cubic-bezier(.55,0,.1,1);width:100%}.el-upload-list__item .el-progress{position:absolute;top:20px;width:100%}.el-upload-list__item .el-progress__text{position:absolute;right:0;top:-13px}.el-upload-list__item .el-progress-bar{margin-right:0;padding-right:0}.el-upload-list__item .el-icon--upload-success{color:var(--el-color-success)}.el-upload-list__item .el-icon--close{color:var(--el-text-color-regular);cursor:pointer;display:none;opacity:.75;position:absolute;right:5px;top:50%;transform:translateY(-50%);transition:opacity var(--el-transition-duration)}.el-upload-list__item .el-icon--close:hover{color:var(--el-color-primary);opacity:1}.el-upload-list__item .el-icon--close-tip{color:var(--el-color-primary);cursor:pointer;display:none;font-size:12px;font-style:normal;opacity:1;position:absolute;right:5px;top:1px}.el-upload-list__item:hover{background-color:var(--el-fill-color-light)}.el-upload-list__item:hover .el-icon--close{display:inline-flex}.el-upload-list__item:hover .el-progress__text{display:none}.el-upload-list__item .el-upload-list__item-info{display:inline-flex;flex-direction:column;justify-content:center;margin-left:4px;width:calc(100% - 30px)}.el-upload-list__item.is-success .el-upload-list__item-status-label{display:inline-flex}.el-upload-list__item.is-success .el-upload-list__item-name:focus,.el-upload-list__item.is-success .el-upload-list__item-name:hover{color:var(--el-color-primary);cursor:pointer}.el-upload-list__item.is-success:focus:not(:hover) .el-icon--close-tip{display:inline-block}.el-upload-list__item.is-success:active,.el-upload-list__item.is-success:not(.focusing):focus{outline-width:0}.el-upload-list__item.is-success:active .el-icon--close-tip,.el-upload-list__item.is-success:not(.focusing):focus .el-icon--close-tip{display:none}.el-upload-list__item.is-success:focus .el-upload-list__item-status-label,.el-upload-list__item.is-success:hover .el-upload-list__item-status-label{display:none;opacity:0}.el-upload-list__item-name{align-items:center;color:var(--el-text-color-regular);display:inline-flex;font-size:var(--el-font-size-base);padding:0 4px;text-align:center;transition:color var(--el-transition-duration)}.el-upload-list__item-name .el-icon{color:var(--el-text-color-secondary);margin-right:6px}.el-upload-list__item-file-name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-upload-list__item-status-label{align-items:center;display:none;height:100%;justify-content:center;line-height:inherit;position:absolute;right:5px;top:0;transition:opacity var(--el-transition-duration)}.el-upload-list__item-delete{color:var(--el-text-color-regular);display:none;font-size:12px;position:absolute;right:10px;top:0}.el-upload-list__item-delete:hover{color:var(--el-color-primary)}.el-upload-list--picture-card{--el-upload-list-picture-card-size:148px;display:inline-flex;flex-wrap:wrap;margin:0}.el-upload-list--picture-card .el-upload-list__item{background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;display:inline-flex;height:var(--el-upload-list-picture-card-size);margin:0 8px 8px 0;overflow:hidden;padding:0;width:var(--el-upload-list-picture-card-size)}.el-upload-list--picture-card .el-upload-list__item .el-icon--check,.el-upload-list--picture-card .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture-card .el-upload-list__item .el-icon--close{display:none}.el-upload-list--picture-card .el-upload-list__item:hover .el-upload-list__item-status-label{display:block;opacity:0}.el-upload-list--picture-card .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture-card .el-upload-list__item .el-upload-list__item-name{display:none}.el-upload-list--picture-card .el-upload-list__item-thumbnail{height:100%;-o-object-fit:contain;object-fit:contain;width:100%}.el-upload-list--picture-card .el-upload-list__item-status-label{background:var(--el-color-success);height:24px;right:-15px;text-align:center;top:-6px;transform:rotate(45deg);width:40px}.el-upload-list--picture-card .el-upload-list__item-status-label i{font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-list--picture-card .el-upload-list__item-actions{align-items:center;background-color:var(--el-overlay-color-lighter);color:#fff;cursor:default;display:inline-flex;font-size:20px;height:100%;justify-content:center;left:0;opacity:0;position:absolute;top:0;transition:opacity var(--el-transition-duration);width:100%}.el-upload-list--picture-card .el-upload-list__item-actions span{cursor:pointer;display:none}.el-upload-list--picture-card .el-upload-list__item-actions span+span{margin-left:16px}.el-upload-list--picture-card .el-upload-list__item-actions .el-upload-list__item-delete{color:inherit;font-size:inherit;position:static}.el-upload-list--picture-card .el-upload-list__item-actions:hover{opacity:1}.el-upload-list--picture-card .el-upload-list__item-actions:hover span{display:inline-flex}.el-upload-list--picture-card .el-progress{bottom:auto;left:50%;top:50%;transform:translate(-50%,-50%);width:126px}.el-upload-list--picture-card .el-progress .el-progress__text{top:50%}.el-upload-list--picture .el-upload-list__item{align-items:center;background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;display:flex;margin-top:10px;overflow:hidden;padding:10px;z-index:0}.el-upload-list--picture .el-upload-list__item .el-icon--check,.el-upload-list--picture .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture .el-upload-list__item:hover .el-upload-list__item-status-label{display:inline-flex;opacity:0}.el-upload-list--picture .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture .el-upload-list__item.is-success .el-upload-list__item-name i{display:none}.el-upload-list--picture .el-upload-list__item .el-icon--close{top:5px;transform:translateY(0)}.el-upload-list--picture .el-upload-list__item-thumbnail{align-items:center;background-color:var(--el-color-white);display:inline-flex;height:70px;justify-content:center;-o-object-fit:contain;object-fit:contain;position:relative;width:70px;z-index:1}.el-upload-list--picture .el-upload-list__item-status-label{background:var(--el-color-success);height:26px;position:absolute;right:-17px;text-align:center;top:-7px;transform:rotate(45deg);width:46px}.el-upload-list--picture .el-upload-list__item-status-label i{font-size:12px;margin-top:12px;transform:rotate(-45deg)}.el-upload-list--picture .el-progress{position:relative;top:-7px}.el-upload-cover{cursor:default;height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:10}.el-upload-cover:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-upload-cover img{display:block;height:100%;width:100%}.el-upload-cover__label{background:var(--el-color-success);height:24px;right:-15px;text-align:center;top:-6px;transform:rotate(45deg);width:40px}.el-upload-cover__label i{color:#fff;font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-cover__progress{display:inline-block;position:static;vertical-align:middle;width:243px}.el-upload-cover__progress+.el-upload__inner{opacity:0}.el-upload-cover__content{height:100%;left:0;position:absolute;top:0;width:100%}.el-upload-cover__interact{background-color:var(--el-overlay-color-light);bottom:0;height:100%;left:0;position:absolute;text-align:center;width:100%}.el-upload-cover__interact .btn{color:#fff;cursor:pointer;display:inline-block;font-size:14px;margin-top:60px;transition:var(--el-transition-md-fade);vertical-align:middle}.el-upload-cover__interact .btn i{margin-top:0}.el-upload-cover__interact .btn span{opacity:0;transition:opacity .15s linear}.el-upload-cover__interact .btn:not(:first-child){margin-left:35px}.el-upload-cover__interact .btn:hover{transform:translateY(-13px)}.el-upload-cover__interact .btn:hover span{opacity:1}.el-upload-cover__interact .btn i{color:#fff;display:block;font-size:24px;line-height:inherit;margin:0 auto 5px}.el-upload-cover__title{background-color:#fff;bottom:0;color:var(--el-text-color-primary);font-size:14px;font-weight:400;height:36px;left:0;line-height:36px;margin:0;overflow:hidden;padding:0 10px;position:absolute;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%}.el-upload-cover+.el-upload__inner{opacity:0;position:relative;z-index:1}.el-progress{align-items:center;display:flex;line-height:1;position:relative}.el-progress__text{color:var(--el-text-color-regular);font-size:14px;line-height:1;margin-left:5px;min-width:50px}.el-progress__text i{display:block;vertical-align:middle}.el-progress--circle,.el-progress--dashboard{display:inline-block}.el-progress--circle .el-progress__text,.el-progress--dashboard .el-progress__text{left:0;margin:0;position:absolute;text-align:center;top:50%;transform:translateY(-50%);width:100%}.el-progress--circle .el-progress__text i,.el-progress--dashboard .el-progress__text i{display:inline-block;vertical-align:middle}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{display:block;margin-right:0;padding-right:0}.el-progress--text-inside .el-progress-bar{margin-right:0;padding-right:0}.el-progress.is-success .el-progress-bar__inner{background-color:var(--el-color-success)}.el-progress.is-success .el-progress__text{color:var(--el-color-success)}.el-progress.is-warning .el-progress-bar__inner{background-color:var(--el-color-warning)}.el-progress.is-warning .el-progress__text{color:var(--el-color-warning)}.el-progress.is-exception .el-progress-bar__inner{background-color:var(--el-color-danger)}.el-progress.is-exception .el-progress__text{color:var(--el-color-danger)}.el-progress-bar{box-sizing:border-box;flex-grow:1}.el-progress-bar__outer{background-color:var(--el-border-color-lighter);border-radius:100px;height:6px;overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{background-color:var(--el-color-primary);border-radius:100px;height:100%;left:0;line-height:1;position:absolute;text-align:right;top:0;transition:width .6s ease;white-space:nowrap}.el-progress-bar__inner:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-progress-bar__inner--indeterminate{animation:indeterminate 3s infinite;transform:translateZ(0)}.el-progress-bar__inner--striped{background-image:linear-gradient(45deg,rgba(0,0,0,.1) 25%,transparent 0,transparent 50%,rgba(0,0,0,.1) 0,rgba(0,0,0,.1) 75%,transparent 0,transparent);background-size:1.25em 1.25em}.el-progress-bar__inner--striped.el-progress-bar__inner--striped-flow{animation:striped-flow 3s linear infinite}.el-progress-bar__innerText{color:#fff;display:inline-block;font-size:12px;margin:0 5px;vertical-align:middle}@keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@keyframes indeterminate{0%{left:-100%}to{left:100%}}@keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;display:inline-block;font-size:var(--el-font-size-base);position:relative;vertical-align:bottom;width:100%}.el-textarea__inner{-webkit-appearance:none;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));display:block;font-family:inherit;font-size:inherit;line-height:1.5;padding:5px 11px;position:relative;resize:vertical;transition:var(--el-transition-box-shadow);width:100%}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset;outline:none}.el-textarea .el-input__count{background:var(--el-fill-color-blank);bottom:5px;color:var(--el-color-info);font-size:12px;line-height:14px;position:absolute;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;--el-input-height:var(--el-component-size);box-sizing:border-box;display:inline-flex;font-size:var(--el-font-size-base);line-height:var(--el-input-height);position:relative;vertical-align:middle;width:var(--el-input-width)}.el-input::-webkit-scrollbar{width:6px;z-index:11}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{background:var(--el-text-color-disabled);border-radius:5px;width:6px}.el-input::-webkit-scrollbar-corner,.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);cursor:pointer;font-size:14px}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{align-items:center;color:var(--el-color-info);display:inline-flex;font-size:12px;height:100%}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);display:inline-block;line-height:normal;padding-left:8px}.el-input__wrapper{align-items:center;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;cursor:text;display:inline-flex;flex-grow:1;justify-content:center;padding:1px 11px;transform:translateZ(0);transition:var(--el-transition-box-shadow)}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);-webkit-appearance:none;background:none;border:none;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));flex-grow:1;font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);outline:none;padding:0;width:100%}.el-input__inner:focus{outline:none}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__prefix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__suffix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{align-items:center;display:flex;height:inherit;justify-content:center;line-height:inherit;margin-left:8px;transition:all var(--el-transition-duration)}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color, ) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{align-items:stretch;display:inline-flex;width:100%}.el-input-group__append,.el-input-group__prepend{align-items:center;background-color:var(--el-fill-color-light);border-radius:var(--el-input-border-radius);color:var(--el-color-info);display:inline-flex;justify-content:center;min-height:100%;padding:0 20px;position:relative;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:none}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{background-color:transparent;border-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-bottom-right-radius:0;border-right:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper,.el-input-group__append{border-bottom-left-radius:0;border-top-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-bottom-right-radius:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-bottom-right-radius:0;border-top-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-bottom-left-radius:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-hidden{display:none!important}.el-input-number{display:inline-flex;line-height:30px;position:relative;vertical-align:middle;width:150px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;line-height:1;text-align:center}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-input-number__decrease,.el-input-number__increase{align-items:center;background:var(--el-fill-color-light);bottom:1px;color:var(--el-text-color-regular);cursor:pointer;display:flex;font-size:13px;height:auto;justify-content:center;position:absolute;top:1px;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:32px;z-index:1}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input__wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{border-left:var(--el-border);border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;right:1px}.el-input-number__decrease{border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border);left:1px}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{line-height:38px;width:180px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{font-size:14px;width:40px}.el-input-number--large .el-input--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{line-height:22px;width:120px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{font-size:12px;width:24px}.el-input-number--small .el-input--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{border-bottom:var(--el-border);border-radius:0 var(--el-border-radius-base) 0 0;bottom:auto;left:auto}.el-input-number.is-controls-right .el-input-number__decrease{border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0;border-right:none;left:auto;right:1px;top:auto}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius,4px);border-radius:var(--el-popper-border-radius);font-size:12px;line-height:20px;min-width:10px;overflow-wrap:break-word;padding:5px 11px;position:absolute;visibility:visible;z-index:2000}.el-popper.is-dark{color:var(--el-bg-color)}.el-popper.is-dark,.el-popper.is-dark>.el-popper__arrow:before{background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark>.el-popper__arrow:before{right:0}.el-popper.is-light,.el-popper.is-light>.el-popper__arrow:before{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light>.el-popper__arrow:before{right:0}.el-popper.is-pure{padding:0}.el-popper__arrow,.el-popper__arrow:before{height:10px;position:absolute;width:10px;z-index:-1}.el-popper__arrow:before{background:var(--el-text-color-primary);box-sizing:border-box;content:" ";transform:rotate(45deg)}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent!important;border-top-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary);align-items:center;color:var(--el-checkbox-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-checkbox-font-weight);height:var(--el-checkbox-height,32px);margin-right:30px;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap}.el-checkbox.is-disabled{cursor:not-allowed}.el-checkbox.is-bordered{border:var(--el-border);border-radius:var(--el-border-radius-base);box-sizing:border-box;padding:0 15px 0 9px}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter)}.el-checkbox.is-bordered.el-checkbox--large{border-radius:var(--el-border-radius-base);padding:0 19px 0 11px}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{border-radius:calc(var(--el-border-radius-base) - 1px);padding:0 11px 0 7px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{border-radius:var(--el-checkbox-border-radius);outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px}.el-checkbox__input{cursor:pointer;display:inline-flex;outline:none;position:relative;white-space:nowrap}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-icon-color);cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-checked-icon-color);transform:rotate(45deg) scaleY(1)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-checked-icon-color);content:"";display:block;height:2px;left:0;position:absolute;right:0;top:5px;transform:scale(.5)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{background-color:var(--el-checkbox-bg-color);border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;display:inline-block;height:var(--el-checkbox-input-height);position:relative;transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46);width:var(--el-checkbox-input-width);z-index:var(--el-index-normal)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{border:1px solid transparent;border-left:0;border-top:0;box-sizing:content-box;content:"";height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);transform-origin:center;transition:transform .15s ease-in .05s;width:3px}.el-checkbox__original{height:0;margin:0;opacity:0;outline:none;position:absolute;width:0;z-index:-1}.el-checkbox__label{display:inline-block;font-size:var(--el-checkbox-font-size);line-height:1;padding-left:8px}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox:last-of-type{margin-right:0}.upload-item .cell[data-v-b8caab98]{margin-bottom:10px;display:flex;align-items:center;justify-content:space-between}.upload-item .cell .right[data-v-b8caab98]{display:flex;align-items:center}.upload-item .label[data-v-b8caab98]{margin-right:10px}.upload-item .input[data-v-b8caab98]{flex:1}.wallpaper-pane[data-v-d4dbee09]{height:300px}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transform-origin:center top;transition:var(--el-transition-md-fade)}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transform-origin:center bottom;transition:var(--el-transition-md-fade)}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transform-origin:top left;transition:var(--el-transition-md-fade)}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-collapse{--el-collapse-border-color:var(--el-border-color-lighter);--el-collapse-header-height:48px;--el-collapse-header-bg-color:var(--el-fill-color-blank);--el-collapse-header-text-color:var(--el-text-color-primary);--el-collapse-header-font-size:13px;--el-collapse-content-bg-color:var(--el-fill-color-blank);--el-collapse-content-font-size:13px;--el-collapse-content-text-color:var(--el-text-color-primary);border-bottom:1px solid var(--el-collapse-border-color);border-top:1px solid var(--el-collapse-border-color)}.el-collapse-item.is-disabled .el-collapse-item__header{color:var(--el-text-color-disabled);cursor:not-allowed}.el-collapse-item__header{align-items:center;background-color:var(--el-collapse-header-bg-color);border:none;border-bottom:1px solid var(--el-collapse-border-color);color:var(--el-collapse-header-text-color);cursor:pointer;display:flex;font-size:var(--el-collapse-header-font-size);font-weight:500;height:var(--el-collapse-header-height);line-height:var(--el-collapse-header-height);outline:none;padding:0;transition:border-bottom-color var(--el-transition-duration);width:100%}.el-collapse-item__arrow{font-weight:300;margin:0 8px 0 auto;transition:transform var(--el-transition-duration)}.el-collapse-item__arrow.is-active{transform:rotate(90deg)}.el-collapse-item__header.focusing:focus:not(:hover){color:var(--el-color-primary)}.el-collapse-item__header.is-active{border-bottom-color:transparent}.el-collapse-item__wrap{background-color:var(--el-collapse-content-bg-color);border-bottom:1px solid var(--el-collapse-border-color);box-sizing:border-box;overflow:hidden;will-change:height}.el-collapse-item__content{color:var(--el-collapse-content-text-color);font-size:var(--el-collapse-content-font-size);line-height:1.7692307692;padding-bottom:25px}.el-collapse-item:last-child{margin-bottom:-1px}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary);height:100%;overflow:hidden;position:relative}.el-scrollbar__wrap{height:100%;overflow:auto}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));border-radius:inherit;cursor:pointer;display:block;height:0;opacity:var(--el-scrollbar-opacity,.3);position:relative;transition:var(--el-transition-duration) background-color;width:0}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{border-radius:4px;bottom:2px;position:absolute;right:2px;z-index:1}.el-scrollbar__bar.is-vertical{top:2px;width:6px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-empty{--el-empty-padding:40px 0;--el-empty-image-width:160px;--el-empty-description-margin-top:20px;--el-empty-bottom-margin-top:20px;--el-empty-fill-color-0:var(--el-color-white);--el-empty-fill-color-1:#fcfcfd;--el-empty-fill-color-2:#f8f9fb;--el-empty-fill-color-3:#f7f8fc;--el-empty-fill-color-4:#eeeff3;--el-empty-fill-color-5:#edeef2;--el-empty-fill-color-6:#e9ebef;--el-empty-fill-color-7:#e5e7e9;--el-empty-fill-color-8:#e0e3e9;--el-empty-fill-color-9:#d5d7de;align-items:center;box-sizing:border-box;display:flex;flex-direction:column;justify-content:center;padding:var(--el-empty-padding);text-align:center}.el-empty__image{width:var(--el-empty-image-width)}.el-empty__image img{height:100%;-o-object-fit:contain;object-fit:contain;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:top;width:100%}.el-empty__image svg{color:var(--el-svg-monochrome-grey);fill:currentColor;height:100%;vertical-align:top;width:100%}.el-empty__description{margin-top:var(--el-empty-description-margin-top)}.el-empty__description p{color:var(--el-text-color-secondary);font-size:var(--el-font-size-base);margin:0}.el-empty__bottom{margin-top:var(--el-empty-bottom-margin-top)}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255,255,255,.5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary);align-items:center;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);box-sizing:border-box;color:var(--el-button-text-color);cursor:pointer;display:inline-flex;font-weight:var(--el-button-font-weight);height:32px;justify-content:center;line-height:1;outline:none;text-align:center;transition:.1s;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-button:hover{background-color:var(--el-button-hover-bg-color);border-color:var(--el-button-hover-border-color);color:var(--el-button-hover-text-color);outline:none}.el-button:active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button>span{align-items:center;display:inline-flex}.el-button+.el-button{margin-left:12px}.el-button{border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base)}.el-button,.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button.is-disabled,.el-button.is-disabled:hover{background-color:var(--el-button-disabled-bg-color);background-image:none;border-color:var(--el-button-disabled-border-color);color:var(--el-button-disabled-text-color);cursor:not-allowed}.el-button.is-loading{pointer-events:none;position:relative}.el-button.is-loading:before{background-color:var(--el-mask-color-extra-light);border-radius:inherit;bottom:-1px;content:"";left:-1px;pointer-events:none;position:absolute;right:-1px;top:-1px;z-index:1}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px;width:32px}.el-button.is-text{background-color:transparent;border:0 solid transparent;color:var(--el-button-text-color)}.el-button.is-text.is-disabled{background-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{background:transparent;border-color:transparent;color:var(--el-button-text-color);height:auto;padding:2px}.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-link:not(.is-disabled):active,.el-button.is-link:not(.is-disabled):hover{background-color:transparent;border-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color)}.el-button--text{background:transparent;border-color:transparent;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button--text:not(.is-disabled):hover{background-color:transparent;border-color:transparent;color:var(--el-color-primary-light-3)}.el-button--text:not(.is-disabled):active{background-color:transparent;border-color:transparent;color:var(--el-color-primary-dark-2)}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8);color:var(--el-color-primary-light-5)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8);color:var(--el-color-success-light-5)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8);color:var(--el-color-warning-light-5)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8);color:var(--el-color-danger-light-5)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8);color:var(--el-color-info-light-5)}.el-button--large{--el-button-size:40px;height:var(--el-button-size)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large{border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base);padding:12px 19px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{padding:12px;width:var(--el-button-size)}.el-button--small{--el-button-size:24px;height:var(--el-button-size)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small{border-radius:calc(var(--el-border-radius-base) - 1px);font-size:12px;padding:5px 11px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{padding:5px;width:var(--el-button-size)}:root{--el-loading-spinner-size:42px;--el-loading-fullscreen-spinner-size:50px}.el-loading-parent--relative{position:relative!important}.el-loading-parent--hidden{overflow:hidden!important}.el-loading-mask{background-color:var(--el-mask-color);bottom:0;left:0;margin:0;position:absolute;right:0;top:0;transition:opacity var(--el-transition-duration);z-index:2000}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:calc((0px - var(--el-loading-fullscreen-spinner-size))/2)}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{height:var(--el-loading-fullscreen-spinner-size);width:var(--el-loading-fullscreen-spinner-size)}.el-loading-spinner{margin-top:calc((0px - var(--el-loading-spinner-size))/2);position:absolute;text-align:center;top:50%;width:100%}.el-loading-spinner .el-loading-text{color:var(--el-color-primary);font-size:14px;margin:3px 0}.el-loading-spinner .circular{animation:loading-rotate 2s linear infinite;display:inline;height:var(--el-loading-spinner-size);width:var(--el-loading-spinner-size)}.el-loading-spinner .path{animation:loading-dash 1.5s ease-in-out infinite;stroke-dasharray:90,150;stroke-dashoffset:0;stroke-width:2;stroke:var(--el-color-primary);stroke-linecap:round}.el-loading-spinner i{color:var(--el-color-primary)}.el-loading-fade-enter-from,.el-loading-fade-leave-to{opacity:0}@keyframes loading-rotate{to{transform:rotate(1turn)}}@keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}to{stroke-dasharray:90,150;stroke-dashoffset:-120px}}.el-card{--el-card-border-color:var(--el-border-color-light);--el-card-border-radius:4px;--el-card-padding:20px;--el-card-bg-color:var(--el-fill-color-blank);background-color:var(--el-card-bg-color);border:1px solid var(--el-card-border-color);border-radius:var(--el-card-border-radius);color:var(--el-text-color-primary);overflow:hidden;transition:var(--el-transition-duration)}.el-card.is-always-shadow,.el-card.is-hover-shadow:focus,.el-card.is-hover-shadow:hover{box-shadow:var(--el-box-shadow-light)}.el-card__header{border-bottom:1px solid var(--el-card-border-color);box-sizing:border-box;padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding)}.el-card__body{padding:var(--el-card-padding)}.el-card__footer{border-top:1px solid var(--el-card-border-color);box-sizing:border-box;padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding)}.el-image__error,.el-image__inner,.el-image__placeholder,.el-image__wrapper{height:100%;width:100%}.el-image{display:inline-block;overflow:hidden;position:relative}.el-image__inner{opacity:1;vertical-align:top}.el-image__inner.is-loading{opacity:0}.el-image__wrapper{left:0;position:absolute;top:0}.el-image__error,.el-image__placeholder{background:var(--el-fill-color-light)}.el-image__error{align-items:center;color:var(--el-text-color-placeholder);display:flex;font-size:14px;justify-content:center;vertical-align:middle}.el-image__preview{cursor:pointer}.el-image-viewer__wrapper{bottom:0;left:0;position:fixed;right:0;top:0}.el-image-viewer__btn{align-items:center;border-radius:50%;box-sizing:border-box;cursor:pointer;display:flex;justify-content:center;opacity:.8;position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:1}.el-image-viewer__btn .el-icon{cursor:pointer;font-size:inherit}.el-image-viewer__close{font-size:40px;height:40px;right:40px;top:40px;width:40px}.el-image-viewer__canvas{align-items:center;display:flex;height:100%;justify-content:center;position:static;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%}.el-image-viewer__actions{background-color:var(--el-text-color-regular);border-color:#fff;border-radius:22px;bottom:30px;height:44px;left:50%;padding:0 23px;transform:translate(-50%);width:282px}.el-image-viewer__actions__inner{align-items:center;color:#fff;cursor:default;display:flex;font-size:23px;height:100%;justify-content:space-around;width:100%}.el-image-viewer__prev{left:40px}.el-image-viewer__next,.el-image-viewer__prev{background-color:var(--el-text-color-regular);border-color:#fff;color:#fff;font-size:24px;height:44px;top:50%;transform:translateY(-50%);width:44px}.el-image-viewer__next{right:40px;text-indent:2px}.el-image-viewer__close{background-color:var(--el-text-color-regular);border-color:#fff;color:#fff;font-size:24px;height:44px;width:44px}.el-image-viewer__mask{background:#000;height:100%;left:0;opacity:.5;position:absolute;top:0;width:100%}.viewer-fade-enter-active{animation:viewer-fade-in var(--el-transition-duration)}.viewer-fade-leave-active{animation:viewer-fade-out var(--el-transition-duration)}@keyframes viewer-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes viewer-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}.PictureItem[data-v-016ce612]{width:50%}.PictureItem .card[data-v-016ce612]{margin:3px}.PictureItem .card .card-header[data-v-016ce612],.PictureItem .card .card-footer[data-v-016ce612]{display:flex;justify-content:space-between}.PictureItem .card .header-btn[data-v-016ce612]{margin-left:10px}.PictureItem .card[data-v-016ce612]:nth-child(odd){margin-right:0}.PictureItem .card .img[data-v-016ce612]{height:100px}.collapse-item .clear-all-btn[data-v-97a3db87]{margin-left:10px}[data-v-97a3db87] .el-scrollbar__view{display:flex;flex-wrap:wrap;width:100%}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{background:var(--el-popup-modal-bg-color);height:100%;left:0;opacity:var(--el-popup-modal-opacity);position:fixed;top:0;width:100%}.el-popup-parent--hidden{overflow:hidden}.el-message-box{--el-messagebox-title-color:var(--el-text-color-primary);--el-messagebox-width:420px;--el-messagebox-border-radius:4px;--el-messagebox-box-shadow:var(--el-box-shadow);--el-messagebox-font-size:var(--el-font-size-large);--el-messagebox-content-font-size:var(--el-font-size-base);--el-messagebox-content-color:var(--el-text-color-regular);--el-messagebox-error-font-size:12px;--el-messagebox-padding-primary:12px;--el-messagebox-font-line-height:var(--el-font-line-height-primary);backface-visibility:hidden;background-color:var(--el-bg-color);border-radius:var(--el-messagebox-border-radius);box-shadow:var(--el-messagebox-box-shadow);box-sizing:border-box;display:inline-block;font-size:var(--el-messagebox-font-size);max-width:var(--el-messagebox-width);overflow:hidden;overflow-wrap:break-word;padding:var(--el-messagebox-padding-primary);position:relative;text-align:left;vertical-align:middle;width:100%}.el-message-box:focus{outline:none!important}.el-overlay.is-message-box .el-overlay-message-box{bottom:0;left:0;overflow:auto;padding:16px;position:fixed;right:0;text-align:center;top:0}.el-overlay.is-message-box .el-overlay-message-box:after{content:"";display:inline-block;height:100%;vertical-align:middle;width:0}.el-message-box.is-draggable .el-message-box__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-message-box__header{padding-bottom:var(--el-messagebox-padding-primary)}.el-message-box__header.show-close{padding-right:calc(var(--el-messagebox-padding-primary) + var(--el-message-close-size, 16px))}.el-message-box__title{color:var(--el-messagebox-title-color);font-size:var(--el-messagebox-font-size);line-height:var(--el-messagebox-font-line-height)}.el-message-box__headerbtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:40px;outline:none;padding:0;position:absolute;right:0;top:0;width:40px}.el-message-box__headerbtn .el-message-box__close{color:var(--el-color-info);font-size:inherit}.el-message-box__headerbtn:focus .el-message-box__close,.el-message-box__headerbtn:hover .el-message-box__close{color:var(--el-color-primary)}.el-message-box__content{color:var(--el-messagebox-content-color);font-size:var(--el-messagebox-content-font-size)}.el-message-box__container{align-items:center;display:flex;gap:12px}.el-message-box__input{padding-top:12px}.el-message-box__input div.invalid>input,.el-message-box__input div.invalid>input:focus{border-color:var(--el-color-error)}.el-message-box__status{font-size:24px}.el-message-box__status.el-message-box-icon--success{--el-messagebox-color:var(--el-color-success);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--info{--el-messagebox-color:var(--el-color-info);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--warning{--el-messagebox-color:var(--el-color-warning);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--error{--el-messagebox-color:var(--el-color-error);color:var(--el-messagebox-color)}.el-message-box__message{margin:0}.el-message-box__message p{line-height:var(--el-messagebox-font-line-height);margin:0}.el-message-box__errormsg{color:var(--el-color-error);font-size:var(--el-messagebox-error-font-size);line-height:var(--el-messagebox-font-line-height)}.el-message-box__btns{align-items:center;display:flex;flex-wrap:wrap;justify-content:flex-end;padding-top:var(--el-messagebox-padding-primary)}.el-message-box--center .el-message-box__title{align-items:center;display:flex;gap:6px;justify-content:center}.el-message-box--center .el-message-box__status{font-size:inherit}.el-message-box--center .el-message-box__btns,.el-message-box--center .el-message-box__container{justify-content:center}.fade-in-linear-enter-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration)}.fade-in-linear-leave-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration) reverse}@keyframes msgbox-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}.el-color-predefine{display:flex;font-size:12px;margin-top:8px;width:280px}.el-color-predefine__colors{display:flex;flex:1;flex-wrap:wrap}.el-color-predefine__color-selector{border-radius:4px;cursor:pointer;height:20px;margin:0 0 8px 8px;width:20px}.el-color-predefine__color-selector:nth-child(10n+1){margin-left:0}.el-color-predefine__color-selector.selected{box-shadow:0 0 3px 2px var(--el-color-primary)}.el-color-predefine__color-selector>div{border-radius:3px;display:flex;height:100%}.el-color-predefine__color-selector.is-alpha{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==)}.el-color-hue-slider{background-color:red;box-sizing:border-box;float:right;height:12px;padding:0 2px;position:relative;width:280px}.el-color-hue-slider__bar{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff,#00f 67%,#f0f 83%,red);height:100%;position:relative}.el-color-hue-slider__thumb{background:#fff;border:1px solid var(--el-border-color-lighter);border-radius:1px;box-shadow:0 0 2px #0009;box-sizing:border-box;cursor:pointer;height:100%;left:0;position:absolute;top:0;width:4px;z-index:1}.el-color-hue-slider__thumb:focus-visible{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-hue-slider.is-vertical{height:180px;padding:2px 0;width:12px}.el-color-hue-slider.is-vertical .el-color-hue-slider__bar{background:linear-gradient(180deg,red 0,#ff0 17%,#0f0 33%,#0ff,#00f 67%,#f0f 83%,red)}.el-color-hue-slider.is-vertical .el-color-hue-slider__thumb{height:4px;left:0;top:0;width:100%}.el-color-svpanel{height:180px;position:relative;width:280px}.el-color-svpanel__black,.el-color-svpanel__white{bottom:0;left:0;position:absolute;right:0;top:0}.el-color-svpanel__white{background:linear-gradient(90deg,#fff,#fff0)}.el-color-svpanel__black{background:linear-gradient(0deg,#000,#0000)}.el-color-svpanel__cursor{position:absolute}.el-color-svpanel__cursor>div{border-radius:50%;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px #0000004d,0 0 1px 2px #0006;cursor:head;height:4px;transform:translate(-2px,-2px);width:4px}.el-color-alpha-slider{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-position:0 0,6px 0,6px -6px,0 6px;background-size:12px 12px;box-sizing:border-box;height:12px;position:relative;width:280px}.el-color-alpha-slider__bar{background:linear-gradient(to right,rgba(255,255,255,0) 0,var(--el-bg-color) 100%);height:100%;position:relative}.el-color-alpha-slider__thumb{background:#fff;border:1px solid var(--el-border-color-lighter);border-radius:1px;box-shadow:0 0 2px #0009;box-sizing:border-box;cursor:pointer;height:100%;left:0;position:absolute;top:0;width:4px;z-index:1}.el-color-alpha-slider__thumb:focus-visible{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-alpha-slider.is-vertical{height:180px;width:20px}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__bar{background:linear-gradient(180deg,#fff0 0,#fff)}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__thumb{height:4px;left:0;top:0;width:100%}.el-color-dropdown{width:300px}.el-color-dropdown__main-wrapper{margin-bottom:6px}.el-color-dropdown__main-wrapper:after{clear:both;content:"";display:table}.el-color-dropdown__btns{margin-top:12px;text-align:right}.el-color-dropdown__value{color:#000;float:left;font-size:12px;line-height:26px;width:160px}.el-color-picker{display:inline-block;line-height:normal;outline:none;position:relative}.el-color-picker:hover:not(.is-disabled,.is-focused) .el-color-picker__trigger{border-color:var(--el-border-color-hover)}.el-color-picker:focus-visible:not(.is-disabled) .el-color-picker__trigger{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-picker.is-focused .el-color-picker__trigger{border-color:var(--el-color-primary)}.el-color-picker.is-disabled .el-color-picker__trigger{cursor:not-allowed}.el-color-picker--large{height:40px}.el-color-picker--large .el-color-picker__trigger{height:40px;width:40px}.el-color-picker--large .el-color-picker__mask{height:38px;width:38px}.el-color-picker--small{height:24px}.el-color-picker--small .el-color-picker__trigger{height:24px;width:24px}.el-color-picker--small .el-color-picker__mask{height:22px;width:22px}.el-color-picker--small .el-color-picker__empty,.el-color-picker--small .el-color-picker__icon{transform:scale(.8)}.el-color-picker__mask{background-color:#ffffffb3;border-radius:4px;cursor:not-allowed;height:30px;left:1px;position:absolute;top:1px;width:30px;z-index:1}.el-color-picker__trigger{align-items:center;border:1px solid var(--el-border-color);border-radius:4px;box-sizing:border-box;cursor:pointer;display:inline-flex;font-size:0;height:32px;justify-content:center;padding:4px;position:relative;width:32px}.el-color-picker__color{border:1px solid var(--el-text-color-secondary);border-radius:var(--el-border-radius-small);box-sizing:border-box;display:block;height:100%;position:relative;text-align:center;width:100%}.el-color-picker__color.is-alpha{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-position:0 0,6px 0,6px -6px,0 6px;background-size:12px 12px}.el-color-picker__color-inner{align-items:center;display:inline-flex;height:100%;justify-content:center;width:100%}.el-color-picker .el-color-picker__empty{color:var(--el-text-color-secondary);font-size:12px}.el-color-picker .el-color-picker__icon{align-items:center;color:#fff;display:inline-flex;font-size:12px;justify-content:center}.el-color-picker__panel{background-color:#fff;border-radius:var(--el-border-radius-base);box-shadow:var(--el-box-shadow-light);box-sizing:content-box;padding:6px;position:absolute;z-index:10}.el-color-picker__panel.el-popper{border:1px solid var(--el-border-color-lighter)}.el-color-picker,.el-color-picker__panel{--el-color-picker-alpha-bg-a:#ccc;--el-color-picker-alpha-bg-b:transparent}.dark .el-color-picker,.dark .el-color-picker__panel{--el-color-picker-alpha-bg-a:#333333}.el-row{box-sizing:border-box;display:flex;flex-wrap:wrap;position:relative}.el-row.is-justify-center{justify-content:center}.el-row.is-justify-end{justify-content:flex-end}.el-row.is-justify-space-between{justify-content:space-between}.el-row.is-justify-space-around{justify-content:space-around}.el-row.is-justify-space-evenly{justify-content:space-evenly}.el-row.is-align-top{align-items:flex-start}.el-row.is-align-middle{align-items:center}.el-row.is-align-bottom{align-items:flex-end}[class*=el-col-]{box-sizing:border-box}[class*=el-col-].is-guttered{display:block;min-height:1px}.el-col-0{flex:0 0 0%;max-width:0}.el-col-0,.el-col-0.is-guttered{display:none}.el-col-offset-0{margin-left:0}.el-col-pull-0{position:relative;right:0}.el-col-push-0{left:0;position:relative}.el-col-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-1,.el-col-1.is-guttered{display:block}.el-col-offset-1{margin-left:4.1666666667%}.el-col-pull-1{position:relative;right:4.1666666667%}.el-col-push-1{left:4.1666666667%;position:relative}.el-col-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-2,.el-col-2.is-guttered{display:block}.el-col-offset-2{margin-left:8.3333333333%}.el-col-pull-2{position:relative;right:8.3333333333%}.el-col-push-2{left:8.3333333333%;position:relative}.el-col-3{flex:0 0 12.5%;max-width:12.5%}.el-col-3,.el-col-3.is-guttered{display:block}.el-col-offset-3{margin-left:12.5%}.el-col-pull-3{position:relative;right:12.5%}.el-col-push-3{left:12.5%;position:relative}.el-col-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-4,.el-col-4.is-guttered{display:block}.el-col-offset-4{margin-left:16.6666666667%}.el-col-pull-4{position:relative;right:16.6666666667%}.el-col-push-4{left:16.6666666667%;position:relative}.el-col-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-5,.el-col-5.is-guttered{display:block}.el-col-offset-5{margin-left:20.8333333333%}.el-col-pull-5{position:relative;right:20.8333333333%}.el-col-push-5{left:20.8333333333%;position:relative}.el-col-6{flex:0 0 25%;max-width:25%}.el-col-6,.el-col-6.is-guttered{display:block}.el-col-offset-6{margin-left:25%}.el-col-pull-6{position:relative;right:25%}.el-col-push-6{left:25%;position:relative}.el-col-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-7,.el-col-7.is-guttered{display:block}.el-col-offset-7{margin-left:29.1666666667%}.el-col-pull-7{position:relative;right:29.1666666667%}.el-col-push-7{left:29.1666666667%;position:relative}.el-col-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-8,.el-col-8.is-guttered{display:block}.el-col-offset-8{margin-left:33.3333333333%}.el-col-pull-8{position:relative;right:33.3333333333%}.el-col-push-8{left:33.3333333333%;position:relative}.el-col-9{flex:0 0 37.5%;max-width:37.5%}.el-col-9,.el-col-9.is-guttered{display:block}.el-col-offset-9{margin-left:37.5%}.el-col-pull-9{position:relative;right:37.5%}.el-col-push-9{left:37.5%;position:relative}.el-col-10{flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-10,.el-col-10.is-guttered{display:block}.el-col-offset-10{margin-left:41.6666666667%}.el-col-pull-10{position:relative;right:41.6666666667%}.el-col-push-10{left:41.6666666667%;position:relative}.el-col-11{flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-11,.el-col-11.is-guttered{display:block}.el-col-offset-11{margin-left:45.8333333333%}.el-col-pull-11{position:relative;right:45.8333333333%}.el-col-push-11{left:45.8333333333%;position:relative}.el-col-12{flex:0 0 50%;max-width:50%}.el-col-12,.el-col-12.is-guttered{display:block}.el-col-offset-12{margin-left:50%}.el-col-pull-12{position:relative;right:50%}.el-col-push-12{left:50%;position:relative}.el-col-13{flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-13,.el-col-13.is-guttered{display:block}.el-col-offset-13{margin-left:54.1666666667%}.el-col-pull-13{position:relative;right:54.1666666667%}.el-col-push-13{left:54.1666666667%;position:relative}.el-col-14{flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-14,.el-col-14.is-guttered{display:block}.el-col-offset-14{margin-left:58.3333333333%}.el-col-pull-14{position:relative;right:58.3333333333%}.el-col-push-14{left:58.3333333333%;position:relative}.el-col-15{flex:0 0 62.5%;max-width:62.5%}.el-col-15,.el-col-15.is-guttered{display:block}.el-col-offset-15{margin-left:62.5%}.el-col-pull-15{position:relative;right:62.5%}.el-col-push-15{left:62.5%;position:relative}.el-col-16{flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-16,.el-col-16.is-guttered{display:block}.el-col-offset-16{margin-left:66.6666666667%}.el-col-pull-16{position:relative;right:66.6666666667%}.el-col-push-16{left:66.6666666667%;position:relative}.el-col-17{flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-17,.el-col-17.is-guttered{display:block}.el-col-offset-17{margin-left:70.8333333333%}.el-col-pull-17{position:relative;right:70.8333333333%}.el-col-push-17{left:70.8333333333%;position:relative}.el-col-18{flex:0 0 75%;max-width:75%}.el-col-18,.el-col-18.is-guttered{display:block}.el-col-offset-18{margin-left:75%}.el-col-pull-18{position:relative;right:75%}.el-col-push-18{left:75%;position:relative}.el-col-19{flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-19,.el-col-19.is-guttered{display:block}.el-col-offset-19{margin-left:79.1666666667%}.el-col-pull-19{position:relative;right:79.1666666667%}.el-col-push-19{left:79.1666666667%;position:relative}.el-col-20{flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-20,.el-col-20.is-guttered{display:block}.el-col-offset-20{margin-left:83.3333333333%}.el-col-pull-20{position:relative;right:83.3333333333%}.el-col-push-20{left:83.3333333333%;position:relative}.el-col-21{flex:0 0 87.5%;max-width:87.5%}.el-col-21,.el-col-21.is-guttered{display:block}.el-col-offset-21{margin-left:87.5%}.el-col-pull-21{position:relative;right:87.5%}.el-col-push-21{left:87.5%;position:relative}.el-col-22{flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-22,.el-col-22.is-guttered{display:block}.el-col-offset-22{margin-left:91.6666666667%}.el-col-pull-22{position:relative;right:91.6666666667%}.el-col-push-22{left:91.6666666667%;position:relative}.el-col-23{flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-23,.el-col-23.is-guttered{display:block}.el-col-offset-23{margin-left:95.8333333333%}.el-col-pull-23{position:relative;right:95.8333333333%}.el-col-push-23{left:95.8333333333%;position:relative}.el-col-24{flex:0 0 100%;max-width:100%}.el-col-24,.el-col-24.is-guttered{display:block}.el-col-offset-24{margin-left:100%}.el-col-pull-24{position:relative;right:100%}.el-col-push-24{left:100%;position:relative}@media only screen and (max-width:767px){.el-col-xs-0{display:none;flex:0 0 0%;max-width:0}.el-col-xs-0.is-guttered{display:none}.el-col-xs-offset-0{margin-left:0}.el-col-xs-pull-0{position:relative;right:0}.el-col-xs-push-0{left:0;position:relative}.el-col-xs-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xs-1,.el-col-xs-1.is-guttered{display:block}.el-col-xs-offset-1{margin-left:4.1666666667%}.el-col-xs-pull-1{position:relative;right:4.1666666667%}.el-col-xs-push-1{left:4.1666666667%;position:relative}.el-col-xs-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xs-2,.el-col-xs-2.is-guttered{display:block}.el-col-xs-offset-2{margin-left:8.3333333333%}.el-col-xs-pull-2{position:relative;right:8.3333333333%}.el-col-xs-push-2{left:8.3333333333%;position:relative}.el-col-xs-3{flex:0 0 12.5%;max-width:12.5%}.el-col-xs-3,.el-col-xs-3.is-guttered{display:block}.el-col-xs-offset-3{margin-left:12.5%}.el-col-xs-pull-3{position:relative;right:12.5%}.el-col-xs-push-3{left:12.5%;position:relative}.el-col-xs-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xs-4,.el-col-xs-4.is-guttered{display:block}.el-col-xs-offset-4{margin-left:16.6666666667%}.el-col-xs-pull-4{position:relative;right:16.6666666667%}.el-col-xs-push-4{left:16.6666666667%;position:relative}.el-col-xs-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xs-5,.el-col-xs-5.is-guttered{display:block}.el-col-xs-offset-5{margin-left:20.8333333333%}.el-col-xs-pull-5{position:relative;right:20.8333333333%}.el-col-xs-push-5{left:20.8333333333%;position:relative}.el-col-xs-6{flex:0 0 25%;max-width:25%}.el-col-xs-6,.el-col-xs-6.is-guttered{display:block}.el-col-xs-offset-6{margin-left:25%}.el-col-xs-pull-6{position:relative;right:25%}.el-col-xs-push-6{left:25%;position:relative}.el-col-xs-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xs-7,.el-col-xs-7.is-guttered{display:block}.el-col-xs-offset-7{margin-left:29.1666666667%}.el-col-xs-pull-7{position:relative;right:29.1666666667%}.el-col-xs-push-7{left:29.1666666667%;position:relative}.el-col-xs-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xs-8,.el-col-xs-8.is-guttered{display:block}.el-col-xs-offset-8{margin-left:33.3333333333%}.el-col-xs-pull-8{position:relative;right:33.3333333333%}.el-col-xs-push-8{left:33.3333333333%;position:relative}.el-col-xs-9{flex:0 0 37.5%;max-width:37.5%}.el-col-xs-9,.el-col-xs-9.is-guttered{display:block}.el-col-xs-offset-9{margin-left:37.5%}.el-col-xs-pull-9{position:relative;right:37.5%}.el-col-xs-push-9{left:37.5%;position:relative}.el-col-xs-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xs-10.is-guttered{display:block}.el-col-xs-offset-10{margin-left:41.6666666667%}.el-col-xs-pull-10{position:relative;right:41.6666666667%}.el-col-xs-push-10{left:41.6666666667%;position:relative}.el-col-xs-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xs-11.is-guttered{display:block}.el-col-xs-offset-11{margin-left:45.8333333333%}.el-col-xs-pull-11{position:relative;right:45.8333333333%}.el-col-xs-push-11{left:45.8333333333%;position:relative}.el-col-xs-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xs-12.is-guttered{display:block}.el-col-xs-offset-12{margin-left:50%}.el-col-xs-pull-12{position:relative;right:50%}.el-col-xs-push-12{left:50%;position:relative}.el-col-xs-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xs-13.is-guttered{display:block}.el-col-xs-offset-13{margin-left:54.1666666667%}.el-col-xs-pull-13{position:relative;right:54.1666666667%}.el-col-xs-push-13{left:54.1666666667%;position:relative}.el-col-xs-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xs-14.is-guttered{display:block}.el-col-xs-offset-14{margin-left:58.3333333333%}.el-col-xs-pull-14{position:relative;right:58.3333333333%}.el-col-xs-push-14{left:58.3333333333%;position:relative}.el-col-xs-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xs-15.is-guttered{display:block}.el-col-xs-offset-15{margin-left:62.5%}.el-col-xs-pull-15{position:relative;right:62.5%}.el-col-xs-push-15{left:62.5%;position:relative}.el-col-xs-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xs-16.is-guttered{display:block}.el-col-xs-offset-16{margin-left:66.6666666667%}.el-col-xs-pull-16{position:relative;right:66.6666666667%}.el-col-xs-push-16{left:66.6666666667%;position:relative}.el-col-xs-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xs-17.is-guttered{display:block}.el-col-xs-offset-17{margin-left:70.8333333333%}.el-col-xs-pull-17{position:relative;right:70.8333333333%}.el-col-xs-push-17{left:70.8333333333%;position:relative}.el-col-xs-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xs-18.is-guttered{display:block}.el-col-xs-offset-18{margin-left:75%}.el-col-xs-pull-18{position:relative;right:75%}.el-col-xs-push-18{left:75%;position:relative}.el-col-xs-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xs-19.is-guttered{display:block}.el-col-xs-offset-19{margin-left:79.1666666667%}.el-col-xs-pull-19{position:relative;right:79.1666666667%}.el-col-xs-push-19{left:79.1666666667%;position:relative}.el-col-xs-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xs-20.is-guttered{display:block}.el-col-xs-offset-20{margin-left:83.3333333333%}.el-col-xs-pull-20{position:relative;right:83.3333333333%}.el-col-xs-push-20{left:83.3333333333%;position:relative}.el-col-xs-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xs-21.is-guttered{display:block}.el-col-xs-offset-21{margin-left:87.5%}.el-col-xs-pull-21{position:relative;right:87.5%}.el-col-xs-push-21{left:87.5%;position:relative}.el-col-xs-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xs-22.is-guttered{display:block}.el-col-xs-offset-22{margin-left:91.6666666667%}.el-col-xs-pull-22{position:relative;right:91.6666666667%}.el-col-xs-push-22{left:91.6666666667%;position:relative}.el-col-xs-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xs-23.is-guttered{display:block}.el-col-xs-offset-23{margin-left:95.8333333333%}.el-col-xs-pull-23{position:relative;right:95.8333333333%}.el-col-xs-push-23{left:95.8333333333%;position:relative}.el-col-xs-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xs-24.is-guttered{display:block}.el-col-xs-offset-24{margin-left:100%}.el-col-xs-pull-24{position:relative;right:100%}.el-col-xs-push-24{left:100%;position:relative}}@media only screen and (min-width:768px){.el-col-sm-0{display:none;flex:0 0 0%;max-width:0}.el-col-sm-0.is-guttered{display:none}.el-col-sm-offset-0{margin-left:0}.el-col-sm-pull-0{position:relative;right:0}.el-col-sm-push-0{left:0;position:relative}.el-col-sm-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-sm-1,.el-col-sm-1.is-guttered{display:block}.el-col-sm-offset-1{margin-left:4.1666666667%}.el-col-sm-pull-1{position:relative;right:4.1666666667%}.el-col-sm-push-1{left:4.1666666667%;position:relative}.el-col-sm-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-sm-2,.el-col-sm-2.is-guttered{display:block}.el-col-sm-offset-2{margin-left:8.3333333333%}.el-col-sm-pull-2{position:relative;right:8.3333333333%}.el-col-sm-push-2{left:8.3333333333%;position:relative}.el-col-sm-3{flex:0 0 12.5%;max-width:12.5%}.el-col-sm-3,.el-col-sm-3.is-guttered{display:block}.el-col-sm-offset-3{margin-left:12.5%}.el-col-sm-pull-3{position:relative;right:12.5%}.el-col-sm-push-3{left:12.5%;position:relative}.el-col-sm-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-sm-4,.el-col-sm-4.is-guttered{display:block}.el-col-sm-offset-4{margin-left:16.6666666667%}.el-col-sm-pull-4{position:relative;right:16.6666666667%}.el-col-sm-push-4{left:16.6666666667%;position:relative}.el-col-sm-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-sm-5,.el-col-sm-5.is-guttered{display:block}.el-col-sm-offset-5{margin-left:20.8333333333%}.el-col-sm-pull-5{position:relative;right:20.8333333333%}.el-col-sm-push-5{left:20.8333333333%;position:relative}.el-col-sm-6{flex:0 0 25%;max-width:25%}.el-col-sm-6,.el-col-sm-6.is-guttered{display:block}.el-col-sm-offset-6{margin-left:25%}.el-col-sm-pull-6{position:relative;right:25%}.el-col-sm-push-6{left:25%;position:relative}.el-col-sm-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-sm-7,.el-col-sm-7.is-guttered{display:block}.el-col-sm-offset-7{margin-left:29.1666666667%}.el-col-sm-pull-7{position:relative;right:29.1666666667%}.el-col-sm-push-7{left:29.1666666667%;position:relative}.el-col-sm-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-sm-8,.el-col-sm-8.is-guttered{display:block}.el-col-sm-offset-8{margin-left:33.3333333333%}.el-col-sm-pull-8{position:relative;right:33.3333333333%}.el-col-sm-push-8{left:33.3333333333%;position:relative}.el-col-sm-9{flex:0 0 37.5%;max-width:37.5%}.el-col-sm-9,.el-col-sm-9.is-guttered{display:block}.el-col-sm-offset-9{margin-left:37.5%}.el-col-sm-pull-9{position:relative;right:37.5%}.el-col-sm-push-9{left:37.5%;position:relative}.el-col-sm-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-sm-10.is-guttered{display:block}.el-col-sm-offset-10{margin-left:41.6666666667%}.el-col-sm-pull-10{position:relative;right:41.6666666667%}.el-col-sm-push-10{left:41.6666666667%;position:relative}.el-col-sm-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-sm-11.is-guttered{display:block}.el-col-sm-offset-11{margin-left:45.8333333333%}.el-col-sm-pull-11{position:relative;right:45.8333333333%}.el-col-sm-push-11{left:45.8333333333%;position:relative}.el-col-sm-12{display:block;flex:0 0 50%;max-width:50%}.el-col-sm-12.is-guttered{display:block}.el-col-sm-offset-12{margin-left:50%}.el-col-sm-pull-12{position:relative;right:50%}.el-col-sm-push-12{left:50%;position:relative}.el-col-sm-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-sm-13.is-guttered{display:block}.el-col-sm-offset-13{margin-left:54.1666666667%}.el-col-sm-pull-13{position:relative;right:54.1666666667%}.el-col-sm-push-13{left:54.1666666667%;position:relative}.el-col-sm-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-sm-14.is-guttered{display:block}.el-col-sm-offset-14{margin-left:58.3333333333%}.el-col-sm-pull-14{position:relative;right:58.3333333333%}.el-col-sm-push-14{left:58.3333333333%;position:relative}.el-col-sm-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-sm-15.is-guttered{display:block}.el-col-sm-offset-15{margin-left:62.5%}.el-col-sm-pull-15{position:relative;right:62.5%}.el-col-sm-push-15{left:62.5%;position:relative}.el-col-sm-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-sm-16.is-guttered{display:block}.el-col-sm-offset-16{margin-left:66.6666666667%}.el-col-sm-pull-16{position:relative;right:66.6666666667%}.el-col-sm-push-16{left:66.6666666667%;position:relative}.el-col-sm-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-sm-17.is-guttered{display:block}.el-col-sm-offset-17{margin-left:70.8333333333%}.el-col-sm-pull-17{position:relative;right:70.8333333333%}.el-col-sm-push-17{left:70.8333333333%;position:relative}.el-col-sm-18{display:block;flex:0 0 75%;max-width:75%}.el-col-sm-18.is-guttered{display:block}.el-col-sm-offset-18{margin-left:75%}.el-col-sm-pull-18{position:relative;right:75%}.el-col-sm-push-18{left:75%;position:relative}.el-col-sm-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-sm-19.is-guttered{display:block}.el-col-sm-offset-19{margin-left:79.1666666667%}.el-col-sm-pull-19{position:relative;right:79.1666666667%}.el-col-sm-push-19{left:79.1666666667%;position:relative}.el-col-sm-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-sm-20.is-guttered{display:block}.el-col-sm-offset-20{margin-left:83.3333333333%}.el-col-sm-pull-20{position:relative;right:83.3333333333%}.el-col-sm-push-20{left:83.3333333333%;position:relative}.el-col-sm-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-sm-21.is-guttered{display:block}.el-col-sm-offset-21{margin-left:87.5%}.el-col-sm-pull-21{position:relative;right:87.5%}.el-col-sm-push-21{left:87.5%;position:relative}.el-col-sm-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-sm-22.is-guttered{display:block}.el-col-sm-offset-22{margin-left:91.6666666667%}.el-col-sm-pull-22{position:relative;right:91.6666666667%}.el-col-sm-push-22{left:91.6666666667%;position:relative}.el-col-sm-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-sm-23.is-guttered{display:block}.el-col-sm-offset-23{margin-left:95.8333333333%}.el-col-sm-pull-23{position:relative;right:95.8333333333%}.el-col-sm-push-23{left:95.8333333333%;position:relative}.el-col-sm-24{display:block;flex:0 0 100%;max-width:100%}.el-col-sm-24.is-guttered{display:block}.el-col-sm-offset-24{margin-left:100%}.el-col-sm-pull-24{position:relative;right:100%}.el-col-sm-push-24{left:100%;position:relative}}@media only screen and (min-width:992px){.el-col-md-0{display:none;flex:0 0 0%;max-width:0}.el-col-md-0.is-guttered{display:none}.el-col-md-offset-0{margin-left:0}.el-col-md-pull-0{position:relative;right:0}.el-col-md-push-0{left:0;position:relative}.el-col-md-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-md-1,.el-col-md-1.is-guttered{display:block}.el-col-md-offset-1{margin-left:4.1666666667%}.el-col-md-pull-1{position:relative;right:4.1666666667%}.el-col-md-push-1{left:4.1666666667%;position:relative}.el-col-md-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-md-2,.el-col-md-2.is-guttered{display:block}.el-col-md-offset-2{margin-left:8.3333333333%}.el-col-md-pull-2{position:relative;right:8.3333333333%}.el-col-md-push-2{left:8.3333333333%;position:relative}.el-col-md-3{flex:0 0 12.5%;max-width:12.5%}.el-col-md-3,.el-col-md-3.is-guttered{display:block}.el-col-md-offset-3{margin-left:12.5%}.el-col-md-pull-3{position:relative;right:12.5%}.el-col-md-push-3{left:12.5%;position:relative}.el-col-md-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-md-4,.el-col-md-4.is-guttered{display:block}.el-col-md-offset-4{margin-left:16.6666666667%}.el-col-md-pull-4{position:relative;right:16.6666666667%}.el-col-md-push-4{left:16.6666666667%;position:relative}.el-col-md-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-md-5,.el-col-md-5.is-guttered{display:block}.el-col-md-offset-5{margin-left:20.8333333333%}.el-col-md-pull-5{position:relative;right:20.8333333333%}.el-col-md-push-5{left:20.8333333333%;position:relative}.el-col-md-6{flex:0 0 25%;max-width:25%}.el-col-md-6,.el-col-md-6.is-guttered{display:block}.el-col-md-offset-6{margin-left:25%}.el-col-md-pull-6{position:relative;right:25%}.el-col-md-push-6{left:25%;position:relative}.el-col-md-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-md-7,.el-col-md-7.is-guttered{display:block}.el-col-md-offset-7{margin-left:29.1666666667%}.el-col-md-pull-7{position:relative;right:29.1666666667%}.el-col-md-push-7{left:29.1666666667%;position:relative}.el-col-md-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-md-8,.el-col-md-8.is-guttered{display:block}.el-col-md-offset-8{margin-left:33.3333333333%}.el-col-md-pull-8{position:relative;right:33.3333333333%}.el-col-md-push-8{left:33.3333333333%;position:relative}.el-col-md-9{flex:0 0 37.5%;max-width:37.5%}.el-col-md-9,.el-col-md-9.is-guttered{display:block}.el-col-md-offset-9{margin-left:37.5%}.el-col-md-pull-9{position:relative;right:37.5%}.el-col-md-push-9{left:37.5%;position:relative}.el-col-md-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-md-10.is-guttered{display:block}.el-col-md-offset-10{margin-left:41.6666666667%}.el-col-md-pull-10{position:relative;right:41.6666666667%}.el-col-md-push-10{left:41.6666666667%;position:relative}.el-col-md-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-md-11.is-guttered{display:block}.el-col-md-offset-11{margin-left:45.8333333333%}.el-col-md-pull-11{position:relative;right:45.8333333333%}.el-col-md-push-11{left:45.8333333333%;position:relative}.el-col-md-12{display:block;flex:0 0 50%;max-width:50%}.el-col-md-12.is-guttered{display:block}.el-col-md-offset-12{margin-left:50%}.el-col-md-pull-12{position:relative;right:50%}.el-col-md-push-12{left:50%;position:relative}.el-col-md-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-md-13.is-guttered{display:block}.el-col-md-offset-13{margin-left:54.1666666667%}.el-col-md-pull-13{position:relative;right:54.1666666667%}.el-col-md-push-13{left:54.1666666667%;position:relative}.el-col-md-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-md-14.is-guttered{display:block}.el-col-md-offset-14{margin-left:58.3333333333%}.el-col-md-pull-14{position:relative;right:58.3333333333%}.el-col-md-push-14{left:58.3333333333%;position:relative}.el-col-md-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-md-15.is-guttered{display:block}.el-col-md-offset-15{margin-left:62.5%}.el-col-md-pull-15{position:relative;right:62.5%}.el-col-md-push-15{left:62.5%;position:relative}.el-col-md-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-md-16.is-guttered{display:block}.el-col-md-offset-16{margin-left:66.6666666667%}.el-col-md-pull-16{position:relative;right:66.6666666667%}.el-col-md-push-16{left:66.6666666667%;position:relative}.el-col-md-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-md-17.is-guttered{display:block}.el-col-md-offset-17{margin-left:70.8333333333%}.el-col-md-pull-17{position:relative;right:70.8333333333%}.el-col-md-push-17{left:70.8333333333%;position:relative}.el-col-md-18{display:block;flex:0 0 75%;max-width:75%}.el-col-md-18.is-guttered{display:block}.el-col-md-offset-18{margin-left:75%}.el-col-md-pull-18{position:relative;right:75%}.el-col-md-push-18{left:75%;position:relative}.el-col-md-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-md-19.is-guttered{display:block}.el-col-md-offset-19{margin-left:79.1666666667%}.el-col-md-pull-19{position:relative;right:79.1666666667%}.el-col-md-push-19{left:79.1666666667%;position:relative}.el-col-md-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-md-20.is-guttered{display:block}.el-col-md-offset-20{margin-left:83.3333333333%}.el-col-md-pull-20{position:relative;right:83.3333333333%}.el-col-md-push-20{left:83.3333333333%;position:relative}.el-col-md-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-md-21.is-guttered{display:block}.el-col-md-offset-21{margin-left:87.5%}.el-col-md-pull-21{position:relative;right:87.5%}.el-col-md-push-21{left:87.5%;position:relative}.el-col-md-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-md-22.is-guttered{display:block}.el-col-md-offset-22{margin-left:91.6666666667%}.el-col-md-pull-22{position:relative;right:91.6666666667%}.el-col-md-push-22{left:91.6666666667%;position:relative}.el-col-md-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-md-23.is-guttered{display:block}.el-col-md-offset-23{margin-left:95.8333333333%}.el-col-md-pull-23{position:relative;right:95.8333333333%}.el-col-md-push-23{left:95.8333333333%;position:relative}.el-col-md-24{display:block;flex:0 0 100%;max-width:100%}.el-col-md-24.is-guttered{display:block}.el-col-md-offset-24{margin-left:100%}.el-col-md-pull-24{position:relative;right:100%}.el-col-md-push-24{left:100%;position:relative}}@media only screen and (min-width:1200px){.el-col-lg-0{display:none;flex:0 0 0%;max-width:0}.el-col-lg-0.is-guttered{display:none}.el-col-lg-offset-0{margin-left:0}.el-col-lg-pull-0{position:relative;right:0}.el-col-lg-push-0{left:0;position:relative}.el-col-lg-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-lg-1,.el-col-lg-1.is-guttered{display:block}.el-col-lg-offset-1{margin-left:4.1666666667%}.el-col-lg-pull-1{position:relative;right:4.1666666667%}.el-col-lg-push-1{left:4.1666666667%;position:relative}.el-col-lg-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-lg-2,.el-col-lg-2.is-guttered{display:block}.el-col-lg-offset-2{margin-left:8.3333333333%}.el-col-lg-pull-2{position:relative;right:8.3333333333%}.el-col-lg-push-2{left:8.3333333333%;position:relative}.el-col-lg-3{flex:0 0 12.5%;max-width:12.5%}.el-col-lg-3,.el-col-lg-3.is-guttered{display:block}.el-col-lg-offset-3{margin-left:12.5%}.el-col-lg-pull-3{position:relative;right:12.5%}.el-col-lg-push-3{left:12.5%;position:relative}.el-col-lg-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-lg-4,.el-col-lg-4.is-guttered{display:block}.el-col-lg-offset-4{margin-left:16.6666666667%}.el-col-lg-pull-4{position:relative;right:16.6666666667%}.el-col-lg-push-4{left:16.6666666667%;position:relative}.el-col-lg-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-lg-5,.el-col-lg-5.is-guttered{display:block}.el-col-lg-offset-5{margin-left:20.8333333333%}.el-col-lg-pull-5{position:relative;right:20.8333333333%}.el-col-lg-push-5{left:20.8333333333%;position:relative}.el-col-lg-6{flex:0 0 25%;max-width:25%}.el-col-lg-6,.el-col-lg-6.is-guttered{display:block}.el-col-lg-offset-6{margin-left:25%}.el-col-lg-pull-6{position:relative;right:25%}.el-col-lg-push-6{left:25%;position:relative}.el-col-lg-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-lg-7,.el-col-lg-7.is-guttered{display:block}.el-col-lg-offset-7{margin-left:29.1666666667%}.el-col-lg-pull-7{position:relative;right:29.1666666667%}.el-col-lg-push-7{left:29.1666666667%;position:relative}.el-col-lg-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-lg-8,.el-col-lg-8.is-guttered{display:block}.el-col-lg-offset-8{margin-left:33.3333333333%}.el-col-lg-pull-8{position:relative;right:33.3333333333%}.el-col-lg-push-8{left:33.3333333333%;position:relative}.el-col-lg-9{flex:0 0 37.5%;max-width:37.5%}.el-col-lg-9,.el-col-lg-9.is-guttered{display:block}.el-col-lg-offset-9{margin-left:37.5%}.el-col-lg-pull-9{position:relative;right:37.5%}.el-col-lg-push-9{left:37.5%;position:relative}.el-col-lg-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-lg-10.is-guttered{display:block}.el-col-lg-offset-10{margin-left:41.6666666667%}.el-col-lg-pull-10{position:relative;right:41.6666666667%}.el-col-lg-push-10{left:41.6666666667%;position:relative}.el-col-lg-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-lg-11.is-guttered{display:block}.el-col-lg-offset-11{margin-left:45.8333333333%}.el-col-lg-pull-11{position:relative;right:45.8333333333%}.el-col-lg-push-11{left:45.8333333333%;position:relative}.el-col-lg-12{display:block;flex:0 0 50%;max-width:50%}.el-col-lg-12.is-guttered{display:block}.el-col-lg-offset-12{margin-left:50%}.el-col-lg-pull-12{position:relative;right:50%}.el-col-lg-push-12{left:50%;position:relative}.el-col-lg-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-lg-13.is-guttered{display:block}.el-col-lg-offset-13{margin-left:54.1666666667%}.el-col-lg-pull-13{position:relative;right:54.1666666667%}.el-col-lg-push-13{left:54.1666666667%;position:relative}.el-col-lg-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-lg-14.is-guttered{display:block}.el-col-lg-offset-14{margin-left:58.3333333333%}.el-col-lg-pull-14{position:relative;right:58.3333333333%}.el-col-lg-push-14{left:58.3333333333%;position:relative}.el-col-lg-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-lg-15.is-guttered{display:block}.el-col-lg-offset-15{margin-left:62.5%}.el-col-lg-pull-15{position:relative;right:62.5%}.el-col-lg-push-15{left:62.5%;position:relative}.el-col-lg-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-lg-16.is-guttered{display:block}.el-col-lg-offset-16{margin-left:66.6666666667%}.el-col-lg-pull-16{position:relative;right:66.6666666667%}.el-col-lg-push-16{left:66.6666666667%;position:relative}.el-col-lg-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-lg-17.is-guttered{display:block}.el-col-lg-offset-17{margin-left:70.8333333333%}.el-col-lg-pull-17{position:relative;right:70.8333333333%}.el-col-lg-push-17{left:70.8333333333%;position:relative}.el-col-lg-18{display:block;flex:0 0 75%;max-width:75%}.el-col-lg-18.is-guttered{display:block}.el-col-lg-offset-18{margin-left:75%}.el-col-lg-pull-18{position:relative;right:75%}.el-col-lg-push-18{left:75%;position:relative}.el-col-lg-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-lg-19.is-guttered{display:block}.el-col-lg-offset-19{margin-left:79.1666666667%}.el-col-lg-pull-19{position:relative;right:79.1666666667%}.el-col-lg-push-19{left:79.1666666667%;position:relative}.el-col-lg-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-lg-20.is-guttered{display:block}.el-col-lg-offset-20{margin-left:83.3333333333%}.el-col-lg-pull-20{position:relative;right:83.3333333333%}.el-col-lg-push-20{left:83.3333333333%;position:relative}.el-col-lg-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-lg-21.is-guttered{display:block}.el-col-lg-offset-21{margin-left:87.5%}.el-col-lg-pull-21{position:relative;right:87.5%}.el-col-lg-push-21{left:87.5%;position:relative}.el-col-lg-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-lg-22.is-guttered{display:block}.el-col-lg-offset-22{margin-left:91.6666666667%}.el-col-lg-pull-22{position:relative;right:91.6666666667%}.el-col-lg-push-22{left:91.6666666667%;position:relative}.el-col-lg-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-lg-23.is-guttered{display:block}.el-col-lg-offset-23{margin-left:95.8333333333%}.el-col-lg-pull-23{position:relative;right:95.8333333333%}.el-col-lg-push-23{left:95.8333333333%;position:relative}.el-col-lg-24{display:block;flex:0 0 100%;max-width:100%}.el-col-lg-24.is-guttered{display:block}.el-col-lg-offset-24{margin-left:100%}.el-col-lg-pull-24{position:relative;right:100%}.el-col-lg-push-24{left:100%;position:relative}}@media only screen and (min-width:1920px){.el-col-xl-0{display:none;flex:0 0 0%;max-width:0}.el-col-xl-0.is-guttered{display:none}.el-col-xl-offset-0{margin-left:0}.el-col-xl-pull-0{position:relative;right:0}.el-col-xl-push-0{left:0;position:relative}.el-col-xl-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xl-1,.el-col-xl-1.is-guttered{display:block}.el-col-xl-offset-1{margin-left:4.1666666667%}.el-col-xl-pull-1{position:relative;right:4.1666666667%}.el-col-xl-push-1{left:4.1666666667%;position:relative}.el-col-xl-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xl-2,.el-col-xl-2.is-guttered{display:block}.el-col-xl-offset-2{margin-left:8.3333333333%}.el-col-xl-pull-2{position:relative;right:8.3333333333%}.el-col-xl-push-2{left:8.3333333333%;position:relative}.el-col-xl-3{flex:0 0 12.5%;max-width:12.5%}.el-col-xl-3,.el-col-xl-3.is-guttered{display:block}.el-col-xl-offset-3{margin-left:12.5%}.el-col-xl-pull-3{position:relative;right:12.5%}.el-col-xl-push-3{left:12.5%;position:relative}.el-col-xl-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xl-4,.el-col-xl-4.is-guttered{display:block}.el-col-xl-offset-4{margin-left:16.6666666667%}.el-col-xl-pull-4{position:relative;right:16.6666666667%}.el-col-xl-push-4{left:16.6666666667%;position:relative}.el-col-xl-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xl-5,.el-col-xl-5.is-guttered{display:block}.el-col-xl-offset-5{margin-left:20.8333333333%}.el-col-xl-pull-5{position:relative;right:20.8333333333%}.el-col-xl-push-5{left:20.8333333333%;position:relative}.el-col-xl-6{flex:0 0 25%;max-width:25%}.el-col-xl-6,.el-col-xl-6.is-guttered{display:block}.el-col-xl-offset-6{margin-left:25%}.el-col-xl-pull-6{position:relative;right:25%}.el-col-xl-push-6{left:25%;position:relative}.el-col-xl-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xl-7,.el-col-xl-7.is-guttered{display:block}.el-col-xl-offset-7{margin-left:29.1666666667%}.el-col-xl-pull-7{position:relative;right:29.1666666667%}.el-col-xl-push-7{left:29.1666666667%;position:relative}.el-col-xl-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xl-8,.el-col-xl-8.is-guttered{display:block}.el-col-xl-offset-8{margin-left:33.3333333333%}.el-col-xl-pull-8{position:relative;right:33.3333333333%}.el-col-xl-push-8{left:33.3333333333%;position:relative}.el-col-xl-9{flex:0 0 37.5%;max-width:37.5%}.el-col-xl-9,.el-col-xl-9.is-guttered{display:block}.el-col-xl-offset-9{margin-left:37.5%}.el-col-xl-pull-9{position:relative;right:37.5%}.el-col-xl-push-9{left:37.5%;position:relative}.el-col-xl-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xl-10.is-guttered{display:block}.el-col-xl-offset-10{margin-left:41.6666666667%}.el-col-xl-pull-10{position:relative;right:41.6666666667%}.el-col-xl-push-10{left:41.6666666667%;position:relative}.el-col-xl-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xl-11.is-guttered{display:block}.el-col-xl-offset-11{margin-left:45.8333333333%}.el-col-xl-pull-11{position:relative;right:45.8333333333%}.el-col-xl-push-11{left:45.8333333333%;position:relative}.el-col-xl-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xl-12.is-guttered{display:block}.el-col-xl-offset-12{margin-left:50%}.el-col-xl-pull-12{position:relative;right:50%}.el-col-xl-push-12{left:50%;position:relative}.el-col-xl-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xl-13.is-guttered{display:block}.el-col-xl-offset-13{margin-left:54.1666666667%}.el-col-xl-pull-13{position:relative;right:54.1666666667%}.el-col-xl-push-13{left:54.1666666667%;position:relative}.el-col-xl-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xl-14.is-guttered{display:block}.el-col-xl-offset-14{margin-left:58.3333333333%}.el-col-xl-pull-14{position:relative;right:58.3333333333%}.el-col-xl-push-14{left:58.3333333333%;position:relative}.el-col-xl-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xl-15.is-guttered{display:block}.el-col-xl-offset-15{margin-left:62.5%}.el-col-xl-pull-15{position:relative;right:62.5%}.el-col-xl-push-15{left:62.5%;position:relative}.el-col-xl-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xl-16.is-guttered{display:block}.el-col-xl-offset-16{margin-left:66.6666666667%}.el-col-xl-pull-16{position:relative;right:66.6666666667%}.el-col-xl-push-16{left:66.6666666667%;position:relative}.el-col-xl-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xl-17.is-guttered{display:block}.el-col-xl-offset-17{margin-left:70.8333333333%}.el-col-xl-pull-17{position:relative;right:70.8333333333%}.el-col-xl-push-17{left:70.8333333333%;position:relative}.el-col-xl-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xl-18.is-guttered{display:block}.el-col-xl-offset-18{margin-left:75%}.el-col-xl-pull-18{position:relative;right:75%}.el-col-xl-push-18{left:75%;position:relative}.el-col-xl-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xl-19.is-guttered{display:block}.el-col-xl-offset-19{margin-left:79.1666666667%}.el-col-xl-pull-19{position:relative;right:79.1666666667%}.el-col-xl-push-19{left:79.1666666667%;position:relative}.el-col-xl-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xl-20.is-guttered{display:block}.el-col-xl-offset-20{margin-left:83.3333333333%}.el-col-xl-pull-20{position:relative;right:83.3333333333%}.el-col-xl-push-20{left:83.3333333333%;position:relative}.el-col-xl-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xl-21.is-guttered{display:block}.el-col-xl-offset-21{margin-left:87.5%}.el-col-xl-pull-21{position:relative;right:87.5%}.el-col-xl-push-21{left:87.5%;position:relative}.el-col-xl-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xl-22.is-guttered{display:block}.el-col-xl-offset-22{margin-left:91.6666666667%}.el-col-xl-pull-22{position:relative;right:91.6666666667%}.el-col-xl-push-22{left:91.6666666667%;position:relative}.el-col-xl-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xl-23.is-guttered{display:block}.el-col-xl-offset-23{margin-left:95.8333333333%}.el-col-xl-pull-23{position:relative;right:95.8333333333%}.el-col-xl-push-23{left:95.8333333333%;position:relative}.el-col-xl-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xl-24.is-guttered{display:block}.el-col-xl-offset-24{margin-left:100%}.el-col-xl-pull-24{position:relative;right:100%}.el-col-xl-push-24{left:100%;position:relative}}.el-text{--el-text-font-size:var(--el-font-size-base);--el-text-color:var(--el-text-color-regular);align-self:center;color:var(--el-text-color);font-size:var(--el-text-font-size);margin:0;overflow-wrap:break-word;padding:0}.el-text.is-truncated{display:inline-block;max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-text.is-line-clamp{display:-webkit-inline-box;-webkit-box-orient:vertical;overflow:hidden}.el-text--large{--el-text-font-size:var(--el-font-size-medium)}.el-text--default{--el-text-font-size:var(--el-font-size-base)}.el-text--small{--el-text-font-size:var(--el-font-size-extra-small)}.el-text.el-text--primary{--el-text-color:var(--el-color-primary)}.el-text.el-text--success{--el-text-color:var(--el-color-success)}.el-text.el-text--warning{--el-text-color:var(--el-color-warning)}.el-text.el-text--danger{--el-text-color:var(--el-color-danger)}.el-text.el-text--error{--el-text-color:var(--el-color-error)}.el-text.el-text--info{--el-text-color:var(--el-color-info)}.el-text>.el-icon{vertical-align:-2px}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px;align-items:center;background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);border-radius:var(--el-tag-border-radius);border-style:solid;border-width:1px;box-sizing:border-box;color:var(--el-tag-text-color);display:inline-flex;font-size:var(--el-tag-font-size);height:24px;justify-content:center;line-height:1;padding:0 9px;vertical-align:middle;white-space:nowrap;--el-icon-size:14px}.el-tag,.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color);flex-shrink:0}.el-tag .el-tag__close:hover{background-color:var(--el-tag-hover-color);color:var(--el-color-white)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-text-color:var(--el-color-white)}.el-tag--dark,.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info,.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning{--el-tag-text-color:var(--el-color-white)}.el-tag--plain,.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{height:32px;padding:0 11px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{height:20px;padding:0 7px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{background-color:var(--el-color-primary);background-position:50%;background-repeat:no-repeat;border-right:none;border-top:none;content:"";height:12px;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;position:absolute;right:20px;top:50%;transform:translateY(-50%);width:12px}.el-select-dropdown{border-radius:var(--el-border-radius-base);box-sizing:border-box;z-index:calc(var(--el-index-top) + 1)}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__empty,.el-select-dropdown__loading{color:var(--el-text-color-secondary);font-size:var(--el-select-font-size);margin:0;padding:10px 0;text-align:center}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{box-sizing:border-box;list-style:none;margin:0;padding:6px 0}.el-select-dropdown__list.el-vl__window{margin:6px 0;padding:0}.el-select-dropdown__header{border-bottom:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__footer{border-top:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__item{box-sizing:border-box;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-base);height:34px;line-height:34px;overflow:hidden;padding:0 32px 0 20px;position:relative;text-overflow:ellipsis;white-space:nowrap}.el-select-dropdown__item.is-hovering{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.is-selected{color:var(--el-color-primary);font-weight:700}.el-select-dropdown__item.is-disabled{background-color:unset;color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{background-color:var(--el-color-primary);background-position:50%;background-repeat:no-repeat;border-right:none;border-top:none;content:"";height:12px;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;position:absolute;right:20px;top:50%;transform:translateY(-50%);width:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-disabled:after{background-color:var(--el-text-color-placeholder)}.el-select-group{margin:0;padding:0}.el-select-group__wrap{list-style:none;margin:0;padding:0;position:relative}.el-select-group__title{color:var(--el-color-info);font-size:12px;line-height:34px;padding-left:20px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-color:var(--el-disabled-text-color);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px;--el-select-width:100%;display:inline-block;position:relative;vertical-align:middle;width:var(--el-select-width)}.el-select__wrapper{align-items:center;background-color:var(--el-fill-color-blank);border-radius:var(--el-border-radius-base);box-shadow:0 0 0 1px var(--el-border-color) inset;box-sizing:border-box;cursor:pointer;display:flex;font-size:14px;gap:6px;line-height:24px;min-height:32px;padding:4px 12px;position:relative;text-align:left;transform:translateZ(0);transition:var(--el-transition-duration)}.el-select__wrapper.is-filterable{cursor:text}.el-select__wrapper.is-focused{box-shadow:0 0 0 1px var(--el-color-primary) inset}.el-select__wrapper.is-hovering:not(.is-focused){box-shadow:0 0 0 1px var(--el-border-color-hover) inset}.el-select__wrapper.is-disabled{background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select__wrapper.is-disabled,.el-select__wrapper.is-disabled:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-select__wrapper.is-disabled .el-select__selected-item{color:var(--el-select-disabled-color)}.el-select__wrapper.is-disabled .el-select__caret,.el-select__wrapper.is-disabled .el-tag{cursor:not-allowed}.el-select__prefix,.el-select__suffix{align-items:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:flex;flex-shrink:0;gap:6px}.el-select__caret{color:var(--el-select-input-color);cursor:pointer;font-size:var(--el-select-input-font-size);transform:rotate(0);transition:var(--el-transition-duration)}.el-select__caret.is-reverse{transform:rotate(180deg)}.el-select__selection{align-items:center;display:flex;flex:1;flex-wrap:wrap;gap:6px;min-width:0;position:relative}.el-select__selection.is-near{margin-left:-8px}.el-select__selection .el-tag{border-color:transparent;cursor:pointer}.el-select__selection .el-tag.el-tag--plain{border-color:var(--el-tag-border-color)}.el-select__selection .el-tag .el-tag__content{min-width:0}.el-select__selected-item{display:flex;flex-wrap:wrap;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-select__tags-text{line-height:normal}.el-select__placeholder,.el-select__tags-text{display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select__placeholder{color:var(--el-input-text-color,var(--el-text-color-regular));position:absolute;top:50%;transform:translateY(-50%);width:100%}.el-select__placeholder.is-transparent{color:var(--el-text-color-placeholder);-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper,.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select__input-wrapper{max-width:100%}.el-select__input-wrapper.is-hidden{opacity:0;position:absolute}.el-select__input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-select-multiple-input-color);font-family:inherit;font-size:inherit;height:24px;max-width:100%;outline:none;padding:0}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input-calculator{left:0;max-width:100%;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:pre}.el-select--large .el-select__wrapper{font-size:14px;gap:6px;line-height:24px;min-height:40px;padding:8px 16px}.el-select--large .el-select__selection{gap:6px}.el-select--large .el-select__selection.is-near{margin-left:-8px}.el-select--large .el-select__prefix,.el-select--large .el-select__suffix{gap:6px}.el-select--large .el-select__input{height:24px}.el-select--small .el-select__wrapper{font-size:12px;gap:4px;line-height:20px;min-height:24px;padding:2px 8px}.el-select--small .el-select__selection{gap:4px}.el-select--small .el-select__selection.is-near{margin-left:-6px}.el-select--small .el-select__prefix,.el-select--small .el-select__suffix{gap:4px}.el-select--small .el-select__input{height:20px}.setting-row .setting-container[data-v-e82e761f]{display:flex;justify-content:space-between;align-items:center}.setting-row .setting-container .input-label[data-v-e82e761f]{margin-right:10px}.setting-row .setting-container .default-btn[data-v-e82e761f]{margin-left:10px}.setting-row .setting-container[data-v-c8dfbdc0]{display:flex;justify-content:space-between;align-items:center}.setting-row .setting-container .input-label[data-v-c8dfbdc0]{margin-right:10px}.setting-row .setting-container .default-btn[data-v-c8dfbdc0]{margin-left:10px}.el-row[data-v-a1302a8c]{margin-bottom:20px}.el-row[data-v-a1302a8c]:last-child{margin-bottom:0}.bili-config .wide-row[data-v-a1302a8c]{margin-right:calc(var(--el-dialog-padding-primary) * -2)}.bili-config .setting-row .setting-container[data-v-a1302a8c]{display:flex;justify-content:space-between;align-items:center}.bili-config .setting-row .setting-container .input-label[data-v-a1302a8c]{margin-right:10px}.bili-config .setting-row .setting-container .default-btn[data-v-a1302a8c]{margin-left:10px}[data-v-a1302a8c] .is-vertical,[data-v-a1302a8c] .is-horizontal{display:none!important}.contact-support a,.contact-support strong,.contact-support h1,.contact-support h2,.contact-support h3,.contact-support h4,.contact-support h5,.contact-support h6{color:var(--el-color-primary)!important}.pane[data-v-4d55d0ef]{cursor:default}.tabs-item[data-v-631d72d1]{margin-top:calc(var(--el-dialog-padding-primary) * -2 + 8px)}[data-v-631d72d1] .el-tabs__nav-wrap:after{background-color:transparent}.upload-dialog[data-v-15497014]{--el-overlay-color-lighter: rgba(0, 0, 0, .2);--el-message-close-size: 20px}[data-v-15497014] .el-dialog__headerbtn{z-index:300}[data-v-15497014] .el-dialog__headerbtn:after{content:"";display:block;position:absolute;top:0;left:0;width:100%;height:100%;transform:scale(1.5)}:root{--scroll-duration: .5s;--scroll-timing-function: ease;--search-bar-top-gap: 35vh;--search-bar-width: 40vw;--search-bar-x-offset: 0px;--wallpaper-pos-x: center;--wallpaper-pos-y: center;--wallpaper-size: cover;--wallpaper-bg-color: whitesmoke}.adblock-tips{display:none!important}.el-message-box .el-button.el-button--primary{background-color:#409eff}.monkey-hidden{display:none!important}body{overflow-x:hidden}/*!* \u6E38\u620F\u4E2D\u5FC3 *!*//*!* \u4F1A\u5458\u8D2D *!*//*!* \u79D1\u5B66\u665A *!*//*!* \u4E0A\u4F20\u6309\u94AE: \u4E3A\u4E86\u8BA9\u6574\u4F53\u66F4\u52A0\u7F8E\u89C2 *!*/.adcard{display:none!important}.center-search-container{width:var(--search-bar-width);position:absolute;top:var(--search-bar-top-gap);left:calc(50vw + var(--search-bar-x-offset));translate:-50% 0;transition:opacity var(--scroll-duration) var(--scroll-timing-function)}.bili-header__banner,.bili-header__channel,.bili-feed4-layout{transition:translate var(--scroll-duration) var(--scroll-timing-function);translate:0 100vh}.header-channel{transition:translate .2s var(--scroll-timing-function) var(--scroll-duration);translate:0 100vh!important}#header-channel-show{translate:0 0!important} `);

(function (vue) {
  'use strict';

  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var require_main_001 = __commonJS({
    "main-BXVrhvDp.js"(exports, module) {
      var isVue2 = false;
      function set(target, key, val) {
        if (Array.isArray(target)) {
          target.length = Math.max(target.length, key);
          target.splice(key, 1, val);
          return val;
        }
        target[key] = val;
        return val;
      }
      function del(target, key) {
        if (Array.isArray(target)) {
          target.splice(key, 1);
          return;
        }
        delete target[key];
      }
      function getDevtoolsGlobalHook() {
        return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
      }
      function getTarget() {
        return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
      }
      const isProxyAvailable = typeof Proxy === "function";
      const HOOK_SETUP = "devtools-plugin:setup";
      const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
      let supported;
      let perf;
      function isPerformanceSupported() {
        var _a2;
        if (supported !== void 0) {
          return supported;
        }
        if (typeof window !== "undefined" && window.performance) {
          supported = true;
          perf = window.performance;
        } else if (typeof globalThis !== "undefined" && ((_a2 = globalThis.perf_hooks) === null || _a2 === void 0 ? void 0 : _a2.performance)) {
          supported = true;
          perf = globalThis.perf_hooks.performance;
        } else {
          supported = false;
        }
        return supported;
      }
      function now$2() {
        return isPerformanceSupported() ? perf.now() : Date.now();
      }
      class ApiProxy {
        constructor(plugin, hook) {
          this.target = null;
          this.targetQueue = [];
          this.onQueue = [];
          this.plugin = plugin;
          this.hook = hook;
          const defaultSettings = {};
          if (plugin.settings) {
            for (const id in plugin.settings) {
              const item = plugin.settings[id];
              defaultSettings[id] = item.defaultValue;
            }
          }
          const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
          let currentSettings = Object.assign({}, defaultSettings);
          try {
            const raw = localStorage.getItem(localSettingsSaveId);
            const data = JSON.parse(raw);
            Object.assign(currentSettings, data);
          } catch (e) {
          }
          this.fallbacks = {
            getSettings() {
              return currentSettings;
            },
            setSettings(value) {
              try {
                localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
              } catch (e) {
              }
              currentSettings = value;
            },
            now() {
              return now$2();
            }
          };
          if (hook) {
            hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
              if (pluginId === this.plugin.id) {
                this.fallbacks.setSettings(value);
              }
            });
          }
          this.proxiedOn = new Proxy({}, {
            get: (_target, prop) => {
              if (this.target) {
                return this.target.on[prop];
              } else {
                return (...args) => {
                  this.onQueue.push({
                    method: prop,
                    args
                  });
                };
              }
            }
          });
          this.proxiedTarget = new Proxy({}, {
            get: (_target, prop) => {
              if (this.target) {
                return this.target[prop];
              } else if (prop === "on") {
                return this.proxiedOn;
              } else if (Object.keys(this.fallbacks).includes(prop)) {
                return (...args) => {
                  this.targetQueue.push({
                    method: prop,
                    args,
                    resolve: () => {
                    }
                  });
                  return this.fallbacks[prop](...args);
                };
              } else {
                return (...args) => {
                  return new Promise((resolve) => {
                    this.targetQueue.push({
                      method: prop,
                      args,
                      resolve
                    });
                  });
                };
              }
            }
          });
        }
        async setRealTarget(target) {
          this.target = target;
          for (const item of this.onQueue) {
            this.target.on[item.method](...item.args);
          }
          for (const item of this.targetQueue) {
            item.resolve(await this.target[item.method](...item.args));
          }
        }
      }
      function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
        const descriptor = pluginDescriptor;
        const target = getTarget();
        const hook = getDevtoolsGlobalHook();
        const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
        if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
          hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
        } else {
          const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
          const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
          list.push({
            pluginDescriptor: descriptor,
            setupFn,
            proxy
          });
          if (proxy) {
            setupFn(proxy.proxiedTarget);
          }
        }
      }
      /*!
       * pinia v2.2.5
       * (c) 2024 Eduardo San Martin Morote
       * @license MIT
       */
      let activePinia;
      const setActivePinia = (pinia2) => activePinia = pinia2;
      const piniaSymbol = Symbol("pinia");
      function isPlainObject$1(o) {
        return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
      }
      var MutationType;
      (function(MutationType2) {
        MutationType2["direct"] = "direct";
        MutationType2["patchObject"] = "patch object";
        MutationType2["patchFunction"] = "patch function";
      })(MutationType || (MutationType = {}));
      const IS_CLIENT = typeof window !== "undefined";
      const _global$1 = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
      function bom(blob, { autoBom = false } = {}) {
        if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
          return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
        }
        return blob;
      }
      function download(url, name, opts) {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url);
        xhr.responseType = "blob";
        xhr.onload = function() {
          saveAs(xhr.response, name, opts);
        };
        xhr.onerror = function() {
          console.error("could not download file");
        };
        xhr.send();
      }
      function corsEnabled(url) {
        const xhr = new XMLHttpRequest();
        xhr.open("HEAD", url, false);
        try {
          xhr.send();
        } catch (e) {
        }
        return xhr.status >= 200 && xhr.status <= 299;
      }
      function click(node) {
        try {
          node.dispatchEvent(new MouseEvent("click"));
        } catch (e) {
          const evt = document.createEvent("MouseEvents");
          evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
          node.dispatchEvent(evt);
        }
      }
      const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
      const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
      const saveAs = !IS_CLIENT ? () => {
      } : (
        // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
        typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (
          // Use msSaveOrOpenBlob as a second approach
          "msSaveOrOpenBlob" in _navigator ? msSaveAs : (
            // Fallback to using FileReader and a popup
            fileSaverSaveAs
          )
        )
      );
      function downloadSaveAs(blob, name = "download", opts) {
        const a = document.createElement("a");
        a.download = name;
        a.rel = "noopener";
        if (typeof blob === "string") {
          a.href = blob;
          if (a.origin !== location.origin) {
            if (corsEnabled(a.href)) {
              download(blob, name, opts);
            } else {
              a.target = "_blank";
              click(a);
            }
          } else {
            click(a);
          }
        } else {
          a.href = URL.createObjectURL(blob);
          setTimeout(function() {
            URL.revokeObjectURL(a.href);
          }, 4e4);
          setTimeout(function() {
            click(a);
          }, 0);
        }
      }
      function msSaveAs(blob, name = "download", opts) {
        if (typeof blob === "string") {
          if (corsEnabled(blob)) {
            download(blob, name, opts);
          } else {
            const a = document.createElement("a");
            a.href = blob;
            a.target = "_blank";
            setTimeout(function() {
              click(a);
            });
          }
        } else {
          navigator.msSaveOrOpenBlob(bom(blob, opts), name);
        }
      }
      function fileSaverSaveAs(blob, name, opts, popup) {
        popup = popup || open("", "_blank");
        if (popup) {
          popup.document.title = popup.document.body.innerText = "downloading...";
        }
        if (typeof blob === "string")
          return download(blob, name, opts);
        const force = blob.type === "application/octet-stream";
        const isSafari = /constructor/i.test(String(_global$1.HTMLElement)) || "safari" in _global$1;
        const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== "undefined") {
          const reader = new FileReader();
          reader.onloadend = function() {
            let url = reader.result;
            if (typeof url !== "string") {
              popup = null;
              throw new Error("Wrong reader.result type");
            }
            url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
            if (popup) {
              popup.location.href = url;
            } else {
              location.assign(url);
            }
            popup = null;
          };
          reader.readAsDataURL(blob);
        } else {
          const url = URL.createObjectURL(blob);
          if (popup)
            popup.location.assign(url);
          else
            location.href = url;
          popup = null;
          setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 4e4);
        }
      }
      function toastMessage(message, type) {
        const piniaMessage = "🍍 " + message;
        if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
          __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
        } else if (type === "error") {
          console.error(piniaMessage);
        } else if (type === "warn") {
          console.warn(piniaMessage);
        } else {
          console.log(piniaMessage);
        }
      }
      function isPinia(o) {
        return "_a" in o && "install" in o;
      }
      function checkClipboardAccess() {
        if (!("clipboard" in navigator)) {
          toastMessage(`Your browser doesn't support the Clipboard API`, "error");
          return true;
        }
      }
      function checkNotFocusedError(error) {
        if (error instanceof Error && error.message.toLowerCase().includes("document is not focused")) {
          toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
          return true;
        }
        return false;
      }
      async function actionGlobalCopyState(pinia2) {
        if (checkClipboardAccess())
          return;
        try {
          await navigator.clipboard.writeText(JSON.stringify(pinia2.state.value));
          toastMessage("Global state copied to clipboard.");
        } catch (error) {
          if (checkNotFocusedError(error))
            return;
          toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
          console.error(error);
        }
      }
      async function actionGlobalPasteState(pinia2) {
        if (checkClipboardAccess())
          return;
        try {
          loadStoresState(pinia2, JSON.parse(await navigator.clipboard.readText()));
          toastMessage("Global state pasted from clipboard.");
        } catch (error) {
          if (checkNotFocusedError(error))
            return;
          toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
          console.error(error);
        }
      }
      async function actionGlobalSaveState(pinia2) {
        try {
          saveAs(new Blob([JSON.stringify(pinia2.state.value)], {
            type: "text/plain;charset=utf-8"
          }), "pinia-state.json");
        } catch (error) {
          toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
          console.error(error);
        }
      }
      let fileInput;
      function getFileOpener() {
        if (!fileInput) {
          fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.accept = ".json";
        }
        function openFile() {
          return new Promise((resolve, reject2) => {
            fileInput.onchange = async () => {
              const files = fileInput.files;
              if (!files)
                return resolve(null);
              const file = files.item(0);
              if (!file)
                return resolve(null);
              return resolve({ text: await file.text(), file });
            };
            fileInput.oncancel = () => resolve(null);
            fileInput.onerror = reject2;
            fileInput.click();
          });
        }
        return openFile;
      }
      async function actionGlobalOpenStateFile(pinia2) {
        try {
          const open2 = getFileOpener();
          const result2 = await open2();
          if (!result2)
            return;
          const { text, file } = result2;
          loadStoresState(pinia2, JSON.parse(text));
          toastMessage(`Global state imported from "${file.name}".`);
        } catch (error) {
          toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
          console.error(error);
        }
      }
      function loadStoresState(pinia2, state) {
        for (const key in state) {
          const storeState = pinia2.state.value[key];
          if (storeState) {
            Object.assign(storeState, state[key]);
          } else {
            pinia2.state.value[key] = state[key];
          }
        }
      }
      function formatDisplay(display) {
        return {
          _custom: {
            display
          }
        };
      }
      const PINIA_ROOT_LABEL = "🍍 Pinia (root)";
      const PINIA_ROOT_ID = "_root";
      function formatStoreForInspectorTree(store) {
        return isPinia(store) ? {
          id: PINIA_ROOT_ID,
          label: PINIA_ROOT_LABEL
        } : {
          id: store.$id,
          label: store.$id
        };
      }
      function formatStoreForInspectorState(store) {
        if (isPinia(store)) {
          const storeNames = Array.from(store._s.keys());
          const storeMap = store._s;
          const state2 = {
            state: storeNames.map((storeId) => ({
              editable: true,
              key: storeId,
              value: store.state.value[storeId]
            })),
            getters: storeNames.filter((id) => storeMap.get(id)._getters).map((id) => {
              const store2 = storeMap.get(id);
              return {
                editable: false,
                key: id,
                value: store2._getters.reduce((getters, key) => {
                  getters[key] = store2[key];
                  return getters;
                }, {})
              };
            })
          };
          return state2;
        }
        const state = {
          state: Object.keys(store.$state).map((key) => ({
            editable: true,
            key,
            value: store.$state[key]
          }))
        };
        if (store._getters && store._getters.length) {
          state.getters = store._getters.map((getterName) => ({
            editable: false,
            key: getterName,
            value: store[getterName]
          }));
        }
        if (store._customProperties.size) {
          state.customProperties = Array.from(store._customProperties).map((key) => ({
            editable: true,
            key,
            value: store[key]
          }));
        }
        return state;
      }
      function formatEventData(events) {
        if (!events)
          return {};
        if (Array.isArray(events)) {
          return events.reduce((data, event) => {
            data.keys.push(event.key);
            data.operations.push(event.type);
            data.oldValue[event.key] = event.oldValue;
            data.newValue[event.key] = event.newValue;
            return data;
          }, {
            oldValue: {},
            keys: [],
            operations: [],
            newValue: {}
          });
        } else {
          return {
            operation: formatDisplay(events.type),
            key: formatDisplay(events.key),
            oldValue: events.oldValue,
            newValue: events.newValue
          };
        }
      }
      function formatMutationType(type) {
        switch (type) {
          case MutationType.direct:
            return "mutation";
          case MutationType.patchFunction:
            return "$patch";
          case MutationType.patchObject:
            return "$patch";
          default:
            return "unknown";
        }
      }
      let isTimelineActive = true;
      const componentStateTypes = [];
      const MUTATIONS_LAYER_ID = "pinia:mutations";
      const INSPECTOR_ID = "pinia";
      const { assign: assign$1 } = Object;
      const getStoreType = (id) => "🍍 " + id;
      function registerPiniaDevtools(app2, pinia2) {
        setupDevtoolsPlugin({
          id: "dev.esm.pinia",
          label: "Pinia 🍍",
          logo: "https://pinia.vuejs.org/logo.svg",
          packageName: "pinia",
          homepage: "https://pinia.vuejs.org",
          componentStateTypes,
          app: app2
        }, (api) => {
          if (typeof api.now !== "function") {
            toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
          }
          api.addTimelineLayer({
            id: MUTATIONS_LAYER_ID,
            label: `Pinia 🍍`,
            color: 15064968
          });
          api.addInspector({
            id: INSPECTOR_ID,
            label: "Pinia 🍍",
            icon: "storage",
            treeFilterPlaceholder: "Search stores",
            actions: [
              {
                icon: "content_copy",
                action: () => {
                  actionGlobalCopyState(pinia2);
                },
                tooltip: "Serialize and copy the state"
              },
              {
                icon: "content_paste",
                action: async () => {
                  await actionGlobalPasteState(pinia2);
                  api.sendInspectorTree(INSPECTOR_ID);
                  api.sendInspectorState(INSPECTOR_ID);
                },
                tooltip: "Replace the state with the content of your clipboard"
              },
              {
                icon: "save",
                action: () => {
                  actionGlobalSaveState(pinia2);
                },
                tooltip: "Save the state as a JSON file"
              },
              {
                icon: "folder_open",
                action: async () => {
                  await actionGlobalOpenStateFile(pinia2);
                  api.sendInspectorTree(INSPECTOR_ID);
                  api.sendInspectorState(INSPECTOR_ID);
                },
                tooltip: "Import the state from a JSON file"
              }
            ],
            nodeActions: [
              {
                icon: "restore",
                tooltip: 'Reset the state (with "$reset")',
                action: (nodeId) => {
                  const store = pinia2._s.get(nodeId);
                  if (!store) {
                    toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
                  } else if (typeof store.$reset !== "function") {
                    toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
                  } else {
                    store.$reset();
                    toastMessage(`Store "${nodeId}" reset.`);
                  }
                }
              }
            ]
          });
          api.on.inspectComponent((payload, ctx) => {
            const proxy = payload.componentInstance && payload.componentInstance.proxy;
            if (proxy && proxy._pStores) {
              const piniaStores = payload.componentInstance.proxy._pStores;
              Object.values(piniaStores).forEach((store) => {
                payload.instanceData.state.push({
                  type: getStoreType(store.$id),
                  key: "state",
                  editable: true,
                  value: store._isOptionsAPI ? {
                    _custom: {
                      value: vue.toRaw(store.$state),
                      actions: [
                        {
                          icon: "restore",
                          tooltip: "Reset the state of this store",
                          action: () => store.$reset()
                        }
                      ]
                    }
                  } : (
                    // NOTE: workaround to unwrap transferred refs
                    Object.keys(store.$state).reduce((state, key) => {
                      state[key] = store.$state[key];
                      return state;
                    }, {})
                  )
                });
                if (store._getters && store._getters.length) {
                  payload.instanceData.state.push({
                    type: getStoreType(store.$id),
                    key: "getters",
                    editable: false,
                    value: store._getters.reduce((getters, key) => {
                      try {
                        getters[key] = store[key];
                      } catch (error) {
                        getters[key] = error;
                      }
                      return getters;
                    }, {})
                  });
                }
              });
            }
          });
          api.on.getInspectorTree((payload) => {
            if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
              let stores = [pinia2];
              stores = stores.concat(Array.from(pinia2._s.values()));
              payload.rootNodes = (payload.filter ? stores.filter((store) => "$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
            }
          });
          globalThis.$pinia = pinia2;
          api.on.getInspectorState((payload) => {
            if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
              const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
              if (!inspectedStore) {
                return;
              }
              if (inspectedStore) {
                if (payload.nodeId !== PINIA_ROOT_ID)
                  globalThis.$store = vue.toRaw(inspectedStore);
                payload.state = formatStoreForInspectorState(inspectedStore);
              }
            }
          });
          api.on.editInspectorState((payload, ctx) => {
            if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
              const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
              if (!inspectedStore) {
                return toastMessage(`store "${payload.nodeId}" not found`, "error");
              }
              const { path } = payload;
              if (!isPinia(inspectedStore)) {
                if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {
                  path.unshift("$state");
                }
              } else {
                path.unshift("state");
              }
              isTimelineActive = false;
              payload.set(inspectedStore, path, payload.state.value);
              isTimelineActive = true;
            }
          });
          api.on.editComponentState((payload) => {
            if (payload.type.startsWith("🍍")) {
              const storeId = payload.type.replace(/^🍍\s*/, "");
              const store = pinia2._s.get(storeId);
              if (!store) {
                return toastMessage(`store "${storeId}" not found`, "error");
              }
              const { path } = payload;
              if (path[0] !== "state") {
                return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
              }
              path[0] = "$state";
              isTimelineActive = false;
              payload.set(store, path, payload.state.value);
              isTimelineActive = true;
            }
          });
        });
      }
      function addStoreToDevtools(app2, store) {
        if (!componentStateTypes.includes(getStoreType(store.$id))) {
          componentStateTypes.push(getStoreType(store.$id));
        }
        setupDevtoolsPlugin({
          id: "dev.esm.pinia",
          label: "Pinia 🍍",
          logo: "https://pinia.vuejs.org/logo.svg",
          packageName: "pinia",
          homepage: "https://pinia.vuejs.org",
          componentStateTypes,
          app: app2,
          settings: {
            logStoreChanges: {
              label: "Notify about new/deleted stores",
              type: "boolean",
              defaultValue: true
            }
            // useEmojis: {
            //   label: 'Use emojis in messages ⚡️',
            //   type: 'boolean',
            //   defaultValue: true,
            // },
          }
        }, (api) => {
          const now2 = typeof api.now === "function" ? api.now.bind(api) : Date.now;
          store.$onAction(({ after: after2, onError, name, args }) => {
            const groupId = runningActionId++;
            api.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: now2(),
                title: "🛫 " + name,
                subtitle: "start",
                data: {
                  store: formatDisplay(store.$id),
                  action: formatDisplay(name),
                  args
                },
                groupId
              }
            });
            after2((result2) => {
              activeAction = void 0;
              api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                  time: now2(),
                  title: "🛬 " + name,
                  subtitle: "end",
                  data: {
                    store: formatDisplay(store.$id),
                    action: formatDisplay(name),
                    args,
                    result: result2
                  },
                  groupId
                }
              });
            });
            onError((error) => {
              activeAction = void 0;
              api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                  time: now2(),
                  logType: "error",
                  title: "💥 " + name,
                  subtitle: "end",
                  data: {
                    store: formatDisplay(store.$id),
                    action: formatDisplay(name),
                    args,
                    error
                  },
                  groupId
                }
              });
            });
          }, true);
          store._customProperties.forEach((name) => {
            vue.watch(() => vue.unref(store[name]), (newValue, oldValue) => {
              api.notifyComponentUpdate();
              api.sendInspectorState(INSPECTOR_ID);
              if (isTimelineActive) {
                api.addTimelineEvent({
                  layerId: MUTATIONS_LAYER_ID,
                  event: {
                    time: now2(),
                    title: "Change",
                    subtitle: name,
                    data: {
                      newValue,
                      oldValue
                    },
                    groupId: activeAction
                  }
                });
              }
            }, { deep: true });
          });
          store.$subscribe(({ events, type }, state) => {
            api.notifyComponentUpdate();
            api.sendInspectorState(INSPECTOR_ID);
            if (!isTimelineActive)
              return;
            const eventData = {
              time: now2(),
              title: formatMutationType(type),
              data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),
              groupId: activeAction
            };
            if (type === MutationType.patchFunction) {
              eventData.subtitle = "⤵️";
            } else if (type === MutationType.patchObject) {
              eventData.subtitle = "🧩";
            } else if (events && !Array.isArray(events)) {
              eventData.subtitle = events.type;
            }
            if (events) {
              eventData.data["rawEvent(s)"] = {
                _custom: {
                  display: "DebuggerEvent",
                  type: "object",
                  tooltip: "raw DebuggerEvent[]",
                  value: events
                }
              };
            }
            api.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: eventData
            });
          }, { detached: true, flush: "sync" });
          const hotUpdate = store._hotUpdate;
          store._hotUpdate = vue.markRaw((newStore) => {
            hotUpdate(newStore);
            api.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: now2(),
                title: "🔥 " + store.$id,
                subtitle: "HMR update",
                data: {
                  store: formatDisplay(store.$id),
                  info: formatDisplay(`HMR update`)
                }
              }
            });
            api.notifyComponentUpdate();
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
          });
          const { $dispose } = store;
          store.$dispose = () => {
            $dispose();
            api.notifyComponentUpdate();
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
            api.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store 🗑`);
          };
          api.notifyComponentUpdate();
          api.sendInspectorTree(INSPECTOR_ID);
          api.sendInspectorState(INSPECTOR_ID);
          api.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed 🆕`);
        });
      }
      let runningActionId = 0;
      let activeAction;
      function patchActionForGrouping(store, actionNames, wrapWithProxy) {
        const actions = actionNames.reduce((storeActions, actionName) => {
          storeActions[actionName] = vue.toRaw(store)[actionName];
          return storeActions;
        }, {});
        for (const actionName in actions) {
          store[actionName] = function() {
            const _actionId = runningActionId;
            const trackedStore = wrapWithProxy ? new Proxy(store, {
              get(...args) {
                activeAction = _actionId;
                return Reflect.get(...args);
              },
              set(...args) {
                activeAction = _actionId;
                return Reflect.set(...args);
              }
            }) : store;
            activeAction = _actionId;
            const retValue = actions[actionName].apply(trackedStore, arguments);
            activeAction = void 0;
            return retValue;
          };
        }
      }
      function devtoolsPlugin({ app: app2, store, options }) {
        if (store.$id.startsWith("__hot:")) {
          return;
        }
        store._isOptionsAPI = !!options.state;
        if (!store._p._testing) {
          patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);
          const originalHotUpdate = store._hotUpdate;
          vue.toRaw(store)._hotUpdate = function(newStore) {
            originalHotUpdate.apply(this, arguments);
            patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
          };
        }
        addStoreToDevtools(
          app2,
          // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
          store
        );
      }
      function createPinia() {
        const scope = vue.effectScope(true);
        const state = scope.run(() => vue.ref({}));
        let _p = [];
        let toBeInstalled = [];
        const pinia2 = vue.markRaw({
          install(app2) {
            setActivePinia(pinia2);
            {
              pinia2._a = app2;
              app2.provide(piniaSymbol, pinia2);
              app2.config.globalProperties.$pinia = pinia2;
              if (IS_CLIENT) {
                registerPiniaDevtools(app2, pinia2);
              }
              toBeInstalled.forEach((plugin) => _p.push(plugin));
              toBeInstalled = [];
            }
          },
          use(plugin) {
            if (!this._a && !isVue2) {
              toBeInstalled.push(plugin);
            } else {
              _p.push(plugin);
            }
            return this;
          },
          _p,
          // it's actually undefined here
          // @ts-expect-error
          _a: null,
          _e: scope,
          _s: /* @__PURE__ */ new Map(),
          state
        });
        if (typeof Proxy !== "undefined") {
          pinia2.use(devtoolsPlugin);
        }
        return pinia2;
      }
      function patchObject(newState, oldState) {
        for (const key in oldState) {
          const subPatch = oldState[key];
          if (!(key in newState)) {
            continue;
          }
          const targetValue = newState[key];
          if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
            newState[key] = patchObject(targetValue, subPatch);
          } else {
            {
              newState[key] = subPatch;
            }
          }
        }
        return newState;
      }
      const noop$3 = () => {
      };
      function addSubscription(subscriptions, callback, detached, onCleanup = noop$3) {
        subscriptions.push(callback);
        const removeSubscription = () => {
          const idx = subscriptions.indexOf(callback);
          if (idx > -1) {
            subscriptions.splice(idx, 1);
            onCleanup();
          }
        };
        if (!detached && vue.getCurrentScope()) {
          vue.onScopeDispose(removeSubscription);
        }
        return removeSubscription;
      }
      function triggerSubscriptions(subscriptions, ...args) {
        subscriptions.slice().forEach((callback) => {
          callback(...args);
        });
      }
      const fallbackRunWithContext = (fn2) => fn2();
      const ACTION_MARKER = Symbol();
      const ACTION_NAME = Symbol();
      function mergeReactiveObjects(target, patchToApply) {
        if (target instanceof Map && patchToApply instanceof Map) {
          patchToApply.forEach((value, key) => target.set(key, value));
        } else if (target instanceof Set && patchToApply instanceof Set) {
          patchToApply.forEach(target.add, target);
        }
        for (const key in patchToApply) {
          if (!patchToApply.hasOwnProperty(key))
            continue;
          const subPatch = patchToApply[key];
          const targetValue = target[key];
          if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
            target[key] = mergeReactiveObjects(targetValue, subPatch);
          } else {
            target[key] = subPatch;
          }
        }
        return target;
      }
      const skipHydrateSymbol = Symbol("pinia:skipHydration");
      function shouldHydrate(obj) {
        return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
      }
      const { assign } = Object;
      function isComputed(o) {
        return !!(vue.isRef(o) && o.effect);
      }
      function createOptionsStore(id, options, pinia2, hot) {
        const { state, actions, getters } = options;
        const initialState = pinia2.state.value[id];
        let store;
        function setup() {
          if (!initialState && !hot) {
            {
              pinia2.state.value[id] = state ? state() : {};
            }
          }
          const localState = hot ? (
            // use ref() to unwrap refs inside state TODO: check if this is still necessary
            vue.toRefs(vue.ref(state ? state() : {}).value)
          ) : vue.toRefs(pinia2.state.value[id]);
          return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
            if (name in localState) {
              console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id}".`);
            }
            computedGetters[name] = vue.markRaw(vue.computed(() => {
              setActivePinia(pinia2);
              const store2 = pinia2._s.get(id);
              return getters[name].call(store2, store2);
            }));
            return computedGetters;
          }, {}));
        }
        store = createSetupStore(id, setup, options, pinia2, hot, true);
        return store;
      }
      function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
        let scope;
        const optionsForPlugin = assign({ actions: {} }, options);
        if (!pinia2._e.active) {
          throw new Error("Pinia destroyed");
        }
        const $subscribeOptions = { deep: true };
        {
          $subscribeOptions.onTrigger = (event) => {
            if (isListening) {
              debuggerEvents = event;
            } else if (isListening == false && !store._hotUpdating) {
              if (Array.isArray(debuggerEvents)) {
                debuggerEvents.push(event);
              } else {
                console.error("🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.");
              }
            }
          };
        }
        let isListening;
        let isSyncListening;
        let subscriptions = [];
        let actionSubscriptions = [];
        let debuggerEvents;
        const initialState = pinia2.state.value[$id];
        if (!isOptionsStore && !initialState && !hot) {
          {
            pinia2.state.value[$id] = {};
          }
        }
        const hotState = vue.ref({});
        let activeListener;
        function $patch(partialStateOrMutator) {
          let subscriptionMutation;
          isListening = isSyncListening = false;
          {
            debuggerEvents = [];
          }
          if (typeof partialStateOrMutator === "function") {
            partialStateOrMutator(pinia2.state.value[$id]);
            subscriptionMutation = {
              type: MutationType.patchFunction,
              storeId: $id,
              events: debuggerEvents
            };
          } else {
            mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
              type: MutationType.patchObject,
              payload: partialStateOrMutator,
              storeId: $id,
              events: debuggerEvents
            };
          }
          const myListenerId = activeListener = Symbol();
          vue.nextTick().then(() => {
            if (activeListener === myListenerId) {
              isListening = true;
            }
          });
          isSyncListening = true;
          triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
        }
        const $reset = isOptionsStore ? function $reset2() {
          const { state } = options;
          const newState = state ? state() : {};
          this.$patch(($state) => {
            assign($state, newState);
          });
        } : (
          /* istanbul ignore next */
          () => {
            throw new Error(`🍍: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
          }
        );
        function $dispose() {
          scope.stop();
          subscriptions = [];
          actionSubscriptions = [];
          pinia2._s.delete($id);
        }
        const action = (fn2, name = "") => {
          if (ACTION_MARKER in fn2) {
            fn2[ACTION_NAME] = name;
            return fn2;
          }
          const wrappedAction = function() {
            setActivePinia(pinia2);
            const args = Array.from(arguments);
            const afterCallbackList = [];
            const onErrorCallbackList = [];
            function after2(callback) {
              afterCallbackList.push(callback);
            }
            function onError(callback) {
              onErrorCallbackList.push(callback);
            }
            triggerSubscriptions(actionSubscriptions, {
              args,
              name: wrappedAction[ACTION_NAME],
              store,
              after: after2,
              onError
            });
            let ret;
            try {
              ret = fn2.apply(this && this.$id === $id ? this : store, args);
            } catch (error) {
              triggerSubscriptions(onErrorCallbackList, error);
              throw error;
            }
            if (ret instanceof Promise) {
              return ret.then((value) => {
                triggerSubscriptions(afterCallbackList, value);
                return value;
              }).catch((error) => {
                triggerSubscriptions(onErrorCallbackList, error);
                return Promise.reject(error);
              });
            }
            triggerSubscriptions(afterCallbackList, ret);
            return ret;
          };
          wrappedAction[ACTION_MARKER] = true;
          wrappedAction[ACTION_NAME] = name;
          return wrappedAction;
        };
        const _hmrPayload = /* @__PURE__ */ vue.markRaw({
          actions: {},
          getters: {},
          state: [],
          hotState
        });
        const partialStore = {
          _p: pinia2,
          // _s: scope,
          $id,
          $onAction: addSubscription.bind(null, actionSubscriptions),
          $patch,
          $reset,
          $subscribe(callback, options2 = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
            const stopWatcher = scope.run(() => vue.watch(() => pinia2.state.value[$id], (state) => {
              if (options2.flush === "sync" ? isSyncListening : isListening) {
                callback({
                  storeId: $id,
                  type: MutationType.direct,
                  events: debuggerEvents
                }, state);
              }
            }, assign({}, $subscribeOptions, options2)));
            return removeSubscription;
          },
          $dispose
        };
        const store = vue.reactive(assign(
          {
            _hmrPayload,
            _customProperties: vue.markRaw(/* @__PURE__ */ new Set())
            // devtools custom properties
          },
          partialStore
          // must be added later
          // setupStore
        ));
        pinia2._s.set($id, store);
        const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
        const setupStore = runWithContext(() => pinia2._e.run(() => (scope = vue.effectScope()).run(() => setup({ action }))));
        for (const key in setupStore) {
          const prop = setupStore[key];
          if (vue.isRef(prop) && !isComputed(prop) || vue.isReactive(prop)) {
            if (hot) {
              set(hotState.value, key, vue.toRef(setupStore, key));
            } else if (!isOptionsStore) {
              if (initialState && shouldHydrate(prop)) {
                if (vue.isRef(prop)) {
                  prop.value = initialState[key];
                } else {
                  mergeReactiveObjects(prop, initialState[key]);
                }
              }
              {
                pinia2.state.value[$id][key] = prop;
              }
            }
            {
              _hmrPayload.state.push(key);
            }
          } else if (typeof prop === "function") {
            const actionValue = hot ? prop : action(prop, key);
            {
              setupStore[key] = actionValue;
            }
            {
              _hmrPayload.actions[key] = prop;
            }
            optionsForPlugin.actions[key] = prop;
          } else {
            if (isComputed(prop)) {
              _hmrPayload.getters[key] = isOptionsStore ? (
                // @ts-expect-error
                options.getters[key]
              ) : prop;
              if (IS_CLIENT) {
                const getters = setupStore._getters || // @ts-expect-error: same
                (setupStore._getters = vue.markRaw([]));
                getters.push(key);
              }
            }
          }
        }
        {
          assign(store, setupStore);
          assign(vue.toRaw(store), setupStore);
        }
        Object.defineProperty(store, "$state", {
          get: () => hot ? hotState.value : pinia2.state.value[$id],
          set: (state) => {
            if (hot) {
              throw new Error("cannot set hotState");
            }
            $patch(($state) => {
              assign($state, state);
            });
          }
        });
        {
          store._hotUpdate = vue.markRaw((newStore) => {
            store._hotUpdating = true;
            newStore._hmrPayload.state.forEach((stateKey) => {
              if (stateKey in store.$state) {
                const newStateTarget = newStore.$state[stateKey];
                const oldStateSource = store.$state[stateKey];
                if (typeof newStateTarget === "object" && isPlainObject$1(newStateTarget) && isPlainObject$1(oldStateSource)) {
                  patchObject(newStateTarget, oldStateSource);
                } else {
                  newStore.$state[stateKey] = oldStateSource;
                }
              }
              set(store, stateKey, vue.toRef(newStore.$state, stateKey));
            });
            Object.keys(store.$state).forEach((stateKey) => {
              if (!(stateKey in newStore.$state)) {
                del(store, stateKey);
              }
            });
            isListening = false;
            isSyncListening = false;
            pinia2.state.value[$id] = vue.toRef(newStore._hmrPayload, "hotState");
            isSyncListening = true;
            vue.nextTick().then(() => {
              isListening = true;
            });
            for (const actionName in newStore._hmrPayload.actions) {
              const actionFn = newStore[actionName];
              set(store, actionName, action(actionFn, actionName));
            }
            for (const getterName in newStore._hmrPayload.getters) {
              const getter = newStore._hmrPayload.getters[getterName];
              const getterValue = isOptionsStore ? (
                // special handling of options api
                vue.computed(() => {
                  setActivePinia(pinia2);
                  return getter.call(store, store);
                })
              ) : getter;
              set(store, getterName, getterValue);
            }
            Object.keys(store._hmrPayload.getters).forEach((key) => {
              if (!(key in newStore._hmrPayload.getters)) {
                del(store, key);
              }
            });
            Object.keys(store._hmrPayload.actions).forEach((key) => {
              if (!(key in newStore._hmrPayload.actions)) {
                del(store, key);
              }
            });
            store._hmrPayload = newStore._hmrPayload;
            store._getters = newStore._getters;
            store._hotUpdating = false;
          });
        }
        if (IS_CLIENT) {
          const nonEnumerable = {
            writable: true,
            configurable: true,
            // avoid warning on devtools trying to display this property
            enumerable: false
          };
          ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p) => {
            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));
          });
        }
        pinia2._p.forEach((extender) => {
          if (IS_CLIENT) {
            const extensions = scope.run(() => extender({
              store,
              app: pinia2._a,
              pinia: pinia2,
              options: optionsForPlugin
            }));
            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
            assign(store, extensions);
          } else {
            assign(store, scope.run(() => extender({
              store,
              app: pinia2._a,
              pinia: pinia2,
              options: optionsForPlugin
            })));
          }
        });
        if (store.$state && typeof store.$state === "object" && typeof store.$state.constructor === "function" && !store.$state.constructor.toString().includes("[native code]")) {
          console.warn(`[🍍]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
        }
        if (initialState && isOptionsStore && options.hydrate) {
          options.hydrate(store.$state, initialState);
        }
        isListening = true;
        isSyncListening = true;
        return store;
      }
      /*! #__NO_SIDE_EFFECTS__ */
      // @__NO_SIDE_EFFECTS__
      function defineStore(idOrOptions, setup, setupOptions) {
        let id;
        let options;
        const isSetupStore = typeof setup === "function";
        if (typeof idOrOptions === "string") {
          id = idOrOptions;
          options = isSetupStore ? setupOptions : setup;
        } else {
          options = idOrOptions;
          id = idOrOptions.id;
          if (typeof id !== "string") {
            throw new Error(`[🍍]: "defineStore()" must be passed a store id as its first argument.`);
          }
        }
        function useStore(pinia2, hot) {
          const hasContext = vue.hasInjectionContext();
          pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
          // pinia instance with getActivePinia()
          pinia2 || (hasContext ? vue.inject(piniaSymbol, null) : null);
          if (pinia2)
            setActivePinia(pinia2);
          if (!activePinia) {
            throw new Error(`[🍍]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
          }
          pinia2 = activePinia;
          if (!pinia2._s.has(id)) {
            if (isSetupStore) {
              createSetupStore(id, setup, options, pinia2);
            } else {
              createOptionsStore(id, options, pinia2);
            }
            {
              useStore._pinia = pinia2;
            }
          }
          const store = pinia2._s.get(id);
          if (hot) {
            const hotId = "__hot:" + id;
            const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia2, true) : createOptionsStore(hotId, assign({}, options), pinia2, true);
            hot._hotUpdate(newStore);
            delete pinia2.state.value[hotId];
            pinia2._s.delete(hotId);
          }
          if (IS_CLIENT) {
            const currentInstance = vue.getCurrentInstance();
            if (currentInstance && currentInstance.proxy && // avoid adding stores that are just built for hot module replacement
            !hot) {
              const vm = currentInstance.proxy;
              const cache = "_pStores" in vm ? vm._pStores : vm._pStores = {};
              cache[id] = store;
            }
          }
          return store;
        }
        useStore.$id = id;
        return useStore;
      }
      function storeToRefs(store) {
        {
          const rawStore = vue.toRaw(store);
          const refs = {};
          for (const key in rawStore) {
            const value = rawStore[key];
            if (vue.isRef(value) || vue.isReactive(value)) {
              refs[key] = // ---
              vue.toRef(store, key);
            }
          }
          return refs;
        }
      }
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_registerMenuCommand = /* @__PURE__ */ (() => typeof GM_registerMenuCommand != "undefined" ? GM_registerMenuCommand : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      function getErrEl() {
        let errEl2 = document.body.errEl;
        if (errEl2 === void 0) {
          errEl2 = document.createElement("div");
          errEl2.classList.add("no-found");
          errEl2.remove = () => {
          };
          document.body.errEl = errEl2;
        }
        return errEl2;
      }
      const errEl = getErrEl();
      function $Q(selector) {
        let ele = document.querySelector(selector);
        if (ele == null) {
          return errEl;
        } else {
          return ele;
        }
      }
      const SEARCH_BAR_TOP_GAP = 35;
      const SEARCH_BAR_WIDTH = 60;
      const SEARCH_BAR_X_OFFSET = 0;
      const SCROLL_DURATION = 0.5;
      let timeHandle = null;
      function testTimeout() {
        if (timeHandle !== null) {
          clearTimeout(timeHandle);
          timeHandle = null;
        }
      }
      function mySetTimout(handle, timeout) {
        testTimeout();
        timeHandle = setTimeout(handle, timeout);
      }
      async function applyOriginalShowState(isShow) {
        if (isShow) {
          $Q(".bili-header__banner").style.translate = "0 0";
          $Q(".bili-header__channel").style.translate = "0 0";
          $Q(".bili-feed4-layout").style.translate = "0 0";
          $Q(".center-search-container").style.opacity = "0";
          mySetTimout(() => {
            $Q(".center-search-container").style.position = "static";
            $Q(".center-search-container").style.translate = "0 0";
            $Q(".center-search-container").style.opacity = "1";
          }, SCROLL_DURATION * 1e3);
          $Q(".header-channel").id = "header-channel-show";
        } else {
          $Q(".bili-header__banner").style.translate = "";
          $Q(".bili-header__channel").style.translate = "";
          $Q(".bili-feed4-layout").style.translate = "";
          $Q(".center-search-container").style.opacity = "0";
          mySetTimout(() => {
            $Q(".center-search-container").style.translate = "";
            $Q(".center-search-container").style.position = "";
            $Q(".center-search-container").style.opacity = "1";
          }, SCROLL_DURATION * 1e3);
          $Q(".header-channel").id = "";
        }
      }
      function useConfig(key, defaultValue) {
        const isObjOrArr = typeof defaultValue === "object" || Array.isArray(defaultValue);
        let storeValue = _GM_getValue(key, defaultValue);
        if (isObjOrArr) {
          if (storeValue !== defaultValue) {
            storeValue = JSON.parse(storeValue);
          }
          if (storeValue === null) {
            storeValue = defaultValue;
          }
        }
        const config = vue.ref(storeValue);
        vue.watch(config, () => {
          if (isObjOrArr) {
            let jsonString = JSON.stringify(config.value);
            _GM_setValue(key, jsonString);
          } else {
            _GM_setValue(key, config.value);
          }
        }, { deep: true });
        return config;
      }
      function useCssVar(varName, defaultValue) {
        let cssVar = useConfig(varName, defaultValue);
        vue.watch(cssVar, () => {
          document.documentElement.style.setProperty(varName, cssVar.value);
        }, { immediate: true });
        return cssVar;
      }
      function useCssVarFormat(varName, defaultValue, format) {
        const cssVar = useCssVar(varName, defaultValue);
        let initValue = parseInt(cssVar.value);
        if (Object.is(initValue, NaN)) {
          initValue = cssVar.value;
        }
        const cssVarFormat = vue.ref(initValue);
        vue.watch(cssVarFormat, () => {
          if (typeof cssVarFormat.value === "number") {
            cssVar.value = cssVarFormat.value + format;
          } else if (cssVarFormat.value === null) {
            cssVar.value = 0;
          } else if (typeof cssVarFormat.value === "string") {
            cssVar.value = cssVarFormat.value;
          }
        });
        return cssVarFormat;
      }
      class Query {
        /**
         *
         * @param timeout
         *  timeout 为-1时 无限查询并等待
         *  If timeout is -1, query indefinitely and wait
         * @param onError
         *  回调函数, 在查找不到时执行
         *  callback function, it will be called when the query fails
         * @param isBlocking
         *  在查询失败时, 是否保持Promise为pending状态, 默认为false
         *  whether to keep the Promise in pending state when a query fails. The default is false
         * @param sleepTime
         *  查询的间隔
         */
        constructor(timeout = 1e4, onError = null, isBlocking = false, sleepTime = 100) {
          let errEl2 = document.body.errEl;
          if (errEl2 === void 0) {
            errEl2 = document.createElement("div");
            errEl2.classList.add("no-found");
            errEl2.remove = () => {
            };
            document.body.errEl = errEl2;
          }
          this.errEl = errEl2;
          this.timeout = timeout;
          this.onError = onError;
          this.isBlocking = isBlocking;
          this.sleepTime = sleepTime;
        }
        /**
         *
         * @param selector
         *  选择器, 和querySelector的参数一致
         *  selector, same to the param of querySelector
         * @param baseEl
         * @returns {Promise<unknown>}
         */
        async queryAsync(selector, baseEl = document) {
          const startTime = Date.now();
          while (true) {
            const ele = baseEl.querySelector(selector);
            if (ele !== null) {
              return ele;
            }
            if (this.timeout !== -1 && Date.now() - startTime > this.timeout) {
              console.warn(`$Q_Async: Timeout: Cannot find element for selector "${selector}"`);
              if (this.onError !== null) {
                this.onError();
              }
              if (!this.isBlocking) {
                return this.errEl;
              }
              return new Promise(() => {
              });
            }
            await this.sleep();
          }
        }
        sleep() {
          return new Promise((resolve) => setTimeout(resolve, this.sleepTime));
        }
      }
      const query = new Query();
      function queryAsync(selector, baseEl) {
        return query.queryAsync(selector, baseEl);
      }
      function useSearchBar(inputSelector) {
        const isShowPlaceHolder = useConfig("isClearPlaceholder", false);
        const isAutoFocus = useConfig("isAutoFocus", false);
        queryAsync(inputSelector).then((inputEl) => {
          let timerId = setInterval(() => {
            let placeholder = inputEl.placeholder;
            if (placeholder === "") {
              return;
            } else {
              clearInterval(timerId);
            }
            vue.watch(isShowPlaceHolder, () => {
              if (isShowPlaceHolder.value) {
                inputEl.placeholder = placeholder;
              } else {
                inputEl.placeholder = "";
              }
            }, { immediate: true });
            if (isAutoFocus.value) {
              inputEl.focus();
            }
          }, 200);
        }).catch((err) => console.error(err));
        return { isShowPlaceHolder, isAutoFocus };
      }
      function useStyleElement(key, defaultValue, cssContent) {
        const isApplied = useConfig(key, defaultValue);
        const style = document.createElement("style");
        style.innerHTML = cssContent;
        vue.watch(isApplied, () => {
          if (isApplied.value) {
            document.head.appendChild(style);
          } else {
            if (style.parentNode === document.head) {
              document.head.removeChild(style);
            }
          }
        }, { immediate: true });
        return isApplied;
      }
      function useStyle(key, defaultValue, selector, styleKey, value) {
        const config = useConfig(key, defaultValue);
        queryAsync(selector).then((ele) => {
          vue.watch(config, () => {
            if (config.value) {
              ele.style[styleKey] = value;
            } else {
              ele.style[styleKey] = "";
            }
          }, { immediate: true });
        }).catch((msg) => {
          console.error(msg);
        });
        return config;
      }
      function useDisplayNone(key, defaultValue, selector) {
        return useStyle(key, defaultValue, selector, "display", "none");
      }
      function useBooleanReverse(target) {
        const proxy = vue.ref(!target.value);
        vue.watch(proxy, () => {
          target.value = !proxy.value;
        });
        return proxy;
      }
      const useBiliStore = /* @__PURE__ */ defineStore("bilibili", () => {
        const isShowOriginal = vue.ref(false);
        vue.watch(isShowOriginal, () => {
          applyOriginalShowState(isShowOriginal.value);
        });
        function useHiddenState(key, defaultValue, selector) {
          return useBooleanReverse(useDisplayNone(key, defaultValue, selector));
        }
        let { isShowPlaceHolder, isAutoFocus } = useSearchBar(".nav-search-content > input");
        const displayConfigObj = vue.ref({
          "下载客户端": useHiddenState("display-status-download", true, ".left-entry li:nth-last-child(1)"),
          "会员购": useHiddenState("display-status-huiyuangou", false, "div.bili-header__bar > ul.left-entry > li:nth-child(5)"),
          "游戏中心": useHiddenState("display-status-game-center", false, " div.bili-header__bar > ul.left-entry > li:nth-child(4)"),
          "上传按钮": useHiddenState("display-status-upload-video", true, ".right-entry-item--upload"),
          "隐藏热搜": useStyleElement(
            "hot-search-recommend",
            true,
            `
      .search-panel .trending {
        display: none !important;
      }
    `
          ),
          "动图菜单项": useBooleanReverse(useStyleElement("display-status-gif", true, `
      .left-entry li:nth-last-child(2) {
        display: none !important;
       }
    `)),
          "热门搜索词": isShowPlaceHolder,
          "自动聚焦": isAutoFocus
        });
        const displayConfigCount = vue.computed(() => {
          return Object.values(displayConfigObj.value).length;
        });
        const displayConfigDescs = vue.computed(() => {
          return Object.keys(displayConfigObj.value);
        });
        const searchBarTopGap = useCssVarFormat("--search-bar-top-gap", SEARCH_BAR_TOP_GAP + "vh", "vh");
        const searchBarWidth = useCssVarFormat("--search-bar-width", SEARCH_BAR_WIDTH + "vw", "vw");
        const searchBarXOffset = useCssVarFormat("--search-bar-x-offset", SEARCH_BAR_X_OFFSET + "vw", "vw");
        const wallpaperPosX = useCssVarFormat("--wallpaper-pos-x", "center", "px");
        const wallpaperPosY = useCssVarFormat("--wallpaper-pos-y", "center", "px");
        const wallpaperSize = useCssVarFormat("--wallpaper-size", "cover", "%");
        const wallpaperBgColor = useCssVar("--wallpaper-bg-color", "#fff");
        return {
          isShowOriginal,
          displayConfigObj,
          displayConfigCount,
          displayConfigDescs,
          searchBarXOffset,
          // displayConfigs,
          // scrollDuration,
          searchBarTopGap,
          searchBarWidth,
          wallpaperPosX,
          wallpaperPosY,
          wallpaperSize,
          wallpaperBgColor
        };
      });
      const wallpaperBase64 = {
        "蓝山": "data:image/jpg;base64,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"
      };
      const useMainStore = /* @__PURE__ */ defineStore("main", () => {
        const extendWallpaperBase64Obj = useConfig("extendWallpaperBase64Obj", {});
        const wallpaperBase64Obj = vue.computed(() => ({
          ...wallpaperBase64,
          ...extendWallpaperBase64Obj.value
        }));
        const currWallpaperName = useConfig("currWallpaperName", "蓝山");
        function deleteWallpaper(name) {
          if (currWallpaperName.value == name) {
            currWallpaperName.value = "蓝山";
          }
          delete extendWallpaperBase64Obj.value[name];
        }
        function renameWallpaper(oldName, newName) {
          let wallpaperBase642 = extendWallpaperBase64Obj.value[oldName];
          extendWallpaperBase64Obj.value[newName] = wallpaperBase642;
          if (currWallpaperName.value == oldName) {
            currWallpaperName.value = newName;
          }
          delete extendWallpaperBase64Obj.value[oldName];
        }
        function applyWallpaper(name) {
          if (!(name in wallpaperBase64Obj.value)) {
            return false;
          }
          currWallpaperName.value = name;
          return true;
        }
        function appendWallpaper(name, base64) {
          extendWallpaperBase64Obj.value[name] = base64;
        }
        function emptyWallpaper() {
          extendWallpaperBase64Obj.value = {};
          currWallpaperName.value = "蓝山";
        }
        if (!(currWallpaperName.value in wallpaperBase64Obj.value)) {
          currWallpaperName.value = "蓝山";
        }
        const isShowDialog2 = useConfig("isShowDialog", false);
        const tabsCurrSel = useConfig("tabs-item-currSel", "0");
        const collapseCurrSel = useConfig("wallpaper-config-currSel", "1");
        const currWallpaperBase64Url = vue.computed(() => {
          return `url(${wallpaperBase64Obj.value[currWallpaperName.value]})`;
        });
        return {
          deleteWallpaper,
          renameWallpaper,
          applyWallpaper,
          appendWallpaper,
          emptyWallpaper,
          currWallpaperName,
          extendWallpaperBase64Obj,
          wallpaperBase64Obj,
          isShowDialog: isShowDialog2,
          tabsCurrSel,
          collapseCurrSel,
          currWallpaperBase64Url
        };
      });
      function tryOnScopeDispose$1(fn2) {
        if (vue.getCurrentScope()) {
          vue.onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function toValue(r) {
        return typeof r === "function" ? r() : vue.unref(r);
      }
      const isClient$1 = typeof window !== "undefined" && typeof document !== "undefined";
      typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
      const toString$2 = Object.prototype.toString;
      const isObject$3 = (val) => toString$2.call(val) === "[object Object]";
      const noop$2 = () => {
      };
      function createFilterWrapper$1(filter2, fn2) {
        function wrapper(...args) {
          return new Promise((resolve, reject2) => {
            Promise.resolve(filter2(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve).catch(reject2);
          });
        }
        return wrapper;
      }
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop$2;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop$2;
        };
        const filter2 = (invoke2) => {
          const duration = toValue(ms);
          const maxDuration = toValue(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke2());
          }
          return new Promise((resolve, reject2) => {
            lastRejector = options.rejectOnCancel ? reject2 : resolve;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve(invoke2());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve(invoke2());
            }, duration);
          });
        };
        return filter2;
      }
      function throttleFilter$1(...args) {
        let lastExec = 0;
        let timer;
        let isLeading = true;
        let lastRejector = noop$2;
        let lastValue;
        let ms;
        let trailing;
        let leading;
        let rejectOnCancel;
        if (!vue.isRef(args[0]) && typeof args[0] === "object")
          ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);
        else
          [ms, trailing = true, leading = true, rejectOnCancel = false] = args;
        const clear = () => {
          if (timer) {
            clearTimeout(timer);
            timer = void 0;
            lastRejector();
            lastRejector = noop$2;
          }
        };
        const filter2 = (_invoke) => {
          const duration = toValue(ms);
          const elapsed = Date.now() - lastExec;
          const invoke2 = () => {
            return lastValue = _invoke();
          };
          clear();
          if (duration <= 0) {
            lastExec = Date.now();
            return invoke2();
          }
          if (elapsed > duration && (leading || !isLeading)) {
            lastExec = Date.now();
            invoke2();
          } else if (trailing) {
            lastValue = new Promise((resolve, reject2) => {
              lastRejector = rejectOnCancel ? reject2 : resolve;
              timer = setTimeout(() => {
                lastExec = Date.now();
                isLeading = true;
                resolve(invoke2());
                clear();
              }, Math.max(0, duration - elapsed));
            });
          }
          if (!leading && !timer)
            timer = setTimeout(() => isLeading = true, duration);
          isLeading = false;
          return lastValue;
        };
        return filter2;
      }
      function getLifeCycleTarget(target) {
        return vue.getCurrentInstance();
      }
      function useDebounceFn(fn2, ms = 200, options = {}) {
        return createFilterWrapper$1(
          debounceFilter(ms, options),
          fn2
        );
      }
      function useThrottleFn$1(fn2, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
        return createFilterWrapper$1(
          throttleFilter$1(ms, trailing, leading, rejectOnCancel),
          fn2
        );
      }
      function tryOnMounted$1(fn2, sync = true, target) {
        const instance = getLifeCycleTarget();
        if (instance)
          vue.onMounted(fn2, target);
        else if (sync)
          fn2();
        else
          vue.nextTick(fn2);
      }
      const defaultWindow$1 = isClient$1 ? window : void 0;
      function unrefElement$1(elRef) {
        var _a2;
        const plain = toValue(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      function useEventListener$1(...args) {
        let target;
        let events2;
        let listeners;
        let options;
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
          [events2, listeners, options] = args;
          target = defaultWindow$1;
        } else {
          [target, events2, listeners, options] = args;
        }
        if (!target)
          return noop$2;
        if (!Array.isArray(events2))
          events2 = [events2];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = vue.watch(
          () => [unrefElement$1(target), toValue(options)],
          ([el, options2]) => {
            cleanup();
            if (!el)
              return;
            const optionsClone = isObject$3(options2) ? { ...options2 } : options2;
            cleanups.push(
              ...events2.flatMap((event) => {
                return listeners.map((listener) => register(el, event, listener, optionsClone));
              })
            );
          },
          { immediate: true, flush: "post" }
        );
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose$1(stop);
        return stop;
      }
      const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
      function useScroll(element, options = {}) {
        const {
          throttle: throttle2 = 0,
          idle = 200,
          onStop = noop$2,
          onScroll = noop$2,
          offset = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          },
          eventListenerOptions = {
            capture: false,
            passive: true
          },
          behavior = "auto",
          window: window2 = defaultWindow$1,
          onError = (e) => {
            console.error(e);
          }
        } = options;
        const internalX = vue.ref(0);
        const internalY = vue.ref(0);
        const x = vue.computed({
          get() {
            return internalX.value;
          },
          set(x2) {
            scrollTo2(x2, void 0);
          }
        });
        const y = vue.computed({
          get() {
            return internalY.value;
          },
          set(y2) {
            scrollTo2(void 0, y2);
          }
        });
        function scrollTo2(_x, _y) {
          var _a2, _b, _c, _d;
          if (!window2)
            return;
          const _element = toValue(element);
          if (!_element)
            return;
          (_c = _element instanceof Document ? window2.document.body : _element) == null ? void 0 : _c.scrollTo({
            top: (_a2 = toValue(_y)) != null ? _a2 : y.value,
            left: (_b = toValue(_x)) != null ? _b : x.value,
            behavior: toValue(behavior)
          });
          const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;
          if (x != null)
            internalX.value = scrollContainer.scrollLeft;
          if (y != null)
            internalY.value = scrollContainer.scrollTop;
        }
        const isScrolling = vue.ref(false);
        const arrivedState = vue.reactive({
          left: true,
          right: false,
          top: true,
          bottom: false
        });
        const directions = vue.reactive({
          left: false,
          right: false,
          top: false,
          bottom: false
        });
        const onScrollEnd = (e) => {
          if (!isScrolling.value)
            return;
          isScrolling.value = false;
          directions.left = false;
          directions.right = false;
          directions.top = false;
          directions.bottom = false;
          onStop(e);
        };
        const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle2 + idle);
        const setArrivedState = (target) => {
          var _a2;
          if (!window2)
            return;
          const el = ((_a2 = target == null ? void 0 : target.document) == null ? void 0 : _a2.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement$1(target);
          const { display, flexDirection } = getComputedStyle(el);
          const scrollLeft = el.scrollLeft;
          directions.left = scrollLeft < internalX.value;
          directions.right = scrollLeft > internalX.value;
          const left = Math.abs(scrollLeft) <= (offset.left || 0);
          const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
          if (display === "flex" && flexDirection === "row-reverse") {
            arrivedState.left = right;
            arrivedState.right = left;
          } else {
            arrivedState.left = left;
            arrivedState.right = right;
          }
          internalX.value = scrollLeft;
          let scrollTop = el.scrollTop;
          if (target === window2.document && !scrollTop)
            scrollTop = window2.document.body.scrollTop;
          directions.top = scrollTop < internalY.value;
          directions.bottom = scrollTop > internalY.value;
          const top = Math.abs(scrollTop) <= (offset.top || 0);
          const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
          if (display === "flex" && flexDirection === "column-reverse") {
            arrivedState.top = bottom;
            arrivedState.bottom = top;
          } else {
            arrivedState.top = top;
            arrivedState.bottom = bottom;
          }
          internalY.value = scrollTop;
        };
        const onScrollHandler = (e) => {
          var _a2;
          if (!window2)
            return;
          const eventTarget = (_a2 = e.target.documentElement) != null ? _a2 : e.target;
          setArrivedState(eventTarget);
          isScrolling.value = true;
          onScrollEndDebounced(e);
          onScroll(e);
        };
        useEventListener$1(
          element,
          "scroll",
          throttle2 ? useThrottleFn$1(onScrollHandler, throttle2, true, false) : onScrollHandler,
          eventListenerOptions
        );
        tryOnMounted$1(() => {
          try {
            const _element = toValue(element);
            if (!_element)
              return;
            setArrivedState(_element);
          } catch (e) {
            onError(e);
          }
        });
        useEventListener$1(
          element,
          "scrollend",
          onScrollEnd,
          eventListenerOptions
        );
        return {
          x,
          y,
          isScrolling,
          arrivedState,
          directions,
          measure() {
            const _element = toValue(element);
            if (window2 && _element)
              setArrivedState(_element);
          }
        };
      }
      var VERSION = "1.13.7";
      var root$1 = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
      var ArrayProto = Array.prototype, ObjProto = Object.prototype;
      var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
      var push = ArrayProto.push, slice$1 = ArrayProto.slice, toString$1 = ObjProto.toString, hasOwnProperty$d = ObjProto.hasOwnProperty;
      var supportsArrayBuffer = typeof ArrayBuffer !== "undefined", supportsDataView = typeof DataView !== "undefined";
      var nativeIsArray = Array.isArray, nativeKeys$1 = Object.keys, nativeCreate$1 = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
      var _isNaN = isNaN, _isFinite = isFinite;
      var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
      var nonEnumerableProps = [
        "valueOf",
        "isPrototypeOf",
        "toString",
        "propertyIsEnumerable",
        "hasOwnProperty",
        "toLocaleString"
      ];
      var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
      function restArguments(func, startIndex) {
        startIndex = startIndex == null ? func.length - 1 : +startIndex;
        return function() {
          var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
          for (; index < length; index++) {
            rest2[index] = arguments[index + startIndex];
          }
          switch (startIndex) {
            case 0:
              return func.call(this, rest2);
            case 1:
              return func.call(this, arguments[0], rest2);
            case 2:
              return func.call(this, arguments[0], arguments[1], rest2);
          }
          var args = Array(startIndex + 1);
          for (index = 0; index < startIndex; index++) {
            args[index] = arguments[index];
          }
          args[startIndex] = rest2;
          return func.apply(this, args);
        };
      }
      function isObject$2(obj) {
        var type = typeof obj;
        return type === "function" || type === "object" && !!obj;
      }
      function isNull(obj) {
        return obj === null;
      }
      function isUndefined$2(obj) {
        return obj === void 0;
      }
      function isBoolean$1(obj) {
        return obj === true || obj === false || toString$1.call(obj) === "[object Boolean]";
      }
      function isElement$1(obj) {
        return !!(obj && obj.nodeType === 1);
      }
      function tagTester(name) {
        var tag = "[object " + name + "]";
        return function(obj) {
          return toString$1.call(obj) === tag;
        };
      }
      const isString$2 = tagTester("String");
      const isNumber$1 = tagTester("Number");
      const isDate = tagTester("Date");
      const isRegExp = tagTester("RegExp");
      const isError = tagTester("Error");
      const isSymbol$1 = tagTester("Symbol");
      const isArrayBuffer = tagTester("ArrayBuffer");
      var isFunction$3 = tagTester("Function");
      var nodelist = root$1.document && root$1.document.childNodes;
      if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
        isFunction$3 = function(obj) {
          return typeof obj == "function" || false;
        };
      }
      const isFunction$4 = isFunction$3;
      const hasObjectTag = tagTester("Object");
      var hasDataViewBug = supportsDataView && (!/\[native code\]/.test(String(DataView)) || hasObjectTag(new DataView(new ArrayBuffer(8)))), isIE11 = typeof Map !== "undefined" && hasObjectTag(/* @__PURE__ */ new Map());
      var isDataView = tagTester("DataView");
      function alternateIsDataView(obj) {
        return obj != null && isFunction$4(obj.getInt8) && isArrayBuffer(obj.buffer);
      }
      const isDataView$1 = hasDataViewBug ? alternateIsDataView : isDataView;
      const isArray$2 = nativeIsArray || tagTester("Array");
      function has$1(obj, key) {
        return obj != null && hasOwnProperty$d.call(obj, key);
      }
      var isArguments$1 = tagTester("Arguments");
      (function() {
        if (!isArguments$1(arguments)) {
          isArguments$1 = function(obj) {
            return has$1(obj, "callee");
          };
        }
      })();
      const isArguments$2 = isArguments$1;
      function isFinite$1(obj) {
        return !isSymbol$1(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
      }
      function isNaN$1(obj) {
        return isNumber$1(obj) && _isNaN(obj);
      }
      function constant$1(value) {
        return function() {
          return value;
        };
      }
      function createSizePropertyCheck(getSizeProperty) {
        return function(collection) {
          var sizeProperty = getSizeProperty(collection);
          return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
        };
      }
      function shallowProperty(key) {
        return function(obj) {
          return obj == null ? void 0 : obj[key];
        };
      }
      const getByteLength = shallowProperty("byteLength");
      const isBufferLike = createSizePropertyCheck(getByteLength);
      var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
      function isTypedArray$1(obj) {
        return nativeIsView ? nativeIsView(obj) && !isDataView$1(obj) : isBufferLike(obj) && typedArrayPattern.test(toString$1.call(obj));
      }
      const isTypedArray$2 = supportsArrayBuffer ? isTypedArray$1 : constant$1(false);
      const getLength = shallowProperty("length");
      function emulatedSet(keys2) {
        var hash = {};
        for (var l = keys2.length, i = 0; i < l; ++i) hash[keys2[i]] = true;
        return {
          contains: function(key) {
            return hash[key] === true;
          },
          push: function(key) {
            hash[key] = true;
            return keys2.push(key);
          }
        };
      }
      function collectNonEnumProps(obj, keys2) {
        keys2 = emulatedSet(keys2);
        var nonEnumIdx = nonEnumerableProps.length;
        var constructor = obj.constructor;
        var proto = isFunction$4(constructor) && constructor.prototype || ObjProto;
        var prop = "constructor";
        if (has$1(obj, prop) && !keys2.contains(prop)) keys2.push(prop);
        while (nonEnumIdx--) {
          prop = nonEnumerableProps[nonEnumIdx];
          if (prop in obj && obj[prop] !== proto[prop] && !keys2.contains(prop)) {
            keys2.push(prop);
          }
        }
      }
      function keys$1(obj) {
        if (!isObject$2(obj)) return [];
        if (nativeKeys$1) return nativeKeys$1(obj);
        var keys2 = [];
        for (var key in obj) if (has$1(obj, key)) keys2.push(key);
        if (hasEnumBug) collectNonEnumProps(obj, keys2);
        return keys2;
      }
      function isEmpty(obj) {
        if (obj == null) return true;
        var length = getLength(obj);
        if (typeof length == "number" && (isArray$2(obj) || isString$2(obj) || isArguments$2(obj))) return length === 0;
        return getLength(keys$1(obj)) === 0;
      }
      function isMatch(object2, attrs) {
        var _keys = keys$1(attrs), length = _keys.length;
        if (object2 == null) return !length;
        var obj = Object(object2);
        for (var i = 0; i < length; i++) {
          var key = _keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
      }
      function _$1(obj) {
        if (obj instanceof _$1) return obj;
        if (!(this instanceof _$1)) return new _$1(obj);
        this._wrapped = obj;
      }
      _$1.VERSION = VERSION;
      _$1.prototype.value = function() {
        return this._wrapped;
      };
      _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;
      _$1.prototype.toString = function() {
        return String(this._wrapped);
      };
      function toBufferView(bufferSource) {
        return new Uint8Array(
          bufferSource.buffer || bufferSource,
          bufferSource.byteOffset || 0,
          getByteLength(bufferSource)
        );
      }
      var tagDataView = "[object DataView]";
      function eq$1(a, b, aStack, bStack) {
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        if (a == null || b == null) return false;
        if (a !== a) return b !== b;
        var type = typeof a;
        if (type !== "function" && type !== "object" && typeof b != "object") return false;
        return deepEq(a, b, aStack, bStack);
      }
      function deepEq(a, b, aStack, bStack) {
        if (a instanceof _$1) a = a._wrapped;
        if (b instanceof _$1) b = b._wrapped;
        var className = toString$1.call(a);
        if (className !== toString$1.call(b)) return false;
        if (hasDataViewBug && className == "[object Object]" && isDataView$1(a)) {
          if (!isDataView$1(b)) return false;
          className = tagDataView;
        }
        switch (className) {
          case "[object RegExp]":
          case "[object String]":
            return "" + a === "" + b;
          case "[object Number]":
            if (+a !== +a) return +b !== +b;
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
          case "[object Date]":
          case "[object Boolean]":
            return +a === +b;
          case "[object Symbol]":
            return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
          case "[object ArrayBuffer]":
          case tagDataView:
            return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
        }
        var areArrays = className === "[object Array]";
        if (!areArrays && isTypedArray$2(a)) {
          var byteLength = getByteLength(a);
          if (byteLength !== getByteLength(b)) return false;
          if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
          areArrays = true;
        }
        if (!areArrays) {
          if (typeof a != "object" || typeof b != "object") return false;
          var aCtor = a.constructor, bCtor = b.constructor;
          if (aCtor !== bCtor && !(isFunction$4(aCtor) && aCtor instanceof aCtor && isFunction$4(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
            return false;
          }
        }
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
          if (aStack[length] === a) return bStack[length] === b;
        }
        aStack.push(a);
        bStack.push(b);
        if (areArrays) {
          length = a.length;
          if (length !== b.length) return false;
          while (length--) {
            if (!eq$1(a[length], b[length], aStack, bStack)) return false;
          }
        } else {
          var _keys = keys$1(a), key;
          length = _keys.length;
          if (keys$1(b).length !== length) return false;
          while (length--) {
            key = _keys[length];
            if (!(has$1(b, key) && eq$1(a[key], b[key], aStack, bStack))) return false;
          }
        }
        aStack.pop();
        bStack.pop();
        return true;
      }
      function isEqual$1(a, b) {
        return eq$1(a, b);
      }
      function allKeys(obj) {
        if (!isObject$2(obj)) return [];
        var keys2 = [];
        for (var key in obj) keys2.push(key);
        if (hasEnumBug) collectNonEnumProps(obj, keys2);
        return keys2;
      }
      function ie11fingerprint(methods) {
        var length = getLength(methods);
        return function(obj) {
          if (obj == null) return false;
          var keys2 = allKeys(obj);
          if (getLength(keys2)) return false;
          for (var i = 0; i < length; i++) {
            if (!isFunction$4(obj[methods[i]])) return false;
          }
          return methods !== weakMapMethods || !isFunction$4(obj[forEachName]);
        };
      }
      var forEachName = "forEach", hasName = "has", commonInit = ["clear", "delete"], mapTail = ["get", hasName, "set"];
      var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = ["add"].concat(commonInit, forEachName, hasName);
      const isMap$1 = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
      const isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
      const isSet$1 = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
      const isWeakSet = tagTester("WeakSet");
      function values(obj) {
        var _keys = keys$1(obj);
        var length = _keys.length;
        var values2 = Array(length);
        for (var i = 0; i < length; i++) {
          values2[i] = obj[_keys[i]];
        }
        return values2;
      }
      function pairs(obj) {
        var _keys = keys$1(obj);
        var length = _keys.length;
        var pairs2 = Array(length);
        for (var i = 0; i < length; i++) {
          pairs2[i] = [_keys[i], obj[_keys[i]]];
        }
        return pairs2;
      }
      function invert(obj) {
        var result2 = {};
        var _keys = keys$1(obj);
        for (var i = 0, length = _keys.length; i < length; i++) {
          result2[obj[_keys[i]]] = _keys[i];
        }
        return result2;
      }
      function functions(obj) {
        var names2 = [];
        for (var key in obj) {
          if (isFunction$4(obj[key])) names2.push(key);
        }
        return names2.sort();
      }
      function createAssigner(keysFunc, defaults2) {
        return function(obj) {
          var length = arguments.length;
          if (defaults2) obj = Object(obj);
          if (length < 2 || obj == null) return obj;
          for (var index = 1; index < length; index++) {
            var source = arguments[index], keys2 = keysFunc(source), l = keys2.length;
            for (var i = 0; i < l; i++) {
              var key = keys2[i];
              if (!defaults2 || obj[key] === void 0) obj[key] = source[key];
            }
          }
          return obj;
        };
      }
      const extend = createAssigner(allKeys);
      const extendOwn = createAssigner(keys$1);
      const defaults = createAssigner(allKeys, true);
      function ctor() {
        return function() {
        };
      }
      function baseCreate$1(prototype) {
        if (!isObject$2(prototype)) return {};
        if (nativeCreate$1) return nativeCreate$1(prototype);
        var Ctor = ctor();
        Ctor.prototype = prototype;
        var result2 = new Ctor();
        Ctor.prototype = null;
        return result2;
      }
      function create(prototype, props) {
        var result2 = baseCreate$1(prototype);
        if (props) extendOwn(result2, props);
        return result2;
      }
      function clone(obj) {
        if (!isObject$2(obj)) return obj;
        return isArray$2(obj) ? obj.slice() : extend({}, obj);
      }
      function tap(obj, interceptor) {
        interceptor(obj);
        return obj;
      }
      function toPath$1(path) {
        return isArray$2(path) ? path : [path];
      }
      _$1.toPath = toPath$1;
      function toPath(path) {
        return _$1.toPath(path);
      }
      function deepGet(obj, path) {
        var length = path.length;
        for (var i = 0; i < length; i++) {
          if (obj == null) return void 0;
          obj = obj[path[i]];
        }
        return length ? obj : void 0;
      }
      function get$1(object2, path, defaultValue) {
        var value = deepGet(object2, toPath(path));
        return isUndefined$2(value) ? defaultValue : value;
      }
      function has(obj, path) {
        path = toPath(path);
        var length = path.length;
        for (var i = 0; i < length; i++) {
          var key = path[i];
          if (!has$1(obj, key)) return false;
          obj = obj[key];
        }
        return !!length;
      }
      function identity$2(value) {
        return value;
      }
      function matcher(attrs) {
        attrs = extendOwn({}, attrs);
        return function(obj) {
          return isMatch(obj, attrs);
        };
      }
      function property$1(path) {
        path = toPath(path);
        return function(obj) {
          return deepGet(obj, path);
        };
      }
      function optimizeCb(func, context, argCount) {
        if (context === void 0) return func;
        switch (argCount == null ? 3 : argCount) {
          case 1:
            return function(value) {
              return func.call(context, value);
            };
          case 3:
            return function(value, index, collection) {
              return func.call(context, value, index, collection);
            };
          case 4:
            return function(accumulator, value, index, collection) {
              return func.call(context, accumulator, value, index, collection);
            };
        }
        return function() {
          return func.apply(context, arguments);
        };
      }
      function baseIteratee$1(value, context, argCount) {
        if (value == null) return identity$2;
        if (isFunction$4(value)) return optimizeCb(value, context, argCount);
        if (isObject$2(value) && !isArray$2(value)) return matcher(value);
        return property$1(value);
      }
      function iteratee(value, context) {
        return baseIteratee$1(value, context, Infinity);
      }
      _$1.iteratee = iteratee;
      function cb(value, context, argCount) {
        if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context);
        return baseIteratee$1(value, context, argCount);
      }
      function mapObject(obj, iteratee2, context) {
        iteratee2 = cb(iteratee2, context);
        var _keys = keys$1(obj), length = _keys.length, results = {};
        for (var index = 0; index < length; index++) {
          var currentKey = _keys[index];
          results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
        }
        return results;
      }
      function noop$1() {
      }
      function propertyOf(obj) {
        if (obj == null) return noop$1;
        return function(path) {
          return get$1(obj, path);
        };
      }
      function times(n, iteratee2, context) {
        var accum = Array(Math.max(0, n));
        iteratee2 = optimizeCb(iteratee2, context, 1);
        for (var i = 0; i < n; i++) accum[i] = iteratee2(i);
        return accum;
      }
      function random(min2, max2) {
        if (max2 == null) {
          max2 = min2;
          min2 = 0;
        }
        return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
      }
      const now$1 = Date.now || function() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      function createEscaper(map2) {
        var escaper = function(match) {
          return map2[match];
        };
        var source = "(?:" + keys$1(map2).join("|") + ")";
        var testRegexp = RegExp(source);
        var replaceRegexp = RegExp(source, "g");
        return function(string) {
          string = string == null ? "" : "" + string;
          return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
      }
      const escapeMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
      };
      const escape = createEscaper(escapeMap);
      const unescapeMap = invert(escapeMap);
      const unescape = createEscaper(unescapeMap);
      const templateSettings = _$1.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
      };
      var noMatch = /(.)^/;
      var escapes = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
      function escapeChar(match) {
        return "\\" + escapes[match];
      }
      var bareIdentifier = /^\s*(\w|\$)+\s*$/;
      function template(text, settings, oldSettings) {
        if (!settings && oldSettings) settings = oldSettings;
        settings = defaults({}, settings, _$1.templateSettings);
        var matcher2 = RegExp([
          (settings.escape || noMatch).source,
          (settings.interpolate || noMatch).source,
          (settings.evaluate || noMatch).source
        ].join("|") + "|$", "g");
        var index = 0;
        var source = "__p+='";
        text.replace(matcher2, function(match, escape2, interpolate, evaluate, offset) {
          source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
          index = offset + match.length;
          if (escape2) {
            source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
          } else if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          } else if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
          return match;
        });
        source += "';\n";
        var argument = settings.variable;
        if (argument) {
          if (!bareIdentifier.test(argument)) throw new Error(
            "variable is not a bare identifier: " + argument
          );
        } else {
          source = "with(obj||{}){\n" + source + "}\n";
          argument = "obj";
        }
        source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
        var render2;
        try {
          render2 = new Function(argument, "_", source);
        } catch (e) {
          e.source = source;
          throw e;
        }
        var template2 = function(data) {
          return render2.call(this, data, _$1);
        };
        template2.source = "function(" + argument + "){\n" + source + "}";
        return template2;
      }
      function result(obj, path, fallback) {
        path = toPath(path);
        var length = path.length;
        if (!length) {
          return isFunction$4(fallback) ? fallback.call(obj) : fallback;
        }
        for (var i = 0; i < length; i++) {
          var prop = obj == null ? void 0 : obj[path[i]];
          if (prop === void 0) {
            prop = fallback;
            i = length;
          }
          obj = isFunction$4(prop) ? prop.call(obj) : prop;
        }
        return obj;
      }
      var idCounter = 0;
      function uniqueId(prefix) {
        var id = ++idCounter + "";
        return prefix ? prefix + id : id;
      }
      function chain(obj) {
        var instance = _$1(obj);
        instance._chain = true;
        return instance;
      }
      function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
        if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
        var self2 = baseCreate$1(sourceFunc.prototype);
        var result2 = sourceFunc.apply(self2, args);
        if (isObject$2(result2)) return result2;
        return self2;
      }
      var partial = restArguments(function(func, boundArgs) {
        var placeholder = partial.placeholder;
        var bound = function() {
          var position = 0, length = boundArgs.length;
          var args = Array(length);
          for (var i = 0; i < length; i++) {
            args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
          }
          while (position < arguments.length) args.push(arguments[position++]);
          return executeBound(func, bound, this, this, args);
        };
        return bound;
      });
      partial.placeholder = _$1;
      const bind = restArguments(function(func, context, args) {
        if (!isFunction$4(func)) throw new TypeError("Bind must be called on a function");
        var bound = restArguments(function(callArgs) {
          return executeBound(func, bound, context, this, args.concat(callArgs));
        });
        return bound;
      });
      const isArrayLike$1 = createSizePropertyCheck(getLength);
      function flatten$2(input, depth, strict, output) {
        output = output || [];
        if (!depth && depth !== 0) {
          depth = Infinity;
        } else if (depth <= 0) {
          return output.concat(input);
        }
        var idx = output.length;
        for (var i = 0, length = getLength(input); i < length; i++) {
          var value = input[i];
          if (isArrayLike$1(value) && (isArray$2(value) || isArguments$2(value))) {
            if (depth > 1) {
              flatten$2(value, depth - 1, strict, output);
              idx = output.length;
            } else {
              var j = 0, len = value.length;
              while (j < len) output[idx++] = value[j++];
            }
          } else if (!strict) {
            output[idx++] = value;
          }
        }
        return output;
      }
      const bindAll = restArguments(function(obj, keys2) {
        keys2 = flatten$2(keys2, false, false);
        var index = keys2.length;
        if (index < 1) throw new Error("bindAll must be passed function names");
        while (index--) {
          var key = keys2[index];
          obj[key] = bind(obj[key], obj);
        }
        return obj;
      });
      function memoize$1(func, hasher) {
        var memoize2 = function(key) {
          var cache = memoize2.cache;
          var address = "" + (hasher ? hasher.apply(this, arguments) : key);
          if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);
          return cache[address];
        };
        memoize2.cache = {};
        return memoize2;
      }
      const delay = restArguments(function(func, wait, args) {
        return setTimeout(function() {
          return func.apply(null, args);
        }, wait);
      });
      const defer = partial(delay, _$1, 1);
      function throttle$1(func, wait, options) {
        var timeout, context, args, result2;
        var previous = 0;
        if (!options) options = {};
        var later = function() {
          previous = options.leading === false ? 0 : now$1();
          timeout = null;
          result2 = func.apply(context, args);
          if (!timeout) context = args = null;
        };
        var throttled = function() {
          var _now = now$1();
          if (!previous && options.leading === false) previous = _now;
          var remaining = wait - (_now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0 || remaining > wait) {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }
            previous = _now;
            result2 = func.apply(context, args);
            if (!timeout) context = args = null;
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result2;
        };
        throttled.cancel = function() {
          clearTimeout(timeout);
          previous = 0;
          timeout = context = args = null;
        };
        return throttled;
      }
      function debounce$1(func, wait, immediate) {
        var timeout, previous, args, result2, context;
        var later = function() {
          var passed = now$1() - previous;
          if (wait > passed) {
            timeout = setTimeout(later, wait - passed);
          } else {
            timeout = null;
            if (!immediate) result2 = func.apply(context, args);
            if (!timeout) args = context = null;
          }
        };
        var debounced = restArguments(function(_args) {
          context = this;
          args = _args;
          previous = now$1();
          if (!timeout) {
            timeout = setTimeout(later, wait);
            if (immediate) result2 = func.apply(context, args);
          }
          return result2;
        });
        debounced.cancel = function() {
          clearTimeout(timeout);
          timeout = args = context = null;
        };
        return debounced;
      }
      function wrap(func, wrapper) {
        return partial(wrapper, func);
      }
      function negate(predicate) {
        return function() {
          return !predicate.apply(this, arguments);
        };
      }
      function compose() {
        var args = arguments;
        var start = args.length - 1;
        return function() {
          var i = start;
          var result2 = args[start].apply(this, arguments);
          while (i--) result2 = args[i].call(this, result2);
          return result2;
        };
      }
      function after(times2, func) {
        return function() {
          if (--times2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function before(times2, func) {
        var memo;
        return function() {
          if (--times2 > 0) {
            memo = func.apply(this, arguments);
          }
          if (times2 <= 1) func = null;
          return memo;
        };
      }
      const once = partial(before, 2);
      function findKey(obj, predicate, context) {
        predicate = cb(predicate, context);
        var _keys = keys$1(obj), key;
        for (var i = 0, length = _keys.length; i < length; i++) {
          key = _keys[i];
          if (predicate(obj[key], key, obj)) return key;
        }
      }
      function createPredicateIndexFinder(dir) {
        return function(array, predicate, context) {
          predicate = cb(predicate, context);
          var length = getLength(array);
          var index = dir > 0 ? 0 : length - 1;
          for (; index >= 0 && index < length; index += dir) {
            if (predicate(array[index], index, array)) return index;
          }
          return -1;
        };
      }
      const findIndex = createPredicateIndexFinder(1);
      const findLastIndex$1 = createPredicateIndexFinder(-1);
      function sortedIndex(array, obj, iteratee2, context) {
        iteratee2 = cb(iteratee2, context, 1);
        var value = iteratee2(obj);
        var low = 0, high = getLength(array);
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (iteratee2(array[mid]) < value) low = mid + 1;
          else high = mid;
        }
        return low;
      }
      function createIndexFinder(dir, predicateFind, sortedIndex2) {
        return function(array, item, idx) {
          var i = 0, length = getLength(array);
          if (typeof idx == "number") {
            if (dir > 0) {
              i = idx >= 0 ? idx : Math.max(idx + length, i);
            } else {
              length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
            }
          } else if (sortedIndex2 && idx && length) {
            idx = sortedIndex2(array, item);
            return array[idx] === item ? idx : -1;
          }
          if (item !== item) {
            idx = predicateFind(slice$1.call(array, i, length), isNaN$1);
            return idx >= 0 ? idx + i : -1;
          }
          for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
            if (array[idx] === item) return idx;
          }
          return -1;
        };
      }
      const indexOf = createIndexFinder(1, findIndex, sortedIndex);
      const lastIndexOf = createIndexFinder(-1, findLastIndex$1);
      function find(obj, predicate, context) {
        var keyFinder = isArrayLike$1(obj) ? findIndex : findKey;
        var key = keyFinder(obj, predicate, context);
        if (key !== void 0 && key !== -1) return obj[key];
      }
      function findWhere(obj, attrs) {
        return find(obj, matcher(attrs));
      }
      function each(obj, iteratee2, context) {
        iteratee2 = optimizeCb(iteratee2, context);
        var i, length;
        if (isArrayLike$1(obj)) {
          for (i = 0, length = obj.length; i < length; i++) {
            iteratee2(obj[i], i, obj);
          }
        } else {
          var _keys = keys$1(obj);
          for (i = 0, length = _keys.length; i < length; i++) {
            iteratee2(obj[_keys[i]], _keys[i], obj);
          }
        }
        return obj;
      }
      function map(obj, iteratee2, context) {
        iteratee2 = cb(iteratee2, context);
        var _keys = !isArrayLike$1(obj) && keys$1(obj), length = (_keys || obj).length, results = Array(length);
        for (var index = 0; index < length; index++) {
          var currentKey = _keys ? _keys[index] : index;
          results[index] = iteratee2(obj[currentKey], currentKey, obj);
        }
        return results;
      }
      function createReduce(dir) {
        var reducer = function(obj, iteratee2, memo, initial2) {
          var _keys = !isArrayLike$1(obj) && keys$1(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
          if (!initial2) {
            memo = obj[_keys ? _keys[index] : index];
            index += dir;
          }
          for (; index >= 0 && index < length; index += dir) {
            var currentKey = _keys ? _keys[index] : index;
            memo = iteratee2(memo, obj[currentKey], currentKey, obj);
          }
          return memo;
        };
        return function(obj, iteratee2, memo, context) {
          var initial2 = arguments.length >= 3;
          return reducer(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
        };
      }
      const reduce = createReduce(1);
      const reduceRight = createReduce(-1);
      function filter(obj, predicate, context) {
        var results = [];
        predicate = cb(predicate, context);
        each(obj, function(value, index, list) {
          if (predicate(value, index, list)) results.push(value);
        });
        return results;
      }
      function reject(obj, predicate, context) {
        return filter(obj, negate(cb(predicate)), context);
      }
      function every(obj, predicate, context) {
        predicate = cb(predicate, context);
        var _keys = !isArrayLike$1(obj) && keys$1(obj), length = (_keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = _keys ? _keys[index] : index;
          if (!predicate(obj[currentKey], currentKey, obj)) return false;
        }
        return true;
      }
      function some(obj, predicate, context) {
        predicate = cb(predicate, context);
        var _keys = !isArrayLike$1(obj) && keys$1(obj), length = (_keys || obj).length;
        for (var index = 0; index < length; index++) {
          var currentKey = _keys ? _keys[index] : index;
          if (predicate(obj[currentKey], currentKey, obj)) return true;
        }
        return false;
      }
      function contains(obj, item, fromIndex, guard) {
        if (!isArrayLike$1(obj)) obj = values(obj);
        if (typeof fromIndex != "number" || guard) fromIndex = 0;
        return indexOf(obj, item, fromIndex) >= 0;
      }
      const invoke = restArguments(function(obj, path, args) {
        var contextPath, func;
        if (isFunction$4(path)) {
          func = path;
        } else {
          path = toPath(path);
          contextPath = path.slice(0, -1);
          path = path[path.length - 1];
        }
        return map(obj, function(context) {
          var method = func;
          if (!method) {
            if (contextPath && contextPath.length) {
              context = deepGet(context, contextPath);
            }
            if (context == null) return void 0;
            method = context[path];
          }
          return method == null ? method : method.apply(context, args);
        });
      });
      function pluck(obj, key) {
        return map(obj, property$1(key));
      }
      function where(obj, attrs) {
        return filter(obj, matcher(attrs));
      }
      function max(obj, iteratee2, context) {
        var result2 = -Infinity, lastComputed = -Infinity, value, computed2;
        if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
          obj = isArrayLike$1(obj) ? obj : values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value != null && value > result2) {
              result2 = value;
            }
          }
        } else {
          iteratee2 = cb(iteratee2, context);
          each(obj, function(v, index, list) {
            computed2 = iteratee2(v, index, list);
            if (computed2 > lastComputed || computed2 === -Infinity && result2 === -Infinity) {
              result2 = v;
              lastComputed = computed2;
            }
          });
        }
        return result2;
      }
      function min(obj, iteratee2, context) {
        var result2 = Infinity, lastComputed = Infinity, value, computed2;
        if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
          obj = isArrayLike$1(obj) ? obj : values(obj);
          for (var i = 0, length = obj.length; i < length; i++) {
            value = obj[i];
            if (value != null && value < result2) {
              result2 = value;
            }
          }
        } else {
          iteratee2 = cb(iteratee2, context);
          each(obj, function(v, index, list) {
            computed2 = iteratee2(v, index, list);
            if (computed2 < lastComputed || computed2 === Infinity && result2 === Infinity) {
              result2 = v;
              lastComputed = computed2;
            }
          });
        }
        return result2;
      }
      var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
      function toArray$1(obj) {
        if (!obj) return [];
        if (isArray$2(obj)) return slice$1.call(obj);
        if (isString$2(obj)) {
          return obj.match(reStrSymbol);
        }
        if (isArrayLike$1(obj)) return map(obj, identity$2);
        return values(obj);
      }
      function sample(obj, n, guard) {
        if (n == null || guard) {
          if (!isArrayLike$1(obj)) obj = values(obj);
          return obj[random(obj.length - 1)];
        }
        var sample2 = toArray$1(obj);
        var length = getLength(sample2);
        n = Math.max(Math.min(n, length), 0);
        var last2 = length - 1;
        for (var index = 0; index < n; index++) {
          var rand = random(index, last2);
          var temp = sample2[index];
          sample2[index] = sample2[rand];
          sample2[rand] = temp;
        }
        return sample2.slice(0, n);
      }
      function shuffle(obj) {
        return sample(obj, Infinity);
      }
      function sortBy(obj, iteratee2, context) {
        var index = 0;
        iteratee2 = cb(iteratee2, context);
        return pluck(map(obj, function(value, key, list) {
          return {
            value,
            index: index++,
            criteria: iteratee2(value, key, list)
          };
        }).sort(function(left, right) {
          var a = left.criteria;
          var b = right.criteria;
          if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
          }
          return left.index - right.index;
        }), "value");
      }
      function group(behavior, partition2) {
        return function(obj, iteratee2, context) {
          var result2 = partition2 ? [[], []] : {};
          iteratee2 = cb(iteratee2, context);
          each(obj, function(value, index) {
            var key = iteratee2(value, index, obj);
            behavior(result2, value, key);
          });
          return result2;
        };
      }
      const groupBy = group(function(result2, value, key) {
        if (has$1(result2, key)) result2[key].push(value);
        else result2[key] = [value];
      });
      const indexBy = group(function(result2, value, key) {
        result2[key] = value;
      });
      const countBy = group(function(result2, value, key) {
        if (has$1(result2, key)) result2[key]++;
        else result2[key] = 1;
      });
      const partition = group(function(result2, value, pass) {
        result2[pass ? 0 : 1].push(value);
      }, true);
      function size(obj) {
        if (obj == null) return 0;
        return isArrayLike$1(obj) ? obj.length : keys$1(obj).length;
      }
      function keyInObj(value, key, obj) {
        return key in obj;
      }
      const pick$1 = restArguments(function(obj, keys2) {
        var result2 = {}, iteratee2 = keys2[0];
        if (obj == null) return result2;
        if (isFunction$4(iteratee2)) {
          if (keys2.length > 1) iteratee2 = optimizeCb(iteratee2, keys2[1]);
          keys2 = allKeys(obj);
        } else {
          iteratee2 = keyInObj;
          keys2 = flatten$2(keys2, false, false);
          obj = Object(obj);
        }
        for (var i = 0, length = keys2.length; i < length; i++) {
          var key = keys2[i];
          var value = obj[key];
          if (iteratee2(value, key, obj)) result2[key] = value;
        }
        return result2;
      });
      const omit = restArguments(function(obj, keys2) {
        var iteratee2 = keys2[0], context;
        if (isFunction$4(iteratee2)) {
          iteratee2 = negate(iteratee2);
          if (keys2.length > 1) context = keys2[1];
        } else {
          keys2 = map(flatten$2(keys2, false, false), String);
          iteratee2 = function(value, key) {
            return !contains(keys2, key);
          };
        }
        return pick$1(obj, iteratee2, context);
      });
      function initial$1(array, n, guard) {
        return slice$1.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
      }
      function first(array, n, guard) {
        if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
        if (n == null || guard) return array[0];
        return initial$1(array, array.length - n);
      }
      function rest(array, n, guard) {
        return slice$1.call(array, n == null || guard ? 1 : n);
      }
      function last(array, n, guard) {
        if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
        if (n == null || guard) return array[array.length - 1];
        return rest(array, Math.max(0, array.length - n));
      }
      function compact(array) {
        return filter(array, Boolean);
      }
      function flatten$1(array, depth) {
        return flatten$2(array, depth, false);
      }
      const difference = restArguments(function(array, rest2) {
        rest2 = flatten$2(rest2, true, true);
        return filter(array, function(value) {
          return !contains(rest2, value);
        });
      });
      const without = restArguments(function(array, otherArrays) {
        return difference(array, otherArrays);
      });
      function uniq(array, isSorted, iteratee2, context) {
        if (!isBoolean$1(isSorted)) {
          context = iteratee2;
          iteratee2 = isSorted;
          isSorted = false;
        }
        if (iteratee2 != null) iteratee2 = cb(iteratee2, context);
        var result2 = [];
        var seen = [];
        for (var i = 0, length = getLength(array); i < length; i++) {
          var value = array[i], computed2 = iteratee2 ? iteratee2(value, i, array) : value;
          if (isSorted && !iteratee2) {
            if (!i || seen !== computed2) result2.push(value);
            seen = computed2;
          } else if (iteratee2) {
            if (!contains(seen, computed2)) {
              seen.push(computed2);
              result2.push(value);
            }
          } else if (!contains(result2, value)) {
            result2.push(value);
          }
        }
        return result2;
      }
      const union = restArguments(function(arrays) {
        return uniq(flatten$2(arrays, true, true));
      });
      function intersection(array) {
        var result2 = [];
        var argsLength = arguments.length;
        for (var i = 0, length = getLength(array); i < length; i++) {
          var item = array[i];
          if (contains(result2, item)) continue;
          var j;
          for (j = 1; j < argsLength; j++) {
            if (!contains(arguments[j], item)) break;
          }
          if (j === argsLength) result2.push(item);
        }
        return result2;
      }
      function unzip(array) {
        var length = array && max(array, getLength).length || 0;
        var result2 = Array(length);
        for (var index = 0; index < length; index++) {
          result2[index] = pluck(array, index);
        }
        return result2;
      }
      const zip = restArguments(unzip);
      function object(list, values2) {
        var result2 = {};
        for (var i = 0, length = getLength(list); i < length; i++) {
          if (values2) {
            result2[list[i]] = values2[i];
          } else {
            result2[list[i][0]] = list[i][1];
          }
        }
        return result2;
      }
      function range(start, stop, step) {
        if (stop == null) {
          stop = start || 0;
          start = 0;
        }
        if (!step) {
          step = stop < start ? -1 : 1;
        }
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var range2 = Array(length);
        for (var idx = 0; idx < length; idx++, start += step) {
          range2[idx] = start;
        }
        return range2;
      }
      function chunk(array, count) {
        if (count == null || count < 1) return [];
        var result2 = [];
        var i = 0, length = array.length;
        while (i < length) {
          result2.push(slice$1.call(array, i, i += count));
        }
        return result2;
      }
      function chainResult(instance, obj) {
        return instance._chain ? _$1(obj).chain() : obj;
      }
      function mixin(obj) {
        each(functions(obj), function(name) {
          var func = _$1[name] = obj[name];
          _$1.prototype[name] = function() {
            var args = [this._wrapped];
            push.apply(args, arguments);
            return chainResult(this, func.apply(_$1, args));
          };
        });
        return _$1;
      }
      each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
        var method = ArrayProto[name];
        _$1.prototype[name] = function() {
          var obj = this._wrapped;
          if (obj != null) {
            method.apply(obj, arguments);
            if ((name === "shift" || name === "splice") && obj.length === 0) {
              delete obj[0];
            }
          }
          return chainResult(this, obj);
        };
      });
      each(["concat", "join", "slice"], function(name) {
        var method = ArrayProto[name];
        _$1.prototype[name] = function() {
          var obj = this._wrapped;
          if (obj != null) obj = method.apply(obj, arguments);
          return chainResult(this, obj);
        };
      });
      const allExports = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        VERSION,
        after,
        all: every,
        allKeys,
        any: some,
        assign: extendOwn,
        before,
        bind,
        bindAll,
        chain,
        chunk,
        clone,
        collect: map,
        compact,
        compose,
        constant: constant$1,
        contains,
        countBy,
        create,
        debounce: debounce$1,
        default: _$1,
        defaults,
        defer,
        delay,
        detect: find,
        difference,
        drop: rest,
        each,
        escape,
        every,
        extend,
        extendOwn,
        filter,
        find,
        findIndex,
        findKey,
        findLastIndex: findLastIndex$1,
        findWhere,
        first,
        flatten: flatten$1,
        foldl: reduce,
        foldr: reduceRight,
        forEach: each,
        functions,
        get: get$1,
        groupBy,
        has,
        head: first,
        identity: identity$2,
        include: contains,
        includes: contains,
        indexBy,
        indexOf,
        initial: initial$1,
        inject: reduce,
        intersection,
        invert,
        invoke,
        isArguments: isArguments$2,
        isArray: isArray$2,
        isArrayBuffer,
        isBoolean: isBoolean$1,
        isDataView: isDataView$1,
        isDate,
        isElement: isElement$1,
        isEmpty,
        isEqual: isEqual$1,
        isError,
        isFinite: isFinite$1,
        isFunction: isFunction$4,
        isMap: isMap$1,
        isMatch,
        isNaN: isNaN$1,
        isNull,
        isNumber: isNumber$1,
        isObject: isObject$2,
        isRegExp,
        isSet: isSet$1,
        isString: isString$2,
        isSymbol: isSymbol$1,
        isTypedArray: isTypedArray$2,
        isUndefined: isUndefined$2,
        isWeakMap,
        isWeakSet,
        iteratee,
        keys: keys$1,
        last,
        lastIndexOf,
        map,
        mapObject,
        matcher,
        matches: matcher,
        max,
        memoize: memoize$1,
        methods: functions,
        min,
        mixin,
        negate,
        noop: noop$1,
        now: now$1,
        object,
        omit,
        once,
        pairs,
        partial,
        partition,
        pick: pick$1,
        pluck,
        property: property$1,
        propertyOf,
        random,
        range,
        reduce,
        reduceRight,
        reject,
        rest,
        restArguments,
        result,
        sample,
        select: filter,
        shuffle,
        size,
        some,
        sortBy,
        sortedIndex,
        tail: rest,
        take: first,
        tap,
        template,
        templateSettings,
        throttle: throttle$1,
        times,
        toArray: toArray$1,
        toPath: toPath$1,
        transpose: unzip,
        unescape,
        union,
        uniq,
        unique: uniq,
        uniqueId,
        unzip,
        values,
        where,
        without,
        wrap,
        zip
      }, Symbol.toStringTag, { value: "Module" }));
      var _ = mixin(allExports);
      _._ = _;
      const _export_sfc$1 = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const _sfc_main$12 = {
        __name: "WallpaperItem",
        setup(__props) {
          const wallpaperRef = vue.ref();
          const biliStore = useBiliStore();
          const { isShowOriginal } = storeToRefs(biliStore);
          function onWallpaperMheelScroll(event) {
            if (event.deltaY > 0) {
              isShowOriginal.value = true;
            }
            event.preventDefault();
          }
          const { arrivedState, y: topOffset } = useScroll(window);
          vue.watch(topOffset, () => {
            if (topOffset.value > 3 && !isShowOriginal.value) {
              isShowOriginal.value = true;
            }
          });
          const { top: isTop } = vue.toRefs(arrivedState);
          const onWindowMhellScroll = throttle$1((event) => {
            if (event.deltaY > 0) {
              return;
            }
            if (!isTop.value) {
              return;
            }
            isShowOriginal.value = false;
          }, 100);
          vue.onMounted(() => {
            wallpaperRef.value.addEventListener("wheel", onWallpaperMheelScroll);
            window.addEventListener("wheel", onWindowMhellScroll, { passive: false });
          });
          vue.onUnmounted(() => {
            window.removeEventListener("wheel", onWindowMhellScroll);
          });
          const mainStore2 = useMainStore();
          const { currWallpaperBase64Url } = storeToRefs(mainStore2);
          vue.onMounted(() => {
            vue.watch(currWallpaperBase64Url, () => {
              wallpaperRef.value.style.backgroundImage = `${currWallpaperBase64Url.value} `;
            }, { immediate: true });
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: vue.normalizeClass(["wallpaper-item", { hidden: vue.unref(isShowOriginal) }]),
              ref_key: "wallpaperRef",
              ref: wallpaperRef
            }, null, 2);
          };
        }
      };
      const WallpaperItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$12, [["__scopeId", "data-v-0166ab8b"]]);
      const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
      const isVisible = (element) => {
        const computed2 = getComputedStyle(element);
        return computed2.position === "fixed" ? false : element.offsetParent !== null;
      };
      const obtainAllFocusableElements$1 = (element) => {
        return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item) => isFocusable(item) && isVisible(item));
      };
      const isFocusable = (element) => {
        if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
          return true;
        }
        if (element.disabled) {
          return false;
        }
        switch (element.nodeName) {
          case "A": {
            return !!element.href && element.rel !== "ignore";
          }
          case "INPUT": {
            return !(element.type === "hidden" || element.type === "file");
          }
          case "BUTTON":
          case "SELECT":
          case "TEXTAREA": {
            return true;
          }
          default: {
            return false;
          }
        }
      };
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      var __defProp$9 = Object.defineProperty;
      var __defProps$6 = Object.defineProperties;
      var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
      var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
      var __hasOwnProp$b = Object.prototype.hasOwnProperty;
      var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
      var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues$9 = (a, b) => {
        for (var prop in b || (b = {}))
          if (__hasOwnProp$b.call(b, prop))
            __defNormalProp$9(a, prop, b[prop]);
        if (__getOwnPropSymbols$b)
          for (var prop of __getOwnPropSymbols$b(b)) {
            if (__propIsEnum$b.call(b, prop))
              __defNormalProp$9(a, prop, b[prop]);
          }
        return a;
      };
      var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
      function computedEager(fn2, options) {
        var _a2;
        const result2 = vue.shallowRef();
        vue.watchEffect(() => {
          result2.value = fn2();
        }, __spreadProps$6(__spreadValues$9({}, options), {
          flush: (_a2 = void 0) != null ? _a2 : "sync"
        }));
        return vue.readonly(result2);
      }
      var _a;
      const isClient = typeof window !== "undefined";
      const isDef = (val) => typeof val !== "undefined";
      const isFunction$2 = (val) => typeof val === "function";
      const isString$1 = (val) => typeof val === "string";
      const noop = () => {
      };
      const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
      function resolveUnref(r) {
        return typeof r === "function" ? r() : vue.unref(r);
      }
      function createFilterWrapper(filter2, fn2) {
        function wrapper(...args) {
          return new Promise((resolve, reject2) => {
            Promise.resolve(filter2(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve).catch(reject2);
          });
        }
        return wrapper;
      }
      function throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {
        let lastExec = 0;
        let timer;
        let isLeading = true;
        let lastRejector = noop;
        let lastValue;
        const clear = () => {
          if (timer) {
            clearTimeout(timer);
            timer = void 0;
            lastRejector();
            lastRejector = noop;
          }
        };
        const filter2 = (_invoke) => {
          const duration = resolveUnref(ms);
          const elapsed = Date.now() - lastExec;
          const invoke2 = () => {
            return lastValue = _invoke();
          };
          clear();
          if (duration <= 0) {
            lastExec = Date.now();
            return invoke2();
          }
          if (elapsed > duration && (leading || !isLeading)) {
            lastExec = Date.now();
            invoke2();
          } else if (trailing) {
            lastValue = new Promise((resolve, reject2) => {
              lastRejector = rejectOnCancel ? reject2 : resolve;
              timer = setTimeout(() => {
                lastExec = Date.now();
                isLeading = true;
                resolve(invoke2());
                clear();
              }, Math.max(0, duration - elapsed));
            });
          }
          if (!leading && !timer)
            timer = setTimeout(() => isLeading = true, duration);
          isLeading = false;
          return lastValue;
        };
        return filter2;
      }
      function identity$1(arg) {
        return arg;
      }
      function tryOnScopeDispose(fn2) {
        if (vue.getCurrentScope()) {
          vue.onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function useThrottleFn(fn2, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
        return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn2);
      }
      function tryOnMounted(fn2, sync = true) {
        if (vue.getCurrentInstance())
          vue.onMounted(fn2);
        else if (sync)
          fn2();
        else
          vue.nextTick(fn2);
      }
      function useTimeoutFn(cb2, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = vue.ref(false);
        let timer = null;
        function clear() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear();
        }
        function start(...args) {
          clear();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb2(...args);
          }, resolveUnref(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient)
            start();
        }
        tryOnScopeDispose(stop);
        return {
          isPending: vue.readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement(elRef) {
        var _a2;
        const plain = resolveUnref(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      const defaultDocument = isClient ? window.document : void 0;
      function useEventListener(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (isString$1(args[0]) || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = vue.watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
          cleanup();
          if (!el)
            return;
          cleanups.push(...events.flatMap((event) => {
            return listeners.map((listener) => register(el, event, listener, options2));
          }));
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
        if (!window2)
          return;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement(target);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup = [
          useEventListener(window2, "click", listener, { passive: true, capture }),
          useEventListener(window2, "pointerdown", (e) => {
            const el = unrefElement(target);
            if (el)
              shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
          }, { passive: true }),
          detectIframe && useEventListener(window2, "blur", (event) => {
            var _a2;
            const el = unrefElement(target);
            if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event);
          })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn2) => fn2());
        return stop;
      }
      function useSupported(callback, sync = false) {
        const isSupported = vue.ref();
        const update = () => isSupported.value = Boolean(callback());
        update();
        tryOnMounted(update, sync);
        return isSupported;
      }
      function cloneFnJSON(source) {
        return JSON.parse(JSON.stringify(source));
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      _global[globalKey] = _global[globalKey] || {};
      function useDocumentVisibility({ document: document2 = defaultDocument } = {}) {
        if (!document2)
          return vue.ref("visible");
        const visibility = vue.ref(document2.visibilityState);
        useEventListener(document2, "visibilitychange", () => {
          visibility.value = document2.visibilityState;
        });
        return visibility;
      }
      var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
      var __hasOwnProp$g = Object.prototype.hasOwnProperty;
      var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
      var __objRest$2 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$g)
          for (var prop of __getOwnPropSymbols$g(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useResizeObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = vue.watch(() => unrefElement(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new ResizeObserver(callback);
            observer.observe(el, observerOptions);
          }
        }, { immediate: true, flush: "post" });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
      var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
      var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
      var __objRest$1 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$8)
          for (var prop of __getOwnPropSymbols$8(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useMutationObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow } = _a2, mutationOptions = __objRest$1(_a2, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = vue.watch(() => unrefElement(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new MutationObserver(callback);
            observer.observe(el, mutationOptions);
          }
        }, { immediate: true });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var __defProp = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a, b) => {
        for (var prop in b || (b = {}))
          if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop))
              __defNormalProp(a, prop, b[prop]);
          }
        return a;
      };
      const _TransitionPresets = {
        easeInSine: [0.12, 0, 0.39, 0],
        easeOutSine: [0.61, 1, 0.88, 1],
        easeInOutSine: [0.37, 0, 0.63, 1],
        easeInQuad: [0.11, 0, 0.5, 0],
        easeOutQuad: [0.5, 1, 0.89, 1],
        easeInOutQuad: [0.45, 0, 0.55, 1],
        easeInCubic: [0.32, 0, 0.67, 0],
        easeOutCubic: [0.33, 1, 0.68, 1],
        easeInOutCubic: [0.65, 0, 0.35, 1],
        easeInQuart: [0.5, 0, 0.75, 0],
        easeOutQuart: [0.25, 1, 0.5, 1],
        easeInOutQuart: [0.76, 0, 0.24, 1],
        easeInQuint: [0.64, 0, 0.78, 0],
        easeOutQuint: [0.22, 1, 0.36, 1],
        easeInOutQuint: [0.83, 0, 0.17, 1],
        easeInExpo: [0.7, 0, 0.84, 0],
        easeOutExpo: [0.16, 1, 0.3, 1],
        easeInOutExpo: [0.87, 0, 0.13, 1],
        easeInCirc: [0.55, 0, 1, 0.45],
        easeOutCirc: [0, 0.55, 0.45, 1],
        easeInOutCirc: [0.85, 0, 0.15, 1],
        easeInBack: [0.36, 0, 0.66, -0.56],
        easeOutBack: [0.34, 1.56, 0.64, 1],
        easeInOutBack: [0.68, -0.6, 0.32, 1.6]
      };
      __spreadValues({
        linear: identity$1
      }, _TransitionPresets);
      function useVModel(props, key, emit, options = {}) {
        var _a2, _b, _c;
        const {
          clone: clone2 = false,
          passive = false,
          eventName,
          deep = false,
          defaultValue
        } = options;
        const vm = vue.getCurrentInstance();
        const _emit = (vm == null ? void 0 : vm.emit) || ((_a2 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a2.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
        let event = eventName;
        event = eventName || event || `update:${key.toString()}`;
        const cloneFn = (val) => !clone2 ? val : isFunction$2(clone2) ? clone2(val) : cloneFnJSON(val);
        const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
        if (passive) {
          const initialValue = getValue2();
          const proxy = vue.ref(initialValue);
          vue.watch(() => props[key], (v) => proxy.value = cloneFn(v));
          vue.watch(proxy, (v) => {
            if (v !== props[key] || deep)
              _emit(event, v);
          }, { deep });
          return proxy;
        } else {
          return vue.computed({
            get() {
              return getValue2();
            },
            set(value) {
              _emit(event, value);
            }
          });
        }
      }
      function useWindowFocus({ window: window2 = defaultWindow } = {}) {
        if (!window2)
          return vue.ref(false);
        const focused = vue.ref(window2.document.hasFocus());
        useEventListener(window2, "blur", () => {
          focused.value = false;
        });
        useEventListener(window2, "focus", () => {
          focused.value = true;
        });
        return focused;
      }
      const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
      const isInContainer = (el, container) => {
        if (!isClient || !el || !container)
          return false;
        const elRect = el.getBoundingClientRect();
        let containerRect;
        if (container instanceof Element) {
          containerRect = container.getBoundingClientRect();
        } else {
          containerRect = {
            top: 0,
            right: window.innerWidth,
            bottom: window.innerHeight,
            left: 0
          };
        }
        return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
      };
      const getClientXY = (event) => {
        let clientX;
        let clientY;
        if (event.type === "touchend") {
          clientY = event.changedTouches[0].clientY;
          clientX = event.changedTouches[0].clientX;
        } else if (event.type.startsWith("touch")) {
          clientY = event.touches[0].clientY;
          clientX = event.touches[0].clientX;
        } else {
          clientY = event.clientY;
          clientX = event.clientX;
        }
        return {
          clientX,
          clientY
        };
      };
      /**
      * @vue/shared v3.5.12
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      const NOOP = () => {
      };
      const hasOwnProperty$c = Object.prototype.hasOwnProperty;
      const hasOwn = (val, key) => hasOwnProperty$c.call(val, key);
      const isArray$1 = Array.isArray;
      const isFunction$1 = (val) => typeof val === "function";
      const isString = (val) => typeof val === "string";
      const isObject$1 = (val) => val !== null && typeof val === "object";
      const objectToString$1 = Object.prototype.toString;
      const toTypeString = (value) => objectToString$1.call(value);
      const toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      const isPlainObject = (val) => toTypeString(val) === "[object Object]";
      const cacheStringFunction = (fn2) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn2(str));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction(
        (str) => {
          return str.replace(camelizeRE, (_2, c) => c ? c.toUpperCase() : "");
        }
      );
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cacheStringFunction(
        (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
      );
      const capitalize$1 = cacheStringFunction((str) => {
        return str.charAt(0).toUpperCase() + str.slice(1);
      });
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var Symbol$1 = root.Symbol;
      var objectProto$e = Object.prototype;
      var hasOwnProperty$b = objectProto$e.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$e.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result2;
      }
      var objectProto$d = Object.prototype;
      var nativeObjectToString = objectProto$d.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$3 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
      }
      function arrayMap(array, iteratee2) {
        var index = -1, length = array == null ? 0 : array.length, result2 = Array(length);
        while (++index < length) {
          result2[index] = iteratee2(array[index], index, array);
        }
        return result2;
      }
      var isArray = Array.isArray;
      var INFINITY$1 = 1 / 0;
      var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY$1 ? "-0" : result2;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$1 = Function.prototype;
      var funcToString$1 = funcProto$1.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$1.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype, objectProto$c = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$a = objectProto$c.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function getValue(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      function getNative(object2, key) {
        var value = getValue(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap = getNative(root, "WeakMap");
      var objectCreate = Object.create;
      var baseCreate = /* @__PURE__ */ function() {
        function object2() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object2.prototype = proto;
          var result2 = new object2();
          object2.prototype = void 0;
          return result2;
        };
      }();
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      var setToString = shortOut(baseSetToString);
      function arrayEach(array, iteratee2) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee2(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        array.length;
        var index = fromIndex + 1;
        while (index--) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object2, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object2, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object2[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$b = Object.prototype;
      var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
      function assignValue(object2, key, value) {
        var objValue = object2[key];
        if (!(hasOwnProperty$9.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
          baseAssignValue(object2, key, value);
        }
      }
      var nativeMax$1 = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      var objectProto$a = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
        return value === proto;
      }
      function baseTimes(n, iteratee2) {
        var index = -1, result2 = Array(n);
        while (++index < n) {
          result2[index] = iteratee2(index);
        }
        return result2;
      }
      var argsTag$3 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$3;
      }
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
      var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
      typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String) : [], length = result2.length;
        for (var key in value) {
          if ((hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys(object2);
        }
        var result2 = [];
        for (var key in Object(object2)) {
          if (hasOwnProperty$6.call(object2, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function keys(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object2) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
      }
      var nativeCreate = getNative(Object, "create");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED$2 ? void 0 : result2;
        }
        return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
      }
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root, "Map");
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$1 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$2 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object2) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath(toString(value));
      }
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseGet(object2, path) {
        path = castPath(path, object2);
        var index = 0, length = path.length;
        while (object2 != null && index < length) {
          object2 = object2[toKey(path[index++])];
        }
        return index && index == length ? object2 : void 0;
      }
      function get(object2, path, defaultValue) {
        var result2 = object2 == null ? void 0 : baseGet(object2, path);
        return result2 === void 0 ? defaultValue : result2;
      }
      function arrayPush(array, values2) {
        var index = -1, length = values2.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values2[index];
        }
        return array;
      }
      var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (predicate(value)) {
            {
              arrayPush(result2, value);
            }
          } else {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array) : [];
      }
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten), func + "");
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs2 = data.__data__;
          if (!Map$1 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
            pairs2.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs2);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0; Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        {
          return buffer.slice();
        }
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function stubArray() {
        return [];
      }
      var objectProto$3 = Object.prototype;
      var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
      var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object(object2);
        return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object2);
        return isArray(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
      }
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys, getSymbols);
      }
      var DataView$1 = getNative(root, "DataView");
      var Promise$1 = getNative(root, "Promise");
      var Set$1 = getNative(root, "Set");
      var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
      var dataViewTag$3 = "[object DataView]";
      var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap);
      var getTag = baseGetTag;
      if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$3;
              case mapCtorString:
                return mapTag$4;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$4;
              case weakMapCtorString:
                return weakMapTag$1;
            }
          }
          return result2;
        };
      }
      var objectProto$2 = Object.prototype;
      var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty$2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      var Uint8Array$1 = root.Uint8Array;
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$1(result2).set(new Uint8Array$1(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = cloneArrayBuffer(dataView.buffer) ;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = cloneArrayBuffer(typedArray.buffer) ;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
      var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
      function initCloneByTag(object2, tag, isDeep) {
        var Ctor = object2.constructor;
        switch (tag) {
          case arrayBufferTag$2:
            return cloneArrayBuffer(object2);
          case boolTag$2:
          case dateTag$2:
            return new Ctor(+object2);
          case dataViewTag$2:
            return cloneDataView(object2);
          case float32Tag$1:
          case float64Tag$1:
          case int8Tag$1:
          case int16Tag$1:
          case int32Tag$1:
          case uint8Tag$1:
          case uint8ClampedTag$1:
          case uint16Tag$1:
          case uint32Tag$1:
            return cloneTypedArray(object2);
          case mapTag$3:
            return new Ctor();
          case numberTag$2:
          case stringTag$2:
            return new Ctor(object2);
          case regexpTag$2:
            return cloneRegExp(object2);
          case setTag$3:
            return new Ctor();
          case symbolTag$2:
            return cloneSymbol(object2);
        }
      }
      function initCloneObject(object2) {
        return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
      }
      var mapTag$2 = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag$2;
      }
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      var setTag$2 = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag$2;
      }
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object2, stack) {
        var result2;
        if (result2 !== void 0) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value);
          }
          if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object2) {
            result2 = isFunc ? {} : initCloneObject(value);
          } else {
            if (!cloneableTags[tag]) {
              return object2 ? value : {};
            }
            result2 = initCloneByTag(value, tag);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = getAllKeys ;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function mapToArray(map2) {
        var index = -1, result2 = Array(map2.size);
        map2.forEach(function(value, key) {
          result2[++index] = [key, value];
        });
        return result2;
      }
      function setToArray(set2) {
        var index = -1, result2 = Array(set2.size);
        set2.forEach(function(value) {
          result2[++index] = value;
        });
        return result2;
      }
      var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object2), new Uint8Array$1(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert || (convert = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack.set(object2, other);
            var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object2);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result2 = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result2;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object2)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch(object2, source, matchData, customizer) {
        var index = matchData.length, length = index;
        if (object2 == null) {
          return !length;
        }
        object2 = Object(object2);
        while (index--) {
          var data = matchData[index];
          if (data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object2[key], srcValue = data[1];
          if (data[2]) {
            if (objValue === void 0 && !(key in object2)) {
              return false;
            }
          } else {
            var stack = new Stack();
            var result2;
            if (!(result2 === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function getMatchData(object2) {
        var result2 = keys(object2), length = result2.length;
        while (length--) {
          var key = result2[length], value = object2[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object2) {
          if (object2 == null) {
            return false;
          }
          return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
        };
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object2) {
          return object2 === source || baseIsMatch(object2, source, matchData);
        };
      }
      function baseHasIn(object2, key) {
        return object2 != null && key in Object(object2);
      }
      function hasPath(object2, path, hasFunc) {
        path = castPath(path, object2);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object2 != null && hasFunc(object2, key))) {
            break;
          }
          object2 = object2[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object2 == null ? 0 : object2.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
      }
      function hasIn(object2, path) {
        return object2 != null && hasPath(object2, path, baseHasIn);
      }
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object2) {
          var objValue = get(object2, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      function basePropertyDeep(path) {
        return function(object2) {
          return baseGet(object2, path);
        };
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      var now = function() {
        return root.Date.now();
      };
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      var nativeMax = Math.max, nativeMin = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result2;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        return baseFindIndex(array, baseIteratee(predicate), index);
      }
      function fromPairs(pairs2) {
        var index = -1, length = pairs2 == null ? 0 : pairs2.length, result2 = {};
        while (++index < length) {
          var pair = pairs2[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isNil(value) {
        return value == null;
      }
      function isUndefined$1(value) {
        return value === void 0;
      }
      function baseSet(object2, path, value, customizer) {
        if (!isObject(object2)) {
          return object2;
        }
        path = castPath(path, object2);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object2;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object2;
      }
      function basePickBy(object2, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object2, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object2), value);
          }
        }
        return result2;
      }
      function basePick(object2, paths) {
        return basePickBy(object2, paths, function(value, path) {
          return hasIn(object2, path);
        });
      }
      var pick = flatRest(function(object2, paths) {
        return object2 == null ? {} : basePick(object2, paths);
      });
      var FUNC_ERROR_TEXT = "Expected a function";
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      const isUndefined = (val) => val === void 0;
      const isBoolean = (val) => typeof val === "boolean";
      const isNumber = (val) => typeof val === "number";
      const isElement = (e) => {
        if (typeof Element === "undefined")
          return false;
        return e instanceof Element;
      };
      const isPropAbsent = (prop) => {
        return isNil(prop);
      };
      const isStringNumber = (val) => {
        if (!isString(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      const escapeStringRegexp = (string = "") => string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      const capitalize = (str) => capitalize$1(str);
      const keysOf = (arr) => Object.keys(arr);
      const entriesOf = (arr) => Object.entries(arr);
      class ElementPlusError extends Error {
        constructor(m) {
          super(m);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m) {
        throw new ElementPlusError(`[${scope}] ${m}`);
      }
      function debugWarn(scope, message) {
        {
          const error = isString(scope) ? new ElementPlusError(`[${scope}] ${message}`) : scope;
          console.warn(error);
        }
      }
      const SCOPE$3 = "utils/dom/style";
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      };
      const addClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      };
      const removeClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      };
      const getStyle = (element, styleName) => {
        var _a2;
        if (!isClient || !element || !styleName)
          return "";
        let key = camelize(styleName);
        if (key === "float")
          key = "cssFloat";
        try {
          const style = element.style[key];
          if (style)
            return style;
          const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
          return computed2 ? computed2[key] : "";
        } catch (e) {
          return element.style[key];
        }
      };
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString(value)) {
          return value;
        }
        debugWarn(SCOPE$3, "binding value must be a string or number");
      }
      const isScroll = (el, isVertical) => {
        if (!isClient)
          return false;
        const key = {
          undefined: "overflow",
          true: "overflow-y",
          false: "overflow-x"
        }[String(isVertical)];
        const overflow = getStyle(el, key);
        return ["scroll", "auto", "overlay"].some((s) => overflow.includes(s));
      };
      const getScrollContainer = (el, isVertical) => {
        if (!isClient)
          return;
        let parent = el;
        while (parent) {
          if ([window, document, document.documentElement].includes(parent))
            return window;
          if (isScroll(parent, isVertical))
            return parent;
          parent = parent.parentNode;
        }
        return parent;
      };
      let scrollBarWidth;
      const getScrollBarWidth = (namespace) => {
        var _a2;
        if (!isClient)
          return 0;
        if (scrollBarWidth !== void 0)
          return scrollBarWidth;
        const outer = document.createElement("div");
        outer.className = `${namespace}-scrollbar__wrap`;
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.position = "absolute";
        outer.style.top = "-9999px";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
        scrollBarWidth = widthNoScroll - widthWithScroll;
        return scrollBarWidth;
      };
      function scrollIntoView(container, selected) {
        if (!isClient)
          return;
        if (!selected) {
          container.scrollTop = 0;
          return;
        }
        const offsetParents = [];
        let pointer = selected.offsetParent;
        while (pointer !== null && container !== pointer && container.contains(pointer)) {
          offsetParents.push(pointer);
          pointer = pointer.offsetParent;
        }
        const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
        const bottom = top + selected.offsetHeight;
        const viewRectTop = container.scrollTop;
        const viewRectBottom = viewRectTop + container.clientHeight;
        if (top < viewRectTop) {
          container.scrollTop = top;
        } else if (bottom > viewRectBottom) {
          container.scrollTop = bottom - container.clientHeight;
        }
      }
      /*! Element Plus Icons Vue v2.3.1 */
      var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "ArrowDown",
        __name: "arrow-down",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
            })
          ]));
        }
      });
      var arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default;
      var arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "ArrowLeft",
        __name: "arrow-left",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_left_default = arrow_left_vue_vue_type_script_setup_true_lang_default;
      var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "ArrowRight",
        __name: "arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_right_default = arrow_right_vue_vue_type_script_setup_true_lang_default;
      var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "ArrowUp",
        __name: "arrow-up",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
            })
          ]));
        }
      });
      var arrow_up_default = arrow_up_vue_vue_type_script_setup_true_lang_default;
      var check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "Check",
        __name: "check",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
            })
          ]));
        }
      });
      var check_default = check_vue_vue_type_script_setup_true_lang_default;
      var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "CircleCheck",
        __name: "circle-check",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
            })
          ]));
        }
      });
      var circle_check_default = circle_check_vue_vue_type_script_setup_true_lang_default;
      var circle_close_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "CircleCloseFilled",
        __name: "circle-close-filled",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
            })
          ]));
        }
      });
      var circle_close_filled_default = circle_close_filled_vue_vue_type_script_setup_true_lang_default;
      var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "CircleClose",
        __name: "circle-close",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
            }),
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      });
      var circle_close_default = circle_close_vue_vue_type_script_setup_true_lang_default;
      var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "Close",
        __name: "close",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
            })
          ]));
        }
      });
      var close_default = close_vue_vue_type_script_setup_true_lang_default;
      var delete_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "Delete",
        __name: "delete",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
            })
          ]));
        }
      });
      var delete_default = delete_vue_vue_type_script_setup_true_lang_default;
      var document_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "Document",
        __name: "document",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
            })
          ]));
        }
      });
      var document_default = document_vue_vue_type_script_setup_true_lang_default;
      var full_screen_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "FullScreen",
        __name: "full-screen",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
            })
          ]));
        }
      });
      var full_screen_default = full_screen_vue_vue_type_script_setup_true_lang_default;
      var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "Hide",
        __name: "hide",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
            }),
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
            })
          ]));
        }
      });
      var hide_default = hide_vue_vue_type_script_setup_true_lang_default;
      var info_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "InfoFilled",
        __name: "info-filled",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
            })
          ]));
        }
      });
      var info_filled_default = info_filled_vue_vue_type_script_setup_true_lang_default;
      var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "Loading",
        __name: "loading",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
            })
          ]));
        }
      });
      var loading_default = loading_vue_vue_type_script_setup_true_lang_default;
      var minus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "Minus",
        __name: "minus",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
            })
          ]));
        }
      });
      var minus_default = minus_vue_vue_type_script_setup_true_lang_default;
      var plus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "Plus",
        __name: "plus",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
            })
          ]));
        }
      });
      var plus_default = plus_vue_vue_type_script_setup_true_lang_default;
      var refresh_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "RefreshLeft",
        __name: "refresh-left",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
            })
          ]));
        }
      });
      var refresh_left_default = refresh_left_vue_vue_type_script_setup_true_lang_default;
      var refresh_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "RefreshRight",
        __name: "refresh-right",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
            })
          ]));
        }
      });
      var refresh_right_default = refresh_right_vue_vue_type_script_setup_true_lang_default;
      var scale_to_original_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "ScaleToOriginal",
        __name: "scale-to-original",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118M512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412M512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512"
            })
          ]));
        }
      });
      var scale_to_original_default = scale_to_original_vue_vue_type_script_setup_true_lang_default;
      var success_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "SuccessFilled",
        __name: "success-filled",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
            })
          ]));
        }
      });
      var success_filled_default = success_filled_vue_vue_type_script_setup_true_lang_default;
      var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "View",
        __name: "view",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
            })
          ]));
        }
      });
      var view_default = view_vue_vue_type_script_setup_true_lang_default;
      var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "WarningFilled",
        __name: "warning-filled",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
            })
          ]));
        }
      });
      var warning_filled_default = warning_filled_vue_vue_type_script_setup_true_lang_default;
      var zoom_in_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "ZoomIn",
        __name: "zoom-in",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
            })
          ]));
        }
      });
      var zoom_in_default = zoom_in_vue_vue_type_script_setup_true_lang_default;
      var zoom_out_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "ZoomOut",
        __name: "zoom-out",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
            })
          ]));
        }
      });
      var zoom_out_default = zoom_out_vue_vue_type_script_setup_true_lang_default;
      const epPropKey = "__epPropKey";
      const definePropType = (val) => val;
      const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
      const buildProp = (prop, key) => {
        if (!isObject$1(prop) || isEpProp(prop))
          return prop;
        const { values: values2, required, default: defaultValue, type, validator } = prop;
        const _validator = values2 || validator ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values2) {
            allowedValues = Array.from(values2);
            if (hasOwn(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator)
            valid || (valid = validator(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            vue.warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type,
          required: !!required,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      };
      const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
        key,
        buildProp(option, key)
      ]));
      const iconPropType = definePropType([
        String,
        Object,
        Function
      ]);
      const CloseComponents = {
        Close: close_default
      };
      const TypeComponents = {
        Close: close_default,
        SuccessFilled: success_filled_default,
        InfoFilled: info_filled_default,
        WarningFilled: warning_filled_default,
        CircleCloseFilled: circle_close_filled_default
      };
      const TypeComponentsMap = {
        success: success_filled_default,
        warning: warning_filled_default,
        error: circle_close_filled_default,
        info: info_filled_default
      };
      const ValidateComponentsMap = {
        validating: loading_default,
        success: circle_check_default,
        error: circle_close_default
      };
      const withInstall = (main, extra) => {
        main.install = (app2) => {
          for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
            app2.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main[key] = comp;
          }
        }
        return main;
      };
      const withInstallFunction = (fn2, name) => {
        fn2.install = (app2) => {
          fn2._context = app2._context;
          app2.config.globalProperties[name] = fn2;
        };
        return fn2;
      };
      const withNoopInstall = (component) => {
        component.install = NOOP;
        return component;
      };
      const composeRefs = (...refs) => {
        return (el) => {
          refs.forEach((ref2) => {
            if (isFunction$1(ref2)) {
              ref2(el);
            } else {
              ref2.value = el;
            }
          });
        };
      };
      const EVENT_CODE = {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        left: "ArrowLeft",
        up: "ArrowUp",
        right: "ArrowRight",
        down: "ArrowDown",
        esc: "Escape",
        delete: "Delete",
        backspace: "Backspace",
        numpadEnter: "NumpadEnter",
        pageUp: "PageUp",
        pageDown: "PageDown",
        home: "Home",
        end: "End"
      };
      const UPDATE_MODEL_EVENT = "update:modelValue";
      const CHANGE_EVENT = "change";
      const INPUT_EVENT = "input";
      const componentSizes = ["", "default", "small", "large"];
      const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
      var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
        PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
        PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
        PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
        PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
        PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
        PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
        PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
        PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
        PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
        PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
        PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
        return PatchFlags2;
      })(PatchFlags || {});
      const flattedChildren = (children) => {
        const vNodes = isArray$1(children) ? children : [children];
        const result2 = [];
        vNodes.forEach((child) => {
          var _a2;
          if (isArray$1(child)) {
            result2.push(...flattedChildren(child));
          } else if (vue.isVNode(child) && isArray$1(child.children)) {
            result2.push(...flattedChildren(child.children));
          } else {
            result2.push(child);
            if (vue.isVNode(child) && ((_a2 = child.component) == null ? void 0 : _a2.subTree)) {
              result2.push(...flattedChildren(child.component.subTree));
            }
          }
        });
        return result2;
      };
      const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
      const mutable = (val) => val;
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = vue.computed(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = vue.getCurrentInstance();
        if (!instance) {
          debugWarn("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function");
          return vue.computed(() => ({}));
        }
        return vue.computed(() => {
          var _a2;
          return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      };
      const useDeprecated = ({ from, replacement, scope, version, ref: ref2, type = "API" }, condition) => {
        vue.watch(() => vue.unref(condition), (val) => {
          if (val) {
            debugWarn(scope, `[${type}] ${from} is about to be deprecated in version ${version}, please use ${replacement} instead.
For more detail, please visit: ${ref2}
`);
          }
        }, {
          immediate: true
        });
      };
      const useDraggable = (targetRef, dragRef, draggable2, overflow) => {
        let transform = {
          offsetX: 0,
          offsetY: 0
        };
        const onMousedown = (e) => {
          const downX = e.clientX;
          const downY = e.clientY;
          const { offsetX, offsetY } = transform;
          const targetRect = targetRef.value.getBoundingClientRect();
          const targetLeft = targetRect.left;
          const targetTop = targetRect.top;
          const targetWidth = targetRect.width;
          const targetHeight = targetRect.height;
          const clientWidth = document.documentElement.clientWidth;
          const clientHeight = document.documentElement.clientHeight;
          const minLeft = -targetLeft + offsetX;
          const minTop = -targetTop + offsetY;
          const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
          const maxTop = clientHeight - targetTop - targetHeight + offsetY;
          const onMousemove = (e2) => {
            let moveX = offsetX + e2.clientX - downX;
            let moveY = offsetY + e2.clientY - downY;
            if (!(overflow == null ? void 0 : overflow.value)) {
              moveX = Math.min(Math.max(moveX, minLeft), maxLeft);
              moveY = Math.min(Math.max(moveY, minTop), maxTop);
            }
            transform = {
              offsetX: moveX,
              offsetY: moveY
            };
            if (targetRef.value) {
              targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
            }
          };
          const onMouseup = () => {
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
          };
          document.addEventListener("mousemove", onMousemove);
          document.addEventListener("mouseup", onMouseup);
        };
        const onDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.addEventListener("mousedown", onMousedown);
          }
        };
        const offDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.removeEventListener("mousedown", onMousedown);
          }
        };
        const resetPosition = () => {
          transform = {
            offsetX: 0,
            offsetY: 0
          };
          if (targetRef.value) {
            targetRef.value.style.transform = "none";
          }
        };
        vue.onMounted(() => {
          vue.watchEffect(() => {
            if (draggable2.value) {
              onDraggable();
            } else {
              offDraggable();
            }
          });
        });
        vue.onBeforeUnmount(() => {
          offDraggable();
        });
        return {
          resetPosition
        };
      };
      var English = {
        name: "en",
        el: {
          breadcrumb: {
            label: "Breadcrumb"
          },
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color.",
            alphaLabel: "pick alpha value"
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          mention: {
            loading: "Loading"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tour: {
            next: "Next",
            previous: "Previous",
            finish: "Finish"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          },
          carousel: {
            leftArrow: "Carousel arrow left",
            rightArrow: "Carousel arrow right",
            indicator: "Carousel switch to index {index}"
          }
        }
      };
      const buildTranslator = (locale) => (path, option) => translate(path, option, vue.unref(locale));
      const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
        var _a2;
        return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
      });
      const buildLocaleContext = (locale) => {
        const lang = vue.computed(() => vue.unref(locale).name);
        const localeRef = vue.isRef(locale) ? locale : vue.ref(locale);
        return {
          lang,
          locale: localeRef,
          t: buildTranslator(locale)
        };
      };
      const localeContextKey = Symbol("localeContextKey");
      const useLocale = (localeOverrides) => {
        const locale = localeOverrides || vue.inject(localeContextKey, vue.ref());
        return buildLocaleContext(vue.computed(() => locale.value || English));
      };
      const defaultNamespace = "el";
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = Symbol("namespaceContextKey");
      const useGetDerivedNamespace = (namespaceOverrides) => {
        const derivedNamespace = namespaceOverrides || (vue.getCurrentInstance() ? vue.inject(namespaceContextKey, vue.ref(defaultNamespace)) : vue.ref(defaultNamespace));
        const namespace = vue.computed(() => {
          return vue.unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      };
      const useNamespace = (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace(namespaceOverrides);
        const b = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object2) => {
          const styles = {};
          for (const key in object2) {
            if (object2[key]) {
              styles[`--${namespace.value}-${key}`] = object2[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object2) => {
          const styles = {};
          for (const key in object2) {
            if (object2[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object2[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b,
          e,
          m,
          be: be2,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      };
      const useLockscreen = (trigger, options = {}) => {
        if (!vue.isRef(trigger)) {
          throwError("[useLockscreen]", "You need to pass a ref param to this function");
        }
        const ns = options.ns || useNamespace("popup");
        const hiddenCls = vue.computed(() => ns.bm("parent", "hidden"));
        if (!isClient || hasClass(document.body, hiddenCls.value)) {
          return;
        }
        let scrollBarWidth2 = 0;
        let withoutHiddenClass = false;
        let bodyWidth = "0";
        const cleanup = () => {
          setTimeout(() => {
            if (typeof document === "undefined")
              return;
            removeClass(document == null ? void 0 : document.body, hiddenCls.value);
            if (withoutHiddenClass && document) {
              document.body.style.width = bodyWidth;
            }
          }, 200);
        };
        vue.watch(trigger, (val) => {
          if (!val) {
            cleanup();
            return;
          }
          withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            bodyWidth = document.body.style.width;
          }
          scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle(document.body, "overflowY");
          if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
            document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
          }
          addClass(document.body, hiddenCls.value);
        });
        vue.onScopeDispose(() => cleanup());
      };
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = vue.getCurrentInstance();
          const { emit } = instance;
          const props = instance.props;
          const hasUpdateHandler = vue.computed(() => isFunction$1(props[updateEventKeyRaw]));
          const isModelBindingAbsent = vue.computed(() => props[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props.disabled === true || !isClient)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean(val))
              return;
            if (props.disabled && val) {
              if (hasUpdateHandler.value) {
                emit(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          vue.watch(() => props[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            vue.watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          vue.onMounted(() => {
            onChange(props[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      };
      const useProp = (name) => {
        const vm = vue.getCurrentInstance();
        return vue.computed(() => {
          var _a2, _b;
          return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
        });
      };
      var E = "top", R = "bottom", W = "right", P = "left", me = "auto", G = [E, R, W, P], U = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
        return t.concat([e + "-" + U, e + "-" + J]);
      }, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
        return t.concat([e, e + "-" + U, e + "-" + J]);
      }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
      function C(t) {
        return t ? (t.nodeName || "").toLowerCase() : null;
      }
      function H(t) {
        if (t == null) return window;
        if (t.toString() !== "[object Window]") {
          var e = t.ownerDocument;
          return e && e.defaultView || window;
        }
        return t;
      }
      function Q(t) {
        var e = H(t).Element;
        return t instanceof e || t instanceof Element;
      }
      function B(t) {
        var e = H(t).HTMLElement;
        return t instanceof e || t instanceof HTMLElement;
      }
      function Pe(t) {
        if (typeof ShadowRoot == "undefined") return false;
        var e = H(t).ShadowRoot;
        return t instanceof e || t instanceof ShadowRoot;
      }
      function Mt(t) {
        var e = t.state;
        Object.keys(e.elements).forEach(function(n) {
          var r = e.styles[n] || {}, o = e.attributes[n] || {}, i = e.elements[n];
          !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function(a) {
            var s = o[a];
            s === false ? i.removeAttribute(a) : i.setAttribute(a, s === true ? "" : s);
          }));
        });
      }
      function Rt(t) {
        var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
          Object.keys(e.elements).forEach(function(r) {
            var o = e.elements[r], i = e.attributes[r] || {}, a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s = a.reduce(function(f, c) {
              return f[c] = "", f;
            }, {});
            !B(o) || !C(o) || (Object.assign(o.style, s), Object.keys(i).forEach(function(f) {
              o.removeAttribute(f);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
      function q(t) {
        return t.split("-")[0];
      }
      var X = Math.max, ve = Math.min, Z = Math.round;
      function ee(t, e) {
        e === void 0 && (e = false);
        var n = t.getBoundingClientRect(), r = 1, o = 1;
        if (B(t) && e) {
          var i = t.offsetHeight, a = t.offsetWidth;
          a > 0 && (r = Z(n.width) / a || 1), i > 0 && (o = Z(n.height) / i || 1);
        }
        return { width: n.width / r, height: n.height / o, top: n.top / o, right: n.right / r, bottom: n.bottom / o, left: n.left / r, x: n.left / r, y: n.top / o };
      }
      function ke(t) {
        var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
        return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
      }
      function it(t, e) {
        var n = e.getRootNode && e.getRootNode();
        if (t.contains(e)) return true;
        if (n && Pe(n)) {
          var r = e;
          do {
            if (r && t.isSameNode(r)) return true;
            r = r.parentNode || r.host;
          } while (r);
        }
        return false;
      }
      function N(t) {
        return H(t).getComputedStyle(t);
      }
      function Wt(t) {
        return ["table", "td", "th"].indexOf(C(t)) >= 0;
      }
      function I(t) {
        return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
      }
      function ge(t) {
        return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I(t);
      }
      function at(t) {
        return !B(t) || N(t).position === "fixed" ? null : t.offsetParent;
      }
      function Bt(t) {
        var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
        if (n && B(t)) {
          var r = N(t);
          if (r.position === "fixed") return null;
        }
        var o = ge(t);
        for (Pe(o) && (o = o.host); B(o) && ["html", "body"].indexOf(C(o)) < 0; ) {
          var i = N(o);
          if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none") return o;
          o = o.parentNode;
        }
        return null;
      }
      function se(t) {
        for (var e = H(t), n = at(t); n && Wt(n) && N(n).position === "static"; ) n = at(n);
        return n && (C(n) === "html" || C(n) === "body" && N(n).position === "static") ? e : n || Bt(t) || e;
      }
      function Le(t) {
        return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
      }
      function fe(t, e, n) {
        return X(t, ve(e, n));
      }
      function St(t, e, n) {
        var r = fe(t, e, n);
        return r > n ? n : r;
      }
      function st() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft(t) {
        return Object.assign({}, st(), t);
      }
      function ct(t, e) {
        return e.reduce(function(n, r) {
          return n[r] = t, n;
        }, {});
      }
      var Tt = function(t, e) {
        return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
      };
      function Ht(t) {
        var e, n = t.state, r = t.name, o = t.options, i = n.elements.arrow, a = n.modifiersData.popperOffsets, s = q(n.placement), f = Le(s), c = [P, W].indexOf(s) >= 0, u = c ? "height" : "width";
        if (!(!i || !a)) {
          var m = Tt(o.padding, n), v = ke(i), l = f === "y" ? E : P, h2 = f === "y" ? R : W, p = n.rects.reference[u] + n.rects.reference[f] - a[f] - n.rects.popper[u], g = a[f] - n.rects.reference[f], x = se(i), y = x ? f === "y" ? x.clientHeight || 0 : x.clientWidth || 0 : 0, $ = p / 2 - g / 2, d = m[l], b = y - v[u] - m[h2], w = y / 2 - v[u] / 2 + $, O = fe(d, w, b), j = f;
          n.modifiersData[r] = (e = {}, e[j] = O, e.centerOffset = O - w, e);
        }
      }
      function Ct(t) {
        var e = t.state, n = t.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r;
        o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || !it(e.elements.popper, o) || (e.elements.arrow = o));
      }
      var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t) {
        return t.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t) {
        var e = t.x, n = t.y, r = window, o = r.devicePixelRatio || 1;
        return { x: Z(e * o) / o || 0, y: Z(n * o) / o || 0 };
      }
      function ut(t) {
        var e, n = t.popper, r = t.popperRect, o = t.placement, i = t.variation, a = t.offsets, s = t.position, f = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, m = t.isFixed, v = a.x, l = v === void 0 ? 0 : v, h2 = a.y, p = h2 === void 0 ? 0 : h2, g = typeof u == "function" ? u({ x: l, y: p }) : { x: l, y: p };
        l = g.x, p = g.y;
        var x = a.hasOwnProperty("x"), y = a.hasOwnProperty("y"), $ = P, d = E, b = window;
        if (c) {
          var w = se(n), O = "clientHeight", j = "clientWidth";
          if (w === H(n) && (w = I(n), N(w).position !== "static" && s === "absolute" && (O = "scrollHeight", j = "scrollWidth")), w = w, o === E || (o === P || o === W) && i === J) {
            d = R;
            var A = m && w === b && b.visualViewport ? b.visualViewport.height : w[O];
            p -= A - r.height, p *= f ? 1 : -1;
          }
          if (o === P || (o === E || o === R) && i === J) {
            $ = W;
            var k = m && w === b && b.visualViewport ? b.visualViewport.width : w[j];
            l -= k - r.width, l *= f ? 1 : -1;
          }
        }
        var D = Object.assign({ position: s }, c && qt), S = u === true ? Vt({ x: l, y: p }) : { x: l, y: p };
        if (l = S.x, p = S.y, f) {
          var L;
          return Object.assign({}, D, (L = {}, L[d] = y ? "0" : "", L[$] = x ? "0" : "", L.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + l + "px, " + p + "px)" : "translate3d(" + l + "px, " + p + "px, 0)", L));
        }
        return Object.assign({}, D, (e = {}, e[d] = y ? p + "px" : "", e[$] = x ? l + "px" : "", e.transform = "", e));
      }
      function Nt(t) {
        var e = t.state, n = t.options, r = n.gpuAcceleration, o = r === void 0 ? true : r, i = n.adaptive, a = i === void 0 ? true : i, s = n.roundOffsets, f = s === void 0 ? true : s, c = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o, isFixed: e.options.strategy === "fixed" };
        e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a, roundOffsets: f })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
      function It(t) {
        var e = t.state, n = t.instance, r = t.options, o = r.scroll, i = o === void 0 ? true : o, a = r.resize, s = a === void 0 ? true : a, f = H(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
        return i && c.forEach(function(u) {
          u.addEventListener("scroll", n.update, ye);
        }), s && f.addEventListener("resize", n.update, ye), function() {
          i && c.forEach(function(u) {
            u.removeEventListener("scroll", n.update, ye);
          }), s && f.removeEventListener("resize", n.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t) {
        return t.replace(/left|right|bottom|top/g, function(e) {
          return _t[e];
        });
      }
      var zt = { start: "end", end: "start" };
      function lt(t) {
        return t.replace(/start|end/g, function(e) {
          return zt[e];
        });
      }
      function We(t) {
        var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
        return { scrollLeft: n, scrollTop: r };
      }
      function Be(t) {
        return ee(I(t)).left + We(t).scrollLeft;
      }
      function Ft(t) {
        var e = H(t), n = I(t), r = e.visualViewport, o = n.clientWidth, i = n.clientHeight, a = 0, s = 0;
        return r && (o = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, s = r.offsetTop)), { width: o, height: i, x: a + Be(t), y: s };
      }
      function Ut(t) {
        var e, n = I(t), r = We(t), o = (e = t.ownerDocument) == null ? void 0 : e.body, i = X(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), a = X(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), s = -r.scrollLeft + Be(t), f = -r.scrollTop;
        return N(o || n).direction === "rtl" && (s += X(n.clientWidth, o ? o.clientWidth : 0) - i), { width: i, height: a, x: s, y: f };
      }
      function Se(t) {
        var e = N(t), n = e.overflow, r = e.overflowX, o = e.overflowY;
        return /auto|scroll|overlay|hidden/.test(n + o + r);
      }
      function dt(t) {
        return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
      }
      function ce(t, e) {
        var n;
        e === void 0 && (e = []);
        var r = dt(t), o = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a = o ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s = e.concat(a);
        return o ? s : s.concat(ce(ge(a)));
      }
      function Te(t) {
        return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
      }
      function Xt(t) {
        var e = ee(t);
        return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
      }
      function ht(t, e) {
        return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I(t)));
      }
      function Yt(t) {
        var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N(t).position) >= 0, r = n && B(t) ? se(t) : t;
        return Q(r) ? e.filter(function(o) {
          return Q(o) && it(o, r) && C(o) !== "body";
        }) : [];
      }
      function Gt(t, e, n) {
        var r = e === "clippingParents" ? Yt(t) : [].concat(e), o = [].concat(r, [n]), i = o[0], a = o.reduce(function(s, f) {
          var c = ht(t, f);
          return s.top = X(c.top, s.top), s.right = ve(c.right, s.right), s.bottom = ve(c.bottom, s.bottom), s.left = X(c.left, s.left), s;
        }, ht(t, i));
        return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
      }
      function mt(t) {
        var e = t.reference, n = t.element, r = t.placement, o = r ? q(r) : null, i = r ? te(r) : null, a = e.x + e.width / 2 - n.width / 2, s = e.y + e.height / 2 - n.height / 2, f;
        switch (o) {
          case E:
            f = { x: a, y: e.y - n.height };
            break;
          case R:
            f = { x: a, y: e.y + e.height };
            break;
          case W:
            f = { x: e.x + e.width, y: s };
            break;
          case P:
            f = { x: e.x - n.width, y: s };
            break;
          default:
            f = { x: e.x, y: e.y };
        }
        var c = o ? Le(o) : null;
        if (c != null) {
          var u = c === "y" ? "height" : "width";
          switch (i) {
            case U:
              f[c] = f[c] - (e[u] / 2 - n[u] / 2);
              break;
            case J:
              f[c] = f[c] + (e[u] / 2 - n[u] / 2);
              break;
          }
        }
        return f;
      }
      function ne(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o = r === void 0 ? t.placement : r, i = n.boundary, a = i === void 0 ? Xe : i, s = n.rootBoundary, f = s === void 0 ? je : s, c = n.elementContext, u = c === void 0 ? K : c, m = n.altBoundary, v = m === void 0 ? false : m, l = n.padding, h2 = l === void 0 ? 0 : l, p = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u === K ? Ye : K, x = t.rects.popper, y = t.elements[v ? g : u], $ = Gt(Q(y) ? y : y.contextElement || I(t.elements.popper), a, f), d = ee(t.elements.reference), b = mt({ reference: d, element: x, strategy: "absolute", placement: o }), w = Te(Object.assign({}, x, b)), O = u === K ? w : d, j = { top: $.top - O.top + p.top, bottom: O.bottom - $.bottom + p.bottom, left: $.left - O.left + p.left, right: O.right - $.right + p.right }, A = t.modifiersData.offset;
        if (u === K && A) {
          var k = A[o];
          Object.keys(j).forEach(function(D) {
            var S = [W, R].indexOf(D) >= 0 ? 1 : -1, L = [E, R].indexOf(D) >= 0 ? "y" : "x";
            j[D] += k[L] * S;
          });
        }
        return j;
      }
      function Jt(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o = n.boundary, i = n.rootBoundary, a = n.padding, s = n.flipVariations, f = n.allowedAutoPlacements, c = f === void 0 ? Ee : f, u = te(r), m = u ? s ? De : De.filter(function(h2) {
          return te(h2) === u;
        }) : G, v = m.filter(function(h2) {
          return c.indexOf(h2) >= 0;
        });
        v.length === 0 && (v = m);
        var l = v.reduce(function(h2, p) {
          return h2[p] = ne(t, { placement: p, boundary: o, rootBoundary: i, padding: a })[q(p)], h2;
        }, {});
        return Object.keys(l).sort(function(h2, p) {
          return l[h2] - l[p];
        });
      }
      function Kt(t) {
        if (q(t) === me) return [];
        var e = be(t);
        return [lt(t), e, lt(e)];
      }
      function Qt(t) {
        var e = t.state, n = t.options, r = t.name;
        if (!e.modifiersData[r]._skip) {
          for (var o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? true : a, f = n.fallbackPlacements, c = n.padding, u = n.boundary, m = n.rootBoundary, v = n.altBoundary, l = n.flipVariations, h2 = l === void 0 ? true : l, p = n.allowedAutoPlacements, g = e.options.placement, x = q(g), y = x === g, $ = f || (y || !h2 ? [be(g)] : Kt(g)), d = [g].concat($).reduce(function(z, V) {
            return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u, rootBoundary: m, padding: c, flipVariations: h2, allowedAutoPlacements: p }) : V);
          }, []), b = e.rects.reference, w = e.rects.popper, O = /* @__PURE__ */ new Map(), j = true, A = d[0], k = 0; k < d.length; k++) {
            var D = d[k], S = q(D), L = te(D) === U, re = [E, R].indexOf(S) >= 0, oe = re ? "width" : "height", M = ne(e, { placement: D, boundary: u, rootBoundary: m, altBoundary: v, padding: c }), T = re ? L ? W : P : L ? R : E;
            b[oe] > w[oe] && (T = be(T));
            var pe = be(T), _2 = [];
            if (i && _2.push(M[S] <= 0), s && _2.push(M[T] <= 0, M[pe] <= 0), _2.every(function(z) {
              return z;
            })) {
              A = D, j = false;
              break;
            }
            O.set(D, _2);
          }
          if (j) for (var ue = h2 ? 3 : 1, xe = function(z) {
            var V = d.find(function(de) {
              var ae = O.get(de);
              if (ae) return ae.slice(0, z).every(function(Y) {
                return Y;
              });
            });
            if (V) return A = V, "break";
          }, ie = ue; ie > 0; ie--) {
            var le = xe(ie);
            if (le === "break") break;
          }
          e.placement !== A && (e.modifiersData[r]._skip = true, e.placement = A, e.reset = true);
        }
      }
      var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt(t, e, n) {
        return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
      }
      function yt(t) {
        return [E, W, R, P].some(function(e) {
          return t[e] >= 0;
        });
      }
      function Zt(t) {
        var e = t.state, n = t.name, r = e.rects.reference, o = e.rects.popper, i = e.modifiersData.preventOverflow, a = ne(e, { elementContext: "reference" }), s = ne(e, { altBoundary: true }), f = gt(a, r), c = gt(s, o, i), u = yt(f), m = yt(c);
        e.modifiersData[n] = { referenceClippingOffsets: f, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: m }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": m });
      }
      var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t, e, n) {
        var r = q(t), o = [P, E].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a = i[0], s = i[1];
        return a = a || 0, s = (s || 0) * o, [P, W].indexOf(r) >= 0 ? { x: s, y: a } : { x: a, y: s };
      }
      function tn(t) {
        var e = t.state, n = t.options, r = t.name, o = n.offset, i = o === void 0 ? [0, 0] : o, a = Ee.reduce(function(u, m) {
          return u[m] = en(m, e.rects, i), u;
        }, {}), s = a[e.placement], f = s.x, c = s.y;
        e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = a;
      }
      var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t) {
        var e = t.state, n = t.name;
        e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t) {
        return t === "x" ? "y" : "x";
      }
      function on(t) {
        var e = t.state, n = t.options, r = t.name, o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? false : a, f = n.boundary, c = n.rootBoundary, u = n.altBoundary, m = n.padding, v = n.tether, l = v === void 0 ? true : v, h2 = n.tetherOffset, p = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f, rootBoundary: c, padding: m, altBoundary: u }), x = q(e.placement), y = te(e.placement), $ = !y, d = Le(x), b = rn(d), w = e.modifiersData.popperOffsets, O = e.rects.reference, j = e.rects.popper, A = typeof p == "function" ? p(Object.assign({}, e.rects, { placement: e.placement })) : p, k = typeof A == "number" ? { mainAxis: A, altAxis: A } : Object.assign({ mainAxis: 0, altAxis: 0 }, A), D = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S = { x: 0, y: 0 };
        if (w) {
          if (i) {
            var L, re = d === "y" ? E : P, oe = d === "y" ? R : W, M = d === "y" ? "height" : "width", T = w[d], pe = T + g[re], _2 = T - g[oe], ue = l ? -j[M] / 2 : 0, xe = y === U ? O[M] : j[M], ie = y === U ? -j[M] : -O[M], le = e.elements.arrow, z = l && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y = fe(0, O[M], z[M]), jt = $ ? O[M] / 2 - ue - Y - de - k.mainAxis : xe - Y - de - k.mainAxis, Dt = $ ? -O[M] / 2 + ue + Y + ae + k.mainAxis : ie + Y + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D == null ? void 0 : D[d]) != null ? L : 0, Pt = T + jt - Ce - Et, At = T + Dt - Ce, qe = fe(l ? ve(pe, Pt) : pe, T, l ? X(_2, At) : _2);
            w[d] = qe, S[d] = qe - T;
          }
          if (s) {
            var Ve, kt = d === "x" ? E : P, Lt = d === "x" ? R : W, F = w[b], he = b === "y" ? "height" : "width", Ne = F + g[kt], Ie = F - g[Lt], $e = [E, P].indexOf(x) !== -1, _e = (Ve = D == null ? void 0 : D[b]) != null ? Ve : 0, ze = $e ? Ne : F - O[he] - j[he] - _e + k.altAxis, Fe = $e ? F + O[he] + j[he] - _e - k.altAxis : Ie, Ue = l && $e ? St(ze, F, Fe) : fe(l ? ze : Ne, F, l ? Fe : Ie);
            w[b] = Ue, S[b] = Ue - F;
          }
          e.modifiersData[r] = S;
        }
      }
      var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t) {
        return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
      }
      function sn(t) {
        return t === H(t) || !B(t) ? We(t) : an(t);
      }
      function fn(t) {
        var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
        return n !== 1 || r !== 1;
      }
      function cn(t, e, n) {
        n === void 0 && (n = false);
        var r = B(e), o = B(e) && fn(e), i = I(e), a = ee(t, o), s = { scrollLeft: 0, scrollTop: 0 }, f = { x: 0, y: 0 };
        return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s = sn(e)), B(e) ? (f = ee(e, true), f.x += e.clientLeft, f.y += e.clientTop) : i && (f.x = Be(i))), { x: a.left + s.scrollLeft - f.x, y: a.top + s.scrollTop - f.y, width: a.width, height: a.height };
      }
      function pn(t) {
        var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
        t.forEach(function(i) {
          e.set(i.name, i);
        });
        function o(i) {
          n.add(i.name);
          var a = [].concat(i.requires || [], i.requiresIfExists || []);
          a.forEach(function(s) {
            if (!n.has(s)) {
              var f = e.get(s);
              f && o(f);
            }
          }), r.push(i);
        }
        return t.forEach(function(i) {
          n.has(i.name) || o(i);
        }), r;
      }
      function un(t) {
        var e = pn(t);
        return ot.reduce(function(n, r) {
          return n.concat(e.filter(function(o) {
            return o.phase === r;
          }));
        }, []);
      }
      function ln(t) {
        var e;
        return function() {
          return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
              e = void 0, n(t());
            });
          })), e;
        };
      }
      function dn(t) {
        var e = t.reduce(function(n, r) {
          var o = n[r.name];
          return n[r.name] = o ? Object.assign({}, o, r, { options: Object.assign({}, o.options, r.options), data: Object.assign({}, o.data, r.data) }) : r, n;
        }, {});
        return Object.keys(e).map(function(n) {
          return e[n];
        });
      }
      var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
        return !e.some(function(r) {
          return !(r && typeof r.getBoundingClientRect == "function");
        });
      }
      function we(t) {
        t === void 0 && (t = {});
        var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o = e.defaultOptions, i = o === void 0 ? Ot : o;
        return function(a, s, f) {
          f === void 0 && (f = i);
          var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a, popper: s }, attributes: {}, styles: {} }, u = [], m = false, v = { state: c, setOptions: function(p) {
            var g = typeof p == "function" ? p(c.options) : p;
            h2(), c.options = Object.assign({}, i, c.options, g), c.scrollParents = { reference: Q(a) ? ce(a) : a.contextElement ? ce(a.contextElement) : [], popper: ce(s) };
            var x = un(dn([].concat(r, c.options.modifiers)));
            return c.orderedModifiers = x.filter(function(y) {
              return y.enabled;
            }), l(), v.update();
          }, forceUpdate: function() {
            if (!m) {
              var p = c.elements, g = p.reference, x = p.popper;
              if ($t(g, x)) {
                c.rects = { reference: cn(g, se(x), c.options.strategy === "fixed"), popper: ke(x) }, c.reset = false, c.placement = c.options.placement, c.orderedModifiers.forEach(function(j) {
                  return c.modifiersData[j.name] = Object.assign({}, j.data);
                });
                for (var y = 0; y < c.orderedModifiers.length; y++) {
                  if (c.reset === true) {
                    c.reset = false, y = -1;
                    continue;
                  }
                  var $ = c.orderedModifiers[y], d = $.fn, b = $.options, w = b === void 0 ? {} : b, O = $.name;
                  typeof d == "function" && (c = d({ state: c, options: w, name: O, instance: v }) || c);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p) {
              v.forceUpdate(), p(c);
            });
          }), destroy: function() {
            h2(), m = true;
          } };
          if (!$t(a, s)) return v;
          v.setOptions(f).then(function(p) {
            !m && f.onFirstUpdate && f.onFirstUpdate(p);
          });
          function l() {
            c.orderedModifiers.forEach(function(p) {
              var g = p.name, x = p.options, y = x === void 0 ? {} : x, $ = p.effect;
              if (typeof $ == "function") {
                var d = $({ state: c, name: g, instance: v, options: y }), b = function() {
                };
                u.push(d || b);
              }
            });
          }
          function h2() {
            u.forEach(function(p) {
              return p();
            }), u = [];
          }
          return v;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
      const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options = vue.computed(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = vue.unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = vue.shallowRef();
        const states = vue.ref({
          styles: {
            popper: {
              position: vue.unref(options).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        vue.watch(options, (newOptions) => {
          const instance = vue.unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        vue.watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, vue.unref(options));
        });
        vue.onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: vue.computed(() => {
            var _a2;
            return { ...((_a2 = vue.unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
          }),
          styles: vue.computed(() => vue.unref(states).styles),
          attributes: vue.computed(() => vue.unref(states).attributes),
          update: () => {
            var _a2;
            return (_a2 = vue.unref(instanceRef)) == null ? void 0 : _a2.update();
          },
          forceUpdate: () => {
            var _a2;
            return (_a2 = vue.unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
          },
          instanceRef: vue.computed(() => vue.unref(instanceRef))
        };
      };
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes
        };
      }
      const useSameTarget = (handleClick) => {
        if (!handleClick) {
          return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
        }
        let mousedownTarget = false;
        let mouseupTarget = false;
        const onClick = (e) => {
          if (mousedownTarget && mouseupTarget) {
            handleClick(e);
          }
          mousedownTarget = mouseupTarget = false;
        };
        const onMousedown = (e) => {
          mousedownTarget = e.target === e.currentTarget;
        };
        const onMouseup = (e) => {
          mouseupTarget = e.target === e.currentTarget;
        };
        return { onClick, onMousedown, onMouseup };
      };
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay2) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay2);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = Symbol("elIdInjection");
      const useIdInjection = () => {
        return vue.getCurrentInstance() ? vue.inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      };
      const useId = (deterministicId) => {
        const idInjection = useIdInjection();
        if (!isClient && idInjection === defaultIdInjection) {
          debugWarn("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
        }
        const namespace = useGetDerivedNamespace();
        const idRef = vue.computed(() => vue.unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      };
      let registeredEscapeHandlers = [];
      const cachedHandler = (e) => {
        const event = e;
        if (event.key === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = (handler) => {
        vue.onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient)
            registeredEscapeHandlers.push(handler);
        });
        vue.onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      };
      const usePopperContainerId = () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id = vue.computed(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = vue.computed(() => `#${id.value}`);
        return {
          id,
          selector
        };
      };
      const createContainer = (id) => {
        const container = document.createElement("div");
        container.id = id;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = () => {
        const { id, selector } = usePopperContainerId();
        vue.onBeforeMount(() => {
          if (!isClient)
            return;
          if (!document.body.querySelector(selector.value)) {
            createContainer(id.value);
          }
        });
        return {
          id,
          selector
        };
      };
      const useDelayedToggleProps = buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      });
      const useDelayedToggle = ({
        showAfter,
        hideAfter,
        autoClose,
        open: open2,
        close: close2
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open2(event);
            const _autoClose = vue.unref(autoClose);
            if (isNumber(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close2(event);
              }, _autoClose);
            }
          }, vue.unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close2(event);
          }, vue.unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      };
      const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
      const useForwardRef = (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        vue.provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      };
      const useForwardRefDirective = (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      };
      const initial = {
        current: 0
      };
      const zIndex = vue.ref(0);
      const defaultInitialZIndex = 2e3;
      const ZINDEX_INJECTION_KEY = Symbol("elZIndexContextKey");
      const zIndexContextKey = Symbol("zIndexContextKey");
      const useZIndex = (zIndexOverrides) => {
        const increasingInjection = vue.getCurrentInstance() ? vue.inject(ZINDEX_INJECTION_KEY, initial) : initial;
        const zIndexInjection = zIndexOverrides || (vue.getCurrentInstance() ? vue.inject(zIndexContextKey, void 0) : void 0);
        const initialZIndex = vue.computed(() => {
          const zIndexFromInjection = vue.unref(zIndexInjection);
          return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = vue.computed(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          increasingInjection.current++;
          zIndex.value = increasingInjection.current;
          return currentZIndex.value;
        };
        if (!isClient && !vue.inject(ZINDEX_INJECTION_KEY)) {
          debugWarn("ZIndexInjection", `Looks like you are using server rendering, you must provide a z-index provider to ensure the hydration process to be succeed
usage: app.provide(ZINDEX_INJECTION_KEY, { current: 0 })`);
        }
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      };
      function useCursor(input) {
        let selectionInfo;
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionInfo = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionInfo == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionInfo;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      const getOrderedChildren = (vm, childComponentName, children) => {
        const nodes = flattedChildren(vm.subTree).filter((n) => {
          var _a2;
          return vue.isVNode(n) && ((_a2 = n.type) == null ? void 0 : _a2.name) === childComponentName && !!n.component;
        });
        const uids = nodes.map((n) => n.component.uid);
        return uids.map((uid) => children[uid]).filter((p) => !!p);
      };
      const useOrderedChildren = (vm, childComponentName) => {
        const children = {};
        const orderedChildren = vue.shallowRef([]);
        const addChild = (child) => {
          children[child.uid] = child;
          orderedChildren.value = getOrderedChildren(vm, childComponentName, children);
        };
        const removeChild = (uid) => {
          delete children[uid];
          orderedChildren.value = orderedChildren.value.filter((children2) => children2.uid !== uid);
        };
        return {
          children: orderedChildren,
          addChild,
          removeChild
        };
      };
      const useSizeProp = buildProp({
        type: String,
        values: componentSizes,
        required: false
      });
      const SIZE_INJECTION_KEY = Symbol("size");
      const useGlobalSize = () => {
        const injectedSize = vue.inject(SIZE_INJECTION_KEY, {});
        return vue.computed(() => {
          return vue.unref(injectedSize.size) || "";
        });
      };
      function useFocusController(target, {
        beforeFocus,
        afterFocus,
        beforeBlur,
        afterBlur
      } = {}) {
        const instance = vue.getCurrentInstance();
        const { emit } = instance;
        const wrapperRef = vue.shallowRef();
        const isFocused = vue.ref(false);
        const handleFocus = (event) => {
          const cancelFocus = isFunction$1(beforeFocus) ? beforeFocus(event) : false;
          if (cancelFocus || isFocused.value)
            return;
          isFocused.value = true;
          emit("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a2;
          const cancelBlur = isFunction$1(beforeBlur) ? beforeBlur(event) : false;
          if (cancelBlur || event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
            return;
          isFocused.value = false;
          emit("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = () => {
          var _a2, _b;
          if (((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(document.activeElement)) && wrapperRef.value !== document.activeElement)
            return;
          (_b = target.value) == null ? void 0 : _b.focus();
        };
        vue.watch(wrapperRef, (el) => {
          if (el) {
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener(wrapperRef, "focus", handleFocus, true);
        useEventListener(wrapperRef, "blur", handleBlur, true);
        useEventListener(wrapperRef, "click", handleClick, true);
        return {
          isFocused,
          wrapperRef,
          handleFocus,
          handleBlur
        };
      }
      function useComposition({
        afterComposition,
        emit
      }) {
        const isComposing = vue.ref(false);
        const handleCompositionStart = (event) => {
          emit == null ? void 0 : emit("compositionstart", event);
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          var _a2;
          emit == null ? void 0 : emit("compositionupdate", event);
          const text = (_a2 = event.target) == null ? void 0 : _a2.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          emit == null ? void 0 : emit("compositionend", event);
          if (isComposing.value) {
            isComposing.value = false;
            vue.nextTick(() => afterComposition(event));
          }
        };
        const handleComposition = (event) => {
          event.type === "compositionend" ? handleCompositionEnd(event) : handleCompositionUpdate(event);
        };
        return {
          isComposing,
          handleComposition,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      const emptyValuesContextKey = Symbol("emptyValuesContextKey");
      const SCOPE$2 = "use-empty-values";
      const DEFAULT_EMPTY_VALUES = ["", void 0, null];
      const DEFAULT_VALUE_ON_CLEAR = void 0;
      const useEmptyValuesProps = buildProps({
        emptyValues: Array,
        valueOnClear: {
          type: [String, Number, Boolean, Function],
          default: void 0,
          validator: (val) => isFunction$1(val) ? !val() : !val
        }
      });
      const useEmptyValues = (props, defaultValue) => {
        const config = vue.getCurrentInstance() ? vue.inject(emptyValuesContextKey, vue.ref({})) : vue.ref({});
        const emptyValues = vue.computed(() => props.emptyValues || config.value.emptyValues || DEFAULT_EMPTY_VALUES);
        const valueOnClear = vue.computed(() => {
          if (isFunction$1(props.valueOnClear)) {
            return props.valueOnClear();
          } else if (props.valueOnClear !== void 0) {
            return props.valueOnClear;
          } else if (isFunction$1(config.value.valueOnClear)) {
            return config.value.valueOnClear();
          } else if (config.value.valueOnClear !== void 0) {
            return config.value.valueOnClear;
          }
          return DEFAULT_VALUE_ON_CLEAR;
        });
        const isEmptyValue = (value) => {
          return emptyValues.value.includes(value);
        };
        if (!emptyValues.value.includes(valueOnClear.value)) {
          debugWarn(SCOPE$2, "value-on-clear should be a value of empty-values");
        }
        return {
          emptyValues,
          valueOnClear,
          isEmptyValue
        };
      };
      const ariaProps = buildProps({
        ariaLabel: String,
        ariaOrientation: {
          type: String,
          values: ["horizontal", "vertical", "undefined"]
        },
        ariaControls: String
      });
      const useAriaProps = (arias) => {
        return pick(ariaProps, arias);
      };
      const configProviderContextKey = Symbol();
      const globalConfig = vue.ref();
      function useGlobalConfig(key, defaultValue = void 0) {
        const config = vue.getCurrentInstance() ? vue.inject(configProviderContextKey, globalConfig) : globalConfig;
        if (key) {
          return vue.computed(() => {
            var _a2, _b;
            return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
          });
        } else {
          return config;
        }
      }
      function useGlobalComponentSettings(block, sizeFallback) {
        const config = useGlobalConfig();
        const ns = useNamespace(block, vue.computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
        }));
        const locale = useLocale(vue.computed(() => {
          var _a2;
          return (_a2 = config.value) == null ? void 0 : _a2.locale;
        }));
        const zIndex2 = useZIndex(vue.computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
        }));
        const size2 = vue.computed(() => {
          var _a2;
          return vue.unref(sizeFallback) || ((_a2 = config.value) == null ? void 0 : _a2.size) || "";
        });
        provideGlobalConfig(vue.computed(() => vue.unref(config) || {}));
        return {
          ns,
          locale,
          zIndex: zIndex2,
          size: size2
        };
      }
      const provideGlobalConfig = (config, app2, global2 = false) => {
        var _a2;
        const inSetup = !!vue.getCurrentInstance();
        const oldConfig = inSetup ? useGlobalConfig() : void 0;
        const provideFn = (_a2 = void 0) != null ? _a2 : inSetup ? vue.provide : void 0;
        if (!provideFn) {
          debugWarn("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
          return;
        }
        const context = vue.computed(() => {
          const cfg = vue.unref(config);
          if (!(oldConfig == null ? void 0 : oldConfig.value))
            return cfg;
          return mergeConfig(oldConfig.value, cfg);
        });
        provideFn(configProviderContextKey, context);
        provideFn(localeContextKey, vue.computed(() => context.value.locale));
        provideFn(namespaceContextKey, vue.computed(() => context.value.namespace));
        provideFn(zIndexContextKey, vue.computed(() => context.value.zIndex));
        provideFn(SIZE_INJECTION_KEY, {
          size: vue.computed(() => context.value.size || "")
        });
        provideFn(emptyValuesContextKey, vue.computed(() => ({
          emptyValues: context.value.emptyValues,
          valueOnClear: context.value.valueOnClear
        })));
        if (global2 || !globalConfig.value) {
          globalConfig.value = context.value;
        }
        return context;
      };
      const mergeConfig = (a, b) => {
        const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a), ...keysOf(b)])];
        const obj = {};
        for (const key of keys2) {
          obj[key] = b[key] !== void 0 ? b[key] : a[key];
        }
        return obj;
      };
      var _export_sfc = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const iconProps = buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      });
      const __default__$D = vue.defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$11 = /* @__PURE__ */ vue.defineComponent({
        ...__default__$D,
        props: iconProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("icon");
          const style = vue.computed(() => {
            const { size: size2, color } = props;
            if (!size2 && !color)
              return {};
            return {
              fontSize: isUndefined(size2) ? void 0 : addUnit(size2),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("i", vue.mergeProps({
              class: vue.unref(ns).b(),
              style: vue.unref(style)
            }, _ctx.$attrs), [
              vue.renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["__file", "icon.vue"]]);
      const ElIcon = withInstall(Icon);
      const formContextKey = Symbol("formContextKey");
      const formItemContextKey = Symbol("formItemContextKey");
      const useFormSize = (fallback, ignore = {}) => {
        const emptyRef = vue.ref(void 0);
        const size2 = ignore.prop ? emptyRef : useProp("size");
        const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : vue.inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : vue.inject(formItemContextKey, void 0);
        return vue.computed(() => size2.value || vue.unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
      };
      const useFormDisabled = (fallback) => {
        const disabled = useProp("disabled");
        const form = vue.inject(formContextKey, void 0);
        return vue.computed(() => disabled.value || vue.unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      };
      const useFormItem = () => {
        const form = vue.inject(formContextKey, void 0);
        const formItem = vue.inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      };
      const useFormItemInputId = (props, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = vue.ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = vue.ref(false);
        }
        const inputId = vue.ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = vue.computed(() => {
          var _a2;
          return !!(!(props.label || props.ariaLabel) && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
        });
        vue.onMounted(() => {
          idUnwatch = vue.watch([vue.toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
            const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        vue.onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      };
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style = window.getComputedStyle(targetElement);
        const boxSizing = style.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a2;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          document.body.appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result2 = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result2.minHeight = `${minHeight}px`;
        }
        if (isNumber(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result2.height = `${height}px`;
        (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result2;
      }
      const inputProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        maxlength: {
          type: [String, Number]
        },
        minlength: {
          type: [String, Number]
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: Boolean,
        clearable: Boolean,
        showPassword: Boolean,
        showWordLimit: Boolean,
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        },
        autofocus: Boolean,
        rows: {
          type: Number,
          default: 2
        },
        ...useAriaProps(["ariaLabel"])
      });
      const inputEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isString(value),
        input: (value) => isString(value),
        change: (value) => isString(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      };
      const __default__$C = vue.defineComponent({
        name: "ElInput",
        inheritAttrs: false
      });
      const _sfc_main$10 = /* @__PURE__ */ vue.defineComponent({
        ...__default__$C,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const rawAttrs = vue.useAttrs();
          const slots = vue.useSlots();
          const containerAttrs = vue.computed(() => {
            const comboBoxAttrs = {};
            if (props.containerRole === "combobox") {
              comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
              comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
              comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
            }
            return comboBoxAttrs;
          });
          const containerKls = vue.computed(() => [
            props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value,
              [nsInput.b("hidden")]: props.type === "hidden"
            },
            rawAttrs.class
          ]);
          const wrapperKls = vue.computed(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const attrs = useAttrs({
            excludeKeys: vue.computed(() => {
              return Object.keys(containerAttrs.value);
            })
          });
          const { form: elForm, formItem: elFormItem } = useFormItem();
          const { inputId } = useFormItemInputId(props, {
            formItemContext: elFormItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = vue.shallowRef();
          const textarea = vue.shallowRef();
          const hovering = vue.ref(false);
          const passwordVisible = vue.ref(false);
          const countStyle = vue.ref();
          const textareaCalcStyle = vue.shallowRef(props.inputStyle);
          const _ref = vue.computed(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            beforeFocus() {
              return inputDisabled.value;
            },
            afterBlur() {
              var _a2;
              if (props.validateEvent) {
                (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "blur").catch((err) => debugWarn(err));
              }
            }
          });
          const needStatusIcon = vue.computed(() => {
            var _a2;
            return (_a2 = elForm == null ? void 0 : elForm.statusIcon) != null ? _a2 : false;
          });
          const validateState = vue.computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
          const validateIcon = vue.computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = vue.computed(() => passwordVisible.value ? view_default : hide_default);
          const containerStyle = vue.computed(() => [
            rawAttrs.style
          ]);
          const textareaStyle = vue.computed(() => [
            props.inputStyle,
            textareaCalcStyle.value,
            { resize: props.resize }
          ]);
          const nativeInputValue = vue.computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
          const showClear = vue.computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = vue.computed(() => props.showPassword && !inputDisabled.value && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
          const isWordLimitVisible = vue.computed(() => props.showWordLimit && !!props.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
          const textLength = vue.computed(() => nativeInputValue.value.length);
          const inputExceed = vue.computed(() => !!isWordLimitVisible.value && textLength.value > Number(props.maxlength));
          const suffixVisible = vue.computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type, autosize } = props;
            if (!isClient || type !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              vue.nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a2;
              if (isInit || !props.autosize)
                return;
              const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props.formatter) {
              value = props.parser ? props.parser(value) : value;
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit(UPDATE_MODEL_EVENT, value);
            emit("input", value);
            await vue.nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            emit("change", event.target.value);
          };
          const {
            isComposing,
            handleCompositionStart,
            handleCompositionUpdate,
            handleCompositionEnd
          } = useComposition({ emit, afterComposition: handleInput });
          const handlePasswordVisible = () => {
            passwordVisible.value = !passwordVisible.value;
            focus();
          };
          const focus = async () => {
            var _a2;
            await vue.nextTick();
            (_a2 = _ref.value) == null ? void 0 : _a2.focus();
          };
          const blur = () => {
            var _a2;
            return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit("keydown", evt);
          };
          const select = () => {
            var _a2;
            (_a2 = _ref.value) == null ? void 0 : _a2.select();
          };
          const clear = () => {
            emit(UPDATE_MODEL_EVENT, "");
            emit("change", "");
            emit("clear");
            emit("input", "");
          };
          vue.watch(() => props.modelValue, () => {
            var _a2;
            vue.nextTick(() => resizeTextarea());
            if (props.validateEvent) {
              (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn(err));
            }
          });
          vue.watch(nativeInputValue, () => setNativeInputValue());
          vue.watch(() => props.type, async () => {
            await vue.nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          vue.onMounted(() => {
            if (!props.formatter && props.parser) {
              debugWarn("ElInput", "If you set the parser, you also need to set the formatter.");
            }
            setNativeInputValue();
            vue.nextTick(resizeTextarea);
          });
          expose({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: vue.toRef(props, "autosize"),
            isComposing,
            focus,
            blur,
            select,
            clear,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", vue.mergeProps(vue.unref(containerAttrs), {
              class: [
                vue.unref(containerKls),
                {
                  [vue.unref(nsInput).bm("group", "append")]: _ctx.$slots.append,
                  [vue.unref(nsInput).bm("group", "prepend")]: _ctx.$slots.prepend
                }
              ],
              style: vue.unref(containerStyle),
              role: _ctx.containerRole,
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }), [
              vue.createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                vue.createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (vue.openBlock(), vue.createElementBlock("div", {
                  key: 0,
                  class: vue.normalizeClass(vue.unref(nsInput).be("group", "prepend"))
                }, [
                  vue.renderSlot(_ctx.$slots, "prepend")
                ], 2)) : vue.createCommentVNode("v-if", true),
                vue.createElementVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: vue.normalizeClass(vue.unref(wrapperKls))
                }, [
                  vue.createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (vue.openBlock(), vue.createElementBlock("span", {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(nsInput).e("prefix"))
                  }, [
                    vue.createElementVNode("span", {
                      class: vue.normalizeClass(vue.unref(nsInput).e("prefix-inner"))
                    }, [
                      vue.renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                        key: 0,
                        class: vue.normalizeClass(vue.unref(nsInput).e("icon"))
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : vue.createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("input", vue.mergeProps({
                    id: vue.unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: vue.unref(nsInput).e("inner")
                  }, vue.unref(attrs), {
                    minlength: _ctx.minlength,
                    maxlength: _ctx.maxlength,
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: vue.unref(inputDisabled),
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.ariaLabel,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: _ctx.form,
                    autofocus: _ctx.autofocus,
                    onCompositionstart: vue.unref(handleCompositionStart),
                    onCompositionupdate: vue.unref(handleCompositionUpdate),
                    onCompositionend: vue.unref(handleCompositionEnd),
                    onInput: handleInput,
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus", "onCompositionstart", "onCompositionupdate", "onCompositionend"]),
                  vue.createCommentVNode(" suffix slot "),
                  vue.unref(suffixVisible) ? (vue.openBlock(), vue.createElementBlock("span", {
                    key: 1,
                    class: vue.normalizeClass(vue.unref(nsInput).e("suffix"))
                  }, [
                    vue.createElementVNode("span", {
                      class: vue.normalizeClass(vue.unref(nsInput).e("suffix-inner"))
                    }, [
                      !vue.unref(showClear) || !vue.unref(showPwdVisible) || !vue.unref(isWordLimitVisible) ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                        vue.renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                          key: 0,
                          class: vue.normalizeClass(vue.unref(nsInput).e("icon"))
                        }, {
                          default: vue.withCtx(() => [
                            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : vue.createCommentVNode("v-if", true)
                      ], 64)) : vue.createCommentVNode("v-if", true),
                      vue.unref(showClear) ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                        key: 1,
                        class: vue.normalizeClass([vue.unref(nsInput).e("icon"), vue.unref(nsInput).e("clear")]),
                        onMousedown: vue.withModifiers(vue.unref(NOOP), ["prevent"]),
                        onClick: clear
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(vue.unref(circle_close_default))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : vue.createCommentVNode("v-if", true),
                      vue.unref(showPwdVisible) ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                        key: 2,
                        class: vue.normalizeClass([vue.unref(nsInput).e("icon"), vue.unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : vue.createCommentVNode("v-if", true),
                      vue.unref(isWordLimitVisible) ? (vue.openBlock(), vue.createElementBlock("span", {
                        key: 3,
                        class: vue.normalizeClass(vue.unref(nsInput).e("count"))
                      }, [
                        vue.createElementVNode("span", {
                          class: vue.normalizeClass(vue.unref(nsInput).e("count-inner"))
                        }, vue.toDisplayString(vue.unref(textLength)) + " / " + vue.toDisplayString(_ctx.maxlength), 3)
                      ], 2)) : vue.createCommentVNode("v-if", true),
                      vue.unref(validateState) && vue.unref(validateIcon) && vue.unref(needStatusIcon) ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                        key: 4,
                        class: vue.normalizeClass([
                          vue.unref(nsInput).e("icon"),
                          vue.unref(nsInput).e("validateIcon"),
                          vue.unref(nsInput).is("loading", vue.unref(validateState) === "validating")
                        ])
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : vue.createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : vue.createCommentVNode("v-if", true)
                ], 2),
                vue.createCommentVNode(" append slot "),
                _ctx.$slots.append ? (vue.openBlock(), vue.createElementBlock("div", {
                  key: 1,
                  class: vue.normalizeClass(vue.unref(nsInput).be("group", "append"))
                }, [
                  vue.renderSlot(_ctx.$slots, "append")
                ], 2)) : vue.createCommentVNode("v-if", true)
              ], 64)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                vue.createCommentVNode(" textarea "),
                vue.createElementVNode("textarea", vue.mergeProps({
                  id: vue.unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: [vue.unref(nsTextarea).e("inner"), vue.unref(nsInput).is("focus", vue.unref(isFocused))]
                }, vue.unref(attrs), {
                  minlength: _ctx.minlength,
                  maxlength: _ctx.maxlength,
                  tabindex: _ctx.tabindex,
                  disabled: vue.unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: vue.unref(textareaStyle),
                  "aria-label": _ctx.ariaLabel,
                  placeholder: _ctx.placeholder,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  rows: _ctx.rows,
                  onCompositionstart: vue.unref(handleCompositionStart),
                  onCompositionupdate: vue.unref(handleCompositionUpdate),
                  onCompositionend: vue.unref(handleCompositionEnd),
                  onInput: handleInput,
                  onFocus: vue.unref(handleFocus),
                  onBlur: vue.unref(handleBlur),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus", "rows", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onFocus", "onBlur"]),
                vue.unref(isWordLimitVisible) ? (vue.openBlock(), vue.createElementBlock("span", {
                  key: 0,
                  style: vue.normalizeStyle(countStyle.value),
                  class: vue.normalizeClass(vue.unref(nsInput).e("count"))
                }, vue.toDisplayString(vue.unref(textLength)) + " / " + vue.toDisplayString(_ctx.maxlength), 7)) : vue.createCommentVNode("v-if", true)
              ], 64))
            ], 16, ["role"]);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["__file", "input.vue"]]);
      const ElInput = withInstall(Input);
      const GAP = 4;
      const BAR_MAP = {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      };
      const renderThumbStyle = ({
        move,
        size: size2,
        bar
      }) => ({
        [bar.size]: size2,
        transform: `translate${bar.axis}(${move}%)`
      });
      const scrollbarContextKey = Symbol("scrollbarContextKey");
      const thumbProps = buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      });
      const COMPONENT_NAME$7 = "Thumb";
      const _sfc_main$$ = /* @__PURE__ */ vue.defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props = __props;
          const scrollbar = vue.inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$7, "can not inject scrollbar context");
          const instance = vue.ref();
          const thumb = vue.ref();
          const thumbState = vue.ref({});
          const visible = vue.ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let originalOnSelectStart = isClient ? document.onselectstart : null;
          const bar = vue.computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = vue.computed(() => renderThumbStyle({
            size: props.size,
            move: props.move,
            bar: bar.value
          }));
          const offsetRatio = vue.computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e) => {
            var _a2;
            e.stopPropagation();
            if (e.ctrlKey || [1, 2].includes(e.button))
              return;
            (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
            startDrag(e);
            const el = e.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e) => {
            e.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          vue.onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener(vue.toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener(vue.toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.Transition, {
              name: vue.unref(ns).b("fade"),
              persisted: ""
            }, {
              default: vue.withCtx(() => [
                vue.withDirectives(vue.createElementVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: vue.normalizeClass([vue.unref(ns).e("bar"), vue.unref(ns).is(vue.unref(bar).key)]),
                  onMousedown: clickTrackHandler
                }, [
                  vue.createElementVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: vue.normalizeClass(vue.unref(ns).e("thumb")),
                    style: vue.normalizeStyle(vue.unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 34), [
                  [vue.vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["__file", "thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        minSize: {
          type: Number,
          required: true
        }
      });
      const _sfc_main$_ = /* @__PURE__ */ vue.defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose }) {
          const props = __props;
          const scrollbar = vue.inject(scrollbarContextKey);
          const moveX = vue.ref(0);
          const moveY = vue.ref(0);
          const sizeWidth = vue.ref("");
          const sizeHeight = vue.ref("");
          const ratioY = vue.ref(1);
          const ratioX = vue.ref(1);
          const handleScroll = (wrap2) => {
            if (wrap2) {
              const offsetHeight = wrap2.offsetHeight - GAP;
              const offsetWidth = wrap2.offsetWidth - GAP;
              moveY.value = wrap2.scrollTop * 100 / offsetHeight * ratioY.value;
              moveX.value = wrap2.scrollLeft * 100 / offsetWidth * ratioX.value;
            }
          };
          const update = () => {
            const wrap2 = scrollbar == null ? void 0 : scrollbar.wrapElement;
            if (!wrap2)
              return;
            const offsetHeight = wrap2.offsetHeight - GAP;
            const offsetWidth = wrap2.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrap2.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrap2.scrollWidth;
            const height = Math.max(originalHeight, props.minSize);
            const width = Math.max(originalWidth, props.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          expose({
            handleScroll,
            update
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
              vue.createVNode(Thumb, {
                move: moveX.value,
                ratio: ratioX.value,
                size: sizeWidth.value,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              vue.createVNode(Thumb, {
                move: moveY.value,
                ratio: ratioY.value,
                size: sizeHeight.value,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["__file", "bar.vue"]]);
      const scrollbarProps = buildProps({
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: {
          type: Boolean,
          default: false
        },
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        },
        tabindex: {
          type: [String, Number],
          default: void 0
        },
        id: String,
        role: String,
        ...useAriaProps(["ariaLabel", "ariaOrientation"])
      });
      const scrollbarEmits = {
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber)
      };
      const COMPONENT_NAME$6 = "ElScrollbar";
      const __default__$B = vue.defineComponent({
        name: COMPONENT_NAME$6
      });
      const _sfc_main$Z = /* @__PURE__ */ vue.defineComponent({
        ...__default__$B,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopResizeListener = void 0;
          let wrapScrollTop = 0;
          let wrapScrollLeft = 0;
          const scrollbarRef = vue.ref();
          const wrapRef = vue.ref();
          const resizeRef = vue.ref();
          const barRef = vue.ref();
          const wrapStyle = vue.computed(() => {
            const style = {};
            if (props.height)
              style.height = addUnit(props.height);
            if (props.maxHeight)
              style.maxHeight = addUnit(props.maxHeight);
            return [props.wrapStyle, style];
          });
          const wrapKls = vue.computed(() => {
            return [
              props.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props.native }
            ];
          });
          const resizeKls = vue.computed(() => {
            return [ns.e("view"), props.viewClass];
          });
          const handleScroll = () => {
            var _a2;
            if (wrapRef.value) {
              (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              wrapScrollTop = wrapRef.value.scrollTop;
              wrapScrollLeft = wrapRef.value.scrollLeft;
              emit("scroll", {
                scrollTop: wrapRef.value.scrollTop,
                scrollLeft: wrapRef.value.scrollLeft
              });
            }
          };
          function scrollTo(arg1, arg2) {
            if (isObject$1(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber(arg1) && isNumber(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber(value)) {
              debugWarn(COMPONENT_NAME$6, "value must be a number");
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber(value)) {
              debugWarn(COMPONENT_NAME$6, "value must be a number");
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update = () => {
            var _a2;
            (_a2 = barRef.value) == null ? void 0 : _a2.update();
          };
          vue.watch(() => props.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
              stopResizeListener = useEventListener("resize", update);
            }
          }, { immediate: true });
          vue.watch(() => [props.maxHeight, props.height], () => {
            if (!props.native)
              vue.nextTick(() => {
                var _a2;
                update();
                if (wrapRef.value) {
                  (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
                }
              });
          });
          vue.provide(scrollbarContextKey, vue.reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          vue.onActivated(() => {
            if (wrapRef.value) {
              wrapRef.value.scrollTop = wrapScrollTop;
              wrapRef.value.scrollLeft = wrapScrollLeft;
            }
          });
          vue.onMounted(() => {
            if (!props.native)
              vue.nextTick(() => {
                update();
              });
          });
          vue.onUpdated(() => update());
          expose({
            wrapRef,
            update,
            scrollTo,
            setScrollTop,
            setScrollLeft,
            handleScroll
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: vue.normalizeClass(vue.unref(ns).b())
            }, [
              vue.createElementVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: vue.normalizeClass(vue.unref(wrapKls)),
                style: vue.normalizeStyle(vue.unref(wrapStyle)),
                tabindex: _ctx.tabindex,
                onScroll: handleScroll
              }, [
                (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.tag), {
                  id: _ctx.id,
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: vue.normalizeClass(vue.unref(resizeKls)),
                  style: vue.normalizeStyle(_ctx.viewStyle),
                  role: _ctx.role,
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": _ctx.ariaOrientation
                }, {
                  default: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
              ], 46, ["tabindex"]),
              !_ctx.native ? (vue.openBlock(), vue.createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                always: _ctx.always,
                "min-size": _ctx.minSize
              }, null, 8, ["always", "min-size"])) : vue.createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["__file", "scrollbar.vue"]]);
      const ElScrollbar = withInstall(Scrollbar);
      const POPPER_INJECTION_KEY = Symbol("popper");
      const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
      const roleTypes = [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ];
      const popperProps = buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      });
      const __default__$A = vue.defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$Y = /* @__PURE__ */ vue.defineComponent({
        ...__default__$A,
        props: popperProps,
        setup(__props, { expose }) {
          const props = __props;
          const triggerRef = vue.ref();
          const popperInstanceRef = vue.ref();
          const contentRef = vue.ref();
          const referenceRef = vue.ref();
          const role = vue.computed(() => props.role);
          const popperProvides = {
            triggerRef,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose(popperProvides);
          vue.provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return vue.renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["__file", "popper.vue"]]);
      const popperArrowProps = buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      });
      const __default__$z = vue.defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$X = /* @__PURE__ */ vue.defineComponent({
        ...__default__$z,
        props: popperArrowProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("popper");
          const { arrowOffset, arrowRef, arrowStyle } = vue.inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          vue.watch(() => props.arrowOffset, (val) => {
            arrowOffset.value = val;
          });
          vue.onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose({
            arrowRef
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: vue.normalizeClass(vue.unref(ns).e("arrow")),
              style: vue.normalizeStyle(vue.unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["__file", "arrow.vue"]]);
      const NAME = "ElOnlyChild";
      const OnlyChild = vue.defineComponent({
        name: NAME,
        setup(_2, {
          slots,
          attrs
        }) {
          var _a2;
          const forwardRefInjection = vue.inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
          return () => {
            var _a22;
            const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              debugWarn(NAME, "requires exact only one valid child.");
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              debugWarn(NAME, "no valid child node found");
              return null;
            }
            return vue.withDirectives(vue.cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node) {
        if (!node)
          return null;
        const children = node;
        for (const child of children) {
          if (isObject$1(child)) {
            switch (child.type) {
              case vue.Comment:
                continue;
              case vue.Text:
              case "svg":
                return wrapTextContent(child);
              case vue.Fragment:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s) {
        const ns = useNamespace("only-child");
        return vue.createVNode("span", {
          "class": ns.e("content")
        }, [s]);
      }
      const popperTriggerProps = buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      });
      const __default__$y = vue.defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$W = /* @__PURE__ */ vue.defineComponent({
        ...__default__$y,
        props: popperTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const { role, triggerRef } = vue.inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef);
          const ariaControls = vue.computed(() => {
            return ariaHaspopup.value ? props.id : void 0;
          });
          const ariaDescribedby = vue.computed(() => {
            if (role && role.value === "tooltip") {
              return props.open && props.id ? props.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = vue.computed(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = vue.computed(() => {
            return ariaHaspopup.value ? `${props.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          const TRIGGER_ELE_EVENTS = [
            "onMouseenter",
            "onMouseleave",
            "onClick",
            "onKeydown",
            "onFocus",
            "onBlur",
            "onContextmenu"
          ];
          vue.onMounted(() => {
            vue.watch(() => props.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef.value = unrefElement(virtualEl);
              }
            }, {
              immediate: true
            });
            vue.watch(triggerRef, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement(el)) {
                TRIGGER_ELE_EVENTS.forEach((eventName) => {
                  var _a2;
                  const handler = props[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                virtualTriggerAriaStopWatch = vue.watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                  [
                    "aria-controls",
                    "aria-describedby",
                    "aria-haspopup",
                    "aria-expanded"
                  ].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (isElement(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          vue.onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
            if (triggerRef.value && isElement(triggerRef.value)) {
              const el = triggerRef.value;
              TRIGGER_ELE_EVENTS.forEach((eventName) => {
                const handler = props[eventName];
                if (handler) {
                  el.removeEventListener(eventName.slice(2).toLowerCase(), handler);
                }
              });
              triggerRef.value = void 0;
            }
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (vue.openBlock(), vue.createBlock(vue.unref(OnlyChild), vue.mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": vue.unref(ariaControls),
              "aria-describedby": vue.unref(ariaDescribedby),
              "aria-expanded": vue.unref(ariaExpanded),
              "aria-haspopup": vue.unref(ariaHaspopup)
            }), {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : vue.createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["__file", "trigger.vue"]]);
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = vue.ref();
      const lastUserFocusTimestamp = vue.ref(0);
      const lastAutomatedFocusTimestamp = vue.ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first2 = getVisibleElement(focusable, container);
        const last2 = getVisibleElement(focusable.reverse(), container);
        return [first2, last2];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack = [];
        const push2 = (layer) => {
          const currentLayer = stack[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack = removeFromStack(stack, layer);
          stack.unshift(layer);
        };
        const remove = (layer) => {
          var _a2, _b;
          stack = removeFromStack(stack, layer);
          (_b = (_a2 = stack[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
        };
        return {
          push: push2,
          remove
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        vue.onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        vue.onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const _sfc_main$V = vue.defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props, { emit }) {
          const forwardRef = vue.ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props.trapped && !focusLayer.paused) {
              emit("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e) => {
            if (!props.loop && !props.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
            const { loop } = props;
            const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first2, last2] = getEdges(container);
              const isTabbable = first2 && last2;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last2) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(first2, true);
                  }
                } else if (shiftKey && [first2, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(last2, true);
                  }
                }
              }
            }
          };
          vue.provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          vue.watch(() => props.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          vue.watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e) => {
            emit(ON_TRAP_FOCUS_EVT, e);
          };
          const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);
          const onFocusIn = (e) => {
            const trapContainer = vue.unref(forwardRef);
            if (!trapContainer)
              return;
            const target = e.target;
            const relatedTarget = e.relatedTarget;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!props.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit("focusin", e);
            if (focusLayer.paused)
              return;
            if (props.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e) => {
            const trapContainer = vue.unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props.trapped) {
              const relatedTarget = e.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target = e.target;
              const isFocusedInTrap = target && trapContainer.contains(target);
              if (!isFocusedInTrap)
                emit("focusout", e);
            }
          };
          async function startTrap() {
            await vue.nextTick();
            const trapContainer = vue.unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  vue.nextTick(() => {
                    let focusStartEl = props.focusStartEl;
                    if (!isString(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = vue.unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          vue.onMounted(() => {
            if (props.trapped) {
              startTrap();
            }
            vue.watch(() => props.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          vue.onBeforeUnmount(() => {
            if (props.trapped) {
              stopTrap();
            }
            if (forwardRef.value) {
              forwardRef.value.removeEventListener("keydown", onKeydown);
              forwardRef.value.removeEventListener("focusin", onFocusIn);
              forwardRef.value.removeEventListener("focusout", onFocusOut);
              forwardRef.value = void 0;
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$8], ["__file", "focus-trap.vue"]]);
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      });
      const popperContentProps = buildProps({
        ...popperCoreConfigProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: definePropType(String),
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: {
          type: Boolean,
          default: false
        },
        trapping: {
          type: Boolean,
          default: false
        },
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        virtualTriggering: Boolean,
        zIndex: Number,
        ...useAriaProps(["ariaLabel"])
      });
      const popperContentEmits = {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      };
      const buildPopperOptions = (props, modifiers = []) => {
        const { placement, strategy, popperOptions } = props;
        const options = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props), ...modifiers]
        };
        deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient)
          return;
        return unrefElement($el);
      };
      function genModifiers(options) {
        const { offset, gpuAcceleration, fallbackPlacements } = options;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset != null ? offset : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options, modifiers) {
        if (modifiers) {
          options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props) => {
        const { popperInstanceRef, contentRef, triggerRef, role } = vue.inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = vue.ref();
        const arrowOffset = vue.ref();
        const eventListenerModifier = vue.computed(() => {
          return {
            name: "eventListeners",
            enabled: !!props.visible
          };
        });
        const arrowModifier = vue.computed(() => {
          var _a2;
          const arrowEl = vue.unref(arrowRef);
          const offset = (_a2 = vue.unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined$1(arrowEl),
            options: {
              element: arrowEl,
              padding: offset
            }
          };
        });
        const options = vue.computed(() => {
          return {
            onFirstUpdate: () => {
              update();
            },
            ...buildPopperOptions(props, [
              vue.unref(arrowModifier),
              vue.unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = vue.computed(() => unwrapMeasurableEl(props.referenceEl) || vue.unref(triggerRef));
        const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
        vue.watch(instanceRef, (instance) => popperInstanceRef.value = instance);
        vue.onMounted(() => {
          vue.watch(() => {
            var _a2;
            return (_a2 = vue.unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
          }, () => {
            update();
          });
        });
        return {
          attributes,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update
        };
      };
      const usePopperContentDOM = (props, {
        attributes,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = vue.computed(() => vue.unref(attributes).popper);
        const contentZIndex = vue.ref(isNumber(props.zIndex) ? props.zIndex : nextZIndex());
        const contentClass = vue.computed(() => [
          ns.b(),
          ns.is("pure", props.pure),
          ns.is(props.effect),
          props.popperClass
        ]);
        const contentStyle = vue.computed(() => {
          return [
            { zIndex: vue.unref(contentZIndex) },
            vue.unref(styles).popper,
            props.popperStyle || {}
          ];
        });
        const ariaModal = vue.computed(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = vue.computed(() => vue.unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = isNumber(props.zIndex) ? props.zIndex : nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const usePopperContentFocusTrap = (props, emit) => {
        const trapped = vue.ref(false);
        const focusStartRef = vue.ref();
        const onFocusAfterTrapped = () => {
          emit("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const __default__$x = vue.defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$U = /* @__PURE__ */ vue.defineComponent({
        ...__default__$x,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props, emit);
          const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props, {
            styles,
            attributes,
            role
          });
          const formItemContext = vue.inject(formItemContextKey, void 0);
          const arrowOffset = vue.ref();
          vue.provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef,
            arrowOffset
          });
          if (formItemContext) {
            vue.provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props.visible && props.focusOnShow) {
              trapped.value = true;
            } else if (props.visible === false) {
              trapped.value = false;
            }
          };
          vue.onMounted(() => {
            vue.watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = vue.unref(triggerTargetEl || contentRef.value);
              const prevEl = vue.unref(prevTriggerTargetEl || contentRef.value);
              if (isElement(el)) {
                triggerTargetAriaStopWatch = vue.watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            vue.watch(() => props.visible, togglePopperAlive, { immediate: true });
          });
          vue.onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", vue.mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, vue.unref(contentAttrs), {
              style: vue.unref(contentStyle),
              class: vue.unref(contentClass),
              tabindex: "-1",
              onMouseenter: (e) => _ctx.$emit("mouseenter", e),
              onMouseleave: (e) => _ctx.$emit("mouseleave", e)
            }), [
              vue.createVNode(vue.unref(ElFocusTrap), {
                trapped: vue.unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": vue.unref(contentRef),
                "focus-start-el": vue.unref(focusStartRef),
                onFocusAfterTrapped: vue.unref(onFocusAfterTrapped),
                onFocusAfterReleased: vue.unref(onFocusAfterReleased),
                onFocusin: vue.unref(onFocusInTrap),
                onFocusoutPrevented: vue.unref(onFocusoutPrevented),
                onReleaseRequested: vue.unref(onReleaseRequested)
              }, {
                default: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16, ["onMouseenter", "onMouseleave"]);
          };
        }
      });
      var ElPopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["__file", "content.vue"]]);
      const ElPopper = withInstall(Popper);
      const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
      const useTooltipContentProps = buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: definePropType([String, Object])
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: Boolean,
        persistent: Boolean,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean,
        ...useAriaProps(["ariaLabel"])
      });
      const useTooltipTriggerProps = buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.space]
        }
      });
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      const useTooltipProps = buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      });
      const tooltipEmits = [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ];
      const isTriggerType = (trigger, type) => {
        if (isArray$1(trigger)) {
          return trigger.includes(type);
        }
        return trigger === type;
      };
      const whenTrigger = (trigger, type, handler) => {
        return (e) => {
          isTriggerType(vue.unref(trigger), type) && handler(e);
        };
      };
      const __default__$w = vue.defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$T = /* @__PURE__ */ vue.defineComponent({
        ...__default__$w,
        props: useTooltipTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id, open: open2, onOpen, onClose, onToggle } = vue.inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef = vue.ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (vue.unref(controlled) || props.disabled) {
              return true;
            }
          };
          const trigger = vue.toRef(props, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "click", (e) => {
            if (e.button === 0) {
              onToggle(e);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "contextmenu", (e) => {
            e.preventDefault();
            onToggle(e);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
            const { code } = e;
            if (props.triggerKeys.includes(code)) {
              e.preventDefault();
              onToggle(e);
            }
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.unref(ElPopperTrigger), {
              id: vue.unref(id),
              "virtual-ref": _ctx.virtualRef,
              open: vue.unref(open2),
              "virtual-triggering": _ctx.virtualTriggering,
              class: vue.normalizeClass(vue.unref(ns).e("trigger")),
              onBlur: vue.unref(onBlur),
              onClick: vue.unref(onClick),
              onContextmenu: vue.unref(onContextMenu),
              onFocus: vue.unref(onFocus),
              onMouseenter: vue.unref(onMouseenter),
              onMouseleave: vue.unref(onMouseleave),
              onKeydown: vue.unref(onKeydown)
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["__file", "trigger.vue"]]);
      const teleportProps = buildProps({
        to: {
          type: definePropType([String, Object]),
          required: true
        },
        disabled: Boolean
      });
      const _sfc_main$S = /* @__PURE__ */ vue.defineComponent({
        __name: "teleport",
        props: teleportProps,
        setup(__props) {
          return (_ctx, _cache) => {
            return _ctx.disabled ? vue.renderSlot(_ctx.$slots, "default", { key: 0 }) : (vue.openBlock(), vue.createBlock(vue.Teleport, {
              key: 1,
              to: _ctx.to
            }, [
              vue.renderSlot(_ctx.$slots, "default")
            ], 8, ["to"]));
          };
        }
      });
      var Teleport = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["__file", "teleport.vue"]]);
      const ElTeleport = withInstall(Teleport);
      const __default__$v = vue.defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$R = /* @__PURE__ */ vue.defineComponent({
        ...__default__$v,
        props: useTooltipContentProps,
        setup(__props, { expose }) {
          const props = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = vue.ref(null);
          let stopHandle;
          const {
            controlled,
            id,
            open: open2,
            trigger,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = vue.inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = vue.computed(() => {
            return props.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = vue.computed(() => {
            return props.persistent;
          });
          vue.onBeforeUnmount(() => {
            stopHandle == null ? void 0 : stopHandle();
          });
          const shouldRender = vue.computed(() => {
            return vue.unref(persistentRef) ? true : vue.unref(open2);
          });
          const shouldShow = vue.computed(() => {
            return props.disabled ? false : vue.unref(open2);
          });
          const appendTo = vue.computed(() => {
            return props.appendTo || selector.value;
          });
          const contentStyle = vue.computed(() => {
            var _a2;
            return (_a2 = props.style) != null ? _a2 : {};
          });
          const ariaHidden = vue.ref(true);
          const onTransitionLeave = () => {
            onHide();
            ariaHidden.value = true;
          };
          const stopWhenControlled = () => {
            if (vue.unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props.enterable && vue.unref(trigger) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (vue.unref(trigger) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
            stopHandle = onClickOutside(vue.computed(() => {
              var _a2;
              return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
            }), () => {
              if (vue.unref(controlled))
                return;
              const $trigger = vue.unref(trigger);
              if ($trigger !== "hover") {
                onClose();
              }
            });
          };
          const onBlur = () => {
            if (!props.virtualTriggering) {
              onClose();
            }
          };
          vue.watch(() => vue.unref(open2), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            } else {
              ariaHidden.value = false;
            }
          }, {
            flush: "post"
          });
          vue.watch(() => props.content, () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          expose({
            contentRef
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.unref(ElTeleport), {
              disabled: !_ctx.teleported,
              to: vue.unref(appendTo)
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.Transition, {
                  name: vue.unref(transitionClass),
                  onAfterLeave: onTransitionLeave,
                  onBeforeEnter,
                  onAfterEnter: onAfterShow,
                  onBeforeLeave
                }, {
                  default: vue.withCtx(() => [
                    vue.unref(shouldRender) ? vue.withDirectives((vue.openBlock(), vue.createBlock(vue.unref(ElPopperContent), vue.mergeProps({
                      key: 0,
                      id: vue.unref(id),
                      ref_key: "contentRef",
                      ref: contentRef
                    }, _ctx.$attrs, {
                      "aria-label": _ctx.ariaLabel,
                      "aria-hidden": ariaHidden.value,
                      "boundaries-padding": _ctx.boundariesPadding,
                      "fallback-placements": _ctx.fallbackPlacements,
                      "gpu-acceleration": _ctx.gpuAcceleration,
                      offset: _ctx.offset,
                      placement: _ctx.placement,
                      "popper-options": _ctx.popperOptions,
                      strategy: _ctx.strategy,
                      effect: _ctx.effect,
                      enterable: _ctx.enterable,
                      pure: _ctx.pure,
                      "popper-class": _ctx.popperClass,
                      "popper-style": [_ctx.popperStyle, vue.unref(contentStyle)],
                      "reference-el": _ctx.referenceEl,
                      "trigger-target-el": _ctx.triggerTargetEl,
                      visible: vue.unref(shouldShow),
                      "z-index": _ctx.zIndex,
                      onMouseenter: vue.unref(onContentEnter),
                      onMouseleave: vue.unref(onContentLeave),
                      onBlur,
                      onClose: vue.unref(onClose)
                    }), {
                      default: vue.withCtx(() => [
                        vue.renderSlot(_ctx.$slots, "default")
                      ]),
                      _: 3
                    }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                      [vue.vShow, vue.unref(shouldShow)]
                    ]) : vue.createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ]),
              _: 3
            }, 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["__file", "content.vue"]]);
      const __default__$u = vue.defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$Q = /* @__PURE__ */ vue.defineComponent({
        ...__default__$u,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          usePopperContainer();
          const id = useId();
          const popperRef = vue.ref();
          const contentRef = vue.ref();
          const updatePopper = () => {
            var _a2;
            const popperComponent = vue.unref(popperRef);
            if (popperComponent) {
              (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
            }
          };
          const open2 = vue.ref(false);
          const toggleReason = vue.ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open2,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: vue.toRef(props, "showAfter"),
            hideAfter: vue.toRef(props, "hideAfter"),
            autoClose: vue.toRef(props, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = vue.computed(() => isBoolean(props.visible) && !hasUpdateHandler.value);
          vue.provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id,
            open: vue.readonly(open2),
            trigger: vue.toRef(props, "trigger"),
            onOpen: (event) => {
              onOpen(event);
            },
            onClose: (event) => {
              onClose(event);
            },
            onToggle: (event) => {
              if (vue.unref(open2)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit("show", toggleReason.value);
            },
            onHide: () => {
              emit("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit("before-hide", toggleReason.value);
            },
            updatePopper
          });
          vue.watch(() => props.disabled, (disabled) => {
            if (disabled && open2.value) {
              open2.value = false;
            }
          });
          const isFocusInsideContent = (event) => {
            var _a2, _b;
            const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
            const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
            return popperContent && popperContent.contains(activeElement);
          };
          vue.onDeactivated(() => open2.value && hide());
          expose({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: vue.withCtx(() => [
                    _ctx.$slots.default ? vue.renderSlot(_ctx.$slots, "default", { key: 0 }) : vue.createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                vue.createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": _ctx.popperClass,
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (vue.openBlock(), vue.createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, ["innerHTML"])) : (vue.openBlock(), vue.createElementBlock("span", { key: 1 }, vue.toDisplayString(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (vue.openBlock(), vue.createBlock(vue.unref(ElPopperArrow), {
                      key: 0,
                      "arrow-offset": _ctx.arrowOffset
                    }, null, 8, ["arrow-offset"])) : vue.createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["__file", "tooltip.vue"]]);
      const ElTooltip = withInstall(Tooltip);
      const buttonGroupContextKey = Symbol("buttonGroupContextKey");
      const useButton = (props, emit) => {
        useDeprecated({
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, vue.computed(() => props.type === "text"));
        const buttonGroupContext = vue.inject(buttonGroupContextKey, void 0);
        const globalConfig2 = useGlobalConfig("button");
        const { form } = useFormItem();
        const _size = useFormSize(vue.computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
        const _disabled = useFormDisabled();
        const _ref = vue.ref();
        const slots = vue.useSlots();
        const _type = vue.computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
        const autoInsertSpace = vue.computed(() => {
          var _a2, _b, _c;
          return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
        });
        const _props = vue.computed(() => {
          if (props.tag === "button") {
            return {
              ariaDisabled: _disabled.value || props.loading,
              disabled: _disabled.value || props.loading,
              autofocus: props.autofocus,
              type: props.nativeType
            };
          }
          return {};
        });
        const shouldAddSpace = vue.computed(() => {
          var _a2;
          const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
            const slot = defaultSlot[0];
            if ((slot == null ? void 0 : slot.type) === vue.Text) {
              const text = slot.children;
              return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(text.trim());
            }
          }
          return false;
        });
        const handleClick = (evt) => {
          if (_disabled.value || props.loading) {
            evt.stopPropagation();
            return;
          }
          if (props.nativeType === "reset") {
            form == null ? void 0 : form.resetFields();
          }
          emit("click", evt);
        };
        return {
          _disabled,
          _size,
          _type,
          _ref,
          _props,
          shouldAddSpace,
          handleClick
        };
      };
      const buttonTypes = [
        "default",
        "primary",
        "success",
        "warning",
        "info",
        "danger",
        "text",
        ""
      ];
      const buttonNativeTypes = ["button", "submit", "reset"];
      const buttonProps = buildProps({
        size: useSizeProp,
        disabled: Boolean,
        type: {
          type: String,
          values: buttonTypes,
          default: ""
        },
        icon: {
          type: iconPropType
        },
        nativeType: {
          type: String,
          values: buttonNativeTypes,
          default: "button"
        },
        loading: Boolean,
        loadingIcon: {
          type: iconPropType,
          default: () => loading_default
        },
        plain: Boolean,
        text: Boolean,
        link: Boolean,
        bg: Boolean,
        autofocus: Boolean,
        round: Boolean,
        circle: Boolean,
        color: String,
        dark: Boolean,
        autoInsertSpace: {
          type: Boolean,
          default: void 0
        },
        tag: {
          type: definePropType([String, Object]),
          default: "button"
        }
      });
      const buttonEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      function bound01$1(n, max2) {
        if (isOnePointZero$1(n)) {
          n = "100%";
        }
        var isPercent = isPercentage$1(n);
        n = max2 === 360 ? n : Math.min(max2, Math.max(0, parseFloat(n)));
        if (isPercent) {
          n = parseInt(String(n * max2), 10) / 100;
        }
        if (Math.abs(n - max2) < 1e-6) {
          return 1;
        }
        if (max2 === 360) {
          n = (n < 0 ? n % max2 + max2 : n % max2) / parseFloat(String(max2));
        } else {
          n = n % max2 / parseFloat(String(max2));
        }
        return n;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero$1(n) {
        return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
      }
      function isPercentage$1(n) {
        return typeof n === "string" && n.indexOf("%") !== -1;
      }
      function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
        }
        return a;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          return "".concat(Number(n) * 100, "%");
        }
        return n;
      }
      function pad2(c) {
        return c.length === 1 ? "0" + c : String(c);
      }
      function rgbToRgb(r, g, b) {
        return {
          r: bound01$1(r, 255) * 255,
          g: bound01$1(g, 255) * 255,
          b: bound01$1(b, 255) * 255
        };
      }
      function rgbToHsl(r, g, b) {
        r = bound01$1(r, 255);
        g = bound01$1(g, 255);
        b = bound01$1(b, 255);
        var max2 = Math.max(r, g, b);
        var min2 = Math.min(r, g, b);
        var h2 = 0;
        var s = 0;
        var l = (max2 + min2) / 2;
        if (max2 === min2) {
          s = 0;
          h2 = 0;
        } else {
          var d = max2 - min2;
          s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
          switch (max2) {
            case r:
              h2 = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h2 = (b - r) / d + 2;
              break;
            case b:
              h2 = (r - g) / d + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s, l };
      }
      function hue2rgb(p, q2, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q2 - p) * (6 * t);
        }
        if (t < 1 / 2) {
          return q2;
        }
        if (t < 2 / 3) {
          return p + (q2 - p) * (2 / 3 - t) * 6;
        }
        return p;
      }
      function hslToRgb(h2, s, l) {
        var r;
        var g;
        var b;
        h2 = bound01$1(h2, 360);
        s = bound01$1(s, 100);
        l = bound01$1(l, 100);
        if (s === 0) {
          g = l;
          b = l;
          r = l;
        } else {
          var q2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q2;
          r = hue2rgb(p, q2, h2 + 1 / 3);
          g = hue2rgb(p, q2, h2);
          b = hue2rgb(p, q2, h2 - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHsv(r, g, b) {
        r = bound01$1(r, 255);
        g = bound01$1(g, 255);
        b = bound01$1(b, 255);
        var max2 = Math.max(r, g, b);
        var min2 = Math.min(r, g, b);
        var h2 = 0;
        var v = max2;
        var d = max2 - min2;
        var s = max2 === 0 ? 0 : d / max2;
        if (max2 === min2) {
          h2 = 0;
        } else {
          switch (max2) {
            case r:
              h2 = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h2 = (b - r) / d + 2;
              break;
            case b:
              h2 = (r - g) / d + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s, v };
      }
      function hsvToRgb(h2, s, v) {
        h2 = bound01$1(h2, 360) * 6;
        s = bound01$1(s, 100);
        v = bound01$1(v, 100);
        var i = Math.floor(h2);
        var f = h2 - i;
        var p = v * (1 - s);
        var q2 = v * (1 - f * s);
        var t = v * (1 - (1 - f) * s);
        var mod = i % 6;
        var r = [v, q2, p, p, t, v][mod];
        var g = [t, v, v, q2, p, p][mod];
        var b = [p, p, t, v, v, q2][mod];
        return { r: r * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHex(r, g, b, allow3Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r, g, b, a, allow4Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b).toString(16)),
          pad2(convertDecimalToHex(a))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a = color.a;
          }
        }
        a = boundAlpha(a);
        return {
          ok,
          format: color.format || format,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match = matchers.rgb.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        match = matchers.rgba.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        match = matchers.hsl.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        match = matchers.hsla.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        match = matchers.hsv.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        match = matchers.hsva.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        match = matchers.hex8.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex6.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        match = matchers.hex4.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            a: convertHexToDecimal(match[4] + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex3.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = (
        /** @class */
        function() {
          function TinyColor2(color, opts) {
            if (color === void 0) {
              color = "";
            }
            if (opts === void 0) {
              opts = {};
            }
            var _a2;
            if (color instanceof TinyColor2) {
              return color;
            }
            if (typeof color === "number") {
              color = numberInputToObject(color);
            }
            this.originalInput = color;
            var rgb = inputToRGB(color);
            this.originalInput = color;
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
            this.a = rgb.a;
            this.roundA = Math.round(100 * this.a) / 100;
            this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
            this.gradientType = opts.gradientType;
            if (this.r < 1) {
              this.r = Math.round(this.r);
            }
            if (this.g < 1) {
              this.g = Math.round(this.g);
            }
            if (this.b < 1) {
              this.b = Math.round(this.b);
            }
            this.isValid = rgb.ok;
          }
          TinyColor2.prototype.isDark = function() {
            return this.getBrightness() < 128;
          };
          TinyColor2.prototype.isLight = function() {
            return !this.isDark();
          };
          TinyColor2.prototype.getBrightness = function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          };
          TinyColor2.prototype.getLuminance = function() {
            var rgb = this.toRgb();
            var R2;
            var G2;
            var B2;
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R2 = RsRGB / 12.92;
            } else {
              R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G2 = GsRGB / 12.92;
            } else {
              G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B2 = BsRGB / 12.92;
            } else {
              B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
          };
          TinyColor2.prototype.getAlpha = function() {
            return this.a;
          };
          TinyColor2.prototype.setAlpha = function(alpha) {
            this.a = boundAlpha(alpha);
            this.roundA = Math.round(100 * this.a) / 100;
            return this;
          };
          TinyColor2.prototype.isMonochrome = function() {
            var s = this.toHsl().s;
            return s === 0;
          };
          TinyColor2.prototype.toHsv = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
          };
          TinyColor2.prototype.toHsvString = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            var h2 = Math.round(hsv.h * 360);
            var s = Math.round(hsv.s * 100);
            var v = Math.round(hsv.v * 100);
            return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHsl = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
          };
          TinyColor2.prototype.toHslString = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            var h2 = Math.round(hsl.h * 360);
            var s = Math.round(hsl.s * 100);
            var l = Math.round(hsl.l * 100);
            return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHex = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return rgbToHex(this.r, this.g, this.b, allow3Char);
          };
          TinyColor2.prototype.toHexString = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return "#" + this.toHex(allow3Char);
          };
          TinyColor2.prototype.toHex8 = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
          };
          TinyColor2.prototype.toHex8String = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return "#" + this.toHex8(allow4Char);
          };
          TinyColor2.prototype.toHexShortString = function(allowShortChar) {
            if (allowShortChar === void 0) {
              allowShortChar = false;
            }
            return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
          };
          TinyColor2.prototype.toRgb = function() {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toRgbString = function() {
            var r = Math.round(this.r);
            var g = Math.round(this.g);
            var b = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toPercentageRgb = function() {
            var fmt = function(x) {
              return "".concat(Math.round(bound01$1(x, 255) * 100), "%");
            };
            return {
              r: fmt(this.r),
              g: fmt(this.g),
              b: fmt(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toPercentageRgbString = function() {
            var rnd = function(x) {
              return Math.round(bound01$1(x, 255) * 100);
            };
            return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toName = function() {
            if (this.a === 0) {
              return "transparent";
            }
            if (this.a < 1) {
              return false;
            }
            var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
            for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
              var _b = _a2[_i], key = _b[0], value = _b[1];
              if (hex === value) {
                return key;
              }
            }
            return false;
          };
          TinyColor2.prototype.toString = function(format) {
            var formatSet = Boolean(format);
            format = format !== null && format !== void 0 ? format : this.format;
            var formattedString = false;
            var hasAlpha = this.a < 1 && this.a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
            if (needsAlphaFormat) {
              if (format === "name" && this.a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
            }
            if (format === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format === "name") {
              formattedString = this.toName();
            }
            if (format === "hsl") {
              formattedString = this.toHslString();
            }
            if (format === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          };
          TinyColor2.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          };
          TinyColor2.prototype.clone = function() {
            return new TinyColor2(this.toString());
          };
          TinyColor2.prototype.lighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.brighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var rgb = this.toRgb();
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
            return new TinyColor2(rgb);
          };
          TinyColor2.prototype.darken = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.tint = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("white", amount);
          };
          TinyColor2.prototype.shade = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("black", amount);
          };
          TinyColor2.prototype.desaturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.saturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.greyscale = function() {
            return this.desaturate(100);
          };
          TinyColor2.prototype.spin = function(amount) {
            var hsl = this.toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.mix = function(color, amount) {
            if (amount === void 0) {
              amount = 50;
            }
            var rgb1 = this.toRgb();
            var rgb2 = new TinyColor2(color).toRgb();
            var p = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p + rgb1.r,
              g: (rgb2.g - rgb1.g) * p + rgb1.g,
              b: (rgb2.b - rgb1.b) * p + rgb1.b,
              a: (rgb2.a - rgb1.a) * p + rgb1.a
            };
            return new TinyColor2(rgba);
          };
          TinyColor2.prototype.analogous = function(results, slices) {
            if (results === void 0) {
              results = 6;
            }
            if (slices === void 0) {
              slices = 30;
            }
            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(new TinyColor2(hsl));
            }
            return ret;
          };
          TinyColor2.prototype.complement = function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.monochromatic = function(results) {
            if (results === void 0) {
              results = 6;
            }
            var hsv = this.toHsv();
            var h2 = hsv.h;
            var s = hsv.s;
            var v = hsv.v;
            var res = [];
            var modification = 1 / results;
            while (results--) {
              res.push(new TinyColor2({ h: h2, s, v }));
              v = (v + modification) % 1;
            }
            return res;
          };
          TinyColor2.prototype.splitcomplement = function() {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            return [
              this,
              new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
              new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          };
          TinyColor2.prototype.onBackground = function(background) {
            var fg = this.toRgb();
            var bg = new TinyColor2(background).toRgb();
            var alpha = fg.a + bg.a * (1 - fg.a);
            return new TinyColor2({
              r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
              g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
              b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
              a: alpha
            });
          };
          TinyColor2.prototype.triad = function() {
            return this.polyad(3);
          };
          TinyColor2.prototype.tetrad = function() {
            return this.polyad(4);
          };
          TinyColor2.prototype.polyad = function(n) {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            var result2 = [this];
            var increment = 360 / n;
            for (var i = 1; i < n; i++) {
              result2.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
            }
            return result2;
          };
          TinyColor2.prototype.equals = function(color) {
            return this.toRgbString() === new TinyColor2(color).toRgbString();
          };
          return TinyColor2;
        }()
      );
      function darken(color, amount = 20) {
        return color.mix("#141414", amount).toString();
      }
      function useButtonCustomStyle(props) {
        const _disabled = useFormDisabled();
        const ns = useNamespace("button");
        return vue.computed(() => {
          let styles = {};
          let buttonColor = props.color;
          if (buttonColor) {
            const match = buttonColor.match(/var\((.*?)\)/);
            if (match) {
              buttonColor = window.getComputedStyle(window.document.documentElement).getPropertyValue(match[1]);
            }
            const color = new TinyColor(buttonColor);
            const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
            if (props.plain) {
              styles = ns.cssVarBlock({
                "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
                "text-color": buttonColor,
                "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
                "hover-text-color": `var(${ns.cssVarName("color-white")})`,
                "hover-bg-color": buttonColor,
                "hover-border-color": buttonColor,
                "active-bg-color": activeBgColor,
                "active-text-color": `var(${ns.cssVarName("color-white")})`,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
              }
            } else {
              const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
              const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
              styles = ns.cssVarBlock({
                "bg-color": buttonColor,
                "text-color": textColor,
                "border-color": buttonColor,
                "hover-bg-color": hoverBgColor,
                "hover-text-color": textColor,
                "hover-border-color": hoverBgColor,
                "active-bg-color": activeBgColor,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
                styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
              }
            }
          }
          return styles;
        });
      }
      const __default__$t = vue.defineComponent({
        name: "ElButton"
      });
      const _sfc_main$P = /* @__PURE__ */ vue.defineComponent({
        ...__default__$t,
        props: buttonProps,
        emits: buttonEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const buttonStyle = useButtonCustomStyle(props);
          const ns = useNamespace("button");
          const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit);
          const buttonKls = vue.computed(() => [
            ns.b(),
            ns.m(_type.value),
            ns.m(_size.value),
            ns.is("disabled", _disabled.value),
            ns.is("loading", props.loading),
            ns.is("plain", props.plain),
            ns.is("round", props.round),
            ns.is("circle", props.circle),
            ns.is("text", props.text),
            ns.is("link", props.link),
            ns.is("has-bg", props.bg)
          ]);
          expose({
            ref: _ref,
            size: _size,
            type: _type,
            disabled: _disabled,
            shouldAddSpace
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.tag), vue.mergeProps({
              ref_key: "_ref",
              ref: _ref
            }, vue.unref(_props), {
              class: vue.unref(buttonKls),
              style: vue.unref(buttonStyle),
              onClick: vue.unref(handleClick)
            }), {
              default: vue.withCtx(() => [
                _ctx.loading ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                  _ctx.$slots.loading ? vue.renderSlot(_ctx.$slots, "loading", { key: 0 }) : (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                    key: 1,
                    class: vue.normalizeClass(vue.unref(ns).is("loading"))
                  }, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.loadingIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"]))
                ], 64)) : _ctx.icon || _ctx.$slots.icon ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), { key: 1 }, {
                  default: vue.withCtx(() => [
                    _ctx.icon ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.icon), { key: 0 })) : vue.renderSlot(_ctx.$slots, "icon", { key: 1 })
                  ]),
                  _: 3
                })) : vue.createCommentVNode("v-if", true),
                _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock("span", {
                  key: 2,
                  class: vue.normalizeClass({ [vue.unref(ns).em("text", "expand")]: vue.unref(shouldAddSpace) })
                }, [
                  vue.renderSlot(_ctx.$slots, "default")
                ], 2)) : vue.createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["class", "style", "onClick"]);
          };
        }
      });
      var Button = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["__file", "button.vue"]]);
      const buttonGroupProps = {
        size: buttonProps.size,
        type: buttonProps.type
      };
      const __default__$s = vue.defineComponent({
        name: "ElButtonGroup"
      });
      const _sfc_main$O = /* @__PURE__ */ vue.defineComponent({
        ...__default__$s,
        props: buttonGroupProps,
        setup(__props) {
          const props = __props;
          vue.provide(buttonGroupContextKey, vue.reactive({
            size: vue.toRef(props, "size"),
            type: vue.toRef(props, "type")
          }));
          const ns = useNamespace("button");
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: vue.normalizeClass(vue.unref(ns).b("group"))
            }, [
              vue.renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["__file", "button-group.vue"]]);
      const ElButton = withInstall(Button, {
        ButtonGroup
      });
      withNoopInstall(ButtonGroup);
      const nodeList = /* @__PURE__ */ new Map();
      if (isClient) {
        let startClick;
        document.addEventListener("mousedown", (e) => startClick = e);
        document.addEventListener("mouseup", (e) => {
          if (startClick) {
            for (const handlers of nodeList.values()) {
              for (const { documentHandler } of handlers) {
                documentHandler(e, startClick);
              }
            }
            startClick = void 0;
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (Array.isArray(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers = nodeList.get(el);
          const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      };
      const REPEAT_INTERVAL = 100;
      const REPEAT_DELAY = 600;
      const vRepeatClick = {
        beforeMount(el, binding) {
          const value = binding.value;
          const { interval = REPEAT_INTERVAL, delay: delay2 = REPEAT_DELAY } = isFunction$1(value) ? {} : value;
          let intervalId;
          let delayId;
          const handler = () => isFunction$1(value) ? value() : value.handler();
          const clear = () => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = void 0;
            }
          };
          el.addEventListener("mousedown", (evt) => {
            if (evt.button !== 0)
              return;
            clear();
            handler();
            document.addEventListener("mouseup", () => clear(), {
              once: true
            });
            delayId = setTimeout(() => {
              intervalId = setInterval(() => {
                handler();
              }, interval);
            }, delay2);
          });
        }
      };
      const FOCUSABLE_CHILDREN = "_trap-focus-children";
      const FOCUS_STACK = [];
      const FOCUS_HANDLER = (e) => {
        if (FOCUS_STACK.length === 0)
          return;
        const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
        if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {
          if (focusableElement.length === 1) {
            e.preventDefault();
            if (document.activeElement !== focusableElement[0]) {
              focusableElement[0].focus();
            }
            return;
          }
          const goingBackward = e.shiftKey;
          const isFirst = e.target === focusableElement[0];
          const isLast = e.target === focusableElement[focusableElement.length - 1];
          if (isFirst && goingBackward) {
            e.preventDefault();
            focusableElement[focusableElement.length - 1].focus();
          }
          if (isLast && !goingBackward) {
            e.preventDefault();
            focusableElement[0].focus();
          }
        }
      };
      const TrapFocus = {
        beforeMount(el) {
          el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          FOCUS_STACK.push(el);
          if (FOCUS_STACK.length <= 1) {
            document.addEventListener("keydown", FOCUS_HANDLER);
          }
        },
        updated(el) {
          vue.nextTick(() => {
            el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          });
        },
        unmounted() {
          FOCUS_STACK.shift();
          if (FOCUS_STACK.length === 0) {
            document.removeEventListener("keydown", FOCUS_HANDLER);
          }
        }
      };
      const cardProps = buildProps({
        header: {
          type: String,
          default: ""
        },
        footer: {
          type: String,
          default: ""
        },
        bodyStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        bodyClass: String,
        shadow: {
          type: String,
          values: ["always", "hover", "never"],
          default: "always"
        }
      });
      const __default__$r = vue.defineComponent({
        name: "ElCard"
      });
      const _sfc_main$N = /* @__PURE__ */ vue.defineComponent({
        ...__default__$r,
        props: cardProps,
        setup(__props) {
          const ns = useNamespace("card");
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: vue.normalizeClass([vue.unref(ns).b(), vue.unref(ns).is(`${_ctx.shadow}-shadow`)])
            }, [
              _ctx.$slots.header || _ctx.header ? (vue.openBlock(), vue.createElementBlock("div", {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).e("header"))
              }, [
                vue.renderSlot(_ctx.$slots, "header", {}, () => [
                  vue.createTextVNode(vue.toDisplayString(_ctx.header), 1)
                ])
              ], 2)) : vue.createCommentVNode("v-if", true),
              vue.createElementVNode("div", {
                class: vue.normalizeClass([vue.unref(ns).e("body"), _ctx.bodyClass]),
                style: vue.normalizeStyle(_ctx.bodyStyle)
              }, [
                vue.renderSlot(_ctx.$slots, "default")
              ], 6),
              _ctx.$slots.footer || _ctx.footer ? (vue.openBlock(), vue.createElementBlock("div", {
                key: 1,
                class: vue.normalizeClass(vue.unref(ns).e("footer"))
              }, [
                vue.renderSlot(_ctx.$slots, "footer", {}, () => [
                  vue.createTextVNode(vue.toDisplayString(_ctx.footer), 1)
                ])
              ], 2)) : vue.createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Card = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["__file", "card.vue"]]);
      const ElCard = withInstall(Card);
      const checkboxProps = {
        modelValue: {
          type: [Number, String, Boolean],
          default: void 0
        },
        label: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        value: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
          type: String,
          default: void 0
        },
        trueValue: {
          type: [String, Number],
          default: void 0
        },
        falseValue: {
          type: [String, Number],
          default: void 0
        },
        trueLabel: {
          type: [String, Number],
          default: void 0
        },
        falseLabel: {
          type: [String, Number],
          default: void 0
        },
        id: {
          type: String,
          default: void 0
        },
        border: Boolean,
        size: useSizeProp,
        tabindex: [String, Number],
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaControls"])
      };
      const checkboxEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString(val) || isNumber(val) || isBoolean(val),
        change: (val) => isString(val) || isNumber(val) || isBoolean(val)
      };
      const checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
      const useCheckboxDisabled = ({
        model,
        isChecked
      }) => {
        const checkboxGroup = vue.inject(checkboxGroupContextKey, void 0);
        const isLimitDisabled = vue.computed(() => {
          var _a2, _b;
          const max2 = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value;
          const min2 = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
          return !isUndefined(max2) && model.value.length >= max2 && !isChecked.value || !isUndefined(min2) && model.value.length <= min2 && isChecked.value;
        });
        const isDisabled = useFormDisabled(vue.computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
        return {
          isDisabled,
          isLimitDisabled
        };
      };
      const useCheckboxEvent = (props, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      }) => {
        const checkboxGroup = vue.inject(checkboxGroupContextKey, void 0);
        const { formItem } = useFormItem();
        const { emit } = vue.getCurrentInstance();
        function getLabeledValue(value) {
          var _a2, _b, _c, _d;
          return [true, props.trueValue, props.trueLabel].includes(value) ? (_b = (_a2 = props.trueValue) != null ? _a2 : props.trueLabel) != null ? _b : true : (_d = (_c = props.falseValue) != null ? _c : props.falseLabel) != null ? _d : false;
        }
        function emitChangeEvent(checked, e) {
          emit("change", getLabeledValue(checked), e);
        }
        function handleChange(e) {
          if (isLimitExceeded.value)
            return;
          const target = e.target;
          emit("change", getLabeledValue(target.checked), e);
        }
        async function onClickRoot(e) {
          if (isLimitExceeded.value)
            return;
          if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
            const eventTargets = e.composedPath();
            const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
            if (!hasLabel) {
              model.value = getLabeledValue([false, props.falseValue, props.falseLabel].includes(model.value));
              await vue.nextTick();
              emitChangeEvent(model.value, e);
            }
          }
        }
        const validateEvent = vue.computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent);
        vue.watch(() => props.modelValue, () => {
          if (validateEvent.value) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
          }
        });
        return {
          handleChange,
          onClickRoot
        };
      };
      const useCheckboxModel = (props) => {
        const selfModel = vue.ref(false);
        const { emit } = vue.getCurrentInstance();
        const checkboxGroup = vue.inject(checkboxGroupContextKey, void 0);
        const isGroup = vue.computed(() => isUndefined(checkboxGroup) === false);
        const isLimitExceeded = vue.ref(false);
        const model = vue.computed({
          get() {
            var _a2, _b;
            return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props.modelValue) != null ? _b : selfModel.value;
          },
          set(val) {
            var _a2, _b;
            if (isGroup.value && isArray$1(val)) {
              isLimitExceeded.value = ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value) && val.length > model.value.length;
              isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
            } else {
              emit(UPDATE_MODEL_EVENT, val);
              selfModel.value = val;
            }
          }
        });
        return {
          model,
          isGroup,
          isLimitExceeded
        };
      };
      const useCheckboxStatus = (props, slots, { model }) => {
        const checkboxGroup = vue.inject(checkboxGroupContextKey, void 0);
        const isFocused = vue.ref(false);
        const actualValue = vue.computed(() => {
          if (!isPropAbsent(props.value)) {
            return props.value;
          }
          return props.label;
        });
        const isChecked = vue.computed(() => {
          const value = model.value;
          if (isBoolean(value)) {
            return value;
          } else if (isArray$1(value)) {
            if (isObject$1(actualValue.value)) {
              return value.map(vue.toRaw).some((o) => isEqual(o, actualValue.value));
            } else {
              return value.map(vue.toRaw).includes(actualValue.value);
            }
          } else if (value !== null && value !== void 0) {
            return value === props.trueValue || value === props.trueLabel;
          } else {
            return !!value;
          }
        });
        const checkboxButtonSize = useFormSize(vue.computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }), {
          prop: true
        });
        const checkboxSize = useFormSize(vue.computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }));
        const hasOwnLabel = vue.computed(() => {
          return !!slots.default || !isPropAbsent(actualValue.value);
        });
        return {
          checkboxButtonSize,
          isChecked,
          isFocused,
          checkboxSize,
          hasOwnLabel,
          actualValue
        };
      };
      const useCheckbox = (props, slots) => {
        const { formItem: elFormItem } = useFormItem();
        const { model, isGroup, isLimitExceeded } = useCheckboxModel(props);
        const {
          isFocused,
          isChecked,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          actualValue
        } = useCheckboxStatus(props, slots, { model });
        const { isDisabled } = useCheckboxDisabled({ model, isChecked });
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: elFormItem,
          disableIdGeneration: hasOwnLabel,
          disableIdManagement: isGroup
        });
        const { handleChange, onClickRoot } = useCheckboxEvent(props, {
          model,
          isLimitExceeded,
          hasOwnLabel,
          isDisabled,
          isLabeledByFormItem
        });
        const setStoreValue = () => {
          function addToStore() {
            var _a2, _b;
            if (isArray$1(model.value) && !model.value.includes(actualValue.value)) {
              model.value.push(actualValue.value);
            } else {
              model.value = (_b = (_a2 = props.trueValue) != null ? _a2 : props.trueLabel) != null ? _b : true;
            }
          }
          props.checked && addToStore();
        };
        setStoreValue();
        useDeprecated({
          from: "label act as value",
          replacement: "value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, vue.computed(() => isGroup.value && isPropAbsent(props.value)));
        useDeprecated({
          from: "true-label",
          replacement: "true-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, vue.computed(() => !!props.trueLabel));
        useDeprecated({
          from: "false-label",
          replacement: "false-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, vue.computed(() => !!props.falseLabel));
        return {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          model,
          actualValue,
          handleChange,
          onClickRoot
        };
      };
      const __default__$q = vue.defineComponent({
        name: "ElCheckbox"
      });
      const _sfc_main$M = /* @__PURE__ */ vue.defineComponent({
        ...__default__$q,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = vue.useSlots();
          const {
            inputId,
            isLabeledByFormItem,
            isChecked,
            isDisabled,
            isFocused,
            checkboxSize,
            hasOwnLabel,
            model,
            actualValue,
            handleChange,
            onClickRoot
          } = useCheckbox(props, slots);
          const ns = useNamespace("checkbox");
          const compKls = vue.computed(() => {
            return [
              ns.b(),
              ns.m(checkboxSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("bordered", props.border),
              ns.is("checked", isChecked.value)
            ];
          });
          const spanKls = vue.computed(() => {
            return [
              ns.e("input"),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("indeterminate", props.indeterminate),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(!vue.unref(hasOwnLabel) && vue.unref(isLabeledByFormItem) ? "span" : "label"), {
              class: vue.normalizeClass(vue.unref(compKls)),
              "aria-controls": _ctx.indeterminate ? _ctx.ariaControls : null,
              onClick: vue.unref(onClickRoot)
            }, {
              default: vue.withCtx(() => {
                var _a2, _b, _c, _d;
                return [
                  vue.createElementVNode("span", {
                    class: vue.normalizeClass(vue.unref(spanKls))
                  }, [
                    _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
                      key: 0,
                      id: vue.unref(inputId),
                      "onUpdate:modelValue": ($event) => vue.isRef(model) ? model.value = $event : null,
                      class: vue.normalizeClass(vue.unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      disabled: vue.unref(isDisabled),
                      "true-value": (_b = (_a2 = _ctx.trueValue) != null ? _a2 : _ctx.trueLabel) != null ? _b : true,
                      "false-value": (_d = (_c = _ctx.falseValue) != null ? _c : _ctx.falseLabel) != null ? _d : false,
                      onChange: vue.unref(handleChange),
                      onFocus: ($event) => isFocused.value = true,
                      onBlur: ($event) => isFocused.value = false,
                      onClick: vue.withModifiers(() => {
                      }, ["stop"])
                    }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [
                      [vue.vModelCheckbox, vue.unref(model)]
                    ]) : vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
                      key: 1,
                      id: vue.unref(inputId),
                      "onUpdate:modelValue": ($event) => vue.isRef(model) ? model.value = $event : null,
                      class: vue.normalizeClass(vue.unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      disabled: vue.unref(isDisabled),
                      value: vue.unref(actualValue),
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      onChange: vue.unref(handleChange),
                      onFocus: ($event) => isFocused.value = true,
                      onBlur: ($event) => isFocused.value = false,
                      onClick: vue.withModifiers(() => {
                      }, ["stop"])
                    }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "disabled", "value", "name", "tabindex", "onChange", "onFocus", "onBlur", "onClick"])), [
                      [vue.vModelCheckbox, vue.unref(model)]
                    ]),
                    vue.createElementVNode("span", {
                      class: vue.normalizeClass(vue.unref(ns).e("inner"))
                    }, null, 2)
                  ], 2),
                  vue.unref(hasOwnLabel) ? (vue.openBlock(), vue.createElementBlock("span", {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(ns).e("label"))
                  }, [
                    vue.renderSlot(_ctx.$slots, "default"),
                    !_ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                      vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)
                    ], 64)) : vue.createCommentVNode("v-if", true)
                  ], 2)) : vue.createCommentVNode("v-if", true)
                ];
              }),
              _: 3
            }, 8, ["class", "aria-controls", "onClick"]);
          };
        }
      });
      var Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["__file", "checkbox.vue"]]);
      const __default__$p = vue.defineComponent({
        name: "ElCheckboxButton"
      });
      const _sfc_main$L = /* @__PURE__ */ vue.defineComponent({
        ...__default__$p,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = vue.useSlots();
          const {
            isFocused,
            isChecked,
            isDisabled,
            checkboxButtonSize,
            model,
            actualValue,
            handleChange
          } = useCheckbox(props, slots);
          const checkboxGroup = vue.inject(checkboxGroupContextKey, void 0);
          const ns = useNamespace("checkbox");
          const activeStyle = vue.computed(() => {
            var _a2, _b, _c, _d;
            const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
            return {
              backgroundColor: fillValue,
              borderColor: fillValue,
              color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
              boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
            };
          });
          const labelKls = vue.computed(() => {
            return [
              ns.b("button"),
              ns.bm("button", checkboxButtonSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            var _a2, _b, _c, _d;
            return vue.openBlock(), vue.createElementBlock("label", {
              class: vue.normalizeClass(vue.unref(labelKls))
            }, [
              _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": ($event) => vue.isRef(model) ? model.value = $event : null,
                class: vue.normalizeClass(vue.unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: vue.unref(isDisabled),
                "true-value": (_b = (_a2 = _ctx.trueValue) != null ? _a2 : _ctx.trueLabel) != null ? _b : true,
                "false-value": (_d = (_c = _ctx.falseValue) != null ? _c : _ctx.falseLabel) != null ? _d : false,
                onChange: vue.unref(handleChange),
                onFocus: ($event) => isFocused.value = true,
                onBlur: ($event) => isFocused.value = false,
                onClick: vue.withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [
                [vue.vModelCheckbox, vue.unref(model)]
              ]) : vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": ($event) => vue.isRef(model) ? model.value = $event : null,
                class: vue.normalizeClass(vue.unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: vue.unref(isDisabled),
                value: vue.unref(actualValue),
                onChange: vue.unref(handleChange),
                onFocus: ($event) => isFocused.value = true,
                onBlur: ($event) => isFocused.value = false,
                onClick: vue.withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "value", "onChange", "onFocus", "onBlur", "onClick"])), [
                [vue.vModelCheckbox, vue.unref(model)]
              ]),
              _ctx.$slots.default || _ctx.label ? (vue.openBlock(), vue.createElementBlock("span", {
                key: 2,
                class: vue.normalizeClass(vue.unref(ns).be("button", "inner")),
                style: vue.normalizeStyle(vue.unref(isChecked) ? vue.unref(activeStyle) : void 0)
              }, [
                vue.renderSlot(_ctx.$slots, "default", {}, () => [
                  vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)
                ])
              ], 6)) : vue.createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var CheckboxButton = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["__file", "checkbox-button.vue"]]);
      const checkboxGroupProps = buildProps({
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        disabled: Boolean,
        min: Number,
        max: Number,
        size: useSizeProp,
        fill: String,
        textColor: String,
        tag: {
          type: String,
          default: "div"
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      });
      const checkboxGroupEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isArray$1(val),
        change: (val) => isArray$1(val)
      };
      const __default__$o = vue.defineComponent({
        name: "ElCheckboxGroup"
      });
      const _sfc_main$K = /* @__PURE__ */ vue.defineComponent({
        ...__default__$o,
        props: checkboxGroupProps,
        emits: checkboxGroupEmits,
        setup(__props, { emit }) {
          const props = __props;
          const ns = useNamespace("checkbox");
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const changeEvent = async (value) => {
            emit(UPDATE_MODEL_EVENT, value);
            await vue.nextTick();
            emit("change", value);
          };
          const modelValue = vue.computed({
            get() {
              return props.modelValue;
            },
            set(val) {
              changeEvent(val);
            }
          });
          vue.provide(checkboxGroupContextKey, {
            ...pick(vue.toRefs(props), [
              "size",
              "min",
              "max",
              "disabled",
              "validateEvent",
              "fill",
              "textColor"
            ]),
            modelValue,
            changeEvent
          });
          vue.watch(() => props.modelValue, () => {
            if (props.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
            }
          });
          return (_ctx, _cache) => {
            var _a2;
            return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.tag), {
              id: vue.unref(groupId),
              class: vue.normalizeClass(vue.unref(ns).b("group")),
              role: "group",
              "aria-label": !vue.unref(isLabeledByFormItem) ? _ctx.ariaLabel || "checkbox-group" : void 0,
              "aria-labelledby": vue.unref(isLabeledByFormItem) ? (_a2 = vue.unref(formItem)) == null ? void 0 : _a2.labelId : void 0
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var CheckboxGroup = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["__file", "checkbox-group.vue"]]);
      const ElCheckbox = withInstall(Checkbox, {
        CheckboxButton,
        CheckboxGroup
      });
      withNoopInstall(CheckboxButton);
      withNoopInstall(CheckboxGroup);
      const tagProps = buildProps({
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger"],
          default: "primary"
        },
        closable: Boolean,
        disableTransitions: Boolean,
        hit: Boolean,
        color: String,
        size: {
          type: String,
          values: componentSizes
        },
        effect: {
          type: String,
          values: ["dark", "light", "plain"],
          default: "light"
        },
        round: Boolean
      });
      const tagEmits = {
        close: (evt) => evt instanceof MouseEvent,
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$n = vue.defineComponent({
        name: "ElTag"
      });
      const _sfc_main$J = /* @__PURE__ */ vue.defineComponent({
        ...__default__$n,
        props: tagProps,
        emits: tagEmits,
        setup(__props, { emit }) {
          const props = __props;
          const tagSize = useFormSize();
          const ns = useNamespace("tag");
          const containerKls = vue.computed(() => {
            const { type, hit, effect, closable, round } = props;
            return [
              ns.b(),
              ns.is("closable", closable),
              ns.m(type || "primary"),
              ns.m(tagSize.value),
              ns.m(effect),
              ns.is("hit", hit),
              ns.is("round", round)
            ];
          });
          const handleClose = (event) => {
            emit("close", event);
          };
          const handleClick = (event) => {
            emit("click", event);
          };
          const handleVNodeMounted = (vnode) => {
            vnode.component.subTree.component.bum = null;
          };
          return (_ctx, _cache) => {
            return _ctx.disableTransitions ? (vue.openBlock(), vue.createElementBlock("span", {
              key: 0,
              class: vue.normalizeClass(vue.unref(containerKls)),
              style: vue.normalizeStyle({ backgroundColor: _ctx.color }),
              onClick: handleClick
            }, [
              vue.createElementVNode("span", {
                class: vue.normalizeClass(vue.unref(ns).e("content"))
              }, [
                vue.renderSlot(_ctx.$slots, "default")
              ], 2),
              _ctx.closable ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).e("close")),
                onClick: vue.withModifiers(handleClose, ["stop"])
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(vue.unref(close_default))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : vue.createCommentVNode("v-if", true)
            ], 6)) : (vue.openBlock(), vue.createBlock(vue.Transition, {
              key: 1,
              name: `${vue.unref(ns).namespace.value}-zoom-in-center`,
              appear: "",
              onVnodeMounted: handleVNodeMounted
            }, {
              default: vue.withCtx(() => [
                vue.createElementVNode("span", {
                  class: vue.normalizeClass(vue.unref(containerKls)),
                  style: vue.normalizeStyle({ backgroundColor: _ctx.color }),
                  onClick: handleClick
                }, [
                  vue.createElementVNode("span", {
                    class: vue.normalizeClass(vue.unref(ns).e("content"))
                  }, [
                    vue.renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.closable ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(ns).e("close")),
                    onClick: vue.withModifiers(handleClose, ["stop"])
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(close_default))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : vue.createCommentVNode("v-if", true)
                ], 6)
              ]),
              _: 3
            }, 8, ["name"]));
          };
        }
      });
      var Tag = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__file", "tag.vue"]]);
      const ElTag = withInstall(Tag);
      const rowContextKey = Symbol("rowContextKey");
      const RowJustify = [
        "start",
        "center",
        "end",
        "space-around",
        "space-between",
        "space-evenly"
      ];
      const RowAlign = ["top", "middle", "bottom"];
      const rowProps = buildProps({
        tag: {
          type: String,
          default: "div"
        },
        gutter: {
          type: Number,
          default: 0
        },
        justify: {
          type: String,
          values: RowJustify,
          default: "start"
        },
        align: {
          type: String,
          values: RowAlign
        }
      });
      const __default__$m = vue.defineComponent({
        name: "ElRow"
      });
      const _sfc_main$I = /* @__PURE__ */ vue.defineComponent({
        ...__default__$m,
        props: rowProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("row");
          const gutter = vue.computed(() => props.gutter);
          vue.provide(rowContextKey, {
            gutter
          });
          const style = vue.computed(() => {
            const styles = {};
            if (!props.gutter) {
              return styles;
            }
            styles.marginRight = styles.marginLeft = `-${props.gutter / 2}px`;
            return styles;
          });
          const rowKls = vue.computed(() => [
            ns.b(),
            ns.is(`justify-${props.justify}`, props.justify !== "start"),
            ns.is(`align-${props.align}`, !!props.align)
          ]);
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.tag), {
              class: vue.normalizeClass(vue.unref(rowKls)),
              style: vue.normalizeStyle(vue.unref(style))
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Row = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__file", "row.vue"]]);
      const ElRow = withInstall(Row);
      const colProps = buildProps({
        tag: {
          type: String,
          default: "div"
        },
        span: {
          type: Number,
          default: 24
        },
        offset: {
          type: Number,
          default: 0
        },
        pull: {
          type: Number,
          default: 0
        },
        push: {
          type: Number,
          default: 0
        },
        xs: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        sm: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        md: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        lg: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        xl: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        }
      });
      const __default__$l = vue.defineComponent({
        name: "ElCol"
      });
      const _sfc_main$H = /* @__PURE__ */ vue.defineComponent({
        ...__default__$l,
        props: colProps,
        setup(__props) {
          const props = __props;
          const { gutter } = vue.inject(rowContextKey, { gutter: vue.computed(() => 0) });
          const ns = useNamespace("col");
          const style = vue.computed(() => {
            const styles = {};
            if (gutter.value) {
              styles.paddingLeft = styles.paddingRight = `${gutter.value / 2}px`;
            }
            return styles;
          });
          const colKls = vue.computed(() => {
            const classes = [];
            const pos = ["span", "offset", "pull", "push"];
            pos.forEach((prop) => {
              const size2 = props[prop];
              if (isNumber(size2)) {
                if (prop === "span")
                  classes.push(ns.b(`${props[prop]}`));
                else if (size2 > 0)
                  classes.push(ns.b(`${prop}-${props[prop]}`));
              }
            });
            const sizes = ["xs", "sm", "md", "lg", "xl"];
            sizes.forEach((size2) => {
              if (isNumber(props[size2])) {
                classes.push(ns.b(`${size2}-${props[size2]}`));
              } else if (isObject$1(props[size2])) {
                Object.entries(props[size2]).forEach(([prop, sizeProp]) => {
                  classes.push(prop !== "span" ? ns.b(`${size2}-${prop}-${sizeProp}`) : ns.b(`${size2}-${sizeProp}`));
                });
              }
            });
            if (gutter.value) {
              classes.push(ns.is("guttered"));
            }
            return [ns.b(), classes];
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.tag), {
              class: vue.normalizeClass(vue.unref(colKls)),
              style: vue.normalizeStyle(vue.unref(style))
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Col = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["__file", "col.vue"]]);
      const ElCol = withInstall(Col);
      const emitChangeFn = (value) => isNumber(value) || isString(value) || isArray$1(value);
      const collapseProps = buildProps({
        accordion: Boolean,
        modelValue: {
          type: definePropType([Array, String, Number]),
          default: () => mutable([])
        }
      });
      const collapseEmits = {
        [UPDATE_MODEL_EVENT]: emitChangeFn,
        [CHANGE_EVENT]: emitChangeFn
      };
      const collapseContextKey = Symbol("collapseContextKey");
      const useCollapse = (props, emit) => {
        const activeNames = vue.ref(castArray(props.modelValue));
        const setActiveNames = (_activeNames) => {
          activeNames.value = _activeNames;
          const value = props.accordion ? activeNames.value[0] : activeNames.value;
          emit(UPDATE_MODEL_EVENT, value);
          emit(CHANGE_EVENT, value);
        };
        const handleItemClick = (name) => {
          if (props.accordion) {
            setActiveNames([activeNames.value[0] === name ? "" : name]);
          } else {
            const _activeNames = [...activeNames.value];
            const index = _activeNames.indexOf(name);
            if (index > -1) {
              _activeNames.splice(index, 1);
            } else {
              _activeNames.push(name);
            }
            setActiveNames(_activeNames);
          }
        };
        vue.watch(() => props.modelValue, () => activeNames.value = castArray(props.modelValue), { deep: true });
        vue.provide(collapseContextKey, {
          activeNames,
          handleItemClick
        });
        return {
          activeNames,
          setActiveNames
        };
      };
      const useCollapseDOM = () => {
        const ns = useNamespace("collapse");
        const rootKls = vue.computed(() => ns.b());
        return {
          rootKls
        };
      };
      const __default__$k = vue.defineComponent({
        name: "ElCollapse"
      });
      const _sfc_main$G = /* @__PURE__ */ vue.defineComponent({
        ...__default__$k,
        props: collapseProps,
        emits: collapseEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const { activeNames, setActiveNames } = useCollapse(props, emit);
          const { rootKls } = useCollapseDOM();
          expose({
            activeNames,
            setActiveNames
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: vue.normalizeClass(vue.unref(rootKls))
            }, [
              vue.renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Collapse = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__file", "collapse.vue"]]);
      const __default__$j = vue.defineComponent({
        name: "ElCollapseTransition"
      });
      const _sfc_main$F = /* @__PURE__ */ vue.defineComponent({
        ...__default__$j,
        setup(__props) {
          const ns = useNamespace("collapse-transition");
          const reset = (el) => {
            el.style.maxHeight = "";
            el.style.overflow = el.dataset.oldOverflow;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          };
          const on2 = {
            beforeEnter(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              if (el.style.height)
                el.dataset.elExistsHeight = el.style.height;
              el.style.maxHeight = 0;
              el.style.paddingTop = 0;
              el.style.paddingBottom = 0;
            },
            enter(el) {
              requestAnimationFrame(() => {
                el.dataset.oldOverflow = el.style.overflow;
                if (el.dataset.elExistsHeight) {
                  el.style.maxHeight = el.dataset.elExistsHeight;
                } else if (el.scrollHeight !== 0) {
                  el.style.maxHeight = `${el.scrollHeight}px`;
                } else {
                  el.style.maxHeight = 0;
                }
                el.style.paddingTop = el.dataset.oldPaddingTop;
                el.style.paddingBottom = el.dataset.oldPaddingBottom;
                el.style.overflow = "hidden";
              });
            },
            afterEnter(el) {
              el.style.maxHeight = "";
              el.style.overflow = el.dataset.oldOverflow;
            },
            enterCancelled(el) {
              reset(el);
            },
            beforeLeave(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              el.dataset.oldOverflow = el.style.overflow;
              el.style.maxHeight = `${el.scrollHeight}px`;
              el.style.overflow = "hidden";
            },
            leave(el) {
              if (el.scrollHeight !== 0) {
                el.style.maxHeight = 0;
                el.style.paddingTop = 0;
                el.style.paddingBottom = 0;
              }
            },
            afterLeave(el) {
              reset(el);
            },
            leaveCancelled(el) {
              reset(el);
            }
          };
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.Transition, vue.mergeProps({
              name: vue.unref(ns).b()
            }, vue.toHandlers(on2)), {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["name"]);
          };
        }
      });
      var CollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["__file", "collapse-transition.vue"]]);
      const ElCollapseTransition = withInstall(CollapseTransition);
      const collapseItemProps = buildProps({
        title: {
          type: String,
          default: ""
        },
        name: {
          type: definePropType([String, Number]),
          default: void 0
        },
        icon: {
          type: iconPropType,
          default: arrow_right_default
        },
        disabled: Boolean
      });
      const useCollapseItem = (props) => {
        const collapse = vue.inject(collapseContextKey);
        const { namespace } = useNamespace("collapse");
        const focusing = vue.ref(false);
        const isClick = vue.ref(false);
        const idInjection = useIdInjection();
        const id = vue.computed(() => idInjection.current++);
        const name = vue.computed(() => {
          var _a2;
          return (_a2 = props.name) != null ? _a2 : `${namespace.value}-id-${idInjection.prefix}-${vue.unref(id)}`;
        });
        const isActive = vue.computed(() => collapse == null ? void 0 : collapse.activeNames.value.includes(vue.unref(name)));
        const handleFocus = () => {
          setTimeout(() => {
            if (!isClick.value) {
              focusing.value = true;
            } else {
              isClick.value = false;
            }
          }, 50);
        };
        const handleHeaderClick = () => {
          if (props.disabled)
            return;
          collapse == null ? void 0 : collapse.handleItemClick(vue.unref(name));
          focusing.value = false;
          isClick.value = true;
        };
        const handleEnterClick = () => {
          collapse == null ? void 0 : collapse.handleItemClick(vue.unref(name));
        };
        return {
          focusing,
          id,
          isActive,
          handleFocus,
          handleHeaderClick,
          handleEnterClick
        };
      };
      const useCollapseItemDOM = (props, { focusing, isActive, id }) => {
        const ns = useNamespace("collapse");
        const rootKls = vue.computed(() => [
          ns.b("item"),
          ns.is("active", vue.unref(isActive)),
          ns.is("disabled", props.disabled)
        ]);
        const headKls = vue.computed(() => [
          ns.be("item", "header"),
          ns.is("active", vue.unref(isActive)),
          { focusing: vue.unref(focusing) && !props.disabled }
        ]);
        const arrowKls = vue.computed(() => [
          ns.be("item", "arrow"),
          ns.is("active", vue.unref(isActive))
        ]);
        const itemWrapperKls = vue.computed(() => ns.be("item", "wrap"));
        const itemContentKls = vue.computed(() => ns.be("item", "content"));
        const scopedContentId = vue.computed(() => ns.b(`content-${vue.unref(id)}`));
        const scopedHeadId = vue.computed(() => ns.b(`head-${vue.unref(id)}`));
        return {
          arrowKls,
          headKls,
          rootKls,
          itemWrapperKls,
          itemContentKls,
          scopedContentId,
          scopedHeadId
        };
      };
      const __default__$i = vue.defineComponent({
        name: "ElCollapseItem"
      });
      const _sfc_main$E = /* @__PURE__ */ vue.defineComponent({
        ...__default__$i,
        props: collapseItemProps,
        setup(__props, { expose }) {
          const props = __props;
          const {
            focusing,
            id,
            isActive,
            handleFocus,
            handleHeaderClick,
            handleEnterClick
          } = useCollapseItem(props);
          const {
            arrowKls,
            headKls,
            rootKls,
            itemWrapperKls,
            itemContentKls,
            scopedContentId,
            scopedHeadId
          } = useCollapseItemDOM(props, { focusing, isActive, id });
          expose({
            isActive
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: vue.normalizeClass(vue.unref(rootKls))
            }, [
              vue.createElementVNode("button", {
                id: vue.unref(scopedHeadId),
                class: vue.normalizeClass(vue.unref(headKls)),
                "aria-expanded": vue.unref(isActive),
                "aria-controls": vue.unref(scopedContentId),
                "aria-describedby": vue.unref(scopedContentId),
                tabindex: _ctx.disabled ? -1 : 0,
                type: "button",
                onClick: vue.unref(handleHeaderClick),
                onKeydown: vue.withKeys(vue.withModifiers(vue.unref(handleEnterClick), ["stop", "prevent"]), ["space", "enter"]),
                onFocus: vue.unref(handleFocus),
                onBlur: ($event) => focusing.value = false
              }, [
                vue.renderSlot(_ctx.$slots, "title", {}, () => [
                  vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)
                ]),
                vue.renderSlot(_ctx.$slots, "icon", { isActive: vue.unref(isActive) }, () => [
                  vue.createVNode(vue.unref(ElIcon), {
                    class: vue.normalizeClass(vue.unref(arrowKls))
                  }, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.icon)))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ])
              ], 42, ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex", "onClick", "onKeydown", "onFocus", "onBlur"]),
              vue.createVNode(vue.unref(ElCollapseTransition), null, {
                default: vue.withCtx(() => [
                  vue.withDirectives(vue.createElementVNode("div", {
                    id: vue.unref(scopedContentId),
                    role: "region",
                    class: vue.normalizeClass(vue.unref(itemWrapperKls)),
                    "aria-hidden": !vue.unref(isActive),
                    "aria-labelledby": vue.unref(scopedHeadId)
                  }, [
                    vue.createElementVNode("div", {
                      class: vue.normalizeClass(vue.unref(itemContentKls))
                    }, [
                      vue.renderSlot(_ctx.$slots, "default")
                    ], 2)
                  ], 10, ["id", "aria-hidden", "aria-labelledby"]), [
                    [vue.vShow, vue.unref(isActive)]
                  ])
                ]),
                _: 3
              })
            ], 2);
          };
        }
      });
      var CollapseItem$1 = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__file", "collapse-item.vue"]]);
      const ElCollapse = withInstall(Collapse, {
        CollapseItem: CollapseItem$1
      });
      const ElCollapseItem = withNoopInstall(CollapseItem$1);
      const alphaSliderProps = buildProps({
        color: {
          type: definePropType(Object),
          required: true
        },
        vertical: {
          type: Boolean,
          default: false
        }
      });
      let isDragging = false;
      function draggable(element, options) {
        if (!isClient)
          return;
        const moveFn = function(event) {
          var _a2;
          (_a2 = options.drag) == null ? void 0 : _a2.call(options, event);
        };
        const upFn = function(event) {
          var _a2;
          document.removeEventListener("mousemove", moveFn);
          document.removeEventListener("mouseup", upFn);
          document.removeEventListener("touchmove", moveFn);
          document.removeEventListener("touchend", upFn);
          document.onselectstart = null;
          document.ondragstart = null;
          isDragging = false;
          (_a2 = options.end) == null ? void 0 : _a2.call(options, event);
        };
        const downFn = function(event) {
          var _a2;
          if (isDragging)
            return;
          event.preventDefault();
          document.onselectstart = () => false;
          document.ondragstart = () => false;
          document.addEventListener("mousemove", moveFn);
          document.addEventListener("mouseup", upFn);
          document.addEventListener("touchmove", moveFn);
          document.addEventListener("touchend", upFn);
          isDragging = true;
          (_a2 = options.start) == null ? void 0 : _a2.call(options, event);
        };
        element.addEventListener("mousedown", downFn);
        element.addEventListener("touchstart", downFn, { passive: false });
      }
      const useAlphaSlider = (props) => {
        const instance = vue.getCurrentInstance();
        const { t } = useLocale();
        const thumb = vue.shallowRef();
        const bar = vue.shallowRef();
        const alpha = vue.computed(() => props.color.get("alpha"));
        const alphaLabel = vue.computed(() => t("el.colorpicker.alphaLabel"));
        function handleClick(event) {
          var _a2;
          const target = event.target;
          if (target !== thumb.value) {
            handleDrag(event);
          }
          (_a2 = thumb.value) == null ? void 0 : _a2.focus();
        }
        function handleDrag(event) {
          if (!bar.value || !thumb.value)
            return;
          const el = instance.vnode.el;
          const rect = el.getBoundingClientRect();
          const { clientX, clientY } = getClientXY(event);
          if (!props.vertical) {
            let left = clientX - rect.left;
            left = Math.max(thumb.value.offsetWidth / 2, left);
            left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
            props.color.set("alpha", Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
          } else {
            let top = clientY - rect.top;
            top = Math.max(thumb.value.offsetHeight / 2, top);
            top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
            props.color.set("alpha", Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
          }
        }
        function handleKeydown(event) {
          const { code, shiftKey } = event;
          const step = shiftKey ? 10 : 1;
          switch (code) {
            case EVENT_CODE.left:
            case EVENT_CODE.down:
              event.preventDefault();
              event.stopPropagation();
              incrementPosition(-step);
              break;
            case EVENT_CODE.right:
            case EVENT_CODE.up:
              event.preventDefault();
              event.stopPropagation();
              incrementPosition(step);
              break;
          }
        }
        function incrementPosition(step) {
          let next = alpha.value + step;
          next = next < 0 ? 0 : next > 100 ? 100 : next;
          props.color.set("alpha", next);
        }
        return {
          thumb,
          bar,
          alpha,
          alphaLabel,
          handleDrag,
          handleClick,
          handleKeydown
        };
      };
      const useAlphaSliderDOM = (props, {
        bar,
        thumb,
        handleDrag
      }) => {
        const instance = vue.getCurrentInstance();
        const ns = useNamespace("color-alpha-slider");
        const thumbLeft = vue.ref(0);
        const thumbTop = vue.ref(0);
        const background = vue.ref();
        function getThumbLeft() {
          if (!thumb.value)
            return 0;
          if (props.vertical)
            return 0;
          const el = instance.vnode.el;
          const alpha = props.color.get("alpha");
          if (!el)
            return 0;
          return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
        }
        function getThumbTop() {
          if (!thumb.value)
            return 0;
          const el = instance.vnode.el;
          if (!props.vertical)
            return 0;
          const alpha = props.color.get("alpha");
          if (!el)
            return 0;
          return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
        }
        function getBackground() {
          if (props.color && props.color.value) {
            const { r, g, b } = props.color.toRgb();
            return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`;
          }
          return "";
        }
        function update() {
          thumbLeft.value = getThumbLeft();
          thumbTop.value = getThumbTop();
          background.value = getBackground();
        }
        vue.onMounted(() => {
          if (!bar.value || !thumb.value)
            return;
          const dragConfig = {
            drag: (event) => {
              handleDrag(event);
            },
            end: (event) => {
              handleDrag(event);
            }
          };
          draggable(bar.value, dragConfig);
          draggable(thumb.value, dragConfig);
          update();
        });
        vue.watch(() => props.color.get("alpha"), () => update());
        vue.watch(() => props.color.value, () => update());
        const rootKls = vue.computed(() => [ns.b(), ns.is("vertical", props.vertical)]);
        const barKls = vue.computed(() => ns.e("bar"));
        const thumbKls = vue.computed(() => ns.e("thumb"));
        const barStyle = vue.computed(() => ({ background: background.value }));
        const thumbStyle = vue.computed(() => ({
          left: addUnit(thumbLeft.value),
          top: addUnit(thumbTop.value)
        }));
        return { rootKls, barKls, barStyle, thumbKls, thumbStyle, update };
      };
      const COMPONENT_NAME$5 = "ElColorAlphaSlider";
      const __default__$h = vue.defineComponent({
        name: COMPONENT_NAME$5
      });
      const _sfc_main$D = /* @__PURE__ */ vue.defineComponent({
        ...__default__$h,
        props: alphaSliderProps,
        setup(__props, { expose }) {
          const props = __props;
          const {
            alpha,
            alphaLabel,
            bar,
            thumb,
            handleDrag,
            handleClick,
            handleKeydown
          } = useAlphaSlider(props);
          const { rootKls, barKls, barStyle, thumbKls, thumbStyle, update } = useAlphaSliderDOM(props, {
            bar,
            thumb,
            handleDrag
          });
          expose({
            update,
            bar,
            thumb
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: vue.normalizeClass(vue.unref(rootKls))
            }, [
              vue.createElementVNode("div", {
                ref_key: "bar",
                ref: bar,
                class: vue.normalizeClass(vue.unref(barKls)),
                style: vue.normalizeStyle(vue.unref(barStyle)),
                onClick: vue.unref(handleClick)
              }, null, 14, ["onClick"]),
              vue.createElementVNode("div", {
                ref_key: "thumb",
                ref: thumb,
                class: vue.normalizeClass(vue.unref(thumbKls)),
                style: vue.normalizeStyle(vue.unref(thumbStyle)),
                "aria-label": vue.unref(alphaLabel),
                "aria-valuenow": vue.unref(alpha),
                "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                "aria-valuemin": "0",
                "aria-valuemax": "100",
                role: "slider",
                tabindex: "0",
                onKeydown: vue.unref(handleKeydown)
              }, null, 46, ["aria-label", "aria-valuenow", "aria-orientation", "onKeydown"])
            ], 2);
          };
        }
      });
      var AlphaSlider = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__file", "alpha-slider.vue"]]);
      const _sfc_main$C = vue.defineComponent({
        name: "ElColorHueSlider",
        props: {
          color: {
            type: Object,
            required: true
          },
          vertical: Boolean
        },
        setup(props) {
          const ns = useNamespace("color-hue-slider");
          const instance = vue.getCurrentInstance();
          const thumb = vue.ref();
          const bar = vue.ref();
          const thumbLeft = vue.ref(0);
          const thumbTop = vue.ref(0);
          const hueValue = vue.computed(() => {
            return props.color.get("hue");
          });
          vue.watch(() => hueValue.value, () => {
            update();
          });
          function handleClick(event) {
            const target = event.target;
            if (target !== thumb.value) {
              handleDrag(event);
            }
          }
          function handleDrag(event) {
            if (!bar.value || !thumb.value)
              return;
            const el = instance.vnode.el;
            const rect = el.getBoundingClientRect();
            const { clientX, clientY } = getClientXY(event);
            let hue;
            if (!props.vertical) {
              let left = clientX - rect.left;
              left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
              left = Math.max(thumb.value.offsetWidth / 2, left);
              hue = Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
            } else {
              let top = clientY - rect.top;
              top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
              top = Math.max(thumb.value.offsetHeight / 2, top);
              hue = Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
            }
            props.color.set("hue", hue);
          }
          function getThumbLeft() {
            if (!thumb.value)
              return 0;
            const el = instance.vnode.el;
            if (props.vertical)
              return 0;
            const hue = props.color.get("hue");
            if (!el)
              return 0;
            return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
          }
          function getThumbTop() {
            if (!thumb.value)
              return 0;
            const el = instance.vnode.el;
            if (!props.vertical)
              return 0;
            const hue = props.color.get("hue");
            if (!el)
              return 0;
            return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
          }
          function update() {
            thumbLeft.value = getThumbLeft();
            thumbTop.value = getThumbTop();
          }
          vue.onMounted(() => {
            if (!bar.value || !thumb.value)
              return;
            const dragConfig = {
              drag: (event) => {
                handleDrag(event);
              },
              end: (event) => {
                handleDrag(event);
              }
            };
            draggable(bar.value, dragConfig);
            draggable(thumb.value, dragConfig);
            update();
          });
          return {
            bar,
            thumb,
            thumbLeft,
            thumbTop,
            hueValue,
            handleClick,
            update,
            ns
          };
        }
      });
      function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.openBlock(), vue.createElementBlock("div", {
          class: vue.normalizeClass([_ctx.ns.b(), _ctx.ns.is("vertical", _ctx.vertical)])
        }, [
          vue.createElementVNode("div", {
            ref: "bar",
            class: vue.normalizeClass(_ctx.ns.e("bar")),
            onClick: _ctx.handleClick
          }, null, 10, ["onClick"]),
          vue.createElementVNode("div", {
            ref: "thumb",
            class: vue.normalizeClass(_ctx.ns.e("thumb")),
            style: vue.normalizeStyle({
              left: _ctx.thumbLeft + "px",
              top: _ctx.thumbTop + "px"
            })
          }, null, 6)
        ], 2);
      }
      var HueSlider = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$7], ["__file", "hue-slider.vue"]]);
      const colorPickerProps = buildProps({
        modelValue: String,
        id: String,
        showAlpha: Boolean,
        colorFormat: String,
        disabled: Boolean,
        size: useSizeProp,
        popperClass: {
          type: String,
          default: ""
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        teleported: useTooltipContentProps.teleported,
        predefine: {
          type: definePropType(Array)
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      });
      const colorPickerEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString(val) || isNil(val),
        [CHANGE_EVENT]: (val) => isString(val) || isNil(val),
        activeChange: (val) => isString(val) || isNil(val),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent
      };
      const colorPickerContextKey = Symbol("colorPickerContextKey");
      const hsv2hsl = function(hue, sat, val) {
        return [
          hue,
          sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0,
          hue / 2
        ];
      };
      const isOnePointZero = function(n) {
        return typeof n === "string" && n.includes(".") && Number.parseFloat(n) === 1;
      };
      const isPercentage = function(n) {
        return typeof n === "string" && n.includes("%");
      };
      const bound01 = function(value, max2) {
        if (isOnePointZero(value))
          value = "100%";
        const processPercent = isPercentage(value);
        value = Math.min(max2, Math.max(0, Number.parseFloat(`${value}`)));
        if (processPercent) {
          value = Number.parseInt(`${value * max2}`, 10) / 100;
        }
        if (Math.abs(value - max2) < 1e-6) {
          return 1;
        }
        return value % max2 / Number.parseFloat(max2);
      };
      const INT_HEX_MAP = {
        10: "A",
        11: "B",
        12: "C",
        13: "D",
        14: "E",
        15: "F"
      };
      const hexOne = (value) => {
        value = Math.min(Math.round(value), 255);
        const high = Math.floor(value / 16);
        const low = value % 16;
        return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`;
      };
      const toHex = function({ r, g, b }) {
        if (Number.isNaN(+r) || Number.isNaN(+g) || Number.isNaN(+b))
          return "";
        return `#${hexOne(r)}${hexOne(g)}${hexOne(b)}`;
      };
      const HEX_INT_MAP = {
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15
      };
      const parseHexChannel = function(hex) {
        if (hex.length === 2) {
          return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
        }
        return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
      };
      const hsl2hsv = function(hue, sat, light) {
        sat = sat / 100;
        light = light / 100;
        let smin = sat;
        const lmin = Math.max(light, 0.01);
        light *= 2;
        sat *= light <= 1 ? light : 2 - light;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v = (light + sat) / 2;
        const sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
        return {
          h: hue,
          s: sv * 100,
          v: v * 100
        };
      };
      const rgb2hsv = (r, g, b) => {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        const max2 = Math.max(r, g, b);
        const min2 = Math.min(r, g, b);
        let h2;
        const v = max2;
        const d = max2 - min2;
        const s = max2 === 0 ? 0 : d / max2;
        if (max2 === min2) {
          h2 = 0;
        } else {
          switch (max2) {
            case r: {
              h2 = (g - b) / d + (g < b ? 6 : 0);
              break;
            }
            case g: {
              h2 = (b - r) / d + 2;
              break;
            }
            case b: {
              h2 = (r - g) / d + 4;
              break;
            }
          }
          h2 /= 6;
        }
        return { h: h2 * 360, s: s * 100, v: v * 100 };
      };
      const hsv2rgb = function(h2, s, v) {
        h2 = bound01(h2, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);
        const i = Math.floor(h2);
        const f = h2 - i;
        const p = v * (1 - s);
        const q2 = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);
        const mod = i % 6;
        const r = [v, q2, p, p, t, v][mod];
        const g = [t, v, v, q2, p, p][mod];
        const b = [p, p, t, v, v, q2][mod];
        return {
          r: Math.round(r * 255),
          g: Math.round(g * 255),
          b: Math.round(b * 255)
        };
      };
      class Color {
        constructor(options = {}) {
          this._hue = 0;
          this._saturation = 100;
          this._value = 100;
          this._alpha = 100;
          this.enableAlpha = false;
          this.format = "hex";
          this.value = "";
          for (const option in options) {
            if (hasOwn(options, option)) {
              this[option] = options[option];
            }
          }
          if (options.value) {
            this.fromString(options.value);
          } else {
            this.doOnChange();
          }
        }
        set(prop, value) {
          if (arguments.length === 1 && typeof prop === "object") {
            for (const p in prop) {
              if (hasOwn(prop, p)) {
                this.set(p, prop[p]);
              }
            }
            return;
          }
          this[`_${prop}`] = value;
          this.doOnChange();
        }
        get(prop) {
          if (prop === "alpha") {
            return Math.floor(this[`_${prop}`]);
          }
          return this[`_${prop}`];
        }
        toRgb() {
          return hsv2rgb(this._hue, this._saturation, this._value);
        }
        fromString(value) {
          if (!value) {
            this._hue = 0;
            this._saturation = 100;
            this._value = 100;
            this.doOnChange();
            return;
          }
          const fromHSV = (h2, s, v) => {
            this._hue = Math.max(0, Math.min(360, h2));
            this._saturation = Math.max(0, Math.min(100, s));
            this._value = Math.max(0, Math.min(100, v));
            this.doOnChange();
          };
          if (value.includes("hsl")) {
            const parts = value.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index) => index > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
            if (parts.length === 4) {
              this._alpha = Number.parseFloat(parts[3]) * 100;
            } else if (parts.length === 3) {
              this._alpha = 100;
            }
            if (parts.length >= 3) {
              const { h: h2, s, v } = hsl2hsv(parts[0], parts[1], parts[2]);
              fromHSV(h2, s, v);
            }
          } else if (value.includes("hsv")) {
            const parts = value.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index) => index > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
            if (parts.length === 4) {
              this._alpha = Number.parseFloat(parts[3]) * 100;
            } else if (parts.length === 3) {
              this._alpha = 100;
            }
            if (parts.length >= 3) {
              fromHSV(parts[0], parts[1], parts[2]);
            }
          } else if (value.includes("rgb")) {
            const parts = value.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index) => index > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
            if (parts.length === 4) {
              this._alpha = Number.parseFloat(parts[3]) * 100;
            } else if (parts.length === 3) {
              this._alpha = 100;
            }
            if (parts.length >= 3) {
              const { h: h2, s, v } = rgb2hsv(parts[0], parts[1], parts[2]);
              fromHSV(h2, s, v);
            }
          } else if (value.includes("#")) {
            const hex = value.replace("#", "").trim();
            if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex))
              return;
            let r, g, b;
            if (hex.length === 3) {
              r = parseHexChannel(hex[0] + hex[0]);
              g = parseHexChannel(hex[1] + hex[1]);
              b = parseHexChannel(hex[2] + hex[2]);
            } else if (hex.length === 6 || hex.length === 8) {
              r = parseHexChannel(hex.slice(0, 2));
              g = parseHexChannel(hex.slice(2, 4));
              b = parseHexChannel(hex.slice(4, 6));
            }
            if (hex.length === 8) {
              this._alpha = parseHexChannel(hex.slice(6)) / 255 * 100;
            } else if (hex.length === 3 || hex.length === 6) {
              this._alpha = 100;
            }
            const { h: h2, s, v } = rgb2hsv(r, g, b);
            fromHSV(h2, s, v);
          }
        }
        compare(color) {
          return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
        }
        doOnChange() {
          const { _hue, _saturation, _value, _alpha, format } = this;
          if (this.enableAlpha) {
            switch (format) {
              case "hsl": {
                const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
                this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${this.get("alpha") / 100})`;
                break;
              }
              case "hsv": {
                this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${this.get("alpha") / 100})`;
                break;
              }
              case "hex": {
                this.value = `${toHex(hsv2rgb(_hue, _saturation, _value))}${hexOne(_alpha * 255 / 100)}`;
                break;
              }
              default: {
                const { r, g, b } = hsv2rgb(_hue, _saturation, _value);
                this.value = `rgba(${r}, ${g}, ${b}, ${this.get("alpha") / 100})`;
              }
            }
          } else {
            switch (format) {
              case "hsl": {
                const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
                this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
                break;
              }
              case "hsv": {
                this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
                break;
              }
              case "rgb": {
                const { r, g, b } = hsv2rgb(_hue, _saturation, _value);
                this.value = `rgb(${r}, ${g}, ${b})`;
                break;
              }
              default: {
                this.value = toHex(hsv2rgb(_hue, _saturation, _value));
              }
            }
          }
        }
      }
      const _sfc_main$B = vue.defineComponent({
        props: {
          colors: {
            type: Array,
            required: true
          },
          color: {
            type: Object,
            required: true
          },
          enableAlpha: {
            type: Boolean,
            required: true
          }
        },
        setup(props) {
          const ns = useNamespace("color-predefine");
          const { currentColor } = vue.inject(colorPickerContextKey);
          const rgbaColors = vue.ref(parseColors(props.colors, props.color));
          vue.watch(() => currentColor.value, (val) => {
            const color = new Color();
            color.fromString(val);
            rgbaColors.value.forEach((item) => {
              item.selected = color.compare(item);
            });
          });
          vue.watchEffect(() => {
            rgbaColors.value = parseColors(props.colors, props.color);
          });
          function handleSelect(index) {
            props.color.fromString(props.colors[index]);
          }
          function parseColors(colors, color) {
            return colors.map((value) => {
              const c = new Color();
              c.enableAlpha = props.enableAlpha;
              c.format = "rgba";
              c.fromString(value);
              c.selected = c.value === color.value;
              return c;
            });
          }
          return {
            rgbaColors,
            handleSelect,
            ns
          };
        }
      });
      function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.openBlock(), vue.createElementBlock("div", {
          class: vue.normalizeClass(_ctx.ns.b())
        }, [
          vue.createElementVNode("div", {
            class: vue.normalizeClass(_ctx.ns.e("colors"))
          }, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.rgbaColors, (item, index) => {
              return vue.openBlock(), vue.createElementBlock("div", {
                key: _ctx.colors[index],
                class: vue.normalizeClass([
                  _ctx.ns.e("color-selector"),
                  _ctx.ns.is("alpha", item._alpha < 100),
                  { selected: item.selected }
                ]),
                onClick: ($event) => _ctx.handleSelect(index)
              }, [
                vue.createElementVNode("div", {
                  style: vue.normalizeStyle({ backgroundColor: item.value })
                }, null, 4)
              ], 10, ["onClick"]);
            }), 128))
          ], 2)
        ], 2);
      }
      var Predefine = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$6], ["__file", "predefine.vue"]]);
      const _sfc_main$A = vue.defineComponent({
        name: "ElSlPanel",
        props: {
          color: {
            type: Object,
            required: true
          }
        },
        setup(props) {
          const ns = useNamespace("color-svpanel");
          const instance = vue.getCurrentInstance();
          const cursorTop = vue.ref(0);
          const cursorLeft = vue.ref(0);
          const background = vue.ref("hsl(0, 100%, 50%)");
          const colorValue = vue.computed(() => {
            const hue = props.color.get("hue");
            const value = props.color.get("value");
            return { hue, value };
          });
          function update() {
            const saturation = props.color.get("saturation");
            const value = props.color.get("value");
            const el = instance.vnode.el;
            const { clientWidth: width, clientHeight: height } = el;
            cursorLeft.value = saturation * width / 100;
            cursorTop.value = (100 - value) * height / 100;
            background.value = `hsl(${props.color.get("hue")}, 100%, 50%)`;
          }
          function handleDrag(event) {
            const el = instance.vnode.el;
            const rect = el.getBoundingClientRect();
            const { clientX, clientY } = getClientXY(event);
            let left = clientX - rect.left;
            let top = clientY - rect.top;
            left = Math.max(0, left);
            left = Math.min(left, rect.width);
            top = Math.max(0, top);
            top = Math.min(top, rect.height);
            cursorLeft.value = left;
            cursorTop.value = top;
            props.color.set({
              saturation: left / rect.width * 100,
              value: 100 - top / rect.height * 100
            });
          }
          vue.watch(() => colorValue.value, () => {
            update();
          });
          vue.onMounted(() => {
            draggable(instance.vnode.el, {
              drag: (event) => {
                handleDrag(event);
              },
              end: (event) => {
                handleDrag(event);
              }
            });
            update();
          });
          return {
            cursorTop,
            cursorLeft,
            background,
            colorValue,
            handleDrag,
            update,
            ns
          };
        }
      });
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.openBlock(), vue.createElementBlock("div", {
          class: vue.normalizeClass(_ctx.ns.b()),
          style: vue.normalizeStyle({
            backgroundColor: _ctx.background
          })
        }, [
          vue.createElementVNode("div", {
            class: vue.normalizeClass(_ctx.ns.e("white"))
          }, null, 2),
          vue.createElementVNode("div", {
            class: vue.normalizeClass(_ctx.ns.e("black"))
          }, null, 2),
          vue.createElementVNode("div", {
            class: vue.normalizeClass(_ctx.ns.e("cursor")),
            style: vue.normalizeStyle({
              top: _ctx.cursorTop + "px",
              left: _ctx.cursorLeft + "px"
            })
          }, [
            vue.createElementVNode("div")
          ], 6)
        ], 6);
      }
      var SvPanel = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$5], ["__file", "sv-panel.vue"]]);
      const __default__$g = vue.defineComponent({
        name: "ElColorPicker"
      });
      const _sfc_main$z = /* @__PURE__ */ vue.defineComponent({
        ...__default__$g,
        props: colorPickerProps,
        emits: colorPickerEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("color");
          const { formItem } = useFormItem();
          const colorSize = useFormSize();
          const colorDisabled = useFormDisabled();
          const { inputId: buttonId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const hue = vue.ref();
          const sv = vue.ref();
          const alpha = vue.ref();
          const popper = vue.ref();
          const triggerRef = vue.ref();
          const inputRef = vue.ref();
          const { isFocused, handleFocus, handleBlur } = useFocusController(triggerRef, {
            beforeFocus() {
              return colorDisabled.value;
            },
            beforeBlur(event) {
              var _a2;
              return (_a2 = popper.value) == null ? void 0 : _a2.isFocusInsideContent(event);
            },
            afterBlur() {
              setShowPicker(false);
              resetColor();
            }
          });
          let shouldActiveChange = true;
          const color = vue.reactive(new Color({
            enableAlpha: props.showAlpha,
            format: props.colorFormat || "",
            value: props.modelValue
          }));
          const showPicker = vue.ref(false);
          const showPanelColor = vue.ref(false);
          const customInput = vue.ref("");
          const displayedColor = vue.computed(() => {
            if (!props.modelValue && !showPanelColor.value) {
              return "transparent";
            }
            return displayedRgb(color, props.showAlpha);
          });
          const currentColor = vue.computed(() => {
            return !props.modelValue && !showPanelColor.value ? "" : color.value;
          });
          const buttonAriaLabel = vue.computed(() => {
            return !isLabeledByFormItem.value ? props.ariaLabel || t("el.colorpicker.defaultLabel") : void 0;
          });
          const buttonAriaLabelledby = vue.computed(() => {
            return isLabeledByFormItem.value ? formItem == null ? void 0 : formItem.labelId : void 0;
          });
          const btnKls = vue.computed(() => {
            return [
              ns.b("picker"),
              ns.is("disabled", colorDisabled.value),
              ns.bm("picker", colorSize.value),
              ns.is("focused", isFocused.value)
            ];
          });
          function displayedRgb(color2, showAlpha) {
            if (!(color2 instanceof Color)) {
              throw new TypeError("color should be instance of _color Class");
            }
            const { r, g, b } = color2.toRgb();
            return showAlpha ? `rgba(${r}, ${g}, ${b}, ${color2.get("alpha") / 100})` : `rgb(${r}, ${g}, ${b})`;
          }
          function setShowPicker(value) {
            showPicker.value = value;
          }
          const debounceSetShowPicker = debounce(setShowPicker, 100, { leading: true });
          function show() {
            if (colorDisabled.value)
              return;
            setShowPicker(true);
          }
          function hide() {
            debounceSetShowPicker(false);
            resetColor();
          }
          function resetColor() {
            vue.nextTick(() => {
              if (props.modelValue) {
                color.fromString(props.modelValue);
              } else {
                color.value = "";
                vue.nextTick(() => {
                  showPanelColor.value = false;
                });
              }
            });
          }
          function handleTrigger() {
            if (colorDisabled.value)
              return;
            debounceSetShowPicker(!showPicker.value);
          }
          function handleConfirm() {
            color.fromString(customInput.value);
          }
          function confirmValue() {
            const value = color.value;
            emit(UPDATE_MODEL_EVENT, value);
            emit("change", value);
            if (props.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
            }
            debounceSetShowPicker(false);
            vue.nextTick(() => {
              const newColor = new Color({
                enableAlpha: props.showAlpha,
                format: props.colorFormat || "",
                value: props.modelValue
              });
              if (!color.compare(newColor)) {
                resetColor();
              }
            });
          }
          function clear() {
            debounceSetShowPicker(false);
            emit(UPDATE_MODEL_EVENT, null);
            emit("change", null);
            if (props.modelValue !== null && props.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
            }
            resetColor();
          }
          function handleClickOutside() {
            if (!showPicker.value)
              return;
            hide();
            isFocused.value && focus();
          }
          function handleEsc(event) {
            event.preventDefault();
            event.stopPropagation();
            setShowPicker(false);
            resetColor();
          }
          function handleKeyDown(event) {
            switch (event.code) {
              case EVENT_CODE.enter:
              case EVENT_CODE.space:
                event.preventDefault();
                event.stopPropagation();
                show();
                inputRef.value.focus();
                break;
              case EVENT_CODE.esc:
                handleEsc(event);
                break;
            }
          }
          function focus() {
            triggerRef.value.focus();
          }
          function blur() {
            triggerRef.value.blur();
          }
          vue.onMounted(() => {
            if (props.modelValue) {
              customInput.value = currentColor.value;
            }
          });
          vue.watch(() => props.modelValue, (newVal) => {
            if (!newVal) {
              showPanelColor.value = false;
            } else if (newVal && newVal !== color.value) {
              shouldActiveChange = false;
              color.fromString(newVal);
            }
          });
          vue.watch(() => [props.colorFormat, props.showAlpha], () => {
            color.enableAlpha = props.showAlpha;
            color.format = props.colorFormat || color.format;
            color.doOnChange();
            emit(UPDATE_MODEL_EVENT, color.value);
          });
          vue.watch(() => currentColor.value, (val) => {
            customInput.value = val;
            shouldActiveChange && emit("activeChange", val);
            shouldActiveChange = true;
          });
          vue.watch(() => color.value, () => {
            if (!props.modelValue && !showPanelColor.value) {
              showPanelColor.value = true;
            }
          });
          vue.watch(() => showPicker.value, () => {
            vue.nextTick(() => {
              var _a2, _b, _c;
              (_a2 = hue.value) == null ? void 0 : _a2.update();
              (_b = sv.value) == null ? void 0 : _b.update();
              (_c = alpha.value) == null ? void 0 : _c.update();
            });
          });
          vue.provide(colorPickerContextKey, {
            currentColor
          });
          expose({
            color,
            show,
            hide,
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.unref(ElTooltip), {
              ref_key: "popper",
              ref: popper,
              visible: showPicker.value,
              "show-arrow": false,
              "fallback-placements": ["bottom", "top", "right", "left"],
              offset: 0,
              "gpu-acceleration": false,
              "popper-class": [vue.unref(ns).be("picker", "panel"), vue.unref(ns).b("dropdown"), _ctx.popperClass],
              "stop-popper-mouse-event": false,
              effect: "light",
              trigger: "click",
              teleported: _ctx.teleported,
              transition: `${vue.unref(ns).namespace.value}-zoom-in-top`,
              persistent: "",
              onHide: ($event) => setShowPicker(false)
            }, {
              content: vue.withCtx(() => [
                vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
                  onKeydown: vue.withKeys(handleEsc, ["esc"])
                }, [
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass(vue.unref(ns).be("dropdown", "main-wrapper"))
                  }, [
                    vue.createVNode(HueSlider, {
                      ref_key: "hue",
                      ref: hue,
                      class: "hue-slider",
                      color: vue.unref(color),
                      vertical: ""
                    }, null, 8, ["color"]),
                    vue.createVNode(SvPanel, {
                      ref_key: "sv",
                      ref: sv,
                      color: vue.unref(color)
                    }, null, 8, ["color"])
                  ], 2),
                  _ctx.showAlpha ? (vue.openBlock(), vue.createBlock(AlphaSlider, {
                    key: 0,
                    ref_key: "alpha",
                    ref: alpha,
                    color: vue.unref(color)
                  }, null, 8, ["color"])) : vue.createCommentVNode("v-if", true),
                  _ctx.predefine ? (vue.openBlock(), vue.createBlock(Predefine, {
                    key: 1,
                    ref: "predefine",
                    "enable-alpha": _ctx.showAlpha,
                    color: vue.unref(color),
                    colors: _ctx.predefine
                  }, null, 8, ["enable-alpha", "color", "colors"])) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass(vue.unref(ns).be("dropdown", "btns"))
                  }, [
                    vue.createElementVNode("span", {
                      class: vue.normalizeClass(vue.unref(ns).be("dropdown", "value"))
                    }, [
                      vue.createVNode(vue.unref(ElInput), {
                        ref_key: "inputRef",
                        ref: inputRef,
                        modelValue: customInput.value,
                        "onUpdate:modelValue": ($event) => customInput.value = $event,
                        "validate-event": false,
                        size: "small",
                        onKeyup: vue.withKeys(handleConfirm, ["enter"]),
                        onBlur: handleConfirm
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "onKeyup"])
                    ], 2),
                    vue.createVNode(vue.unref(ElButton), {
                      class: vue.normalizeClass(vue.unref(ns).be("dropdown", "link-btn")),
                      text: "",
                      size: "small",
                      onClick: clear
                    }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(vue.toDisplayString(vue.unref(t)("el.colorpicker.clear")), 1)
                      ]),
                      _: 1
                    }, 8, ["class"]),
                    vue.createVNode(vue.unref(ElButton), {
                      plain: "",
                      size: "small",
                      class: vue.normalizeClass(vue.unref(ns).be("dropdown", "btn")),
                      onClick: confirmValue
                    }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(vue.toDisplayString(vue.unref(t)("el.colorpicker.confirm")), 1)
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ], 2)
                ], 40, ["onKeydown"])), [
                  [vue.unref(ClickOutside), handleClickOutside]
                ])
              ]),
              default: vue.withCtx(() => [
                vue.createElementVNode("div", vue.mergeProps({
                  id: vue.unref(buttonId),
                  ref_key: "triggerRef",
                  ref: triggerRef
                }, _ctx.$attrs, {
                  class: vue.unref(btnKls),
                  role: "button",
                  "aria-label": vue.unref(buttonAriaLabel),
                  "aria-labelledby": vue.unref(buttonAriaLabelledby),
                  "aria-description": vue.unref(t)("el.colorpicker.description", { color: _ctx.modelValue || "" }),
                  "aria-disabled": vue.unref(colorDisabled),
                  tabindex: vue.unref(colorDisabled) ? -1 : _ctx.tabindex,
                  onKeydown: handleKeyDown,
                  onFocus: vue.unref(handleFocus),
                  onBlur: vue.unref(handleBlur)
                }), [
                  vue.unref(colorDisabled) ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(ns).be("picker", "mask"))
                  }, null, 2)) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass(vue.unref(ns).be("picker", "trigger")),
                    onClick: handleTrigger
                  }, [
                    vue.createElementVNode("span", {
                      class: vue.normalizeClass([vue.unref(ns).be("picker", "color"), vue.unref(ns).is("alpha", _ctx.showAlpha)])
                    }, [
                      vue.createElementVNode("span", {
                        class: vue.normalizeClass(vue.unref(ns).be("picker", "color-inner")),
                        style: vue.normalizeStyle({
                          backgroundColor: vue.unref(displayedColor)
                        })
                      }, [
                        vue.withDirectives(vue.createVNode(vue.unref(ElIcon), {
                          class: vue.normalizeClass([vue.unref(ns).be("picker", "icon"), vue.unref(ns).is("icon-arrow-down")])
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(arrow_down_default))
                          ]),
                          _: 1
                        }, 8, ["class"]), [
                          [vue.vShow, _ctx.modelValue || showPanelColor.value]
                        ]),
                        vue.withDirectives(vue.createVNode(vue.unref(ElIcon), {
                          class: vue.normalizeClass([vue.unref(ns).be("picker", "empty"), vue.unref(ns).is("icon-close")])
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(close_default))
                          ]),
                          _: 1
                        }, 8, ["class"]), [
                          [vue.vShow, !_ctx.modelValue && !showPanelColor.value]
                        ])
                      ], 6)
                    ], 2)
                  ], 2)
                ], 16, ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex", "onFocus", "onBlur"])
              ]),
              _: 1
            }, 8, ["visible", "popper-class", "teleported", "transition", "onHide"]);
          };
        }
      });
      var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__file", "color-picker.vue"]]);
      const ElColorPicker = withInstall(ColorPicker);
      const overlayProps = buildProps({
        mask: {
          type: Boolean,
          default: true
        },
        customMaskEvent: Boolean,
        overlayClass: {
          type: definePropType([
            String,
            Array,
            Object
          ])
        },
        zIndex: {
          type: definePropType([String, Number])
        }
      });
      const overlayEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const BLOCK = "overlay";
      var Overlay = vue.defineComponent({
        name: "ElOverlay",
        props: overlayProps,
        emits: overlayEmits,
        setup(props, { slots, emit }) {
          const ns = useNamespace(BLOCK);
          const onMaskClick = (e) => {
            emit("click", e);
          };
          const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
          return () => {
            return props.mask ? vue.createVNode("div", {
              class: [ns.b(), props.overlayClass],
              style: {
                zIndex: props.zIndex
              },
              onClick,
              onMousedown,
              onMouseup
            }, [vue.renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : vue.h("div", {
              class: props.overlayClass,
              style: {
                zIndex: props.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
              }
            }, [vue.renderSlot(slots, "default")]);
          };
        }
      });
      const ElOverlay = Overlay;
      const dialogInjectionKey = Symbol("dialogInjectionKey");
      const dialogContentProps = buildProps({
        center: Boolean,
        alignCenter: Boolean,
        closeIcon: {
          type: iconPropType
        },
        draggable: Boolean,
        overflow: Boolean,
        fullscreen: Boolean,
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        ariaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogContentEmits = {
        close: () => true
      };
      const __default__$f = vue.defineComponent({ name: "ElDialogContent" });
      const _sfc_main$y = /* @__PURE__ */ vue.defineComponent({
        ...__default__$f,
        props: dialogContentProps,
        emits: dialogContentEmits,
        setup(__props, { expose }) {
          const props = __props;
          const { t } = useLocale();
          const { Close } = CloseComponents;
          const { dialogRef, headerRef, bodyId, ns, style } = vue.inject(dialogInjectionKey);
          const { focusTrapRef } = vue.inject(FOCUS_TRAP_INJECTION_KEY);
          const dialogKls = vue.computed(() => [
            ns.b(),
            ns.is("fullscreen", props.fullscreen),
            ns.is("draggable", props.draggable),
            ns.is("align-center", props.alignCenter),
            { [ns.m("center")]: props.center }
          ]);
          const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
          const draggable2 = vue.computed(() => props.draggable);
          const overflow = vue.computed(() => props.overflow);
          const { resetPosition } = useDraggable(dialogRef, headerRef, draggable2, overflow);
          expose({
            resetPosition
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              ref: vue.unref(composedDialogRef),
              class: vue.normalizeClass(vue.unref(dialogKls)),
              style: vue.normalizeStyle(vue.unref(style)),
              tabindex: "-1"
            }, [
              vue.createElementVNode("header", {
                ref_key: "headerRef",
                ref: headerRef,
                class: vue.normalizeClass([vue.unref(ns).e("header"), { "show-close": _ctx.showClose }])
              }, [
                vue.renderSlot(_ctx.$slots, "header", {}, () => [
                  vue.createElementVNode("span", {
                    role: "heading",
                    "aria-level": _ctx.ariaLevel,
                    class: vue.normalizeClass(vue.unref(ns).e("title"))
                  }, vue.toDisplayString(_ctx.title), 11, ["aria-level"])
                ]),
                _ctx.showClose ? (vue.openBlock(), vue.createElementBlock("button", {
                  key: 0,
                  "aria-label": vue.unref(t)("el.dialog.close"),
                  class: vue.normalizeClass(vue.unref(ns).e("headerbtn")),
                  type: "button",
                  onClick: ($event) => _ctx.$emit("close")
                }, [
                  vue.createVNode(vue.unref(ElIcon), {
                    class: vue.normalizeClass(vue.unref(ns).e("close"))
                  }, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.closeIcon || vue.unref(Close))))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, ["aria-label", "onClick"])) : vue.createCommentVNode("v-if", true)
              ], 2),
              vue.createElementVNode("div", {
                id: vue.unref(bodyId),
                class: vue.normalizeClass(vue.unref(ns).e("body"))
              }, [
                vue.renderSlot(_ctx.$slots, "default")
              ], 10, ["id"]),
              _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock("footer", {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).e("footer"))
              }, [
                vue.renderSlot(_ctx.$slots, "footer")
              ], 2)) : vue.createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var ElDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__file", "dialog-content.vue"]]);
      const dialogProps = buildProps({
        ...dialogContentProps,
        appendToBody: Boolean,
        appendTo: {
          type: definePropType([String, Object]),
          default: "body"
        },
        beforeClose: {
          type: definePropType(Function)
        },
        destroyOnClose: Boolean,
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        modal: {
          type: Boolean,
          default: true
        },
        openDelay: {
          type: Number,
          default: 0
        },
        closeDelay: {
          type: Number,
          default: 0
        },
        top: {
          type: String
        },
        modelValue: Boolean,
        modalClass: String,
        width: {
          type: [String, Number]
        },
        zIndex: {
          type: Number
        },
        trapFocus: Boolean,
        headerAriaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogEmits = {
        open: () => true,
        opened: () => true,
        close: () => true,
        closed: () => true,
        [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
        openAutoFocus: () => true,
        closeAutoFocus: () => true
      };
      const useDialog = (props, targetRef) => {
        var _a2;
        const instance = vue.getCurrentInstance();
        const emit = instance.emit;
        const { nextZIndex } = useZIndex();
        let lastPosition = "";
        const titleId = useId();
        const bodyId = useId();
        const visible = vue.ref(false);
        const closed = vue.ref(false);
        const rendered = vue.ref(false);
        const zIndex2 = vue.ref((_a2 = props.zIndex) != null ? _a2 : nextZIndex());
        let openTimer = void 0;
        let closeTimer = void 0;
        const namespace = useGlobalConfig("namespace", defaultNamespace);
        const style = vue.computed(() => {
          const style2 = {};
          const varPrefix = `--${namespace.value}-dialog`;
          if (!props.fullscreen) {
            if (props.top) {
              style2[`${varPrefix}-margin-top`] = props.top;
            }
            if (props.width) {
              style2[`${varPrefix}-width`] = addUnit(props.width);
            }
          }
          return style2;
        });
        const overlayDialogStyle = vue.computed(() => {
          if (props.alignCenter) {
            return { display: "flex" };
          }
          return {};
        });
        function afterEnter() {
          emit("opened");
        }
        function afterLeave() {
          emit("closed");
          emit(UPDATE_MODEL_EVENT, false);
          if (props.destroyOnClose) {
            rendered.value = false;
          }
        }
        function beforeLeave() {
          emit("close");
        }
        function open2() {
          closeTimer == null ? void 0 : closeTimer();
          openTimer == null ? void 0 : openTimer();
          if (props.openDelay && props.openDelay > 0) {
            ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props.openDelay));
          } else {
            doOpen();
          }
        }
        function close2() {
          openTimer == null ? void 0 : openTimer();
          closeTimer == null ? void 0 : closeTimer();
          if (props.closeDelay && props.closeDelay > 0) {
            ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props.closeDelay));
          } else {
            doClose();
          }
        }
        function handleClose() {
          function hide(shouldCancel) {
            if (shouldCancel)
              return;
            closed.value = true;
            visible.value = false;
          }
          if (props.beforeClose) {
            props.beforeClose(hide);
          } else {
            close2();
          }
        }
        function onModalClick() {
          if (props.closeOnClickModal) {
            handleClose();
          }
        }
        function doOpen() {
          if (!isClient)
            return;
          visible.value = true;
        }
        function doClose() {
          visible.value = false;
        }
        function onOpenAutoFocus() {
          emit("openAutoFocus");
        }
        function onCloseAutoFocus() {
          emit("closeAutoFocus");
        }
        function onFocusoutPrevented(event) {
          var _a22;
          if (((_a22 = event.detail) == null ? void 0 : _a22.focusReason) === "pointer") {
            event.preventDefault();
          }
        }
        if (props.lockScroll) {
          useLockscreen(visible);
        }
        function onCloseRequested() {
          if (props.closeOnPressEscape) {
            handleClose();
          }
        }
        vue.watch(() => props.modelValue, (val) => {
          if (val) {
            closed.value = false;
            open2();
            rendered.value = true;
            zIndex2.value = isUndefined$1(props.zIndex) ? nextZIndex() : zIndex2.value++;
            vue.nextTick(() => {
              emit("open");
              if (targetRef.value) {
                targetRef.value.scrollTop = 0;
              }
            });
          } else {
            if (visible.value) {
              close2();
            }
          }
        });
        vue.watch(() => props.fullscreen, (val) => {
          if (!targetRef.value)
            return;
          if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
          } else {
            targetRef.value.style.transform = lastPosition;
          }
        });
        vue.onMounted(() => {
          if (props.modelValue) {
            visible.value = true;
            rendered.value = true;
            open2();
          }
        });
        return {
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          close: close2,
          doClose,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented,
          titleId,
          bodyId,
          closed,
          style,
          overlayDialogStyle,
          rendered,
          visible,
          zIndex: zIndex2
        };
      };
      const __default__$e = vue.defineComponent({
        name: "ElDialog",
        inheritAttrs: false
      });
      const _sfc_main$x = /* @__PURE__ */ vue.defineComponent({
        ...__default__$e,
        props: dialogProps,
        emits: dialogEmits,
        setup(__props, { expose }) {
          const props = __props;
          const slots = vue.useSlots();
          useDeprecated({
            scope: "el-dialog",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#slots"
          }, vue.computed(() => !!slots.title));
          const ns = useNamespace("dialog");
          const dialogRef = vue.ref();
          const headerRef = vue.ref();
          const dialogContentRef = vue.ref();
          const {
            visible,
            titleId,
            bodyId,
            style,
            overlayDialogStyle,
            rendered,
            zIndex: zIndex2,
            afterEnter,
            afterLeave,
            beforeLeave,
            handleClose,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onCloseRequested,
            onFocusoutPrevented
          } = useDialog(props, dialogRef);
          vue.provide(dialogInjectionKey, {
            dialogRef,
            headerRef,
            bodyId,
            ns,
            rendered,
            style
          });
          const overlayEvent = useSameTarget(onModalClick);
          const draggable2 = vue.computed(() => props.draggable && !props.fullscreen);
          const resetPosition = () => {
            var _a2;
            (_a2 = dialogContentRef.value) == null ? void 0 : _a2.resetPosition();
          };
          expose({
            visible,
            dialogContentRef,
            resetPosition
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.unref(ElTeleport), {
              to: _ctx.appendTo,
              disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.Transition, {
                  name: "dialog-fade",
                  onAfterEnter: vue.unref(afterEnter),
                  onAfterLeave: vue.unref(afterLeave),
                  onBeforeLeave: vue.unref(beforeLeave),
                  persisted: ""
                }, {
                  default: vue.withCtx(() => [
                    vue.withDirectives(vue.createVNode(vue.unref(ElOverlay), {
                      "custom-mask-event": "",
                      mask: _ctx.modal,
                      "overlay-class": _ctx.modalClass,
                      "z-index": vue.unref(zIndex2)
                    }, {
                      default: vue.withCtx(() => [
                        vue.createElementVNode("div", {
                          role: "dialog",
                          "aria-modal": "true",
                          "aria-label": _ctx.title || void 0,
                          "aria-labelledby": !_ctx.title ? vue.unref(titleId) : void 0,
                          "aria-describedby": vue.unref(bodyId),
                          class: vue.normalizeClass(`${vue.unref(ns).namespace.value}-overlay-dialog`),
                          style: vue.normalizeStyle(vue.unref(overlayDialogStyle)),
                          onClick: vue.unref(overlayEvent).onClick,
                          onMousedown: vue.unref(overlayEvent).onMousedown,
                          onMouseup: vue.unref(overlayEvent).onMouseup
                        }, [
                          vue.createVNode(vue.unref(ElFocusTrap), {
                            loop: "",
                            trapped: vue.unref(visible),
                            "focus-start-el": "container",
                            onFocusAfterTrapped: vue.unref(onOpenAutoFocus),
                            onFocusAfterReleased: vue.unref(onCloseAutoFocus),
                            onFocusoutPrevented: vue.unref(onFocusoutPrevented),
                            onReleaseRequested: vue.unref(onCloseRequested)
                          }, {
                            default: vue.withCtx(() => [
                              vue.unref(rendered) ? (vue.openBlock(), vue.createBlock(ElDialogContent, vue.mergeProps({
                                key: 0,
                                ref_key: "dialogContentRef",
                                ref: dialogContentRef
                              }, _ctx.$attrs, {
                                center: _ctx.center,
                                "align-center": _ctx.alignCenter,
                                "close-icon": _ctx.closeIcon,
                                draggable: vue.unref(draggable2),
                                overflow: _ctx.overflow,
                                fullscreen: _ctx.fullscreen,
                                "show-close": _ctx.showClose,
                                title: _ctx.title,
                                "aria-level": _ctx.headerAriaLevel,
                                onClose: vue.unref(handleClose)
                              }), vue.createSlots({
                                header: vue.withCtx(() => [
                                  !_ctx.$slots.title ? vue.renderSlot(_ctx.$slots, "header", {
                                    key: 0,
                                    close: vue.unref(handleClose),
                                    titleId: vue.unref(titleId),
                                    titleClass: vue.unref(ns).e("title")
                                  }) : vue.renderSlot(_ctx.$slots, "title", { key: 1 })
                                ]),
                                default: vue.withCtx(() => [
                                  vue.renderSlot(_ctx.$slots, "default")
                                ]),
                                _: 2
                              }, [
                                _ctx.$slots.footer ? {
                                  name: "footer",
                                  fn: vue.withCtx(() => [
                                    vue.renderSlot(_ctx.$slots, "footer")
                                  ])
                                } : void 0
                              ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : vue.createCommentVNode("v-if", true)
                            ]),
                            _: 3
                          }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                        ], 46, ["aria-label", "aria-labelledby", "aria-describedby", "onClick", "onMousedown", "onMouseup"])
                      ]),
                      _: 3
                    }, 8, ["mask", "overlay-class", "z-index"]), [
                      [vue.vShow, vue.unref(visible)]
                    ])
                  ]),
                  _: 3
                }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
              ]),
              _: 3
            }, 8, ["to", "disabled"]);
          };
        }
      });
      var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__file", "dialog.vue"]]);
      const ElDialog = withInstall(Dialog);
      const __default__$d = vue.defineComponent({
        name: "ImgEmpty"
      });
      const _sfc_main$w = /* @__PURE__ */ vue.defineComponent({
        ...__default__$d,
        setup(__props) {
          const ns = useNamespace("empty");
          const id = useId();
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("svg", {
              viewBox: "0 0 79 86",
              version: "1.1",
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink"
            }, [
              vue.createElementVNode("defs", null, [
                vue.createElementVNode("linearGradient", {
                  id: `linearGradient-1-${vue.unref(id)}`,
                  x1: "38.8503086%",
                  y1: "0%",
                  x2: "61.1496914%",
                  y2: "100%"
                }, [
                  vue.createElementVNode("stop", {
                    "stop-color": `var(${vue.unref(ns).cssVarBlockName("fill-color-1")})`,
                    offset: "0%"
                  }, null, 8, ["stop-color"]),
                  vue.createElementVNode("stop", {
                    "stop-color": `var(${vue.unref(ns).cssVarBlockName("fill-color-4")})`,
                    offset: "100%"
                  }, null, 8, ["stop-color"])
                ], 8, ["id"]),
                vue.createElementVNode("linearGradient", {
                  id: `linearGradient-2-${vue.unref(id)}`,
                  x1: "0%",
                  y1: "9.5%",
                  x2: "100%",
                  y2: "90.5%"
                }, [
                  vue.createElementVNode("stop", {
                    "stop-color": `var(${vue.unref(ns).cssVarBlockName("fill-color-1")})`,
                    offset: "0%"
                  }, null, 8, ["stop-color"]),
                  vue.createElementVNode("stop", {
                    "stop-color": `var(${vue.unref(ns).cssVarBlockName("fill-color-6")})`,
                    offset: "100%"
                  }, null, 8, ["stop-color"])
                ], 8, ["id"]),
                vue.createElementVNode("rect", {
                  id: `path-3-${vue.unref(id)}`,
                  x: "0",
                  y: "0",
                  width: "17",
                  height: "36"
                }, null, 8, ["id"])
              ]),
              vue.createElementVNode("g", {
                id: "Illustrations",
                stroke: "none",
                "stroke-width": "1",
                fill: "none",
                "fill-rule": "evenodd"
              }, [
                vue.createElementVNode("g", {
                  id: "B-type",
                  transform: "translate(-1268.000000, -535.000000)"
                }, [
                  vue.createElementVNode("g", {
                    id: "Group-2",
                    transform: "translate(1268.000000, 535.000000)"
                  }, [
                    vue.createElementVNode("path", {
                      id: "Oval-Copy-2",
                      d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
                      fill: `var(${vue.unref(ns).cssVarBlockName("fill-color-3")})`
                    }, null, 8, ["fill"]),
                    vue.createElementVNode("polygon", {
                      id: "Rectangle-Copy-14",
                      fill: `var(${vue.unref(ns).cssVarBlockName("fill-color-7")})`,
                      transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
                      points: "13 58 53 58 42 45 2 45"
                    }, null, 8, ["fill"]),
                    vue.createElementVNode("g", {
                      id: "Group-Copy",
                      transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
                    }, [
                      vue.createElementVNode("polygon", {
                        id: "Rectangle-Copy-10",
                        fill: `var(${vue.unref(ns).cssVarBlockName("fill-color-7")})`,
                        transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
                        points: "2.84078316e-14 3 18 3 23 7 5 7"
                      }, null, 8, ["fill"]),
                      vue.createElementVNode("polygon", {
                        id: "Rectangle-Copy-11",
                        fill: `var(${vue.unref(ns).cssVarBlockName("fill-color-5")})`,
                        points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
                      }, null, 8, ["fill"]),
                      vue.createElementVNode("rect", {
                        id: "Rectangle-Copy-12",
                        fill: `url(#linearGradient-1-${vue.unref(id)})`,
                        transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                        x: "38",
                        y: "7",
                        width: "17",
                        height: "36"
                      }, null, 8, ["fill"]),
                      vue.createElementVNode("polygon", {
                        id: "Rectangle-Copy-13",
                        fill: `var(${vue.unref(ns).cssVarBlockName("fill-color-2")})`,
                        transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
                        points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
                      }, null, 8, ["fill"])
                    ]),
                    vue.createElementVNode("rect", {
                      id: "Rectangle-Copy-15",
                      fill: `url(#linearGradient-2-${vue.unref(id)})`,
                      x: "13",
                      y: "45",
                      width: "40",
                      height: "36"
                    }, null, 8, ["fill"]),
                    vue.createElementVNode("g", {
                      id: "Rectangle-Copy-17",
                      transform: "translate(53.000000, 45.000000)"
                    }, [
                      vue.createElementVNode("use", {
                        id: "Mask",
                        fill: `var(${vue.unref(ns).cssVarBlockName("fill-color-8")})`,
                        transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                        "xlink:href": `#path-3-${vue.unref(id)}`
                      }, null, 8, ["fill", "xlink:href"]),
                      vue.createElementVNode("polygon", {
                        id: "Rectangle-Copy",
                        fill: `var(${vue.unref(ns).cssVarBlockName("fill-color-9")})`,
                        mask: `url(#mask-4-${vue.unref(id)})`,
                        transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                        points: "7 0 24 0 20 18 7 16.5"
                      }, null, 8, ["fill", "mask"])
                    ]),
                    vue.createElementVNode("polygon", {
                      id: "Rectangle-Copy-18",
                      fill: `var(${vue.unref(ns).cssVarBlockName("fill-color-2")})`,
                      transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
                      points: "62 45 79 45 70 58 53 58"
                    }, null, 8, ["fill"])
                  ])
                ])
              ])
            ]);
          };
        }
      });
      var ImgEmpty = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__file", "img-empty.vue"]]);
      const emptyProps = buildProps({
        image: {
          type: String,
          default: ""
        },
        imageSize: Number,
        description: {
          type: String,
          default: ""
        }
      });
      const __default__$c = vue.defineComponent({
        name: "ElEmpty"
      });
      const _sfc_main$v = /* @__PURE__ */ vue.defineComponent({
        ...__default__$c,
        props: emptyProps,
        setup(__props) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("empty");
          const emptyDescription = vue.computed(() => props.description || t("el.table.emptyText"));
          const imageStyle = vue.computed(() => ({
            width: addUnit(props.imageSize)
          }));
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: vue.normalizeClass(vue.unref(ns).b())
            }, [
              vue.createElementVNode("div", {
                class: vue.normalizeClass(vue.unref(ns).e("image")),
                style: vue.normalizeStyle(vue.unref(imageStyle))
              }, [
                _ctx.image ? (vue.openBlock(), vue.createElementBlock("img", {
                  key: 0,
                  src: _ctx.image,
                  ondragstart: "return false"
                }, null, 8, ["src"])) : vue.renderSlot(_ctx.$slots, "image", { key: 1 }, () => [
                  vue.createVNode(ImgEmpty)
                ])
              ], 6),
              vue.createElementVNode("div", {
                class: vue.normalizeClass(vue.unref(ns).e("description"))
              }, [
                _ctx.$slots.description ? vue.renderSlot(_ctx.$slots, "description", { key: 0 }) : (vue.openBlock(), vue.createElementBlock("p", { key: 1 }, vue.toDisplayString(vue.unref(emptyDescription)), 1))
              ], 2),
              _ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock("div", {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).e("bottom"))
              }, [
                vue.renderSlot(_ctx.$slots, "default")
              ], 2)) : vue.createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Empty = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__file", "empty.vue"]]);
      const ElEmpty = withInstall(Empty);
      const imageViewerProps = buildProps({
        urlList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        hideOnClickModal: Boolean,
        teleported: Boolean,
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        },
        minScale: {
          type: Number,
          default: 0.2
        },
        maxScale: {
          type: Number,
          default: 7
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const imageViewerEmits = {
        close: () => true,
        switch: (index) => isNumber(index),
        rotate: (deg) => isNumber(deg)
      };
      const __default__$b = vue.defineComponent({
        name: "ElImageViewer"
      });
      const _sfc_main$u = /* @__PURE__ */ vue.defineComponent({
        ...__default__$b,
        props: imageViewerProps,
        emits: imageViewerEmits,
        setup(__props, { expose, emit }) {
          var _a2;
          const props = __props;
          const modes = {
            CONTAIN: {
              name: "contain",
              icon: vue.markRaw(full_screen_default)
            },
            ORIGINAL: {
              name: "original",
              icon: vue.markRaw(scale_to_original_default)
            }
          };
          const { t } = useLocale();
          const ns = useNamespace("image-viewer");
          const { nextZIndex } = useZIndex();
          const wrapper = vue.ref();
          const imgRefs = vue.ref([]);
          const scopeEventListener = vue.effectScope();
          const loading = vue.ref(true);
          const activeIndex = vue.ref(props.initialIndex);
          const mode = vue.shallowRef(modes.CONTAIN);
          const transform = vue.ref({
            scale: 1,
            deg: 0,
            offsetX: 0,
            offsetY: 0,
            enableTransition: false
          });
          const zIndex2 = vue.ref((_a2 = props.zIndex) != null ? _a2 : nextZIndex());
          const isSingle = vue.computed(() => {
            const { urlList } = props;
            return urlList.length <= 1;
          });
          const isFirst = vue.computed(() => {
            return activeIndex.value === 0;
          });
          const isLast = vue.computed(() => {
            return activeIndex.value === props.urlList.length - 1;
          });
          const currentImg = vue.computed(() => {
            return props.urlList[activeIndex.value];
          });
          const arrowPrevKls = vue.computed(() => [
            ns.e("btn"),
            ns.e("prev"),
            ns.is("disabled", !props.infinite && isFirst.value)
          ]);
          const arrowNextKls = vue.computed(() => [
            ns.e("btn"),
            ns.e("next"),
            ns.is("disabled", !props.infinite && isLast.value)
          ]);
          const imgStyle = vue.computed(() => {
            const { scale, deg, offsetX, offsetY, enableTransition } = transform.value;
            let translateX = offsetX / scale;
            let translateY = offsetY / scale;
            const radian = deg * Math.PI / 180;
            const cosRadian = Math.cos(radian);
            const sinRadian = Math.sin(radian);
            translateX = translateX * cosRadian + translateY * sinRadian;
            translateY = translateY * cosRadian - offsetX / scale * sinRadian;
            const style = {
              transform: `scale(${scale}) rotate(${deg}deg) translate(${translateX}px, ${translateY}px)`,
              transition: enableTransition ? "transform .3s" : ""
            };
            if (mode.value.name === modes.CONTAIN.name) {
              style.maxWidth = style.maxHeight = "100%";
            }
            return style;
          });
          function hide() {
            unregisterEventListener();
            emit("close");
          }
          function registerEventListener() {
            const keydownHandler = throttle((e) => {
              switch (e.code) {
                case EVENT_CODE.esc:
                  props.closeOnPressEscape && hide();
                  break;
                case EVENT_CODE.space:
                  toggleMode();
                  break;
                case EVENT_CODE.left:
                  prev();
                  break;
                case EVENT_CODE.up:
                  handleActions("zoomIn");
                  break;
                case EVENT_CODE.right:
                  next();
                  break;
                case EVENT_CODE.down:
                  handleActions("zoomOut");
                  break;
              }
            });
            const mousewheelHandler = throttle((e) => {
              const delta = e.deltaY || e.deltaX;
              handleActions(delta < 0 ? "zoomIn" : "zoomOut", {
                zoomRate: props.zoomRate,
                enableTransition: false
              });
            });
            scopeEventListener.run(() => {
              useEventListener(document, "keydown", keydownHandler);
              useEventListener(document, "wheel", mousewheelHandler);
            });
          }
          function unregisterEventListener() {
            scopeEventListener.stop();
          }
          function handleImgLoad() {
            loading.value = false;
          }
          function handleImgError(e) {
            loading.value = false;
            e.target.alt = t("el.image.error");
          }
          function handleMouseDown(e) {
            if (loading.value || e.button !== 0 || !wrapper.value)
              return;
            transform.value.enableTransition = false;
            const { offsetX, offsetY } = transform.value;
            const startX = e.pageX;
            const startY = e.pageY;
            const dragHandler = throttle((ev) => {
              transform.value = {
                ...transform.value,
                offsetX: offsetX + ev.pageX - startX,
                offsetY: offsetY + ev.pageY - startY
              };
            });
            const removeMousemove = useEventListener(document, "mousemove", dragHandler);
            useEventListener(document, "mouseup", () => {
              removeMousemove();
            });
            e.preventDefault();
          }
          function reset() {
            transform.value = {
              scale: 1,
              deg: 0,
              offsetX: 0,
              offsetY: 0,
              enableTransition: false
            };
          }
          function toggleMode() {
            if (loading.value)
              return;
            const modeNames = keysOf(modes);
            const modeValues = Object.values(modes);
            const currentMode = mode.value.name;
            const index = modeValues.findIndex((i) => i.name === currentMode);
            const nextIndex = (index + 1) % modeNames.length;
            mode.value = modes[modeNames[nextIndex]];
            reset();
          }
          function setActiveItem(index) {
            const len = props.urlList.length;
            activeIndex.value = (index + len) % len;
          }
          function prev() {
            if (isFirst.value && !props.infinite)
              return;
            setActiveItem(activeIndex.value - 1);
          }
          function next() {
            if (isLast.value && !props.infinite)
              return;
            setActiveItem(activeIndex.value + 1);
          }
          function handleActions(action, options = {}) {
            if (loading.value)
              return;
            const { minScale, maxScale } = props;
            const { zoomRate, rotateDeg, enableTransition } = {
              zoomRate: props.zoomRate,
              rotateDeg: 90,
              enableTransition: true,
              ...options
            };
            switch (action) {
              case "zoomOut":
                if (transform.value.scale > minScale) {
                  transform.value.scale = Number.parseFloat((transform.value.scale / zoomRate).toFixed(3));
                }
                break;
              case "zoomIn":
                if (transform.value.scale < maxScale) {
                  transform.value.scale = Number.parseFloat((transform.value.scale * zoomRate).toFixed(3));
                }
                break;
              case "clockwise":
                transform.value.deg += rotateDeg;
                emit("rotate", transform.value.deg);
                break;
              case "anticlockwise":
                transform.value.deg -= rotateDeg;
                emit("rotate", transform.value.deg);
                break;
            }
            transform.value.enableTransition = enableTransition;
          }
          vue.watch(currentImg, () => {
            vue.nextTick(() => {
              const $img = imgRefs.value[0];
              if (!($img == null ? void 0 : $img.complete)) {
                loading.value = true;
              }
            });
          });
          vue.watch(activeIndex, (val) => {
            reset();
            emit("switch", val);
          });
          vue.onMounted(() => {
            var _a22, _b;
            registerEventListener();
            (_b = (_a22 = wrapper.value) == null ? void 0 : _a22.focus) == null ? void 0 : _b.call(_a22);
          });
          expose({
            setActiveItem
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.unref(ElTeleport), {
              to: "body",
              disabled: !_ctx.teleported
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.Transition, {
                  name: "viewer-fade",
                  appear: ""
                }, {
                  default: vue.withCtx(() => [
                    vue.createElementVNode("div", {
                      ref_key: "wrapper",
                      ref: wrapper,
                      tabindex: -1,
                      class: vue.normalizeClass(vue.unref(ns).e("wrapper")),
                      style: vue.normalizeStyle({ zIndex: zIndex2.value })
                    }, [
                      vue.createElementVNode("div", {
                        class: vue.normalizeClass(vue.unref(ns).e("mask")),
                        onClick: vue.withModifiers(($event) => _ctx.hideOnClickModal && hide(), ["self"])
                      }, null, 10, ["onClick"]),
                      vue.createCommentVNode(" CLOSE "),
                      vue.createElementVNode("span", {
                        class: vue.normalizeClass([vue.unref(ns).e("btn"), vue.unref(ns).e("close")]),
                        onClick: hide
                      }, [
                        vue.createVNode(vue.unref(ElIcon), null, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(close_default))
                          ]),
                          _: 1
                        })
                      ], 2),
                      vue.createCommentVNode(" ARROW "),
                      !vue.unref(isSingle) ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                        vue.createElementVNode("span", {
                          class: vue.normalizeClass(vue.unref(arrowPrevKls)),
                          onClick: prev
                        }, [
                          vue.createVNode(vue.unref(ElIcon), null, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(arrow_left_default))
                            ]),
                            _: 1
                          })
                        ], 2),
                        vue.createElementVNode("span", {
                          class: vue.normalizeClass(vue.unref(arrowNextKls)),
                          onClick: next
                        }, [
                          vue.createVNode(vue.unref(ElIcon), null, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(arrow_right_default))
                            ]),
                            _: 1
                          })
                        ], 2)
                      ], 64)) : vue.createCommentVNode("v-if", true),
                      vue.createCommentVNode(" ACTIONS "),
                      vue.createElementVNode("div", {
                        class: vue.normalizeClass([vue.unref(ns).e("btn"), vue.unref(ns).e("actions")])
                      }, [
                        vue.createElementVNode("div", {
                          class: vue.normalizeClass(vue.unref(ns).e("actions__inner"))
                        }, [
                          vue.createVNode(vue.unref(ElIcon), {
                            onClick: ($event) => handleActions("zoomOut")
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(zoom_out_default))
                            ]),
                            _: 1
                          }, 8, ["onClick"]),
                          vue.createVNode(vue.unref(ElIcon), {
                            onClick: ($event) => handleActions("zoomIn")
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(zoom_in_default))
                            ]),
                            _: 1
                          }, 8, ["onClick"]),
                          vue.createElementVNode("i", {
                            class: vue.normalizeClass(vue.unref(ns).e("actions__divider"))
                          }, null, 2),
                          vue.createVNode(vue.unref(ElIcon), { onClick: toggleMode }, {
                            default: vue.withCtx(() => [
                              (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(mode).icon)))
                            ]),
                            _: 1
                          }),
                          vue.createElementVNode("i", {
                            class: vue.normalizeClass(vue.unref(ns).e("actions__divider"))
                          }, null, 2),
                          vue.createVNode(vue.unref(ElIcon), {
                            onClick: ($event) => handleActions("anticlockwise")
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(refresh_left_default))
                            ]),
                            _: 1
                          }, 8, ["onClick"]),
                          vue.createVNode(vue.unref(ElIcon), {
                            onClick: ($event) => handleActions("clockwise")
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(refresh_right_default))
                            ]),
                            _: 1
                          }, 8, ["onClick"])
                        ], 2)
                      ], 2),
                      vue.createCommentVNode(" CANVAS "),
                      vue.createElementVNode("div", {
                        class: vue.normalizeClass(vue.unref(ns).e("canvas"))
                      }, [
                        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.urlList, (url, i) => {
                          return vue.withDirectives((vue.openBlock(), vue.createElementBlock("img", {
                            ref_for: true,
                            ref: (el) => imgRefs.value[i] = el,
                            key: url,
                            src: url,
                            style: vue.normalizeStyle(vue.unref(imgStyle)),
                            class: vue.normalizeClass(vue.unref(ns).e("img")),
                            crossorigin: _ctx.crossorigin,
                            onLoad: handleImgLoad,
                            onError: handleImgError,
                            onMousedown: handleMouseDown
                          }, null, 46, ["src", "crossorigin"])), [
                            [vue.vShow, i === activeIndex.value]
                          ]);
                        }), 128))
                      ], 2),
                      vue.renderSlot(_ctx.$slots, "default")
                    ], 6)
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["disabled"]);
          };
        }
      });
      var ImageViewer = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__file", "image-viewer.vue"]]);
      const ElImageViewer = withInstall(ImageViewer);
      const imageProps = buildProps({
        hideOnClickModal: Boolean,
        src: {
          type: String,
          default: ""
        },
        fit: {
          type: String,
          values: ["", "contain", "cover", "fill", "none", "scale-down"],
          default: ""
        },
        loading: {
          type: String,
          values: ["eager", "lazy"]
        },
        lazy: Boolean,
        scrollContainer: {
          type: definePropType([String, Object])
        },
        previewSrcList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        previewTeleported: Boolean,
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        },
        minScale: {
          type: Number,
          default: 0.2
        },
        maxScale: {
          type: Number,
          default: 7
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const imageEmits = {
        load: (evt) => evt instanceof Event,
        error: (evt) => evt instanceof Event,
        switch: (val) => isNumber(val),
        close: () => true,
        show: () => true
      };
      const __default__$a = vue.defineComponent({
        name: "ElImage",
        inheritAttrs: false
      });
      const _sfc_main$t = /* @__PURE__ */ vue.defineComponent({
        ...__default__$a,
        props: imageProps,
        emits: imageEmits,
        setup(__props, { emit }) {
          const props = __props;
          let prevOverflow = "";
          const { t } = useLocale();
          const ns = useNamespace("image");
          const rawAttrs = vue.useAttrs();
          const containerAttrs = vue.computed(() => {
            return fromPairs(Object.entries(rawAttrs).filter(([key]) => /^(data-|on[A-Z])/i.test(key) || ["id", "style"].includes(key)));
          });
          const imgAttrs = useAttrs({
            excludeListeners: true,
            excludeKeys: vue.computed(() => {
              return Object.keys(containerAttrs.value);
            })
          });
          const imageSrc = vue.ref();
          const hasLoadError = vue.ref(false);
          const isLoading = vue.ref(true);
          const showViewer = vue.ref(false);
          const container = vue.ref();
          const _scrollContainer = vue.ref();
          const supportLoading = isClient && "loading" in HTMLImageElement.prototype;
          let stopScrollListener;
          let stopWheelListener;
          const imageKls = vue.computed(() => [
            ns.e("inner"),
            preview.value && ns.e("preview"),
            isLoading.value && ns.is("loading")
          ]);
          const imageStyle = vue.computed(() => {
            const { fit } = props;
            if (isClient && fit) {
              return { objectFit: fit };
            }
            return {};
          });
          const preview = vue.computed(() => {
            const { previewSrcList } = props;
            return Array.isArray(previewSrcList) && previewSrcList.length > 0;
          });
          const imageIndex = vue.computed(() => {
            const { previewSrcList, initialIndex } = props;
            let previewIndex = initialIndex;
            if (initialIndex > previewSrcList.length - 1) {
              previewIndex = 0;
            }
            return previewIndex;
          });
          const isManual = vue.computed(() => {
            if (props.loading === "eager")
              return false;
            return !supportLoading && props.loading === "lazy" || props.lazy;
          });
          const loadImage = () => {
            if (!isClient)
              return;
            isLoading.value = true;
            hasLoadError.value = false;
            imageSrc.value = props.src;
          };
          function handleLoad(event) {
            isLoading.value = false;
            hasLoadError.value = false;
            emit("load", event);
          }
          function handleError(event) {
            isLoading.value = false;
            hasLoadError.value = true;
            emit("error", event);
          }
          function handleLazyLoad() {
            if (isInContainer(container.value, _scrollContainer.value)) {
              loadImage();
              removeLazyLoadListener();
            }
          }
          const lazyLoadHandler = useThrottleFn(handleLazyLoad, 200, true);
          async function addLazyLoadListener() {
            var _a2;
            if (!isClient)
              return;
            await vue.nextTick();
            const { scrollContainer } = props;
            if (isElement(scrollContainer)) {
              _scrollContainer.value = scrollContainer;
            } else if (isString(scrollContainer) && scrollContainer !== "") {
              _scrollContainer.value = (_a2 = document.querySelector(scrollContainer)) != null ? _a2 : void 0;
            } else if (container.value) {
              _scrollContainer.value = getScrollContainer(container.value);
            }
            if (_scrollContainer.value) {
              stopScrollListener = useEventListener(_scrollContainer, "scroll", lazyLoadHandler);
              setTimeout(() => handleLazyLoad(), 100);
            }
          }
          function removeLazyLoadListener() {
            if (!isClient || !_scrollContainer.value || !lazyLoadHandler)
              return;
            stopScrollListener == null ? void 0 : stopScrollListener();
            _scrollContainer.value = void 0;
          }
          function wheelHandler(e) {
            if (!e.ctrlKey)
              return;
            if (e.deltaY < 0) {
              e.preventDefault();
              return false;
            } else if (e.deltaY > 0) {
              e.preventDefault();
              return false;
            }
          }
          function clickHandler() {
            if (!preview.value)
              return;
            stopWheelListener = useEventListener("wheel", wheelHandler, {
              passive: false
            });
            prevOverflow = document.body.style.overflow;
            document.body.style.overflow = "hidden";
            showViewer.value = true;
            emit("show");
          }
          function closeViewer() {
            stopWheelListener == null ? void 0 : stopWheelListener();
            document.body.style.overflow = prevOverflow;
            showViewer.value = false;
            emit("close");
          }
          function switchViewer(val) {
            emit("switch", val);
          }
          vue.watch(() => props.src, () => {
            if (isManual.value) {
              isLoading.value = true;
              hasLoadError.value = false;
              removeLazyLoadListener();
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          vue.onMounted(() => {
            if (isManual.value) {
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", vue.mergeProps({
              ref_key: "container",
              ref: container
            }, vue.unref(containerAttrs), {
              class: [vue.unref(ns).b(), _ctx.$attrs.class]
            }), [
              hasLoadError.value ? vue.renderSlot(_ctx.$slots, "error", { key: 0 }, () => [
                vue.createElementVNode("div", {
                  class: vue.normalizeClass(vue.unref(ns).e("error"))
                }, vue.toDisplayString(vue.unref(t)("el.image.error")), 3)
              ]) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                imageSrc.value !== void 0 ? (vue.openBlock(), vue.createElementBlock("img", vue.mergeProps({ key: 0 }, vue.unref(imgAttrs), {
                  src: imageSrc.value,
                  loading: _ctx.loading,
                  style: vue.unref(imageStyle),
                  class: vue.unref(imageKls),
                  crossorigin: _ctx.crossorigin,
                  onClick: clickHandler,
                  onLoad: handleLoad,
                  onError: handleError
                }), null, 16, ["src", "loading", "crossorigin"])) : vue.createCommentVNode("v-if", true),
                isLoading.value ? (vue.openBlock(), vue.createElementBlock("div", {
                  key: 1,
                  class: vue.normalizeClass(vue.unref(ns).e("wrapper"))
                }, [
                  vue.renderSlot(_ctx.$slots, "placeholder", {}, () => [
                    vue.createElementVNode("div", {
                      class: vue.normalizeClass(vue.unref(ns).e("placeholder"))
                    }, null, 2)
                  ])
                ], 2)) : vue.createCommentVNode("v-if", true)
              ], 64)),
              vue.unref(preview) ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 2 }, [
                showViewer.value ? (vue.openBlock(), vue.createBlock(vue.unref(ElImageViewer), {
                  key: 0,
                  "z-index": _ctx.zIndex,
                  "initial-index": vue.unref(imageIndex),
                  infinite: _ctx.infinite,
                  "zoom-rate": _ctx.zoomRate,
                  "min-scale": _ctx.minScale,
                  "max-scale": _ctx.maxScale,
                  "url-list": _ctx.previewSrcList,
                  crossorigin: _ctx.crossorigin,
                  "hide-on-click-modal": _ctx.hideOnClickModal,
                  teleported: _ctx.previewTeleported,
                  "close-on-press-escape": _ctx.closeOnPressEscape,
                  onClose: closeViewer,
                  onSwitch: switchViewer
                }, {
                  default: vue.withCtx(() => [
                    _ctx.$slots.viewer ? (vue.openBlock(), vue.createElementBlock("div", { key: 0 }, [
                      vue.renderSlot(_ctx.$slots, "viewer")
                    ])) : vue.createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "url-list", "crossorigin", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : vue.createCommentVNode("v-if", true)
              ], 64)) : vue.createCommentVNode("v-if", true)
            ], 16);
          };
        }
      });
      var Image$1 = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "image.vue"]]);
      const ElImage = withInstall(Image$1);
      const inputNumberProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        step: {
          type: Number,
          default: 1
        },
        stepStrictly: Boolean,
        max: {
          type: Number,
          default: Number.POSITIVE_INFINITY
        },
        min: {
          type: Number,
          default: Number.NEGATIVE_INFINITY
        },
        modelValue: Number,
        readonly: Boolean,
        disabled: Boolean,
        size: useSizeProp,
        controls: {
          type: Boolean,
          default: true
        },
        controlsPosition: {
          type: String,
          default: "",
          values: ["", "right"]
        },
        valueOnClear: {
          type: [String, Number, null],
          validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
          default: null
        },
        name: String,
        placeholder: String,
        precision: {
          type: Number,
          validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      });
      const inputNumberEmits = {
        [CHANGE_EVENT]: (cur, prev) => prev !== cur,
        blur: (e) => e instanceof FocusEvent,
        focus: (e) => e instanceof FocusEvent,
        [INPUT_EVENT]: (val) => isNumber(val) || isNil(val),
        [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil(val)
      };
      const __default__$9 = vue.defineComponent({
        name: "ElInputNumber"
      });
      const _sfc_main$s = /* @__PURE__ */ vue.defineComponent({
        ...__default__$9,
        props: inputNumberProps,
        emits: inputNumberEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const { t } = useLocale();
          const ns = useNamespace("input-number");
          const input = vue.ref();
          const data = vue.reactive({
            currentValue: props.modelValue,
            userInput: null
          });
          const { formItem } = useFormItem();
          const minDisabled = vue.computed(() => isNumber(props.modelValue) && props.modelValue <= props.min);
          const maxDisabled = vue.computed(() => isNumber(props.modelValue) && props.modelValue >= props.max);
          const numPrecision = vue.computed(() => {
            const stepPrecision = getPrecision(props.step);
            if (!isUndefined(props.precision)) {
              if (stepPrecision > props.precision) {
                debugWarn("InputNumber", "precision should not be less than the decimal places of step");
              }
              return props.precision;
            } else {
              return Math.max(getPrecision(props.modelValue), stepPrecision);
            }
          });
          const controlsAtRight = vue.computed(() => {
            return props.controls && props.controlsPosition === "right";
          });
          const inputNumberSize = useFormSize();
          const inputNumberDisabled = useFormDisabled();
          const displayValue = vue.computed(() => {
            if (data.userInput !== null) {
              return data.userInput;
            }
            let currentValue = data.currentValue;
            if (isNil(currentValue))
              return "";
            if (isNumber(currentValue)) {
              if (Number.isNaN(currentValue))
                return "";
              if (!isUndefined(props.precision)) {
                currentValue = currentValue.toFixed(props.precision);
              }
            }
            return currentValue;
          });
          const toPrecision = (num, pre) => {
            if (isUndefined(pre))
              pre = numPrecision.value;
            if (pre === 0)
              return Math.round(num);
            let snum = String(num);
            const pointPos = snum.indexOf(".");
            if (pointPos === -1)
              return num;
            const nums = snum.replace(".", "").split("");
            const datum = nums[pointPos + pre];
            if (!datum)
              return num;
            const length = snum.length;
            if (snum.charAt(length - 1) === "5") {
              snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
            }
            return Number.parseFloat(Number(snum).toFixed(pre));
          };
          const getPrecision = (value) => {
            if (isNil(value))
              return 0;
            const valueString = value.toString();
            const dotPosition = valueString.indexOf(".");
            let precision = 0;
            if (dotPosition !== -1) {
              precision = valueString.length - dotPosition - 1;
            }
            return precision;
          };
          const ensurePrecision = (val, coefficient = 1) => {
            if (!isNumber(val))
              return data.currentValue;
            return toPrecision(val + props.step * coefficient);
          };
          const increase = () => {
            if (props.readonly || inputNumberDisabled.value || maxDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value);
            setCurrentValue(newVal);
            emit(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const decrease = () => {
            if (props.readonly || inputNumberDisabled.value || minDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value, -1);
            setCurrentValue(newVal);
            emit(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const verifyValue = (value, update) => {
            const { max: max2, min: min2, step, precision, stepStrictly, valueOnClear } = props;
            if (max2 < min2) {
              throwError("InputNumber", "min should not be greater than max.");
            }
            let newVal = Number(value);
            if (isNil(value) || Number.isNaN(newVal)) {
              return null;
            }
            if (value === "") {
              if (valueOnClear === null) {
                return null;
              }
              newVal = isString(valueOnClear) ? { min: min2, max: max2 }[valueOnClear] : valueOnClear;
            }
            if (stepStrictly) {
              newVal = toPrecision(Math.round(newVal / step) * step, precision);
              if (newVal !== value) {
                update && emit(UPDATE_MODEL_EVENT, newVal);
              }
            }
            if (!isUndefined(precision)) {
              newVal = toPrecision(newVal, precision);
            }
            if (newVal > max2 || newVal < min2) {
              newVal = newVal > max2 ? max2 : min2;
              update && emit(UPDATE_MODEL_EVENT, newVal);
            }
            return newVal;
          };
          const setCurrentValue = (value, emitChange = true) => {
            var _a2;
            const oldVal = data.currentValue;
            const newVal = verifyValue(value);
            if (!emitChange) {
              emit(UPDATE_MODEL_EVENT, newVal);
              return;
            }
            if (oldVal === newVal && value)
              return;
            data.userInput = null;
            emit(UPDATE_MODEL_EVENT, newVal);
            if (oldVal !== newVal) {
              emit(CHANGE_EVENT, newVal, oldVal);
            }
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn(err));
            }
            data.currentValue = newVal;
          };
          const handleInput = (value) => {
            data.userInput = value;
            const newVal = value === "" ? null : Number(value);
            emit(INPUT_EVENT, newVal);
            setCurrentValue(newVal, false);
          };
          const handleInputChange = (value) => {
            const newVal = value !== "" ? Number(value) : "";
            if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
              setCurrentValue(newVal);
            }
            setCurrentValueToModelValue();
            data.userInput = null;
          };
          const focus = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          };
          const blur = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
          };
          const handleFocus = (event) => {
            emit("focus", event);
          };
          const handleBlur = (event) => {
            var _a2;
            data.userInput = null;
            emit("blur", event);
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn(err));
            }
          };
          const setCurrentValueToModelValue = () => {
            if (data.currentValue !== props.modelValue) {
              data.currentValue = props.modelValue;
            }
          };
          const handleWheel = (e) => {
            if (document.activeElement === e.target)
              e.preventDefault();
          };
          vue.watch(() => props.modelValue, (value, oldValue) => {
            const newValue = verifyValue(value, true);
            if (data.userInput === null && newValue !== oldValue) {
              data.currentValue = newValue;
            }
          }, { immediate: true });
          vue.onMounted(() => {
            var _a2;
            const { min: min2, max: max2, modelValue } = props;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput.setAttribute("role", "spinbutton");
            if (Number.isFinite(max2)) {
              innerInput.setAttribute("aria-valuemax", String(max2));
            } else {
              innerInput.removeAttribute("aria-valuemax");
            }
            if (Number.isFinite(min2)) {
              innerInput.setAttribute("aria-valuemin", String(min2));
            } else {
              innerInput.removeAttribute("aria-valuemin");
            }
            innerInput.setAttribute("aria-valuenow", data.currentValue || data.currentValue === 0 ? String(data.currentValue) : "");
            innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
            if (!isNumber(modelValue) && modelValue != null) {
              let val = Number(modelValue);
              if (Number.isNaN(val)) {
                val = null;
              }
              emit(UPDATE_MODEL_EVENT, val);
            }
            innerInput.addEventListener("wheel", handleWheel, { passive: false });
          });
          vue.onUpdated(() => {
            var _a2, _b;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${(_b = data.currentValue) != null ? _b : ""}`);
          });
          expose({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: vue.normalizeClass([
                vue.unref(ns).b(),
                vue.unref(ns).m(vue.unref(inputNumberSize)),
                vue.unref(ns).is("disabled", vue.unref(inputNumberDisabled)),
                vue.unref(ns).is("without-controls", !_ctx.controls),
                vue.unref(ns).is("controls-right", vue.unref(controlsAtRight))
              ]),
              onDragstart: vue.withModifiers(() => {
              }, ["prevent"])
            }, [
              _ctx.controls ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("span", {
                key: 0,
                role: "button",
                "aria-label": vue.unref(t)("el.inputNumber.decrease"),
                class: vue.normalizeClass([vue.unref(ns).e("decrease"), vue.unref(ns).is("disabled", vue.unref(minDisabled))]),
                onKeydown: vue.withKeys(decrease, ["enter"])
              }, [
                vue.renderSlot(_ctx.$slots, "decrease-icon", {}, () => [
                  vue.createVNode(vue.unref(ElIcon), null, {
                    default: vue.withCtx(() => [
                      vue.unref(controlsAtRight) ? (vue.openBlock(), vue.createBlock(vue.unref(arrow_down_default), { key: 0 })) : (vue.openBlock(), vue.createBlock(vue.unref(minus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, ["aria-label", "onKeydown"])), [
                [vue.unref(vRepeatClick), decrease]
              ]) : vue.createCommentVNode("v-if", true),
              _ctx.controls ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("span", {
                key: 1,
                role: "button",
                "aria-label": vue.unref(t)("el.inputNumber.increase"),
                class: vue.normalizeClass([vue.unref(ns).e("increase"), vue.unref(ns).is("disabled", vue.unref(maxDisabled))]),
                onKeydown: vue.withKeys(increase, ["enter"])
              }, [
                vue.renderSlot(_ctx.$slots, "increase-icon", {}, () => [
                  vue.createVNode(vue.unref(ElIcon), null, {
                    default: vue.withCtx(() => [
                      vue.unref(controlsAtRight) ? (vue.openBlock(), vue.createBlock(vue.unref(arrow_up_default), { key: 0 })) : (vue.openBlock(), vue.createBlock(vue.unref(plus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, ["aria-label", "onKeydown"])), [
                [vue.unref(vRepeatClick), increase]
              ]) : vue.createCommentVNode("v-if", true),
              vue.createVNode(vue.unref(ElInput), {
                id: _ctx.id,
                ref_key: "input",
                ref: input,
                type: "number",
                step: _ctx.step,
                "model-value": vue.unref(displayValue),
                placeholder: _ctx.placeholder,
                readonly: _ctx.readonly,
                disabled: vue.unref(inputNumberDisabled),
                size: vue.unref(inputNumberSize),
                max: _ctx.max,
                min: _ctx.min,
                name: _ctx.name,
                "aria-label": _ctx.ariaLabel,
                "validate-event": false,
                onKeydown: [
                  vue.withKeys(vue.withModifiers(increase, ["prevent"]), ["up"]),
                  vue.withKeys(vue.withModifiers(decrease, ["prevent"]), ["down"])
                ],
                onBlur: handleBlur,
                onFocus: handleFocus,
                onInput: handleInput,
                onChange: handleInputChange
              }, vue.createSlots({
                _: 2
              }, [
                _ctx.$slots.prefix ? {
                  name: "prefix",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "prefix")
                  ])
                } : void 0,
                _ctx.$slots.suffix ? {
                  name: "suffix",
                  fn: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "suffix")
                  ])
                } : void 0
              ]), 1032, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "aria-label", "onKeydown"])
            ], 42, ["onDragstart"]);
          };
        }
      });
      var InputNumber = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "input-number.vue"]]);
      const ElInputNumber = withInstall(InputNumber);
      const selectGroupKey = Symbol("ElSelectGroup");
      const selectKey = Symbol("ElSelect");
      function useOption(props, states) {
        const select = vue.inject(selectKey);
        const selectGroup = vue.inject(selectGroupKey, { disabled: false });
        const itemSelected = vue.computed(() => {
          return contains2(castArray(select.props.modelValue), props.value);
        });
        const limitReached = vue.computed(() => {
          var _a2;
          if (select.props.multiple) {
            const modelValue = castArray((_a2 = select.props.modelValue) != null ? _a2 : []);
            return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
          } else {
            return false;
          }
        });
        const currentLabel = vue.computed(() => {
          return props.label || (isObject$1(props.value) ? "" : props.value);
        });
        const currentValue = vue.computed(() => {
          return props.value || props.label || "";
        });
        const isDisabled = vue.computed(() => {
          return props.disabled || states.groupDisabled || limitReached.value;
        });
        const instance = vue.getCurrentInstance();
        const contains2 = (arr = [], target) => {
          if (!isObject$1(props.value)) {
            return arr && arr.includes(target);
          } else {
            const valueKey = select.props.valueKey;
            return arr && arr.some((item) => {
              return vue.toRaw(get(item, valueKey)) === get(target, valueKey);
            });
          }
        };
        const hoverItem = () => {
          if (!props.disabled && !selectGroup.disabled) {
            select.states.hoveringIndex = select.optionsArray.indexOf(instance.proxy);
          }
        };
        const updateOption = (query2) => {
          const regexp = new RegExp(escapeStringRegexp(query2), "i");
          states.visible = regexp.test(currentLabel.value) || props.created;
        };
        vue.watch(() => currentLabel.value, () => {
          if (!props.created && !select.props.remote)
            select.setSelected();
        });
        vue.watch(() => props.value, (val, oldVal) => {
          const { remote, valueKey } = select.props;
          if (val !== oldVal) {
            select.onOptionDestroy(oldVal, instance.proxy);
            select.onOptionCreate(instance.proxy);
          }
          if (!props.created && !remote) {
            if (valueKey && isObject$1(val) && isObject$1(oldVal) && val[valueKey] === oldVal[valueKey]) {
              return;
            }
            select.setSelected();
          }
        });
        vue.watch(() => selectGroup.disabled, () => {
          states.groupDisabled = selectGroup.disabled;
        }, { immediate: true });
        return {
          select,
          currentLabel,
          currentValue,
          itemSelected,
          isDisabled,
          hoverItem,
          updateOption
        };
      }
      const _sfc_main$r = vue.defineComponent({
        name: "ElOption",
        componentName: "ElOption",
        props: {
          value: {
            required: true,
            type: [String, Number, Boolean, Object]
          },
          label: [String, Number],
          created: Boolean,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const id = useId();
          const containerKls = vue.computed(() => [
            ns.be("dropdown", "item"),
            ns.is("disabled", vue.unref(isDisabled)),
            ns.is("selected", vue.unref(itemSelected)),
            ns.is("hovering", vue.unref(hover))
          ]);
          const states = vue.reactive({
            index: -1,
            groupDisabled: false,
            visible: true,
            hover: false
          });
          const {
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption
          } = useOption(props, states);
          const { visible, hover } = vue.toRefs(states);
          const vm = vue.getCurrentInstance().proxy;
          select.onOptionCreate(vm);
          vue.onBeforeUnmount(() => {
            const key = vm.value;
            const { selected } = select.states;
            const selectedOptions = select.props.multiple ? selected : [selected];
            const doesSelected = selectedOptions.some((item) => {
              return item.value === vm.value;
            });
            vue.nextTick(() => {
              if (select.states.cachedOptions.get(key) === vm && !doesSelected) {
                select.states.cachedOptions.delete(key);
              }
            });
            select.onOptionDestroy(key, vm);
          });
          function selectOptionClick() {
            if (!isDisabled.value) {
              select.handleOptionSelect(vm);
            }
          }
          return {
            ns,
            id,
            containerKls,
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption,
            visible,
            hover,
            selectOptionClick,
            states
          };
        }
      });
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.withDirectives((vue.openBlock(), vue.createElementBlock("li", {
          id: _ctx.id,
          class: vue.normalizeClass(_ctx.containerKls),
          role: "option",
          "aria-disabled": _ctx.isDisabled || void 0,
          "aria-selected": _ctx.itemSelected,
          onMouseenter: _ctx.hoverItem,
          onClick: vue.withModifiers(_ctx.selectOptionClick, ["stop"])
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, () => [
            vue.createElementVNode("span", null, vue.toDisplayString(_ctx.currentLabel), 1)
          ])
        ], 42, ["id", "aria-disabled", "aria-selected", "onMouseenter", "onClick"])), [
          [vue.vShow, _ctx.visible]
        ]);
      }
      var Option = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$4], ["__file", "option.vue"]]);
      const _sfc_main$q = vue.defineComponent({
        name: "ElSelectDropdown",
        componentName: "ElSelectDropdown",
        setup() {
          const select = vue.inject(selectKey);
          const ns = useNamespace("select");
          const popperClass = vue.computed(() => select.props.popperClass);
          const isMultiple = vue.computed(() => select.props.multiple);
          const isFitInputWidth = vue.computed(() => select.props.fitInputWidth);
          const minWidth = vue.ref("");
          function updateMinWidth() {
            var _a2;
            minWidth.value = `${(_a2 = select.selectRef) == null ? void 0 : _a2.offsetWidth}px`;
          }
          vue.onMounted(() => {
            updateMinWidth();
            useResizeObserver(select.selectRef, updateMinWidth);
          });
          return {
            ns,
            minWidth,
            popperClass,
            isMultiple,
            isFitInputWidth
          };
        }
      });
      function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.openBlock(), vue.createElementBlock("div", {
          class: vue.normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
          style: vue.normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
        }, [
          _ctx.$slots.header ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: vue.normalizeClass(_ctx.ns.be("dropdown", "header"))
          }, [
            vue.renderSlot(_ctx.$slots, "header")
          ], 2)) : vue.createCommentVNode("v-if", true),
          vue.renderSlot(_ctx.$slots, "default"),
          _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 1,
            class: vue.normalizeClass(_ctx.ns.be("dropdown", "footer"))
          }, [
            vue.renderSlot(_ctx.$slots, "footer")
          ], 2)) : vue.createCommentVNode("v-if", true)
        ], 6);
      }
      var ElSelectMenu = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$3], ["__file", "select-dropdown.vue"]]);
      const MINIMUM_INPUT_WIDTH = 11;
      const useSelect = (props, emit) => {
        const { t } = useLocale();
        const contentId = useId();
        const nsSelect = useNamespace("select");
        const nsInput = useNamespace("input");
        const states = vue.reactive({
          inputValue: "",
          options: /* @__PURE__ */ new Map(),
          cachedOptions: /* @__PURE__ */ new Map(),
          disabledOptions: /* @__PURE__ */ new Map(),
          optionValues: [],
          selected: [],
          selectionWidth: 0,
          calculatorWidth: 0,
          collapseItemWidth: 0,
          selectedLabel: "",
          hoveringIndex: -1,
          previousQuery: null,
          inputHovering: false,
          menuVisibleOnFocus: false,
          isBeforeHide: false
        });
        const selectRef = vue.ref(null);
        const selectionRef = vue.ref(null);
        const tooltipRef = vue.ref(null);
        const tagTooltipRef = vue.ref(null);
        const inputRef = vue.ref(null);
        const calculatorRef = vue.ref(null);
        const prefixRef = vue.ref(null);
        const suffixRef = vue.ref(null);
        const menuRef = vue.ref(null);
        const tagMenuRef = vue.ref(null);
        const collapseItemRef = vue.ref(null);
        const scrollbarRef = vue.ref(null);
        const {
          isComposing,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        } = useComposition({
          afterComposition: (e) => onInput(e)
        });
        const { wrapperRef, isFocused, handleBlur } = useFocusController(inputRef, {
          beforeFocus() {
            return selectDisabled.value;
          },
          afterFocus() {
            if (props.automaticDropdown && !expanded.value) {
              expanded.value = true;
              states.menuVisibleOnFocus = true;
            }
          },
          beforeBlur(event) {
            var _a2, _b;
            return ((_a2 = tooltipRef.value) == null ? void 0 : _a2.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event));
          },
          afterBlur() {
            expanded.value = false;
            states.menuVisibleOnFocus = false;
          }
        });
        const expanded = vue.ref(false);
        const hoverOption = vue.ref();
        const { form, formItem } = useFormItem();
        const { inputId } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const { valueOnClear, isEmptyValue } = useEmptyValues(props);
        const selectDisabled = vue.computed(() => props.disabled || (form == null ? void 0 : form.disabled));
        const hasModelValue = vue.computed(() => {
          return isArray$1(props.modelValue) ? props.modelValue.length > 0 : !isEmptyValue(props.modelValue);
        });
        const showClose = vue.computed(() => {
          return props.clearable && !selectDisabled.value && states.inputHovering && hasModelValue.value;
        });
        const iconComponent = vue.computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
        const iconReverse = vue.computed(() => nsSelect.is("reverse", iconComponent.value && expanded.value));
        const validateState = vue.computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
        const validateIcon = vue.computed(() => ValidateComponentsMap[validateState.value]);
        const debounce$12 = vue.computed(() => props.remote ? 300 : 0);
        const emptyText = vue.computed(() => {
          if (props.loading) {
            return props.loadingText || t("el.select.loading");
          } else {
            if (props.remote && !states.inputValue && states.options.size === 0)
              return false;
            if (props.filterable && states.inputValue && states.options.size > 0 && filteredOptionsCount.value === 0) {
              return props.noMatchText || t("el.select.noMatch");
            }
            if (states.options.size === 0) {
              return props.noDataText || t("el.select.noData");
            }
          }
          return null;
        });
        const filteredOptionsCount = vue.computed(() => optionsArray.value.filter((option) => option.visible).length);
        const optionsArray = vue.computed(() => {
          const list = Array.from(states.options.values());
          const newList = [];
          states.optionValues.forEach((item) => {
            const index = list.findIndex((i) => i.value === item);
            if (index > -1) {
              newList.push(list[index]);
            }
          });
          return newList.length >= list.length ? newList : list;
        });
        const cachedOptionsArray = vue.computed(() => Array.from(states.cachedOptions.values()));
        const showNewOption = vue.computed(() => {
          const hasExistingOption = optionsArray.value.filter((option) => {
            return !option.created;
          }).some((option) => {
            return option.currentLabel === states.inputValue;
          });
          return props.filterable && props.allowCreate && states.inputValue !== "" && !hasExistingOption;
        });
        const updateOptions2 = () => {
          if (props.filterable && isFunction$1(props.filterMethod))
            return;
          if (props.filterable && props.remote && isFunction$1(props.remoteMethod))
            return;
          optionsArray.value.forEach((option) => {
            var _a2;
            (_a2 = option.updateOption) == null ? void 0 : _a2.call(option, states.inputValue);
          });
        };
        const selectSize = useFormSize();
        const collapseTagSize = vue.computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
        const dropdownMenuVisible = vue.computed({
          get() {
            return expanded.value && emptyText.value !== false;
          },
          set(val) {
            expanded.value = val;
          }
        });
        const shouldShowPlaceholder = vue.computed(() => {
          if (props.multiple && !isUndefined(props.modelValue)) {
            return castArray(props.modelValue).length === 0 && !states.inputValue;
          }
          const value = isArray$1(props.modelValue) ? props.modelValue[0] : props.modelValue;
          return props.filterable || isUndefined(value) ? !states.inputValue : true;
        });
        const currentPlaceholder = vue.computed(() => {
          var _a2;
          const _placeholder = (_a2 = props.placeholder) != null ? _a2 : t("el.select.placeholder");
          return props.multiple || !hasModelValue.value ? _placeholder : states.selectedLabel;
        });
        const mouseEnterEventName = vue.computed(() => isIOS ? null : "mouseenter");
        vue.watch(() => props.modelValue, (val, oldVal) => {
          if (props.multiple) {
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
              handleQueryChange("");
            }
          }
          setSelected();
          if (!isEqual(val, oldVal) && props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
          }
        }, {
          flush: "post",
          deep: true
        });
        vue.watch(() => expanded.value, (val) => {
          if (val) {
            handleQueryChange(states.inputValue);
          } else {
            states.inputValue = "";
            states.previousQuery = null;
            states.isBeforeHide = true;
          }
          emit("visible-change", val);
        });
        vue.watch(() => states.options.entries(), () => {
          var _a2;
          if (!isClient)
            return;
          const inputs = ((_a2 = selectRef.value) == null ? void 0 : _a2.querySelectorAll("input")) || [];
          if (!props.filterable && !props.defaultFirstOption && !isUndefined(props.modelValue) || !Array.from(inputs).includes(document.activeElement)) {
            setSelected();
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            checkDefaultFirstOption();
          }
        }, {
          flush: "post"
        });
        vue.watch(() => states.hoveringIndex, (val) => {
          if (isNumber(val) && val > -1) {
            hoverOption.value = optionsArray.value[val] || {};
          } else {
            hoverOption.value = {};
          }
          optionsArray.value.forEach((option) => {
            option.hover = hoverOption.value === option;
          });
        });
        vue.watchEffect(() => {
          if (states.isBeforeHide)
            return;
          updateOptions2();
        });
        const handleQueryChange = (val) => {
          if (states.previousQuery === val || isComposing.value) {
            return;
          }
          states.previousQuery = val;
          if (props.filterable && isFunction$1(props.filterMethod)) {
            props.filterMethod(val);
          } else if (props.filterable && props.remote && isFunction$1(props.remoteMethod)) {
            props.remoteMethod(val);
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            vue.nextTick(checkDefaultFirstOption);
          } else {
            vue.nextTick(updateHoveringIndex);
          }
        };
        const checkDefaultFirstOption = () => {
          const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
          const userCreatedOption = optionsInDropdown.find((n) => n.created);
          const firstOriginOption = optionsInDropdown[0];
          states.hoveringIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
        };
        const setSelected = () => {
          if (!props.multiple) {
            const value = isArray$1(props.modelValue) ? props.modelValue[0] : props.modelValue;
            const option = getOption(value);
            states.selectedLabel = option.currentLabel;
            states.selected = [option];
            return;
          } else {
            states.selectedLabel = "";
          }
          const result2 = [];
          if (!isUndefined(props.modelValue)) {
            castArray(props.modelValue).forEach((value) => {
              result2.push(getOption(value));
            });
          }
          states.selected = result2;
        };
        const getOption = (value) => {
          let option;
          const isObjectValue = toRawType(value).toLowerCase() === "object";
          const isNull2 = toRawType(value).toLowerCase() === "null";
          const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
          for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
            const cachedOption = cachedOptionsArray.value[i];
            const isEqualValue = isObjectValue ? get(cachedOption.value, props.valueKey) === get(value, props.valueKey) : cachedOption.value === value;
            if (isEqualValue) {
              option = {
                value,
                currentLabel: cachedOption.currentLabel,
                get isDisabled() {
                  return cachedOption.isDisabled;
                }
              };
              break;
            }
          }
          if (option)
            return option;
          const label = isObjectValue ? value.label : !isNull2 && !isUndefined2 ? value : "";
          const newOption = {
            value,
            currentLabel: label
          };
          return newOption;
        };
        const updateHoveringIndex = () => {
          states.hoveringIndex = optionsArray.value.findIndex((item) => states.selected.some((selected) => getValueKey(selected) === getValueKey(item)));
        };
        const resetSelectionWidth = () => {
          states.selectionWidth = selectionRef.value.getBoundingClientRect().width;
        };
        const resetCalculatorWidth = () => {
          states.calculatorWidth = calculatorRef.value.getBoundingClientRect().width;
        };
        const resetCollapseItemWidth = () => {
          states.collapseItemWidth = collapseItemRef.value.getBoundingClientRect().width;
        };
        const updateTooltip = () => {
          var _a2, _b;
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        };
        const updateTagTooltip = () => {
          var _a2, _b;
          (_b = (_a2 = tagTooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        };
        const onInputChange = () => {
          if (states.inputValue.length > 0 && !expanded.value) {
            expanded.value = true;
          }
          handleQueryChange(states.inputValue);
        };
        const onInput = (event) => {
          states.inputValue = event.target.value;
          if (props.remote) {
            debouncedOnInputChange();
          } else {
            return onInputChange();
          }
        };
        const debouncedOnInputChange = debounce(() => {
          onInputChange();
        }, debounce$12.value);
        const emitChange = (val) => {
          if (!isEqual(props.modelValue, val)) {
            emit(CHANGE_EVENT, val);
          }
        };
        const getLastNotDisabledIndex = (value) => findLastIndex(value, (it2) => !states.disabledOptions.has(it2));
        const deletePrevTag = (e) => {
          if (!props.multiple)
            return;
          if (e.code === EVENT_CODE.delete)
            return;
          if (e.target.value.length <= 0) {
            const value = castArray(props.modelValue).slice();
            const lastNotDisabledIndex = getLastNotDisabledIndex(value);
            if (lastNotDisabledIndex < 0)
              return;
            const removeTagValue = value[lastNotDisabledIndex];
            value.splice(lastNotDisabledIndex, 1);
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            emit("remove-tag", removeTagValue);
          }
        };
        const deleteTag = (event, tag) => {
          const index = states.selected.indexOf(tag);
          if (index > -1 && !selectDisabled.value) {
            const value = castArray(props.modelValue).slice();
            value.splice(index, 1);
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            emit("remove-tag", tag.value);
          }
          event.stopPropagation();
          focus();
        };
        const deleteSelected = (event) => {
          event.stopPropagation();
          const value = props.multiple ? [] : valueOnClear.value;
          if (props.multiple) {
            for (const item of states.selected) {
              if (item.isDisabled)
                value.push(item.value);
            }
          }
          emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          states.hoveringIndex = -1;
          expanded.value = false;
          emit("clear");
          focus();
        };
        const handleOptionSelect = (option) => {
          var _a2;
          if (props.multiple) {
            const value = castArray((_a2 = props.modelValue) != null ? _a2 : []).slice();
            const optionIndex = getValueIndex(value, option.value);
            if (optionIndex > -1) {
              value.splice(optionIndex, 1);
            } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
              value.push(option.value);
            }
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            if (option.created) {
              handleQueryChange("");
            }
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
            }
          } else {
            emit(UPDATE_MODEL_EVENT, option.value);
            emitChange(option.value);
            expanded.value = false;
          }
          focus();
          if (expanded.value)
            return;
          vue.nextTick(() => {
            scrollToOption(option);
          });
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$1(value))
            return arr.indexOf(value);
          const valueKey = props.valueKey;
          let index = -1;
          arr.some((item, i) => {
            if (vue.toRaw(get(item, valueKey)) === get(value, valueKey)) {
              index = i;
              return true;
            }
            return false;
          });
          return index;
        };
        const scrollToOption = (option) => {
          var _a2, _b, _c, _d, _e;
          const targetOption = isArray$1(option) ? option[0] : option;
          let target = null;
          if (targetOption == null ? void 0 : targetOption.value) {
            const options = optionsArray.value.filter((item) => item.value === targetOption.value);
            if (options.length > 0) {
              target = options[0].$el;
            }
          }
          if (tooltipRef.value && target) {
            const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${nsSelect.be("dropdown", "wrap")}`);
            if (menu) {
              scrollIntoView(menu, target);
            }
          }
          (_e = scrollbarRef.value) == null ? void 0 : _e.handleScroll();
        };
        const onOptionCreate = (vm) => {
          states.options.set(vm.value, vm);
          states.cachedOptions.set(vm.value, vm);
          vm.disabled && states.disabledOptions.set(vm.value, vm);
        };
        const onOptionDestroy = (key, vm) => {
          if (states.options.get(key) === vm) {
            states.options.delete(key);
          }
        };
        const popperRef = vue.computed(() => {
          var _a2, _b;
          return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        const handleMenuEnter = () => {
          states.isBeforeHide = false;
          vue.nextTick(() => scrollToOption(states.selected));
        };
        const focus = () => {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        };
        const blur = () => {
          var _a2;
          if (expanded.value) {
            expanded.value = false;
            vue.nextTick(() => {
              var _a22;
              return (_a22 = inputRef.value) == null ? void 0 : _a22.blur();
            });
            return;
          }
          (_a2 = inputRef.value) == null ? void 0 : _a2.blur();
        };
        const handleClearClick = (event) => {
          deleteSelected(event);
        };
        const handleClickOutside = (event) => {
          expanded.value = false;
          if (isFocused.value) {
            const _event2 = new FocusEvent("focus", event);
            vue.nextTick(() => handleBlur(_event2));
          }
        };
        const handleEsc = () => {
          if (states.inputValue.length > 0) {
            states.inputValue = "";
          } else {
            expanded.value = false;
          }
        };
        const toggleMenu = () => {
          if (selectDisabled.value)
            return;
          if (isIOS)
            states.inputHovering = true;
          if (states.menuVisibleOnFocus) {
            states.menuVisibleOnFocus = false;
          } else {
            expanded.value = !expanded.value;
          }
        };
        const selectOption = () => {
          if (!expanded.value) {
            toggleMenu();
          } else {
            if (optionsArray.value[states.hoveringIndex]) {
              handleOptionSelect(optionsArray.value[states.hoveringIndex]);
            }
          }
        };
        const getValueKey = (item) => {
          return isObject$1(item.value) ? get(item.value, props.valueKey) : item.value;
        };
        const optionsAllDisabled = vue.computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
        const showTagList = vue.computed(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(0, props.maxCollapseTags) : states.selected;
        });
        const collapseTagList = vue.computed(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(props.maxCollapseTags) : [];
        });
        const navigateOptions = (direction) => {
          if (!expanded.value) {
            expanded.value = true;
            return;
          }
          if (states.options.size === 0 || states.filteredOptionsCount === 0 || isComposing.value)
            return;
          if (!optionsAllDisabled.value) {
            if (direction === "next") {
              states.hoveringIndex++;
              if (states.hoveringIndex === states.options.size) {
                states.hoveringIndex = 0;
              }
            } else if (direction === "prev") {
              states.hoveringIndex--;
              if (states.hoveringIndex < 0) {
                states.hoveringIndex = states.options.size - 1;
              }
            }
            const option = optionsArray.value[states.hoveringIndex];
            if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
              navigateOptions(direction);
            }
            vue.nextTick(() => scrollToOption(hoverOption.value));
          }
        };
        const getGapWidth = () => {
          if (!selectionRef.value)
            return 0;
          const style = window.getComputedStyle(selectionRef.value);
          return Number.parseFloat(style.gap || "6px");
        };
        const tagStyle = vue.computed(() => {
          const gapWidth = getGapWidth();
          const maxWidth = collapseItemRef.value && props.maxCollapseTags === 1 ? states.selectionWidth - states.collapseItemWidth - gapWidth : states.selectionWidth;
          return { maxWidth: `${maxWidth}px` };
        });
        const collapseTagStyle = vue.computed(() => {
          return { maxWidth: `${states.selectionWidth}px` };
        });
        const inputStyle = vue.computed(() => ({
          width: `${Math.max(states.calculatorWidth, MINIMUM_INPUT_WIDTH)}px`
        }));
        useResizeObserver(selectionRef, resetSelectionWidth);
        useResizeObserver(calculatorRef, resetCalculatorWidth);
        useResizeObserver(menuRef, updateTooltip);
        useResizeObserver(wrapperRef, updateTooltip);
        useResizeObserver(tagMenuRef, updateTagTooltip);
        useResizeObserver(collapseItemRef, resetCollapseItemWidth);
        vue.onMounted(() => {
          setSelected();
        });
        return {
          inputId,
          contentId,
          nsSelect,
          nsInput,
          states,
          isFocused,
          expanded,
          optionsArray,
          hoverOption,
          selectSize,
          filteredOptionsCount,
          resetCalculatorWidth,
          updateTooltip,
          updateTagTooltip,
          debouncedOnInputChange,
          onInput,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          hasModelValue,
          shouldShowPlaceholder,
          currentPlaceholder,
          mouseEnterEventName,
          showClose,
          iconComponent,
          iconReverse,
          validateState,
          validateIcon,
          showNewOption,
          updateOptions: updateOptions2,
          collapseTagSize,
          setSelected,
          selectDisabled,
          emptyText,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          focus,
          blur,
          handleClearClick,
          handleClickOutside,
          handleEsc,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          dropdownMenuVisible,
          showTagList,
          collapseTagList,
          tagStyle,
          collapseTagStyle,
          inputStyle,
          popperRef,
          inputRef,
          tooltipRef,
          tagTooltipRef,
          calculatorRef,
          prefixRef,
          suffixRef,
          selectRef,
          wrapperRef,
          selectionRef,
          scrollbarRef,
          menuRef,
          tagMenuRef,
          collapseItemRef
        };
      };
      var ElOptions = vue.defineComponent({
        name: "ElOptions",
        setup(_2, { slots }) {
          const select = vue.inject(selectKey);
          let cachedValueList = [];
          return () => {
            var _a2, _b;
            const children = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
            const valueList = [];
            function filterOptions(children2) {
              if (!isArray$1(children2))
                return;
              children2.forEach((item) => {
                var _a22, _b2, _c, _d;
                const name = (_a22 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a22.name;
                if (name === "ElOptionGroup") {
                  filterOptions(!isString(item.children) && !isArray$1(item.children) && isFunction$1((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
                } else if (name === "ElOption") {
                  valueList.push((_d = item.props) == null ? void 0 : _d.value);
                } else if (isArray$1(item.children)) {
                  filterOptions(item.children);
                }
              });
            }
            if (children.length) {
              filterOptions((_b = children[0]) == null ? void 0 : _b.children);
            }
            if (!isEqual(valueList, cachedValueList)) {
              cachedValueList = valueList;
              if (select) {
                select.states.optionValues = valueList;
              }
            }
            return children;
          };
        }
      });
      const SelectProps = buildProps({
        name: String,
        id: String,
        modelValue: {
          type: [Array, String, Number, Boolean, Object],
          default: void 0
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        automaticDropdown: Boolean,
        size: useSizeProp,
        effect: {
          type: definePropType(String),
          default: "light"
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        allowCreate: Boolean,
        loading: Boolean,
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        remote: Boolean,
        loadingText: String,
        noMatchText: String,
        noDataText: String,
        remoteMethod: Function,
        filterMethod: Function,
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        placeholder: {
          type: String
        },
        defaultFirstOption: Boolean,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        valueKey: {
          type: String,
          default: "value"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: Boolean,
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: iconPropType,
          default: circle_close_default
        },
        fitInputWidth: Boolean,
        suffixIcon: {
          type: iconPropType,
          default: arrow_down_default
        },
        tagType: { ...tagProps.type, default: "info" },
        tagEffect: { ...tagProps.effect, default: "light" },
        validateEvent: {
          type: Boolean,
          default: true
        },
        remoteShowSuffix: Boolean,
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: ["bottom-start", "top-start", "right", "left"]
        },
        appendTo: String,
        ...useEmptyValuesProps,
        ...useAriaProps(["ariaLabel"])
      });
      const COMPONENT_NAME$4 = "ElSelect";
      const _sfc_main$p = vue.defineComponent({
        name: COMPONENT_NAME$4,
        componentName: COMPONENT_NAME$4,
        components: {
          ElSelectMenu,
          ElOption: Option,
          ElOptions,
          ElTag,
          ElScrollbar,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside },
        props: SelectProps,
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props, { emit }) {
          const modelValue = vue.computed(() => {
            const { modelValue: rawModelValue, multiple } = props;
            const fallback = multiple ? [] : void 0;
            if (isArray$1(rawModelValue)) {
              return multiple ? rawModelValue : fallback;
            }
            return multiple ? fallback : rawModelValue;
          });
          const _props = vue.reactive({
            ...vue.toRefs(props),
            modelValue
          });
          const API = useSelect(_props, emit);
          vue.provide(selectKey, vue.reactive({
            props: _props,
            states: API.states,
            optionsArray: API.optionsArray,
            handleOptionSelect: API.handleOptionSelect,
            onOptionCreate: API.onOptionCreate,
            onOptionDestroy: API.onOptionDestroy,
            selectRef: API.selectRef,
            setSelected: API.setSelected
          }));
          const selectedLabel = vue.computed(() => {
            if (!props.multiple) {
              return API.states.selectedLabel;
            }
            return API.states.selected.map((i) => i.currentLabel);
          });
          return {
            ...API,
            modelValue,
            selectedLabel
          };
        }
      });
      function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = vue.resolveComponent("el-tag");
        const _component_el_tooltip = vue.resolveComponent("el-tooltip");
        const _component_el_icon = vue.resolveComponent("el-icon");
        const _component_el_option = vue.resolveComponent("el-option");
        const _component_el_options = vue.resolveComponent("el-options");
        const _component_el_scrollbar = vue.resolveComponent("el-scrollbar");
        const _component_el_select_menu = vue.resolveComponent("el-select-menu");
        const _directive_click_outside = vue.resolveDirective("click-outside");
        return vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
          ref: "selectRef",
          class: vue.normalizeClass([_ctx.nsSelect.b(), _ctx.nsSelect.m(_ctx.selectSize)]),
          [vue.toHandlerKey(_ctx.mouseEnterEventName)]: ($event) => _ctx.states.inputHovering = true,
          onMouseleave: ($event) => _ctx.states.inputHovering = false
        }, [
          vue.createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropdownMenuVisible,
            placement: _ctx.placement,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
            "popper-options": _ctx.popperOptions,
            "fallback-placements": _ctx.fallbackPlacements,
            effect: _ctx.effect,
            pure: "",
            trigger: "click",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            persistent: _ctx.persistent,
            "append-to": _ctx.appendTo,
            onBeforeShow: _ctx.handleMenuEnter,
            onHide: ($event) => _ctx.states.isBeforeHide = false
          }, {
            default: vue.withCtx(() => {
              var _a2;
              return [
                vue.createElementVNode("div", {
                  ref: "wrapperRef",
                  class: vue.normalizeClass([
                    _ctx.nsSelect.e("wrapper"),
                    _ctx.nsSelect.is("focused", _ctx.isFocused),
                    _ctx.nsSelect.is("hovering", _ctx.states.inputHovering),
                    _ctx.nsSelect.is("filterable", _ctx.filterable),
                    _ctx.nsSelect.is("disabled", _ctx.selectDisabled)
                  ]),
                  onClick: vue.withModifiers(_ctx.toggleMenu, ["prevent"])
                }, [
                  _ctx.$slots.prefix ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 0,
                    ref: "prefixRef",
                    class: vue.normalizeClass(_ctx.nsSelect.e("prefix"))
                  }, [
                    vue.renderSlot(_ctx.$slots, "prefix")
                  ], 2)) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("div", {
                    ref: "selectionRef",
                    class: vue.normalizeClass([
                      _ctx.nsSelect.e("selection"),
                      _ctx.nsSelect.is("near", _ctx.multiple && !_ctx.$slots.prefix && !!_ctx.states.selected.length)
                    ])
                  }, [
                    _ctx.multiple ? vue.renderSlot(_ctx.$slots, "tag", { key: 0 }, () => [
                      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.showTagList, (item) => {
                        return vue.openBlock(), vue.createElementBlock("div", {
                          key: _ctx.getValueKey(item),
                          class: vue.normalizeClass(_ctx.nsSelect.e("selected-item"))
                        }, [
                          vue.createVNode(_component_el_tag, {
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            type: _ctx.tagType,
                            effect: _ctx.tagEffect,
                            "disable-transitions": "",
                            style: vue.normalizeStyle(_ctx.tagStyle),
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: vue.withCtx(() => [
                              vue.createElementVNode("span", {
                                class: vue.normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, [
                                vue.renderSlot(_ctx.$slots, "label", {
                                  label: item.currentLabel,
                                  value: item.value
                                }, () => [
                                  vue.createTextVNode(vue.toDisplayString(item.currentLabel), 1)
                                ])
                              ], 2)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "type", "effect", "style", "onClose"])
                        ], 2);
                      }), 128)),
                      _ctx.collapseTags && _ctx.states.selected.length > _ctx.maxCollapseTags ? (vue.openBlock(), vue.createBlock(_component_el_tooltip, {
                        key: 0,
                        ref: "tagTooltipRef",
                        disabled: _ctx.dropdownMenuVisible || !_ctx.collapseTagsTooltip,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        effect: _ctx.effect,
                        placement: "bottom",
                        teleported: _ctx.teleported
                      }, {
                        default: vue.withCtx(() => [
                          vue.createElementVNode("div", {
                            ref: "collapseItemRef",
                            class: vue.normalizeClass(_ctx.nsSelect.e("selected-item"))
                          }, [
                            vue.createVNode(_component_el_tag, {
                              closable: false,
                              size: _ctx.collapseTagSize,
                              type: _ctx.tagType,
                              effect: _ctx.tagEffect,
                              "disable-transitions": "",
                              style: vue.normalizeStyle(_ctx.collapseTagStyle)
                            }, {
                              default: vue.withCtx(() => [
                                vue.createElementVNode("span", {
                                  class: vue.normalizeClass(_ctx.nsSelect.e("tags-text"))
                                }, " + " + vue.toDisplayString(_ctx.states.selected.length - _ctx.maxCollapseTags), 3)
                              ]),
                              _: 1
                            }, 8, ["size", "type", "effect", "style"])
                          ], 2)
                        ]),
                        content: vue.withCtx(() => [
                          vue.createElementVNode("div", {
                            ref: "tagMenuRef",
                            class: vue.normalizeClass(_ctx.nsSelect.e("selection"))
                          }, [
                            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.collapseTagList, (item) => {
                              return vue.openBlock(), vue.createElementBlock("div", {
                                key: _ctx.getValueKey(item),
                                class: vue.normalizeClass(_ctx.nsSelect.e("selected-item"))
                              }, [
                                vue.createVNode(_component_el_tag, {
                                  class: "in-tooltip",
                                  closable: !_ctx.selectDisabled && !item.isDisabled,
                                  size: _ctx.collapseTagSize,
                                  type: _ctx.tagType,
                                  effect: _ctx.tagEffect,
                                  "disable-transitions": "",
                                  onClose: ($event) => _ctx.deleteTag($event, item)
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.createElementVNode("span", {
                                      class: vue.normalizeClass(_ctx.nsSelect.e("tags-text"))
                                    }, [
                                      vue.renderSlot(_ctx.$slots, "label", {
                                        label: item.currentLabel,
                                        value: item.value
                                      }, () => [
                                        vue.createTextVNode(vue.toDisplayString(item.currentLabel), 1)
                                      ])
                                    ], 2)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "type", "effect", "onClose"])
                              ], 2);
                            }), 128))
                          ], 2)
                        ]),
                        _: 3
                      }, 8, ["disabled", "effect", "teleported"])) : vue.createCommentVNode("v-if", true)
                    ]) : vue.createCommentVNode("v-if", true),
                    !_ctx.selectDisabled ? (vue.openBlock(), vue.createElementBlock("div", {
                      key: 1,
                      class: vue.normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("input-wrapper"),
                        _ctx.nsSelect.is("hidden", !_ctx.filterable)
                      ])
                    }, [
                      vue.withDirectives(vue.createElementVNode("input", {
                        id: _ctx.inputId,
                        ref: "inputRef",
                        "onUpdate:modelValue": ($event) => _ctx.states.inputValue = $event,
                        type: "text",
                        name: _ctx.name,
                        class: vue.normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                        disabled: _ctx.selectDisabled,
                        autocomplete: _ctx.autocomplete,
                        style: vue.normalizeStyle(_ctx.inputStyle),
                        role: "combobox",
                        readonly: !_ctx.filterable,
                        spellcheck: "false",
                        "aria-activedescendant": ((_a2 = _ctx.hoverOption) == null ? void 0 : _a2.id) || "",
                        "aria-controls": _ctx.contentId,
                        "aria-expanded": _ctx.dropdownMenuVisible,
                        "aria-label": _ctx.ariaLabel,
                        "aria-autocomplete": "none",
                        "aria-haspopup": "listbox",
                        onKeydown: [
                          vue.withKeys(vue.withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"]),
                          vue.withKeys(vue.withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"]),
                          vue.withKeys(vue.withModifiers(_ctx.handleEsc, ["stop", "prevent"]), ["esc"]),
                          vue.withKeys(vue.withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
                          vue.withKeys(vue.withModifiers(_ctx.deletePrevTag, ["stop"]), ["delete"])
                        ],
                        onCompositionstart: _ctx.handleCompositionStart,
                        onCompositionupdate: _ctx.handleCompositionUpdate,
                        onCompositionend: _ctx.handleCompositionEnd,
                        onInput: _ctx.onInput,
                        onClick: vue.withModifiers(_ctx.toggleMenu, ["stop"])
                      }, null, 46, ["id", "onUpdate:modelValue", "name", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label", "onKeydown", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onInput", "onClick"]), [
                        [vue.vModelText, _ctx.states.inputValue]
                      ]),
                      _ctx.filterable ? (vue.openBlock(), vue.createElementBlock("span", {
                        key: 0,
                        ref: "calculatorRef",
                        "aria-hidden": "true",
                        class: vue.normalizeClass(_ctx.nsSelect.e("input-calculator")),
                        textContent: vue.toDisplayString(_ctx.states.inputValue)
                      }, null, 10, ["textContent"])) : vue.createCommentVNode("v-if", true)
                    ], 2)) : vue.createCommentVNode("v-if", true),
                    _ctx.shouldShowPlaceholder ? (vue.openBlock(), vue.createElementBlock("div", {
                      key: 2,
                      class: vue.normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("placeholder"),
                        _ctx.nsSelect.is("transparent", !_ctx.hasModelValue || _ctx.expanded && !_ctx.states.inputValue)
                      ])
                    }, [
                      _ctx.hasModelValue ? vue.renderSlot(_ctx.$slots, "label", {
                        key: 0,
                        label: _ctx.currentPlaceholder,
                        value: _ctx.modelValue
                      }, () => [
                        vue.createElementVNode("span", null, vue.toDisplayString(_ctx.currentPlaceholder), 1)
                      ]) : (vue.openBlock(), vue.createElementBlock("span", { key: 1 }, vue.toDisplayString(_ctx.currentPlaceholder), 1))
                    ], 2)) : vue.createCommentVNode("v-if", true)
                  ], 2),
                  vue.createElementVNode("div", {
                    ref: "suffixRef",
                    class: vue.normalizeClass(_ctx.nsSelect.e("suffix"))
                  }, [
                    _ctx.iconComponent && !_ctx.showClose ? (vue.openBlock(), vue.createBlock(_component_el_icon, {
                      key: 0,
                      class: vue.normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                    }, {
                      default: vue.withCtx(() => [
                        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : vue.createCommentVNode("v-if", true),
                    _ctx.showClose && _ctx.clearIcon ? (vue.openBlock(), vue.createBlock(_component_el_icon, {
                      key: 1,
                      class: vue.normalizeClass([
                        _ctx.nsSelect.e("caret"),
                        _ctx.nsSelect.e("icon"),
                        _ctx.nsSelect.e("clear")
                      ]),
                      onClick: _ctx.handleClearClick
                    }, {
                      default: vue.withCtx(() => [
                        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : vue.createCommentVNode("v-if", true),
                    _ctx.validateState && _ctx.validateIcon ? (vue.openBlock(), vue.createBlock(_component_el_icon, {
                      key: 2,
                      class: vue.normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                    }, {
                      default: vue.withCtx(() => [
                        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.validateIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : vue.createCommentVNode("v-if", true)
                  ], 2)
                ], 10, ["onClick"])
              ];
            }),
            content: vue.withCtx(() => [
              vue.createVNode(_component_el_select_menu, { ref: "menuRef" }, {
                default: vue.withCtx(() => [
                  _ctx.$slots.header ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 0,
                    class: vue.normalizeClass(_ctx.nsSelect.be("dropdown", "header")),
                    onClick: vue.withModifiers(() => {
                    }, ["stop"])
                  }, [
                    vue.renderSlot(_ctx.$slots, "header")
                  ], 10, ["onClick"])) : vue.createCommentVNode("v-if", true),
                  vue.withDirectives(vue.createVNode(_component_el_scrollbar, {
                    id: _ctx.contentId,
                    ref: "scrollbarRef",
                    tag: "ul",
                    "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                    "view-class": _ctx.nsSelect.be("dropdown", "list"),
                    class: vue.normalizeClass([_ctx.nsSelect.is("empty", _ctx.filteredOptionsCount === 0)]),
                    role: "listbox",
                    "aria-label": _ctx.ariaLabel,
                    "aria-orientation": "vertical"
                  }, {
                    default: vue.withCtx(() => [
                      _ctx.showNewOption ? (vue.openBlock(), vue.createBlock(_component_el_option, {
                        key: 0,
                        value: _ctx.states.inputValue,
                        created: true
                      }, null, 8, ["value"])) : vue.createCommentVNode("v-if", true),
                      vue.createVNode(_component_el_options, null, {
                        default: vue.withCtx(() => [
                          vue.renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
                    [vue.vShow, _ctx.states.options.size > 0 && !_ctx.loading]
                  ]),
                  _ctx.$slots.loading && _ctx.loading ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 1,
                    class: vue.normalizeClass(_ctx.nsSelect.be("dropdown", "loading"))
                  }, [
                    vue.renderSlot(_ctx.$slots, "loading")
                  ], 2)) : _ctx.loading || _ctx.filteredOptionsCount === 0 ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 2,
                    class: vue.normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                  }, [
                    vue.renderSlot(_ctx.$slots, "empty", {}, () => [
                      vue.createElementVNode("span", null, vue.toDisplayString(_ctx.emptyText), 1)
                    ])
                  ], 2)) : vue.createCommentVNode("v-if", true),
                  _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 3,
                    class: vue.normalizeClass(_ctx.nsSelect.be("dropdown", "footer")),
                    onClick: vue.withModifiers(() => {
                    }, ["stop"])
                  }, [
                    vue.renderSlot(_ctx.$slots, "footer")
                  ], 10, ["onClick"])) : vue.createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 512)
            ]),
            _: 3
          }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "transition", "persistent", "append-to", "onBeforeShow", "onHide"])
        ], 16, ["onMouseleave"])), [
          [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
        ]);
      }
      var Select = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$2], ["__file", "select.vue"]]);
      const _sfc_main$o = vue.defineComponent({
        name: "ElOptionGroup",
        componentName: "ElOptionGroup",
        props: {
          label: String,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const groupRef = vue.ref(null);
          const instance = vue.getCurrentInstance();
          const children = vue.ref([]);
          vue.provide(selectGroupKey, vue.reactive({
            ...vue.toRefs(props)
          }));
          const visible = vue.computed(() => children.value.some((option) => option.visible === true));
          const isOption = (node) => {
            var _a2, _b;
            return ((_a2 = node.type) == null ? void 0 : _a2.name) === "ElOption" && !!((_b = node.component) == null ? void 0 : _b.proxy);
          };
          const flattedChildren2 = (node) => {
            const Nodes = castArray(node);
            const children2 = [];
            Nodes.forEach((child) => {
              var _a2, _b;
              if (isOption(child)) {
                children2.push(child.component.proxy);
              } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
                children2.push(...flattedChildren2(child.children));
              } else if ((_b = child.component) == null ? void 0 : _b.subTree) {
                children2.push(...flattedChildren2(child.component.subTree));
              }
            });
            return children2;
          };
          const updateChildren = () => {
            children.value = flattedChildren2(instance.subTree);
          };
          vue.onMounted(() => {
            updateChildren();
          });
          useMutationObserver(groupRef, updateChildren, {
            attributes: true,
            subtree: true,
            childList: true
          });
          return {
            groupRef,
            visible,
            ns
          };
        }
      });
      function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.withDirectives((vue.openBlock(), vue.createElementBlock("ul", {
          ref: "groupRef",
          class: vue.normalizeClass(_ctx.ns.be("group", "wrap"))
        }, [
          vue.createElementVNode("li", {
            class: vue.normalizeClass(_ctx.ns.be("group", "title"))
          }, vue.toDisplayString(_ctx.label), 3),
          vue.createElementVNode("li", null, [
            vue.createElementVNode("ul", {
              class: vue.normalizeClass(_ctx.ns.b("group"))
            }, [
              vue.renderSlot(_ctx.$slots, "default")
            ], 2)
          ])
        ], 2)), [
          [vue.vShow, _ctx.visible]
        ]);
      }
      var OptionGroup = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$1], ["__file", "option-group.vue"]]);
      const ElSelect = withInstall(Select, {
        Option,
        OptionGroup
      });
      const ElOption = withNoopInstall(Option);
      withNoopInstall(OptionGroup);
      const progressProps = buildProps({
        type: {
          type: String,
          default: "line",
          values: ["line", "circle", "dashboard"]
        },
        percentage: {
          type: Number,
          default: 0,
          validator: (val) => val >= 0 && val <= 100
        },
        status: {
          type: String,
          default: "",
          values: ["", "success", "exception", "warning"]
        },
        indeterminate: Boolean,
        duration: {
          type: Number,
          default: 3
        },
        strokeWidth: {
          type: Number,
          default: 6
        },
        strokeLinecap: {
          type: definePropType(String),
          default: "round"
        },
        textInside: Boolean,
        width: {
          type: Number,
          default: 126
        },
        showText: {
          type: Boolean,
          default: true
        },
        color: {
          type: definePropType([
            String,
            Array,
            Function
          ]),
          default: ""
        },
        striped: Boolean,
        stripedFlow: Boolean,
        format: {
          type: definePropType(Function),
          default: (percentage) => `${percentage}%`
        }
      });
      const __default__$8 = vue.defineComponent({
        name: "ElProgress"
      });
      const _sfc_main$n = /* @__PURE__ */ vue.defineComponent({
        ...__default__$8,
        props: progressProps,
        setup(__props) {
          const props = __props;
          const STATUS_COLOR_MAP = {
            success: "#13ce66",
            exception: "#ff4949",
            warning: "#e6a23c",
            default: "#20a0ff"
          };
          const ns = useNamespace("progress");
          const barStyle = vue.computed(() => {
            const barStyle2 = {
              width: `${props.percentage}%`,
              animationDuration: `${props.duration}s`
            };
            const color = getCurrentColor(props.percentage);
            if (color.includes("gradient")) {
              barStyle2.background = color;
            } else {
              barStyle2.backgroundColor = color;
            }
            return barStyle2;
          });
          const relativeStrokeWidth = vue.computed(() => (props.strokeWidth / props.width * 100).toFixed(1));
          const radius = vue.computed(() => {
            if (["circle", "dashboard"].includes(props.type)) {
              return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
            }
            return 0;
          });
          const trackPath = vue.computed(() => {
            const r = radius.value;
            const isDashboard = props.type === "dashboard";
            return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
          });
          const perimeter = vue.computed(() => 2 * Math.PI * radius.value);
          const rate = vue.computed(() => props.type === "dashboard" ? 0.75 : 1);
          const strokeDashoffset = vue.computed(() => {
            const offset = -1 * perimeter.value * (1 - rate.value) / 2;
            return `${offset}px`;
          });
          const trailPathStyle = vue.computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value
          }));
          const circlePathStyle = vue.computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value * (props.percentage / 100)}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value,
            transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
          }));
          const stroke = vue.computed(() => {
            let ret;
            if (props.color) {
              ret = getCurrentColor(props.percentage);
            } else {
              ret = STATUS_COLOR_MAP[props.status] || STATUS_COLOR_MAP.default;
            }
            return ret;
          });
          const statusIcon = vue.computed(() => {
            if (props.status === "warning") {
              return warning_filled_default;
            }
            if (props.type === "line") {
              return props.status === "success" ? circle_check_default : circle_close_default;
            } else {
              return props.status === "success" ? check_default : close_default;
            }
          });
          const progressTextSize = vue.computed(() => {
            return props.type === "line" ? 12 + props.strokeWidth * 0.4 : props.width * 0.111111 + 2;
          });
          const content = vue.computed(() => props.format(props.percentage));
          function getColors(color) {
            const span = 100 / color.length;
            const seriesColors = color.map((seriesColor, index) => {
              if (isString(seriesColor)) {
                return {
                  color: seriesColor,
                  percentage: (index + 1) * span
                };
              }
              return seriesColor;
            });
            return seriesColors.sort((a, b) => a.percentage - b.percentage);
          }
          const getCurrentColor = (percentage) => {
            var _a2;
            const { color } = props;
            if (isFunction$1(color)) {
              return color(percentage);
            } else if (isString(color)) {
              return color;
            } else {
              const colors = getColors(color);
              for (const color2 of colors) {
                if (color2.percentage > percentage)
                  return color2.color;
              }
              return (_a2 = colors[colors.length - 1]) == null ? void 0 : _a2.color;
            }
          };
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: vue.normalizeClass([
                vue.unref(ns).b(),
                vue.unref(ns).m(_ctx.type),
                vue.unref(ns).is(_ctx.status),
                {
                  [vue.unref(ns).m("without-text")]: !_ctx.showText,
                  [vue.unref(ns).m("text-inside")]: _ctx.textInside
                }
              ]),
              role: "progressbar",
              "aria-valuenow": _ctx.percentage,
              "aria-valuemin": "0",
              "aria-valuemax": "100"
            }, [
              _ctx.type === "line" ? (vue.openBlock(), vue.createElementBlock("div", {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).b("bar"))
              }, [
                vue.createElementVNode("div", {
                  class: vue.normalizeClass(vue.unref(ns).be("bar", "outer")),
                  style: vue.normalizeStyle({ height: `${_ctx.strokeWidth}px` })
                }, [
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass([
                      vue.unref(ns).be("bar", "inner"),
                      { [vue.unref(ns).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate },
                      { [vue.unref(ns).bem("bar", "inner", "striped")]: _ctx.striped },
                      { [vue.unref(ns).bem("bar", "inner", "striped-flow")]: _ctx.stripedFlow }
                    ]),
                    style: vue.normalizeStyle(vue.unref(barStyle))
                  }, [
                    (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (vue.openBlock(), vue.createElementBlock("div", {
                      key: 0,
                      class: vue.normalizeClass(vue.unref(ns).be("bar", "innerText"))
                    }, [
                      vue.renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                        vue.createElementVNode("span", null, vue.toDisplayString(vue.unref(content)), 1)
                      ])
                    ], 2)) : vue.createCommentVNode("v-if", true)
                  ], 6)
                ], 6)
              ], 2)) : (vue.openBlock(), vue.createElementBlock("div", {
                key: 1,
                class: vue.normalizeClass(vue.unref(ns).b("circle")),
                style: vue.normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
              }, [
                (vue.openBlock(), vue.createElementBlock("svg", { viewBox: "0 0 100 100" }, [
                  vue.createElementVNode("path", {
                    class: vue.normalizeClass(vue.unref(ns).be("circle", "track")),
                    d: vue.unref(trackPath),
                    stroke: `var(${vue.unref(ns).cssVarName("fill-color-light")}, #e5e9f2)`,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": vue.unref(relativeStrokeWidth),
                    fill: "none",
                    style: vue.normalizeStyle(vue.unref(trailPathStyle))
                  }, null, 14, ["d", "stroke", "stroke-linecap", "stroke-width"]),
                  vue.createElementVNode("path", {
                    class: vue.normalizeClass(vue.unref(ns).be("circle", "path")),
                    d: vue.unref(trackPath),
                    stroke: vue.unref(stroke),
                    fill: "none",
                    opacity: _ctx.percentage ? 1 : 0,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": vue.unref(relativeStrokeWidth),
                    style: vue.normalizeStyle(vue.unref(circlePathStyle))
                  }, null, 14, ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"])
                ]))
              ], 6)),
              (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (vue.openBlock(), vue.createElementBlock("div", {
                key: 2,
                class: vue.normalizeClass(vue.unref(ns).e("text")),
                style: vue.normalizeStyle({ fontSize: `${vue.unref(progressTextSize)}px` })
              }, [
                vue.renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                  !_ctx.status ? (vue.openBlock(), vue.createElementBlock("span", { key: 0 }, vue.toDisplayString(vue.unref(content)), 1)) : (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), { key: 1 }, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(statusIcon))))
                    ]),
                    _: 1
                  }))
                ])
              ], 6)) : vue.createCommentVNode("v-if", true)
            ], 10, ["aria-valuenow"]);
          };
        }
      });
      var Progress = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__file", "progress.vue"]]);
      const ElProgress = withInstall(Progress);
      const tabsRootContextKey = Symbol("tabsRootContextKey");
      const tabBarProps = buildProps({
        tabs: {
          type: definePropType(Array),
          default: () => mutable([])
        }
      });
      const COMPONENT_NAME$3 = "ElTabBar";
      const __default__$7 = vue.defineComponent({
        name: COMPONENT_NAME$3
      });
      const _sfc_main$m = /* @__PURE__ */ vue.defineComponent({
        ...__default__$7,
        props: tabBarProps,
        setup(__props, { expose }) {
          const props = __props;
          const instance = vue.getCurrentInstance();
          const rootTabs = vue.inject(tabsRootContextKey);
          if (!rootTabs)
            throwError(COMPONENT_NAME$3, "<el-tabs><el-tab-bar /></el-tabs>");
          const ns = useNamespace("tabs");
          const barRef = vue.ref();
          const barStyle = vue.ref();
          const getBarStyle = () => {
            let offset = 0;
            let tabSize = 0;
            const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
            const sizeDir = sizeName === "width" ? "x" : "y";
            const position = sizeDir === "x" ? "left" : "top";
            props.tabs.every((tab) => {
              var _a2, _b;
              const $el = (_b = (_a2 = instance.parent) == null ? void 0 : _a2.refs) == null ? void 0 : _b[`tab-${tab.uid}`];
              if (!$el)
                return false;
              if (!tab.active) {
                return true;
              }
              offset = $el[`offset${capitalize(position)}`];
              tabSize = $el[`client${capitalize(sizeName)}`];
              const tabStyles = window.getComputedStyle($el);
              if (sizeName === "width") {
                tabSize -= Number.parseFloat(tabStyles.paddingLeft) + Number.parseFloat(tabStyles.paddingRight);
                offset += Number.parseFloat(tabStyles.paddingLeft);
              }
              return false;
            });
            return {
              [sizeName]: `${tabSize}px`,
              transform: `translate${capitalize(sizeDir)}(${offset}px)`
            };
          };
          const update = () => barStyle.value = getBarStyle();
          const saveObserver = [];
          const observerTabs = () => {
            var _a2;
            saveObserver.forEach((observer) => observer.stop());
            saveObserver.length = 0;
            const list = (_a2 = instance.parent) == null ? void 0 : _a2.refs;
            if (!list)
              return;
            for (const key in list) {
              if (key.startsWith("tab-")) {
                const _el = list[key];
                if (_el) {
                  saveObserver.push(useResizeObserver(_el, update));
                }
              }
            }
          };
          vue.watch(() => props.tabs, async () => {
            await vue.nextTick();
            update();
            observerTabs();
          }, { immediate: true });
          const barObserever = useResizeObserver(barRef, () => update());
          vue.onBeforeUnmount(() => {
            saveObserver.forEach((observer) => observer.stop());
            saveObserver.length = 0;
            barObserever.stop();
          });
          expose({
            ref: barRef,
            update
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              ref_key: "barRef",
              ref: barRef,
              class: vue.normalizeClass([vue.unref(ns).e("active-bar"), vue.unref(ns).is(vue.unref(rootTabs).props.tabPosition)]),
              style: vue.normalizeStyle(barStyle.value)
            }, null, 6);
          };
        }
      });
      var TabBar = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__file", "tab-bar.vue"]]);
      const tabNavProps = buildProps({
        panes: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        currentName: {
          type: [String, Number],
          default: ""
        },
        editable: Boolean,
        type: {
          type: String,
          values: ["card", "border-card", ""],
          default: ""
        },
        stretch: Boolean
      });
      const tabNavEmits = {
        tabClick: (tab, tabName, ev) => ev instanceof Event,
        tabRemove: (tab, ev) => ev instanceof Event
      };
      const COMPONENT_NAME$2 = "ElTabNav";
      const TabNav = vue.defineComponent({
        name: COMPONENT_NAME$2,
        props: tabNavProps,
        emits: tabNavEmits,
        setup(props, {
          expose,
          emit
        }) {
          const rootTabs = vue.inject(tabsRootContextKey);
          if (!rootTabs)
            throwError(COMPONENT_NAME$2, `<el-tabs><tab-nav /></el-tabs>`);
          const ns = useNamespace("tabs");
          const visibility = useDocumentVisibility();
          const focused = useWindowFocus();
          const navScroll$ = vue.ref();
          const nav$ = vue.ref();
          const el$ = vue.ref();
          const tabBarRef = vue.ref();
          const scrollable = vue.ref(false);
          const navOffset = vue.ref(0);
          const isFocus = vue.ref(false);
          const focusable = vue.ref(true);
          const sizeName = vue.computed(() => ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height");
          const navStyle = vue.computed(() => {
            const dir = sizeName.value === "width" ? "X" : "Y";
            return {
              transform: `translate${dir}(-${navOffset.value}px)`
            };
          });
          const scrollPrev = () => {
            if (!navScroll$.value)
              return;
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (!currentOffset)
              return;
            const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
            navOffset.value = newOffset;
          };
          const scrollNext = () => {
            if (!navScroll$.value || !nav$.value)
              return;
            const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (navSize - currentOffset <= containerSize)
              return;
            const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
            navOffset.value = newOffset;
          };
          const scrollToActiveTab = async () => {
            const nav = nav$.value;
            if (!scrollable.value || !el$.value || !navScroll$.value || !nav)
              return;
            await vue.nextTick();
            const activeTab = el$.value.querySelector(".is-active");
            if (!activeTab)
              return;
            const navScroll = navScroll$.value;
            const isHorizontal = ["top", "bottom"].includes(rootTabs.props.tabPosition);
            const activeTabBounding = activeTab.getBoundingClientRect();
            const navScrollBounding = navScroll.getBoundingClientRect();
            const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
            const currentOffset = navOffset.value;
            let newOffset = currentOffset;
            if (isHorizontal) {
              if (activeTabBounding.left < navScrollBounding.left) {
                newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
              }
              if (activeTabBounding.right > navScrollBounding.right) {
                newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
              }
            } else {
              if (activeTabBounding.top < navScrollBounding.top) {
                newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
              }
              if (activeTabBounding.bottom > navScrollBounding.bottom) {
                newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
              }
            }
            newOffset = Math.max(newOffset, 0);
            navOffset.value = Math.min(newOffset, maxOffset);
          };
          const update = () => {
            var _a2;
            if (!nav$.value || !navScroll$.value)
              return;
            props.stretch && ((_a2 = tabBarRef.value) == null ? void 0 : _a2.update());
            const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (containerSize < navSize) {
              scrollable.value = scrollable.value || {};
              scrollable.value.prev = currentOffset;
              scrollable.value.next = currentOffset + containerSize < navSize;
              if (navSize - currentOffset < containerSize) {
                navOffset.value = navSize - containerSize;
              }
            } else {
              scrollable.value = false;
              if (currentOffset > 0) {
                navOffset.value = 0;
              }
            }
          };
          const changeTab = (e) => {
            const code = e.code;
            const {
              up,
              down,
              left,
              right
            } = EVENT_CODE;
            if (![up, down, left, right].includes(code))
              return;
            const tabList = Array.from(e.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
            const currentIndex = tabList.indexOf(e.target);
            let nextIndex;
            if (code === left || code === up) {
              if (currentIndex === 0) {
                nextIndex = tabList.length - 1;
              } else {
                nextIndex = currentIndex - 1;
              }
            } else {
              if (currentIndex < tabList.length - 1) {
                nextIndex = currentIndex + 1;
              } else {
                nextIndex = 0;
              }
            }
            tabList[nextIndex].focus({
              preventScroll: true
            });
            tabList[nextIndex].click();
            setFocus();
          };
          const setFocus = () => {
            if (focusable.value)
              isFocus.value = true;
          };
          const removeFocus = () => isFocus.value = false;
          vue.watch(visibility, (visibility2) => {
            if (visibility2 === "hidden") {
              focusable.value = false;
            } else if (visibility2 === "visible") {
              setTimeout(() => focusable.value = true, 50);
            }
          });
          vue.watch(focused, (focused2) => {
            if (focused2) {
              setTimeout(() => focusable.value = true, 50);
            } else {
              focusable.value = false;
            }
          });
          useResizeObserver(el$, update);
          vue.onMounted(() => setTimeout(() => scrollToActiveTab(), 0));
          vue.onUpdated(() => update());
          expose({
            scrollToActiveTab,
            removeFocus
          });
          return () => {
            const scrollBtn = scrollable.value ? [vue.createVNode("span", {
              "class": [ns.e("nav-prev"), ns.is("disabled", !scrollable.value.prev)],
              "onClick": scrollPrev
            }, [vue.createVNode(ElIcon, null, {
              default: () => [vue.createVNode(arrow_left_default, null, null)]
            })]), vue.createVNode("span", {
              "class": [ns.e("nav-next"), ns.is("disabled", !scrollable.value.next)],
              "onClick": scrollNext
            }, [vue.createVNode(ElIcon, null, {
              default: () => [vue.createVNode(arrow_right_default, null, null)]
            })])] : null;
            const tabs = props.panes.map((pane, index) => {
              var _a2, _b, _c, _d;
              const uid = pane.uid;
              const disabled = pane.props.disabled;
              const tabName = (_b = (_a2 = pane.props.name) != null ? _a2 : pane.index) != null ? _b : `${index}`;
              const closable = !disabled && (pane.isClosable || props.editable);
              pane.index = `${index}`;
              const btnClose = closable ? vue.createVNode(ElIcon, {
                "class": "is-icon-close",
                "onClick": (ev) => emit("tabRemove", pane, ev)
              }, {
                default: () => [vue.createVNode(close_default, null, null)]
              }) : null;
              const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;
              const tabindex = !disabled && pane.active ? 0 : -1;
              return vue.createVNode("div", {
                "ref": `tab-${uid}`,
                "class": [ns.e("item"), ns.is(rootTabs.props.tabPosition), ns.is("active", pane.active), ns.is("disabled", disabled), ns.is("closable", closable), ns.is("focus", isFocus.value)],
                "id": `tab-${tabName}`,
                "key": `tab-${uid}`,
                "aria-controls": `pane-${tabName}`,
                "role": "tab",
                "aria-selected": pane.active,
                "tabindex": tabindex,
                "onFocus": () => setFocus(),
                "onBlur": () => removeFocus(),
                "onClick": (ev) => {
                  removeFocus();
                  emit("tabClick", pane, tabName, ev);
                },
                "onKeydown": (ev) => {
                  if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {
                    emit("tabRemove", pane, ev);
                  }
                }
              }, [...[tabLabelContent, btnClose]]);
            });
            return vue.createVNode("div", {
              "ref": el$,
              "class": [ns.e("nav-wrap"), ns.is("scrollable", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]
            }, [scrollBtn, vue.createVNode("div", {
              "class": ns.e("nav-scroll"),
              "ref": navScroll$
            }, [vue.createVNode("div", {
              "class": [ns.e("nav"), ns.is(rootTabs.props.tabPosition), ns.is("stretch", props.stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition))],
              "ref": nav$,
              "style": navStyle.value,
              "role": "tablist",
              "onKeydown": changeTab
            }, [...[!props.type ? vue.createVNode(TabBar, {
              "ref": tabBarRef,
              "tabs": [...props.panes]
            }, null) : null, tabs]])])]);
          };
        }
      });
      const tabsProps = buildProps({
        type: {
          type: String,
          values: ["card", "border-card", ""],
          default: ""
        },
        closable: Boolean,
        addable: Boolean,
        modelValue: {
          type: [String, Number]
        },
        editable: Boolean,
        tabPosition: {
          type: String,
          values: ["top", "right", "bottom", "left"],
          default: "top"
        },
        beforeLeave: {
          type: definePropType(Function),
          default: () => true
        },
        stretch: Boolean
      });
      const isPaneName = (value) => isString(value) || isNumber(value);
      const tabsEmits = {
        [UPDATE_MODEL_EVENT]: (name) => isPaneName(name),
        tabClick: (pane, ev) => ev instanceof Event,
        tabChange: (name) => isPaneName(name),
        edit: (paneName, action) => ["remove", "add"].includes(action),
        tabRemove: (name) => isPaneName(name),
        tabAdd: () => true
      };
      const Tabs = vue.defineComponent({
        name: "ElTabs",
        props: tabsProps,
        emits: tabsEmits,
        setup(props, {
          emit,
          slots,
          expose
        }) {
          var _a2;
          const ns = useNamespace("tabs");
          const isVertical = vue.computed(() => ["left", "right"].includes(props.tabPosition));
          const {
            children: panes,
            addChild: sortPane,
            removeChild: unregisterPane
          } = useOrderedChildren(vue.getCurrentInstance(), "ElTabPane");
          const nav$ = vue.ref();
          const currentName = vue.ref((_a2 = props.modelValue) != null ? _a2 : "0");
          const setCurrentName = async (value, trigger = false) => {
            var _a22, _b, _c;
            if (currentName.value === value || isUndefined(value))
              return;
            try {
              const canLeave = await ((_a22 = props.beforeLeave) == null ? void 0 : _a22.call(props, value, currentName.value));
              if (canLeave !== false) {
                currentName.value = value;
                if (trigger) {
                  emit(UPDATE_MODEL_EVENT, value);
                  emit("tabChange", value);
                }
                (_c = (_b = nav$.value) == null ? void 0 : _b.removeFocus) == null ? void 0 : _c.call(_b);
              }
            } catch (e) {
            }
          };
          const handleTabClick = (tab, tabName, event) => {
            if (tab.props.disabled)
              return;
            setCurrentName(tabName, true);
            emit("tabClick", tab, event);
          };
          const handleTabRemove = (pane, ev) => {
            if (pane.props.disabled || isUndefined(pane.props.name))
              return;
            ev.stopPropagation();
            emit("edit", pane.props.name, "remove");
            emit("tabRemove", pane.props.name);
          };
          const handleTabAdd = () => {
            emit("edit", void 0, "add");
            emit("tabAdd");
          };
          vue.watch(() => props.modelValue, (modelValue) => setCurrentName(modelValue));
          vue.watch(currentName, async () => {
            var _a22;
            await vue.nextTick();
            (_a22 = nav$.value) == null ? void 0 : _a22.scrollToActiveTab();
          });
          vue.provide(tabsRootContextKey, {
            props,
            currentName,
            registerPane: (pane) => {
              panes.value.push(pane);
            },
            sortPane,
            unregisterPane
          });
          expose({
            currentName
          });
          const TabNavRenderer = ({
            render: render2
          }) => {
            return render2();
          };
          return () => {
            const addSlot = slots["add-icon"];
            const newButton = props.editable || props.addable ? vue.createVNode("div", {
              "class": [ns.e("new-tab"), isVertical.value && ns.e("new-tab-vertical")],
              "tabindex": "0",
              "onClick": handleTabAdd,
              "onKeydown": (ev) => {
                if (ev.code === EVENT_CODE.enter)
                  handleTabAdd();
              }
            }, [addSlot ? vue.renderSlot(slots, "add-icon") : vue.createVNode(ElIcon, {
              "class": ns.is("icon-plus")
            }, {
              default: () => [vue.createVNode(plus_default, null, null)]
            })]) : null;
            const header = vue.createVNode("div", {
              "class": [ns.e("header"), isVertical.value && ns.e("header-vertical"), ns.is(props.tabPosition)]
            }, [vue.createVNode(TabNavRenderer, {
              "render": () => {
                const hasLabelSlot = panes.value.some((pane) => pane.slots.label);
                return vue.createVNode(TabNav, {
                  ref: nav$,
                  currentName: currentName.value,
                  editable: props.editable,
                  type: props.type,
                  panes: panes.value,
                  stretch: props.stretch,
                  onTabClick: handleTabClick,
                  onTabRemove: handleTabRemove
                }, {
                  $stable: !hasLabelSlot
                });
              }
            }, null), newButton]);
            const panels = vue.createVNode("div", {
              "class": ns.e("content")
            }, [vue.renderSlot(slots, "default")]);
            return vue.createVNode("div", {
              "class": [ns.b(), ns.m(props.tabPosition), {
                [ns.m("card")]: props.type === "card",
                [ns.m("border-card")]: props.type === "border-card"
              }]
            }, [panels, header]);
          };
        }
      });
      const tabPaneProps = buildProps({
        label: {
          type: String,
          default: ""
        },
        name: {
          type: [String, Number]
        },
        closable: Boolean,
        disabled: Boolean,
        lazy: Boolean
      });
      const COMPONENT_NAME$1 = "ElTabPane";
      const __default__$6 = vue.defineComponent({
        name: COMPONENT_NAME$1
      });
      const _sfc_main$l = /* @__PURE__ */ vue.defineComponent({
        ...__default__$6,
        props: tabPaneProps,
        setup(__props) {
          const props = __props;
          const instance = vue.getCurrentInstance();
          const slots = vue.useSlots();
          const tabsRoot = vue.inject(tabsRootContextKey);
          if (!tabsRoot)
            throwError(COMPONENT_NAME$1, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
          const ns = useNamespace("tab-pane");
          const index = vue.ref();
          const isClosable = vue.computed(() => props.closable || tabsRoot.props.closable);
          const active = computedEager(() => {
            var _a2;
            return tabsRoot.currentName.value === ((_a2 = props.name) != null ? _a2 : index.value);
          });
          const loaded = vue.ref(active.value);
          const paneName = vue.computed(() => {
            var _a2;
            return (_a2 = props.name) != null ? _a2 : index.value;
          });
          const shouldBeRender = computedEager(() => !props.lazy || loaded.value || active.value);
          vue.watch(active, (val) => {
            if (val)
              loaded.value = true;
          });
          const pane = vue.reactive({
            uid: instance.uid,
            slots,
            props,
            paneName,
            active,
            index,
            isClosable
          });
          tabsRoot.registerPane(pane);
          vue.onMounted(() => {
            tabsRoot.sortPane(pane);
          });
          vue.onUnmounted(() => {
            tabsRoot.unregisterPane(pane.uid);
          });
          return (_ctx, _cache) => {
            return vue.unref(shouldBeRender) ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
              key: 0,
              id: `pane-${vue.unref(paneName)}`,
              class: vue.normalizeClass(vue.unref(ns).b()),
              role: "tabpanel",
              "aria-hidden": !vue.unref(active),
              "aria-labelledby": `tab-${vue.unref(paneName)}`
            }, [
              vue.renderSlot(_ctx.$slots, "default")
            ], 10, ["id", "aria-hidden", "aria-labelledby"])), [
              [vue.vShow, vue.unref(active)]
            ]) : vue.createCommentVNode("v-if", true);
          };
        }
      });
      var TabPane = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__file", "tab-pane.vue"]]);
      const ElTabs = withInstall(Tabs, {
        TabPane
      });
      const ElTabPane = withNoopInstall(TabPane);
      const textProps = buildProps({
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger", ""],
          default: ""
        },
        size: {
          type: String,
          values: componentSizes,
          default: ""
        },
        truncated: Boolean,
        lineClamp: {
          type: [String, Number]
        },
        tag: {
          type: String,
          default: "span"
        }
      });
      const __default__$5 = vue.defineComponent({
        name: "ElText"
      });
      const _sfc_main$k = /* @__PURE__ */ vue.defineComponent({
        ...__default__$5,
        props: textProps,
        setup(__props) {
          const props = __props;
          const textSize = useFormSize();
          const ns = useNamespace("text");
          const textKls = vue.computed(() => [
            ns.b(),
            ns.m(props.type),
            ns.m(textSize.value),
            ns.is("truncated", props.truncated),
            ns.is("line-clamp", !isUndefined(props.lineClamp))
          ]);
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.tag), {
              class: vue.normalizeClass(vue.unref(textKls)),
              style: vue.normalizeStyle({ "-webkit-line-clamp": _ctx.lineClamp })
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Text = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "text.vue"]]);
      const ElText = withInstall(Text);
      const uploadContextKey = Symbol("uploadContextKey");
      const SCOPE$1 = "ElUpload";
      class UploadAjaxError extends Error {
        constructor(message, status, method, url) {
          super(message);
          this.name = "UploadAjaxError";
          this.status = status;
          this.method = method;
          this.url = url;
        }
      }
      function getError(action, option, xhr) {
        let msg;
        if (xhr.response) {
          msg = `${xhr.response.error || xhr.response}`;
        } else if (xhr.responseText) {
          msg = `${xhr.responseText}`;
        } else {
          msg = `fail to ${option.method} ${action} ${xhr.status}`;
        }
        return new UploadAjaxError(msg, xhr.status, option.method, action);
      }
      function getBody(xhr) {
        const text = xhr.responseText || xhr.response;
        if (!text) {
          return text;
        }
        try {
          return JSON.parse(text);
        } catch (e) {
          return text;
        }
      }
      const ajaxUpload = (option) => {
        if (typeof XMLHttpRequest === "undefined")
          throwError(SCOPE$1, "XMLHttpRequest is undefined");
        const xhr = new XMLHttpRequest();
        const action = option.action;
        if (xhr.upload) {
          xhr.upload.addEventListener("progress", (evt) => {
            const progressEvt = evt;
            progressEvt.percent = evt.total > 0 ? evt.loaded / evt.total * 100 : 0;
            option.onProgress(progressEvt);
          });
        }
        const formData = new FormData();
        if (option.data) {
          for (const [key, value] of Object.entries(option.data)) {
            if (isArray$1(value) && value.length)
              formData.append(key, ...value);
            else
              formData.append(key, value);
          }
        }
        formData.append(option.filename, option.file, option.file.name);
        xhr.addEventListener("error", () => {
          option.onError(getError(action, option, xhr));
        });
        xhr.addEventListener("load", () => {
          if (xhr.status < 200 || xhr.status >= 300) {
            return option.onError(getError(action, option, xhr));
          }
          option.onSuccess(getBody(xhr));
        });
        xhr.open(option.method, action, true);
        if (option.withCredentials && "withCredentials" in xhr) {
          xhr.withCredentials = true;
        }
        const headers = option.headers || {};
        if (headers instanceof Headers) {
          headers.forEach((value, key) => xhr.setRequestHeader(key, value));
        } else {
          for (const [key, value] of Object.entries(headers)) {
            if (isNil(value))
              continue;
            xhr.setRequestHeader(key, String(value));
          }
        }
        xhr.send(formData);
        return xhr;
      };
      const uploadListTypes = ["text", "picture", "picture-card"];
      let fileId = 1;
      const genFileId = () => Date.now() + fileId++;
      const uploadBaseProps = buildProps({
        action: {
          type: String,
          default: "#"
        },
        headers: {
          type: definePropType(Object)
        },
        method: {
          type: String,
          default: "post"
        },
        data: {
          type: definePropType([Object, Function, Promise]),
          default: () => mutable({})
        },
        multiple: Boolean,
        name: {
          type: String,
          default: "file"
        },
        drag: Boolean,
        withCredentials: Boolean,
        showFileList: {
          type: Boolean,
          default: true
        },
        accept: {
          type: String,
          default: ""
        },
        fileList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        autoUpload: {
          type: Boolean,
          default: true
        },
        listType: {
          type: String,
          values: uploadListTypes,
          default: "text"
        },
        httpRequest: {
          type: definePropType(Function),
          default: ajaxUpload
        },
        disabled: Boolean,
        limit: Number
      });
      const uploadProps = buildProps({
        ...uploadBaseProps,
        beforeUpload: {
          type: definePropType(Function),
          default: NOOP
        },
        beforeRemove: {
          type: definePropType(Function)
        },
        onRemove: {
          type: definePropType(Function),
          default: NOOP
        },
        onChange: {
          type: definePropType(Function),
          default: NOOP
        },
        onPreview: {
          type: definePropType(Function),
          default: NOOP
        },
        onSuccess: {
          type: definePropType(Function),
          default: NOOP
        },
        onProgress: {
          type: definePropType(Function),
          default: NOOP
        },
        onError: {
          type: definePropType(Function),
          default: NOOP
        },
        onExceed: {
          type: definePropType(Function),
          default: NOOP
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const uploadListProps = buildProps({
        files: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        disabled: {
          type: Boolean,
          default: false
        },
        handlePreview: {
          type: definePropType(Function),
          default: NOOP
        },
        listType: {
          type: String,
          values: uploadListTypes,
          default: "text"
        },
        crossorigin: {
          type: definePropType(String)
        }
      });
      const uploadListEmits = {
        remove: (file) => !!file
      };
      const __default__$4 = vue.defineComponent({
        name: "ElUploadList"
      });
      const _sfc_main$j = /* @__PURE__ */ vue.defineComponent({
        ...__default__$4,
        props: uploadListProps,
        emits: uploadListEmits,
        setup(__props, { emit }) {
          const props = __props;
          const { t } = useLocale();
          const nsUpload = useNamespace("upload");
          const nsIcon = useNamespace("icon");
          const nsList = useNamespace("list");
          const disabled = useFormDisabled();
          const focusing = vue.ref(false);
          const containerKls = vue.computed(() => [
            nsUpload.b("list"),
            nsUpload.bm("list", props.listType),
            nsUpload.is("disabled", props.disabled)
          ]);
          const handleRemove = (file) => {
            emit("remove", file);
          };
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.TransitionGroup, {
              tag: "ul",
              class: vue.normalizeClass(vue.unref(containerKls)),
              name: vue.unref(nsList).b()
            }, {
              default: vue.withCtx(() => [
                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.files, (file, index) => {
                  return vue.openBlock(), vue.createElementBlock("li", {
                    key: file.uid || file.name,
                    class: vue.normalizeClass([
                      vue.unref(nsUpload).be("list", "item"),
                      vue.unref(nsUpload).is(file.status),
                      { focusing: focusing.value }
                    ]),
                    tabindex: "0",
                    onKeydown: vue.withKeys(($event) => !vue.unref(disabled) && handleRemove(file), ["delete"]),
                    onFocus: ($event) => focusing.value = true,
                    onBlur: ($event) => focusing.value = false,
                    onClick: ($event) => focusing.value = false
                  }, [
                    vue.renderSlot(_ctx.$slots, "default", {
                      file,
                      index
                    }, () => [
                      _ctx.listType === "picture" || file.status !== "uploading" && _ctx.listType === "picture-card" ? (vue.openBlock(), vue.createElementBlock("img", {
                        key: 0,
                        class: vue.normalizeClass(vue.unref(nsUpload).be("list", "item-thumbnail")),
                        src: file.url,
                        crossorigin: _ctx.crossorigin,
                        alt: ""
                      }, null, 10, ["src", "crossorigin"])) : vue.createCommentVNode("v-if", true),
                      file.status === "uploading" || _ctx.listType !== "picture-card" ? (vue.openBlock(), vue.createElementBlock("div", {
                        key: 1,
                        class: vue.normalizeClass(vue.unref(nsUpload).be("list", "item-info"))
                      }, [
                        vue.createElementVNode("a", {
                          class: vue.normalizeClass(vue.unref(nsUpload).be("list", "item-name")),
                          onClick: vue.withModifiers(($event) => _ctx.handlePreview(file), ["prevent"])
                        }, [
                          vue.createVNode(vue.unref(ElIcon), {
                            class: vue.normalizeClass(vue.unref(nsIcon).m("document"))
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(document_default))
                            ]),
                            _: 1
                          }, 8, ["class"]),
                          vue.createElementVNode("span", {
                            class: vue.normalizeClass(vue.unref(nsUpload).be("list", "item-file-name")),
                            title: file.name
                          }, vue.toDisplayString(file.name), 11, ["title"])
                        ], 10, ["onClick"]),
                        file.status === "uploading" ? (vue.openBlock(), vue.createBlock(vue.unref(ElProgress), {
                          key: 0,
                          type: _ctx.listType === "picture-card" ? "circle" : "line",
                          "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
                          percentage: Number(file.percentage),
                          style: vue.normalizeStyle(_ctx.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                        }, null, 8, ["type", "stroke-width", "percentage", "style"])) : vue.createCommentVNode("v-if", true)
                      ], 2)) : vue.createCommentVNode("v-if", true),
                      vue.createElementVNode("label", {
                        class: vue.normalizeClass(vue.unref(nsUpload).be("list", "item-status-label"))
                      }, [
                        _ctx.listType === "text" ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                          key: 0,
                          class: vue.normalizeClass([vue.unref(nsIcon).m("upload-success"), vue.unref(nsIcon).m("circle-check")])
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(circle_check_default))
                          ]),
                          _: 1
                        }, 8, ["class"])) : ["picture-card", "picture"].includes(_ctx.listType) ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                          key: 1,
                          class: vue.normalizeClass([vue.unref(nsIcon).m("upload-success"), vue.unref(nsIcon).m("check")])
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(check_default))
                          ]),
                          _: 1
                        }, 8, ["class"])) : vue.createCommentVNode("v-if", true)
                      ], 2),
                      !vue.unref(disabled) ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                        key: 2,
                        class: vue.normalizeClass(vue.unref(nsIcon).m("close")),
                        onClick: ($event) => handleRemove(file)
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(vue.unref(close_default))
                        ]),
                        _: 2
                      }, 1032, ["class", "onClick"])) : vue.createCommentVNode("v-if", true),
                      vue.createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
                      vue.createCommentVNode(" This is a bug which needs to be fixed "),
                      vue.createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
                      !vue.unref(disabled) ? (vue.openBlock(), vue.createElementBlock("i", {
                        key: 3,
                        class: vue.normalizeClass(vue.unref(nsIcon).m("close-tip"))
                      }, vue.toDisplayString(vue.unref(t)("el.upload.deleteTip")), 3)) : vue.createCommentVNode("v-if", true),
                      _ctx.listType === "picture-card" ? (vue.openBlock(), vue.createElementBlock("span", {
                        key: 4,
                        class: vue.normalizeClass(vue.unref(nsUpload).be("list", "item-actions"))
                      }, [
                        vue.createElementVNode("span", {
                          class: vue.normalizeClass(vue.unref(nsUpload).be("list", "item-preview")),
                          onClick: ($event) => _ctx.handlePreview(file)
                        }, [
                          vue.createVNode(vue.unref(ElIcon), {
                            class: vue.normalizeClass(vue.unref(nsIcon).m("zoom-in"))
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(zoom_in_default))
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 10, ["onClick"]),
                        !vue.unref(disabled) ? (vue.openBlock(), vue.createElementBlock("span", {
                          key: 0,
                          class: vue.normalizeClass(vue.unref(nsUpload).be("list", "item-delete")),
                          onClick: ($event) => handleRemove(file)
                        }, [
                          vue.createVNode(vue.unref(ElIcon), {
                            class: vue.normalizeClass(vue.unref(nsIcon).m("delete"))
                          }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(vue.unref(delete_default))
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 10, ["onClick"])) : vue.createCommentVNode("v-if", true)
                      ], 2)) : vue.createCommentVNode("v-if", true)
                    ])
                  ], 42, ["onKeydown", "onFocus", "onBlur", "onClick"]);
                }), 128)),
                vue.renderSlot(_ctx.$slots, "append")
              ]),
              _: 3
            }, 8, ["class", "name"]);
          };
        }
      });
      var UploadList = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "upload-list.vue"]]);
      const uploadDraggerProps = buildProps({
        disabled: {
          type: Boolean,
          default: false
        }
      });
      const uploadDraggerEmits = {
        file: (file) => isArray$1(file)
      };
      const COMPONENT_NAME = "ElUploadDrag";
      const __default__$3 = vue.defineComponent({
        name: COMPONENT_NAME
      });
      const _sfc_main$i = /* @__PURE__ */ vue.defineComponent({
        ...__default__$3,
        props: uploadDraggerProps,
        emits: uploadDraggerEmits,
        setup(__props, { emit }) {
          const uploaderContext = vue.inject(uploadContextKey);
          if (!uploaderContext) {
            throwError(COMPONENT_NAME, "usage: <el-upload><el-upload-dragger /></el-upload>");
          }
          const ns = useNamespace("upload");
          const dragover = vue.ref(false);
          const disabled = useFormDisabled();
          const onDrop = (e) => {
            if (disabled.value)
              return;
            dragover.value = false;
            e.stopPropagation();
            const files = Array.from(e.dataTransfer.files);
            emit("file", files);
          };
          const onDragover = () => {
            if (!disabled.value)
              dragover.value = true;
          };
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: vue.normalizeClass([vue.unref(ns).b("dragger"), vue.unref(ns).is("dragover", dragover.value)]),
              onDrop: vue.withModifiers(onDrop, ["prevent"]),
              onDragover: vue.withModifiers(onDragover, ["prevent"]),
              onDragleave: vue.withModifiers(($event) => dragover.value = false, ["prevent"])
            }, [
              vue.renderSlot(_ctx.$slots, "default")
            ], 42, ["onDrop", "onDragover", "onDragleave"]);
          };
        }
      });
      var UploadDragger = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__file", "upload-dragger.vue"]]);
      const uploadContentProps = buildProps({
        ...uploadBaseProps,
        beforeUpload: {
          type: definePropType(Function),
          default: NOOP
        },
        onRemove: {
          type: definePropType(Function),
          default: NOOP
        },
        onStart: {
          type: definePropType(Function),
          default: NOOP
        },
        onSuccess: {
          type: definePropType(Function),
          default: NOOP
        },
        onProgress: {
          type: definePropType(Function),
          default: NOOP
        },
        onError: {
          type: definePropType(Function),
          default: NOOP
        },
        onExceed: {
          type: definePropType(Function),
          default: NOOP
        }
      });
      const __default__$2 = vue.defineComponent({
        name: "ElUploadContent",
        inheritAttrs: false
      });
      const _sfc_main$h = /* @__PURE__ */ vue.defineComponent({
        ...__default__$2,
        props: uploadContentProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("upload");
          const disabled = useFormDisabled();
          const requests = vue.shallowRef({});
          const inputRef = vue.shallowRef();
          const uploadFiles = (files) => {
            if (files.length === 0)
              return;
            const { autoUpload, limit, fileList, multiple, onStart, onExceed } = props;
            if (limit && fileList.length + files.length > limit) {
              onExceed(files, fileList);
              return;
            }
            if (!multiple) {
              files = files.slice(0, 1);
            }
            for (const file of files) {
              const rawFile = file;
              rawFile.uid = genFileId();
              onStart(rawFile);
              if (autoUpload)
                upload(rawFile);
            }
          };
          const upload = async (rawFile) => {
            inputRef.value.value = "";
            if (!props.beforeUpload) {
              return doUpload(rawFile);
            }
            let hookResult;
            let beforeData = {};
            try {
              const originData = props.data;
              const beforeUploadPromise = props.beforeUpload(rawFile);
              beforeData = isPlainObject(props.data) ? cloneDeep(props.data) : props.data;
              hookResult = await beforeUploadPromise;
              if (isPlainObject(props.data) && isEqual(originData, beforeData)) {
                beforeData = cloneDeep(props.data);
              }
            } catch (e) {
              hookResult = false;
            }
            if (hookResult === false) {
              props.onRemove(rawFile);
              return;
            }
            let file = rawFile;
            if (hookResult instanceof Blob) {
              if (hookResult instanceof File) {
                file = hookResult;
              } else {
                file = new File([hookResult], rawFile.name, {
                  type: rawFile.type
                });
              }
            }
            doUpload(Object.assign(file, {
              uid: rawFile.uid
            }), beforeData);
          };
          const resolveData = async (data, rawFile) => {
            if (isFunction$1(data)) {
              return data(rawFile);
            }
            return data;
          };
          const doUpload = async (rawFile, beforeData) => {
            const {
              headers,
              data,
              method,
              withCredentials,
              name: filename,
              action,
              onProgress,
              onSuccess,
              onError,
              httpRequest
            } = props;
            try {
              beforeData = await resolveData(beforeData != null ? beforeData : data, rawFile);
            } catch (e) {
              props.onRemove(rawFile);
              return;
            }
            const { uid } = rawFile;
            const options = {
              headers: headers || {},
              withCredentials,
              file: rawFile,
              data: beforeData,
              method,
              filename,
              action,
              onProgress: (evt) => {
                onProgress(evt, rawFile);
              },
              onSuccess: (res) => {
                onSuccess(res, rawFile);
                delete requests.value[uid];
              },
              onError: (err) => {
                onError(err, rawFile);
                delete requests.value[uid];
              }
            };
            const request = httpRequest(options);
            requests.value[uid] = request;
            if (request instanceof Promise) {
              request.then(options.onSuccess, options.onError);
            }
          };
          const handleChange = (e) => {
            const files = e.target.files;
            if (!files)
              return;
            uploadFiles(Array.from(files));
          };
          const handleClick = () => {
            if (!disabled.value) {
              inputRef.value.value = "";
              inputRef.value.click();
            }
          };
          const handleKeydown = () => {
            handleClick();
          };
          const abort = (file) => {
            const _reqs = entriesOf(requests.value).filter(file ? ([uid]) => String(file.uid) === uid : () => true);
            _reqs.forEach(([uid, req]) => {
              if (req instanceof XMLHttpRequest)
                req.abort();
              delete requests.value[uid];
            });
          };
          expose({
            abort,
            upload
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: vue.normalizeClass([
                vue.unref(ns).b(),
                vue.unref(ns).m(_ctx.listType),
                vue.unref(ns).is("drag", _ctx.drag),
                vue.unref(ns).is("disabled", vue.unref(disabled))
              ]),
              tabindex: vue.unref(disabled) ? "-1" : "0",
              onClick: handleClick,
              onKeydown: vue.withKeys(vue.withModifiers(handleKeydown, ["self"]), ["enter", "space"])
            }, [
              _ctx.drag ? (vue.openBlock(), vue.createBlock(UploadDragger, {
                key: 0,
                disabled: vue.unref(disabled),
                onFile: uploadFiles
              }, {
                default: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["disabled"])) : vue.renderSlot(_ctx.$slots, "default", { key: 1 }),
              vue.createElementVNode("input", {
                ref_key: "inputRef",
                ref: inputRef,
                class: vue.normalizeClass(vue.unref(ns).e("input")),
                name: _ctx.name,
                disabled: vue.unref(disabled),
                multiple: _ctx.multiple,
                accept: _ctx.accept,
                type: "file",
                onChange: handleChange,
                onClick: vue.withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["name", "disabled", "multiple", "accept", "onClick"])
            ], 42, ["tabindex", "onKeydown"]);
          };
        }
      });
      var UploadContent = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__file", "upload-content.vue"]]);
      const SCOPE = "ElUpload";
      const revokeFileObjectURL = (file) => {
        var _a2;
        if ((_a2 = file.url) == null ? void 0 : _a2.startsWith("blob:")) {
          URL.revokeObjectURL(file.url);
        }
      };
      const useHandlers = (props, uploadRef) => {
        const uploadFiles = useVModel(props, "fileList", void 0, { passive: true });
        const getFile = (rawFile) => uploadFiles.value.find((file) => file.uid === rawFile.uid);
        function abort(file) {
          var _a2;
          (_a2 = uploadRef.value) == null ? void 0 : _a2.abort(file);
        }
        function clearFiles(states = ["ready", "uploading", "success", "fail"]) {
          uploadFiles.value = uploadFiles.value.filter((row) => !states.includes(row.status));
        }
        function removeFile(file) {
          uploadFiles.value = uploadFiles.value.filter((uploadFile) => uploadFile !== file);
        }
        const handleError = (err, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          console.error(err);
          file.status = "fail";
          removeFile(file);
          props.onError(err, file, uploadFiles.value);
          props.onChange(file, uploadFiles.value);
        };
        const handleProgress = (evt, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          props.onProgress(evt, file, uploadFiles.value);
          file.status = "uploading";
          file.percentage = Math.round(evt.percent);
        };
        const handleSuccess = (response, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          file.status = "success";
          file.response = response;
          props.onSuccess(response, file, uploadFiles.value);
          props.onChange(file, uploadFiles.value);
        };
        const handleStart = (file) => {
          if (isNil(file.uid))
            file.uid = genFileId();
          const uploadFile = {
            name: file.name,
            percentage: 0,
            status: "ready",
            size: file.size,
            raw: file,
            uid: file.uid
          };
          if (props.listType === "picture-card" || props.listType === "picture") {
            try {
              uploadFile.url = URL.createObjectURL(file);
            } catch (err) {
              debugWarn(SCOPE, err.message);
              props.onError(err, uploadFile, uploadFiles.value);
            }
          }
          uploadFiles.value = [...uploadFiles.value, uploadFile];
          props.onChange(uploadFile, uploadFiles.value);
        };
        const handleRemove = async (file) => {
          const uploadFile = file instanceof File ? getFile(file) : file;
          if (!uploadFile)
            throwError(SCOPE, "file to be removed not found");
          const doRemove = (file2) => {
            abort(file2);
            removeFile(file2);
            props.onRemove(file2, uploadFiles.value);
            revokeFileObjectURL(file2);
          };
          if (props.beforeRemove) {
            const before2 = await props.beforeRemove(uploadFile, uploadFiles.value);
            if (before2 !== false)
              doRemove(uploadFile);
          } else {
            doRemove(uploadFile);
          }
        };
        function submit() {
          uploadFiles.value.filter(({ status }) => status === "ready").forEach(({ raw }) => {
            var _a2;
            return raw && ((_a2 = uploadRef.value) == null ? void 0 : _a2.upload(raw));
          });
        }
        vue.watch(() => props.listType, (val) => {
          if (val !== "picture-card" && val !== "picture") {
            return;
          }
          uploadFiles.value = uploadFiles.value.map((file) => {
            const { raw, url } = file;
            if (!url && raw) {
              try {
                file.url = URL.createObjectURL(raw);
              } catch (err) {
                props.onError(err, file, uploadFiles.value);
              }
            }
            return file;
          });
        });
        vue.watch(uploadFiles, (files) => {
          for (const file of files) {
            file.uid || (file.uid = genFileId());
            file.status || (file.status = "success");
          }
        }, { immediate: true, deep: true });
        return {
          uploadFiles,
          abort,
          clearFiles,
          handleError,
          handleProgress,
          handleStart,
          handleSuccess,
          handleRemove,
          submit,
          revokeFileObjectURL
        };
      };
      const __default__$1 = vue.defineComponent({
        name: "ElUpload"
      });
      const _sfc_main$g = /* @__PURE__ */ vue.defineComponent({
        ...__default__$1,
        props: uploadProps,
        setup(__props, { expose }) {
          const props = __props;
          const disabled = useFormDisabled();
          const uploadRef = vue.shallowRef();
          const {
            abort,
            submit,
            clearFiles,
            uploadFiles,
            handleStart,
            handleError,
            handleRemove,
            handleSuccess,
            handleProgress,
            revokeFileObjectURL: revokeFileObjectURL2
          } = useHandlers(props, uploadRef);
          const isPictureCard = vue.computed(() => props.listType === "picture-card");
          const uploadContentProps2 = vue.computed(() => ({
            ...props,
            fileList: uploadFiles.value,
            onStart: handleStart,
            onProgress: handleProgress,
            onSuccess: handleSuccess,
            onError: handleError,
            onRemove: handleRemove
          }));
          vue.onBeforeUnmount(() => {
            uploadFiles.value.forEach(revokeFileObjectURL2);
          });
          vue.provide(uploadContextKey, {
            accept: vue.toRef(props, "accept")
          });
          expose({
            abort,
            submit,
            clearFiles,
            handleStart,
            handleRemove
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", null, [
              vue.unref(isPictureCard) && _ctx.showFileList ? (vue.openBlock(), vue.createBlock(UploadList, {
                key: 0,
                disabled: vue.unref(disabled),
                "list-type": _ctx.listType,
                files: vue.unref(uploadFiles),
                crossorigin: _ctx.crossorigin,
                "handle-preview": _ctx.onPreview,
                onRemove: vue.unref(handleRemove)
              }, vue.createSlots({
                append: vue.withCtx(() => [
                  vue.createVNode(UploadContent, vue.mergeProps({
                    ref_key: "uploadRef",
                    ref: uploadRef
                  }, vue.unref(uploadContentProps2)), {
                    default: vue.withCtx(() => [
                      _ctx.$slots.trigger ? vue.renderSlot(_ctx.$slots, "trigger", { key: 0 }) : vue.createCommentVNode("v-if", true),
                      !_ctx.$slots.trigger && _ctx.$slots.default ? vue.renderSlot(_ctx.$slots, "default", { key: 1 }) : vue.createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16)
                ]),
                _: 2
              }, [
                _ctx.$slots.file ? {
                  name: "default",
                  fn: vue.withCtx(({ file, index }) => [
                    vue.renderSlot(_ctx.$slots, "file", {
                      file,
                      index
                    })
                  ])
                } : void 0
              ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : vue.createCommentVNode("v-if", true),
              !vue.unref(isPictureCard) || vue.unref(isPictureCard) && !_ctx.showFileList ? (vue.openBlock(), vue.createBlock(UploadContent, vue.mergeProps({
                key: 1,
                ref_key: "uploadRef",
                ref: uploadRef
              }, vue.unref(uploadContentProps2)), {
                default: vue.withCtx(() => [
                  _ctx.$slots.trigger ? vue.renderSlot(_ctx.$slots, "trigger", { key: 0 }) : vue.createCommentVNode("v-if", true),
                  !_ctx.$slots.trigger && _ctx.$slots.default ? vue.renderSlot(_ctx.$slots, "default", { key: 1 }) : vue.createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 16)) : vue.createCommentVNode("v-if", true),
              _ctx.$slots.trigger ? vue.renderSlot(_ctx.$slots, "default", { key: 2 }) : vue.createCommentVNode("v-if", true),
              vue.renderSlot(_ctx.$slots, "tip"),
              !vue.unref(isPictureCard) && _ctx.showFileList ? (vue.openBlock(), vue.createBlock(UploadList, {
                key: 3,
                disabled: vue.unref(disabled),
                "list-type": _ctx.listType,
                files: vue.unref(uploadFiles),
                crossorigin: _ctx.crossorigin,
                "handle-preview": _ctx.onPreview,
                onRemove: vue.unref(handleRemove)
              }, vue.createSlots({
                _: 2
              }, [
                _ctx.$slots.file ? {
                  name: "default",
                  fn: vue.withCtx(({ file, index }) => [
                    vue.renderSlot(_ctx.$slots, "file", {
                      file,
                      index
                    })
                  ])
                } : void 0
              ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : vue.createCommentVNode("v-if", true)
            ]);
          };
        }
      });
      var Upload = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__file", "upload.vue"]]);
      const ElUpload = withInstall(Upload);
      function createLoadingComponent(options) {
        let afterLeaveTimer;
        const afterLeaveFlag = vue.ref(false);
        const data = vue.reactive({
          ...options,
          originalPosition: "",
          originalOverflow: "",
          visible: false
        });
        function setText(text) {
          data.text = text;
        }
        function destroySelf() {
          const target = data.parent;
          const ns = vm.ns;
          if (!target.vLoadingAddClassList) {
            let loadingNumber = target.getAttribute("loading-number");
            loadingNumber = Number.parseInt(loadingNumber) - 1;
            if (!loadingNumber) {
              removeClass(target, ns.bm("parent", "relative"));
              target.removeAttribute("loading-number");
            } else {
              target.setAttribute("loading-number", loadingNumber.toString());
            }
            removeClass(target, ns.bm("parent", "hidden"));
          }
          removeElLoadingChild();
          loadingInstance.unmount();
        }
        function removeElLoadingChild() {
          var _a2, _b;
          (_b = (_a2 = vm.$el) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b.removeChild(vm.$el);
        }
        function close2() {
          var _a2;
          if (options.beforeClose && !options.beforeClose())
            return;
          afterLeaveFlag.value = true;
          clearTimeout(afterLeaveTimer);
          afterLeaveTimer = setTimeout(handleAfterLeave, 400);
          data.visible = false;
          (_a2 = options.closed) == null ? void 0 : _a2.call(options);
        }
        function handleAfterLeave() {
          if (!afterLeaveFlag.value)
            return;
          const target = data.parent;
          afterLeaveFlag.value = false;
          target.vLoadingAddClassList = void 0;
          destroySelf();
        }
        const elLoadingComponent = vue.defineComponent({
          name: "ElLoading",
          setup(_2, { expose }) {
            const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("loading");
            expose({
              ns,
              zIndex: zIndex2
            });
            return () => {
              const svg = data.spinner || data.svg;
              const spinner = vue.h("svg", {
                class: "circular",
                viewBox: data.svgViewBox ? data.svgViewBox : "0 0 50 50",
                ...svg ? { innerHTML: svg } : {}
              }, [
                vue.h("circle", {
                  class: "path",
                  cx: "25",
                  cy: "25",
                  r: "20",
                  fill: "none"
                })
              ]);
              const spinnerText = data.text ? vue.h("p", { class: ns.b("text") }, [data.text]) : void 0;
              return vue.h(vue.Transition, {
                name: ns.b("fade"),
                onAfterLeave: handleAfterLeave
              }, {
                default: vue.withCtx(() => [
                  vue.withDirectives(vue.createVNode("div", {
                    style: {
                      backgroundColor: data.background || ""
                    },
                    class: [
                      ns.b("mask"),
                      data.customClass,
                      data.fullscreen ? "is-fullscreen" : ""
                    ]
                  }, [
                    vue.h("div", {
                      class: ns.b("spinner")
                    }, [spinner, spinnerText])
                  ]), [[vue.vShow, data.visible]])
                ])
              });
            };
          }
        });
        const loadingInstance = vue.createApp(elLoadingComponent);
        const vm = loadingInstance.mount(document.createElement("div"));
        return {
          ...vue.toRefs(data),
          setText,
          removeElLoadingChild,
          close: close2,
          handleAfterLeave,
          vm,
          get $el() {
            return vm.$el;
          }
        };
      }
      let fullscreenInstance = void 0;
      const Loading = function(options = {}) {
        if (!isClient)
          return void 0;
        const resolved = resolveOptions(options);
        if (resolved.fullscreen && fullscreenInstance) {
          return fullscreenInstance;
        }
        const instance = createLoadingComponent({
          ...resolved,
          closed: () => {
            var _a2;
            (_a2 = resolved.closed) == null ? void 0 : _a2.call(resolved);
            if (resolved.fullscreen)
              fullscreenInstance = void 0;
          }
        });
        addStyle(resolved, resolved.parent, instance);
        addClassList(resolved, resolved.parent, instance);
        resolved.parent.vLoadingAddClassList = () => addClassList(resolved, resolved.parent, instance);
        let loadingNumber = resolved.parent.getAttribute("loading-number");
        if (!loadingNumber) {
          loadingNumber = "1";
        } else {
          loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
        }
        resolved.parent.setAttribute("loading-number", loadingNumber);
        resolved.parent.appendChild(instance.$el);
        vue.nextTick(() => instance.visible.value = resolved.visible);
        if (resolved.fullscreen) {
          fullscreenInstance = instance;
        }
        return instance;
      };
      const resolveOptions = (options) => {
        var _a2, _b, _c, _d;
        let target;
        if (isString(options.target)) {
          target = (_a2 = document.querySelector(options.target)) != null ? _a2 : document.body;
        } else {
          target = options.target || document.body;
        }
        return {
          parent: target === document.body || options.body ? document.body : target,
          background: options.background || "",
          svg: options.svg || "",
          svgViewBox: options.svgViewBox || "",
          spinner: options.spinner || false,
          text: options.text || "",
          fullscreen: target === document.body && ((_b = options.fullscreen) != null ? _b : true),
          lock: (_c = options.lock) != null ? _c : false,
          customClass: options.customClass || "",
          visible: (_d = options.visible) != null ? _d : true,
          beforeClose: options.beforeClose,
          closed: options.closed,
          target
        };
      };
      const addStyle = async (options, parent, instance) => {
        const { nextZIndex } = instance.vm.zIndex || instance.vm._.exposed.zIndex;
        const maskStyle = {};
        if (options.fullscreen) {
          instance.originalPosition.value = getStyle(document.body, "position");
          instance.originalOverflow.value = getStyle(document.body, "overflow");
          maskStyle.zIndex = nextZIndex();
        } else if (options.parent === document.body) {
          instance.originalPosition.value = getStyle(document.body, "position");
          await vue.nextTick();
          for (const property2 of ["top", "left"]) {
            const scroll = property2 === "top" ? "scrollTop" : "scrollLeft";
            maskStyle[property2] = `${options.target.getBoundingClientRect()[property2] + document.body[scroll] + document.documentElement[scroll] - Number.parseInt(getStyle(document.body, `margin-${property2}`), 10)}px`;
          }
          for (const property2 of ["height", "width"]) {
            maskStyle[property2] = `${options.target.getBoundingClientRect()[property2]}px`;
          }
        } else {
          instance.originalPosition.value = getStyle(parent, "position");
        }
        for (const [key, value] of Object.entries(maskStyle)) {
          instance.$el.style[key] = value;
        }
      };
      const addClassList = (options, parent, instance) => {
        const ns = instance.vm.ns || instance.vm._.exposed.ns;
        if (!["absolute", "fixed", "sticky"].includes(instance.originalPosition.value)) {
          addClass(parent, ns.bm("parent", "relative"));
        } else {
          removeClass(parent, ns.bm("parent", "relative"));
        }
        if (options.fullscreen && options.lock) {
          addClass(parent, ns.bm("parent", "hidden"));
        } else {
          removeClass(parent, ns.bm("parent", "hidden"));
        }
      };
      const INSTANCE_KEY = Symbol("ElLoading");
      const createInstance = (el, binding) => {
        var _a2, _b, _c, _d;
        const vm = binding.instance;
        const getBindingProp = (key) => isObject$1(binding.value) ? binding.value[key] : void 0;
        const resolveExpression = (key) => {
          const data = isString(key) && (vm == null ? void 0 : vm[key]) || key;
          if (data)
            return vue.ref(data);
          else
            return data;
        };
        const getProp = (name) => resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${hyphenate(name)}`));
        const fullscreen = (_a2 = getBindingProp("fullscreen")) != null ? _a2 : binding.modifiers.fullscreen;
        const options = {
          text: getProp("text"),
          svg: getProp("svg"),
          svgViewBox: getProp("svgViewBox"),
          spinner: getProp("spinner"),
          background: getProp("background"),
          customClass: getProp("customClass"),
          fullscreen,
          target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
          body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
          lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
        };
        el[INSTANCE_KEY] = {
          options,
          instance: Loading(options)
        };
      };
      const updateOptions = (newOptions, originalOptions) => {
        for (const key of Object.keys(originalOptions)) {
          if (vue.isRef(originalOptions[key]))
            originalOptions[key].value = newOptions[key];
        }
      };
      const vLoading = {
        mounted(el, binding) {
          if (binding.value) {
            createInstance(el, binding);
          }
        },
        updated(el, binding) {
          const instance = el[INSTANCE_KEY];
          if (binding.oldValue !== binding.value) {
            if (binding.value && !binding.oldValue) {
              createInstance(el, binding);
            } else if (binding.value && binding.oldValue) {
              if (isObject$1(binding.value))
                updateOptions(binding.value, instance.options);
            } else {
              instance == null ? void 0 : instance.instance.close();
            }
          }
        },
        unmounted(el) {
          var _a2;
          (_a2 = el[INSTANCE_KEY]) == null ? void 0 : _a2.instance.close();
          el[INSTANCE_KEY] = null;
        }
      };
      const _sfc_main$f = vue.defineComponent({
        name: "ElMessageBox",
        directives: {
          TrapFocus
        },
        components: {
          ElButton,
          ElFocusTrap,
          ElInput,
          ElOverlay,
          ElIcon,
          ...TypeComponents
        },
        inheritAttrs: false,
        props: {
          buttonSize: {
            type: String,
            validator: isValidComponentSize
          },
          modal: {
            type: Boolean,
            default: true
          },
          lockScroll: {
            type: Boolean,
            default: true
          },
          showClose: {
            type: Boolean,
            default: true
          },
          closeOnClickModal: {
            type: Boolean,
            default: true
          },
          closeOnPressEscape: {
            type: Boolean,
            default: true
          },
          closeOnHashChange: {
            type: Boolean,
            default: true
          },
          center: Boolean,
          draggable: Boolean,
          overflow: Boolean,
          roundButton: {
            default: false,
            type: Boolean
          },
          container: {
            type: String,
            default: "body"
          },
          boxType: {
            type: String,
            default: ""
          }
        },
        emits: ["vanish", "action"],
        setup(props, { emit }) {
          const {
            locale,
            zIndex: zIndex2,
            ns,
            size: btnSize
          } = useGlobalComponentSettings("message-box", vue.computed(() => props.buttonSize));
          const { t } = locale;
          const { nextZIndex } = zIndex2;
          const visible = vue.ref(false);
          const state = vue.reactive({
            autofocus: true,
            beforeClose: null,
            callback: null,
            cancelButtonText: "",
            cancelButtonClass: "",
            confirmButtonText: "",
            confirmButtonClass: "",
            customClass: "",
            customStyle: {},
            dangerouslyUseHTMLString: false,
            distinguishCancelAndClose: false,
            icon: "",
            inputPattern: null,
            inputPlaceholder: "",
            inputType: "text",
            inputValue: null,
            inputValidator: null,
            inputErrorMessage: "",
            message: null,
            modalFade: true,
            modalClass: "",
            showCancelButton: false,
            showConfirmButton: true,
            type: "",
            title: void 0,
            showInput: false,
            action: "",
            confirmButtonLoading: false,
            cancelButtonLoading: false,
            confirmButtonLoadingIcon: vue.markRaw(loading_default),
            cancelButtonLoadingIcon: vue.markRaw(loading_default),
            confirmButtonDisabled: false,
            editorErrorMessage: "",
            validateError: false,
            zIndex: nextZIndex()
          });
          const typeClass = vue.computed(() => {
            const type = state.type;
            return { [ns.bm("icon", type)]: type && TypeComponentsMap[type] };
          });
          const contentId = useId();
          const inputId = useId();
          const iconComponent = vue.computed(() => state.icon || TypeComponentsMap[state.type] || "");
          const hasMessage = vue.computed(() => !!state.message);
          const rootRef = vue.ref();
          const headerRef = vue.ref();
          const focusStartRef = vue.ref();
          const inputRef = vue.ref();
          const confirmRef = vue.ref();
          const confirmButtonClasses = vue.computed(() => state.confirmButtonClass);
          vue.watch(() => state.inputValue, async (val) => {
            await vue.nextTick();
            if (props.boxType === "prompt" && val !== null) {
              validate();
            }
          }, { immediate: true });
          vue.watch(() => visible.value, (val) => {
            var _a2, _b;
            if (val) {
              if (props.boxType !== "prompt") {
                if (state.autofocus) {
                  focusStartRef.value = (_b = (_a2 = confirmRef.value) == null ? void 0 : _a2.$el) != null ? _b : rootRef.value;
                } else {
                  focusStartRef.value = rootRef.value;
                }
              }
              state.zIndex = nextZIndex();
            }
            if (props.boxType !== "prompt")
              return;
            if (val) {
              vue.nextTick().then(() => {
                var _a22;
                if (inputRef.value && inputRef.value.$el) {
                  if (state.autofocus) {
                    focusStartRef.value = (_a22 = getInputElement()) != null ? _a22 : rootRef.value;
                  } else {
                    focusStartRef.value = rootRef.value;
                  }
                }
              });
            } else {
              state.editorErrorMessage = "";
              state.validateError = false;
            }
          });
          const draggable2 = vue.computed(() => props.draggable);
          const overflow = vue.computed(() => props.overflow);
          useDraggable(rootRef, headerRef, draggable2, overflow);
          vue.onMounted(async () => {
            await vue.nextTick();
            if (props.closeOnHashChange) {
              window.addEventListener("hashchange", doClose);
            }
          });
          vue.onBeforeUnmount(() => {
            if (props.closeOnHashChange) {
              window.removeEventListener("hashchange", doClose);
            }
          });
          function doClose() {
            if (!visible.value)
              return;
            visible.value = false;
            vue.nextTick(() => {
              if (state.action)
                emit("action", state.action);
            });
          }
          const handleWrapperClick = () => {
            if (props.closeOnClickModal) {
              handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
            }
          };
          const overlayEvent = useSameTarget(handleWrapperClick);
          const handleInputEnter = (e) => {
            if (state.inputType !== "textarea") {
              e.preventDefault();
              return handleAction("confirm");
            }
          };
          const handleAction = (action) => {
            var _a2;
            if (props.boxType === "prompt" && action === "confirm" && !validate()) {
              return;
            }
            state.action = action;
            if (state.beforeClose) {
              (_a2 = state.beforeClose) == null ? void 0 : _a2.call(state, action, state, doClose);
            } else {
              doClose();
            }
          };
          const validate = () => {
            if (props.boxType === "prompt") {
              const inputPattern = state.inputPattern;
              if (inputPattern && !inputPattern.test(state.inputValue || "")) {
                state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
                state.validateError = true;
                return false;
              }
              const inputValidator = state.inputValidator;
              if (typeof inputValidator === "function") {
                const validateResult = inputValidator(state.inputValue);
                if (validateResult === false) {
                  state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
                  state.validateError = true;
                  return false;
                }
                if (typeof validateResult === "string") {
                  state.editorErrorMessage = validateResult;
                  state.validateError = true;
                  return false;
                }
              }
            }
            state.editorErrorMessage = "";
            state.validateError = false;
            return true;
          };
          const getInputElement = () => {
            const inputRefs = inputRef.value.$refs;
            return inputRefs.input || inputRefs.textarea;
          };
          const handleClose = () => {
            handleAction("close");
          };
          const onCloseRequested = () => {
            if (props.closeOnPressEscape) {
              handleClose();
            }
          };
          if (props.lockScroll) {
            useLockscreen(visible);
          }
          return {
            ...vue.toRefs(state),
            ns,
            overlayEvent,
            visible,
            hasMessage,
            typeClass,
            contentId,
            inputId,
            btnSize,
            iconComponent,
            confirmButtonClasses,
            rootRef,
            focusStartRef,
            headerRef,
            inputRef,
            confirmRef,
            doClose,
            handleClose,
            onCloseRequested,
            handleWrapperClick,
            handleInputEnter,
            handleAction,
            t
          };
        }
      });
      function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_icon = vue.resolveComponent("el-icon");
        const _component_close = vue.resolveComponent("close");
        const _component_el_input = vue.resolveComponent("el-input");
        const _component_el_button = vue.resolveComponent("el-button");
        const _component_el_focus_trap = vue.resolveComponent("el-focus-trap");
        const _component_el_overlay = vue.resolveComponent("el-overlay");
        return vue.openBlock(), vue.createBlock(vue.Transition, {
          name: "fade-in-linear",
          onAfterLeave: ($event) => _ctx.$emit("vanish"),
          persisted: ""
        }, {
          default: vue.withCtx(() => [
            vue.withDirectives(vue.createVNode(_component_el_overlay, {
              "z-index": _ctx.zIndex,
              "overlay-class": [_ctx.ns.is("message-box"), _ctx.modalClass],
              mask: _ctx.modal
            }, {
              default: vue.withCtx(() => [
                vue.createElementVNode("div", {
                  role: "dialog",
                  "aria-label": _ctx.title,
                  "aria-modal": "true",
                  "aria-describedby": !_ctx.showInput ? _ctx.contentId : void 0,
                  class: vue.normalizeClass(`${_ctx.ns.namespace.value}-overlay-message-box`),
                  onClick: _ctx.overlayEvent.onClick,
                  onMousedown: _ctx.overlayEvent.onMousedown,
                  onMouseup: _ctx.overlayEvent.onMouseup
                }, [
                  vue.createVNode(_component_el_focus_trap, {
                    loop: "",
                    trapped: _ctx.visible,
                    "focus-trap-el": _ctx.rootRef,
                    "focus-start-el": _ctx.focusStartRef,
                    onReleaseRequested: _ctx.onCloseRequested
                  }, {
                    default: vue.withCtx(() => [
                      vue.createElementVNode("div", {
                        ref: "rootRef",
                        class: vue.normalizeClass([
                          _ctx.ns.b(),
                          _ctx.customClass,
                          _ctx.ns.is("draggable", _ctx.draggable),
                          { [_ctx.ns.m("center")]: _ctx.center }
                        ]),
                        style: vue.normalizeStyle(_ctx.customStyle),
                        tabindex: "-1",
                        onClick: vue.withModifiers(() => {
                        }, ["stop"])
                      }, [
                        _ctx.title !== null && _ctx.title !== void 0 ? (vue.openBlock(), vue.createElementBlock("div", {
                          key: 0,
                          ref: "headerRef",
                          class: vue.normalizeClass([_ctx.ns.e("header"), { "show-close": _ctx.showClose }])
                        }, [
                          vue.createElementVNode("div", {
                            class: vue.normalizeClass(_ctx.ns.e("title"))
                          }, [
                            _ctx.iconComponent && _ctx.center ? (vue.openBlock(), vue.createBlock(_component_el_icon, {
                              key: 0,
                              class: vue.normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: vue.withCtx(() => [
                                (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : vue.createCommentVNode("v-if", true),
                            vue.createElementVNode("span", null, vue.toDisplayString(_ctx.title), 1)
                          ], 2),
                          _ctx.showClose ? (vue.openBlock(), vue.createElementBlock("button", {
                            key: 0,
                            type: "button",
                            class: vue.normalizeClass(_ctx.ns.e("headerbtn")),
                            "aria-label": _ctx.t("el.messagebox.close"),
                            onClick: ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"),
                            onKeydown: vue.withKeys(vue.withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"])
                          }, [
                            vue.createVNode(_component_el_icon, {
                              class: vue.normalizeClass(_ctx.ns.e("close"))
                            }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(_component_close)
                              ]),
                              _: 1
                            }, 8, ["class"])
                          ], 42, ["aria-label", "onClick", "onKeydown"])) : vue.createCommentVNode("v-if", true)
                        ], 2)) : vue.createCommentVNode("v-if", true),
                        vue.createElementVNode("div", {
                          id: _ctx.contentId,
                          class: vue.normalizeClass(_ctx.ns.e("content"))
                        }, [
                          vue.createElementVNode("div", {
                            class: vue.normalizeClass(_ctx.ns.e("container"))
                          }, [
                            _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? (vue.openBlock(), vue.createBlock(_component_el_icon, {
                              key: 0,
                              class: vue.normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: vue.withCtx(() => [
                                (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : vue.createCommentVNode("v-if", true),
                            _ctx.hasMessage ? (vue.openBlock(), vue.createElementBlock("div", {
                              key: 1,
                              class: vue.normalizeClass(_ctx.ns.e("message"))
                            }, [
                              vue.renderSlot(_ctx.$slots, "default", {}, () => [
                                !_ctx.dangerouslyUseHTMLString ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 0,
                                  for: _ctx.showInput ? _ctx.inputId : void 0
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.createTextVNode(vue.toDisplayString(!_ctx.dangerouslyUseHTMLString ? _ctx.message : ""), 1)
                                  ]),
                                  _: 1
                                }, 8, ["for"])) : (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 1,
                                  for: _ctx.showInput ? _ctx.inputId : void 0,
                                  innerHTML: _ctx.message
                                }, null, 8, ["for", "innerHTML"]))
                              ])
                            ], 2)) : vue.createCommentVNode("v-if", true)
                          ], 2),
                          vue.withDirectives(vue.createElementVNode("div", {
                            class: vue.normalizeClass(_ctx.ns.e("input"))
                          }, [
                            vue.createVNode(_component_el_input, {
                              id: _ctx.inputId,
                              ref: "inputRef",
                              modelValue: _ctx.inputValue,
                              "onUpdate:modelValue": ($event) => _ctx.inputValue = $event,
                              type: _ctx.inputType,
                              placeholder: _ctx.inputPlaceholder,
                              "aria-invalid": _ctx.validateError,
                              class: vue.normalizeClass({ invalid: _ctx.validateError }),
                              onKeydown: vue.withKeys(_ctx.handleInputEnter, ["enter"])
                            }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                            vue.createElementVNode("div", {
                              class: vue.normalizeClass(_ctx.ns.e("errormsg")),
                              style: vue.normalizeStyle({
                                visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                              })
                            }, vue.toDisplayString(_ctx.editorErrorMessage), 7)
                          ], 2), [
                            [vue.vShow, _ctx.showInput]
                          ])
                        ], 10, ["id"]),
                        vue.createElementVNode("div", {
                          class: vue.normalizeClass(_ctx.ns.e("btns"))
                        }, [
                          _ctx.showCancelButton ? (vue.openBlock(), vue.createBlock(_component_el_button, {
                            key: 0,
                            loading: _ctx.cancelButtonLoading,
                            "loading-icon": _ctx.cancelButtonLoadingIcon,
                            class: vue.normalizeClass([_ctx.cancelButtonClass]),
                            round: _ctx.roundButton,
                            size: _ctx.btnSize,
                            onClick: ($event) => _ctx.handleAction("cancel"),
                            onKeydown: vue.withKeys(vue.withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"])
                          }, {
                            default: vue.withCtx(() => [
                              vue.createTextVNode(vue.toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "loading-icon", "class", "round", "size", "onClick", "onKeydown"])) : vue.createCommentVNode("v-if", true),
                          vue.withDirectives(vue.createVNode(_component_el_button, {
                            ref: "confirmRef",
                            type: "primary",
                            loading: _ctx.confirmButtonLoading,
                            "loading-icon": _ctx.confirmButtonLoadingIcon,
                            class: vue.normalizeClass([_ctx.confirmButtonClasses]),
                            round: _ctx.roundButton,
                            disabled: _ctx.confirmButtonDisabled,
                            size: _ctx.btnSize,
                            onClick: ($event) => _ctx.handleAction("confirm"),
                            onKeydown: vue.withKeys(vue.withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"])
                          }, {
                            default: vue.withCtx(() => [
                              vue.createTextVNode(vue.toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "loading-icon", "class", "round", "disabled", "size", "onClick", "onKeydown"]), [
                            [vue.vShow, _ctx.showConfirmButton]
                          ])
                        ], 2)
                      ], 14, ["onClick"])
                    ]),
                    _: 3
                  }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
                ], 42, ["aria-label", "aria-describedby", "onClick", "onMousedown", "onMouseup"])
              ]),
              _: 3
            }, 8, ["z-index", "overlay-class", "mask"]), [
              [vue.vShow, _ctx.visible]
            ])
          ]),
          _: 3
        }, 8, ["onAfterLeave"]);
      }
      var MessageBoxConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render], ["__file", "index.vue"]]);
      const messageInstance = /* @__PURE__ */ new Map();
      const getAppendToElement = (props) => {
        let appendTo = document.body;
        if (props.appendTo) {
          if (isString(props.appendTo)) {
            appendTo = document.querySelector(props.appendTo);
          }
          if (isElement(props.appendTo)) {
            appendTo = props.appendTo;
          }
          if (!isElement(appendTo)) {
            debugWarn("ElMessageBox", "the appendTo option is not an HTMLElement. Falling back to document.body.");
            appendTo = document.body;
          }
        }
        return appendTo;
      };
      const initInstance = (props, container, appContext = null) => {
        const vnode = vue.createVNode(MessageBoxConstructor, props, isFunction$1(props.message) || vue.isVNode(props.message) ? {
          default: isFunction$1(props.message) ? props.message : () => props.message
        } : null);
        vnode.appContext = appContext;
        vue.render(vnode, container);
        getAppendToElement(props).appendChild(container.firstElementChild);
        return vnode.component;
      };
      const genContainer = () => {
        return document.createElement("div");
      };
      const showMessage = (options, appContext) => {
        const container = genContainer();
        options.onVanish = () => {
          vue.render(null, container);
          messageInstance.delete(vm);
        };
        options.onAction = (action) => {
          const currentMsg = messageInstance.get(vm);
          let resolve;
          if (options.showInput) {
            resolve = { value: vm.inputValue, action };
          } else {
            resolve = action;
          }
          if (options.callback) {
            options.callback(resolve, instance.proxy);
          } else {
            if (action === "cancel" || action === "close") {
              if (options.distinguishCancelAndClose && action !== "cancel") {
                currentMsg.reject("close");
              } else {
                currentMsg.reject("cancel");
              }
            } else {
              currentMsg.resolve(resolve);
            }
          }
        };
        const instance = initInstance(options, container, appContext);
        const vm = instance.proxy;
        for (const prop in options) {
          if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {
            vm[prop] = options[prop];
          }
        }
        vm.visible = true;
        return vm;
      };
      function MessageBox(options, appContext = null) {
        if (!isClient)
          return Promise.reject();
        let callback;
        if (isString(options) || vue.isVNode(options)) {
          options = {
            message: options
          };
        } else {
          callback = options.callback;
        }
        return new Promise((resolve, reject2) => {
          const vm = showMessage(options, appContext != null ? appContext : MessageBox._context);
          messageInstance.set(vm, {
            options,
            callback,
            resolve,
            reject: reject2
          });
        });
      }
      const MESSAGE_BOX_VARIANTS = ["alert", "confirm", "prompt"];
      const MESSAGE_BOX_DEFAULT_OPTS = {
        alert: { closeOnPressEscape: false, closeOnClickModal: false },
        confirm: { showCancelButton: true },
        prompt: { showCancelButton: true, showInput: true }
      };
      MESSAGE_BOX_VARIANTS.forEach((boxType) => {
        MessageBox[boxType] = messageBoxFactory(boxType);
      });
      function messageBoxFactory(boxType) {
        return (message, title, options, appContext) => {
          let titleOrOpts = "";
          if (isObject$1(title)) {
            options = title;
            titleOrOpts = "";
          } else if (isUndefined(title)) {
            titleOrOpts = "";
          } else {
            titleOrOpts = title;
          }
          return MessageBox(Object.assign({
            title: titleOrOpts,
            message,
            type: "",
            ...MESSAGE_BOX_DEFAULT_OPTS[boxType]
          }, options, {
            boxType
          }), appContext);
        };
      }
      MessageBox.close = () => {
        messageInstance.forEach((_2, vm) => {
          vm.doClose();
        });
        messageInstance.clear();
      };
      MessageBox._context = null;
      const _MessageBox = MessageBox;
      _MessageBox.install = (app2) => {
        _MessageBox._context = app2._context;
        app2.config.globalProperties.$msgbox = _MessageBox;
        app2.config.globalProperties.$messageBox = _MessageBox;
        app2.config.globalProperties.$alert = _MessageBox.alert;
        app2.config.globalProperties.$confirm = _MessageBox.confirm;
        app2.config.globalProperties.$prompt = _MessageBox.prompt;
      };
      const ElMessageBox = _MessageBox;
      const notificationTypes = [
        "success",
        "info",
        "warning",
        "error"
      ];
      const notificationProps = buildProps({
        customClass: {
          type: String,
          default: ""
        },
        dangerouslyUseHTMLString: Boolean,
        duration: {
          type: Number,
          default: 4500
        },
        icon: {
          type: iconPropType
        },
        id: {
          type: String,
          default: ""
        },
        message: {
          type: definePropType([String, Object]),
          default: ""
        },
        offset: {
          type: Number,
          default: 0
        },
        onClick: {
          type: definePropType(Function),
          default: () => void 0
        },
        onClose: {
          type: definePropType(Function),
          required: true
        },
        position: {
          type: String,
          values: ["top-right", "top-left", "bottom-right", "bottom-left"],
          default: "top-right"
        },
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          values: [...notificationTypes, ""],
          default: ""
        },
        zIndex: Number
      });
      const notificationEmits = {
        destroy: () => true
      };
      const __default__ = vue.defineComponent({
        name: "ElNotification"
      });
      const _sfc_main$e = /* @__PURE__ */ vue.defineComponent({
        ...__default__,
        props: notificationProps,
        emits: notificationEmits,
        setup(__props, { expose }) {
          const props = __props;
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("notification");
          const { nextZIndex, currentZIndex } = zIndex2;
          const { Close } = CloseComponents;
          const visible = vue.ref(false);
          let timer = void 0;
          const typeClass = vue.computed(() => {
            const type = props.type;
            return type && TypeComponentsMap[props.type] ? ns.m(type) : "";
          });
          const iconComponent = vue.computed(() => {
            if (!props.type)
              return props.icon;
            return TypeComponentsMap[props.type] || props.icon;
          });
          const horizontalClass = vue.computed(() => props.position.endsWith("right") ? "right" : "left");
          const verticalProperty = vue.computed(() => props.position.startsWith("top") ? "top" : "bottom");
          const positionStyle = vue.computed(() => {
            var _a2;
            return {
              [verticalProperty.value]: `${props.offset}px`,
              zIndex: (_a2 = props.zIndex) != null ? _a2 : currentZIndex.value
            };
          });
          function startTimer() {
            if (props.duration > 0) {
              ({ stop: timer } = useTimeoutFn(() => {
                if (visible.value)
                  close2();
              }, props.duration));
            }
          }
          function clearTimer() {
            timer == null ? void 0 : timer();
          }
          function close2() {
            visible.value = false;
          }
          function onKeydown({ code }) {
            if (code === EVENT_CODE.delete || code === EVENT_CODE.backspace) {
              clearTimer();
            } else if (code === EVENT_CODE.esc) {
              if (visible.value) {
                close2();
              }
            } else {
              startTimer();
            }
          }
          vue.onMounted(() => {
            startTimer();
            nextZIndex();
            visible.value = true;
          });
          useEventListener(document, "keydown", onKeydown);
          expose({
            visible,
            close: close2
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.Transition, {
              name: vue.unref(ns).b("fade"),
              onBeforeLeave: _ctx.onClose,
              onAfterLeave: ($event) => _ctx.$emit("destroy"),
              persisted: ""
            }, {
              default: vue.withCtx(() => [
                vue.withDirectives(vue.createElementVNode("div", {
                  id: _ctx.id,
                  class: vue.normalizeClass([vue.unref(ns).b(), _ctx.customClass, vue.unref(horizontalClass)]),
                  style: vue.normalizeStyle(vue.unref(positionStyle)),
                  role: "alert",
                  onMouseenter: clearTimer,
                  onMouseleave: startTimer,
                  onClick: _ctx.onClick
                }, [
                  vue.unref(iconComponent) ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                    key: 0,
                    class: vue.normalizeClass([vue.unref(ns).e("icon"), vue.unref(typeClass)])
                  }, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass(vue.unref(ns).e("group"))
                  }, [
                    vue.createElementVNode("h2", {
                      class: vue.normalizeClass(vue.unref(ns).e("title")),
                      textContent: vue.toDisplayString(_ctx.title)
                    }, null, 10, ["textContent"]),
                    vue.withDirectives(vue.createElementVNode("div", {
                      class: vue.normalizeClass(vue.unref(ns).e("content")),
                      style: vue.normalizeStyle(!!_ctx.title ? void 0 : { margin: 0 })
                    }, [
                      vue.renderSlot(_ctx.$slots, "default", {}, () => [
                        !_ctx.dangerouslyUseHTMLString ? (vue.openBlock(), vue.createElementBlock("p", { key: 0 }, vue.toDisplayString(_ctx.message), 1)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                          vue.createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                          vue.createElementVNode("p", { innerHTML: _ctx.message }, null, 8, ["innerHTML"])
                        ], 2112))
                      ])
                    ], 6), [
                      [vue.vShow, _ctx.message]
                    ]),
                    _ctx.showClose ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                      key: 0,
                      class: vue.normalizeClass(vue.unref(ns).e("closeBtn")),
                      onClick: vue.withModifiers(close2, ["stop"])
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(Close))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : vue.createCommentVNode("v-if", true)
                  ], 2)
                ], 46, ["id", "onClick"]), [
                  [vue.vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name", "onBeforeLeave", "onAfterLeave"]);
          };
        }
      });
      var NotificationConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__file", "notification.vue"]]);
      const notifications = {
        "top-left": [],
        "top-right": [],
        "bottom-left": [],
        "bottom-right": []
      };
      const GAP_SIZE = 16;
      let seed = 1;
      const notify = function(options = {}, context = null) {
        if (!isClient)
          return { close: () => void 0 };
        if (typeof options === "string" || vue.isVNode(options)) {
          options = { message: options };
        }
        const position = options.position || "top-right";
        let verticalOffset = options.offset || 0;
        notifications[position].forEach(({ vm: vm2 }) => {
          var _a2;
          verticalOffset += (((_a2 = vm2.el) == null ? void 0 : _a2.offsetHeight) || 0) + GAP_SIZE;
        });
        verticalOffset += GAP_SIZE;
        const id = `notification_${seed++}`;
        const userOnClose = options.onClose;
        const props = {
          ...options,
          offset: verticalOffset,
          id,
          onClose: () => {
            close(id, position, userOnClose);
          }
        };
        let appendTo = document.body;
        if (isElement(options.appendTo)) {
          appendTo = options.appendTo;
        } else if (isString(options.appendTo)) {
          appendTo = document.querySelector(options.appendTo);
        }
        if (!isElement(appendTo)) {
          debugWarn("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body.");
          appendTo = document.body;
        }
        const container = document.createElement("div");
        const vm = vue.createVNode(NotificationConstructor, props, vue.isVNode(props.message) ? {
          default: () => props.message
        } : null);
        vm.appContext = context != null ? context : notify._context;
        vm.props.onDestroy = () => {
          vue.render(null, container);
        };
        vue.render(vm, container);
        notifications[position].push({ vm });
        appendTo.appendChild(container.firstElementChild);
        return {
          close: () => {
            vm.component.exposed.visible.value = false;
          }
        };
      };
      notificationTypes.forEach((type) => {
        notify[type] = (options = {}) => {
          if (typeof options === "string" || vue.isVNode(options)) {
            options = {
              message: options
            };
          }
          return notify({
            ...options,
            type
          });
        };
      });
      function close(id, position, userOnClose) {
        const orientedNotifications = notifications[position];
        const idx = orientedNotifications.findIndex(({ vm: vm2 }) => {
          var _a2;
          return ((_a2 = vm2.component) == null ? void 0 : _a2.props.id) === id;
        });
        if (idx === -1)
          return;
        const { vm } = orientedNotifications[idx];
        if (!vm)
          return;
        userOnClose == null ? void 0 : userOnClose(vm);
        const removedHeight = vm.el.offsetHeight;
        const verticalPos = position.split("-")[0];
        orientedNotifications.splice(idx, 1);
        const len = orientedNotifications.length;
        if (len < 1)
          return;
        for (let i = idx; i < len; i++) {
          const { el, component } = orientedNotifications[i].vm;
          const pos = Number.parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;
          component.props.offset = pos;
        }
      }
      function closeAll() {
        for (const orientedNotifications of Object.values(notifications)) {
          orientedNotifications.forEach(({ vm }) => {
            vm.component.exposed.visible.value = false;
          });
        }
      }
      notify.closeAll = closeAll;
      notify._context = null;
      const ElNotification = withInstallFunction(notify, "$notify");
      const _hoisted_1$8 = {
        viewBox: "0 0 1024 1024",
        width: "1.2em",
        height: "1.2em"
      };
      function render(_ctx, _cache) {
        return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$8, _cache[0] || (_cache[0] = [
          vue.createElementVNode("path", {
            fill: "currentColor",
            d: "M544 864V672h128L512 480L352 672h128v192H320v-1.6c-5.376.32-10.496 1.6-16 1.6A240 240 0 0 1 64 624c0-123.136 93.12-223.488 212.608-237.248A239.81 239.81 0 0 1 512 192a239.87 239.87 0 0 1 235.456 194.752c119.488 13.76 212.48 114.112 212.48 237.248a240 240 0 0 1-240 240c-5.376 0-10.56-1.28-16-1.6v1.6z"
          }, null, -1)
        ]));
      }
      const __unplugin_components_4 = vue.markRaw({ name: "ep-upload-filled", render });
      /*!
       * Compressor.js v1.2.1
       * https://fengyuanchen.github.io/compressorjs
       *
       * Copyright 2018-present Chen Fengyuan
       * Released under the MIT license
       *
       * Date: 2023-02-28T14:09:41.732Z
       */
      function ownKeys(object2, enumerableOnly) {
        var keys2 = Object.keys(object2);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object2);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
          })), keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = null != arguments[i] ? arguments[i] : {};
          i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
        return target;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      function _defineProperty(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _toPrimitive(input, hint) {
        if (typeof input !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (typeof res !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return typeof key === "symbol" ? key : String(key);
      }
      var canvasToBlob = { exports: {} };
      (function(module2) {
        if (typeof window === "undefined") {
          return;
        }
        (function(window2) {
          var CanvasPrototype = window2.HTMLCanvasElement && window2.HTMLCanvasElement.prototype;
          var hasBlobConstructor = window2.Blob && function() {
            try {
              return Boolean(new Blob());
            } catch (e) {
              return false;
            }
          }();
          var hasArrayBufferViewSupport = hasBlobConstructor && window2.Uint8Array && function() {
            try {
              return new Blob([new Uint8Array(100)]).size === 100;
            } catch (e) {
              return false;
            }
          }();
          var BlobBuilder = window2.BlobBuilder || window2.WebKitBlobBuilder || window2.MozBlobBuilder || window2.MSBlobBuilder;
          var dataURIPattern = /^data:((.*?)(;charset=.*?)?)(;base64)?,/;
          var dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window2.atob && window2.ArrayBuffer && window2.Uint8Array && function(dataURI) {
            var matches, mediaType, isBase64, dataString, byteString, arrayBuffer, intArray, i, bb;
            matches = dataURI.match(dataURIPattern);
            if (!matches) {
              throw new Error("invalid data URI");
            }
            mediaType = matches[2] ? matches[1] : "text/plain" + (matches[3] || ";charset=US-ASCII");
            isBase64 = !!matches[4];
            dataString = dataURI.slice(matches[0].length);
            if (isBase64) {
              byteString = atob(dataString);
            } else {
              byteString = decodeURIComponent(dataString);
            }
            arrayBuffer = new ArrayBuffer(byteString.length);
            intArray = new Uint8Array(arrayBuffer);
            for (i = 0; i < byteString.length; i += 1) {
              intArray[i] = byteString.charCodeAt(i);
            }
            if (hasBlobConstructor) {
              return new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], {
                type: mediaType
              });
            }
            bb = new BlobBuilder();
            bb.append(arrayBuffer);
            return bb.getBlob(mediaType);
          };
          if (window2.HTMLCanvasElement && !CanvasPrototype.toBlob) {
            if (CanvasPrototype.mozGetAsFile) {
              CanvasPrototype.toBlob = function(callback, type, quality) {
                var self2 = this;
                setTimeout(function() {
                  if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
                    callback(dataURLtoBlob(self2.toDataURL(type, quality)));
                  } else {
                    callback(self2.mozGetAsFile("blob", type));
                  }
                });
              };
            } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
              if (CanvasPrototype.msToBlob) {
                CanvasPrototype.toBlob = function(callback, type, quality) {
                  var self2 = this;
                  setTimeout(function() {
                    if ((type && type !== "image/png" || quality) && CanvasPrototype.toDataURL && dataURLtoBlob) {
                      callback(dataURLtoBlob(self2.toDataURL(type, quality)));
                    } else {
                      callback(self2.msToBlob(type));
                    }
                  });
                };
              } else {
                CanvasPrototype.toBlob = function(callback, type, quality) {
                  var self2 = this;
                  setTimeout(function() {
                    callback(dataURLtoBlob(self2.toDataURL(type, quality)));
                  });
                };
              }
            }
          }
          if (module2.exports) {
            module2.exports = dataURLtoBlob;
          } else {
            window2.dataURLtoBlob = dataURLtoBlob;
          }
        })(window);
      })(canvasToBlob);
      var toBlob = canvasToBlob.exports;
      var isBlob = function isBlob2(value) {
        if (typeof Blob === "undefined") {
          return false;
        }
        return value instanceof Blob || Object.prototype.toString.call(value) === "[object Blob]";
      };
      var DEFAULTS = {
        /**
         * Indicates if output the original image instead of the compressed one
         * when the size of the compressed image is greater than the original one's
         * @type {boolean}
         */
        strict: true,
        /**
         * Indicates if read the image's Exif Orientation information,
         * and then rotate or flip the image automatically.
         * @type {boolean}
         */
        checkOrientation: true,
        /**
         * Indicates if retain the image's Exif information after compressed.
         * @type {boolean}
        */
        retainExif: false,
        /**
         * The max width of the output image.
         * @type {number}
         */
        maxWidth: Infinity,
        /**
         * The max height of the output image.
         * @type {number}
         */
        maxHeight: Infinity,
        /**
         * The min width of the output image.
         * @type {number}
         */
        minWidth: 0,
        /**
         * The min height of the output image.
         * @type {number}
         */
        minHeight: 0,
        /**
         * The width of the output image.
         * If not specified, the natural width of the source image will be used.
         * @type {number}
         */
        width: void 0,
        /**
         * The height of the output image.
         * If not specified, the natural height of the source image will be used.
         * @type {number}
         */
        height: void 0,
        /**
         * Sets how the size of the image should be resized to the container
         * specified by the `width` and `height` options.
         * @type {string}
         */
        resize: "none",
        /**
         * The quality of the output image.
         * It must be a number between `0` and `1`,
         * and only available for `image/jpeg` and `image/webp` images.
         * Check out {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob canvas.toBlob}.
         * @type {number}
         */
        quality: 0.8,
        /**
         * The mime type of the output image.
         * By default, the original mime type of the source image file will be used.
         * @type {string}
         */
        mimeType: "auto",
        /**
         * Files whose file type is included in this list,
         * and whose file size exceeds the `convertSize` value will be converted to JPEGs.
         * @type {string｜Array}
         */
        convertTypes: ["image/png"],
        /**
         * PNG files over this size (5 MB by default) will be converted to JPEGs.
         * To disable this, just set the value to `Infinity`.
         * @type {number}
         */
        convertSize: 5e6,
        /**
         * The hook function to execute before draw the image into the canvas for compression.
         * @type {Function}
         * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.
         * @param {HTMLCanvasElement} canvas - The canvas for compression.
         * @example
         * function (context, canvas) {
         *   context.fillStyle = '#fff';
         * }
         */
        beforeDraw: null,
        /**
         * The hook function to execute after drew the image into the canvas for compression.
         * @type {Function}
         * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.
         * @param {HTMLCanvasElement} canvas - The canvas for compression.
         * @example
         * function (context, canvas) {
         *   context.filter = 'grayscale(100%)';
         * }
         */
        drew: null,
        /**
         * The hook function to execute when success to compress the image.
         * @type {Function}
         * @param {File} file - The compressed image File object.
         * @example
         * function (file) {
         *   console.log(file);
         * }
         */
        success: null,
        /**
         * The hook function to execute when fail to compress the image.
         * @type {Function}
         * @param {Error} err - An Error object.
         * @example
         * function (err) {
         *   console.log(err.message);
         * }
         */
        error: null
      };
      var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined";
      var WINDOW = IS_BROWSER ? window : {};
      var isPositiveNumber = function isPositiveNumber2(value) {
        return value > 0 && value < Infinity;
      };
      var slice = Array.prototype.slice;
      function toArray(value) {
        return Array.from ? Array.from(value) : slice.call(value);
      }
      var REGEXP_IMAGE_TYPE = /^image\/.+$/;
      function isImageType(value) {
        return REGEXP_IMAGE_TYPE.test(value);
      }
      function imageTypeToExtension(value) {
        var extension = isImageType(value) ? value.substr(6) : "";
        if (extension === "jpeg") {
          extension = "jpg";
        }
        return ".".concat(extension);
      }
      var fromCharCode = String.fromCharCode;
      function getStringFromCharCode(dataView, start, length) {
        var str = "";
        var i;
        length += start;
        for (i = start; i < length; i += 1) {
          str += fromCharCode(dataView.getUint8(i));
        }
        return str;
      }
      var btoa = WINDOW.btoa;
      function arrayBufferToDataURL(arrayBuffer, mimeType) {
        var chunks = [];
        var chunkSize = 8192;
        var uint8 = new Uint8Array(arrayBuffer);
        while (uint8.length > 0) {
          chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
          uint8 = uint8.subarray(chunkSize);
        }
        return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join("")));
      }
      function resetAndGetOrientation(arrayBuffer) {
        var dataView = new DataView(arrayBuffer);
        var orientation;
        try {
          var littleEndian;
          var app1Start;
          var ifdStart;
          if (dataView.getUint8(0) === 255 && dataView.getUint8(1) === 216) {
            var length = dataView.byteLength;
            var offset = 2;
            while (offset + 1 < length) {
              if (dataView.getUint8(offset) === 255 && dataView.getUint8(offset + 1) === 225) {
                app1Start = offset;
                break;
              }
              offset += 1;
            }
          }
          if (app1Start) {
            var exifIDCode = app1Start + 4;
            var tiffOffset = app1Start + 10;
            if (getStringFromCharCode(dataView, exifIDCode, 4) === "Exif") {
              var endianness = dataView.getUint16(tiffOffset);
              littleEndian = endianness === 18761;
              if (littleEndian || endianness === 19789) {
                if (dataView.getUint16(tiffOffset + 2, littleEndian) === 42) {
                  var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
                  if (firstIFDOffset >= 8) {
                    ifdStart = tiffOffset + firstIFDOffset;
                  }
                }
              }
            }
          }
          if (ifdStart) {
            var _length = dataView.getUint16(ifdStart, littleEndian);
            var _offset;
            var i;
            for (i = 0; i < _length; i += 1) {
              _offset = ifdStart + i * 12 + 2;
              if (dataView.getUint16(_offset, littleEndian) === 274) {
                _offset += 8;
                orientation = dataView.getUint16(_offset, littleEndian);
                dataView.setUint16(_offset, 1, littleEndian);
                break;
              }
            }
          }
        } catch (e) {
          orientation = 1;
        }
        return orientation;
      }
      function parseOrientation(orientation) {
        var rotate = 0;
        var scaleX = 1;
        var scaleY = 1;
        switch (orientation) {
          case 2:
            scaleX = -1;
            break;
          case 3:
            rotate = -180;
            break;
          case 4:
            scaleY = -1;
            break;
          case 5:
            rotate = 90;
            scaleY = -1;
            break;
          case 6:
            rotate = 90;
            break;
          case 7:
            rotate = 90;
            scaleX = -1;
            break;
          case 8:
            rotate = -90;
            break;
        }
        return {
          rotate,
          scaleX,
          scaleY
        };
      }
      var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
      function normalizeDecimalNumber(value) {
        var times2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11;
        return REGEXP_DECIMALS.test(value) ? Math.round(value * times2) / times2 : value;
      }
      function getAdjustedSizes(_ref) {
        var aspectRatio = _ref.aspectRatio, height = _ref.height, width = _ref.width;
        var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
        var isValidWidth = isPositiveNumber(width);
        var isValidHeight = isPositiveNumber(height);
        if (isValidWidth && isValidHeight) {
          var adjustedWidth = height * aspectRatio;
          if ((type === "contain" || type === "none") && adjustedWidth > width || type === "cover" && adjustedWidth < width) {
            height = width / aspectRatio;
          } else {
            width = height * aspectRatio;
          }
        } else if (isValidWidth) {
          height = width / aspectRatio;
        } else if (isValidHeight) {
          width = height * aspectRatio;
        }
        return {
          width,
          height
        };
      }
      function getExif(arrayBuffer) {
        var array = toArray(new Uint8Array(arrayBuffer));
        var length = array.length;
        var segments = [];
        var start = 0;
        while (start + 3 < length) {
          var value = array[start];
          var next = array[start + 1];
          if (value === 255 && next === 218) {
            break;
          }
          if (value === 255 && next === 216) {
            start += 2;
          } else {
            var offset = array[start + 2] * 256 + array[start + 3];
            var end = start + offset + 2;
            var segment = array.slice(start, end);
            segments.push(segment);
            start = end;
          }
        }
        return segments.reduce(function(exifArray, current) {
          if (current[0] === 255 && current[1] === 225) {
            return exifArray.concat(current);
          }
          return exifArray;
        }, []);
      }
      function insertExif(arrayBuffer, exifArray) {
        var array = toArray(new Uint8Array(arrayBuffer));
        if (array[2] !== 255 || array[3] !== 224) {
          return arrayBuffer;
        }
        var app0Length = array[4] * 256 + array[5];
        var newArrayBuffer = [255, 216].concat(exifArray, array.slice(4 + app0Length));
        return new Uint8Array(newArrayBuffer);
      }
      var ArrayBuffer$1 = WINDOW.ArrayBuffer, FileReader$1 = WINDOW.FileReader;
      var URL$1 = WINDOW.URL || WINDOW.webkitURL;
      var REGEXP_EXTENSION = /\.\w+$/;
      var AnotherCompressor = WINDOW.Compressor;
      var Compressor = /* @__PURE__ */ function() {
        function Compressor2(file, options) {
          _classCallCheck(this, Compressor2);
          this.file = file;
          this.exif = [];
          this.image = new Image();
          this.options = _objectSpread2(_objectSpread2({}, DEFAULTS), options);
          this.aborted = false;
          this.result = null;
          this.init();
        }
        _createClass(Compressor2, [{
          key: "init",
          value: function init() {
            var _this = this;
            var file = this.file, options = this.options;
            if (!isBlob(file)) {
              this.fail(new Error("The first argument must be a File or Blob object."));
              return;
            }
            var mimeType = file.type;
            if (!isImageType(mimeType)) {
              this.fail(new Error("The first argument must be an image File or Blob object."));
              return;
            }
            if (!URL$1 || !FileReader$1) {
              this.fail(new Error("The current browser does not support image compression."));
              return;
            }
            if (!ArrayBuffer$1) {
              options.checkOrientation = false;
              options.retainExif = false;
            }
            var isJPEGImage = mimeType === "image/jpeg";
            var checkOrientation = isJPEGImage && options.checkOrientation;
            var retainExif = isJPEGImage && options.retainExif;
            if (URL$1 && !checkOrientation && !retainExif) {
              this.load({
                url: URL$1.createObjectURL(file)
              });
            } else {
              var reader = new FileReader$1();
              this.reader = reader;
              reader.onload = function(_ref) {
                var target = _ref.target;
                var result2 = target.result;
                var data = {};
                var orientation = 1;
                if (checkOrientation) {
                  orientation = resetAndGetOrientation(result2);
                  if (orientation > 1) {
                    _extends(data, parseOrientation(orientation));
                  }
                }
                if (retainExif) {
                  _this.exif = getExif(result2);
                }
                if (checkOrientation || retainExif) {
                  if (!URL$1 || orientation > 1) {
                    data.url = arrayBufferToDataURL(result2, mimeType);
                  } else {
                    data.url = URL$1.createObjectURL(file);
                  }
                } else {
                  data.url = result2;
                }
                _this.load(data);
              };
              reader.onabort = function() {
                _this.fail(new Error("Aborted to read the image with FileReader."));
              };
              reader.onerror = function() {
                _this.fail(new Error("Failed to read the image with FileReader."));
              };
              reader.onloadend = function() {
                _this.reader = null;
              };
              if (checkOrientation || retainExif) {
                reader.readAsArrayBuffer(file);
              } else {
                reader.readAsDataURL(file);
              }
            }
          }
        }, {
          key: "load",
          value: function load(data) {
            var _this2 = this;
            var file = this.file, image = this.image;
            image.onload = function() {
              _this2.draw(_objectSpread2(_objectSpread2({}, data), {}, {
                naturalWidth: image.naturalWidth,
                naturalHeight: image.naturalHeight
              }));
            };
            image.onabort = function() {
              _this2.fail(new Error("Aborted to load the image."));
            };
            image.onerror = function() {
              _this2.fail(new Error("Failed to load the image."));
            };
            if (WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent)) {
              image.crossOrigin = "anonymous";
            }
            image.alt = file.name;
            image.src = data.url;
          }
        }, {
          key: "draw",
          value: function draw(_ref2) {
            var _this3 = this;
            var naturalWidth = _ref2.naturalWidth, naturalHeight = _ref2.naturalHeight, _ref2$rotate = _ref2.rotate, rotate = _ref2$rotate === void 0 ? 0 : _ref2$rotate, _ref2$scaleX = _ref2.scaleX, scaleX = _ref2$scaleX === void 0 ? 1 : _ref2$scaleX, _ref2$scaleY = _ref2.scaleY, scaleY = _ref2$scaleY === void 0 ? 1 : _ref2$scaleY;
            var file = this.file, image = this.image, options = this.options;
            var canvas = document.createElement("canvas");
            var context = canvas.getContext("2d");
            var is90DegreesRotated = Math.abs(rotate) % 180 === 90;
            var resizable = (options.resize === "contain" || options.resize === "cover") && isPositiveNumber(options.width) && isPositiveNumber(options.height);
            var maxWidth = Math.max(options.maxWidth, 0) || Infinity;
            var maxHeight = Math.max(options.maxHeight, 0) || Infinity;
            var minWidth = Math.max(options.minWidth, 0) || 0;
            var minHeight = Math.max(options.minHeight, 0) || 0;
            var aspectRatio = naturalWidth / naturalHeight;
            var width = options.width, height = options.height;
            if (is90DegreesRotated) {
              var _ref3 = [maxHeight, maxWidth];
              maxWidth = _ref3[0];
              maxHeight = _ref3[1];
              var _ref4 = [minHeight, minWidth];
              minWidth = _ref4[0];
              minHeight = _ref4[1];
              var _ref5 = [height, width];
              width = _ref5[0];
              height = _ref5[1];
            }
            if (resizable) {
              aspectRatio = width / height;
            }
            var _getAdjustedSizes = getAdjustedSizes({
              aspectRatio,
              width: maxWidth,
              height: maxHeight
            }, "contain");
            maxWidth = _getAdjustedSizes.width;
            maxHeight = _getAdjustedSizes.height;
            var _getAdjustedSizes2 = getAdjustedSizes({
              aspectRatio,
              width: minWidth,
              height: minHeight
            }, "cover");
            minWidth = _getAdjustedSizes2.width;
            minHeight = _getAdjustedSizes2.height;
            if (resizable) {
              var _getAdjustedSizes3 = getAdjustedSizes({
                aspectRatio,
                width,
                height
              }, options.resize);
              width = _getAdjustedSizes3.width;
              height = _getAdjustedSizes3.height;
            } else {
              var _getAdjustedSizes4 = getAdjustedSizes({
                aspectRatio,
                width,
                height
              });
              var _getAdjustedSizes4$wi = _getAdjustedSizes4.width;
              width = _getAdjustedSizes4$wi === void 0 ? naturalWidth : _getAdjustedSizes4$wi;
              var _getAdjustedSizes4$he = _getAdjustedSizes4.height;
              height = _getAdjustedSizes4$he === void 0 ? naturalHeight : _getAdjustedSizes4$he;
            }
            width = Math.floor(normalizeDecimalNumber(Math.min(Math.max(width, minWidth), maxWidth)));
            height = Math.floor(normalizeDecimalNumber(Math.min(Math.max(height, minHeight), maxHeight)));
            var destX = -width / 2;
            var destY = -height / 2;
            var destWidth = width;
            var destHeight = height;
            var params = [];
            if (resizable) {
              var srcX = 0;
              var srcY = 0;
              var srcWidth = naturalWidth;
              var srcHeight = naturalHeight;
              var _getAdjustedSizes5 = getAdjustedSizes({
                aspectRatio,
                width: naturalWidth,
                height: naturalHeight
              }, {
                contain: "cover",
                cover: "contain"
              }[options.resize]);
              srcWidth = _getAdjustedSizes5.width;
              srcHeight = _getAdjustedSizes5.height;
              srcX = (naturalWidth - srcWidth) / 2;
              srcY = (naturalHeight - srcHeight) / 2;
              params.push(srcX, srcY, srcWidth, srcHeight);
            }
            params.push(destX, destY, destWidth, destHeight);
            if (is90DegreesRotated) {
              var _ref6 = [height, width];
              width = _ref6[0];
              height = _ref6[1];
            }
            canvas.width = width;
            canvas.height = height;
            if (!isImageType(options.mimeType)) {
              options.mimeType = file.type;
            }
            var fillStyle = "transparent";
            if (file.size > options.convertSize && options.convertTypes.indexOf(options.mimeType) >= 0) {
              options.mimeType = "image/jpeg";
            }
            var isJPEGImage = options.mimeType === "image/jpeg";
            if (isJPEGImage) {
              fillStyle = "#fff";
            }
            context.fillStyle = fillStyle;
            context.fillRect(0, 0, width, height);
            if (options.beforeDraw) {
              options.beforeDraw.call(this, context, canvas);
            }
            if (this.aborted) {
              return;
            }
            context.save();
            context.translate(width / 2, height / 2);
            context.rotate(rotate * Math.PI / 180);
            context.scale(scaleX, scaleY);
            context.drawImage.apply(context, [image].concat(params));
            context.restore();
            if (options.drew) {
              options.drew.call(this, context, canvas);
            }
            if (this.aborted) {
              return;
            }
            var callback = function callback2(blob) {
              if (!_this3.aborted) {
                var done = function done2(result2) {
                  return _this3.done({
                    naturalWidth,
                    naturalHeight,
                    result: result2
                  });
                };
                if (blob && isJPEGImage && options.retainExif && _this3.exif && _this3.exif.length > 0) {
                  var next = function next2(arrayBuffer) {
                    return done(toBlob(arrayBufferToDataURL(insertExif(arrayBuffer, _this3.exif), options.mimeType)));
                  };
                  if (blob.arrayBuffer) {
                    blob.arrayBuffer().then(next).catch(function() {
                      _this3.fail(new Error("Failed to read the compressed image with Blob.arrayBuffer()."));
                    });
                  } else {
                    var reader = new FileReader$1();
                    _this3.reader = reader;
                    reader.onload = function(_ref7) {
                      var target = _ref7.target;
                      next(target.result);
                    };
                    reader.onabort = function() {
                      _this3.fail(new Error("Aborted to read the compressed image with FileReader."));
                    };
                    reader.onerror = function() {
                      _this3.fail(new Error("Failed to read the compressed image with FileReader."));
                    };
                    reader.onloadend = function() {
                      _this3.reader = null;
                    };
                    reader.readAsArrayBuffer(blob);
                  }
                } else {
                  done(blob);
                }
              }
            };
            if (canvas.toBlob) {
              canvas.toBlob(callback, options.mimeType, options.quality);
            } else {
              callback(toBlob(canvas.toDataURL(options.mimeType, options.quality)));
            }
          }
        }, {
          key: "done",
          value: function done(_ref8) {
            var naturalWidth = _ref8.naturalWidth, naturalHeight = _ref8.naturalHeight, result2 = _ref8.result;
            var file = this.file, image = this.image, options = this.options;
            if (URL$1 && image.src.indexOf("blob:") === 0) {
              URL$1.revokeObjectURL(image.src);
            }
            if (result2) {
              if (options.strict && !options.retainExif && result2.size > file.size && options.mimeType === file.type && !(options.width > naturalWidth || options.height > naturalHeight || options.minWidth > naturalWidth || options.minHeight > naturalHeight || options.maxWidth < naturalWidth || options.maxHeight < naturalHeight)) {
                result2 = file;
              } else {
                var date = /* @__PURE__ */ new Date();
                result2.lastModified = date.getTime();
                result2.lastModifiedDate = date;
                result2.name = file.name;
                if (result2.name && result2.type !== file.type) {
                  result2.name = result2.name.replace(REGEXP_EXTENSION, imageTypeToExtension(result2.type));
                }
              }
            } else {
              result2 = file;
            }
            this.result = result2;
            if (options.success) {
              options.success.call(this, result2);
            }
          }
        }, {
          key: "fail",
          value: function fail(err) {
            var options = this.options;
            if (options.error) {
              options.error.call(this, err);
            } else {
              throw err;
            }
          }
        }, {
          key: "abort",
          value: function abort() {
            if (!this.aborted) {
              this.aborted = true;
              if (this.reader) {
                this.reader.abort();
              } else if (!this.image.complete) {
                this.image.onload = null;
                this.image.onabort();
              } else {
                this.fail(new Error("The compression process has been aborted."));
              }
            }
          }
          /**
           * Get the no conflict compressor class.
           * @returns {Compressor} The compressor class.
           */
        }], [{
          key: "noConflict",
          value: function noConflict() {
            window.Compressor = AnotherCompressor;
            return Compressor2;
          }
          /**
           * Change the default options.
           * @param {Object} options - The new default options.
           */
        }, {
          key: "setDefaults",
          value: function setDefaults(options) {
            _extends(DEFAULTS, options);
          }
        }]);
        return Compressor2;
      }();
      const _hoisted_1$7 = { class: "upload-item" };
      const _hoisted_2$1 = { class: "cell" };
      const _hoisted_3$1 = { class: "cell" };
      const _hoisted_4 = { class: "right" };
      const _sfc_main$d = {
        __name: "UploadItem",
        setup(__props) {
          const mainStore2 = useMainStore();
          const { extendWallpaperBase64Obj } = storeToRefs(mainStore2);
          const wallpaperName = vue.ref(generateUniqueDefaultName());
          const isCompressor = useConfig("isCompressor", false);
          const rate = useConfig("compressorRate", 0.8);
          function storeFile(rawFile) {
            const reader = new FileReader();
            reader.readAsDataURL(rawFile);
            reader.onloadend = () => {
              mainStore2.appendWallpaper(wallpaperName.value, reader.result);
              mainStore2.applyWallpaper(wallpaperName.value);
              wallpaperName.value = generateUniqueDefaultName();
            };
          }
          function storeFileCompressor(rawFile) {
            new Compressor(rawFile, {
              quality: rate.value,
              // 压缩质量，0.8 代表 80% 的质量
              success(compressedFile) {
                storeFile(compressedFile);
              }
            });
          }
          function onBeforeUpload(rawFile) {
            if (isCompressor.value) {
              storeFileCompressor(rawFile);
            } else {
              storeFile(rawFile);
            }
            return false;
          }
          function generateUniqueDefaultName() {
            const defaultWallpaperName = "默认壁纸名";
            let counter = 0;
            while (defaultWallpaperName + counter in extendWallpaperBase64Obj.value) {
              counter++;
            }
            return defaultWallpaperName + counter;
          }
          return (_ctx, _cache) => {
            const _component_el_input = ElInput;
            const _component_el_checkbox = ElCheckbox;
            const _component_el_tooltip = ElTooltip;
            const _component_el_input_number = ElInputNumber;
            const _component_i_ep_upload_filled = __unplugin_components_4;
            const _component_el_icon = ElIcon;
            const _component_el_upload = ElUpload;
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$7, [
              vue.createElementVNode("div", _hoisted_2$1, [
                _cache[3] || (_cache[3] = vue.createElementVNode("span", { class: "label" }, " 壁纸名: ", -1)),
                vue.createVNode(_component_el_input, {
                  modelValue: wallpaperName.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => wallpaperName.value = $event),
                  class: "input",
                  placeholder: "请给壁纸取个名字"
                }, null, 8, ["modelValue"])
              ]),
              vue.createElementVNode("div", _hoisted_3$1, [
                vue.createVNode(_component_el_checkbox, {
                  class: "checkbox",
                  modelValue: vue.unref(isCompressor),
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => vue.isRef(isCompressor) ? isCompressor.value = $event : null),
                  label: "是否压缩"
                }, null, 8, ["modelValue"]),
                vue.createElementVNode("div", _hoisted_4, [
                  vue.createVNode(_component_el_tooltip, {
                    class: "box-item",
                    effect: "light",
                    content: "压缩比越接近1, 越是无损压缩, 但存储时, 图片体积会更大",
                    placement: "bottom"
                  }, {
                    default: vue.withCtx(() => _cache[4] || (_cache[4] = [
                      vue.createElementVNode("span", { class: "label" }, " 压缩比: ", -1)
                    ])),
                    _: 1
                  }),
                  vue.createVNode(_component_el_input_number, {
                    modelValue: vue.unref(rate),
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => vue.isRef(rate) ? rate.value = $event : null),
                    min: 0.5,
                    max: 1,
                    step: 0.1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              vue.createVNode(_component_el_upload, {
                multiple: "",
                drag: "",
                "before-upload": onBeforeUpload
              }, {
                tip: vue.withCtx(() => _cache[5] || (_cache[5] = [
                  vue.createElementVNode("div", { class: "el-upload__tip" }, " 正常不需要压缩图片, 支持点击上传多张图片 ", -1)
                ])),
                default: vue.withCtx(() => [
                  vue.createVNode(_component_el_icon, { class: "el-icon--upload" }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(_component_i_ep_upload_filled)
                    ]),
                    _: 1
                  }),
                  _cache[6] || (_cache[6] = vue.createElementVNode("div", { class: "el-upload__text" }, [
                    vue.createTextVNode(" 将图片拖入框内, 或者"),
                    vue.createElementVNode("em", null, "点击上传")
                  ], -1))
                ]),
                _: 1
              })
            ]);
          };
        }
      };
      const UploadItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__scopeId", "data-v-b8caab98"]]);
      const _hoisted_1$6 = { class: "wallpaper-pane" };
      const _sfc_main$c = {
        __name: "UploadPane",
        setup(__props) {
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$6, [
              vue.createVNode(UploadItem)
            ]);
          };
        }
      };
      const UploadPane = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__scopeId", "data-v-d4dbee09"]]);
      const _hoisted_1$5 = { class: "PictureItem" };
      const _hoisted_2 = { class: "card-header" };
      const _hoisted_3 = { class: "card-footer" };
      const _sfc_main$b = {
        __name: "PictureItem",
        props: {
          imgName: {
            type: String,
            default: ""
          },
          imgSrc: {
            type: String,
            default: ""
          },
          deletable: {
            type: Boolean,
            default: false
          },
          lazy: {
            type: Boolean,
            default: false
          }
        },
        setup(__props) {
          const props = __props;
          const mainStore2 = useMainStore();
          function applyWallpaper() {
            mainStore2.applyWallpaper(props.imgName);
          }
          function renameWallpaper() {
            ElMessageBox.prompt("", "修改壁纸名", {
              confirmButtonText: "确定",
              cancelButtonText: "取消"
            }).then(({ value: newName }) => {
              mainStore2.renameWallpaper(props.imgName, newName);
              ElNotification({
                title: "消息",
                message: "已修改",
                type: "success"
              });
            }).catch(() => {
            });
          }
          function deleteWallpaper() {
            mainStore2.deleteWallpaper(props.imgName);
          }
          const loading = vue.ref(true);
          function onLoadSuccess() {
            loading.value = false;
          }
          return (_ctx, _cache) => {
            const _component_el_button = ElButton;
            const _component_el_image = ElImage;
            const _component_el_card = ElCard;
            const _directive_loading = vLoading;
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$5, [
              vue.createVNode(_component_el_card, {
                class: "card",
                shadow: "hover"
              }, {
                header: vue.withCtx(() => [
                  vue.createElementVNode("div", _hoisted_2, [
                    vue.createElementVNode("span", null, vue.toDisplayString(__props.imgName), 1),
                    __props.deletable ? (vue.openBlock(), vue.createBlock(_component_el_button, {
                      key: 0,
                      type: "primary",
                      onClick: renameWallpaper,
                      class: "header-btn",
                      plain: ""
                    }, {
                      default: vue.withCtx(() => _cache[0] || (_cache[0] = [
                        vue.createTextVNode("修改")
                      ])),
                      _: 1
                    })) : vue.createCommentVNode("", true)
                  ])
                ]),
                footer: vue.withCtx(() => [
                  vue.createElementVNode("div", _hoisted_3, [
                    vue.createVNode(_component_el_button, {
                      type: "primary",
                      onClick: applyWallpaper,
                      plain: ""
                    }, {
                      default: vue.withCtx(() => _cache[1] || (_cache[1] = [
                        vue.createTextVNode("应用壁纸")
                      ])),
                      _: 1
                    }),
                    __props.deletable ? (vue.openBlock(), vue.createBlock(_component_el_button, {
                      key: 0,
                      type: "danger",
                      onClick: deleteWallpaper,
                      plain: ""
                    }, {
                      default: vue.withCtx(() => _cache[2] || (_cache[2] = [
                        vue.createTextVNode("删除")
                      ])),
                      _: 1
                    })) : vue.createCommentVNode("", true)
                  ])
                ]),
                default: vue.withCtx(() => [
                  vue.withDirectives(vue.createVNode(_component_el_image, {
                    class: "img",
                    "preview-src-list": [__props.imgSrc],
                    src: __props.imgSrc,
                    fit: "cover",
                    lazy: __props.lazy,
                    onLoad: onLoadSuccess
                  }, null, 8, ["preview-src-list", "src", "lazy"]), [
                    [_directive_loading, loading.value]
                  ])
                ]),
                _: 1
              })
            ]);
          };
        }
      };
      const PictureItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__scopeId", "data-v-016ce612"]]);
      function isObjEmpty(obj) {
        return Object.keys(obj).length === 0;
      }
      const _sfc_main$a = {
        __name: "CollapseItem",
        props: {
          name: {
            type: String,
            default: ""
          },
          height: {
            type: String,
            default: "40vh"
          },
          imgObj: {
            type: Object,
            default: () => ({})
          },
          deletable: {
            type: Boolean,
            default: false
          },
          title: {
            type: String,
            default: ""
          }
        },
        setup(__props) {
          const mainStore2 = useMainStore();
          const { tabsCurrSel } = storeToRefs(mainStore2);
          function toImportPane() {
            tabsCurrSel.value = "0";
          }
          function clearAll(event) {
            event.stopPropagation();
            ElMessageBox.confirm("是否要清除所有自定义背景图?", "", {
              confirmButtonText: "确定",
              cancelButtonText: "取消"
            }).then(() => {
              mainStore2.emptyWallpaper();
            }).catch(() => {
            });
          }
          storeToRefs(mainStore2);
          return (_ctx, _cache) => {
            const _component_el_button = ElButton;
            const _component_el_empty = ElEmpty;
            const _component_el_scrollbar = ElScrollbar;
            const _component_el_collapse_item = ElCollapseItem;
            return vue.openBlock(), vue.createBlock(_component_el_collapse_item, {
              class: "collapse-item",
              title: __props.title,
              name: __props.name
            }, vue.createSlots({
              default: vue.withCtx(() => [
                vue.unref(isObjEmpty)(__props.imgObj) ? (vue.openBlock(), vue.createBlock(_component_el_empty, {
                  key: 0,
                  description: "没有自定义壁纸, 请导入壁纸"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_el_button, {
                      type: "primary",
                      onClick: toImportPane
                    }, {
                      default: vue.withCtx(() => _cache[1] || (_cache[1] = [
                        vue.createTextVNode("导入壁纸")
                      ])),
                      _: 1
                    })
                  ]),
                  _: 1
                })) : (vue.openBlock(), vue.createBlock(_component_el_scrollbar, {
                  key: 1,
                  ref: "scrollRef",
                  class: "scroll",
                  "max-height": __props.height
                }, {
                  default: vue.withCtx(() => [
                    (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.imgObj, (imgSrc, imgName, index) => {
                      return vue.openBlock(), vue.createBlock(PictureItem, {
                        imgSrc,
                        imgName,
                        deletable: __props.deletable,
                        lazy: index > 1
                      }, null, 8, ["imgSrc", "imgName", "deletable", "lazy"]);
                    }), 256))
                  ]),
                  _: 1
                }, 8, ["max-height"]))
              ]),
              _: 2
            }, [
              __props.deletable ? {
                name: "title",
                fn: vue.withCtx(() => [
                  vue.createTextVNode(vue.toDisplayString(__props.title) + " ", 1),
                  vue.createVNode(_component_el_button, {
                    class: "clear-all-btn",
                    onClick: clearAll,
                    text: "",
                    type: "danger"
                  }, {
                    default: vue.withCtx(() => _cache[0] || (_cache[0] = [
                      vue.createTextVNode("删除全部")
                    ])),
                    _: 1
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["title", "name"]);
          };
        }
      };
      const CollapseItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["__scopeId", "data-v-97a3db87"]]);
      const _hoisted_1$4 = { class: "wallpaper-config" };
      const _sfc_main$9 = {
        __name: "WallpaperConfig",
        setup(__props) {
          const mainStore2 = useMainStore();
          const { extendWallpaperBase64Obj, collapseCurrSel } = storeToRefs(mainStore2);
          return (_ctx, _cache) => {
            const _component_el_collapse = ElCollapse;
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$4, [
              vue.createVNode(_component_el_collapse, {
                modelValue: vue.unref(collapseCurrSel),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(collapseCurrSel) ? collapseCurrSel.value = $event : null),
                accordion: ""
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(CollapseItem, {
                    name: "1",
                    title: "默认壁纸",
                    imgObj: vue.unref(wallpaperBase64)
                  }, null, 8, ["imgObj"]),
                  vue.createVNode(CollapseItem, {
                    name: "2",
                    title: "自定义壁纸",
                    imgObj: vue.unref(extendWallpaperBase64Obj),
                    deletable: true
                  }, null, 8, ["imgObj"])
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]);
          };
        }
      };
      const _sfc_main$8 = {
        __name: "CssVarConfig",
        props: /* @__PURE__ */ vue.mergeModels({
          default: {
            type: [String, Number],
            default: 0
          },
          options: {
            type: Array,
            default: () => []
          },
          tip: {
            type: String,
            default: ""
          },
          mode: {
            type: String,
            default: "number"
          },
          suffix: {
            type: String,
            default: ""
          }
        }, {
          "modelValue": {},
          "modelModifiers": {}
        }),
        emits: ["update:modelValue"],
        setup(__props) {
          const props = __props;
          const cssVar = vue.useModel(__props, "modelValue");
          function setPosDefault() {
            cssVar.value = props.default;
          }
          return (_ctx, _cache) => {
            const _component_el_text = ElText;
            const _component_el_tooltip = ElTooltip;
            const _component_el_option = ElOption;
            const _component_el_select = ElSelect;
            const _component_el_input_number = ElInputNumber;
            const _component_el_button = ElButton;
            const _component_el_col = ElCol;
            const _component_el_row = ElRow;
            return vue.openBlock(), vue.createBlock(_component_el_row, { class: "setting-row" }, {
              default: vue.withCtx(() => [
                vue.createVNode(_component_el_col, {
                  class: "setting-container",
                  span: 24
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_el_tooltip, {
                      effect: "light",
                      content: __props.tip,
                      placement: "bottom",
                      disabled: __props.tip.length === 0
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_el_text, { class: "input-label" }, {
                          default: vue.withCtx(() => [
                            vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
                          ]),
                          _: 3
                        })
                      ]),
                      _: 3
                    }, 8, ["content", "disabled"]),
                    typeof cssVar.value === __props.mode || cssVar.value === null && __props.mode === "number" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                      __props.mode === "string" ? (vue.openBlock(), vue.createBlock(_component_el_select, {
                        key: 0,
                        modelValue: cssVar.value,
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => cssVar.value = $event),
                        placeholder: "Select",
                        style: { "width": "220px" }
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.options, (item) => {
                            return vue.openBlock(), vue.createBlock(_component_el_option, {
                              key: item.value,
                              label: item.label,
                              value: item.value
                            }, null, 8, ["label", "value"]);
                          }), 128))
                        ]),
                        _: 1
                      }, 8, ["modelValue"])) : (vue.openBlock(), vue.createBlock(_component_el_input_number, {
                        key: 1,
                        modelValue: cssVar.value,
                        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => cssVar.value = $event),
                        step: 10,
                        style: { "width": "200px" }
                      }, vue.createSlots({ _: 2 }, [
                        __props.suffix.length !== 0 ? {
                          name: "suffix",
                          fn: vue.withCtx(() => [
                            vue.createElementVNode("span", null, vue.toDisplayString(__props.suffix), 1)
                          ]),
                          key: "0"
                        } : void 0
                      ]), 1032, ["modelValue"]))
                    ], 64)) : (vue.openBlock(), vue.createBlock(_component_el_button, {
                      key: 1,
                      type: "primary",
                      plain: "",
                      onClick: setPosDefault
                    }, {
                      default: vue.withCtx(() => _cache[2] || (_cache[2] = [
                        vue.createTextVNode("切换设置方式")
                      ])),
                      _: 1
                    })),
                    vue.createVNode(_component_el_button, {
                      class: "default-btn",
                      type: "primary",
                      plain: "",
                      onClick: setPosDefault
                    }, {
                      default: vue.withCtx(() => _cache[3] || (_cache[3] = [
                        vue.createTextVNode("设为默认值")
                      ])),
                      _: 1
                    })
                  ]),
                  _: 3
                })
              ]),
              _: 3
            });
          };
        }
      };
      const CssVarConfig = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["__scopeId", "data-v-e82e761f"]]);
      const _sfc_main$7 = {
        __name: "NumRowConfig",
        props: /* @__PURE__ */ vue.mergeModels({
          min: {
            type: Number,
            default: -Infinity
          },
          max: {
            type: Number,
            default: Infinity
          },
          desc: {
            type: String,
            default: ""
          },
          defaultValue: {
            type: Number,
            default: 0
          },
          defaultBtnDesc: {
            type: String,
            default: "设为默认值"
          },
          tip: {
            type: String,
            default: ""
          }
        }, {
          "modelValue": {},
          "modelModifiers": {}
        }),
        emits: ["update:modelValue"],
        setup(__props) {
          const props = __props;
          const cssVar = vue.useModel(__props, "modelValue");
          function setCssVarDefault() {
            cssVar.value = props.defaultValue;
          }
          return (_ctx, _cache) => {
            const _component_el_text = ElText;
            const _component_el_tooltip = ElTooltip;
            const _component_el_input_number = ElInputNumber;
            const _component_el_button = ElButton;
            const _component_el_col = ElCol;
            const _component_el_row = ElRow;
            return vue.openBlock(), vue.createBlock(_component_el_row, { class: "setting-row" }, {
              default: vue.withCtx(() => [
                vue.createVNode(_component_el_col, {
                  class: "setting-container",
                  span: 24
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_el_tooltip, {
                      disabled: __props.tip === "",
                      content: __props.tip,
                      placement: "bottom"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_el_text, { class: "input-label" }, {
                          default: vue.withCtx(() => [
                            vue.createTextVNode(vue.toDisplayString(__props.desc), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["disabled", "content"]),
                    vue.createVNode(_component_el_input_number, {
                      modelValue: cssVar.value,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => cssVar.value = $event),
                      min: __props.min,
                      max: __props.max
                    }, null, 8, ["modelValue", "min", "max"]),
                    vue.createVNode(_component_el_button, {
                      class: "default-btn",
                      type: "primary",
                      plain: "",
                      onClick: setCssVarDefault
                    }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(vue.toDisplayString(__props.defaultBtnDesc), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            });
          };
        }
      };
      const NumRowConfig = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["__scopeId", "data-v-c8dfbdc0"]]);
      const _sfc_main$6 = {
        __name: "BiliConfig",
        setup(__props) {
          const biliStore = useBiliStore();
          const {
            displayConfigObj,
            displayConfigDescs,
            displayConfigCount,
            searchBarTopGap,
            searchBarWidth,
            searchBarXOffset,
            wallpaperPosX,
            wallpaperPosY,
            wallpaperSize,
            wallpaperBgColor
          } = storeToRefs(biliStore);
          vue.watch(wallpaperBgColor, () => {
            console.log(wallpaperBgColor.value);
          });
          let COL_COUNT = 4;
          const rowCount = vue.computed(() => {
            return Math.ceil(displayConfigCount.value / COL_COUNT);
          });
          useMainStore();
          let optionsX = [
            {
              value: "left",
              label: "左"
            },
            {
              value: "center",
              label: "中"
            },
            {
              value: "right",
              label: "右"
            }
          ];
          let optionsY = [
            {
              value: "top",
              label: "上"
            },
            {
              value: "center",
              label: "中"
            },
            {
              value: "bottom",
              label: "下"
            }
          ];
          let optionsSize = [
            {
              value: "contain",
              label: "包含"
            },
            {
              value: "cover",
              label: "覆盖"
            }
          ];
          const posTipX = vue.ref("壁纸如果很长, 设置效果就会很明显");
          const posTipY = vue.ref("壁纸如果很高, 设置效果就会很明显");
          const posNumTip = vue.ref("可以输入负值");
          const activeName = useConfig("bili-config-active-name", false);
          return (_ctx, _cache) => {
            const _component_el_text = ElText;
            const _component_el_col = ElCol;
            const _component_el_row = ElRow;
            const _component_el_checkbox = ElCheckbox;
            const _component_el_color_picker = ElColorPicker;
            const _component_el_collapse_item = ElCollapseItem;
            const _component_el_collapse = ElCollapse;
            const _component_el_scrollbar = ElScrollbar;
            return vue.openBlock(), vue.createBlock(_component_el_scrollbar, {
              "max-height": "60vh",
              class: "bili-config"
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(_component_el_row, null, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_el_col, { span: 24 }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_el_text, { size: "large" }, {
                          default: vue.withCtx(() => _cache[11] || (_cache[11] = [
                            vue.createTextVNode("自定义导航条")
                          ])),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(rowCount), (_rowIndex, rowIndex) => {
                  return vue.openBlock(), vue.createBlock(_component_el_row, { class: "wide-row" }, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(COL_COUNT), (_colIndex, colIndex) => {
                        return vue.openBlock(), vue.createBlock(_component_el_col, {
                          class: "checkbox-wrapper",
                          span: 24 / vue.unref(COL_COUNT)
                        }, {
                          default: vue.withCtx(() => [
                            rowIndex * vue.unref(COL_COUNT) + colIndex < vue.unref(displayConfigCount) ? (vue.openBlock(), vue.createBlock(_component_el_checkbox, {
                              key: 0,
                              label: vue.unref(displayConfigDescs)[rowIndex * vue.unref(COL_COUNT) + colIndex],
                              modelValue: vue.unref(displayConfigObj)[vue.unref(displayConfigDescs)[rowIndex * vue.unref(COL_COUNT) + colIndex]],
                              "onUpdate:modelValue": ($event) => vue.unref(displayConfigObj)[vue.unref(displayConfigDescs)[rowIndex * vue.unref(COL_COUNT) + colIndex]] = $event
                            }, null, 8, ["label", "modelValue", "onUpdate:modelValue"])) : vue.createCommentVNode("", true)
                          ]),
                          _: 2
                        }, 1032, ["span"]);
                      }), 256))
                    ]),
                    _: 2
                  }, 1024);
                }), 256)),
                vue.createVNode(NumRowConfig, {
                  modelValue: vue.unref(searchBarTopGap),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(searchBarTopGap) ? searchBarTopGap.value = $event : null),
                  desc: "搜索框离顶部高度, 单位vh:",
                  min: 0,
                  max: 100,
                  "default-btn-desc": "距顶设为默认值",
                  "default-value": vue.unref(SEARCH_BAR_TOP_GAP)
                }, null, 8, ["modelValue", "default-value"]),
                vue.createVNode(NumRowConfig, {
                  modelValue: vue.unref(searchBarWidth),
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => vue.isRef(searchBarWidth) ? searchBarWidth.value = $event : null),
                  desc: "搜索框宽度, 单位vw:",
                  min: 0,
                  max: 100,
                  "default-btn-desc": "宽度设为默认值",
                  "default-value": vue.unref(SEARCH_BAR_WIDTH)
                }, null, 8, ["modelValue", "default-value"]),
                vue.createVNode(NumRowConfig, {
                  modelValue: vue.unref(searchBarXOffset),
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => vue.isRef(searchBarXOffset) ? searchBarXOffset.value = $event : null),
                  desc: "搜索框X轴偏移, 单位vw:",
                  "default-btn-desc": "偏移设为默认值",
                  "default-value": vue.unref(SEARCH_BAR_X_OFFSET),
                  tip: "正数往右偏, 负数往左偏"
                }, null, 8, ["modelValue", "default-value"]),
                vue.createVNode(CssVarConfig, {
                  tip: posTipX.value,
                  modelValue: vue.unref(wallpaperPosX),
                  "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => vue.isRef(wallpaperPosX) ? wallpaperPosX.value = $event : null),
                  default: "center",
                  mode: "string",
                  options: vue.unref(optionsX)
                }, {
                  default: vue.withCtx(() => _cache[12] || (_cache[12] = [
                    vue.createTextVNode(" 壁纸X轴显示位置 ")
                  ])),
                  _: 1
                }, 8, ["tip", "modelValue", "options"]),
                vue.createVNode(CssVarConfig, {
                  tip: posTipY.value,
                  modelValue: vue.unref(wallpaperPosY),
                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => vue.isRef(wallpaperPosY) ? wallpaperPosY.value = $event : null),
                  default: "center",
                  mode: "string",
                  options: vue.unref(optionsY)
                }, {
                  default: vue.withCtx(() => _cache[13] || (_cache[13] = [
                    vue.createTextVNode(" 壁纸Y轴显示位置 ")
                  ])),
                  _: 1
                }, 8, ["tip", "modelValue", "options"]),
                vue.createVNode(CssVarConfig, {
                  modelValue: vue.unref(wallpaperSize),
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => vue.isRef(wallpaperSize) ? wallpaperSize.value = $event : null),
                  default: "cover",
                  mode: "string",
                  options: vue.unref(optionsSize)
                }, {
                  default: vue.withCtx(() => _cache[14] || (_cache[14] = [
                    vue.createTextVNode(" 壁纸显示模式 ")
                  ])),
                  _: 1
                }, 8, ["modelValue", "options"]),
                vue.createVNode(_component_el_row, { class: "gap-setting-row" }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_el_col, {
                      class: "gap-setting-container",
                      span: 24
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_el_text, { style: { "margin-right": "20px" } }, {
                          default: vue.withCtx(() => _cache[15] || (_cache[15] = [
                            vue.createTextVNode("壁纸背景颜色:")
                          ])),
                          _: 1
                        }),
                        vue.createVNode(_component_el_color_picker, {
                          modelValue: vue.unref(wallpaperBgColor),
                          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => vue.isRef(wallpaperBgColor) ? wallpaperBgColor.value = $event : null),
                          "show-alpha": ""
                        }, null, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                vue.createVNode(_component_el_collapse, {
                  modelValue: vue.unref(activeName),
                  "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => vue.isRef(activeName) ? activeName.value = $event : null),
                  accordion: ""
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_el_collapse_item, {
                      title: "高级壁纸设置",
                      name: "1"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(CssVarConfig, {
                          tip: posNumTip.value,
                          modelValue: vue.unref(wallpaperPosX),
                          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => vue.isRef(wallpaperPosX) ? wallpaperPosX.value = $event : null),
                          default: 0,
                          mode: "number",
                          suffix: "px"
                        }, {
                          default: vue.withCtx(() => _cache[16] || (_cache[16] = [
                            vue.createTextVNode(" 壁纸X轴显示位置(px) ")
                          ])),
                          _: 1
                        }, 8, ["tip", "modelValue"]),
                        vue.createVNode(CssVarConfig, {
                          tip: posNumTip.value,
                          modelValue: vue.unref(wallpaperPosY),
                          "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => vue.isRef(wallpaperPosY) ? wallpaperPosY.value = $event : null),
                          default: 0,
                          mode: "number",
                          suffix: "px"
                        }, {
                          default: vue.withCtx(() => _cache[17] || (_cache[17] = [
                            vue.createTextVNode(" 壁纸Y轴显示位置(px) ")
                          ])),
                          _: 1
                        }, 8, ["tip", "modelValue"]),
                        vue.createVNode(CssVarConfig, {
                          modelValue: vue.unref(wallpaperSize),
                          "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => vue.isRef(wallpaperSize) ? wallpaperSize.value = $event : null),
                          default: 100,
                          mode: "number",
                          suffix: "%"
                        }, {
                          default: vue.withCtx(() => _cache[18] || (_cache[18] = [
                            vue.createTextVNode(" 壁纸显示大小 ")
                          ])),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ]),
              _: 1
            });
          };
        }
      };
      const BiliConfig = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["__scopeId", "data-v-a1302a8c"]]);
      const _hoisted_1$3 = { class: "markdown-body" };
      const _sfc_main$5 = {
        __name: "contact-support",
        setup(__props, { expose: __expose }) {
          const frontmatter = {};
          __expose({ frontmatter });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$3, _cache[0] || (_cache[0] = [
              vue.createStaticVNode('<h3>联系</h3><p>作者的 QQ 号码是<strong>2402398917</strong> ,项目已<a href="https://github.com/HHsomeHand/BiliWallpaper/tree/main">开源</a> 衷心感谢您的支持！在使用脚本过程中如果遇到<strong>任何问题</strong>，欢迎随时联系我， <strong>脚本定制</strong>也可以通过 QQ 进一步交流。</p><p>请我喝瓶汽水怎么样: <a href="https://afdian.com/a/hzx3000">爱发电</a> <a href="https://afdian.com/a/hzx3000">https://afdian.com/a/hzx3000</a></p><h4>我的其他脚本:</h4><ul><li><p><a href="https://scriptcat.org/zh-CN/users/135494">脚本猫脚本发布页 (推荐)</a></p></li><li><p><a href="https://greasyfork.org/zh-CN/users/1267636-%E5%9F%BC%E7%8E%89%E4%B8%80%E6%8B%B3">greasyfork</a></p></li></ul><ul><li><p><a href="https://sleazyfork.org/zh-CN/users/1267636-%E5%9F%BC%E7%8E%89%E4%B8%80%E6%8B%B3">sleazyfork (需要魔法)</a></p></li><li><p><a href="https://github.com/HHsomeHand?tab=repositories">Github</a></p></li></ul>', 6)
            ]));
          };
        }
      };
      const _hoisted_1$2 = { class: "contact-support" };
      const _sfc_main$4 = {
        __name: "ContactSupport",
        setup(__props) {
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$2, [
              vue.createVNode(vue.unref(_sfc_main$5))
            ]);
          };
        }
      };
      const _sfc_main$3 = {
        __name: "PaneItem",
        props: {
          label: {
            type: String,
            required: true
          },
          name: {
            type: String,
            required: true
          }
        },
        setup(__props) {
          function onMouseDown(event) {
            event.stopPropagation();
          }
          return (_ctx, _cache) => {
            const _component_el_tab_pane = ElTabPane;
            const _component_el_collapse_transition = ElCollapseTransition;
            return vue.openBlock(), vue.createBlock(_component_el_collapse_transition, null, {
              default: vue.withCtx(() => [
                vue.createVNode(_component_el_tab_pane, {
                  ref: "uploadPaneRef",
                  label: __props.label,
                  name: __props.name
                }, {
                  default: vue.withCtx(() => [
                    vue.createElementVNode("div", {
                      onMousedown: onMouseDown,
                      class: "pane"
                    }, [
                      vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
                    ], 32)
                  ]),
                  _: 3
                }, 8, ["label", "name"])
              ]),
              _: 3
            });
          };
        }
      };
      const PaneItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["__scopeId", "data-v-4d55d0ef"]]);
      const _hoisted_1$1 = { class: "tabs-item" };
      const _sfc_main$2 = {
        __name: "TabsItem",
        setup(__props) {
          const mainStore2 = useMainStore();
          const { tabsCurrSel } = storeToRefs(mainStore2);
          const panes = [
            {
              label: "上传壁纸",
              component: UploadPane,
              name: "0"
            },
            {
              label: "管理壁纸",
              component: _sfc_main$9,
              name: "1"
            },
            {
              label: "屏蔽设置",
              component: BiliConfig,
              name: "2"
            },
            {
              label: "联系作者",
              component: _sfc_main$4,
              name: "3"
            }
          ];
          return (_ctx, _cache) => {
            const _component_el_tabs = ElTabs;
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1, [
              vue.createVNode(_component_el_tabs, {
                modelValue: vue.unref(tabsCurrSel),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(tabsCurrSel) ? tabsCurrSel.value = $event : null)
              }, {
                default: vue.withCtx(() => [
                  (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, vue.renderList(panes, (pane) => {
                    return vue.createVNode(PaneItem, {
                      label: pane.label,
                      name: pane.name
                    }, {
                      default: vue.withCtx(() => [
                        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(pane.component)))
                      ]),
                      _: 2
                    }, 1032, ["label", "name"]);
                  }), 64))
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]);
          };
        }
      };
      const TabsItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["__scopeId", "data-v-631d72d1"]]);
      function setMovable(Ele) {
        let scale = 1;
        let originX = 0;
        let originY = 0;
        let isDragging2 = false;
        let startX, startY;
        Ele.addEventListener("mousedown", (event) => {
          event.stopPropagation();
          event.preventDefault();
          isDragging2 = true;
          startX = event.clientX;
          startY = event.clientY;
          Ele.style.cursor = "grabbing";
        });
        Ele.onclick = (event) => event.stopPropagation();
        window.addEventListener("mouseup", (event) => {
          event.stopPropagation();
          event.preventDefault();
          isDragging2 = false;
          Ele.style.cursor = "grab";
        });
        window.addEventListener("mousemove", (event) => {
          event.stopPropagation();
          event.preventDefault();
          if (!isDragging2) return;
          const dx = event.clientX - startX;
          const dy = event.clientY - startY;
          originX += dx;
          originY += dy;
          startX = event.clientX;
          startY = event.clientY;
          Ele.style.transform = `translate(${originX}px, ${originY}px) scale(${scale})`;
        });
        Ele.reset = function() {
          scale = 1;
          originX = 0;
          originY = 0;
          Ele.style.transform = `translate(0, 0) scale(${scale})`;
        };
      }
      const _sfc_main$1 = {
        __name: "DialogItem",
        setup(__props) {
          const mainStore2 = useMainStore();
          const { isShowDialog: isShowDialog2 } = storeToRefs(mainStore2);
          const dialogRef = vue.ref(null);
          async function onDialogOpen() {
            let dialogEl = dialogRef.value;
            let targetEl = await queryAsync(".el-dialog", dialogEl);
            setMovable(targetEl);
          }
          return (_ctx, _cache) => {
            const _component_el_dialog = ElDialog;
            return vue.openBlock(), vue.createElementBlock("div", {
              ref_key: "dialogRef",
              ref: dialogRef,
              class: "upload-dialog"
            }, [
              vue.createVNode(_component_el_dialog, {
                onOpened: onDialogOpen,
                modelValue: vue.unref(isShowDialog2),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(isShowDialog2) ? isShowDialog2.value = $event : null),
                width: "500",
                "align-center": ""
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(TabsItem)
                ]),
                _: 1
              }, 8, ["modelValue"])
            ], 512);
          };
        }
      };
      const DialogItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["__scopeId", "data-v-15497014"]]);
      const _hoisted_1 = { class: "app" };
      const _sfc_main = {
        __name: "App",
        setup(__props) {
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1, [
              vue.createVNode(WallpaperItem),
              (vue.openBlock(), vue.createBlock(vue.Teleport, { to: "body" }, [
                vue.createVNode(DialogItem)
              ]))
            ]);
          };
        }
      };
      const pinia = createPinia();
      const app = vue.createApp(_sfc_main).use(pinia);
      const mainStore = useMainStore();
      const { isShowDialog } = storeToRefs(mainStore);
      _GM_registerMenuCommand("设置 (点我切换背景图片)", () => {
        isShowDialog.value = true;
      });
      app.mount(
        (() => {
          const app2 = document.createElement("div");
          let parent = document.querySelector(".bili-header");
          if (parent.firstChild) {
            parent.insertBefore(app2, parent.firstChild);
          } else {
            parent.appendChild(app2);
          }
          return app2;
        })()
      );
    }
  });
  require_main_001();

})(Vue);