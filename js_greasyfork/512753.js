// ==UserScript==
// @name         bossç›´è˜è¿‡æ»¤ä¸æ´»è·ƒçš„HR ï¼ˆæ°¸è¿œæ€€å¿µç‰ˆï¼‰
// @namespace    https://github.com/lastsunday/job-hunting-tampermonkey/
// @version      1.0.0
// @description  ä¸€é”®å»ä¸–ä¸æ´»è·ƒçš„HRå¹¶æ°¸è¿œæ€€å¿µä»–ä»¬ï¼Œè°¢è°¢ä½ ä»¬æµªè´¹äº†æˆ‘é‚£ä¹ˆå¤šç”Ÿå‘½ğŸ•¯ã€‚
// @author       shawn
// @license      MIT
// @match        https://www.zhipin.com/web/geek/job*
// @icon         https://img.bosszhipin.com/beijin/mcs/banner/3e9d37e9effaa2b6daf43f3f03f7cb15cfcd208495d565ef66e7dff9f98764da.jpg
// @grant        none
// @require      https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js
// @downloadURL https://update.greasyfork.org/scripts/512753/boss%E7%9B%B4%E8%81%98%E8%BF%87%E6%BB%A4%E4%B8%8D%E6%B4%BB%E8%B7%83%E7%9A%84HR%20%EF%BC%88%E6%B0%B8%E8%BF%9C%E6%80%80%E5%BF%B5%E7%89%88%EF%BC%89.user.js
// @updateURL https://update.greasyfork.org/scripts/512753/boss%E7%9B%B4%E8%81%98%E8%BF%87%E6%BB%A4%E4%B8%8D%E6%B4%BB%E8%B7%83%E7%9A%84HR%20%EF%BC%88%E6%B0%B8%E8%BF%9C%E6%80%80%E5%BF%B5%E7%89%88%EF%BC%89.meta.js
// ==/UserScript==

//app css
const appCss = `
.__boss_time_tag,
.__zhipin_time_tag,
.__zhilian_time_tag {
  position: absolute;
  right: 0;
  top: 0;
  background: rgba(229, 248, 248);
  color: #00a6a7;
  padding: 0 8px;
  font-size: 14px;
  border-radius: 0 0 0 4px;
  text-align: right;
}
/*
.__zhipin_time_tag {
    position: absolute;
    right: 0;
    top: 0;
    background: #426eff;
    color: white;
    padding: 0 8px;
    font-size: 14px;
    border-radius: 0 0 0 4px;
} */

.__job51_time_tag {
  position: absolute;
  right: 0;
  top: 0;
  background: rgba(229, 248, 248);
  color: #00a6a7;
  padding: 0 8px;
  font-size: 14px;
  border-radius: 0 0 0 4px;
  text-align: right;
}

.__jobsdb_time_tag {
  position: absolute;
  right: 0;
  background: rgba(229, 248, 248);
  color: #00a6a7;
  padding: 0 8px;
  font-size: 14px;
  border-radius: 0 0 0 4px;
  text-align: right;
  margin-right: 57px;
  margin-top: 10px;
}

/*for jbsdb job item*/
div[data-search-sol-meta] {
  display: flex;
}

/* ä¸BOSSç›´è˜çš„ç­›é€‰å™¨æ ·å¼ .condition-filter-select .current-select ä¿æŒä¸€è‡´*/
.__boss_filter.condition-filter-select .current-select::after {
  content: unset;
}
.__boss_filter.condition-filter-select .current-select {
  padding-right: 12px;
}
.__boss_filter_result-hidden {
  display: none;
}

.__is_outsourcing_or_training {
}

.__rencent_update {
  color: red;
}

.__time_tag_base_text_font {
  color: white;
  font-size: 12px;
  line-height: 18px;
}

.echo-like .echo-like__icon {
}

.echo-like__count {
}

.__company_info_search {
  display: flex;
  padding: 10px;
  font-size: 14px;
  color: #414a60;
  a {
    padding-right: 10px;
    font-size: 14px;
    color: #414a60;
  }

  a:hover {
    background-color: yellowgreen;
    color: white;
  }
}

.__BOSS_function_panel {
  padding-left: 10px;
}

.__51JOB_function_panel {
  margin-left: -10px;
  margin-top: 5px;
}

.__ZHILIAN_function_panel {
  margin-left: -10px;
}

.__LAGOU_function_panel {
  padding-left: 17px;
  margin-right: 10px;
}

.__JOBSDB_function_panel {
  display: flex;
  flex-direction: column;
  position: relative;
}

.__comment_wrapper {
  display: flex;
  justify-content: end;
  font-size: 14px;
  color: #414a60;
}

.__BOSS_comment_wrapper {
  padding-right: 10px;
  padding-bottom: 10px;
}

.__51JOB_comment_wrapper {

}

.__ZHILIAN_comment_wrapper {

}

.__LAGOU_comment_wrapper {
  padding-right: 10px;
  padding-bottom: 5px;
}

.__JOBSDB_comment_wrapper {
  padding-right: 25px;
}

.__logo_in_function_panel{
  position: absolute;
  right: 0;
  bottom: 0px;
  width: 20px;
}

.__first_browse_time{
  font-size: 14px;
  color: #414a60;
}

.company_bankrupt{
  background:red!important;
  color:#fff!important;
}

`;

const trainingData = [
    "æ£®è¿ªä¿¡æ¯ç§‘æŠ€",
    "é¼è‚²è½¯ä»¶",
    "éº¦è²å°”è†œ",
    "é«˜ç§‘(åŒ—äº¬)",
    "é—ªå…‹ä¿¡æ¯æŠ€æœ¯",
    "é‡‘ç¿äº‘æ•°æ®",
    "é‚¦é£ç§‘æŠ€",
    "è¾¾å†…",
    "è´ç«‹ç¾ç§‘æŠ€",
    "è°¢å°”ç§‘æŠ€",
    "è¯šè¿…ç½‘ç»œç§‘æŠ€",
    "èœ—ç‰›åˆ›æƒ³",
    "è“è‰²æ›™å…‰ä¿¡æ¯æŠ€æœ¯",
    "è“‰æ¸äº‘ç§‘æŠ€",
    "è«ç­‰é—²æ•™è‚²",
    "è£æ–°å¹¿è‚²ç§‘æŠ€",
    "è£æ–°ä¸­å…³æ‘IT",
    "è‹±æ‰è½¯ä»¶èŒä¸š",
    "è…¾ç‘æ’ä¿¡ç½‘ç»œç§‘æŠ€",
    "è”æˆç§‘å¤§ä¿¡æ¯æŠ€æœ¯",
    "çº¢ç³–ç§‘æŠ€",
    "ç¥éªç½‘ç»œç§‘æŠ€",
    "ç¡…è°·é«˜ç§‘",
    "ç¿è¿œå•†åŠ¡ä¿¡æ¯å’¨è¯¢",
    "ç¿å³°ç§‘æŠ€",
    "ç™¾å¹´æœ‰ä¸ºç§‘æŠ€",
    "ç™¾å•ç½‘",
    "ç™»å®¢ç½‘äº’è”ç½‘ç§‘æŠ€",
    "ç‘æ’åˆ›æƒ³ä¿¡æ¯ç§‘æŠ€",
    "ç‹®å­åº§",
    "ç‰›ç‰›ç‰›",
    "çˆ±å°šæ™ºè§‚ç§‘æŠ€",
    "ç«å±±çŸ³ç½‘ç»œ",
    "æ¸…ç¿åˆ›æ–°ç§‘æŠ€",
    "æ·±åœ³å¸‚èŠ±èŠ±ç½‘ç½‘ç»œ",
    "æ·±åœ³å¸‚å¥•éç½‘ç»œ",
    "æ·±åœ³å¸‚å¤§æ£®ç½‘äº‘",
    "æ·±åœ³å¸‚ä¸€è§ˆç½‘ç»œè‚¡ä»½",
    "æµ·æ–‡ä¿¡æ¯",
    "æµ·å¾·æ™ºå’Œç§‘æŠ€",
    "æ³•èµ›ç‰¹ç§‘æŠ€",
    "æ²³åŒ—èæµ·è¡Œæˆ¿åœ°äº§ç»çºª",
    "æ²ˆé˜³èŒµç‰¹",
    "æ±‡ç›Šå•†åŠ¡ä¿¡æ¯å’¨è¯¢",
    "æ±‡æ™ºåŠ¨åŠ›",
    "æ±‡æ–°ä¼˜ç§‘ç§‘æŠ€",
    "æ±‡ä¼—ç›Šæ™ºç§‘æŠ€",
    "æ­¦æ±‰æ—¶å…‰æœºç§‘æŠ€",
    "æ­¦åˆ›ä¿¡æ¯ç§‘æŠ€",
    "æ¬£é˜³ç§‘æŠ€",
    "æ£®è¿ªä¿¡æ¯ç§‘æŠ€",
    "æ ªå¼ä¼šç¤¾",
    "æœ—æ²ƒä¿¡æ¯æŠ€æœ¯",
    "æš®å…‰æ—¶ä»£ç§‘æŠ€",
    "æ™ºæ¸¸ç½‘ç»œ",
    "æ™ºæ…§åˆ›æƒ³ç§‘æŠ€",
    "æ™¶ç¾è±ç‰¹",
    "æ™Ÿå¸ç§‘æŠ€",
    "æ™‹ä½‘ç§‘æŠ€",
    "æ—…çƒ¨ç½‘ç»œç§‘æŠ€",
    "æ–°åç”µè„‘",
    "æŒå®åˆåŠ›ç§‘æŠ€",
    "æ‹¾å¾—ç§‘æŠ€",
    "æ‹œçº³ç¿",
    "æ‰ç§€äººäººç§‘æŠ€",
    "æˆéƒ½è«ç­‰é—²æ•™è‚²",
    "æˆéƒ½ç¿¡ç¿ ç§‘æŠ€",
    "æˆéƒ½æ—­ç¥¥ç§‘æŠ€",
    "æˆéƒ½å®œç®€æŠ•èµ„",
    "æˆéƒ½å’Œç¦¹ç½‘ç»œ",
    "æˆéƒ½åšç¿æ–¯ç§‘ç½‘ç»œ",
    "æˆéƒ½åç‚œäº‘å•†",
    "æˆéƒ½ä¼ŸéŸ§",
    "æ…§ä¸ä¿¡æ¯æŠ€æœ¯",
    "æ’å®‰ç‘è¾¾ç§‘æŠ€",
    "æ€ªç‹—è½¯ä»¶",
    "å¾¡é›ªç½‘ç»œç§‘æŠ€",
    "å¹¿å·ç•™ä½™é¦™ä¿¡æ¯",
    "å¹¿å·æµæ°“å…”ç½‘ç»œ",
    "å¹¿å·ä¸ƒé”¦å®«ç½‘ç»œ",
    "å¹¿ä¸œæº¢è¾¾ç§‘æŠ€",
    "å¹¿ä¸œæ¨±é›ªç§‘æŠ€",
    "å·´äººäº’åŠ¨æˆéƒ½ç½‘ç»œç§‘æŠ€",
    "å·è½¯ä¿¡æ¯",
    "å·æ±‡ç§‘æŠ€",
    "å°šè§‚ç§‘æŠ€",
    "å°šå­¦å ‚",
    "å®‰è…¾å°šç¾è½¯ä»¶",
    "å­¦ç›Ÿè‹±æ‰",
    "å¥•éç½‘ç»œ",
    "å¥‡ç¾æ‹‰ç§‘æŠ€",
    "å¥‡ç‚¹ç‰©æµ",
    "å¥‡ä½³ç§‘æŠ€",
    "å¤©é›„ç‘ç§‘",
    "å¤©çºµç§‘æŠ€",
    "å¤©ç§‘åŒåˆ›ç§‘æŠ€",
    "å¤©æ—¶åˆ©æ•™è‚²ç§‘æŠ€",
    "å¤šè¿ª",
    "å››å·é‡‘æ˜ç§‘æŠ€",
    "å››å·æ ¼ç¿æ³°æ€ä¿¡æ¯ç§‘æŠ€",
    "å››å·å¤å…´æ•™è‚²",
    "å˜‰å®‡ä¸‰é‘«",
    "å›é£ç¯ä¿",
    "åŒç»´å•†è´¸",
    "åšé€šç§‘æŠ€",
    "åšæœ—äº‘è½¯ç§‘æŠ€",
    "åšä¸ºå³°è½¯ä»¶",
    "å—å……å’Œèƒœç½‘ç»œ",
    "å“ç»´ä¿¡æ¯æŠ€æœ¯",
    "å“ç¿ä¿¡æ¯æŠ€æœ¯",
    "å“æ–°æ™ºè¶£",
    "å“æ–°æ€åˆ›ç§‘æŠ€",
    "åè½¯é«˜ç§‘",
    "åè‚²ç½‘ç§‘æŠ€",
    "åè‚²å›½é™…",
    "åè‚²ä¿¡æ¯æŠ€æœ¯",
    "åå¤å¤©ç½‘æ™ºèƒ½ç§‘æŠ€",
    "åä¿¡æ™ºåŸç§‘æŠ€",
    "åä¸ºé«˜ç§‘",
    "åä¸ºäº‘é›†",
    "åŒ—äº¬é‡‘ç¿äº‘",
    "åŒ—äº¬é‚®ç”µå¤§å­¦â€œäº’è”ç½‘+â€äººæ‰åŸ¹å…»åŸºåœ°",
    "åŒ—äº¬æ‰˜æ™®äº‘æ•°æ®",
    "åŒ—äº¬æˆæ–‡ç§‘æŠ€",
    "åŒ—äº¬åšæœ—äº‘",
    "åŒ—äº¬åšæœ—äº‘è½¯",
    "åŒ—äº¬ä¸­ç§‘è½¯äº‘",
    "åŠ¨å¬éŸ³ä¹æ–‡åŒ–ä¼ æ’­",
    "åˆ›ç«‹ä¿¡æ¯ç§‘æŠ€æœ‰é™è´£ä»»å…¬å¸",
    "åˆ›æƒ³å¤©ç©º",
    "åˆ›äº«æºä¿¡æ¯æŠ€æœ¯",
    "å…´å­¦ä¿¡æ¯æŠ€æœ¯",
    "ä¿®è¿œå ‚ç§‘æŠ€",
    "ä½°å›½ç§‘æŠ€",
    "ä¼ŸéŸ§ç§‘æŠ€",
    "ä¼šåœ†å®ç§‘æŠ€",
    "ä¼˜æ‰åˆ›æ™º",
    "ä¼˜æ‰åˆ›æ™ºç§‘æŠ€",
    "ä¼—è½¯ç§‘æŠ€",
    "ä¼—è½¯ä¿¡æ¯ç§‘æŠ€",
    "äº’åŠ¨æ— é™ç§‘æŠ€",
    "äº‘è½¯é«˜ç§‘",
    "äº‘è½¯äº’è”",
    "äº‘çŸ¥å­¦ç§‘æŠ€",
    "äº‘å›¾é£å¢¨ä¿¡æ¯",
    "ä¹èƒœç§‘æŠ€",
    "ä¹…è¿œé“¶æµ·è½¯ä»¶è‚¡ä»½",
    "ä¸­è½¯",
    "ä¸­èˆªäº‘å¤©",
    "ä¸­ç§‘è½¯äº‘æ•°æ®",
    "ä¸­ç§‘åˆè¿…ç§‘æŠ€",
    "ä¸­ç¿å¤©æˆä¼ä¸šç®¡ç†å’¨è¯¢",
    "ä¸­å“ä¿¡æ¯æŠ€æœ¯",
    "ä¸­å…³æ‘è½¯ä»¶",
    "ä¸­å…³æ–°æ‰",
    "ä¸œè½¯",
    "ä¸–çºªäº‘é¼ä¿¡æ¯",
    "ä¸–çºªäº‘åˆ›",
    "ä¸Šæµ·åŒç™¾å®ä¸š",
    "æˆéƒ½å¯°å®‡æ€åˆ›ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¼€ç½‘ç§‘æŠ€(åŒ—äº¬)æœ‰é™å…¬å¸æˆéƒ½åˆ†å…¬å¸",
    "ä¸­ç§‘å¯Œç›ˆ(åŒ—äº¬)ç§‘æŠ€æœ‰é™å…¬å¸",
    "åä¸ºäº‘è½¯(åŒ—äº¬ï¼‰ç§‘æŠ€æœ‰é™å…¬å¸",
    "äº‘æ±‡é«˜ç§‘ï¼ˆåŒ—äº¬ï¼‰ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½æ™ºè‚²äº’åŠ¨ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½æ±‡èƒ½åˆ›ç§‘ç§‘æŠ€æœ‰é™å…¬å¸",
    "å››å·è‚²é“ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½å…„å¼Ÿè¿æ•™è‚²å’¨è¯¢æœ‰é™å…¬å¸",
    "ä¼˜è¶Šæ•™è‚²",
    "æˆéƒ½å›½ä¿¡å®‰ä¿¡æ¯äº§ä¸šåŸºåœ°æœ‰é™å…¬å¸",
    "æˆéƒ½è“‰æ©™æ™ºç¿",
    "æˆéƒ½é—ªå®¢ä¿¡æ¯æŠ€æœ¯",
    "åŒ—äº¬é’§é¼ä¸–çºªç§‘æŠ€æœ‰é™å…¬å¸",
    "å››å·èœ€æ³°åŒ–å·¥ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½æ™ºäº‘æ±‡é€šç§‘æŠ€æœ‰é™å…¬å¸",
    "é‡‘æŒ‡åˆ›äº¿ï¼ˆåŒ—äº¬ï¼‰ç§‘æŠ€æœ‰é™å…¬å¸",
    "å››å·æ™ºæ¸¸ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å››å·æ™ºæ¸¸ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å››å·ç‹®å­åº§äº’è”ç½‘ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ…§ä¸ä¿¡æ¯æŠ€æœ¯æˆéƒ½æœ‰é™å…¬å¸",
    "æˆéƒ½ä¸‰ä¸ªå­—ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æˆéƒ½æš®å…‰æ—¶ä»£ç§‘æŠ€æœ‰é™å…¬å¸",
    "ä¸­è½¯åˆ›æ–°ï¼ˆåŒ—äº¬ï¼‰ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½å¯°å®‡æ€åˆ›ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½ä¼˜æ‰åˆ›æ™º",
    "å·´äººäº’åŠ¨æˆéƒ½ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "ä¸­è½¯å›½é™…æ•™è‚²",
    "ä¸­è½¯è½¯ä»¶èŒä¸šåŸ¹è®­å­¦æ ¡",
    "æˆéƒ½ç±³å¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "äº‘è½¯é«˜ç§‘(æˆéƒ½)åˆ†å…¬å¸",
    "ä¸­è½¯ç‰©è”ï¼ˆåŒ—äº¬ï¼‰ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½åè‚²ä¿¡æ¯æŠ€æœ¯èŒä¸šæŠ€èƒ½åŸ¹è®­å­¦æ ¡",
    "å››å·å¤©çºµç§‘æŠ€æœ‰é™å…¬å¸",
    "å››å·æ–°åç”µè„‘å­¦æ ¡",
    "åšåˆ›åå®‡ï¼ˆåŒ—äº¬ï¼‰ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½äº”æœˆèŠ±åŠ³åŠ¨èŒä¸šæŠ€èƒ½åŸ¹è®­å­¦æ ¡",
    "åŒ—äº¬ä¸­é’ä¸­å…³æ‘è½¯ä»¶äººæ‰åŸºåœ°",
    "åŒ—äº¬æ•°é€šå›½è½¯ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸æˆéƒ½åˆ†å…¬å¸",
    "åšåˆ›åå®‡",
    "èœ—ç‰›åˆ›æƒ³",
    "æ–°åé›†å›¢",
    "åŒ—äº¬åƒé”‹äº’è”ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½åšä¸ºå³°è½¯ä»¶æŠ€æœ¯æœ‰é™å…¬å¸",
    "ä¸­è½¯å¼€åˆ›",
    "æˆéƒ½è¾¾å†…ç§‘æŠ€æœ‰é™å…¬å¸é’ç¾Šåˆ†å…¬å¸",
    "åä¸ºé«˜ç§‘ï¼ˆåŒ—äº¬ï¼‰è½¯ä»¶æœ‰é™å…¬å¸",
    "åŒ—äº¬è£æ–°å¹¿è‚²ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½æ±‡æ™ºåŠ¨åŠ›ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æˆéƒ½ç³–æœæ—¶ä»£ç§‘æŠ€æœ‰é™å…¬å¸",
    "åä¿¡æ™ºåŸæ•™è‚²æŠ€æœ¯æœ‰é™å…¬å¸",
    "ä¸­å…³æ‘å¤§å­¦ç”Ÿå°±ä¸šå®è®­åŸºåœ°",
    "æˆéƒ½å°šå­¦å ‚ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½å¾®é“¶ä¼—ç­¹æ•°æ®ä¿¡æ¯æŠ€æœ¯æœåŠ¡æœ‰é™å…¬å¸",
    "å››å·ä¼—ä¿¡äº’è”ç§‘æŠ€æœ‰é™å…¬å¸",
    "åŒ—äº¬ç»å‰ç§‘æŠ€å‘å±•ä¸­å¿ƒï¼ˆç»å‰ç§‘æŠ€ï¼‰",
    "ä¸Šæµ·åæ°èŒä¸šæŠ€èƒ½åŸ¹è®­æœ‰é™å…¬å¸",
    "æˆéƒ½è¾¾å†…ç§‘æŠ€",
    "æˆéƒ½å›½ä¿¡å®‰ä¿¡æ¯äº§ä¸šåŸºåœ°æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ˜“æ°‘ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ–°æœæ•™è‚²å‘å±•æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚è“éŸ³ç½‘ç»œä¼ åª’æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç‘ä¹‹å›¾è£…é¥°è®¾è®¡æœ‰é™å…¬å¸",
    "æ·±åœ³äºšç¾å…¹è®¾è®¡ç ”ç©¶é™¢æœ‰é™å…¬å¸",
    "åœ£ååœ£ç‚¹è®¾è®¡ï¼ˆæ·±åœ³ï¼‰æœ‰é™å…¬å¸",
    "æ·±åœ³é¸¿è®¯è®¡ç®—æœºç³»ç»Ÿæœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ˜Ÿä¹è½¯ä»¶æœ‰é™å…¬å¸",
    "æ·±åœ³è¯ºè¾¾æ€ç§‘æŠ€å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³æ…§æ€è¿œç§‘æŠ€å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³åˆç‚¼å½±è§†ä¼ åª’æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åå¤§æ™ºåˆ›ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³è¯ºè¾¾æ€ç§‘æŠ€å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³åˆä¼—è‰¾ç‰¹ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³è“æµ·æ˜Ÿç©ºä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³é‘«åˆ›ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å ‰äº‘ä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³æ·±è½¯æ™ºèƒ½è®¾å¤‡æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ²»ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¸­æ·±è½¯é€šç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç¨‹åºçŒ¿æ•™è‚²ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚è£ç››åˆçºµç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚è¯šè‡³è½¯ä»¶æœ‰é™å…¬å¸",
    "æ·±åœ³è…¾å°šæ—¶ä»£ä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ²ƒè¾¾åˆ›ç§‘æœ‰é™å…¬å¸",
    "æ·±åœ³å¾„èˆŸç§‘æŠ€å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³å‡Œå²³è½¯ä»¶ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ™ºè”äº‘è°·ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚äº‘è”å¤©ä¸‹ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å°šå¤©è§‚ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¯è¾°æ˜Ÿåˆ›ï¼ˆæ·±åœ³ï¼‰ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ…§å­¦å›½é™…ç§‘æŠ€å‘å±•(æ·±åœ³)æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åå“è½¯ä»¶æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å¤§æ–¹ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åšç››ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é€šå¤©æ™ºè¾¾ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å“ˆå“ˆç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åˆ›æ˜Ÿåšç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ™®è¾¾æºç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "åŒ—äº¬æ‰ç§€äººäººç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åšç››ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚è¯šä¸æˆç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å¨å°”è®¯è¾¾ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç¿”èšä½³å’Œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ´ä¸½ä¿é‘«ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¼—äº¿é€šä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å“ˆå“ˆç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å†…è¾¾å€¾æ³‰ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç”³å—é“ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ–°é¾™æš´å®‡ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ°‘å®‡æ¸¸æˆç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¸‡åº¦ç½‘ç»œæŠ€æœ¯å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å¤©ç‘åœ°å®‰ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ¿ æ±‡ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å£¹æŸ’æŒç½‘ç»œç§‘æŠ€å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä½‘åšç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å®ç«¯åˆ©é‘«ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åˆ©å®‡å®åˆ©ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚è‹¥è¾°ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å“ˆå“ˆç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¸€äºŒæ‹›è˜æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¸‡é¹åˆ©é€šç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æŒ¯è®¯ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æé¾™è°·ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç‘å®‰åˆ¶é€ ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æµ·çº³äº‘æ¸¸ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚è…¾æè®¯ç§‘ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ±‡ä¸€é“ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åˆ›æ„é˜ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç™¾åˆ©åº¦åº·ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚çº¢é¸Ÿç½‘ç»œç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å®‡è“å®æ³‰ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³èµ›ä¼˜è½¯ä»¶è®¾è®¡æœ‰é™å…¬å¸",
    "æ·±åœ³ä¸­æ˜Ÿä¿¡æ¯æŠ€æœ¯æœåŠ¡æœ‰é™å…¬å¸",
    "æ·±åœ³æƒ ç§‘è½¯ä»¶è®¾è®¡æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æŒå¨±ç‚«åŠ¨ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "å¹¿å·ä¸­æ˜Ÿé›†å›¢æœ‰é™å…¬å¸æ·±åœ³åˆ†å…¬å¸",
    "æ·±åœ³å¸‚æ³½æ—ä¿¡æ¯å’¨è¯¢æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ±‡ç‰¹é€šç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å¤§æ–¹ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ°‘å®‡æ¸¸æˆç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç›Šè¿…ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ±‡ä¸€é“ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ–¹ç‰¹ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æŒ¯è®¯ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚è¿œåŠ›ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ°‘å®‡æ¸¸æˆç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚èšè§†ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ™ºç›ˆç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚è‹¥è¾°ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å“ˆå“ˆç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³ç‡•èµµæ¸¸æˆç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å¤©ä¹‹è…¾ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é²²é¹ç½‘äº‘ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å‰æµ·ä¿ç™¾ä¸šäº’è”ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åšæ€åˆ›ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚éŸ³ä¼´å°”ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åè¾¾ä¸–æ­£ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚è°¨ä¿¡ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å·çŸ³ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç´«å·è½¯ä»¶æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åå¤§æ™ºåˆ›ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚çš“è¯šç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ—¶ç©ºæ•°é€šç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ±‡æ¬£è…¾è¾¾ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚äº‘è”æ—¶ç©ºç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚äº’è”å®‰è¾¾ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æµ·é€šæ˜“è¾¾ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¸­ä¼ç§‘åˆ›ç§‘æŠ€æœåŠ¡æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å¯èˆªä¹‹æ˜Ÿç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ©æ³½æ±‡ç§‘æŠ€å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç‹ç»œå¤©ä¸‹ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ™®æ™´ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ³½æ—ä¿¡æ¯å’¨è¯¢æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åæ™¨çç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³æ€å¤©ä¸‹ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³ç™¾é”¤ç‚¼ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å“²èŠ’ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å®ƒçŸ³ä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é¹åŸäº’è”ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é¹åŸäº’è”ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å‰æµ·äº‘æŠ€æœ¯å•†å­¦é™¢æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¸€é£è¡Œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é‘«ç²¾è‰¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å®œä¼—è½¯ä»¶æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¼—è½¯ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ£®ç«¹ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å‡Œå¨ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¸­è½¯æ˜“åŠ¨ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å®‰ç››ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³ä¸ƒä¸ƒå…ƒç´ ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ–‡æ€è”åˆç½‘ç»œæŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç‹®å­åº§ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç•…äº«è½¯ä»¶ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æµ·æ«ç§‘æŠ€æœ‰é™å…¬å¸",
    "é€Ÿæ©™ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ™ºè›™ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³äº‘å’Œæ•°æ®ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³ç†æ–¹ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç§‘å”¯ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ–¯å¯†è¾¾ç½‘ç»œç§‘æŠ€å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³ä¸°å·¢ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é“äº‘æ±‡ç½‘ç»œç§‘æŠ€å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³æ´›è¨ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³è¯­é£ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³ä¸ƒå•¸ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é€¸ç¿”ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å›½ä¿¡å®‰ä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "åŒ—äº¬åè‚²å…‰å¤§ç§‘æŠ€å‘å±•æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç‘æ»‹å¾·ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¸°æ³½é«˜ç§‘ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ–°ä¸€ä»£ä¿¡æ¯æŠ€æœ¯ç ”ç©¶é™¢",
    "æ·±åœ³å¸‚åç§‘ç½‘è®¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ–°ä¸€ä»£ä¿¡æ¯æŠ€æœ¯ç ”ç©¶é™¢",
    "æ·±åœ³è‹±äºšé€”ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ­¦å¤§æ–°ç ”ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ˜“äº‹æ´¾å…‹ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åè¾¾ä¸–æ­£ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ™®ååšå¤§ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å˜€å˜€è¾¾ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³äº‘å‡Œå›½é™…ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åŸ¹ç¿æ•™è‚²ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚äººäººä¸Šä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "å“æ–°æ™ºè¶£(åŒ—äº¬)ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸æ·±åœ³åˆ†å…¬å¸",
    "æ·±åœ³å¸‚ä¸­è½¯å“è¶Šæ•™è‚²ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å“ç»´ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³ä¸­è½¯å›½é™…æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åç»´ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åè®¯æŠ€æœ¯æœåŠ¡æœ‰é™å…¬å¸",
    "åŒ—äº¬äº¨éš†ä¼Ÿä¸šä¿¡æ¯å’¨è¯¢æœ‰é™è´£ä»»å…¬å¸æ·±åœ³åˆ†å…¬å¸",
    "æ·±åœ³åè‚²ç½‘ç§‘æŠ€å‘å±•æœ‰é™å…¬å¸",
    "æ·±åœ³åè‚²ç½‘ç§‘æŠ€å‘å±•æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å®œä¼—è½¯ä»¶æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³é€»è¾‘æ€ç»´è½¯ä»¶æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é‘«å—è±ªç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä½‘è°·æš´ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å®‹ç¦è¿ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¼Ÿæ³°å®‰é‘«ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ´å®‡ç½‘å®¢ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ…§æç§‘æŠ€æœ‰é™å…¬å¸",
    "å‡Œé˜³ç§‘æŠ€(æ·±åœ³)æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æµ·çº³è®¡ç®—æœºç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚èµ„ä¿¡åˆ©é€šç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é—¨é“ä¿¡æ¯å’¨è¯¢æœ‰é™å…¬å¸",
    "æ·±åœ³äºŒå››å…­ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å›½ä¿¡å®‰ä¿¡æ¯äº§ä¸šåŸºåœ°æœ‰é™å…¬å¸",
    "æ·±åœ³å°”é›…èµ›è¯ºä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æé€Ÿåº¦ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³æ–‡è±†ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å…´æµ·éŸµé€šä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³æ€å¯†ç‰¹ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³æ˜“é€æµªç§‘æŠ€æœ‰é™å…¬å¸",
    "è¥¿å®‰è¿ªæ¬§è½¯ä»¶æœ‰é™å…¬å¸æ·±åœ³åˆ†å…¬å¸",
    "è¯ºåšæºè½¯ä»¶ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·å¤šè¿ªç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸æ·±åœ³ç¦ç”°åˆ†å…¬å¸",
    "å¹¿å·å¤šè¿ªç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸æ·±åœ³å®å®‰åˆ†å…¬å¸",
    "å¹¿ä¸œæ™¶ç¾è±ç‰¹ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·æµæ°“å…”ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ— å¿§äº’è”ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿ä¸œåå¤å¤©ç½‘æ™ºèƒ½ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿ä¸œæº¢è¾¾ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿ä¸œæ¨±é›ªç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·æµæ°“å…”ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿ä¸œæ™¶ç¾è±ç‰¹ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·å¤šè¿ªç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸æ·±åœ³é¾™ååˆ†å…¬å¸",
    "æ·±åœ³åšä¸ºå³°ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç§‘å¤§ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ³½æ—ä¿¡æ¯å’¨è¯¢æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚èµ·èˆªåˆ›åŠ¿ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ­¦æ±‰ä½°é’§æˆæŠ€æœ¯æœ‰é™è´£ä»»å…¬å¸æ·±åœ³åˆ†å…¬å¸",
    "æ·±åœ³å¸‚æ–°è¾¹ç•Œç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚äº‘æ¸¸å¤©ä¸‹ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å®æ–¯å¯Œé€šç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç‘åˆç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³æ›™ä¹‹å…‰æ•™è‚²å’¨è¯¢æ–‡åŒ–æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ™ºè”äº‘è°·ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³åšç¿åŒåˆ›ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³ç››æ€ç§‘æ•™æ–‡åŒ–æœ‰é™å…¬å¸",
    "æ·±åœ³ç«æ˜Ÿæ˜Ÿé™…ä¼ æ’­æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ³°æ³½æŠ€æœ¯æœ‰é™å…¬å¸",
    "è…¾è¯šè½¯ä»¶å¼€å‘ï¼ˆæ·±åœ³ï¼‰æœ‰é™å…¬å¸",
    "è…¾è¯šè½¯ä»¶å¼€å‘ï¼ˆæ·±åœ³ï¼‰æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ±‡é€šåˆåŠ›ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç‚«å½©æ˜Ÿæ–‡åŒ–ä¼ åª’æœ‰é™å…¬å¸",
    "æ·±åœ³äº‘å¤©å›¢ç”µå­å•†åŠ¡æœ‰é™å…¬å¸",
    "æ·±åœ³æ©é¢‚ç§‘æŠ€å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ·±åµŒç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åç‘å¾·å›½é™…é‡‘èæœåŠ¡æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ·±ä¼äº’èµ¢ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚éŸµå‘³ä¸–è¾¾ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³è¾¾å†…ä¸ºä¸Šè½¯ä»¶æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åè¾°è½¯ä»¶å¼€å‘ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚åšå£«å¤©äº‘è½¯ä»¶å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æé€Ÿä¼ å¥‡è½¯ä»¶å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚è¯ºå˜‰å† ç§‘ç”µå­æœ‰é™å…¬å¸",
    "æ·±åœ³å‰æµ·æ˜Ÿç²¤æ–‡åŒ–ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç¿æ€æºä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "å‰æµ·å®è‰ç¾ï¼ˆæ·±åœ³ï¼‰å›½é™…å’¨è¯¢æœåŠ¡æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å¤§ä¼—ä¸‡å…´ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¸€äºŒäººåŠ›èµ„æºæœåŠ¡æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ä¸­ç§‘é¸¿å›¾ä¿¡æ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç‚¹æ—¶åˆ›æ–°ç§‘æŠ€æœ‰é™å…¬å¸",
    "åŒ—äº¬æ¸…å¤§ä¹é¼ç§‘æŠ€å‘å±•æœ‰é™å…¬å¸æ·±åœ³åˆ†å…¬å¸",
    "æ·±åœ³å¸‚æ¢¦å¹»ç»„åˆç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é¸¿ç¨‹ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³ç‘å…ƒä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "å¹¿å·å¤šè¿ªç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·ç²¤åµŒé€šä¿¡ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸",
    "å¹¿å·å¸‚èˆœç„¶ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·å¸‚ä¸­æ‹“ä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·å¸‚å®é¾™ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·ä¸­æ˜Ÿé›†å›¢æœ‰é™å…¬å¸",
    "å¹¿å·æ–‡è±†ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·æ–‡è±†ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·æ–‡è±†ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·æ–‡è±†ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·æ–‡è±†ç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·æ£®è¿ªä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿ä¸œæº¢è¾¾ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿ä¸œæ™‹ä½‘ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸",
    "å¹¿å·ç¥éªç½‘ç»œç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿ä¸œéº¦è²å°”è†œç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿å·ç™¾å•ç½‘äº’è”ç½‘ç§‘æŠ€æœ‰é™å…¬å¸",
    "å¹¿ä¸œçº¢æ¾ç½‘ç»œä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "å››å·æ™Ÿå¸ç§‘æŠ€å‘å±•æœ‰é™å…¬å¸",
    "å››å·æµ·å¾·æ™ºå’Œç§‘æŠ€æœ‰é™å…¬å¸",
    "å››å·çº¢ç³–ç§‘æŠ€æœ‰é™å…¬å¸",
    "å››å·å¤©çºµç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½è°¢å°”ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½ä¹èƒœç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½é—ªå…‹ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æˆéƒ½æ±‡æ™ºåŠ¨åŠ›ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æˆéƒ½èœ—ç‰›åˆ›æƒ³ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½ä¸­è½¯å“è¶Šä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æˆéƒ½äº’åŠ¨æ— é™ç§‘æŠ€æœ‰é™å…¬å¸",
    "æˆéƒ½è“æºä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æˆéƒ½å›½ä¿¡å®‰ä¿¡æ¯äº§ä¸šåŸºåœ°æœ‰é™å…¬å¸",
    "æˆéƒ½å›½åµŒæ•™è‚²",
    "æˆéƒ½ç¿å³°ç§‘æŠ€æœ‰é™å…¬",
    "æ­¦æ±‰å¸‚åä¿¡æ™ºåŸç§‘æŠ€æœ‰é™å…¬å¸",
    "ä¸Šæµ·æ¸…æ³½ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸  ",
    "ä¸Šæµ·é’ä¸šè®¡ç®—æœºç§‘æŠ€æœ‰é™å…¬å¸ ",
    "ä¸Šæµ·æ¸¸çˆ±æ•°ç ç§‘æŠ€æœ‰é™å…¬å¸ ",
    "ä¸Šæµ·å“ˆæ©è®¡ç®—æœºç§‘æŠ€æœ‰é™å…¬å¸ ",
    "ä¸Šæµ·æ˜†ç«¥ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "ä¸Šæµ·å››åŸŸä¿¡æ¯    ",
    "æ°æ™®è½¯ä»¶ç§‘æŠ€æœ‰é™å…¬å¸",
    "ä¸Šæµ·æ²›é¸¿ç½‘ç»œ     ",
    "ä¸Šæµ·äº¤å¤§å¿—ç›Ÿ",
    "ä¸Šæµ·å¯æ˜è½¯ä»¶",
    "ä¸Šæµ·æµ·åŒä¿¡æ¯ ",
    "ä¸Šæµ·å­ç¿è½¯ä»¶",
    "æµ·åŒç™¾å®ä¸š",
    "ä¸Šæµ·å‡æ–¯ç”µå­ç§‘æŠ€æœ‰é™å…¬å¸ ",
    "ä¸Šæµ·å¯æ˜è½¯ä»¶è‚¡ä»½æœ‰é™å…¬å¸",
    "ä¸Šæµ·æ—¶ç›ˆä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸     ",
    "ä¸Šæµ·ç§¯é¼ä¿¡æ¯ç§‘æŠ€  ",
    "ä¸Šæµ·å‡¡ç‹„ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "ä¸Šæµ·å¾®åŠ¨ä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸  ",
    "ä¸Šæµ·ç´¢æ¼«è®¡ç®—æœºç§‘æŠ€æœ‰é™å…¬å¸ ",
    "ä¸Šæµ·è‡´éª‹äº’è”ç½‘ç§‘æŠ€æœ‰é™å…¬å¸",
    "ä¸Šæµ·ä¸‡ç¾è½¯ä»¶ç§‘æŠ€æœ‰é™å…¬å¸",
    "ä¸Šæµ·ä¸‡ç¾è½¯ä»¶ç§‘æŠ€æœ‰é™å…¬å¸",
    "ä¸Šæµ·æŒšå“äº’è”ç½‘ç§‘æŠ€æœ‰é™å…¬å¸",
    "åŒ—äº¬äº¨éš†ä¼Ÿä¸šä¿¡æ¯å’¨è¯¢æœ‰é™è´£ä»»å…¬å¸",
    "åŒ—äº¬è‰ºè€˜è¯ºå¸ƒæŠ•èµ„ç®¡ç†å…¬å¸",
    "åŒ—äº¬ä¸­é‡‘ä»˜é€šç§‘æŠ€å‘å±•æœ‰é™å…¬å¸",
    "åŒ—äº¬è£æ–°å¹¿è‚²ç§‘æŠ€æœ‰é™å…¬å¸",
    "ä¸­é’ä¸­å…³æ‘è½¯ä»¶äººæ‰åŸºåœ°",
    "åŒ—äº¬ç™¾æµ‹æŠ€æœ¯å’¨è¯¢æœ‰é™å…¬å¸",
    "ä¸­é’ä¸­å…³æ‘è½¯ä»¶äººæ‰åŸºåœ°",
    "åŒ—äº¬å¾·æ¶¦æ•™è‚²",
    "è±èŒµç¯çƒæ•™è‚²ç§‘æŠ€(åŒ—äº¬)æœ‰é™å…¬å¸",
    "å“æ–°æ™ºè¶£(åŒ—äº¬)ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸",
    "åŒ—äº¬å®Œç¾ç©ºé—´æ•™è‚²ç§‘æŠ€æœ‰é™å…¬å¸",
    "åŒ—äº¬ç¿¡ç¿ æ•™è‚²ç§‘æŠ€æœ‰é™å…¬å¸",
    "AAAæ•™è‚²é›†å›¢",
    "å›½ä¿¡æ¸…è½¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "ä¸­è½¯å›½é™…æœ‰é™å…¬å¸",
    "å®Œç¾ç©ºé—´æ¸¸æˆåŠ¨æ¼«å­¦é™¢(å“æ–°æ€åˆ›)",
    "å°šå¾·æœºæ„",
    "äº‘åˆ›ç§‘æŠ€",
    "ä¸ŠåµŒåŸºåœ°",
    "ä¿¡ç›ˆè¾¾å…¬å¸",
    "æ·±åœ³è‡´è˜äº’è”ç½‘ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å…°çŸ³å›½é™…æœ‰é™å…¬å¸",
    "AADHKå…¬å¸",
    "æ·±åœ³é‡‘å¡å¼—æŠ•èµ„ç®¡ç†æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é˜¿å¡ç´¢èµ„è®¯è‚¡ä»½æœ‰é™å…¬å¸",
    "å—äº¬æ˜“åšä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ¹–å—åˆ›æ™ºé¾™åšä¿¡æ¯ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸",
];

function isTraining(brandName) {
    return trainingData.filter((item) => (item.includes(brandName) || brandName.includes(item))).length > 0;
}

const outsourceData = [
    "æ¶¦å»ºè‚¡ä»½",
    "CDCè½¯ä»¶",
    "NTTDATA",
    "ä¸‡å›½æ•°æ®æœåŠ¡",
    "ä¸‰ç»´å¤©åœ°",
    "ä¸Šæµ·ä¸­ä¿¡ä¿¡æ¯å‘å±•",
    "ä¸Šæµ·ä¸­è½¯åè…¾è½¯ä»¶ç³»ç»Ÿæœ‰é™å…¬å¸",
    "ä¸Šæµ·ä½©èˆªèˆªç©ºç§‘æŠ€",
    "ä¸Šæµ·å¤æ·±è“è½¯ä»¶è‚¡ä»½å…¬å¸",
    "ä¸Šæµ·å½§æ±‚ä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "ä¸Šæµ·å¾®åˆ›è½¯ä»¶",
    "ä¸Šæµ·å¾®åˆ›è½¯ä»¶è‚¡ä»½æœ‰é™å…¬å¸",
    "ä¸Šæµ·æ€èŠ®",
    "ä¸Šæµ·æ˜“å®è½¯ä»¶æœ‰é™å…¬å¸",
    "ä¸Šæµ·æ˜“ç«‹å¾·ä¿¡æ¯æŠ€æœ¯è‚¡ä»½æœ‰é™å…¬å¸",
    "ä¸Šæµ·æ™Ÿæ¬§",
    "ä¸Šæµ·æ±‰å¾—ä¿¡æ¯æŠ€æœ¯è‚¡ä»½æœ‰é™å…¬å¸",
    "ä¸Šæµ·æ±‰æœ”ä¿¡æ¯ç§‘æŠ€",
    "ä¸Šæµ·æµ©æ–¹",
    "ä¸Šæµ·æµ·ä¸‡ä¿¡æ¯ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸",
    "ä¸Šæµ·æµ·éš†",
    "ä¸Šæµ·è‰¾èè½¯ä»¶è‚¡ä»½æœ‰é™å…¬å¸",
    "ä¸–çºªæ’é€š",
    "ä¸œå—èé€š",
    "ä¸œè½¯é›†å›¢",
    "ä¸­ä¿¡ç½‘ç§‘",
    "ä¸­å…´è½¯ä»¶",
    "ä¸­åšç ”ç©¶é™¢",
    "ä¸­å’Œè½¯ä»¶",
    "ä¸­å›½ä¿¡æ¯æŠ€æœ¯",
    "ä¸­æ’åšç‘",
    "ä¸­ç”µé‡‘ä¿¡(åŸæ–‡æ€æµ·è¾‰)",
    "ä¸­ç”µé‡‘ä¿¡/æ–‡æ€æµ·è¾‰(åŒ—äº¬ï¼‰",
    "ä¸­ç›ˆè“æµ·",
    "ä¸­ç§‘åˆ›è¾¾è½¯ä»¶",
    "ä¸­ç§‘è½¯",
    "ä¸­ç§‘è½¯(æ ¹æ®è¯„è®ºæ·»åŠ )",
    "ä¸­ç½‘åœ¨çº¿",
    "ä¸­è®¯è½¯ä»¶",
    "ä¸­è¯šç­¾",
    "ä¸­è½¯",
    "ä¸­è½¯å›½é™…",
    "ä¹…é›…ç§‘æŠ€",
    "ä¹Œé¸«ç§‘æŠ€ï¼ˆæ­å·ï¼‰",
    "ä¹åŸå…³è´¸",
    "ä¹æ´²è´¢åŠ¡",
    "äº‘å’Œæ©å¢¨",
    "äº‘è…¾æœªæ¥ï¼ˆè´µå·ï¼‰",
    "äºšä¿¡ç§‘æŠ€",
    "äºšä¿¡è”åˆ›",
    "äº¬åŒ—æ–¹",
    "äººç‘é›†å›¢",
    "äº¿åŠ›å‰å¥¥",
    "äº¿è¾¾ä¿¡æ¯ï¼ˆå¤§è¿ï¼‰",
    "ä¼—ä¿¡æ˜“æˆ",
    "ä½°é’§æˆ",
    "ä¿¡å¿…ä¼˜",
    "ä¿¡é›…è¾¾",
    "å¥å‹ç”ŸåŒ–",
    "å…ƒæ‹“ç§‘æŠ€",
    "å…ˆè¿›æ•°é€š",
    "å…¨é€Ÿåˆ›æƒ³ï¼ˆæ­å·ï¼‰",
    "å‡Œå¿—è½¯ä»¶",
    "å‡¯æ·å’¨è¯¢(ä¸­å›½)æœ‰é™å…¬å¸",
    "åˆ›åšå›½é™…",
    "å‰æµ·æ³°å¦ç§‘æŠ€ï¼ˆæ·±åœ³ï¼‰æœ‰é™å…¬å¸",
    "åŒ—äº¬äº‘æ ¸ç½‘ç»œ",
    "åŒ—äº¬äº‘æ ¸ç½‘ç»œè‚¡ä»½æœ‰é™å…¬å¸",
    "åŒ—äº¬åèƒœå¤©æˆ",
    "åŒ—äº¬åè·¯æ—¶ä»£",
    "åŒ—äº¬å¤©æ™¯éš†",
    "åŒ—äº¬å°–å³°",
    "åŒ—äº¬å¼€è¿è”åˆ",
    "åŒ—äº¬æŠ¤èˆª",
    "åŒ—äº¬æ–°æ€è½¯ä»¶æŠ€æœ¯æœ‰é™å…¬å¸",
    "åŒ—äº¬ç‚¹ç‚¹ä¼æœ",
    "åŒ—äº¬ç™¾èƒœæ‰¬è½¯ä»¶æŠ€æœ¯æœ‰é™å…¬å¸",
    "åŒ—äº¬é•¿äº®åˆåº¦ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "åŒ—ä¿¡æº",
    "åŒ—æ–¹ç§‘è¯š",
    "åŒ—æ˜è½¯ä»¶",
    "åŒ—é“¶é‡‘ç§‘",
    "åƒæ–¹ç§‘æŠ€",
    "åæ‹“æ•°ç ",
    "åè‹ç§‘æŠ€",
    "åè·¯æ—¶ä»£",
    "åé€šç§‘æŠ€",
    "åé“æ•°æ®å¤„ç†",
    "å“æœ›ä¿¡æ¯",
    "å—äº¬äº‘æ˜‡",
    "å—äº¬æ˜Šäº¦æº",
    "å—äº¬æ˜Ÿç©ºåœ¨çº¿",
    "å—äº¬ç»›é—¨ä¿¡æ¯ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸",
    "å—äº¬è¿ˆç‰¹æœ›",
    "å—äº¬é“¶è¡Œæ¶ˆè´¹é‡‘èä¸­å¿ƒ",
    "å—äº¬éº¦æ€ä¼¦",
    "å—å¤©ä¿¡æ¯",
    "å—å¨è½¯ä»¶",
    "åšå½¦ç§‘æŠ€",
    "åšæ‚¦ç§‘åˆ›",
    "åšæœ—è½¯ä»¶",
    "å°å­šç‘Ÿæ–¯æŠ€æœ¯ï¼ˆä¸­å›½ï¼‰æœ‰é™å…¬å¸",
    "åˆè‚¥å‡¯æ·",
    "åŒå’Œä¿¡æ¯",
    "å¯æ˜è½¯ä»¶",
    "å’Œä»ç§‘æŠ€",
    "å’šç“œç§‘æŠ€",
    "å››å·å‡†è¾¾ä¿¡æ¯ï¼ˆå››å·ï¼‰",
    "å››å·æ±‰ç§‘",
    "å››æ–¹ç²¾åˆ›ï¼ˆæ·±åœ³ï¼‰",
    "å›½ç¿ç§‘æŠ€",
    "åœ¨ä¿¡æ±‡é€š",
    "å¤æ·±è“è½¯ä»¶å¼€å‘",
    "å¤§å®‡å®™ä¿¡æ¯",
    "å¤§å±•ä¿¡æ¯ç§‘æŠ€ï¼ˆæ·±åœ³ï¼‰æœ‰é™å…¬å¸",
    "å¤§å±•ç§‘æŠ€",
    "å¤§æ±‰è½¯ä»¶",
    "å¤§è¿åä¿¡",
    "å¤§è¿æ–‡æ€æµ·è¾‰ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "å¤§è¿æ–¯é”ä¿¡æ¯æŠ€æœ¯å…¬å¸",
    "å¤©æ´¥å–œé¹Šå…±äº«ç§‘æŠ€",
    "å¤©é˜³ç§‘æŠ€",
    "å¥¥åšæ°å¤©",
    "å®‡ä¿¡æ˜“è¯š",
    "å®‡ä¿¡ç§‘æŠ€",
    "å®‰ç¡•ä¿¡æ¯",
    "å®‰ç¡•ä¿¡æ¯æŠ€æœ¯",
    "å®æ™ºç§‘æŠ€",
    "å¯ŒåŸºèé€š",
    "å¯Œå£«é€šä¿¡æ¯",
    "å°è‰äº’è”",
    "å±±ä¸œåŒ—æ˜å…¨ç¨‹ç‰©æµ",
    "å±¹é€šä¿¡æ¯ç§‘æŠ€",
    "å¹¿å·å‡¯æ³½åˆ©ï¼ˆéƒ¨åˆ†å¤–åŒ…ï¼‰",
    "å¹¿å·æºåˆ›ä¿¡æ¯",
    "å¹¿å·èµ›æ„ä¿¡æ¯ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸",
    "å¹¿å·è¿…ç»´è¿é”",
    "å¹¿è”è¾¾ï¼ˆåŒ—äº¬ï¼‰",
    "å¼€è¿è”åˆ",
    "å½©è®¯ç§‘æŠ€",
    "å¾—é€¸ä¿¡æ¯",
    "å¾®åˆ›è½¯ä»¶",
    "å¾·ç§‘ä¿¡æ¯",
    "å¾·ç§‘ä¿¡æ¯ï¼ˆæ·±åœ³ï¼‰",
    "æ’å®",
    "æ’ç”Ÿç”µå­",
    "æ…§åšäº‘é€š",
    "æ…§åšäº‘é€šï¼ˆåŒ—äº¬ï¼‰",
    "æ‡¿åè½¯ä»¶",
    "æ‹“ä¿è½¯ä»¶",
    "æ‹“ç»´ä¿¡æ¯",
    "æ®è¯´å·²ä¸æ˜¯å¤–åŒ…ï¼‰",
    "æ–‡æ€æµ·è¾‰",
    "æ–¯å‡¯",
    "æ–¯ç‰¹æ²ƒå…‹ï¼ˆThoughtWorkï¼‰",
    "æ–°å¤§é™†è½¯ä»¶",
    "æ–°å®‡è½¯ä»¶",
    "æ–°èšæ€",
    "æ–°è‡´è½¯ä»¶",
    "æ–¹å¤©ç§‘æŠ€",
    "æ—¥ç”µå“è¶Š",
    "æ—¶ä»£é“¶é€šï¼ˆæ­å·ï¼‰",
    "æ—¶ç©ºäº‘ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ˜ç•¥ç§‘æŠ€",
    "æ˜“å®è½¯ä»¶ï¼ˆæ·±åœ³ï¼‰",
    "æ˜“æ€åš",
    "æ˜“ç«‹å¾·ï¼ˆä¸Šæµ·ï¼‰",
    "æ˜“è”è¾¾ï¼ˆåŒ—äº¬ï¼‰",
    "æ˜“è¯šäº’åŠ¨ï¼ˆåŒ—äº¬ï¼‰",
    "æ™Ÿå³°è½¯ä»¶",
    "æ™®è”è½¯ä»¶",
    "æ™ºæ…§ç›¾",
    "æœ—æ–°ç§‘æŠ€",
    "æ­å·ç«¯ç‚¹ç§‘æŠ€",
    "æ­å·é¢å’Œ",
    "æŸ¯è±ç‰¹",
    "æ ¹æ®è¯„è®ºæ·»åŠ )",
    "æ­¦å¤§å‰å¥¥",
    "æ­¦æ±‰ä½°é’§æˆæŠ€æœ¯",
    "æ­¦æ±‰è½¯å¸è”åˆç§‘æŠ€",
    "æ°¸æ–°è§†åš",
    "æ±‡ä¿¡é‡‘æœ",
    "æ±‰å…‹æ—¶ä»£",
    "æ±‰å…‹æ—¶ä»£ï¼ˆåŒ—äº¬ï¼‰",
    "æ±‰å¾—ä¿¡æ¯ï¼ˆä¸Šæµ·ï¼‰",
    "æ±Ÿè‹å¤©é¼",
    "æ±Ÿè‹æ…§ä¸–è”ç½‘ç»œç§‘æŠ€",
    "æ±Ÿè‹æ¬§ç´¢è½¯ä»¶",
    "æ±Ÿè‹æ¶¦å’Œè½¯ä»¶",
    "æ±Ÿè‹çº¢ç½‘",
    "æ±Ÿè‹é¸¿ä¿¡",
    "æ³•æœ¬ä¿¡æ¯",
    "æ³›äºšä¿¡æ¯æŠ€æœ¯",
    "æ³°è±ªç§‘æŠ€è‚¡ä»½",
    "æ³°è±ªè½¯ä»¶",
    "æ³½ä½³ç§‘æŠ€ï¼ˆåŒ—äº¬æ³½ä½³ç§‘ç›Šç§‘æŠ€æœ‰é™å…¬å¸ï¼‰",
    "æµ™å¤§ç½‘æ–°Insigmaï¼ˆæ­å·ï¼‰ï¼ˆè¯·æ³¨æ„",
    "æµ™æ±Ÿå¤§å",
    "æµ™æ±Ÿå¸Œä¼˜",
    "æµ©é²¸æ™ºèƒ½",
    "æµ©é²¸ç§‘æŠ€",
    "æµ©é²¸ç§‘æŠ€(é˜¿é‡Œå¤–åŒ…",
    "æµªæ½®",
    "æµªæ½®é›†å›¢",
    "æµ·ä¸‡ç§‘æŠ€",
    "æµ·äº‘æ•°æ®",
    "æµ·é€šå®‰æ’ï¼ˆå¹¿ä¸œï¼‰",
    "æµ·éš†è½¯ä»¶",
    "æ¶¦å’Œ",
    "æ¶¦æ¨é‡‘è",
    "æ·±åœ³å…´èè”ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å››æ–¹ç²¾åˆ›èµ„è®¯è‚¡ä»½æœ‰é™å…¬å¸",
    "æ·±åœ³å››æ–¹ç²¾åˆ›èµ„è®¯è‚¡ä»½æœ‰é™å…¬å¸åŒ—äº¬åˆ†å…¬å¸",
    "æ·±åœ³å¤§å±•ä¿¡æ¯ç§‘æŠ€",
    "æ·±åœ³å®æ¶¦å…´ä¸š",
    "æ·±åœ³å¸‚å…ˆè¿›æ•°é€šèå®‰ä¿¡æ¯æŠ€æœ¯",
    "æ·±åœ³å¸‚åšå¥¥ç‰¹ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å¸ƒé›·æ³½ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚å¾·ç§‘ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ˜“æ€åšè½¯ä»¶æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚æ³•æœ¬ä¿¡æ¯æŠ€æœ¯è‚¡ä»½æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚ç´«å·è½¯ä»¶æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é‡‘å«ä¿¡",
    "æ·±åœ³å¸‚é•¿äº®ä¿æ³°ä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é•¿äº®æ ¸å¿ƒç§‘æŠ€æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é•¿äº®ç§‘æŠ€è‚¡ä»½æœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é›è”è®¡ç®—ç³»ç»Ÿæœ‰é™å…¬å¸",
    "æ·±åœ³å¸‚é›†ç›Šåˆ›æ–°ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³å¾·ç§‘ä¿¡æ¯æŠ€æœ¯",
    "æ·±åœ³æ€ç‰¹é¡º",
    "æ·±åœ³æ€¡åŒ–ç”µè„‘",
    "æ·±åœ³æ‹“ä¿",
    "æ·±åœ³æ˜“å®",
    "æ·±åœ³æ™ºæ…§ç›¾(åä»˜ä¿¡æ¯)",
    "æ·±åœ³ç´¢ä¿¡è¾¾æ•°æ®æŠ€æœ¯æœ‰é™å…¬å¸",
    "æ·±åœ³ç½‘æ–°æ–°æ€",
    "æ·±åœ³é“¶å…´ç§‘æŠ€å¼€å‘æœ‰é™å…¬å¸",
    "æ·±åœ³é›è”æŠ€æœ¯",
    "æ·±åœ³é’æ¡ç››å¤ç§‘æŠ€",
    "æ·±åœ³é¹å¼€ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "çˆ±æ€çˆ±",
    "ç‰¹åŠ›æƒ ",
    "çŒå®ç½‘",
    "ç‘å‹äº‘æ™ºç§‘æŠ€",
    "ç‘ç¥¥ç§‘æŠ€",
    "ç”³æœ´ä¿¡æ¯",
    "ç™¾å¾®ç§‘æŠ€",
    "ç›ˆè¾¾ä¿¡æ¯",
    "ç››å”ç§‘æŠ€",
    "ç››å®‰å¾·",
    "ç¿ä¿¡å¤©å’Œ",
    "ç¿è‡³å¤§æ•°æ®",
    "çŸ¥è¿ª",
    "çŸ©ç«‹ä¿¡æ¯",
    "çŸ³åŒ–ç›ˆç§‘",
    "ç¥å·ä¿¡æ¯",
    "ç¥å·æ•°ç ",
    "ç¥å·æ³°å²³ï¼ˆåŒ—äº¬ç¥å·æ³°å²³è½¯ä»¶è‚¡ä»½æœ‰é™å…¬å¸ï¼‰",
    "ç¦ç‘åšå¾·",
    "ç§‘å¤§å›½åˆ›è½¯ä»¶è‚¡ä»½å…¬å¸",
    "ç§‘è“è½¯ä»¶",
    "ç«‹æ€è¾°ç§‘æŠ€",
    "ç¬¬ä¸€çº¿å®‰è±",
    "ç²¾é”åŠ¨åŠ›",
    "ç´¢è¿ªæ–¯",
    "ç´«å·è½¯ä»¶",
    "ç´«é‡‘æ”¯ç‚¹",
    "çº¬åˆ›è½¯ä»¶",
    "ç»çº¬å›½é™…",
    "ç»›é—¨ç§‘æŠ€",
    "ç»´æ©è´ç‰¹",
    "ç»¿å’Œç”Ÿæ´»é€š",
    "ç¼–ç ç‹",
    "ç½‘æ–°åšåˆ›",
    "ç½‘æ–°æ–°æ€ï¼ˆæ·±åœ³ï¼‰",
    "è”åˆä¿¡æ¯",
    "è”æƒ³åˆ©æ³°ï¼ˆåŒ—äº¬ï¼‰",
    "è”è¿ªæ’æ˜Ÿ",
    "è‡´è¿œå®£å¤§",
    "è‰¾æ–¯å…‹é›·",
    "è‰¾èï¼ˆä¸Šæµ·ï¼‰",
    "è‹±æè½¯ä»¶å¼€å‘(å¤§è¿)",
    "è¯æ˜åº·å¾·",
    "è“å‡Œè½¯ä»¶",
    "èèˆªä¿¡æ¯",
    "è£•å®ç§‘æŠ€",
    "è¥¿å®‰åç‚ä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸",
    "è¥¿å®‰ç‚å…´",
    "è®¯æ–¹æŠ€æœ¯ï¼ˆæ·±åœ³ï¼‰",
    "è¯šè¿ˆç§‘æŠ€",
    "è¯ºèµ›è½¯ä»¶",
    "èµ›æ„ä¿¡æ¯ï¼ˆå¹¿å·ï¼‰",
    "èµ›ç§‘æ–¯",
    "èµ›è¿ªé€š",
    "èµ¢æ—¶èƒœï¼ˆåŒ—äº¬ï¼‰",
    "è½¯é€šåŠ¨åŠ›",
    "é€šåŠ¨åŠ›ä¿¡æ¯",
    "é€šé‚®é›†å›¢",
    "é‡‘æ–¯ç‘",
    "é‡‘æ¡¥ä¿¡æ¯ï¼ˆä¸Šæµ·ï¼‰",
    "é‡‘ç°ä»£",
    "é‡‘è‰²åå‹¤",
    "é‡‘è¯è‚¡ä»½",
    "é“¶ä¸°æ–°è",
    "é•¿äº®ç§‘æŠ€",
    "é˜¿ç±³å¾·",
    "éŸ³æ³°æ€",
    "é¡¶å°–ä¼ æ‰¿",
    "é¡¶ç‚¹è½¯ä»¶",
    "é¢†é›ç§‘æŠ€ï¼ˆåŒ—äº¬ï¼‰",
    "é£äº‘ç§‘æŠ€",
    "é©¬è¡¡è¾¾ä¿¡æ¯æŠ€æœ¯ï¼ˆä¸Šæµ·ï¼‰æœ‰é™å…¬å¸",
    "é«˜ä¼Ÿè¾¾",
    "éº¦äºšä¿¡",
    "éº¦æ€ä¼¦",
    "éº¦è‚¯é”¡",
    "é¼æ·è½¯ä»¶ï¼ˆä¸Šæµ·ï¼‰",
    "æ—¥ç”µå“è¶Šè½¯ä»¶",
    "ç¥å·æ•°ç é€šç”¨è½¯ä»¶",
    "å¼€ç›®ä½°é’§æˆ",
    "ST æ–°æµ·",
    "å¤©æºè¿ªç§‘",
    "å¡”å¡”",
    "æµ·å—é’¦è¯š",
    "ä¿¡å¿…ä¼˜Symbio",
    "æˆéƒ½ä¿¡å¿…ä¼˜ä¿¡æ¯æŠ€æœ¯æœ‰é™å…¬å¸",
    "ä¸Šæµ·ä»è”",
    "ä¸­ç”µé‡‘ä¿¡",
    "æè”è‚¡ä»½",
    "å¯è¿ªä¸‡ä¼—"
];

function isOutsource(brandName) {
    return outsourceData.filter((item) => (item.includes(brandName) || brandName.includes(item))).length > 0;
}

;(function () {
    if (typeof window.CustomEvent === "function") return false;

    function CustomEvent(event, params) {
        params = params || {bubbles: false, cancelable: false, detail: undefined};
        let evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
    }

    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;

})();
(function () {
    'use strict';

    let appStyleTag = document.createElement("style");
    appStyleTag.innerHTML = appCss;
    document.getElementsByTagName("head")[0].appendChild(appStyleTag);

    //æ‹¦æˆªAjax
    function ajaxEventTrigger(event) {
        let ajaxEvent = new CustomEvent(event, {detail: this});
        window.dispatchEvent(ajaxEvent);
    }

    let oldXHR = window.XMLHttpRequest;
    if (!oldXHR) return console.error('ä¸æ”¯æŒ XMLHttpRequestï¼ è¯·æ›´æ¢æœ€æ–°çš„ chrome æµè§ˆå™¨')

    function newXHR() {
        let realXHR = new oldXHR();

        realXHR.addEventListener('abort', function () {
            ajaxEventTrigger.call(this, 'ajaxAbort');
        }, false);
        realXHR.addEventListener('error', function () {
            ajaxEventTrigger.call(this, 'ajaxError');
        }, false);
        realXHR.addEventListener('load', function () {
            ajaxEventTrigger.call(this, 'ajaxLoad');
        }, false);
        realXHR.addEventListener('loadstart', function () {
            ajaxEventTrigger.call(this, 'ajaxLoadStart');
        }, false);
        realXHR.addEventListener('progress', function () {
            ajaxEventTrigger.call(this, 'ajaxProgress');
        }, false);
        realXHR.addEventListener('timeout', function () {
            ajaxEventTrigger.call(this, 'ajaxTimeout');
        }, false);
        realXHR.addEventListener('loadend', function () {
            ajaxEventTrigger.call(this, 'ajaxLoadEnd');
        }, false);
        realXHR.addEventListener('readystatechange', function () {
            ajaxEventTrigger.call(this, 'ajaxReadyStateChange');
        }, false);

        let send = realXHR.send;
        realXHR.send = function (...arg) {
            send.apply(realXHR, arg);
            realXHR.body = arg[0];
            ajaxEventTrigger.call(realXHR, 'ajaxSend');
        }

        let open = realXHR.open;
        realXHR.open = function (...arg) {
            open.apply(realXHR, arg)
            realXHR.method = arg[0];
            realXHR.orignUrl = arg[1];
            realXHR.async = arg[2];
            ajaxEventTrigger.call(realXHR, 'ajaxOpen');
        }

        let setRequestHeader = realXHR.setRequestHeader;
        realXHR.requestHeader = {};
        realXHR.setRequestHeader = function (name, value) {
            realXHR.requestHeader[name] = value;
            setRequestHeader.call(realXHR, name, value)
        }
        return realXHR;
    }

    newXHR.prototype = oldXHR.prototype;
    window.XMLHttpRequest = newXHR;

    window.addEventListener("ajaxGetData", function (e) {
        const data = e?.detail;
        if (!data) return;
        const responseURL = data?.responseURL;
        //é€»è¾‘ä¸»å…¥å£
        // boss ç›´è˜æ¥å£
        if (responseURL.indexOf("/search/joblist.json") !== -1) {
            handler.boss.handle(data?.response);
        }
        // æ™ºè”æ‹›è˜æ¥å£
        if (responseURL.indexOf("/search/positions") !== -1) {
            handler.zhilian.build().handle(data?.response);
        }
        // å‰ç¨‹æ— å¿§æ¥å£
        if (responseURL.indexOf("/api/job/search-pc") !== -1) {
            handler.job51.handle(data?.response);
        }

        // æ‹‰å‹¾ç½‘æ¥å£
        if (responseURL.indexOf("/jobs/v2/positionAjax.json") !== -1) {
            /**
             * Question: æ¥å£å“åº”æ˜¯åŠ å¯†çš„ï¼Œä¸ºä»€ä¹ˆè¿™é‡Œæ‹¿åˆ°çš„æ˜¯è§£å¯†åçš„ï¼Ÿ
             * æ‹‰å‹¾çš„åŠ å¯†æ˜¯è‡ªå·±é‡å†™äº† XMLHttpRequestï¼Œåœ¨ send å‰è¿›è¡ŒåŠ å¯†ï¼Œæ¥å—åˆ°å“åº”åè§£å¯†ï¼Œå†æ´¾å‘äº‹ä»¶å‡ºå»
             * ç”±äºæ‹‰å‹¾çš„é‡å†™åœ¨ proxyAjax ä¹‹å‰è¿è¡Œï¼Œæ‰€ä»¥è¿™é‡Œæ‹¿åˆ°çš„æ˜¯è§£å¯†åçš„æ•°æ®
             */
            handler.lagou.build().handle(data?.response);
        }
    });

    window.addEventListener("proxyScriptLoaded", async function (e) {
        if (location.host === "sou.zhaopin.com") {
            // æ™ºè”æ‹›è˜é¦–æ¬¡æ‰“å¼€
            const data = e?.detail?.zhipin?.initialState;
            handler.zhilian.build().handleFirstTimeOpen(data || {});
        }

        if (location.host === "www.lagou.com") {
            // æ‹‰å‹¾é¦–æ¬¡æ‰“å¼€
            const data = e?.detail?.lagou?.initialState;
            handler.lagou.build().handleFirstTimeOpen(data || {});
        }

    });
    // ç›‘å¬é¡µé¢çš„ajax
    window.addEventListener("ajaxReadyStateChange", function (e) {
        let xhr = e.detail;
        const data = {
            response: xhr?.response,
            responseType: xhr?.responseType,
            responseURL: xhr?.responseURL ? xhr.responseURL : xhr?.orignUrl,
            status: xhr?.status,
            statusText: xhr?.statusText,
            readyState: xhr?.readyState,
            withCredentials: xhr?.withCredentials,
        };
        if (xhr?.readyState == 4 && xhr?.status == 200) {
            // ç›´æ¥ç»™ xhrï¼Œapp.js æ”¶ä¸åˆ°ã€‚
            let event = new CustomEvent('ajaxGetData', {detail: data});
            window.dispatchEvent(event);
        }
    })

    //util
    // è½¬æ¢æ—¶é—´
    function convertTimeToHumanReadable(dateTime) {
        let date = dayjs(dateTime);
        let curDate = dayjs();

        // è®¡ç®—æ—¶é—´å·®å…±æœ‰å¤šå°‘ä¸ªåˆ†é’Ÿ
        let minC = curDate.diff(date, "minute", true);
        // è®¡ç®—æ—¶é—´å·®å…±æœ‰å¤šå°‘ä¸ªå°æ—¶
        let hourC = curDate.diff(date, "hour", true);
        // è®¡ç®—æ—¶é—´å·®å…±æœ‰å¤šå°‘ä¸ªå¤©
        let dayC = curDate.diff(date, "day", true);
        // è®¡ç®—æ—¶é—´å·®å…±æœ‰å¤šå°‘ä¸ªå‘¨
        let weekC = curDate.diff(date, "week", true);
        // è®¡ç®—æ—¶é—´å·®å…±æœ‰å¤šå°‘ä¸ªæœˆ
        let monthC = curDate.diff(date, "month", true);

        if (minC < 5) {
            return `åˆšåˆš`;
        } else if (minC < 60) {
            return `1å°æ—¶å†…`;
        } else if (hourC < 24) {
            return `1å¤©å†…`;
        } else if (dayC < 7) {
            return `${parseInt(dayC)}å¤©å†…`;
        } else if (monthC < 1) {
            return `${parseInt(Math.ceil(weekC))}å‘¨å†…`;
        } else if (monthC <= 2) {
            return `2ä¸ªæœˆå†…`;
        } else if (monthC <= 3) {
            return `3ä¸ªæœˆå†…`;
        } else {
            return "è¶…å‡º3ä¸ªæœˆ";
        }
    }

    function convertTimeOffsetToHumanReadable(dateTime) {
        let date = dayjs(dateTime);
        let curDate = dayjs();

        // è®¡ç®—æ—¶é—´å·®å…±æœ‰å¤šå°‘ä¸ªåˆ†é’Ÿ
        let minC = curDate.diff(date, "minute", true);
        // è®¡ç®—æ—¶é—´å·®å…±æœ‰å¤šå°‘ä¸ªå°æ—¶
        let hourC = curDate.diff(date, "hour", true);
        // è®¡ç®—æ—¶é—´å·®å…±æœ‰å¤šå°‘ä¸ªå¤©
        let dayC = curDate.diff(date, "day", true);
        // è®¡ç®—æ—¶é—´å·®å…±æœ‰å¤šå°‘ä¸ªæœˆ
        let monthC = curDate.diff(date, "month", true);

        if (minC < 1) {
            return `åˆšåˆš`;
        } else if (minC < 60) {
            return `${parseInt(minC)}åˆ†é’Ÿå‰`;
        } else if (hourC < 24) {
            return `${parseInt(hourC)}å°æ—¶å‰`;
        } else if (monthC < 1) {
            return `${parseInt(dayC)}å¤©å‰`;
        } else {
            return `${parseInt(monthC)}æœˆå‰`;
        }
    }

    function getRandomInt(max) {
        return Math.floor(Math.random() * max);
    }

    function debounce(fn, delay) {
        let timer = null;
        return function (...args) {
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                fn(...args);
            }, delay);
        };
    }

    // ä¸‹åˆ’çº¿è½¬æ¢é©¼å³°
    function toHump(name) {
        return name.replace(/\_(\w)/g, function (all, letter) {
            return letter.toUpperCase();
        });
    }

    // é©¼å³°è½¬æ¢ä¸‹åˆ’çº¿
    function toLine(name) {
        return name.replace(/([A-Z])/g, "_$1").toLowerCase();
    }

    /**
     * éšæœºç­‰å¾…
     * @param {*} delayTime ç­‰å¾…æ—¶é—´ï¼Œå•ä½ms
     * @param {*} randomRange éšæœºæ—¶é—´èŒƒå›´ï¼Œå•ä½ms
     * @returns
     */
    function randomDelay(delayTime, randomRange) {
        return new Promise((r) =>
            setTimeout(r, delayTime + getRandomInt(randomRange))
        );
    }

    function convertEmptyStringToNull(value) {
        if (value) {
            if (isEmpty(value) || isBlank(value)) {
                return null;
            } else {
                return value;
            }
        } else {
            return null;
        }
    }

    const isEmpty = (str) => !str?.length;

    function isBlank(str) {
        return !str || /^\s*$/.test(str);
    }


    //common
    const JOB_STATUS_DESC_NEWEST = {key: "æœ€æ–°", label: "æœ€æ–°", order: 0};
    const JOB_STATUS_DESC_RECRUITING = {
        key: "æ‹›è˜ä¸­",
        label: "æ‹›è˜ä¸­",
        order: 1,
    };
    const JOB_STATUS_DESC_UNKNOW = {label: "æœªçŸ¥", order: 2};

    const PLATFORM_BOSS = "BOSS";
    const PLATFORM_51JOB = "51JOB";
    const PLATFORM_ZHILIAN = "ZHILIAN";
    const PLATFORM_LAGOU = "LAGOU";
    const PLATFORM_JOBSDB = "JOBSDB";

    //common render
    function renderTimeTag(
        divElement,
        jobDTO,
        {jobStatusDesc, hrActiveTimeDesc, platform,hrName} = {}
    ) {
        if (jobDTO == null || jobDTO == undefined) {
            throw new Error("jobDTO is required");
        }
        //å¯¹å‘å¸ƒæ—¶é—´çš„å¤„ç†
        if (platform && platform == PLATFORM_BOSS) {
            let statusTag = null;
            //jobStatusDesc
            if (jobStatusDesc) {
                statusTag = document.createElement("span");
                let statusToTimeText = "";
                if (jobStatusDesc == JOB_STATUS_DESC_NEWEST) {
                    statusToTimeText = "ä¸€å‘¨å†…";
                    statusTag.innerHTML = "ã€ " + statusToTimeText + "å‘å¸ƒâ”ã€‘";
                    statusTag.title =
                        "å½“å‰æ‹›è˜çŠ¶æ€ã€" +
                        jobStatusDesc.label +
                        "ã€‘ï¼Œæ‹›è˜çŠ¶æ€ï¼šæœ€æ–°ï¼šä»£è¡¨ä¸€å‘¨å†…å‘å¸ƒï¼›æ‹›è˜ä¸­ï¼šä»£è¡¨å‘å¸ƒæ—¶é—´è¶…è¿‡ä¸€å‘¨";
                } else {
                    statusTag.innerHTML = "ã€å‘å¸ƒæ—¶é—´æœªçŸ¥ã€‘";
                }
                statusTag.classList.add("__time_tag_base_text_font");
                divElement.appendChild(statusTag);
            }
            //hrActiveTimeDesc for boss
            if (jobDTO.hrActiveTimeDesc) {
                let hrActiveTimeDescTag = document.createElement("span");

                // åˆ›å»ºåŒ…å«è¦åŒ¹é…çš„å­—ç¬¦ä¸²çš„æ•°ç»„
                const inactiveStatuses = [
                    "åŠå¹´å‰æ´»è·ƒ", "5æœˆå†…æ´»è·ƒ", "2æœˆå†…æ´»è·ƒ", "è¿‘åŠå¹´æ´»è·ƒ", "æœ¬æœˆæ´»è·ƒ", "4æœˆå†…æ´»è·ƒ", "3æœˆå†…æ´»è·ƒ"
                ];
                // ä½¿ç”¨ includes() æ¥æ£€æŸ¥æ˜¯å¦åŒ¹é…
                if (inactiveStatuses.includes(jobDTO.hrActiveTimeDesc)) {
                    hrActiveTimeDescTag.innerHTML = `ã€HR${jobDTO.hrName}å·²å»ä¸–ã€‘`;
                    hrActiveTimeDescTag.classList.add("__HR_dead_RIP");
                } else {
                    hrActiveTimeDescTag.innerHTML = `ã€HR-${jobDTO.hrActiveTimeDesc}ã€‘`;
                }

                hrActiveTimeDescTag.classList.add("__time_tag_base_text_font");
                divElement.appendChild(hrActiveTimeDescTag);
            }
        } else {
            //firstPublishTime
            let firstPublishTime = jobDTO.jobFirstPublishDatetime;
            if (firstPublishTime) {
                let firstPublishTimeTag = document.createElement("span");
                let firstPublishTimeHumanReadable = convertTimeToHumanReadable(
                    firstPublishTime
                );
                firstPublishTimeTag.innerHTML +=
                    "ã€" + firstPublishTimeHumanReadable + "å‘å¸ƒã€‘";
                firstPublishTimeTag.classList.add("__time_tag_base_text_font");
                divElement.appendChild(firstPublishTimeTag);
            }
        }
        //companyInfo
        let companyInfoTag = null;
        let companyInfoText = getCompanyInfoText(jobDTO.jobCompanyName);
        if (companyInfoText !== "") {
            companyInfoTag = document.createElement("span");
            companyInfoTag.innerHTML = companyInfoText;
            companyInfoTag.classList.add("__time_tag_base_text_font");
            divElement.appendChild(companyInfoTag);
        }

        divElement.classList.add("__time_tag_base_text_font");

        //ä¸ºtime tagæŸ“è‰²
        if (hrActiveTimeDesc) {
            // for boss
            //æ ¹æ®hræ´»è·ƒæ—¶é—´ä¸ºJobItemæŸ“è‰²
            let now = dayjs();
            let hrActiveDatetime = now.subtract(
                convertHrActiveTimeDescToOffsetTime(hrActiveTimeDesc),
                "millisecond"
            );
            divElement.style = getRenderTimeStyle(hrActiveDatetime);
        } else {
            divElement.style = getRenderTimeStyle(
                jobDTO.jobFirstPublishDatetime ?? null,
                jobStatusDesc
            );
        }
    }

    function setupSortJobItem(node) {
        if (!node) return;
        node.style = "display:flex;flex-direction: column;";
        //for zhilian
        const paginationNode = node.querySelector(".pagination");
        if (paginationNode) {
            paginationNode.style = "order:99999;";
        }
    }

    function createLoadingDOM(brandName, styleClass) {
        const div = document.createElement("div");
        div.classList.add(styleClass);
        div.classList.add("__loading_tag");
        renderTimeLoadingTag(div, brandName);
        return div;
    }

    function hiddenLoadingDOM() {
        let loadingTagList = document.querySelectorAll(".__loading_tag");
        if (loadingTagList) {
            loadingTagList.forEach((item) => {
                item.style = "visibility: hidden;";
            });
        }
    }

    function renderTimeLoadingTag(divElement, brandName) {
        let timeText = "ã€æ­£æŸ¥æ‰¾å‘å¸ƒæ—¶é—´âŒ›ï¸ã€‘";
        let text = timeText;
        text += getCompanyInfoText(brandName);
        divElement.style = getRenderTimeStyle();
        divElement.classList.add("__time_tag_base_text_font");
        divElement.innerHTML = text;
    }

    function getCompanyInfoText(brandName) {
        let text = "";
        const isOutsourceBrand = isOutsource(brandName);
        const isTrainingBrand = isTraining(brandName);
        if (isOutsourceBrand) {
            text += "ã€ç–‘ä¼¼å¤–åŒ…å…¬å¸ã€‘";
        }
        if (isTrainingBrand) {
            text += "ã€ç–‘ä¼¼åŸ¹è®­æœºæ„ã€‘";
        }
        if (isOutsourceBrand || isTrainingBrand) {
            text += "â›…";
        } else {
            text += "â˜€";
        }
        return text;
    }

    function getRenderTimeStyle(lastModifyTime, jobStatusDesc) {
        let offsetTimeDay;
        if (jobStatusDesc) {
            if (JOB_STATUS_DESC_NEWEST == jobStatusDesc) {
                offsetTimeDay = 7; // actual <7
            } else {
                offsetTimeDay = -1;
            }
        } else {
            if (lastModifyTime) {
                offsetTimeDay = dayjs().diff(dayjs(lastModifyTime), "day");
            } else {
                lastModifyTime = -1;
            }
        }
        return (
            "background-color: " + getTimeColorByOffsetTimeDay(offsetTimeDay) + ";"
        );
    }

    function getTimeColorByOffsetTimeDay(offsetTimeDay) {
        if (offsetTimeDay >= 0) {
            if (offsetTimeDay <= 7) {
                return "yellowgreen";
            } else if (offsetTimeDay <= 14) {
                return "green";
            } else if (offsetTimeDay <= 28) {
                return "orange";
            } else if (offsetTimeDay <= 56) {
                return "red";
            } else {
                return "gray";
            }
        } else {
            return "black";
        }
    }

    function renderSortJobItem(list, getListItem, {platform}) {
        const idAndSortIndexMap = new Map();
        //è®¾ç½®ä¸€ä¸ªæ ‡è¯†id,renderSortCustomId
        list.forEach((item, index) => {
            item.renderSortCustomId = index;
        });
        const sortList = JSON.parse(JSON.stringify(list));
        //sort firstBrowseDatetime
        sortList.sort((o1, o2) => {
            return (
                dayjs(o2.firstBrowseDatetime ?? null).valueOf() -
                dayjs(o1.firstBrowseDatetime ?? null).valueOf()
            );
        });
        if (platform == PLATFORM_BOSS) {
            //handle hr active time
            sortList.forEach((item) => {
                let hrActiveTimeOffsetTime = convertHrActiveTimeDescToOffsetTime(
                    item.hrActiveTimeDesc
                );
                item.hrActiveTimeOffsetTime = hrActiveTimeOffsetTime;
            });
            sortList.sort((o1, o2) => {
                return o1.hrActiveTimeOffsetTime - o2.hrActiveTimeOffsetTime;
            });
            sortList.sort((o1, o2) => {
                if (o2.jobStatusDesc && o1.jobStatusDesc) {
                    return o1.jobStatusDesc.order - o2.jobStatusDesc.order;
                } else {
                    return 0;
                }
            });
        } else {
            //sort firstPublishTime
            sortList.sort((o1, o2) => {
                return (
                    dayjs(o2.jobFirstPublishDatetime ?? null).valueOf() -
                    dayjs(o1.jobFirstPublishDatetime ?? null).valueOf()
                );
            });
        }
        sortList.forEach((item, index) => {
            idAndSortIndexMap.set(item.renderSortCustomId, index);
        });
        list.forEach((item, index) => {
            const dom = getListItem(index);
            let targetDom;
            if (platform) {
                if (PLATFORM_JOBSDB == platform) {
                    targetDom = dom.parentNode.parentNode;
                } else {
                    targetDom = dom;
                }
            } else {
                targetDom = dom;
            }
            let styleString =
                "order:" + idAndSortIndexMap.get(item.renderSortCustomId) + ";";
            targetDom.style = styleString;
        });
    }

    function renderFunctionPanel(list, getListItem, {platform} = {}) {
        list.forEach((item, index) => {
            const dom = getListItem(index);
            let targetDom;
            if (platform) {
                if (PLATFORM_JOBSDB == platform) {
                    targetDom = dom.parentNode.parentNode;
                } else {
                    targetDom = dom;
                }
            } else {
                targetDom = dom;
            }
            let functionPanelDiv = document.createElement("div");
            functionPanelDiv.classList.add(`__${platform}_function_panel`);
            targetDom.append(functionPanelDiv);
            functionPanelDiv.appendChild(createSearchCompanyLink(item.jobCompanyName));


        });
    }

    function createSearchCompanyLink(keyword) {
        const decode = encodeURIComponent(keyword);
        const dom = document.createElement("div");
        dom.className = "__company_info_search";
        let labelDiv = document.createElement("div");
        labelDiv.innerHTML = "å…¬å¸ä¿¡æ¯æŸ¥è¯¢ï¼š";
        dom.appendChild(labelDiv);
        dom.appendChild(
            createATag(
                `https://www.xiaohongshu.com/search_result?keyword=${decode}`,
                "å°çº¢ä¹¦"
            )
        );
        dom.appendChild(
            createATag(
                `https://maimai.cn/web/search_center?type=feed&query=${decode}&highlight=true`,
                "è„‰è„‰"
            )
        );
        dom.appendChild(
            createATag(`https://www.bing.com/search?q=${decode}`, "å¿…åº”")
        );
        dom.appendChild(
            createATag(`https://www.google.com/search?q=${decode}`, "Google")
        );
        dom.appendChild(
            createATag(`https://aiqicha.baidu.com/s?q=${decode}`, "çˆ±ä¼æŸ¥")
        );
        return dom;
    }

    function createATag(url, label) {
        let aTag = document.createElement("a");
        aTag.href = url;
        aTag.target = "_blank";
        aTag.ref = "noopener noreferrer";
        aTag.text = "ğŸ”" + label;
        aTag.addEventListener("click", (event) => {
            event.stopPropagation();
        });
        return aTag;
    }

    const ACTIVE_TIME_MATCH = /(?<num>[0-9\.]*)/;

    function convertHrActiveTimeDescToOffsetTime(hrActiveTimeDesc) {
        //æŒ‰åç§»é‡æŒ‰æ¯«ç§’ç®—
        let offsetTime;
        const halfYear = 86400000 * 30 * 6;
        const oneYear = 86400000 * 30 * 6 * 2;
        if (hrActiveTimeDesc) {
            let coefficient;
            if (hrActiveTimeDesc.includes("åˆšåˆš")) {
                offsetTime = 0;
            } else if (
                hrActiveTimeDesc.includes("æ—¥") ||
                hrActiveTimeDesc.includes("å‘¨") ||
                hrActiveTimeDesc.includes("æœˆ")
            ) {
                if (hrActiveTimeDesc.includes("æ—¥")) {
                    coefficient = 86400000;
                } else if (hrActiveTimeDesc.includes("å‘¨")) {
                    coefficient = 86400000 * 7;
                } else {
                    coefficient = 86400000 * 30;
                }
                let groups = hrActiveTimeDesc.match(ACTIVE_TIME_MATCH).groups;
                if (groups) {
                    let num = groups.num;
                    if (num) {
                        offsetTime = Number.parseInt(num) * coefficient;
                    } else {
                        //æ²¡æœ‰æ•°å­—ï¼Œåªæœ‰æœ¬å­—ï¼Œå¦‚ï¼šæœ¬å‘¨
                        offsetTime = 1 * coefficient;
                    }
                }
            } else if (hrActiveTimeDesc.includes("åŠå¹´å‰")) {
                offsetTime = halfYear;
            } else if (hrActiveTimeDesc.includes("è¿‘åŠå¹´")) {
                offsetTime = halfYear + 86400000;
            } else {
                offsetTime = oneYear;
            }
        } else {
            offsetTime = oneYear;
        }
        return offsetTime;
    }

    //data handle

    class Job {
        jobId;
        jobPlatform;
        jobUrl;
        jobName;
        jobCompanyName;
        jobLocationName;
        jobAddress;
        jobLongitude;
        jobLatitude;
        jobDescription;
        jobDegreeName;
        jobYear;
        jobSalaryMin;
        jobSalaryMax;
        jobSalaryTotalMonth;
        jobFirstPublishDatetime;
        bossName;
        bossCompanyName;
        bossPosition;
        createDatetime;
        updateDatetime
    }

    const SALARY_MATCH = /(?<min>[0-9\.]*)(?<minUnit>\D*)(?<max>[0-9\.]*)(?<maxUnit>\D*)(?<month>\d*)/;
    const JOB_YEAR_MATCH = /(?<min>[0-9\.]*)\D*(?<max>[0-9\.]*)/;

    async function getJobs(list, platform) {
        let jobs;
        if (PLATFORM_51JOB == platform) {
            jobs = handle51JobData(list);
        } else if (PLATFORM_BOSS == platform) {
            jobs = handleBossData(list);
        } else if (PLATFORM_ZHILIAN == platform) {
            jobs = handleZhilianData(list);
        } else if (PLATFORM_LAGOU == platform) {
            jobs = handleLagouData(list);
        } else if (PLATFORM_JOBSDB == platform) {
            jobs = handleJobsdb(list);
        } else {
            //skip
        }
        return jobs;
    }

    function genId(id, platform) {
        return platform + "_" + id;
    }

    function getJobIds(list, platform) {
        let result = [];
        for (let i = 0; i < list.length; i++) {
            let item = list[i];
            let jobId;
            if (PLATFORM_51JOB == platform) {
                jobId = item.jobId;
            } else if (PLATFORM_BOSS == platform) {
                jobId = item.value.zpData.jobInfo.encryptId;
            } else if (PLATFORM_ZHILIAN == platform) {
                jobId = item.jobId;
            } else if (PLATFORM_LAGOU == platform) {
                jobId = item.positionId;
            } else if (PLATFORM_JOBSDB == platform) {
                jobId = item.id;
            } else {
                //skip
            }
            result.push(genId(jobId, platform));
        }
        return result;
    }

    function handleJobsdb(list) {
        let jobs = [];
        for (let i = 0; i < list.length; i++) {
            let job = new Job();
            let item = list[i];
            const {id, jobUrl, title, jobDetail, listingDate, salary} = item;
            const {description: companyFullName} = item.advertiser;
            const {countryCode: city, label: positionAddress} = item.jobLocation;
            job.jobId = genId(id, PLATFORM_JOBSDB);
            job.jobPlatform = PLATFORM_JOBSDB;
            job.jobUrl = jobUrl;
            job.jobName = title;
            job.jobCompanyName = companyFullName;
            job.jobLocationName = city;
            job.jobAddress = positionAddress;
            job.jobLongitude = "";
            job.jobLatitude = "";
            job.jobDescription = jobDetail;
            job.jobDegreeName = "";
            job.jobYear = "";
            //handle salary
            //TODO salary content was complex,not handle all situation
            let targetSalary = salary.replaceAll(",", "").replaceAll("$", "");
            let groups = targetSalary.match(SALARY_MATCH)?.groups;
            if (groups) {
                let coefficient;
                let minUnitCoefficient;
                let maxUnitCoefficient;
                if (salary.includes("per hour")) {
                    //ä¸€å¤©8å°æ—¶å·¥ä½œ5å¤©
                    coefficient = 1 * 8 * 5;
                } else {
                    coefficient = 1;
                }
                if (groups?.minUnit.includes("k")) {
                    minUnitCoefficient = 1000;
                } else {
                    minUnitCoefficient = 1;
                }
                if (groups?.maxUnit.includes("k")) {
                    maxUnitCoefficient = 1000;
                } else {
                    maxUnitCoefficient = 1;
                }
                job.jobSalaryMin =
                    Number.parseInt(groups?.min) * coefficient * minUnitCoefficient;
                job.jobSalaryMax =
                    Number.parseInt(groups?.max) * coefficient * maxUnitCoefficient;
            } else {
                //skip
            }
            job.jobSalaryTotalMonth = null;
            job.jobFirstPublishDatetime = listingDate;
            job.bossName = "";
            job.bossCompanyName = companyFullName;
            job.bossPosition = null;
            jobs.push(job);
        }
        return jobs;
    }

    function handleLagouData(list) {
        let jobs = [];
        for (let i = 0; i < list.length; i++) {
            let job = new Job();
            let item = list[i];
            const {
                positionId,
                positionName,
                companyFullName,
                city,
                positionAddress,
                longitude,
                latitude,
                positionDetail,
                education,
                workYear,
                salary,
                publisherId,
                createTime,
            } = item;
            job.jobId = genId(positionId, PLATFORM_LAGOU);
            job.jobPlatform = PLATFORM_LAGOU;
            job.jobUrl = "https://www.lagou.com/wn/jobs/" + positionId + ".html";
            job.jobName = positionName;
            job.jobCompanyName = companyFullName;
            job.jobLocationName = city;
            job.jobAddress = positionAddress;
            job.jobLongitude = longitude;
            job.jobLatitude = latitude;
            job.jobDescription = positionDetail;
            job.jobDegreeName = education;
            //handle job year
            let jobYearGroups = workYear.match(JOB_YEAR_MATCH)?.groups;
            if (jobYearGroups) {
                job.jobYear = jobYearGroups.min;
            } else {
                //skip
            }
            //handle salary
            let groups = salary.match(SALARY_MATCH)?.groups;
            if (groups) {
                //unit is K,1K = 1000
                job.jobSalaryMin = Number.parseInt(groups?.min) * 1000;
                job.jobSalaryMax = Number.parseInt(groups?.max) * 1000;
            } else {
                //skip
            }
            job.jobSalaryTotalMonth = null;
            job.jobFirstPublishDatetime = createTime;
            job.bossName = publisherId;
            job.bossCompanyName = companyFullName;
            job.bossPosition = null;
            jobs.push(job);
        }
        return jobs;
    }

    function handleZhilianData(list) {
        let jobs = [];
        for (let i = 0; i < list.length; i++) {
            let job = new Job();
            let item = list[i];
            const {
                jobId,
                positionUrl,
                name,
                companyName,
                workCity,
                streetName,
                jobSummary,
                education,
                workingExp,
                salaryReal,
                firstPublishTime,
                salaryCount,
            } = item;
            const {staffName, hrJob} = item.staffCard;
            job.jobId = genId(jobId, PLATFORM_ZHILIAN);
            job.jobPlatform = PLATFORM_ZHILIAN;
            job.jobUrl = positionUrl;
            job.jobName = name;
            job.jobCompanyName = companyName;
            job.jobLocationName = workCity;
            job.jobAddress = streetName;
            job.jobLongitude = null;
            job.jobLatitude = null;
            job.jobDescription = jobSummary;
            job.jobDegreeName = education;
            //handle job year
            let jobYearGroups = workingExp.match(JOB_YEAR_MATCH)?.groups;
            if (jobYearGroups) {
                job.jobYear = jobYearGroups.min;
            } else {
                //skip
            }
            //handle salary
            let groups = salaryReal.match(SALARY_MATCH)?.groups;
            if (groups) {
                job.jobSalaryMin = Number.parseInt(groups?.min);
                job.jobSalaryMax = Number.parseInt(groups?.max);
            } else {
                //skip
            }
            //handle salary month
            let groupsSalaryCount = salaryCount.match(/(?<count>\d*)/)?.groups;
            job.jobSalaryTotalMonth = groupsSalaryCount.count;
            job.jobFirstPublishDatetime = firstPublishTime;
            job.bossName = staffName;
            job.bossCompanyName = companyName;
            job.bossPosition = hrJob;
            jobs.push(job);
        }
        return jobs;
    }

    function handleBossData(list) {
        let jobs = [];
        for (let i = 0; i < list.length; i++) {
            let job = new Job();
            let item = list[i];
            let zpData = item.value.zpData;
            const {brandName} = zpData.brandComInfo;
            const {name, brandName: bossBranchName, title} = zpData.bossInfo;
            const {
                encryptId,
                jobName,
                locationName,
                address,
                longitude,
                latitude,
                postDescription,
                degreeName,
                experienceName,
                salaryDesc,
                jobStatusDesc,
                jobUrl,
            } = zpData.jobInfo;
            job.jobId = genId(encryptId, PLATFORM_BOSS);
            job.jobPlatform = PLATFORM_BOSS;
            job.jobUrl = jobUrl;
            job.jobName = jobName;
            job.jobCompanyName = brandName;
            job.jobLocationName = locationName;
            job.jobAddress = address;
            job.jobLongitude = longitude;
            job.jobLatitude = latitude;
            job.jobDescription = postDescription;
            job.jobDegreeName = degreeName;
            //handle job year
            let jobYearGroups = experienceName.match(JOB_YEAR_MATCH)?.groups;
            if (jobYearGroups) {
                job.jobYear = jobYearGroups.min;
            } else {
                //skip
            }
            //handle salary
            let groups = salaryDesc.match(SALARY_MATCH)?.groups;
            if (groups) {
                let coefficient;
                if (salaryDesc.includes("å…ƒ") && salaryDesc.includes("å¤©")) {
                    //ä¸€ä¸ªæœˆç®—20å¤©å·¥ä½œæ—¥ï¼Œä¸€èˆ¬ä¸€å‘¨5å¤©ï¼Œæœ‰äº›ç‰¹æ®Šçš„6å¤©å·¥ä½œ
                    coefficient = 1 * 20;
                } else if (salaryDesc.includes("å…ƒ")) {
                    coefficient = 1;
                } else {
                    coefficient = 1000;
                }
                job.jobSalaryMin = Number.parseInt(groups?.min) * coefficient;
                job.jobSalaryMax = Number.parseInt(groups?.max) * coefficient;
                job.jobSalaryTotalMonth = groups?.month;
            } else {
                //skip
            }
            if (jobStatusDesc == JOB_STATUS_DESC_NEWEST.key) {
                //æ‹›è˜çŠ¶æ€ä¸ºæœ€æ–°ï¼Œåˆ™ä»£è¡¨ä¸€å‘¨å†…å‘å¸ƒçš„èŒä½ã€‚è®°å½•å…¥åº“çš„æ—¶é—´è®¾ç½®å–ä»Šå¤©é›¶ç‚¹ã€‚
                job.jobFirstPublishDatetime = dayjs(new Date()).startOf("day");
            } else {
                job.jobFirstPublishDatetime = null;
            }
            job.bossName = name;
            job.bossCompanyName = bossBranchName;
            job.bossPosition = title;
            jobs.push(job);
        }
        return jobs;
    }

    function handle51JobData(list) {
        let jobs = [];
        for (let i = 0; i < list.length; i++) {
            let job = new Job();
            let item = list[i];
            const {
                jobId,
                jobHref,
                jobName,
                fullCompanyName,
                jobAreaString,
                lat,
                lon,
                jobDescribe,
                degreeString,
                jobSalaryMin,
                jobSalaryMax,
                hrName,
                hrPosition,
                confirmDateString,
                provideSalaryString,
                workYearString,
            } = item;
            job.jobId = genId(jobId, PLATFORM_51JOB);
            job.jobPlatform = PLATFORM_51JOB;
            job.jobUrl = jobHref;
            job.jobName = jobName;
            job.jobCompanyName = fullCompanyName;
            job.jobLocationName = jobAreaString;
            job.jobAddress = jobAreaString;
            job.jobLongitude = lon;
            job.jobLatitude = lat;
            job.jobDescription = jobDescribe;
            job.jobDegreeName = degreeString;
            if (workYearString.endsWith("æ— éœ€ç»éªŒ")) {
                job.jobYear = 0;
            } else {
                let groups = workYearString.match(/(?<min>[0-9\.]*)/)?.groups;
                job.jobYear = groups.min;
            }
            job.jobSalaryMin = jobSalaryMin;
            job.jobSalaryMax = jobSalaryMax;
            if (provideSalaryString.endsWith("è–ª")) {
                let groups = provideSalaryString.match(SALARY_MATCH)?.groups;
                job.jobSalaryTotalMonth = groups.month;
            } else {
                job.jobSalaryTotalMont = "";
            }
            job.jobFirstPublishDatetime = confirmDateString;
            job.bossName = hrName;
            job.bossCompanyName = fullCompanyName;
            job.bossPosition = hrPosition;
            jobs.push(job);
        }
        return jobs;
    }
    function updateJobCards() {
      const jobCardWrappers = document.querySelectorAll('.job-card-wrapper');

      jobCardWrappers.forEach(wrapper => {
          // å¤„ç† HR å·²å»ä¸–çš„æè¿°
          const hrDeadDesc = wrapper.querySelector('.__HR_dead_RIP');
          if (hrDeadDesc) {
              const hrDeadDescText = hrDeadDesc.textContent;
              const nameMatch = hrDeadDescText.match(/HR(.*?)å·²å»ä¸–/);
              const hrName = nameMatch[1].trim();
              const jobCardFooter = wrapper.querySelector('.job-card-footer.clearfix');
              if (jobCardFooter) {
                  jobCardFooter.innerHTML = ''; // æ¸…ç©ºç°æœ‰å†…å®¹
                  const newParagraph = document.createElement('p'); // åˆ›å»ºæ–°çš„æ®µè½
                  newParagraph.innerHTML = `HR${hrName}å·²å»ä¸– | è¯·å…è®¸æˆ‘ä»¬åœ¨æ­¤çŒ®ä¸Šæœ€åçš„å‘Šåˆ«ï¼Œä»¥çºªå¿µå…¶åœ¨Bossç›´è˜ä¸­ç•™ä¸‹çš„è¶³è¿¹ä¸å›å¿†ğŸ•¯ğŸ•¯ğŸ•¯`;
                  jobCardFooter.appendChild(newParagraph); // å°†æ–°æ®µè½æ·»åŠ åˆ°footerä¸­
              }



              // å¤„ç†è–ªèµ„ä¿¡æ¯
              const salaryElement = wrapper.querySelector('.salary');
              if (salaryElement) {
                  const salaryText = salaryElement.textContent;
                  const salaryMatch = salaryText.match(/(\d+)\s*-\s*(\d+)\s*[kK]/);

                  if (salaryMatch) {
                      const minSalary = parseInt(salaryMatch[1], 10); // è–ªèµ„ä¸‹é™
                      const maxSalary = parseInt(salaryMatch[2], 10); // è–ªèµ„ä¸Šé™
                      const averageSalary = Math.floor((minSalary + maxSalary) / 2); // è®¡ç®—å¹³å‡è–ªèµ„

                      // æ ¹æ®å¹³å‡è–ªèµ„ç”ŸæˆèŠ±åœˆæ•°é‡ï¼Œæ¯ 2k ä¸€ä¸ªèŠ±åœˆ
                      const flowersCount = Math.floor(averageSalary / 2);
                      const flowers = 'ğŸµ'.repeat(flowersCount); // æ ¹æ®æ•°é‡ç”ŸæˆèŠ±åœˆ

                      salaryElement.textContent = `${flowers}`; // æ›´æ–°è–ªèµ„æ˜¾ç¤ºä¸ºèŠ±åœˆ
                  } else {
                      console.log("æœªåŒ¹é…åˆ°è–ªèµ„èŒƒå›´");
                  }
              }
              // å¤„ç†åœ°åŒºä¿¡æ¯
              const jobAreaMain = wrapper.querySelector('.job-title.clearfix');
              const jobAreaText = wrapper.querySelector('.job-area').textContent;
              jobAreaMain.innerHTML = '';
              const hrRest = document.createElement('p');
              hrRest.innerHTML = `${hrName}é•¿çœ äº${jobAreaText}`;
              jobAreaMain.appendChild(hrRest); // å°†æ–°æ®µè½æ·»åŠ åˆ°footerä¸­

              // å¤„ç†å…¬å¸ä¿¡æ¯
              const jobCompanyInfo = wrapper.querySelector('.company-tag-list');
              jobCompanyInfo.innerHTML = '';

              const companyStatus = [
                  { text: 'å…¬å¸èµ„é‡‘é“¾æ–­è£‚', className: 'company_bankrupt' },
                  { text: 'æ¿’ä¸´ç ´äº§', className: 'company_bankrupt' }
              ];
              companyStatus.forEach(status => {
                  const listItem = document.createElement('li');
                  listItem.innerHTML = status.text;
                  listItem.classList.add(status.className);
                  jobCompanyInfo.appendChild(listItem);
              });

          }

      });
  }

    //handler
    const handler = {
        job51: {
            handle: function (responseText) {
                try {
                    const data = JSON.parse(responseText);
                    mutationContainer().then((node) => {
                        setupSortJobItem(node);
                        parseData(data?.resultbody?.job?.items || [], getListByNode(node));
                    });
                } catch (err) {
                    console.error("è§£æ JSON å¤±è´¥", err);
                }

                // è·å–èŒä½åˆ—è¡¨èŠ‚ç‚¹
                function getListByNode(node) {
                    const children = node?.children;
                    return function getListItem(index) {
                        return children?.[index];
                    };
                }

                // ç›‘å¬ positionList-hook èŠ‚ç‚¹ï¼Œåˆ¤æ–­èŒä½åˆ—è¡¨æ˜¯å¦è¢«æŒ‚è½½
                function mutationContainer() {
                    return new Promise((resolve, reject) => {
                        const dom = document.querySelector(".joblist");
                        const observer = new MutationObserver(function (childList, obs) {
                            const isAdd = (childList || []).some((item) => {
                                return item?.addedNodes?.length > 0;
                            });
                            return isAdd ? resolve(dom) : reject("æœªæ‰¾åˆ°èŒä½åˆ—è¡¨");
                        });

                        observer.observe(dom, {
                            childList: true,
                            subtree: false,
                        });
                    });
                }

                // è§£ææ•°æ®ï¼Œæ’å…¥æ—¶é—´æ ‡ç­¾
                async function parseData(list, getListItem) {
                    list.forEach((item, index) => {
                        const dom = getListItem(index);
                        const {companyName} = item;
                        let loadingLastModifyTimeTag = createLoadingDOM(
                            companyName,
                            "__job51_time_tag"
                        );
                        dom.appendChild(loadingLastModifyTimeTag);
                    });

                    let jobDTOList = await getJobs(list, PLATFORM_51JOB);
                    list.forEach((item, index) => {
                        const dom = getListItem(index);
                        let tag = createDOM(jobDTOList[index]);
                        dom.appendChild(tag);
                    });
                    hiddenLoadingDOM();
                    renderSortJobItem(jobDTOList, getListItem, {platform: PLATFORM_51JOB});
                    renderFunctionPanel(jobDTOList, getListItem, {platform: PLATFORM_51JOB});
                }

                function createDOM(jobDTO) {
                    const div = document.createElement("div");
                    div.classList.add("__job51_time_tag");
                    renderTimeTag(div, jobDTO);
                    return div;
                }
            }
        },
        boss: {
            handle: function (responseText) {
                try {
                    const data = JSON.parse(responseText);
                    mutationContainer().then((node) => {
                        setupSortJobItem(node);
                        parseBossData(data?.zpData?.jobList || [], getListByNode(node));
                        onlineFilter();
                    });
                    return;
                } catch (err) {
                    console.error("è§£æ JSON å¤±è´¥", err);
                }

                // è·å–èŒä½åˆ—è¡¨èŠ‚ç‚¹
                function getListByNode(node) {
                    const children = node?.children;
                    return function getListItem(index) {
                        return children?.[index];
                    };
                }

                // ç›‘å¬ search-job-result èŠ‚ç‚¹ï¼Œåˆ¤æ–­èŒä½åˆ—è¡¨æ˜¯å¦è¢«æŒ‚è½½
                function mutationContainer() {
                    return new Promise((resolve, reject) => {
                        const dom = document.querySelector(".search-job-result");
                        const observer = new MutationObserver(function (childList, obs) {
                            (childList || []).forEach((item) => {
                                const {addedNodes} = item;
                                if (addedNodes && addedNodes.length > 0) {
                                    addedNodes.forEach((node) => {
                                        const {className} = node;
                                        if (className === "job-list-box") {
                                            observer.disconnect();
                                            resolve(node);
                                        }
                                    });
                                }
                            });
                            return reject("æœªæ‰¾åˆ°èŒä½åˆ—è¡¨");
                        });

                        observer.observe(dom, {
                            childList: true,
                            subtree: false,
                        });
                    });
                }

                function convertJobStatusDesc(statusText) {
                    if (statusText == JOB_STATUS_DESC_NEWEST.key) {
                        return JOB_STATUS_DESC_NEWEST;
                    } else if (statusText == JOB_STATUS_DESC_RECRUITING.key) {
                        return JOB_STATUS_DESC_RECRUITING;
                    } else {
                        return JOB_STATUS_DESC_UNKNOW;
                    }
                }

                // è§£ææ•°æ®ï¼Œæ’å…¥æ—¶é—´æ ‡ç­¾
                function parseBossData(list, getListItem) {
                    const apiUrlList = [];
                    const urlList = [];
                    list.forEach((item, index) => {
                        const {brandName, securityId} = item;
                        const dom = getListItem(index);
                        //apiUrl
                        let pureJobItemDetailApiUrl =
                            "https://www.zhipin.com/wapi/zpgeek/job/detail.json?securityId=" +
                            securityId;
                        apiUrlList.push(pureJobItemDetailApiUrl);
                        //jobUrl
                        const jobItemDetailUrl = dom
                            .querySelector(".job-card-body")
                            .querySelector(".job-card-left").href;
                        const url = new URL(jobItemDetailUrl);
                        let pureJobItemDetailUrl = url.origin + url.pathname;
                        urlList.push(pureJobItemDetailUrl);

                        let loadingLastModifyTimeTag = createLoadingDOM(
                            brandName,
                            "__boss_time_tag"
                        );
                        dom.appendChild(loadingLastModifyTimeTag);
                    });
                    const promiseList = apiUrlList.map(async (url, index) => {
                        const DELAY_FETCH_TIME = 75; //ms
                        const DELAY_FETCH_TIME_RANDOM_OFFSET = 50; //ms
                        await randomDelay(DELAY_FETCH_TIME * index, DELAY_FETCH_TIME_RANDOM_OFFSET); // é¿å…é¢‘ç¹è¯·æ±‚è§¦å‘é£æ§
                        const response = await fetch(url);
                        const result = await response.json();
                        return result;
                    });

                    Promise.allSettled(promiseList)
                        .then(async (jsonList) => {
                            let jobDTOList = [];
                            jsonList.forEach((item, index) => {
                                item.value.zpData.jobInfo.jobUrl = urlList[index];
                            });

                            jobDTOList = await getJobs(jsonList, PLATFORM_BOSS);
                            const lastModifyTimeList = [];
                            const jobStatusDescList = [];
                            const hrActiveTimeDescList = [];
                            const hrNameList = [];
                            jsonList.forEach((item, index) => {
                                lastModifyTimeList.push(
                                    dayjs(item.value?.zpData?.brandComInfo?.activeTime)
                                );
                                let jobStatus = convertJobStatusDesc(
                                    item.value?.zpData?.jobInfo?.jobStatusDesc
                                );
                                jobStatusDescList.push(jobStatus);

//                                console.log(item.value);
//                                console.log(item.value?.zpData);
//                                console.log(item.value?.zpData?.bossInfo);

                                let hrName = item.value?.zpData?.bossInfo?.name;
                                hrNameList.push(hrName);
//                                console.log(hrNameList);
                                //é¢å¤–é’ˆå¯¹BOSSå¹³å°ï¼Œä¸ºåé¢çš„æ’åºåšå‡†å¤‡
                                jobDTOList[index].jobStatusDesc = jobStatus;
                                let hrActiveTimeDesc = item.value?.zpData?.bossInfo?.activeTimeDesc;
                                hrActiveTimeDescList.push(hrActiveTimeDesc);
                                //é¢å¤–é’ˆå¯¹BOSSå¹³å°ï¼Œä¸ºåé¢çš„æ’åºåšå‡†å¤‡
                                jobDTOList[index].hrActiveTimeDesc = hrActiveTimeDesc;

                                jobDTOList[index].hrName = hrName;
                            });

                            list.forEach((item, index) => {
                                const dom = getListItem(index);
                                let tag = createDOM(
                                    jobDTOList[index],
                                    hrActiveTimeDescList[index],
                                    jobStatusDescList[index],
                                    hrNameList[index],
                                );
                                dom.appendChild(tag);
                            });
                            hiddenLoadingDOM();
                            renderSortJobItem(jobDTOList, getListItem, {platform: PLATFORM_BOSS});
                            renderFunctionPanel(jobDTOList, getListItem, {platform: PLATFORM_BOSS});
                            updateJobCards();
                        })
                        .catch((error) => {
                            console.log(error);
                            hiddenLoadingDOM();
                        });
                }

                function createDOM(jobDTO, hrActiveTimeDesc, jobStatusDesc,hrName) {
                    const div = document.createElement("div");
                    div.classList.add("__boss_time_tag");
                    renderTimeTag(div, jobDTO, {
                        hrActiveTimeDesc: hrActiveTimeDesc,
                        jobStatusDesc: jobStatusDesc,
                        platform: PLATFORM_BOSS,
                        hrName:hrName,
                    });
                    return div;
                }

                function onlineFilter() {
                    const bfEle = document.querySelector('.__boss_filter.condition-filter-select');
                    if (bfEle) {
                        _console('1. bfEle å·²ç»å­˜åœ¨');
                        // å…ˆç§»é™¤é€‰ä¸­æ ·å¼
                        bfEle.classList.remove('is-select');
                    } else {
                        // ä¸å­˜åœ¨åˆ™åˆ›å»ºå¹¶æ·»åŠ åˆ°DOMæ ‘ä¸­
                        try {
                            createFilter();
                        } catch (error) {
                            _console('æ–°å¢ç­›é€‰å‡ºé”™', error);
                        }
                    }
                }

                function _console() {
                    console.log(...arguments)
                }

                // åˆ›å»ºfilterè¿‡æ»¤æ‹›è˜äººåœ¨çº¿çš„job
                function createFilter() {
                    _console('2. bfEle ä¸å­˜åœ¨ï¼Œæ‰§è¡Œæ·»åŠ ');

                    let newFilterNode = document.createElement('div');
                    newFilterNode.innerHTML = `<div class="current-select">
        <span class="placeholder-text">æ‹›è˜äººåœ¨çº¿</span>
    </div>`;
                    newFilterNode.classList.add('condition-filter-select', '__boss_filter');

                    // ç»‘å®šç‚¹å‡»äº‹ä»¶
                    newFilterNode.addEventListener('click', function (e) {
                        e.stopPropagation();

                        let filterEle = e.currentTarget;
                        const isSelected = filterEle.classList.contains('is-select');
                        if (isSelected) {
                            filterEle.classList.remove('is-select');
                        } else {
                            filterEle.classList.add('is-select');
                        }
                        Array.from(document.querySelectorAll('.search-job-result .job-card-wrapper')).map(node => {
                            const isOnline = node.getElementsByClassName('boss-online-tag').length !== 0;
                            if (isSelected) {
                                node.classList.remove('__boss_filter_result-hidden');
                            } else {
                                !isOnline && node.classList.add('__boss_filter_result-hidden');
                            }
                        });

                    });

                    // æ’å…¥åˆ°çˆ¶å…ƒç´  .search-condition-wrapper æœ€åä¸€ä¸ªå…ƒç´ ä¹‹å‰
                    let parentNode = document.querySelector('.search-condition-wrapper');

                    if (parentNode !== null) {
                        let lastChild = parentNode.lastChild;
                        parentNode.insertBefore(newFilterNode, lastChild);
                    } else {
                        _console('3. parentNode ä¸å­˜åœ¨ï¼Œæ— æ³•æ’å…¥filter');
                    }
                }
            }
        },
        zhilian: {
            build: function () {
                // è·å–èŒä½åˆ—è¡¨èŠ‚ç‚¹
                function getListByNode(node) {
                    const children = node?.children;
                    return function getListItem(index) {
                        return children?.[index];
                    };
                }

                // ç›‘å¬ positionList-hook èŠ‚ç‚¹ï¼Œåˆ¤æ–­èŒä½åˆ—è¡¨æ˜¯å¦è¢«æŒ‚è½½
                function mutationContainer() {
                    return new Promise((resolve, reject) => {
                        const dom = document.querySelector(".positionlist__list");
                        const observer = new MutationObserver(function (childList) {
                            const isAdd = (childList || []).some((item) => {
                                return item?.addedNodes?.length > 0;
                            });
                            return isAdd ? resolve(dom) : reject("æœªæ‰¾åˆ°èŒä½åˆ—è¡¨");
                        });

                        observer.observe(dom, {
                            childList: true,
                            subtree: false,
                        });
                    });
                }

                // è§£ææ•°æ®ï¼Œæ’å…¥æ—¶é—´æ ‡ç­¾
                async function parseZhilianData(list, getListItem) {
                    list.forEach((item, index) => {
                        const dom = getListItem(index);
                        const {companyName} = item;
                        let loadingLastModifyTimeTag = createLoadingDOM(
                            companyName,
                            "__zhilian_time_tag"
                        );
                        dom.appendChild(loadingLastModifyTimeTag);
                    });

                    let jobDTOList = await getJobs(list, PLATFORM_ZHILIAN);
                    list.forEach((item, index) => {
                        const dom = getListItem(index);
                        let tag = createDOM(jobDTOList[index]);
                        dom.appendChild(tag);
                    });
                    hiddenLoadingDOM();
                    renderSortJobItem(jobDTOList, getListItem, {platform: PLATFORM_ZHILIAN});
                    renderFunctionPanel(jobDTOList, getListItem, {platform: PLATFORM_ZHILIAN});
                }

                function createDOM(jobDTO) {
                    const div = document.createElement("div");
                    div.classList.add("__zhilian_time_tag");
                    renderTimeTag(div, jobDTO);
                    return div;
                }

                return {
                    handle: function (responseText) {
                        try {
                            const data = JSON.parse(responseText);
                            mutationContainer().then((node) => {
                                setupSortJobItem(node);
                                parseZhilianData(data?.data?.list || [], getListByNode(node));
                            });
                        } catch (err) {
                            console.error("è§£æ JSON å¤±è´¥", err);
                        }
                    },
                    handleFirstTimeOpen: async function (data) {
                        const dom = document.querySelector(".positionlist__list");
                        setupSortJobItem(dom);
                        const children = dom?.children;
                        const {positionList = []} = data;
                        if (!children || !positionList || positionList.lenth === 0) return;
                        positionList.forEach((item, index) => {
                            const dom = children?.[index];
                            const {companyName} = item;
                            let loadingLastModifyTimeTag = createLoadingDOM(
                                companyName,
                                "__zhilian_time_tag"
                            );
                            dom.appendChild(loadingLastModifyTimeTag);
                        });
                        let jobDTOList = await getJobs(positionList, PLATFORM_ZHILIAN);
                        positionList.forEach((item, index) => {
                            const dom = children?.[index];
                            if (!dom) return;

                            let tag = createDOM(jobDTOList[index]);
                            dom.appendChild(tag);
                        });
                        hiddenLoadingDOM();
                        renderSortJobItem(
                            jobDTOList,
                            (index) => {
                                return children?.[index];
                            },
                            {platform: PLATFORM_ZHILIAN}
                        );
                        renderFunctionPanel(
                            jobDTOList,
                            (index) => {
                                return children?.[index];
                            },
                            {platform: PLATFORM_ZHILIAN}
                        );
                    },
                };

            }
        },
        lagou: {
            build: function () {
                function getListValue(data = {}) {
                    return ["content", "positionResult", "result"].reduce((value, key) => {
                        return value ? value?.[key] : undefined;
                    }, data);
                }

                // è·å–èŒä½åˆ—è¡¨èŠ‚ç‚¹
                function getListByNode(node) {
                    const children = node?.children;
                    return function getListItem(index) {
                        return children?.[index];
                    };
                }

                // ç›‘å¬èŠ‚ç‚¹ï¼Œåˆ¤æ–­èŒä½åˆ—è¡¨æ˜¯å¦è¢«æŒ‚è½½
                function mutationContainer() {
                    return new Promise((resolve, reject) => {
                        const dom = document.getElementById("jobList");
                        // é¦–æ¬¡åˆ·æ–°é¡µé¢çš„æ—¶å€™ä¼šè§¦å‘å¤šæ¬¡ï¼Œæ‰€ä»¥åŠ ä¸Š debounce
                        const observer = new MutationObserver(
                            debounce(function (childList) {
                                // æ‹‰å‹¾çš„é¡µé¢ä¼šè§¦å‘å¤šæ¬¡ï¼Œéƒ½æ˜¯å…ˆåˆ é™¤ jobList èŠ‚ç‚¹ï¼Œå†æ·»åŠ å›å»
                                const isAdd = (childList || []).some((item) => {
                                    return item?.addedNodes?.length > 0;
                                });
                                return isAdd
                                    ? resolve(dom.querySelector(".list__YibNq"))
                                    : reject("æœªæ‰¾åˆ°èŒä½åˆ—è¡¨");
                            }, 1000)
                        );

                        observer.observe(dom, {
                            childList: true,
                            subtree: false,
                        });
                    });
                }

                // è§£ææ•°æ®ï¼Œæ’å…¥æ—¶é—´æ ‡ç­¾
                async function parseLaGouData(list, getListItem) {
                    list.forEach((item, index) => {
                        const dom = getListItem(index);
                        const {companyShortName} = item;
                        let loadingLastModifyTimeTag = createLoadingDOM(
                            companyShortName,
                            "__zhipin_time_tag"
                        );
                        dom.appendChild(loadingLastModifyTimeTag);
                    });

                    let jobDTOList = await getJobs(list, PLATFORM_LAGOU);
                    list.forEach((item, index) => {
                        const dom = getListItem(index);
                        let tag = createDOM(jobDTOList[index]);
                        dom.appendChild(tag);
                    });
                    hiddenLoadingDOM();
                    renderSortJobItem(jobDTOList, getListItem, {platform: PLATFORM_LAGOU});
                    renderFunctionPanel(jobDTOList, getListItem, {platform: PLATFORM_LAGOU});
                }

                function createDOM(jobDTO) {
                    const div = document.createElement("div");
                    div.classList.add("__zhipin_time_tag");
                    renderTimeTag(div, jobDTO);
                    return div;
                }

                return {
                    handle: function (responseText) {
                        try {
                            const data = JSON.parse(responseText);
                            mutationContainer().then((node) => {
                                setupSortJobItem(node); // æ·»åŠ  flex æ ·å¼ï¼Œä»¥ä¾¿åç»­ç”¨ order è¿›è¡Œæ’åº
                                parseLaGouData(getListValue(data) || [], getListByNode(node));
                            });
                        } catch (err) {
                            console.error("è§£æ JSON å¤±è´¥", err);
                        }
                    },
                    handleFirstTimeOpen: async function (data) {
                        mutationContainer().then(async (dom) => {
                            setupSortJobItem(dom);
                            const children = dom?.children;
                            const list = getListValue(data?.props?.pageProps?.initData) || [];
                            // è¿™é‡Œå¯ä»¥æŸ¥çœ‹å…·ä½“job listä¿¡æ¯
                            // console.log(list);
                            if (!children || !list || list.lenth === 0) return;
                            list.forEach((item, index) => {
                                const dom = children?.[index];
                                const {companyShortName} = item;
                                let loadingLastModifyTimeTag = createLoadingDOM(
                                    companyShortName,
                                    "__zhipin_time_tag"
                                );
                                dom.appendChild(loadingLastModifyTimeTag);
                            });
                            let jobDTOList = await getJobs(list, PLATFORM_LAGOU);
                            list.forEach((item, index) => {
                                const dom = children?.[index];
                                if (!dom) return;

                                let tag = createDOM(jobDTOList[index]);
                                dom.appendChild(tag);
                            });
                            hiddenLoadingDOM();
                            renderSortJobItem(
                                jobDTOList,
                                (index) => {
                                    return children?.[index];
                                },
                                {platform: PLATFORM_LAGOU}
                            );
                            renderFunctionPanel(
                                jobDTOList,
                                (index) => {
                                    return children?.[index];
                                },
                                {platform: PLATFORM_LAGOU}
                            );
                        });
                    },
                };
            }
        }
    }

})();
;(function () {
    // ç”±äºæ³¨å…¥è„šæœ¬çš„æ—¶å€™ DOMContentLoaded å·²ç»è§¦å‘ï¼Œç›‘å¬ä¸åˆ°
    // proxy è„šæœ¬å·²åŠ è½½ï¼Œå‘é€äº‹ä»¶
    let event = new CustomEvent('proxyScriptLoaded', {
        detail: {
            zhipin: {
                initialState: window.__INITIAL_STATE__
            },
            lagou: {
                initialState: window.__NEXT_DATA__
            }
        }
    });
    window.dispatchEvent(event);
})();

