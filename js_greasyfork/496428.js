// ==UserScript==
// @name         Symfony 翻译文档 security.html
// @namespace    fireloong
// @version      0.1.2
// @description  翻译文档 security.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/security.html
// @match        https://symfony.com/doc/6.4/security.html
// @match        https://symfony.com/doc/7.1/security.html
// @match        https://symfony.com/doc/7.2/security.html
// @match        https://symfony.com/doc/current/security.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/496428/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20securityhtml.user.js
// @updateURL https://update.greasyfork.org/scripts/496428/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20securityhtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates_li = {
        'Form Login': '表单登录',
        'JSON Login': 'JSON 登录',
        'HTTP Basic': 'HTTP 基本认证',
        'Login Link': '登录链接',
        'X.509 Client Certificates': 'X.509 客户端证书',
        'Remote users': '远程用户',
        'Custom Authenticators': '自定义身份验证器',
        'Password Hashing and Verification': '密码哈希和验证',
        'Authenticating against an LDAP server': '对 LDAP 服务器进行身份验证',
        'How to Add "Remember Me" Login Functionality': '如何添加“记住我”登录功能',
        'How to Impersonate a User': '如何模拟用户身份',
        'How to Create and Enable Custom User Checkers': '如何创建和启用自定义用户检查器',
        'How to Restrict Firewalls to a Request': '如何限制防火墙到某个请求',
        'How to Implement CSRF Protection': '如何实现 CSRF 保护',
        'Customizing the Form Login Authenticator Responses': '自定义表单登录身份验证器响应',
        'How to Write a Custom Authenticator': '如何编写自定义身份验证器',
        'The Entry Point: Helping Users Start Authentication': '入口点：帮助用户开始身份验证',
        'How to Use Voters to Check User Permissions': '如何使用 Voters 来检查用户权限',
        'How Does the Security access_control Work?': '安全访问控制是如何工作的？',
        'Using Expressions in Security Access Controls': '在安全访问控制中使用表达式',
        'How to Customize Access Denied Responses': '如何自定义访问被拒绝响应',
        'How to Force HTTPS or HTTP for different URLs': '如何为不同的 URL 强制使用 HTTPS 或 HTTP'
    };
    let m = 0;
    $('article > .section li > a').each(function(i,v){
        if(translates_li.hasOwnProperty($(this).text())) {
            $(this).html(translates_li[$(this).text()]);
        }
    });

    const translates = {
        'Security': '安全',
        'Symfony provides many tools to secure your application. Some HTTP-related\nsecurity tools, like secure session cookies and\nCSRF protection are provided by default. The\nSecurityBundle, which you will learn about in this guide, provides all\nauthentication and authorization features needed to secure your\napplication.': 'Symfony 提供了许多工具来保护你的应用程序。一些与 HTTP 相关的安全工具，如<a href="session.html" class="reference internal">安全的会话 cookie</a> 和 <a href="security/csrf.html" class="reference internal">CSRF 保护</a>，都是默认提供的。在本指南中，你将了解到的 SecurityBundle 提供了保护你的应用程序所需的所有身份验证和授权功能。',
        'To get started, install the SecurityBundle:': '要开始，请先安装 SecurityBundle：',
        'If you have Symfony Flex installed, this also\ncreates a security.yaml configuration file for you:': '如果你已经安装了 <a href="setup.html#symfony-flex" class="reference internal">Symfony Flex</a>，它还会为你创建一个 <code translate="no" class="notranslate">security.yaml</code> 配置文件：',
        "That's a lot of config! In the next sections, the three main elements are\ndiscussed:": '这有很多配置！在接下来的部分中，将讨论三个主要元素：',
        'The User (providers)': '<a href="security.html#the-user" class="reference internal">用户</a> (<code translate="no" class="notranslate">providers</code>)',
        '\n                            Any secured section of your application needs some concept of\na user. The user provider loads users from any storage (e.g. the\ndatabase) based on a "user identifier" (e.g. the user\'s email address);\n                    ': '你的应用程序的任何安全部分都需要一些用户的概念。用户提供者基于“用户标识符”（例如用户的电子邮件地址）从任何存储（例如数据库）中加载用户；',
        'The Firewall & Authenticating Users (firewalls)': '<a href="security.html#the-firewall" class="reference internal">防火墙</a> &amp; <a href="security.html#authenticating-users" class="reference internal">用户认证</a> (<code translate="no" class="notranslate">firewalls</code>)',
        '\n                            The firewall is the core of securing your application. Every request\nwithin the firewall is checked if it needs an authenticated user. The\nfirewall also takes care of authenticating this user (e.g. using a\nlogin form);\n                    ': '防火墙是保护你的应用程序的核心。防火墙内的每个请求都会检查是否需要经过身份验证的用户。防火墙还负责验证此用户（例如，使用登录表单）；',
        'Access Control (Authorization) (access_control)': '<a href="security.html#access-control-authorization" class="reference internal">访问控制（授权）</a> (<code translate="no" class="notranslate">access_control</code>)',
        '\n                            Using access control and the authorization checker, you control the\nrequired permissions to perform a specific action or visit a specific\nURL.\n                    ': '使用访问控制和授权检查器，你可以控制执行特定操作或访问特定 URL 所需的权限。',

        'The User': '用户',
        'Permissions in Symfony are always linked to a user object. If you need to\nsecure (parts of) your application, you need to create a user class. This\nis a class that implements UserInterface.\nThis is often a Doctrine entity, but you can also use a dedicated\nSecurity user class.': '在 Symfony 中，权限总是与用户对象相关联。如果你需要保护你的应用程序（或应用程序的一部分），你需要创建一个用户类。这是一个实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Core/User/UserInterface.php" class="reference external" title="Symfony\Component\Security\Core\User\UserInterface" rel="external noopener noreferrer" target="_blank">UserInterface</a> 的类。这通常是一个 Doctrine 实体，但你也可以使用专门的 Security 用户类。',
        'The easiest way to generate a user class is using the make:user command\nfrom the MakerBundle:': '生成用户类的最简单方法是使用 <a href="https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html" class="reference external">MakerBundle</a> 中的 <code translate="no" class="notranslate">make:user</code> 命令：',
        "Starting in MakerBundle: v1.57.0 - You can pass either --with-uuid or\n--with-ulid to make:user. Leveraging Symfony's Uid Component,\nthis generates a User entity with the id type as Uuid\nor Ulid instead of int.": '从 <a href="https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html" class="reference external">MakerBundle</a> v1.57.0 版本开始，你可以通过传递 <code translate="no" class="notranslate">--with-uuid</code> 或 <code translate="no" class="notranslate">--with-ulid</code> 参数给 <code translate="no" class="notranslate">make:user</code> 命令。利用 Symfony 的 <a href="components/uid.html" class="reference internal">Uid 组件</a>，这将生成一个 <code translate="no" class="notranslate">User</code> 实体，其 <code translate="no" class="notranslate">id</code> 类型为 <a href="components/uid.html#uuid" class="reference internal">Uuid</a> 或 <a href="components/uid.html#ulid" class="reference internal">Ulid</a>，而不是 <code translate="no" class="notranslate">int</code>。',
        "If your user is a Doctrine entity, like in the example above, don't forget\nto create the tables by creating and running a migration:": '如果你的用户是一个 Doctrine 实体，就像上面的例子一样，别忘了通过<a href="doctrine.html#doctrine-creating-the-database-tables-schema" class="reference internal">创建和运行迁移</a>来创建表：',
        'Starting in MakerBundle: v1.56.0 - Passing --formatted to make:migration\ngenerates a nice and tidy migration file.': '从 <a href="https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html" class="reference external">MakerBundle</a> v1.56.0 版本开始，向 <code translate="no" class="notranslate">make:migration</code> 命令传递 <code translate="no" class="notranslate">--formatted</code> 参数将生成一个整洁且格式良好的迁移文件。',

        'Loading the User: The User Provider': '加载用户：用户提供者',
        'Besides creating the entity, the make:user command also adds config\nfor a user provider in your security configuration:': '除了创建实体之外，<code translate="no" class="notranslate">make:user</code> 命令还会在你的安全配置中添加一个用户提供者的配置：',
        'This user provider knows how to (re)load users from a storage (e.g. a database)\nbased on a "user identifier" (e.g. the user\'s email address or username).\nThe configuration above uses Doctrine to load the User entity using the\nemail property as "user identifier".': '这个用户提供者知道如何从存储（例如数据库）中（重新）加载用户，这是基于“用户标识符”（例如用户的电子邮件地址或用户名）来完成的。上面的配置使用 Doctrine 来加载 <code translate="no" class="notranslate">User</code> 实体，并使用 <code translate="no" class="notranslate">email</code> 属性作为“用户标识符”。',
        'User providers are used in a couple places during the security lifecycle:': '在安全生命周期的几个环节中都会使用到用户提供者：',
        'Load the User based on an identifier': '基于标识符加载用户',
        '\n                            During login (or any other authenticator), the provider loads the user\nbased on the user identifier. Some other features, like\nuser impersonation and\nRemember Me also use this.\n                    ': '在登录（或任何其它认证器）期间，提供者会根据用户标识符来加载用户。其它一些功能，如<a href="security/impersonating_user.html" class="reference internal">用户模拟</a>和<a href="security/remember_me.html" class="reference internal">记住我</a>也使用此功能。',
        'Reload the User from the session': '从会话中重新加载用户',
        '\n                            At the beginning of each request, the user is loaded from the\nsession (unless your firewall is stateless). The provider\n"refreshes" the user (e.g. the database is queried again for fresh\ndata) to make sure all user information is up to date (and if\nnecessary, the user is de-authenticated/logged out if something\nchanged). See Security for more information about\nthis process.\n                    ': '在每个请求的开头，用户都会从会话中加载（除非你的防火墙是无状态的）。提供者会“刷新”用户（例如，再次查询数据库以获取最新数据），以确保所有用户信息都是最新的（如果发生更改，必要时用户将被取消认证/登出）。有关此过程的更多信息，请参阅<a href="security.html#user_session_refresh" class="reference internal">安全性</a>部分。',
        'Symfony comes with several built-in user providers:': 'Symfony 提供了几个内置的用户提供者：',
        'Entity User Provider': '<a href="security/user_providers.html#security-entity-user-provider" class="reference internal">实体用户提供者</a>',
        '\n                            Loads users from a database using Doctrine;\n                    ': '使用 <a href="doctrine.html" class="reference internal">Doctrine</a> 从数据库中加载用户；',
        'LDAP User Provider': '<a href="security/ldap.html#security-ldap-user-provider" class="reference internal">LDAP 用户提供者</a>',
        '\n                            Loads users from a LDAP server;\n                    ': '从 LDAP 服务器加载用户；',
        'Memory User Provider': '<a href="security/user_providers.html#security-memory-user-provider" class="reference internal">内存用户提供者</a>',
        '\n                            Loads users from a configuration file;\n                    ': '从配置文件中加载用户；',
        'Chain User Provider': '<a href="security/user_providers.html#security-chain-user-provider" class="reference internal">链式用户提供者</a>',
        '\n                            Merges two or more user providers into a new user provider.\nSince each firewall has exactly one user provider, you can use this\nto chain multiple providers together.\n                    ': '将两个或多个用户提供者合并为一个新的用户提供者。由于每个防火墙正好有一个用户提供者，因此你可以使用它来将多个提供者链接在一起。',
        'The built-in user providers cover the most common needs for applications, but you\ncan also create your own custom user provider.': '内置的用户提供者覆盖了应用程序最常见的需求，但你也可以创建自己的<a href="security/user_providers.html#security-custom-user-provider" class="reference internal">自定义用户提供者</a>。',
        'Sometimes, you need to inject the user provider in another class (e.g.\nin your custom authenticator). All user providers follow this pattern\nfor their service ID: security.user.provider.concrete.<your-provider-name>\n(where <your-provider-name> is the configuration key, e.g.\napp_user_provider). If you only have one user provider, you can autowire\nit using the UserProviderInterface\ntype-hint.': '有时，你需要在另一个类中注入用户提供者（例如在你的自定义认证器中）。所有用户提供者的服务 ID 都遵循此模式：<code translate="no" class="notranslate">security.user.provider.concrete.&lt;your-provider-name&gt;</code>（其中 <code translate="no" class="notranslate">&lt;your-provider-name&gt;</code> 是配置键，例如 <code translate="no" class="notranslate">app_user_provider</code>）。如果你只有一个用户提供者，你可以使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Core/User/UserProviderInterface.php" class="reference external" title="Symfony\Component\Security\Core\User\UserProviderInterface" rel="external noopener noreferrer" target="_blank">UserProviderInterface</a> 类型提示来自动装配它。',

        'Registering the User: Hashing Passwords': '注册用户：密码哈希处理',
        'Many applications require a user to log in with a password. For these\napplications, the SecurityBundle provides password hashing and verification\nfunctionality.': '许多应用程序需要用户使用密码登录。对于这些应用程序，SecurityBundle 提供了密码哈希处理和验证功能。',
        'First, make sure your User class implements the\nPasswordAuthenticatedUserInterface:': '首先，确保你的 User 类实现了 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Core/User/PasswordAuthenticatedUserInterface.php" class="reference external" title="Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface" rel="external noopener noreferrer" target="_blank">PasswordAuthenticatedUserInterface</a> 接口：',
        "Then, configure which password hasher should be used for this class. If your\nsecurity.yaml file wasn't already pre-configured, then make:user should\nhave done this for you:": '然后，配置应该为该类使用哪个密码哈希器。如果你的 <code translate="no" class="notranslate">security.yaml</code> 文件还没有预先配置，那么 <code translate="no" class="notranslate">make:user</code> 应该已经为你做了这件事：',
        'Now that Symfony knows how you want to hash the passwords, you can use the\nUserPasswordHasherInterface service to do this before saving your users to\nthe database:': '既然 Symfony 已经知道你想要如何对密码进行哈希处理，你就可以在将用户保存到数据库之前使用 <code translate="no" class="notranslate">UserPasswordHasherInterface</code> 服务来完成这个操作：',
        'If your user class is a Doctrine entity and you hash user passwords, the\nDoctrine repository class related to the user class must implement the\nPasswordUpgraderInterface.': '如果你的用户类是一个 Doctrine 实体，并且你对用户密码进行了哈希处理，那么与用户类相关的 Doctrine 存储库类必须实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Core/User/PasswordUpgraderInterface.php" class="reference external" title="Symfony\Component\Security\Core\User\PasswordUpgraderInterface" rel="external noopener noreferrer" target="_blank">PasswordUpgraderInterface</a> 接口。',
        'The make:registration-form maker command can help you set-up the\nregistration controller and add features like email address\nverification using the SymfonyCastsVerifyEmailBundle.': '<code translate="no" class="notranslate">make:registration-form</code> maker 命令可以帮助你设置注册控制器，并添加使用 <a href="https://github.com/symfonycasts/verify-email-bundle" class="reference external" rel="external noopener noreferrer" target="_blank">SymfonyCastsVerifyEmailBundle</a> 进行电子邮件地址验证等功能。',
        'You can also manually hash a password by running:': '你还可以通过运行以下命令来手动对密码进行哈希处理：',
        'Read more about all available hashers and password migration in\nPassword Hashing and Verification.': '在密码哈希处理和验证中了解更多关于所有可用的<a href="security/passwords.html" class="reference internal">哈希器和密码迁移</a>的信息。',
        "In applications using Symfony 6.2 and PHP 8.2 or newer, the\nSensitiveParameter PHP attribute is applied to all plain passwords and\nsensitive tokens so they don't appear in stack traces.": '在使用 Symfony 6.2 和 PHP 8.2 或更高版本的应用程序中，<a href="https://www.php.net/manual/zh/class.sensitiveparameter.php" class="reference external" rel="external noopener noreferrer" target="_blank">SensitiveParameter PHP 属性</a>应用于所有明文密码和敏感令牌，以便它们不会出现在堆栈跟踪中。',

        'The Firewall': '防火墙',
        'The firewalls section of config/packages/security.yaml is the most\nimportant section. A "firewall" is your authentication system: the firewall\ndefines which parts of your application are secured and how your users\nwill be able to authenticate (e.g. login form, API token, etc).': '<code translate="no" class="notranslate">config/packages/security.yaml</code> 文件中的 <code translate="no" class="notranslate">firewalls</code> 部分是最重要的部分。一个“防火墙”就是你的认证系统：防火墙定义了你的应用程序的哪些部分受到保护，以及你的用户将如何认证（例如登录表单、API令牌等）。',
        'Only one firewall is active on each request: Symfony uses the pattern key\nto find the first match (you can also\nmatch by host or other things).\nHere, all real URLs are handled by the main firewall (no pattern key means\nit matches all URLs).': '每个请求只有一个防火墙处于活动状态：Symfony 使用 <code translate="no" class="notranslate">pattern</code> 键来查找第一个匹配项（你也可以<a href="security/firewall_restriction.html" class="reference internal">根据主机或其它内容进行匹配</a>）。在这里，所有实际的 URL 都由 <code translate="no" class="notranslate">main</code> 防火墙处理（没有 <code translate="no" class="notranslate">pattern</code> 键意味着它匹配所有 URL）。',
        "The dev firewall is really a fake firewall: it makes sure that you\ndon't accidentally block Symfony's dev tools - which live under URLs like\n/_profiler and /_wdt.": '<code translate="no" class="notranslate">dev</code> 防火墙实际上是一个假防火墙：它确保你不会意外地阻止 Symfony 的开发工具——这些工具位于类似 <code translate="no" class="notranslate">/_profiler</code> 和 <code translate="no" class="notranslate">/_wdt</code> 的URL下。',
        'When matching several routes, instead of creating a long regex you can also\nuse an array of simpler regexes to match each route:': '当匹配多个路由时，除了创建一个长正则表达式外，你还可以使用一个更简单的正则表达式数组来匹配每个路由：',
        'This feature is not supported by the XML configuration format.': '此功能不受XML配置格式支持。',
        'The feature to use an array of regex was introduced in Symfony 6.4.': '使用正则表达式数组的功能是在 Symfony 6.4 中引入的。',
        'All real URLs are handled by the main firewall (no pattern key means\nit matches all URLs). A firewall can have many modes of authentication,\nin other words, it enables many ways to ask the question "Who are you?".': '所有实际的 URL 都由  <code translate="no" class="notranslate">main</code> 防火墙处理（没有 <code translate="no" class="notranslate">pattern</code> 键意味着它匹配所有 URL）。一个防火墙可以有多种认证模式，换句话说，它支持多种方式来提问“你是谁？”。',
        "Often, the user is unknown (i.e. not logged in) when they first visit your\nwebsite. If you visit your homepage right now, you will have access and\nyou'll see that you're visiting a page behind the firewall in the toolbar:": '通常，用户首次访问你的网站时都是未知的（即未登录）。如果你现在访问你的主页，你将能够访问它，并且你会看到工具栏上显示你正在访问防火墙后面的页面：',
        'Visiting a URL under a firewall doesn\'t necessarily require you to be authenticated\n(e.g. the login form has to be accessible or some parts of your application\nare public). On the other hand, all pages that you want to be aware of a logged in\nuser have to be under the same firewall. So if you want to display a "You are logged in\nas ..." message on every page, they all have to be included in the same firewall.': '访问防火墙下的 URL 并不一定需要认证（例如，登录表单必须可访问，或者你的应用程序的某些部分是公开的）。另一方面，所有需要意识到已登录用户的页面都必须在同一个防火墙下。因此，如果你想在每页上显示“你已登录为...”的消息，它们都必须包含在同一个防火墙中。',
        "You'll learn how to restrict access to URLs, controllers or\nanything else within your firewall in the access control section.": '在<a href="security.html#security-access-control" class="reference internal">访问控制</a>部分，你将学习如何限制对防火墙内的 URL、控制器或其它任何内容的访问。',
        'The lazy anonymous mode prevents the session from being started if\nthere is no need for authorization (i.e. explicit check for a user\nprivilege). This is important to keep requests cacheable (see\nHTTP Cache).': '<code translate="no" class="notranslate">lazy</code> 匿名模式会在不需要授权的情况下（即不需要显式检查用户权限）阻止会话的启动。这对于保持请求的缓存性很重要（参见 <a href="http_cache.html" class="reference internal">HTTP 缓存</a>）。',
         'If you do not see the toolbar, install the profiler\nwith:': '如果你看不到工具栏，请使用以下命令安装 <a href="profiler.html" class="reference internal">profiler</a>：',

        'Fetching the Firewall Configuration for a Request': '获取请求的防火墙配置',
        'If you need to get the configuration of the firewall that matched a given request,\nuse the Security service:': '如果您需要获取与给定请求匹配的防火墙配置，请使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/SecurityBundle/Security.php" class="reference external" title="Symfony\Bundle\SecurityBundle\Security" rel="external noopener noreferrer" target="_blank">Security</a> 服务：',
        'The getFirewallConfig() method was introduced in Symfony 6.2.': '<code translate="no" class="notranslate">getFirewallConfig()</code> 方法在 Symfony 6.2 中被引入。',

        'Authenticating Users': '验证用户身份',
        'During authentication, the system tries to find a matching user for the\nvisitor of the webpage. Traditionally, this was done using a login form or\na HTTP basic dialog in the browser. However, the SecurityBundle comes with\nmany other authenticators:': '在身份验证过程中，系统尝试为网页访问者查找匹配的用户。传统上，这是通过在浏览器中使用登录表单或 HTTP 基本对话框来完成的。但是，SecurityBundle 提供了许多其它身份验证器：',
        'If your application logs users in via a third-party service such as\nGoogle, Facebook or Twitter (social login), check out the HWIOAuthBundle\ncommunity bundle.': '如果您的应用程序通过第三方服务（如 Google、Facebook 或 Twitter，即社交登录）来登录用户，请查看 <a href="https://github.com/hwi/HWIOAuthBundle" class="reference external" rel="external noopener noreferrer" target="_blank">HWIOAuthBundle</a> 社区包。',

        'Form Login': '表单登录',
        'Most websites have a login form where users authenticate using an\nidentifier (e.g. email address or username) and a password. This\nfunctionality is provided by the built-in FormLoginAuthenticator.': '大多数网站都有一个登录表单，用户通过标识符（例如电子邮件地址或用户名）和密码进行身份验证。此功能由内置的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Http/Authenticator/FormLoginAuthenticator.php" class="reference external" title="Symfony\Component\Security\Http\Authenticator\FormLoginAuthenticator" rel="external noopener noreferrer" target="_blank">FormLoginAuthenticator</a> 提供。',
        'You can run the following command to create everything needed to add a login\nform in your application:': '你可以运行以下命令来创建在你的应用中添加一个登录表单所需的一切：',
        'This command will create the required controller and template and it will also\nupdate the security configuration. Alternatively, if you prefer to make these\nchanges manually, follow the next steps.': '这个命令将创建所需的控制器和模板，并更新安全配置。另外，如果你更喜欢手动进行这些更改，请按照以下步骤操作。',
        'First, create a controller for the login form:': '首先，为登录表单创建一个控制器：',
        'Then, enable the FormLoginAuthenticator using the form_login setting:': '然后，使用 <code translate="no" class="notranslate">form_login</code> 设置启用 <code translate="no" class="notranslate">FormLoginAuthenticator</code>：',
        'The login_path and check_path support URLs and route names (but\ncannot have mandatory wildcards - e.g. /login/{foo} where foo\nhas no default value).': '<code translate="no" class="notranslate">login_path</code> 和 <code translate="no" class="notranslate">check_path</code> 支持 URL 和路由名称（但不能有强制的通配符，例如 <code translate="no" class="notranslate">/login/{foo}</code>，其中 <code translate="no" class="notranslate">foo</code> 没有默认值）。',
        'Once enabled, the security system redirects unauthenticated visitors to the\nlogin_path when they try to access a secured place (this behavior can\nbe customized using authentication entry points).': '启用后，当未经身份验证的访问者尝试访问安全区域时，安全系统会将其重定向到 <code translate="no" class="notranslate">login_path</code> （可以使用<a href="security/access_denied_handler.html#security-entry-point" class="reference internal">身份验证入口点</a>自定义此行为）。',
        'Edit the login controller to render the login form:': '编辑登录控制器以呈现登录表单：',
        "Don't let this controller confuse you. Its job is only to render the form.\nThe FormLoginAuthenticator will handle the form submission automatically.\nIf the user submits an invalid email or password, that authenticator will store\nthe error and redirect back to this controller, where we read the error (using\nAuthenticationUtils) so that it can be displayed back to the user.": '不要让这个控制器混淆你。它的工作只是渲染表单。<code translate="no" class="notranslate">FormLoginAuthenticator</code> 将自动处理表单提交。如果用户提交了无效的电子邮件或密码，该身份验证器将存储错误并重定向回此控制器，我们将在这里读取错误（使用 <code translate="no" class="notranslate">AuthenticationUtils</code>），以便将其显示回给用户。',
        'Finally, create or update the template:': '最后，创建或更新模板：',
        'The error variable passed into the template is an instance\nof AuthenticationException.\nIt may contain sensitive information about the authentication failure.\nNever use error.message: use the messageKey property instead,\nas shown in the example. This message is always safe to display.': '传递给模板的 <code translate="no" class="notranslate">error</code> 变量是 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Core/Exception/AuthenticationException.php" class="reference external" title="Symfony\Component\Security\Core\Exception\AuthenticationException" rel="external noopener noreferrer" target="_blank">AuthenticationException</a> 的一个实例。它可能包含有关身份验证失败的敏感信息。永远不要使用 <code translate="no" class="notranslate">error.message</code>：而应使用 <code translate="no" class="notranslate">messageKey</code> 属性，如示例中所示。这个消息始终可以安全地显示。',
        'The form can look like anything, but it usually follows some conventions:': '表单的外观可以多种多样，但通常遵循一些约定：',
        "The <form> element sends a POST request to the app_login route, since\nthat's what you configured as the check_path under the form_login key in\nsecurity.yaml;": '<code translate="no" class="notranslate">&lt;form&gt;</code> 元素向 <code translate="no" class="notranslate">app_login</code> 路由发送 <code translate="no" class="notranslate">POST</code> 请求，因为您在 <code translate="no" class="notranslate">security.yaml</code> 中的 <code translate="no" class="notranslate">form_login</code> 键下配置了 <code translate="no" class="notranslate">check_path</code> 为 <code translate="no" class="notranslate">app_login</code>；',
        'The username (or whatever your user\'s "identifier" is, like an email) field has\nthe name _username and the password field has the name _password.': '用户名（或用户的“标识符”，如电子邮件）字段的名称为 <code translate="no" class="notranslate">_username</code>，密码字段的名称为 <code translate="no" class="notranslate">_password</code>。',
        'Actually, all of this can be configured under the form_login key. See\nSecurity Configuration Reference (SecurityBundle) for more details.':'实际上，所有这些都可以在 <code translate="no" class="notranslate">form_login</code> 键下进行配置。有关更多详细信息，请参阅<a href="reference/configuration/security.html#reference-security-firewall-form-login" class="reference internal">安全配置参考（SecurityBundle）</a>。',
        'This login form is currently not protected against CSRF attacks. Read\nSecurity on how to protect your login form.': '当前，此登录表单未受 CSRF 攻击保护。请阅读<a href="security.html#form_login-csrf" class="reference internal">安全</a>章节以了解如何保护您的登录表单。',
        "And that's it! When you submit the form, the security system automatically\nreads the _username and _password POST parameter, loads the user via\nthe user provider, checks the user's credentials and either authenticates the\nuser or sends them back to the login form where the error can be displayed.": '就是这样！当您提交表单时，安全系统会自动读取 <code translate="no" class="notranslate">_username</code> 和 <code translate="no" class="notranslate">_password</code> POST 参数，通过用户提供程序加载用户，检查用户的凭据，然后对用户进行身份验证或将它们重定向回登录表单，以便在那里显示错误。',
        'To review the whole process:': '回顾整个过程：',
        'The user tries to access a resource that is protected (e.g. /admin);': '用户尝试访问受保护的资源（例如 <code translate="no" class="notranslate">/admin</code>）；',
        'The firewall initiates the authentication process by redirecting the\nuser to the login form (/login);': '防火墙通过将用户重定向到登录表单（<code translate="no" class="notranslate">/login</code>）来启动身份验证过程；',
        'The /login page renders login form via the route and controller created\nin this example;': '<code translate="no" class="notranslate">/login</code> 页面通过本例中创建的路由和控制器渲染登录表单；',
        'The user submits the login form to /login;': '用户提交登录表单到 <code translate="no" class="notranslate">/login</code>；',
        "The security system (i.e. the FormLoginAuthenticator) intercepts the\nrequest, checks the user's submitted credentials, authenticates the user if\nthey are correct, and sends the user back to the login form if they are not.": '安全系统（即 <code translate="no" class="notranslate">FormLoginAuthenticator</code>）拦截请求，检查用户提交的凭据，如果凭据正确则对用户进行身份验证，如果凭据不正确则将用户发送回登录表单。',
        'You can customize the responses on a successful or failed login\nattempt. See Customizing the Form Login Authenticator Responses.': '您可以自定义登录成功或失败时的响应。请参阅<a href="security/form_login.html" class="reference internal">自定义表单登录身份验证器响应</a>。',
        'CSRF Protection in Login Forms': '登录表单中的 CSRF 保护',
        'Login CSRF attacks can be prevented using the same technique of adding hidden\nCSRF tokens into the login forms. The Security component already provides CSRF\nprotection, but you need to configure some options before using it.': '可以通过在登录表单中添加隐藏的 CSRF 令牌来防止登录 CSRF 攻击。安全组件已经提供了 CSRF 保护，但在使用之前，您需要配置一些选项。',
        'First, you need to enable CSRF on the form login:': '首先，您需要在表单登录上启用 CSRF：',
        'Then, use the csrf_token() function in the Twig template to generate a CSRF\ntoken and store it as a hidden field of the form. By default, the HTML field\nmust be called _csrf_token and the string used to generate the value must\nbe authenticate:': '然后，在 Twig 模板中使用 <code translate="no" class="notranslate">csrf_token()</code> 函数生成 CSRF 令牌并将其存储为表单的隐藏字段。默认情况下，HTML 字段必须名为 <code translate="no" class="notranslate">_csrf_token</code>，用于生成值的字符串必须为 <code translate="no" class="notranslate">authenticate</code>：',
        'After this, you have protected your login form against CSRF attacks.': '这样，您就已经保护了登录表单免受 CSRF 攻击。',
        'You can change the name of the field by setting csrf_parameter and change\nthe token ID by setting  csrf_token_id in your configuration. See\nSecurity Configuration Reference (SecurityBundle) for more details.': '您可以通过在配置中设置 <code translate="no" class="notranslate">csrf_parameter</code> 来更改字段的名称，并通过设置 <code translate="no" class="notranslate">csrf_token_id</code> 来更改令牌 ID。有关更多详细信息，请参阅<a href="reference/configuration/security.html#reference-security-firewall-form-login" class="reference internal">安全配置参考（SecurityBundle）</a>。',

        'JSON Login': 'JSON 登录',
        'Some applications provide an API that is secured using tokens. These\napplications may use an endpoint that provides these tokens based on a\nusername (or email) and password. The JSON login authenticator helps you create\nthis functionality.': '一些应用程序提供使用令牌保护的 API。这些应用程序可能会使用基于用户名（或电子邮件）和密码提供这些令牌的端点。JSON 登录身份验证器可帮助您创建此功能。',
        'Enable the authenticator using the json_login setting:': '使用 <code translate="no" class="notranslate">json_login</code> 设置启用身份验证器：',
        'The check_path supports URLs and route names (but cannot have\nmandatory wildcards - e.g. /login/{foo} where foo has no\ndefault value).': '<code translate="no" class="notranslate">check_path</code> 支持 URL 和路由名称（但不能有强制的通配符，例如 <code translate="no" class="notranslate">/login/{foo}</code>，其中 <code translate="no" class="notranslate">foo</code> 没有默认值）。',
        'The authenticator runs when a client requests the check_path. First,\ncreate a controller for this path:': '当客户端请求 <code translate="no" class="notranslate">check_path</code> 时，身份验证器会运行。首先，为这个路径创建一个控制器：',
        'This login controller will be called after the authenticator successfully\nauthenticates the user. You can get the authenticated user, generate a\ntoken (or whatever you need to return) and return the JSON response:': '在身份验证器成功对用户进行身份验证后，将调用此登录控制器。您可以获取经过身份验证的用户，生成令牌（或您需要返回的任何内容），并返回 JSON 响应：',
        'The #[CurrentUser] can only be used in controller arguments to\nretrieve the authenticated user. In services, you would use\ngetUser().': '<code translate="no" class="notranslate">#[CurrentUser]</code> 只能在控制器参数中使用以检索经过身份验证的用户。在服务中，您应该使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/SecurityBundle/Security.php#:~:text=function%20getUser" class="reference external" title="Symfony\Bundle\SecurityBundle\Security::getUser()" rel="external noopener noreferrer" target="_blank">getUser()</a>。',
        "That's it! To summarize the process:": '就是这样！总结一下过程：',
        'A client (e.g. the front-end) makes a POST request with the\nContent-Type: application/json header to /api/login with\nusername (even if your identifier is actually an email) and\npassword keys:': '客户端（例如前端）使用 <code translate="no" class="notranslate">Content-Type: application/json</code> 头向 <code translate="no" class="notranslate">/api/login</code> 发送 POST 请求，其中包含 <code translate="no" class="notranslate">username</code>（即使您的标识符实际上是电子邮件）和 <code translate="no" class="notranslate">password</code> 键：',
        "The security system intercepts the request, checks the user's submitted\ncredentials and authenticates the user. If the credentials are incorrect,\nan HTTP 401 Unauthorized JSON response is returned, otherwise your\ncontroller is run;": '安全系统拦截请求，检查用户提交的凭据并对用户进行身份验证。如果凭据不正确，将返回 HTTP 401 Unauthorized JSON 响应，否则将运行您的控制器；',
        'Your controller creates the correct response:': '您的控制器创建正确的响应：',
        'The JSON request format can be configured under the json_login key.\nSee Security Configuration Reference (SecurityBundle) for more details.': '可以在 <code translate="no" class="notranslate">json_login</code> 键下配置 JSON 请求格式。有关更多详细信息，请参阅<a href="reference/configuration/security.html#reference-security-firewall-json-login" class="reference internal">安全配置参考（SecurityBundle）</a>。',

        'HTTP Basic': 'HTTP 基本认证',
        'HTTP Basic authentication is a standardized HTTP authentication\nframework. It asks credentials (username and password) using a dialog in\nthe browser and the HTTP basic authenticator of Symfony will verify these\ncredentials.': 'HTTP 基本认证是一个标准化的 HTTP 认证框架。它通过浏览器中的对话框请求凭据（用户名和密码），而 Symfony 的 HTTP 基本身份验证器将验证这些凭据。',
        'Add the http_basic key to your firewall to enable HTTP Basic\nauthentication:': '将  <code translate="no" class="notranslate">http_basic</code> 键添加到您的防火墙中，以启用 HTTP 基本认证：',
        "That's it! Whenever an unauthenticated user tries to visit a protected\npage, Symfony will inform the browser that it needs to start HTTP basic\nauthentication (using the WWW-Authenticate response header). Then, the\nauthenticator verifies the credentials and authenticates the user.": '就是这样！每当未经身份验证的用户尝试访问受保护的页面时，Symfony 将通知浏览器需要开始 HTTP 基本认证（使用 <code translate="no" class="notranslate">WWW-Authenticate</code> 响应头）。然后，身份验证器验证凭据并对用户进行身份验证。',
        'You cannot use log out with the HTTP\nbasic authenticator. Even if you log out from Symfony, your browser\n"remembers" your credentials and will send them on every request.': '您无法使用 HTTP 基本身份验证器进行<a href="security.html#security-logging-out" class="reference internal">注销</a>。即使您从 Symfony 注销，您的浏览器也会“记住”您的凭据，并在每次请求时发送它们。',

        'Login Link': '登录链接',
        'Login links are a passwordless authentication mechanism. The user will\nreceive a short-lived link (e.g. via email) which will authenticate them to the\nwebsite.': '登录链接是一种无密码身份验证机制。用户将收到一个短期有效的链接（例如通过电子邮件），该链接将使他们能够登录到网站。',
        'You can learn all about this authenticator in How to use Passwordless Login Link Authentication.': '您可以在<a href="security/login_link.html" class="reference internal">如何使用无密码登录链接身份验证</a>中了解有关此身份验证器的所有信息。',

        'Access Tokens': '访问令牌',
        'Access Tokens are often used in API contexts.\nThe user receives a token from an authorization server\nwhich authenticates them.': '访问令牌通常用于 API 上下文。用户从授权服务器接收一个令牌，该令牌用于对他们进行身份验证。',
        'You can learn all about this authenticator in How to use Access Token Authentication.': '您可以在<a href="security/access_token.html" class="reference internal">如何使用访问令牌身份验证</a>中了解有关此身份验证器的所有信息。',

        'X.509 Client Certificates': 'X.509 客户端证书',
        'When using client certificates, your web server does all the authentication\nitself. The X.509 authenticator provided by Symfony extracts the email from\nthe "distinguished name" (DN) of the client certificate. Then, it uses this\nemail as user identifier in the user provider.': '当使用客户端证书时，您的 Web 服务器会自行完成所有身份验证。Symfony 提供的 X.509 身份验证器从客户端证书的“可识别名称”（DN）中提取电子邮件。然后，它使用此电子邮件作为用户提供程序中的用户标识符。',
        "First, configure your web server to enable client certificate verification\nand to expose the certificate's DN to the Symfony application:": '首先，配置您的 Web 服务器以启用客户端证书验证并将证书的 DN 暴露给 Symfony 应用程序：',
        'Then, enable the X.509 authenticator using x509 on your firewall:': '然后，在您的防火墙上使用 <code translate="no" class="notranslate">x509</code> 启用 X.509 身份验证器：',
        'By default, Symfony extracts the email address from the DN in two different\nways:': '默认情况下，Symfony 通过两种不同的方式从 DN 中提取电子邮件地址：',
        'First, it tries the SSL_CLIENT_S_DN_Email server parameter, which is\nexposed by Apache;': '首先，它尝试 <code translate="no" class="notranslate">SSL_CLIENT_S_DN_Email</code> 服务器参数，该参数由 Apache 公开；',
        'If it is not set (e.g. when using Nginx), it uses SSL_CLIENT_S_DN and\nmatches the value following emailAddress.': '如果未设置（例如，当使用 Nginx 时），它将使用 <code translate="no" class="notranslate">SSL_CLIENT_S_DN</code> 并匹配 <code translate="no" class="notranslate">emailAddress</code> 后面的值。',
        'You can customize the name of some parameters under the x509 key.\nSee the x509 configuration reference\nfor more details.': '您可以在 <code translate="no" class="notranslate">x509</code> 键下自定义某些参数的名称。有关更多详细信息，请参阅 <a href="reference/configuration/security.html#reference-security-firewall-x509" class="reference internal">x509 配置参考</a>。',

        'Remote Users': '远程用户',
        'Besides client certificate authentication, there are more web server\nmodules that pre-authenticate a user (e.g. kerberos). The remote user\nauthenticator provides a basic integration for these services.': '除了客户端证书身份验证外，还有更多 Web 服务器模块会对用户进行预身份验证（例如 Kerberos）。远程用户身份验证器为这些服务提供了基本集成。',
        'These modules often expose the authenticated user in the REMOTE_USER\nenvironment variable. The remote user authenticator uses this value as the\nuser identifier to load the corresponding user.': '这些模块通常会在 <code translate="no" class="notranslate">REMOTE_USER</code> 环境变量中公开已身份验证的用户。远程用户身份验证器使用此值作为用户标识符来加载相应的用户。',
        'Enable remote user authentication using the remote_user key:': '使用 <code translate="no" class="notranslate">remote_user</code> 键启用远程用户身份验证：',
        'You can customize the name of this server variable under the\nremote_user key. See\nthe configuration reference\nfor more details.': '您可以在 <code translate="no" class="notranslate">remote_user</code> 键下自定义此服务器变量的名称。有关更多详细信息，请参阅<a href="reference/configuration/security.html#reference-security-firewall-remote-user" class="reference internal">配置参考</a>。',

        'Limiting Login Attempts': '限制登录尝试次数',
        "Symfony provides basic protection against brute force login attacks thanks to\nthe Rate Limiter component. If you haven't used this\ncomponent in your application yet, install it before using this feature:": 'Symfony 通过 <a href="rate_limiter.html" class="reference internal">Rate Limiter 组件</a>提供了针对<a href="https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks" class="reference external" rel="external noopener noreferrer" target="_blank">暴力破解登录攻击</a>的基本保护。如果您尚未在应用程序中使用此组件，请在使用此功能之前进行安装：',
        'Then, enable this feature using the login_throttling setting:': '然后，使用 <code translate="no" class="notranslate">login_throttling</code> 设置启用此功能：',
        'The value of the interval option must be a number followed by any of the\nunits accepted by the PHP date relative formats (e.g. 3 seconds,\n10 hours, 1 day, etc.)': '<code translate="no" class="notranslate">interval</code> 选项的值必须是一个数字，后跟 <a href="https://www.php.net/manual/zh/datetime.formats.php#datetime.formats.relative" class="reference external" rel="external noopener noreferrer" target="_blank">PHP 日期相对格式</a>接受的任何单位（例如 <code translate="no" class="notranslate">3 seconds</code>、<code translate="no" class="notranslate">10 hours</code>、<code translate="no" class="notranslate">1 day</code> 等）。',
        "Internally, Symfony uses the Rate Limiter component\nwhich by default uses Symfony's cache to store the previous login attempts.\nHowever, you can implement a custom storage.": '在内部，Symfony 使用 <a href="rate_limiter.html" class="reference internal">Rate Limiter 组件</a>，该组件默认使用 Symfony 的缓存来存储先前的登录尝试。但是，您可以实现<a href="rate_limiter.html#rate-limiter-storage" class="reference internal">自定义存储</a>。',
        'Login attempts are limited on max_attempts (default: 5)\nfailed requests for IP address + username and 5 * max_attempts\nfailed requests for IP address. The second limit protects against an\nattacker using multiple usernames from bypassing the first limit, without\ndisrupting normal users on big networks (such as offices).': '登录尝试次数限制为针对 <code translate="no" class="notranslate">IP address + username</code> 的 <code translate="no" class="notranslate">max_attempts</code>（默认值为5）次失败请求，以及针对 <code translate="no" class="notranslate">IP address</code> 的 <code translate="no" class="notranslate">5 * max_attempts</code> 次失败请求。第二个限制保护攻击者使用多个用户名绕过第一个限制，同时不影响大型网络（如办公室）中的正常用户。',
        'Limiting the failed login attempts is only one basic protection against\nbrute force attacks. The OWASP Brute Force Attacks guidelines mention\nseveral other protections that you should consider depending on the\nlevel of protection required.': '限制失败的登录尝试只是针对暴力破解攻击的一种基本保护。<a href="https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks" class="reference external" rel="external noopener noreferrer" target="_blank">OWASP 力破解攻击</a>指南提到了其它几种保护措施，您应根据所需的保护级别进行考虑。',
        'If you need a more complex limiting algorithm, create a class that implements\nRequestRateLimiterInterface\n(or use\nDefaultLoginRateLimiter)\nand set the limiter option to its service ID:': '如果您需要一个更复杂的限制算法，请创建一个实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/RateLimiter/RequestRateLimiterInterface.php" class="reference external" title="Symfony\Component\HttpFoundation\RateLimiter\RequestRateLimiterInterface" rel="external noopener noreferrer" target="_blank">RequestRateLimiterInterface</a> 的类（或使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Http/RateLimiter/DefaultLoginRateLimiter.php" class="reference external" title="Symfony\Component\Security\Http\RateLimiter\DefaultLoginRateLimiter" rel="external noopener noreferrer" target="_blank">DefaultLoginRateLimiter</a>），并将 <code translate="no" class="notranslate">limiter</code> 选项设置为其服务 ID：',

        'Customize Successful and Failed Authentication Behavior': '自定义成功和失败的身份验证行为',
        "If you want to customize how the successful or failed authentication process is\nhandled, you don't have to overwrite the respective listeners globally. Instead,\nyou can set custom success failure handlers by implementing the\nAuthenticationSuccessHandlerInterface\nor the\nAuthenticationFailureHandlerInterface.": '如果您想要自定义成功或失败的身份验证过程是如何处理的，您不必全局覆盖相应的监听器。相反，您可以通过实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Http/Authentication/AuthenticationSuccessHandlerInterface.php" class="reference external" title="Symfony\Component\Security\Http\Authentication\AuthenticationSuccessHandlerInterface" rel="external noopener noreferrer" target="_blank">AuthenticationSuccessHandlerInterface</a> 或 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Http/Authentication/AuthenticationFailureHandlerInterface.php" class="reference external" title="Symfony\Component\Security\Http\Authentication\AuthenticationFailureHandlerInterface" rel="external noopener noreferrer" target="_blank">AuthenticationFailureHandlerInterface</a> 来设置自定义的成功和失败处理程序。',
        'Read how to customize your success handler\nfor more information about this.': '阅读<a href="security/login_link.html#login-link_customize-success-handler" class="reference internal">如何自定义成功处理程序</a>以获取更多相关信息。',

        'Login Programmatically': '程序化登录',
        'The Symfony\\Bundle\\SecurityBundle\\Security\nclass was introduced in Symfony 6.2. Prior to 6.2, it was called\nSymfony\\Component\\Security\\Core\\Security.': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/SecurityBundle/Security.php" class="reference external" title="Symfony\Bundle\SecurityBundle\Security" rel="external noopener noreferrer" target="_blank">Symfony\\Bundle\\SecurityBundle\\Security</a> 类是在 Symfony 6.2 中引入的。在 6.2 版本之前，它被称为 <code translate="no" class="notranslate">Symfony<wbr>\\Component<wbr>\\Security<wbr>\\Core<wbr>\\Security</wbr></wbr></wbr></wbr></code>。',
        'The login()\nmethod was introduced in Symfony 6.2.': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/SecurityBundle/Security.php#:~:text=function%20login" class="reference external" title="Symfony\Bundle\SecurityBundle\Security::login()" rel="external noopener noreferrer" target="_blank">login()</a> 方法在 Symfony 6.2 中被引入。',
        'You can log in a user programmatically using the login() method of the\nSecurity helper:': '您可以使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/SecurityBundle/Security.php" class="reference external" title="Symfony\Bundle\SecurityBundle\Security" rel="external noopener noreferrer" target="_blank">Security</a> 助手的 <code translate="no" class="notranslate">login()</code> 方法程序化地登录用户：',
        'The feature to use a custom redirection logic was introduced in Symfony 6.3.': '使用自定义重定向逻辑的功能是在 Symfony 6.3 中引入的。',
        'The feature to add badges was introduced in Symfony 6.4.': '添加徽章的功能是在 Symfony 6.4 中引入的。',

        'Logging Out': '注销登录',
        'To enable logging out, activate the  logout config parameter under your firewall:': '要启用注销登录，请在您的防火墙下激活 <code translate="no" class="notranslate">logout</code> 配置参数：',
        'Symfony will then un-authenticate users navigating to the configured path,\nand redirect them to the configured target.': '然后，Symfony 将对导航到已配置 <code translate="no" class="notranslate">path</code> 的用户进行注销，并将他们重定向到已配置的 <code translate="no" class="notranslate">target</code>。',
        'If you need to reference the logout path, you can use the _logout_<firewallname>\nroute name (e.g. _logout_main).': '如果您需要引用注销路径，可以使用 <code translate="no" class="notranslate">_logout_&lt;firewallname&gt;</code> 路由名称（例如 <code translate="no" class="notranslate">_logout_main</code>）。',
        'If your project does not use Symfony Flex, make sure\nyou have imported the logout route loader in your routes:': '如果您的项目没有使用 <a href="setup.html#symfony-flex" class="reference internal">Symfony Flex</a>，请确保在路由中导入了注销路由加载器：',
        'The LogoutRouteLoader was\nintroduced in Symfony 6.4.': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/SecurityBundle/Routing/LogoutRouteLoader.php" class="reference external" title="Symfony\Bundle\SecurityBundle\Routing\LogoutRouteLoader" rel="external noopener noreferrer" target="_blank">LogoutRouteLoader</a> 是在Symfony 6.4中引入的。',

        'Logout programmatically': '程序化注销登录',
        'The logout()\nmethod was introduced in Symfony 6.2.': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/SecurityBundle/Security.php#:~:text=function%20logout" class="reference external" title="Symfony\Bundle\SecurityBundle\Security::logout()" rel="external noopener noreferrer" target="_blank">logout()</a> 方法在 Symfony 6.2 中被引入。',
        'You can logout user programmatically using the logout() method of the\nSecurity helper:': '您可以使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/SecurityBundle/Security.php" class="reference external" title="Symfony\Bundle\SecurityBundle\Security" rel="external noopener noreferrer" target="_blank">Security</a> 助手的 <code translate="no" class="notranslate">logout()</code> 方法程序化地注销用户：',
        'The user will be logged out from the firewall of the request. If the request is\nnot behind a firewall a \\LogicException will be thrown.': '用户将从请求的防火墙中注销。如果请求不在防火墙后面，将抛出一个 <code translate="no" class="notranslate">\\LogicException</code> 异常。',

        'Customizing Logout': '自定义注销登录',
        'In some cases you need to run extra logic upon logout (e.g. invalidate\nsome tokens) or want to customize what happens after a logout. During\nlogout, a LogoutEvent\nis dispatched. Register an event listener or subscriber\nto execute custom logic:': '在某些情况下，您需要在注销时运行额外的逻辑（例如使某些令牌无效）或自定义注销后发生的情况。在注销过程中，会分派一个 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Http/Event/LogoutEvent.php" class="reference external" title="Symfony\Component\Security\Http\Event\LogoutEvent" rel="external noopener noreferrer" target="_blank">LogoutEvent</a> 事件。注册一个<a href="event_dispatcher.html" class="reference internal">事件监听器或订阅者</a>来执行自定义逻辑：',

        'Customizing Logout Path': '自定义注销路径',
        'Another option is to configure path as a route name. This can be useful\nif you want logout URIs to be dynamic (e.g. translated according to the\ncurrent locale). In that case, you have to create this route yourself:': '另一种选项是将 <code translate="no" class="notranslate">path</code> 配置为路由名称。如果您希望注销 URI 是动态的（例如，根据当前区域设置进行翻译），这将非常有用。在这种情况下，您需要自己创建这个路由：',
        'Then, pass the route name to the path option:': '然后，将路由名称传递给 <code translate="no" class="notranslate">path</code> 选项：',

        'Fetching the User Object': '获取用户对象',
        'After authentication, the User object of the current user can be\naccessed via the getUser() shortcut in the\nbase controller:': '在身份验证后，可以通过<a href="controller.html#the-base-controller-class-services" class="reference internal">基础控制器</a>中的 <code translate="no" class="notranslate">getUser()</code> 快捷方式来访问当前用户的 <code translate="no" class="notranslate">User</code> 对象：',

        'Fetching the User from a Service': '从服务中获取用户',
        'If you need to get the logged in user from a service, use the\nSecurity service:': '如果你需要从服务中获取已登录的用户，请使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/SecurityBundle/Security.php" class="reference external" title="Symfony\Bundle\SecurityBundle\Security" rel="external noopener noreferrer" target="_blank">Security</a> 服务：',
        'The Security class\nwas introduced in Symfony 6.2. In previous Symfony versions this class was\ndefined in Symfony\\Component\\Security\\Core\\Security.': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/SecurityBundle/Security.php" class="reference external" title="Symfony\Bundle\SecurityBundle\Security" rel="external noopener noreferrer" target="_blank">Security</a> 类在 Symfony 6.2 中被引入。在之前的 Symfony 版本中，这个类被定义在 <code translate="no" class="notranslate">Symfony<wbr>\\Component<wbr>\\Security<wbr>\\Core<wbr>\\Security</wbr></wbr></wbr></wbr></code> 中。',

        'Fetch the User in a Template': '在模板中获取用户',
        'In a Twig Template the user object is available via the app.user variable\nthanks to the Twig global app variable:': '在 Twig 模板中，用户对象可以通过<a href="templates.html#twig-app-variable" class="reference internal">全局的 Twig 变量</a> <code translate="no" class="notranslate">app.user</code> 来访问：',

        'Access Control (Authorization)': '访问控制（授权）',
        'Users can now log in to your app using your login form. Great! Now, you need to learn\nhow to deny access and work with the User object. This is called authorization,\nand its job is to decide if a user can access some resource (a URL, a model object,\na method call, ...).': '用户现在可以使用您的登录表单登录到您的应用，太好了！现在，您需要学习如何拒绝访问并处理 User 对象。这被称为授权，它的任务是决定用户是否可以访问某些资源（URL、模型对象、方法调用等）。',
        'The process of authorization has two different sides:': '授权过程有两个不同的方面：',
        'The user receives a specific role when logging in (e.g. ROLE_ADMIN).': '用户在登录时获得一个特定的角色（例如 <code translate="no" class="notranslate">ROLE_ADMIN</code>）。',
        'You add code so that a resource (e.g. URL, controller) requires a specific\n"attribute" (e.g. a role like ROLE_ADMIN) in order to be accessed.': '您添加代码，以便资源（例如 URL、控制器）需要具有特定的“属性”（例如角色 <code translate="no" class="notranslate">ROLE_ADMIN</code>）才能被访问。',

        'Roles': '角色',
        "When a user logs in, Symfony calls the getRoles() method on your User\nobject to determine which roles this user has. In the User class that\nwas generated earlier, the roles are an array that's stored in the\ndatabase and every user is always given at least one role: ROLE_USER:": '当用户登录时，Symfony 会在您的 <code translate="no" class="notranslate">User</code> 对象上调用 <code translate="no" class="notranslate">getRoles()</code> 方法来确定这个用户有哪些角色。在之前生成的 <code translate="no" class="notranslate">User</code> 类中，角色是一个存储在数据库中的数组，并且每个用户总是至少被赋予一个角色：<code translate="no" class="notranslate">ROLE_USER</code>。',
        "This is a nice default, but you can do whatever you want to determine which roles\na user should have. The only rule is that every role must start with the\nROLE_ prefix - otherwise, things won't work as expected. Other than that,\na role is just a string and you can invent whatever you need (e.g. ROLE_PRODUCT_ADMIN).": '这是一个很好的默认设置，但您可以根据需要确定用户应该具有哪些角色。唯一的规则是每个角色都必须以 <code translate="no" class="notranslate">ROLE_</code> 前缀开头——否则，事情将不会按预期工作。除此之外，角色只是一个字符串，您可以根据需要自行创建（例如 <code translate="no" class="notranslate">ROLE_PRODUCT_ADMIN</code>）。',
        "You'll use these roles next to grant access to specific sections of your site.": '接下来，您将使用这些角色来授予对网站特定部分的访问权限。',

        'Hierarchical Roles': '层次化角色',
        'Instead of giving many roles to each user, you can define role inheritance\nrules by creating a role hierarchy:': '与其为每个用户分配多个角色，您可以创建角色层次结构来定义角色继承规则：',
        'Users with the ROLE_ADMIN role will also have the ROLE_USER role.\nUsers with ROLE_SUPER_ADMIN, will automatically have ROLE_ADMIN,\nROLE_ALLOWED_TO_SWITCH and ROLE_USER (inherited from\nROLE_ADMIN).': '具有 <code translate="no" class="notranslate">ROLE_ADMIN</code> 角色的用户也将具有 <code translate="no" class="notranslate">ROLE_USER</code> 角色。具有 <code translate="no" class="notranslate">ROLE_SUPER_ADMIN</code> 角色的用户将自动拥有 <code translate="no" class="notranslate">ROLE_ADMIN</code>、<code translate="no" class="notranslate">ROLE_ALLOWED_TO_SWITCH</code> 和 <code translate="no" class="notranslate">ROLE_USER</code>（从 <code translate="no" class="notranslate">ROLE_ADMIN</code> 继承）。',
        'For role hierarchy to work, do not use $user->getRoles() manually.\nFor example, in a controller extending from the base controller:': '要使角色层次结构生效，请不要手动使用 <code translate="no" class="notranslate">$user-&gt;getRoles()</code>。例如，在扩展自基础控制器的控制器中：',
        "The role_hierarchy values are static - you can't, for example, store the\nrole hierarchy in a database. If you need that, create a custom\nsecurity voter that looks for the user roles\nin the database.": '<code translate="no" class="notranslate">role_hierarchy</code> 的值是静态的——你不能将角色层次结构存储在数据库中，例如。如果你需要这样做，请创建一个自定义的<a href="security/voters.html" class="reference internal">安全投票者</a>，该投票者在数据库中查找用户角色。',
        'Add Code to Deny Access': '添加代码以拒绝访问',
        'There are two ways to deny access to something:': '有两种方法可以拒绝访问某个资源：',
        'access_control in security.yaml\nallows you to protect URL patterns (e.g. /admin/*). Simpler, but less flexible;': '<a href="security.html#security-authorization-access-control" class="reference internal">在 security.yaml 中的 access_control</a> 允许您保护 URL 模式（例如 <code translate="no" class="notranslate">/admin/*</code）。这种方法更简单，但灵活性较差；',
        'in your controller (or other code).': '<a href="security.html#security-securing-controller" class="reference internal">在您的控制器（或其他代码）中</a>。',

        'Securing URL patterns (access_control)': '保护 URL 模式（access_control）',
        'The most basic way to secure part of your app is to secure an entire URL pattern\nin security.yaml. For example, to require ROLE_ADMIN for all URLs that\nstart with /admin, you can:': '保护应用程序部分的最基本方法是在 <code translate="no" class="notranslate">security.yaml</code> 中保护整个 URL 模式。例如，要求所有以 <code translate="no" class="notranslate">/admin</code> 开头的 URL 都需要 <code translate="no" class="notranslate">ROLE_ADMIN</code> 角色，您可以：',
        'You can define as many URL patterns as you need - each is a regular expression.\nBUT, only one will be matched per request: Symfony starts at the top of\nthe list and stops when it finds the first match:': '您可以根据需要定义任意数量的 URL 模式——每个都是一个正则表达式。但是，每个请求只会匹配一个模式：Symfony 从列表的顶部开始，并在找到第一个匹配项时停止：',
        'Prepending the path with ^ means that only URLs beginning with the\npattern are matched. For example, a path of /admin (without the ^)\nwould match /admin/foo but would also match URLs like /foo/admin.': '在路径前加上 <code translate="no" class="notranslate">^</code> 表示仅匹配以该模式开头的 URL。例如，路径 <code translate="no" class="notranslate">/admin</code>（没有 <code translate="no" class="notranslate">^</code>）将匹配 <code translate="no" class="notranslate">/admin/foo</code>，但也会匹配像 <code translate="no" class="notranslate">/foo/admin</code> 这样的 URL。',
        'Each access_control can also match on IP address, hostname and HTTP methods.\nIt can also be used to redirect a user to the https version of a URL pattern.\nFor more complex needs, you can also use a service implementing RequestMatcherInterface.': '每个 <code translate="no" class="notranslate">access_control</code> 也可以匹配 IP 地址、主机名和 HTTP 方法。它还可以用于将用户重定向到 URL 模式的 <code translate="no" class="notranslate">https</code> 版本。对于更复杂的需求，您还可以使用实现 <code translate="no" class="notranslate">RequestMatcherInterface</code> 的服务。',
        'See How Does the Security access_control Work?.': '请参阅 <a href="security/access_control.html" class="reference internal">Security access_control 是如何工作的？</a>。',

        'Securing Controllers and other Code' :'保护控制器和其它代码',
        'You can deny access from inside a controller:': '您可以在控制器内部拒绝访问：',
        "That's it! If access is not granted, a special\nAccessDeniedException\nis thrown and no more code in your controller is called. Then, one of two things\nwill happen:": '就这样！如果未授予访问权限，将抛出一个特殊的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Core/Exception/AccessDeniedException.php" class="reference external" title="Symfony\Component\Security\Core\Exception\AccessDeniedException" rel="external noopener noreferrer" target="_blank">AccessDeniedException</a> 异常，并且不会调用控制器中的更多代码。然后，将发生以下两种情况之一：',
        "If the user isn't logged in yet, they will be asked to log in (e.g. redirected\nto the login page).": '如果用户尚未登录，将要求他们登录（例如，重定向到登录页面）。',
        "If the user is logged in, but does not have the ROLE_ADMIN role, they'll\nbe shown the 403 access denied page (which you can\ncustomize).": '如果用户已登录，但没有 <code translate="no" class="notranslate">ROLE_ADMIN</code> 角色，他们将看到 403 访问被拒绝页面（您可以<a href="controller/error_pages.html#controller-error-pages-by-status-code" class="reference internal">自定义</a>该页面）。',
        'Another way to secure one or more controller actions is to use the #[IsGranted] attribute.\nIn the following example, all controller actions will require the\nROLE_ADMIN permission, except for adminDashboard(), which will require\nthe ROLE_SUPER_ADMIN permission:': '保护一个或多个控制器操作的另一种方法是使用 <code translate="no" class="notranslate">#[IsGranted]</code> 注解。在以下示例中，除了 <code translate="no" class="notranslate">adminDashboard()</code> 需要 <code translate="no" class="notranslate">ROLE_SUPER_ADMIN</code> 权限外，所有控制器操作都将需要 <code translate="no" class="notranslate">ROLE_ADMIN</code> 权限：',
        'If you want to use a custom status code instead of the default one (which\nis 403), this can be done by setting with the statusCode argument:': '如果您想使用自定义状态码而不是默认状态码（默认是 403），可以通过设置 <code translate="no" class="notranslate">statusCode</code> 参数来实现：',
        'You can also set the internal exception code of the\nAccessDeniedException\nthat is thrown with the exceptionCode argument:': '您还可以设置抛出的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Core/Exception/AccessDeniedException.php" class="reference external" title="Symfony\Component\Security\Core\Exception\AccessDeniedException" rel="external noopener noreferrer" target="_blank">AccessDeniedException</a> 的内部异常代码，使用 <code translate="no" class="notranslate">exceptionCode</code> 参数：',
        'The #[IsGranted] attribute was introduced in Symfony 6.2.': '<code translate="no" class="notranslate">#[IsGranted]</code> 注解在 Symfony 6.2 中被引入。',
        'The exceptionCode argument of the #[IsGranted] attribute was\nintroduced in Symfony 6.3.': '<code translate="no" class="notranslate">#[IsGranted]</code> 注解的 <code translate="no" class="notranslate">exceptionCode</code> 参数在 Symfony 6.3 中被引入。',

        'Access Control in Templates': '在模板中控制访问权限',
        'If you want to check if the current user has a certain role, you can use\nthe built-in is_granted() helper function in any Twig template:': '如果您想检查当前用户是否具有某个角色，您可以在任何 Twig 模板中使用内置的 <code translate="no" class="notranslate">is_granted()</code> 辅助函数：',

        'Securing other Services': '保护其它服务',
        'You can check access anywhere in your code by injecting the Security\nservice. For example, suppose you have a SalesReportManager service and you\nwant to include extra details only for users that have a ROLE_SALES_ADMIN role:': '您可以通过注入 <code translate="no" class="notranslate">Security</code> 服务在代码中的任何位置检查访问权限。例如，假设您有一个 <code translate="no" class="notranslate">SalesReportManager</code> 服务，并且您只想为具有 <code translate="no" class="notranslate">ROLE_SALES_ADMIN</code> 角色的用户包含额外详细信息：',
        "If you're using the default services.yaml configuration,\nSymfony will automatically pass the security.helper to your service\nthanks to autowiring and the Security type-hint.": '如果您使用的是<a href="service_container.html#service-container-services-load-example" class="reference internal">默认的 services.yaml 配置</a>，Symfony 将通过自动装配和 <code translate="no" class="notranslate">Security</code> 类型提示自动将 <code translate="no" class="notranslate">security.helper</code> 传递给您的服务。',
        'You can also use a lower-level\nAuthorizationCheckerInterface\nservice. It does the same thing as Security, but allows you to type-hint a\nmore-specific interface.': '您还可以使用更低级别的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Core/Authorization/AuthorizationCheckerInterface.php" class="reference external" title="Symfony\Component\Security\Core\Authorization\AuthorizationCheckerInterface" rel="external noopener noreferrer" target="_blank">AuthorizationCheckerInterface</a> 服务。它与 <code translate="no" class="notranslate">Security</code> 服务做同样的事情，但允许您使用更具体的接口进行类型提示。',
        'When a visitor isn\'t yet logged in to your website, they are treated as\n"unauthenticated" and don\'t have any roles. This will block them from\nvisiting your pages if you defined an access_control rule.': '当访问者尚未登录到您的网站时，他们被视为“未经验证”并且没有任何角色。如果您定义了 <code translate="no" class="notranslate">access_control</code> 规则，这将阻止他们访问您的页面。',
        'In the access_control configuration, you can use the PUBLIC_ACCESS\nsecurity attribute to exclude some routes for unauthenticated access (e.g.\nthe login page):': '在 <code translate="no" class="notranslate">access_control</code> 配置中，您可以使用 <code translate="no" class="notranslate">PUBLIC_ACCESS</code> 安全属性来排除一些未经验证的访问路由（例如登录页面）：',

        'Granting Anonymous Users Access in a Custom Voter': '在自定义 Voter 中授予匿名用户访问权限',
        "If you're using a custom voter, you can allow\nanonymous users access by checking if there is no user set on the token:": '如果您使用<a href="security/voters.html" class="reference internal">自定义 voter</a>，可以通过检查令牌上是否没有设置用户来允许匿名用户访问：',

        'Setting Individual User Permissions': '设置单个用户权限',
        'Most applications require more specific access rules. For instance, a user\nshould be able to only edit their own comments on a blog. Voters allow you\nto write whatever business logic you need to determine access. Using\nthese voters is similar to the role-based access checks implemented in the\nprevious chapters. Read How to Use Voters to Check User Permissions to learn how to implement\nyour own voter.': '大多数应用程序需要更具体的访问规则。例如，用户应该只能编辑博客上他们自己的评论。投票者允许您编写所需的任何业务逻辑来确定访问权限。使用这些 voters 与前面章节中实现的基于角色的访问检查类似。阅读<a href="security/voters.html" class="reference internal">如何使用投票者检查用户权限</a>以了解如何实现您自己的 voter。',

        'Checking to see if a User is Logged In': '检查用户是否已登录',
        "If you only want to check if a user is logged in (you don't care about roles),\nyou have the following two options.": '如果您只想检查用户是否已登录（不关心角色），您有以下两种选择。',
        "Firstly, if you've given every user ROLE_USER, you can check for that role.": '首先，如果您已经为每个用户分配了 <code translate="no" class="notranslate">ROLE_USER</code> 角色，您可以检查该角色。',
        'Secondly, you can use the special "attribute" IS_AUTHENTICATED_FULLY in place of a role:': '其次，您可以使用特殊的“属性”<code translate="no" class="notranslate">IS_AUTHENTICATED_FULLY</code> 来代替角色：',
        'You can use IS_AUTHENTICATED anywhere roles are used: like\naccess_control or in Twig.': '您可以在使用角色的任何地方使用 <code translate="no" class="notranslate">IS_AUTHENTICATED</code>：例如在 <code translate="no" class="notranslate">access_control</code> 或 Twig 中。',
        "IS_AUTHENTICATED isn't a role, but it kind of acts like one, and every\nuser that has logged in will have this. Actually, there are some special attributes\nlike this:": '<code translate="no" class="notranslate">IS_AUTHENTICATED</code> 不是角色，但它有点像角色，每个已登录的用户都会有这个属性。实际上，有一些这样的特殊属性：',
        'IS_AUTHENTICATED_FULLY: This is similar to IS_AUTHENTICATED_REMEMBERED,\nbut stronger. Users who are logged in only because of a "remember me cookie"\nwill have IS_AUTHENTICATED_REMEMBERED but will not have IS_AUTHENTICATED_FULLY.': '<code translate="no" class="notranslate">IS_AUTHENTICATED_FULLY</code>：这与 <code translate="no" class="notranslate">IS_AUTHENTICATED_REMEMBERED</code> 类似，但更强。仅因为“记住我”的 cookie 而登录的用户将具有 <code translate="no" class="notranslate">IS_AUTHENTICATED_REMEMBERED</code>，但不会具有 <code translate="no" class="notranslate">IS_AUTHENTICATED_FULLY</code>。',
        'IS_REMEMBERED: Only users authenticated using the\nremember me functionality, (i.e. a\nremember-me cookie).': '<code translate="no" class="notranslate">IS_REMEMBERED</code>：仅使用<a href="security/remember_me.html" class="reference internal">“记住我”功能</a>（即记住我 cookie）进行身份验证的用户。',
        'IS_IMPERSONATOR: When the current user is\nimpersonating another user in this\nsession, this attribute will match.': '<code translate="no" class="notranslate">IS_IMPERSONATOR</code>：当当前用户在此会话中<a href="security/impersonating_user.html" class="reference internal">模拟</a>另一个用户时，此属性将匹配。',
        "All logged in users also have an attribute called IS_AUTHENTICATED_REMEMBERED,\neven if the application doesn't use the Remember Me feature. This attribute\nexists for backward-compatibility reasons with Symfony versions prior to 6.4.": '所有已登录的用户还有一个名为 <code translate="no" class="notranslate">IS_AUTHENTICATED_REMEMBERED</code> 的属性，即使应用程序不使用“记住我”功能也是如此。该属性存在的原因是为了与 6.4 版本之前的 Symfony 版本向后兼容。',
        "This attribute behaves the same as IS_AUTHENTICATED. That's why in modern\nSymfony applications it's recommended to no longer use IS_AUTHENTICATED_REMEMBERED.": '该属性的行为与 <code translate="no" class="notranslate">IS_AUTHENTICATED</code> 相同。这就是为什么在现代 Symfony 应用程序中建议不再使用 <code translate="no" class="notranslate">IS_AUTHENTICATED_REMEMBERED</code> 的原因。',

        'Understanding how Users are Refreshed from the Session': '理解如何从会话中刷新用户对象',
        'At the end of every request (unless your firewall is stateless), your\nUser object is serialized to the session. At the beginning of the next\nrequest, it\'s deserialized and then passed to your user provider to "refresh" it\n(e.g. Doctrine queries for a fresh user).': '在每个请求的末尾（除非您的防火墙是 <code translate="no" class="notranslate">stateless</code>），您的 <code translate="no" class="notranslate">User</code> 对象将被序列化到会话中。在下一个请求开始时，它将被反序列化，然后传递给您的用户提供者以“刷新”它（例如，Doctrine 查询新的用户）。',
        'Then, the two User objects (the original from the session and the refreshed User\nobject) are "compared" to see if they are "equal". By default, the core\nAbstractToken class compares the return values of the getPassword(),\ngetSalt() and getUserIdentifier() methods. If any of these are different,\nyour user will be logged out. This is a security measure to make sure that malicious\nusers can be de-authenticated if core user data changes.': '然后，将两个 User 对象（来自会话的原始对象和刷新的 User 对象）进行“比较”，以查看它们是否“相等”。默认情况下，核心的 <code translate="no" class="notranslate">AbstractToken</code> 类会比较 <code translate="no" class="notranslate">getPassword()</code>、<code translate="no" class="notranslate">getSalt()</code> 和 <code translate="no" class="notranslate">getUserIdentifier()</code> 方法的返回值。如果其中任何一个不同，您的用户将被注销。这是一项安全措施，以确保在核心用户数据发生变化时，恶意用户可以被取消身份验证。',
        "However, in some cases, this process can cause unexpected authentication problems.\nIf you're having problems authenticating, it could be that you are authenticating\nsuccessfully, but you immediately lose authentication after the first redirect.": '但是，在某些情况下，此过程可能会导致意外的身份验证问题。如果您在身份验证时遇到问题，可能是您已成功进行身份验证，但在第一次重定向后立即失去了身份验证。',
        'In that case, review the serialization logic (e.g. the __serialize() or\nserialize() methods) on your user class (if you have any) to make sure\nthat all the fields necessary are serialized and also exclude all the\nfields not necessary to be serialized (e.g. Doctrine relations).': '在这种情况下，请检查您的用户类（如果有）上的序列化逻辑（例如 <code translate="no" class="notranslate">__serialize()</code> 或 <code translate="no" class="notranslate">serialize()</code> 方法），以确保所有必要的字段都被序列化，并排除所有不需要序列化的字段（例如 Doctrine 关联）。',

        'Comparing Users Manually with EquatableInterface': '使用 EquatableInterface 手动比较用户对象',
        'Or, if you need more control over the "compare users" process, make your User class\nimplement EquatableInterface.\nThen, your isEqualTo() method will be called when comparing users instead\nof the core logic.': '或者，如果您需要更多控制“比较用户”过程，请让您的 User 类实现  <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Core/User/EquatableInterface.php" class="reference external" title="Symfony\Component\Security\Core\User\EquatableInterface" rel="external noopener noreferrer" target="_blank">EquatableInterface</a>。然后，在比较用户时，将调用您的 <code translate="no" class="notranslate">isEqualTo()</code> 方法，而不是核心逻辑。',

        'Security Events': '安全事件',
        'During the authentication process, multiple events are dispatched that allow you\nto hook into the process or customize the response sent back to the user. You\ncan do this by creating an event listener or subscriber\nfor these events.': '在身份验证过程中，会触发多个事件，允许您挂钩到该过程或自定义发送回给用户的响应。您可以通过为这些事件创建<a href="event_dispatcher.html" class="reference internal">事件监听器或订阅者</a>来实现这一点。',
        'Every Security firewall has its own event dispatcher\n(security.event_dispatcher.FIREWALLNAME). Events are dispatched on\nboth the global and the firewall-specific dispatcher. You can register\non the firewall dispatcher if you want your listener to only be\ncalled for a specific firewall. For instance, if you have an api\nand main firewall, use this configuration to register only on the\nlogout event in the main firewall:': '每个安全防火墙都有自己的事件调度器（<code translate="no" class="notranslate">security.event_dispatcher.FIREWALLNAME</code>）。事件将在全局调度器和特定于防火墙的调度器上触发。如果您只想让监听器在特定防火墙中调用，可以在防火墙调度器上注册。例如，如果您有一个 API 防火墙和一个 <code translate="no" class="notranslate">main</code> 防火墙，请使用以下配置仅在 <code translate="no" class="notranslate">main</code> 防火墙的注销事件上注册：',

        'Authentication Events': '身份验证事件',
        '\n                            Dispatched after the authenticator created the security passport.\nListeners of this event do the actual authentication checks (like\nchecking the passport, validating the CSRF token, etc.)\n                    ': '在安全认证器创建<a href="security/custom_authenticator.html#security-passport" class="reference internal">安全护照</a>后触发此事件。此事件的监听器执行实际的身份验证检查（如检查护照、验证 CSRF 令牌等）。',
        '\n                            Dispatched after the passport was validated and the authenticator\ncreated the security token (and user). This can be used in advanced use-cases\nwhere you need to modify the created token (e.g. for multi factor\nauthentication).\n                    ': '在护照验证后，且认证器创建了安全令牌（和用户）后触发此事件。这可以在高级用例中使用，当您需要修改创建的令牌时（例如，用于多因素身份验证）。',
        '\n                            Dispatched when authentication is nearing success. This is the last\nevent that can make an authentication fail by throwing an\nAuthenticationException.\n                    ': '在身份验证即将成功时触发。这是通过抛出 <code translate="no" class="notranslate">AuthenticationException</code> 可以使身份验证失败的最后一个事件。',
        '\n                            Dispatched after authentication was fully successful. Listeners to this\nevent can modify the response sent back to the user.\n                    ': '在身份验证完全成功后触发。此事件的监听器可以修改发送回给用户的响应。',
        '\n                            Dispatched after an AuthenticationException was thrown during\nauthentication. Listeners to this event can modify the error response\nsent back to the user.\n                    ': '在身份验证过程中抛出 <code translate="no" class="notranslate">AuthenticationException</code> 后触发。此事件的监听器可以修改发送回给用户的错误响应。',

        'Other Events': '其它事件',
        '\n                            Dispatched after authentication was fully successful only when the authenticator\nimplements InteractiveAuthenticatorInterface,\nwhich indicates login requires explicit user action (e.g. a login form).\nListeners to this event can modify the response sent back to the user.\n                    ': '仅当认证器实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Http/Authenticator/InteractiveAuthenticatorInterface.php" class="reference external" title="Symfony\Component\Security\Http\Authenticator\InteractiveAuthenticatorInterface" rel="external noopener noreferrer" target="_blank">InteractiveAuthenticatorInterface</a> 时，在身份验证完全成功后触发此事件，这表明登录需要明确的用户操作（例如登录表单）。此事件的监听器可以修改发送回给用户的响应。',
        '\n                            Dispatched just before a user logs out of your application. See\nSecurity.\n                    ': '在用户从您的应用程序注销之前立即触发。请参阅<a href="security.html#security-logging-out" class="reference internal">安全</a>。',
        '\n                            Dispatched when a user is deauthenticated, for instance because the\npassword was changed. See Security.\n                    ': '在用户被取消身份验证时触发，例如因为密码被更改。请参阅<a href="security.html#user_session_refresh" class="reference internal">安全</a>。',
        '\n                            Dispatched after impersonation is completed. See\nHow to Impersonate a User.\n                    ': '在模拟完成后触发。请参阅<a href="security/impersonating_user.html" class="reference internal">如何模拟用户</a>。',

        'Frequently Asked Questions': '常见问题',
        'Can I have Multiple Firewalls?': '我可以有多个防火墙吗？',
        "\n                            Yes! However, each firewall is like a separate security system: being authenticated\nin one firewall doesn't make you authenticated in another one. Each firewall can have\nmultiple ways of allowing authentication (e.g. form login, and API key authentication).\nIf you want to share authentication between firewalls, you have to explicitly\nspecify the same Security Configuration Reference (SecurityBundle) for different firewalls.\n                    ": '是的！但是，每个防火墙都像是一个独立的安全系统：在一个防火墙中进行身份验证并不会使您在另一个防火墙中也获得身份验证。每个防火墙可以有多种允许身份验证的方式（例如表单登录和 API 密钥身份验证）。如果您想在不同防火墙之间共享身份验证，则需要明确为不同的防火墙指定相同的<a href="reference/configuration/security.html#reference-security-firewall-context" class="reference internal">安全配置引用（SecurityBundle）</a>。',
        'Security doesn\'t seem to work on my Error Pages': '在我的错误页面上，安全性似乎不起作用',
        "\n                            As routing is done before security, 404 error pages are not covered by\nany firewall. This means you can't check for security or even access the\nuser object on these pages. See How to Customize Error Pages\nfor more details.\n                    ": '由于路由是在安全之前完成的，所以404错误页面不受任何防火墙的保护。这意味着您无法检查安全性，甚至无法访问这些页面上的用户对象。有关详细信息，请参见<a href="controller/error_pages.html" class="reference internal">如何自定义错误页</a>。',
        'My Authentication Doesn\'t Seem to Work: No Errors, but I\'m Never Logged In': '我的身份验证似乎不起作用：没有错误，但我从未登录过',
        "\n                            Sometimes authentication may be successful, but after redirecting, you're\nlogged out immediately due to a problem loading the User from the session.\nTo see if this is an issue, check your log file (var/log/dev.log) for\nthe log message.\n                    ": '有时身份验证可能成功，但在重定向后，由于从会话中加载 <code translate="no" class="notranslate">User</code> 时出现问题，您会立即被注销。要查看这是否是问题所在，请检查日志文件（<code translate="no" class="notranslate">var/log/dev.log</code>）中的日志消息。',
        'Cannot refresh token because user has changed': '无法刷新令牌，因为用户已更改',
        '\n                            If you see this, there are two possible causes. First, there may be a problem\nloading your User from the session. See Security. Second,\nif certain user information was changed in the database since the last page\nrefresh, Symfony will purposely log out the user for security reasons.\n                    ': '如果你看到这个提示，有两种可能的原因。首先，从会话中加载用户时可能存在问题。请查看<a href="security.html#user_session_refresh" class="reference internal">安全性设置</a>。其次，如果自上次页面刷新以来在数据库中更改了某些用户信息，出于安全原因，Symfony 会故意注销该用户。',

        'Learn More': '了解更多',
        'Authentication (Identifying/Logging in the User)': '身份验证（识别/用户登录）',
        'Authorization (Denying Access)': '授权（拒绝访问）',
    };

    fanyi(translates, 1, true);
})($);
