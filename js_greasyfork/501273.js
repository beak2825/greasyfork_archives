// ==UserScript==
// @name         Symfony 翻译文档 routing/custom_route_loader.html
// @namespace    fireloong
// @version      0.1.4
// @description  翻译文档 routing/custom_route_loader.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/routing/custom_route_loader.html
// @match        https://symfony.com/doc/6.4/routing/custom_route_loader.html
// @match        https://symfony.com/doc/7.1/routing/custom_route_loader.html
// @match        https://symfony.com/doc/7.2/routing/custom_route_loader.html
// @match        https://symfony.com/doc/current/routing/custom_route_loader.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/501273/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20routingcustom_route_loaderhtml.user.js
// @updateURL https://update.greasyfork.org/scripts/501273/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20routingcustom_route_loaderhtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        '\n        \n                    How to Create a custom Route Loader\n        \n            ': '如何创建自定义路由加载器',
         "Basic applications can define all their routes in a single configuration file -\nusually config/routes.yaml (see Routing).\nHowever, in most applications it's common to import routes definitions from\ndifferent resources: PHP attributes in controller files, YAML, XML\nor PHP files stored in some directory, etc.": '基本应用可以在单个配置文件中定义所有路由——通常是 <code translate="no" class="notranslate">config/routes.yaml</code>（参见<a href="../routing.html#routing-creating-routes" class="reference internal">路由</a>）。然而，在大多数应用中，从不同的资源中导入路由定义是很常见的：如控制器文件中的PHP属性，存储在特定目录下的YAML、XML或PHP文件等。',
        'Built-in Route Loaders': '内置路由加载器',
        'Symfony provides several route loaders for the most common needs:': 'Symfony 为最常见的需求提供了几种路由加载器：',
        'The attribute value of the second argument of import() was introduced\nin Symfony 6.1.': '在 Symfony 6.1 中引入了 <code translate="no" class="notranslate">import()</code> 函数的第二个参数的 <code translate="no" class="notranslate">attribute</code> 值。',
        'The feature to import routes from a PSR-4 namespace root was introduced in Symfony 6.2.': '从 PSR-4 命名空间根目录导入路由的功能是在 Symfony 6.2 中引入的。',
        "When importing resources, the key (e.g. app_file) is the name of the collection.\nJust be sure that it's unique per file so no other lines override it.": '在导入资源时，键（例如 <code translate="no" class="notranslate">app_file</code>）是集合的名称。只要确保它在每个文件中都是唯一的，这样其它行就不会覆盖它。',
        'If your application needs are different, you can create your own custom route\nloader as explained in the next section.': '如果你的应用需求不同，你可以按照下一节中的说明创建自己的自定义路由加载器。',

        'What is a Custom Route Loader': '什么是自定义路由加载器',
        'A custom route loader enables you to generate routes based on some\nconventions, patterns or integrations. An example for this use-case is the\nOpenAPI-Symfony-Routing library where routes are generated based on\nOpenAPI/Swagger attributes. Another example is the SonataAdminBundle that\ncreates routes based on CRUD conventions.': '自定义路由加载器允许您根据某些约定、模式或集成来生成路由。这种用例的一个例子是 <a href="https://github.com/Tobion/OpenAPI-Symfony-Routing" class="reference external" rel="external noopener noreferrer" target="_blank">OpenAPI-Symfony-Routing</a> 库，其中路由是根据 OpenAPI/Swagger 属性生成的。另一个例子是 <a href="https://github.com/sonata-project/SonataAdminBundle" class="reference external" rel="external noopener noreferrer" target="_blank">SonataAdminBundle</a>，它根据 CRUD 约定创建路由。',

        'Loading Routes': '加载路由',
        'The routes in a Symfony application are loaded by the\nDelegatingLoader.\nThis loader uses several other loaders (delegates) to load resources of\ndifferent types, for instance YAML files or #[Route] attributes in controller\nfiles. The specialized loaders implement\nLoaderInterface\nand therefore have two important methods:\nsupports()\nand load().': '在 Symfony 应用中，路由是由 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Routing/DelegatingLoader.php" class="reference external" title="Symfony\Bundle\FrameworkBundle\Routing\DelegatingLoader" rel="external noopener noreferrer" target="_blank">DelegatingLoader</a> 加载的。这个加载器使用多个其它加载器（委托）来加载不同类型的资源，例如 YAML 文件或控制器文件中的 <code translate="no" class="notranslate">#[Route]</code> 注解。专业的加载器实现了 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/LoaderInterface.php" class="reference external" title="Symfony\Component\Config\Loader\LoaderInterface" rel="external noopener noreferrer" target="_blank">LoaderInterface</a>，因此有两个重要的方法：<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/LoaderInterface.php#:~:text=function%20supports" class="reference external" title="Symfony\Component\Config\Loader\LoaderInterface::supports()" rel="external noopener noreferrer" target="_blank">supports()</a> 和 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/LoaderInterface.php#:~:text=function%20load" class="reference external" title="Symfony\Component\Config\Loader\LoaderInterface::load()" rel="external noopener noreferrer" target="_blank">load()</a>。',
        'Take these lines from the routes.yaml:': '从 <code translate="no" class="notranslate">routes.yaml</code> 中取出以下行：',
        'When the main loader parses this, it tries all registered delegate loaders and calls\ntheir supports()\nmethod with the given resource (../src/Controller/)\nand type (attribute) as arguments. When one of the loader returns true,\nits load() method\nwill be called, which should return a RouteCollection\ncontaining Route objects.': '当主加载器解析这个时，它会尝试所有已注册的委托加载器，并调用它们的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/LoaderInterface.php#:~:text=function%20supports" class="reference external" title="Symfony\Component\Config\Loader\LoaderInterface::supports()" rel="external noopener noreferrer" target="_blank">supports()</a> 方法，以给定的资源（<code translate="no" class="notranslate">../src/Controller/</code>）和类型（<code translate="no" class="notranslate">attribute</code>）作为参数。当其中一个加载器返回 <code translate="no" class="notranslate">true</code> 时，它的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/LoaderInterface.php#:~:text=function%20load" class="reference external" title="Symfony\Component\Config\Loader\LoaderInterface::load()" rel="external noopener noreferrer" target="_blank">load()</a> 方法将被调用，该方法应该返回一个包含 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Routing/Route.php" class="reference external" title="Symfony\Component\Routing\Route" rel="external noopener noreferrer" target="_blank">Route</a> 对象的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Routing/RouteCollection.php" class="reference external" title="Symfony\Component\Routing\RouteCollection" rel="external noopener noreferrer" target="_blank">RouteCollection</a>。',
        'Routes loaded this way will be cached by the Router the same way as\nwhen they are defined in one of the default formats (e.g. XML, YAML,\nPHP file).': '以这种方式加载的路由将由路由器进行缓存，与在默认格式之一（例如 XML、YAML、PHP 文件）中定义它们时的方式相同。',

        'Loading Routes with a Custom Service': '使用自定义服务加载路由',
        "Using a regular Symfony service is the simplest way to load routes in a\ncustomized way. It's much easier than creating a full custom route loader, so\nyou should always consider this option first.": '使用常规的 Symfony 服务是自定义加载路由的最简单方式。这比创建一个完整的自定义路由加载器要容易得多，因此您应该首先考虑这个选项。',
        'To do so, define type: service as the type of the loaded routing resource\nand configure the service and method to call:': '要做到这一点，将加载的路由资源的类型定义为 <code translate="no" class="notranslate">type: service</code>，并配置要调用的服务和方法：',
        "In this example, the routes are loaded by calling the loadRoutes() method\nof the service whose ID is admin_route_loader. Your service doesn't have to\nextend or implement any special class, but the called method must return a\nRouteCollection object.": '在这个例子中，路由是通过调用 ID 为 <code translate="no" class="notranslate">admin_route_loader</code> 的服务的 <code translate="no" class="notranslate">loadRoutes()</code> 方法来加载的。您的服务不需要扩展或实现任何特殊的类，但是被调用的方法必须返回一个 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Routing/RouteCollection.php" class="reference external" title="Symfony\Component\Routing\RouteCollection" rel="external noopener noreferrer" target="_blank">RouteCollection</a> 对象。',
        "If you're using autoconfigure, your class should\nimplement the RouteLoaderInterface\ninterface to be tagged automatically. If you're not using autoconfigure,\ntag it manually with routing.route_loader.": '如果您正在使用<a href="../service_container.html#services-autoconfigure" class="reference internal">自动配置</a>，您的类应该实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Routing/RouteLoaderInterface.php" class="reference external" title="Symfony\Bundle\FrameworkBundle\Routing\RouteLoaderInterface" rel="external noopener noreferrer" target="_blank">RouteLoaderInterface</a> 接口以便自动打标签。如果您<strong>没有使用自动配置</strong>，请手动使用 <code translate="no" class="notranslate">routing.route_loader</code> 标签来标记它。',
        "The routes defined using service route loaders will be automatically\ncached by the framework. So whenever your service should load new routes,\ndon't forget to clear the cache.": '使用服务路由加载器定义的路由将被框架自动缓存。因此，每当您的服务需要加载新路由时，请不要忘记清除缓存。',
        "If your service is invokable, you don't need to specify the method to use.": '如果您的服务是可调用的，则无需指定要使用的方法。',

        'Creating a custom Loader': '创建自定义加载器',
        'To load routes from some custom source (i.e. from something other than attributes,\nYAML or XML files), you need to create a custom route loader. This loader\nhas to implement LoaderInterface.': '要从某些自定义源（即除属性、YAML 或 XML文件之外的其它源）加载路由，您需要创建一个自定义路由加载器。此加载器必须实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/LoaderInterface.php" class="reference external" title="Symfony\Component\Config\Loader\LoaderInterface" rel="external noopener noreferrer" target="_blank">LoaderInterface</a>。',
        'In most cases it is easier to extend from\nLoader instead of implementing\nLoaderInterface yourself.': '在大多数情况下，扩展 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/Loader.php" class="reference external" title="Symfony\Component\Config\Loader\Loader" rel="external noopener noreferrer" target="_blank">Loader</a> 比自己实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/LoaderInterface.php" class="reference external" title="Symfony\Component\Config\Loader\LoaderInterface" rel="external noopener noreferrer" target="_blank">LoaderInterface</a> 更容易。',
        'The sample loader below supports loading routing resources with a type of\nextra. The type name should not clash with other loaders that might\nsupport the same type of resource. Make up any name specific to what\nyou do. The resource name itself is not actually used in the example:': '下面的示例加载器支持加载类型为 <code translate="no" class="notranslate">extra</code> 的路由资源。类型名称不应与其它可能支持相同类型资源的加载器冲突。请根据您所做的操作来命名。在示例中，资源名称本身实际上并未使用：',
        'Make sure the controller you specify really exists. In this case you\nhave to create an extra() method in the ExtraController:': '请确保您指定的控制器确实存在。在这种情况下，您必须在 <code translate="no" class="notranslate">ExtraController</code> 中创建一个 <code translate="no" class="notranslate">extra()</code> 方法：',
        'Now define a service for the ExtraLoader:': '现在为 <code translate="no" class="notranslate">ExtraLoader</code> 定义一个服务：',
        'Notice the tag routing.loader. All services with this tag will be marked\nas potential route loaders and added as specialized route loaders to the\nrouting.loader service, which is an instance of\nDelegatingLoader.': '注意 <code translate="no" class="notranslate">routing.loader</code> 标签。所有带有此标签的服务都将被标记为潜在的路由加载器，并作为专门的路由加载器添加到 <code translate="no" class="notranslate">routing.loader</code> 服务中，该服务是 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Routing/DelegatingLoader.php" class="reference external" title="Symfony\Bundle\FrameworkBundle\Routing\DelegatingLoader" rel="external noopener noreferrer" target="_blank">DelegatingLoader</a> 的实例。',

        'Using the Custom Loader': '使用自定义加载器',
        'If you did nothing else, your custom routing loader would not be called.\nWhat remains to do is adding a few lines to the routing configuration:': '如果您没有执行其它操作，那么您的自定义路由加载器将不会被调用。接下来要做的就是向路由配置中添加几行代码：',
        'The important part here is the type key. Its value should be extra as\nthis is the type which the ExtraLoader supports and this will make sure\nits load() method gets called. The resource key is insignificant\nfor the ExtraLoader, so it is set to . (a single dot).': '这里的关键是 <code translate="no" class="notranslate">type</code> 键。它的值应该是 <code translate="no" class="notranslate">extra</code>，因为这是 <code translate="no" class="notranslate">ExtraLoader</code> 支持的类型，这将确保调用其 <code translate="no" class="notranslate">load()</code> 方法。对于 <code translate="no" class="notranslate">ExtraLoader</code> 来说，<code translate="no" class="notranslate">resource</code> 键并不重要，因此它被设置为 <code translate="no" class="notranslate">.</code>（单个点）。',
        "The routes defined using custom route loaders will be automatically\ncached by the framework. So whenever you change something in the loader\nclass itself, don't forget to clear the cache.": '使用自定义路由加载器定义的路由将被框架自动缓存。因此，每当您在加载器类本身中更改某些内容时，请不要忘记清除缓存。',

        'More Advanced Loaders': '更高级的加载器',
        'If your custom route loader extends from\nLoader as shown above, you\ncan also make use of the provided resolver, an instance of\nLoaderResolver, to load secondary\nrouting resources.': '如果您的自定义路由加载器如上面所示扩展自 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/Loader.php" class="reference external" title="Symfony\Component\Config\Loader\Loader" rel="external noopener noreferrer" target="_blank">Loader</a>，您还可以使用提供的解析器（<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/LoaderResolver.php" class="reference external" title="Symfony\Component\Config\Loader\LoaderResolver" rel="external noopener noreferrer" target="_blank">LoaderResolver</a> 的实例）来加载辅助路由资源。',
        'You still need to implement\nsupports()\nand load().\nWhenever you want to load another resource - for instance a YAML routing\nconfiguration file - you can call the\nimport() method:': '您仍然需要实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/LoaderInterface.php#:~:text=function%20supports" class="reference external" title="Symfony\Component\Config\Loader\LoaderInterface::supports()" rel="external noopener noreferrer" target="_blank">supports()</a> 和 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/LoaderInterface.php#:~:text=function%20load" class="reference external" title="Symfony\Component\Config\Loader\LoaderInterface::load()" rel="external noopener noreferrer" target="_blank">load()</a>。每当您想要加载另一个资源时（例如 YAML 路由配置文件），您可以调用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Config/Loader/Loader.php#:~:text=function%20import" class="reference external" title="Symfony\Component\Config\Loader\Loader::import()" rel="external noopener noreferrer" target="_blank">import()</a> 方法：',
        'The resource name and type of the imported routing configuration can\nbe anything that would normally be supported by the routing configuration\nloader (YAML, XML, PHP, attribute, etc.).': '导入的路由配置的资源名称和类型可以是路由配置加载器通常支持的任何内容（YAML、XML、PHP、注解等）。',
        'For more advanced uses, check out the ChainRouter provided by the Symfony\nCMF project. This router allows applications to use two or more routers\ncombined, for example to keep using the default Symfony routing system when\nwriting a custom router.': '对于更高级的使用，请查看 Symfony CMF 项目提供的 <a href="https://symfony.com/doc/current/cmf/components/routing/chain.html" class="reference external">ChainRouter</a>。此路由器允许应用程序结合使用两个或多个路由器，例如，在编写自定义路由器时继续使用默认的 Symfony 路由系统。'
    };

    fanyi(translates, 1);
})($);
