// ==UserScript==
// @name         DemonicScans Unified Automator
// @namespace    https://github.com/wverri/autods
// @version      0.7.19-alpha
// @description  Consolidated automation suite for DemonicScans: wave battles, PvP, farming, UI enhancements, and image blocking.
// @author       Willian Verri
// @match        https://demonicscans.org/*
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_deleteValue
// @grant        GM_addStyle
// @grant        GM_xmlhttpRequest
// @grant        unsafeWindow
// @run-at       document-start
// @license MIT
// @downloadURL https://update.greasyfork.org/scripts/553682/DemonicScans%20Unified%20Automator.user.js
// @updateURL https://update.greasyfork.org/scripts/553682/DemonicScans%20Unified%20Automator.meta.js
// ==/UserScript==

var version = GM_info.script.version;

(function unifiedAutomator() {
    'use strict';

    const SCRIPT_VERSION = version;
    
    const STORAGE_NAMESPACE = 'autods.v1';
    const IS_TAMPERMONKEY = typeof GM_getValue === 'function' && typeof GM_setValue === 'function';
    const STORAGE_KEYS = Object.freeze({
        lastWaveUrl: 'session.lastWaveUrl'
    });
    const PANEL_WIDTH_PX = 200;
    const MIN_PANEL_WIDTH_PX = 300;
    const TOOLBAR_HEIGHT_FALLBACK = 56;
    const MAX_PERSISTENT_LOGS = 100;

    const DEFAULT_CONFIG = Object.freeze({
        core: {
            enabled: true,
            logLevel: 'info',
            shadowDom: true,
            unlockAttackButtons: true,  // Always unlock attack buttons (manual + auto)
            userId: null  // User ID for AJAX requests (auto-detected or manually set)
        },
        stamina: {
            minThreshold: 0,  // Stamina mÃ­nima necessÃ¡ria para entrar em batalha (0 = sem verificaÃ§Ã£o)
            checkIntervalMs: 300000  // 5 minutos entre verificaÃ§Ãµes quando aguardando regeneraÃ§Ã£o
        },
        wave: {
            enabled: true,
            monsterNames: ['Bonecrusher'],  // Legacy - kept for backward compatibility
            priorityMode: 'lowest_hp',
            minMobHp: 100000,
            monsterFilter: {
                maxHp: 0,
                minDamage: 0,
                includeNames: [],  // Whitelist - only target these names
                excludeNames: []   // Blacklist - skip these names
            },
            loot: {
                enabled: true,
                parallelOperations: 3
            },
            maxConcurrentBattles: 5,
            maxBattlesReloadMs: 30000,
            ultraFastMode: false,
            ultraFastConfig: {
                parallelAttacks: 10,
                skillId: -2,
                minDelayBetweenAttacks: 30,
                damageTarget: 3000000,
                autoFSP: true,
                minStaminaForFSP: 100,
                lootDeadBeforeFSP: true,
                monsterFilter: {
                    includeNames: [],  // Whitelist - only target these names (empty = all)
                    excludeNames: []   // Blacklist - skip these names
                }
            }
        },
        dungeonWave: {
            // enabled: true,  // â† ADICIONAR ISTO - necessÃ¡rio para module activation
            monsterNames: [],  // Legacy - kept for backward compatibility
            priorityMode: 'lowest_hp',
            minMobHp: 4000000,
            monsterFilter: {
                maxHp: 0,
                minDamage: 0,
                includeNames: [],  // Whitelist - only target these names
                excludeNames: []   // Blacklist - skip these names
            },
            loot: {
                enabled: true,
                parallelOperations: 3
            },
            defaultDamageTarget: 3000000,
            magusDamageTarget: 1000000,
            showDamagePills: true,
            showExpPills: true,
            showZeroJoined: true,
            hpFilterOptions: ['20-50%', '50-80%', '80-100%', '100%'],
            lootAllEnabled: true
        },
        battle: {
            enabled: true,
            minDamageTarget: 100000,
            attackSkillId: 0,
            delayBaseMs: 1000,
            delayVariation: 0.3,
            randomizeDelays: true,
            smartDamage: {
                enabled: false,
                skills: {
                    slash: { skillId: 0, damageLimit: 0, name: 'Slash' },
                    powerSlash: { skillId: -1, damageLimit: 320000, name: 'Power Slash' },
                    heroicSlash: { skillId: -2, damageLimit: 1600000, name: 'Heroic Slash' },
                    ultimateSlash: { skillId: -3, damageLimit: 3400000, name: 'Ultimate Slash' },
                    legendarySlash: { skillId: -4, damageLimit: 6800000, name: 'Legendary Slash' }
                }
            }
        },
        ultraFastBoss: {
            targetDamage: 1000000000,  // 1B default target
            skillId: -2,  // Heroic Slash (50 stamina)
            autoPotion: true,  // Auto-use Full Stamina Potion
            parallelAttacks: 10,  // Number of simultaneous attacks per batch
            minDelayBetweenAttacks: 30,  // ms between attack batches
            // Runtime state (not saved)
            running: false,
            currentDamage: 0,
            attackCount: 0,
            potionsUsed: 0
        },
        credentials: {
            email: '',
            password: ''
        },
        pvp: {
            enabled: true,// Enable/disable PvP automation
            autoMode: 'limited',
            limitedBattles: 10,
            autoSurrender: false,
            autoSurrenderThreshold: 10,  // % HP to trigger surrender
            ultraFastMode: true,  // Ultra Fast PvP mode (attacks via GM_xmlhttpRequest)
            ultraFastConfig: {
                skillId: 0,  // 0 = Slash (1 token), -1 = Power Slash (5 tokens, 10x damage)
                minDelayBetweenAttacks: 50,  // ms between attacks (minimum possible)
                autoReturnToLobby: true,  // Automatically return to lobby after battle
                autoContinueBattles: true,  // Automatically start new battles
                maxConsecutiveBattles: 30,  // Max battles per session (0 = unlimited)
                useSmartRotation: false,  // Use smart skill rotation pattern
                smartRotationPattern: [
                    { skill: 18, count: 1 },  // 1x skill 18
                    { skill: 9, count: 1 },   // 1x skill 9
                    { skill: -1, count: 1 },  // 1x skill -1
                    { skill: 0, count: 9 }    // 9x skill 0
                ]
            }
        },
        ui: {
            activeTab: 'quick', // 'quick' | 'farm' | 'dungeon' | 'battle' | 'pvp' | 'interface'
            panel: {
                width: PANEL_WIDTH_PX,
                position: null,
                activeTab: 'overview'
            },
            logFloater: {
                enabled: true,
                position: 'bottom-right', // 'bottom-right' | 'bottom-left' | 'top-right' | 'top-left'
                minimized: false
            },
            panelStates: {
                stats: false,
                automation: false,
                status: false,
                configs: false
            },
            dropdownStates: {
                'wave-unified': false,
                'battle': false,
                'pvp': false,
                'ultra-fast': false,
                'others': false
            },
            toasts: {
                enabled: true,
                durationMs: 4500,
                position: 'bottom-right'
            }
        },
        floatingHelpers: {
            enabled: true,
            position: 'right',
            topOffset: '50%',
            hideNativePopup: true,  // Hide native Battle Consumables popup
            potions: {
                small: { enabled: true, quantities: [1, 3, 5] },
                full: { enabled: true, quantities: [1, 3, 5] },
                exp: { enabled: true, showTimer: true }
            },
            loot: {
                enabled: true,
                showFloating: true
            }
        },
        smartDamageCalc: {
            enabled: true,
            defenseValues: [0, 25, 50],
            showInStats: true
        },
        equipmentBonuses: {
            // Manual equipment bonuses (auto-extraction not available due to dynamic modals)
            // Update these values based on your equipped items
            extra_damage_monsters: 26,  // % Extra Damage to Monsters (e.g., Scalescourge 14% + Helmet 14%)
            armor_penetration: 5,       // % Armor Penetration
            crit_rate: 0,               // % Critical Rate
            crit_damage: 0,             // % Critical Damage
            stamina_save: 0,            // % Stamina Save
            heal_on_damage: 5,          // % Heal on Damage
            note: 'Update these values manually. Check your equipped items by clicking Info buttons in inventory.php'
        },
        ultraFastAttack: {
            enabled: false,
            maxParallelBattles: 5,  // Number of monsters to join/attack simultaneously
            maxConcurrentBattles: 5,  // Max battles you can join at once in the wave (server limit)
            attacksPerMonster: 1,  // Number of attacks before leaving
            skillId: -2,  // Skill to use for attacks (0 = Slash, -1 = Power Slash, etc.)
            delayBetweenBatches: 3000,  // Delay between batches of parallel operations (ms)
            delayAfterJoin: 500,  // â³ CRITICAL: Delay after joins complete, before starting attacks (ms) - prevents race condition
            monsterNames: [],  // Filter by monster names (empty = all available)
            minMobHp: 100000,  // Minimum HP to consider
            priorityMode: 'lowest_hp',  // 'lowest_hp' | 'highest_hp' | 'random'
            autoReturnToWave: true  // Automatically return to wave after batch completes
        },
        ultraFastLoot: {
            enabled: false,
            maxParallelLoots: 10,  // Number of monsters to loot simultaneously
            delayBetweenLoots: 100,  // Delay between individual loot requests (ms)
            autoLootAfterFarm: false,  // Auto-loot after ultraFastAttack completes
            onlyEligible: true,  // Only loot monsters the user has joined
            filters: {
                monsterNames: [],  // Filter by monster names (empty = all)
                excludeNames: []  // Exclude specific monster names
            }
        },
        ultraFastStamina: {
            enabled: false,
            batchSize: 10,  // Number of chapters to react to simultaneously
            delayBetweenBatches: 1000,  // Delay between batches (ms)
            reactionType: '1'  // Reaction type: '1' (ðŸ‘), '2' (â¤ï¸), '3' (ðŸ˜‚), '4' (ðŸ˜®), '5' (ðŸ˜¢)
        },
        ultraFastDungeon: {
            enabled: false,
            maxParallelBattles: 5,  // Number of monsters to attack simultaneously
            attacksPerMonster: 3,  // Number of attacks per monster before checking
            delayBetweenBatches: 2000,  // Delay between batches (ms)
            monsterNames: [],  // Legacy - kept for backward compatibility
            monsterFilter: {
                maxHp: 0,
                minDamage: 0,
                includeNames: [],  // Whitelist - only target these names
                excludeNames: []   // Blacklist - skip these names
            },
            minMobHp: 1000000,  // Minimum HP to consider
            priorityMode: 'lowest_damage',  // 'lowest_damage' | 'highest_damage' | 'lowest_hp' | 'highest_hp'
            checkJoined: true,  // Check monsters you've already joined
            checkNotJoined: true,  // Check monsters not yet joined
            useSmartDamage: true,  // Use smart damage calculation to respect thresholds
            damageThresholds: {
                default: 3000000,  // Default damage limit for most monsters
                magus: 1000000     // Damage limit for Magus monsters
            },
            safetyMargin: 1,  // Stop at 95% of threshold to avoid overshooting (0.0-1.0)
            respectExpLimit: true  // Never exceed 20% of monster's total HP (required for full EXP on kill)
        },
        specialBossFarm: {
            enabled: false,
            targetDamage: 50000000,  // 50M damage minimum for special loot
            skillId: -2,  // Skill to use (-2 = 50 stamina, -3 = 100 stamina, -4 = 200 stamina)
            parallelAttacks: 5,  // Number of simultaneous attacks per boss
            minDelayBetweenAttacks: 50,  // Minimum delay between attack rounds (ms)
            autoStaminaPotion: true,  // Automatically use stamina potions when low
            minStaminaForPotion: 100,  // Use potion if stamina below this value
            checkInterval: 300000,  // 5 minutes (300000ms) - wait time if no bosses found
            bossNames: ['General', 'Seraph', 'King', 'Empress', 'Bastion', 'Oathkeeper']  // Boss keywords to search for
        },
        imageBlocker: {
            enabled: false  // Block images to reduce bandwidth and improve performance
        }
    });

    const LEVELS = ['debug', 'info', 'warn', 'error'];
    const NUMBER_FORMAT = new Intl.NumberFormat('en-US');

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, Math.max(0, ms)));
    }

    function sleepRandom(baseMs = 1000, variation = 0.3, enabled = true) {
        const base = Math.max(0, baseMs);
        if (!enabled || variation <= 0) {
            return sleep(base);
        }
        const delta = base * Math.max(0, variation);
        const min = Math.max(0, base - delta);
        const max = base + delta;
        const value = Math.floor(Math.random() * (max - min + 1) + min);
        return sleep(value);
    }

    // DEPRECATED: Legacy wrappers for backward compatibility
    // All code should migrate to context.numbers.parse() instead of numberFromText()
    // These wrappers will be removed in Phase 4
    
    /**
     * @deprecated Use context.numbers.parse() instead
     * Legacy wrapper for backward compatibility with existing code
     */
    function numberFromText(text) {
        // Create temporary service instance (will be replaced by context.numbers at runtime)
        const tempService = createNumberFormattingService();
        return tempService.parse(text);
    }

    /**
     * @deprecated Use context.numbers.format() instead
     * Legacy wrapper for backward compatibility with existing code
     */
    function formatNumber(value) {
        // Create temporary service instance (will be replaced by context.numbers at runtime)
        const tempService = createNumberFormattingService();
        return tempService.format(value);
    }

    /**
     * @deprecated Use context.numbers.calculateDamageVsDefense() instead
     * Legacy wrapper for backward compatibility with existing code
     */
    function calculateDamageVsDefense(attack, defense) {
        // Create temporary service instance (will be replaced by context.numbers at runtime)
        const tempService = createNumberFormattingService();
        return tempService.calculateDamageVsDefense(attack, defense);
    }

    function calculateExpectedDungeonDamage(currentHP, maxHP) {
        // CÃ¡lculo baseado no HP atual e mÃ¡ximo
        // Estimativa: ~15-25% do HP atual como dano esperado
        const hpRatio = currentHP / maxHP;
        const baseDamage = Math.round(currentHP * 0.20);
        const bonus = Math.round(baseDamage * hpRatio * 0.1);
        return baseDamage + bonus;
    }

    function calculateExpectedExp(currentHP, maxHP) {
        // CÃ¡lculo de EXP esperada baseado no HP
        // Base: 10% do HP atual + bÃ´nus proporcional
        const hpRatio = currentHP / maxHP;
        const baseExp = Math.round(currentHP * 0.1);
        const levelMultiplier = 1 + (hpRatio * 0.5);
        return Math.round(baseExp * levelMultiplier);
    }

    // ==================== STAMINA READER SERVICE ====================
    // Centralized stamina reading utilities
    // Eliminates ~100 lines of duplicated code across modules
    
    /**
     * Create centralized stamina reader service
     * Provides unified API for reading player stamina from various DOM locations
     * 
     * @returns {Object} Stamina reader service
     * @returns {function(): number} getCurrent - Get current stamina value (0 if not found)
     * @returns {function(): number} getMax - Get maximum stamina value (0 if not found)
     * @returns {function(): number} getPercentage - Get stamina percentage 0-100 (0 if invalid)
     * @returns {function(number): boolean} hasEnough - Check if current stamina >= required amount
     * 
     * @example
     * const stamina = createStaminaReader();
     * const current = stamina.getCurrent(); // 180
     * const max = stamina.getMax(); // 200
     * const pct = stamina.getPercentage(); // 90.0
     * const canAttack = stamina.hasEnough(50); // true if current >= 50
     */
    function createStaminaReader() {
        const STAMINA_SELECTORS = [
            '#stamina_span',
            '[data-player-stamina]',
            '.gtb-stat[data-stat="stamina"] .gtb-value',
            '.stamina .current'
        ];
        
        const STAMINA_XPATH = [
            '//*[@id="discuscontainer"]/div[1]/div[1]/div[2]/span[1]/span'
        ];
        
        return {
            getCurrent() {
                const data = readGauge(STAMINA_SELECTORS, {
                    xpath: STAMINA_XPATH,
                    parse: true,
                    warn: false
                });
                return data?.current || 0;
            },
            
            getMax() {
                const data = readGauge(STAMINA_SELECTORS, {
                    xpath: STAMINA_XPATH,
                    parse: true,
                    warn: false
                });
                return data?.max || 0;
            },
            
            getPercentage() {
                const data = readGauge(STAMINA_SELECTORS, {
                    xpath: STAMINA_XPATH,
                    parse: true,
                    warn: false
                });
                if (!data?.current || !data?.max) return 0;
                return (data.current / data.max) * 100;
            },
            
            hasEnough(required) {
                return this.getCurrent() >= required;
            }
        };
    }

    /**
     * Check if a monster is a special boss (General, King, Empress, Bastion)
     * @param {string} monsterName - Monster name to check
     * @returns {boolean} - True if special boss
     */
    function isSpecialBoss(monsterName) {
        if (!monsterName) return false;
        const nameLower = monsterName.toLowerCase();
        const keywords = ['general', 'king', 'empress', 'bastion'];
        return keywords.some(keyword => nameLower.includes(keyword));
    }

    /**
     * Get effective damage target for a monster (minimum 50M for special bosses)
     * @param {string} monsterName - Monster name
     * @param {number} configuredTarget - Configured damage target
     * @returns {number} - Effective damage target (minimum 50M for special bosses)
     */
    function getEffectiveDamageTarget(monsterName, configuredTarget) {
        const SPECIAL_BOSS_MIN_DAMAGE = 50000000; // 50M
        if (isSpecialBoss(monsterName)) {
            return Math.max(configuredTarget || 0, SPECIAL_BOSS_MIN_DAMAGE);
        }
        return configuredTarget || 0;
    }

    function escapeHtml(value) {
        return String(value ?? '').replace(/[&<>"']/g, (char) => {
            switch (char) {
                case '&': return '&amp;';
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '"': return '&quot;';
                case "'": return '&#39;';
                default: return char;
            }
        });
    }

    /**
     * @deprecated Use context.notifications.error() instead
     * Legacy function kept for backward compatibility
     * Will be removed in Phase 4
     * 
     * Show error notification (loot errors)
     * @param {string} message - Error message
     * @param {number} duration - Display duration in milliseconds
     * @param {Object} logger - Logger instance (optional)
     */
    function showErrorNotification(message, duration = 10000, logger = null) {
        // If running in context with notifications service, use it
        if (typeof window !== 'undefined' && window.autoDSServices?.context?.notifications) {
            window.autoDSServices.context.notifications.error(message, duration);
            return;
        }
        
        // Fallback to native notification if available
        if (typeof window !== 'undefined' && typeof window.showNotification === 'function') {
            window.showNotification(message, 'error');
            return;
        }
        
        // Last resort: console.error
        if (logger) {
            logger.error(`ðŸš« ERRO DE LOOT: ${message}`);
        } else {
            console.error(`[AutoDS] ERRO DE LOOT: ${message}`);
        }
    }

    function ensureLayoutStyles(doc) {
        if (!doc) return;
        if (doc.getElementById('autods-layout-offset-style')) return;
        const style = doc.createElement('style');
        style.id = 'autods-layout-offset-style';
        style.textContent = `
            :root {
                --autods-panel-width: 0px;
                --autods-toolbar-height: 0px;
            }
            body.autods-layout-ready {
                margin-right: var(--autods-panel-width, 0px);
                transition: margin-right 0.3s ease;
            }

            /* Mobile layout adjustments */
            @media (max-width: 768px) {
                body.autods-layout-ready {
                    margin-right: min(85vw, 400px);
                }
            }

            @media (max-width: 480px) {
                body.autods-layout-ready {
                    margin-right: 0 !important;
                }
                body.autods-layout-ready.autods-panel-visible {
                    overflow: hidden;
                }
            }
        `;
        doc.head ? doc.head.appendChild(style) : doc.documentElement.appendChild(style);
    }

    function ensureFloatingHelpersStyles(doc) {
        if (!doc) return;
        if (doc.getElementById('autods-floating-helpers-style')) return;
        const style = doc.createElement('style');
        style.id = 'autods-floating-helpers-style';
        style.textContent = `
            /* Floating Helpers Styles */
                position: fixed;
                top: 0;
                right: 0;
                bottom: 0;
                width: 220px;
                z-index: 999998;
                display: flex;
                flex-direction: column;
                padding: 16px 8px;
                background: rgba(10, 18, 30, 0.92);
                border-left: 1px solid rgba(70, 130, 220, 0.25);
                box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(10px) saturate(180%);
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease, width 0.3s ease;
                will-change: transform;
                overflow-y: auto;
                overflow-x: hidden;
                scrollbar-width: thin;
                scrollbar-color: rgba(70, 130, 220, 0.4) transparent;
            }
            #autods-shortcuts-toolbar::-webkit-scrollbar {
                width: 6px;
            }
            #autods-shortcuts-toolbar::-webkit-scrollbar-track {
                background: transparent;
            }
            #autods-shortcuts-toolbar::-webkit-scrollbar-thumb {
                background: rgba(70, 130, 220, 0.3);
                border-radius: 999px;
            }
            #autods-shortcuts-toolbar::-webkit-scrollbar-thumb:hover {
                background: rgba(70, 130, 220, 0.5);
            }
            #autods-shortcuts-toolbar[data-hidden="1"] {
                transform: translateX(100%);
                opacity: 0;
                pointer-events: none;
            }
            #autods-shortcuts-toolbar .autods-toolbar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                width: 100%;
            }
            #autods-shortcuts-toolbar .autods-toolbar-dashboard {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                font-size: 12px;
                font-weight: 700;
                text-transform: uppercase;
                letter-spacing: 1px;
                color: rgba(255, 255, 255, 0.95);
                padding: 12px 16px;
                text-align: center;
                text-decoration: none;
                background: linear-gradient(135deg, rgba(50, 100, 180, 0.6), rgba(30, 70, 140, 0.7));
                border-radius: 10px;
                border: 2px solid rgba(70, 130, 220, 0.5);
                user-select: none;
                margin-bottom: 8px;
                transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            }
            #autods-shortcuts-toolbar .autods-toolbar-dashboard:hover {
                background: linear-gradient(135deg, rgba(70, 130, 220, 0.8), rgba(50, 100, 180, 0.9));
                border-color: rgba(100, 160, 255, 0.8);
                transform: translateY(-2px);
                box-shadow: 0 6px 18px rgba(70, 130, 220, 0.4);
            }
            #autods-shortcuts-toolbar .autods-toolbar-dashboard:active {
                transform: translateY(0);
                box-shadow: 0 2px 8px rgba(70, 130, 220, 0.3);
            }
            #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-icon {
                font-size: 16px;
                line-height: 1;
            }
            #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-text {
                line-height: 1;
            }
            #autods-shortcuts-toolbar .autods-toolbar-links {
                display: flex;
                flex-direction: column;
                gap: 6px;
                width: 100%;
            }
            .autods-toolbar-heading {
                font-size: 9px;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.8px;
                color: rgba(140, 190, 255, 0.75);
                padding: 6px 12px;
                border-radius: 6px;
                background: rgba(30, 60, 120, 0.3);
                border: 1px solid rgba(70, 130, 220, 0.2);
                user-select: none;
                margin-top: 8px;
            }
            .autods-toolbar-divider {
                width: 100%;
                height: 1px;
                background: rgba(70, 130, 220, 0.2);
                margin: 4px 0;
            }
            .autods-toolbar-link {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 10px 12px;
                border-radius: 8px;
                background: rgba(20, 40, 80, 0.5);
                border: 1px solid rgba(70, 130, 220, 0.25);
                color: rgba(200, 220, 255, 0.95);
                font-size: 11px;
                font-weight: 500;
                text-decoration: none;
                line-height: 1.3;
                white-space: normal;
                word-wrap: break-word;
                transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                user-select: none;
            }
            .autods-toolbar-link:hover {
                background: rgba(50, 90, 160, 0.6);
                border-color: rgba(70, 130, 220, 0.5);
                color: rgba(255, 255, 255, 1);
                transform: translateX(-3px);
                box-shadow: -3px 0 12px rgba(70, 130, 220, 0.3);
            }
            .autods-toolbar-link:active {
                transform: translateX(-1px);
            }
            .autods-toolbar-link.active {
                background: rgba(70, 130, 220, 0.4);
                border-color: rgba(100, 160, 255, 0.7);
                color: rgba(255, 255, 255, 1);
                font-weight: 600;
                box-shadow: 0 0 20px rgba(70, 130, 220, 0.4), inset 0 0 20px rgba(70, 130, 220, 0.2);
            }
            .autods-toolbar-link .badge {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                padding: 2px 6px;
                min-width: 20px;
                font-size: 9px;
                font-weight: 600;
                border-radius: 4px;
                background: rgba(70, 130, 220, 0.3);
                border: 1px solid rgba(100, 160, 255, 0.4);
                color: rgba(255, 255, 255, 0.95);
            }

            /* Ajuste do body para nÃ£o ficar embaixo da toolbar */
            body {
                margin-right: 220px !important;
                transition: margin-right 0.3s ease;
            }
            body.autods-toolbar-hidden {
                margin-right: 0 !important;
            }
            
            /* ðŸ†• When shell is open, add extra margin for the shell panel */
            body.autods-shell-open {
                margin-right: calc(220px + var(--autods-panel-width, 380px)) !important;
                transition: margin-right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }
            
            /* Mobile: shell takes full width, no extra margin from toolbar */
            @media (max-width: 480px) {
                body.autods-shell-open {
                    margin-right: 0 !important;
                }
            }

            /* Mobile-First Responsive Design para Toolbar */
            @media (max-width: 1024px) {
                #autods-shortcuts-toolbar {
                    width: 200px;
                    padding: 14px 7px;
                }
                body {
                    margin-right: 200px !important;
                }
                .autods-toolbar-dashboard {
                    font-size: 11px;
                    padding: 11px 14px;
                }
                .autods-toolbar-link {
                    padding: 9px 11px;
                    font-size: 10px;
                }
            }

            @media (max-width: 768px) {
                #autods-shortcuts-toolbar {
                    width: 180px;
                    padding: 12px 6px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard {
                    font-size: 10px;
                    padding: 10px 12px;
                    gap: 6px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-icon {
                    font-size: 14px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-inner {
                    gap: 8px;
                }
                .autods-toolbar-link {
                    padding: 8px 10px;
                    font-size: 10px;
                    gap: 5px;
                }
                .autods-toolbar-heading {
                    font-size: 8px;
                    padding: 5px 8px;
                }
                body {
                    margin-right: 180px !important;
                }
            }

            @media (max-width: 600px) {
                #autods-shortcuts-toolbar {
                    width: 64px;
                    padding: 10px 4px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard {
                    flex-direction: column;
                    padding: 12px 6px;
                    gap: 4px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-icon {
                    font-size: 18px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-text {
                    font-size: 7px;
                    letter-spacing: 0.5px;
                    writing-mode: horizontal-tb;
                    line-height: 1.1;
                }
                #autods-shortcuts-toolbar .autods-toolbar-inner {
                    gap: 6px;
                }
                .autods-toolbar-link {
                    padding: 10px 6px;
                    font-size: 0;
                    justify-content: center;
                    text-align: center;
                    min-height: 44px;
                    gap: 0;
                }
                .autods-toolbar-link::before {
                    content: attr(data-icon);
                    font-size: 16px;
                    line-height: 1;
                }
                .autods-toolbar-heading {
                    font-size: 7px;
                    padding: 6px 3px;
                    writing-mode: vertical-rl;
                    text-orientation: mixed;
                    letter-spacing: 0.5px;
                }
                .autods-toolbar-divider {
                    display: none;
                }
                .autods-toolbar-link .badge {
                    position: absolute;
                    top: 2px;
                    right: 2px;
                    font-size: 8px;
                    min-width: 16px;
                    padding: 1px 4px;
                }
                body {
                    margin-right: 64px !important;
                }
            }

            @media (max-width: 480px) {
                #autods-shortcuts-toolbar {
                    width: 56px;
                    padding: 8px 3px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard {
                    padding: 10px 5px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-icon {
                    font-size: 16px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-text {
                    font-size: 6px;
                }
                .autods-toolbar-link {
                    padding: 8px 4px;
                    min-height: 40px;
                }
                .autods-toolbar-link::before {
                    font-size: 14px;
                }
                .autods-toolbar-heading {
                    font-size: 6px;
                    padding: 5px 2px;
                }
                body {
                    margin-right: 56px !important;
                }
            }

            /* Responsividade para telas muito pequenas */

            /* Floating Helpers Styles */
            #autods-floating-helpers {
                position: fixed;
                display: flex;
                flex-direction: column;
                gap: 8px;
                z-index: 2147483647;
                pointer-events: auto;
                transition: right 0.3s ease, left 0.3s ease, opacity 0.3s ease, flex-direction 0.3s ease;
            }

            /* Desktop: posicionar Ã  direita da pÃ¡gina (canto direito) */
            @media (min-width: 769px) {
                #autods-floating-helpers[data-position="right"] {
                    right: 12px;
                }
                #autods-floating-helpers[data-position="left"] {
                    left: 12px;
                }
                #autods-floating-helpers {
                    gap: 8px;
                }
                
                /* ðŸ†• Quando shell abre, empurrar floating helpers para a direita */
                body.autods-shell-open #autods-floating-helpers[data-position="right"] {
                    right: calc(12px + var(--autods-panel-width, 380px));
                }
            }

            /* Tablet: reduzir espaÃ§amento */
            @media (max-width: 768px) and (min-width: 481px) {
                #autods-floating-helpers[data-position="right"] {
                    right: 12px;
                }
                #autods-floating-helpers[data-position="left"] {
                    left: 12px;
                }
                #autods-floating-helpers {
                    gap: 6px;
                }
            }

            /* Mobile: grid layout 2x3 ou menos em tela pequena */
            @media (max-width: 480px) {
                #autods-floating-helpers {
                    right: 12px !important;
                    left: auto !important;
                    top: auto !important;
                    bottom: 12px;
                    display: grid;
                    grid-template-columns: repeat(2, 1fr);
                    gap: 6px;
                    max-width: calc(100vw - 68px); /* 56px toolbar + 12px margin */
                    width: auto;
                    padding: 8px;
                    background: rgba(30, 30, 46, 0.9);
                    border: 2px solid rgba(137, 180, 250, 0.3);
                    border-radius: 8px;
                    transition: all 0.3s ease;
                }

                /* Estado minimizado em mobile - mostrar apenas toggle */
                #autods-floating-helpers[data-minimized="1"] {
                    grid-template-columns: 1fr;
                    padding: 4px;
                    width: auto;
                    max-width: none;
                }

                /* Esconder todos os elementos exceto toggle quando minimizado */
                #autods-floating-helpers[data-minimized="1"] > *:not(#autods-floating-helpers-toggle) {
                    display: none !important;
                }

                /* Toggle button sempre visÃ­vel */
                #autods-floating-helpers-toggle {
                    order: -1; /* ForÃ§ar para primeiro em flex */
                    padding: 6px;
                    background: linear-gradient(135deg, rgba(137, 180, 250, 0.2), rgba(139, 233, 253, 0.2));
                    border: 1px solid rgba(137, 180, 250, 0.4);
                    border-radius: 6px;
                    color: #89b4fa;
                    font-size: 12px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    text-align: center;
                    display: block !important;
                    width: 100%;
                }

                #autods-floating-helpers-toggle:hover {
                    background: linear-gradient(135deg, rgba(137, 180, 250, 0.3), rgba(139, 233, 253, 0.3));
                    border-color: rgba(137, 180, 250, 0.6);
                }
                
                /* Container expandido para mostrar grid */
                #autods-floating-helpers[data-minimized="0"] {
                    display: flex;
                    flex-direction: column;
                }

                #autods-floating-helpers::-webkit-scrollbar {
                    display: none;
                }
                
                /* Garantir que todos os botÃµes apareÃ§am em mobile */
                #autods-floating-helpers > div {
                    min-width: 0;
                    flex: 1;
                }
                
                /* Tab buttons em grid 2x2 */
                #autods-floating-helpers #autods-main-tab-buttons {
                    display: grid;
                    grid-template-columns: repeat(2, 1fr);
                    gap: 6px;
                    padding: 0;
                    margin: 0;
                    border: none;
                    padding-top: 0;
                }
            }

            /* Additional styles for floating helper boxes - REMOVED (now using inline styles) */
            /* All buttons now use standardized inline styles with gradients and colors */

            .battle-drawer-box {
                border-color: rgba(249, 226, 175, 0.5);
            }

            .battle-drawer-box:hover {
                box-shadow: 0 4px 12px rgba(249, 226, 175, 0.4);
            }

            .potion-box.potion-exp {
                border-color: rgba(249, 226, 175, 0.5);
            }

            .potion-box.potion-exp:hover {
                box-shadow: 0 4px 12px rgba(249, 226, 175, 0.4);
            }

            .loot-box {
                border-color: rgba(166, 227, 161, 0.5);
            }

            .loot-box:hover {
                box-shadow: 0 4px 12px rgba(166, 227, 161, 0.4);
            }

            @media (max-width: 480px) {
                .potion-box, .loot-box, .battle-drawer-box {
                    min-width: 50px;
                    padding: 6px;
                    flex-shrink: 0;
                }
            }

            /* Panel Toggle Button (Desktop) */
            #autods-panel-toggle-btn {
                position: fixed;
                top: 50%;
                right: 12px;
                transform: translateY(-50%);
                z-index: 9998;
                width: 48px;
                height: 48px;
                border-radius: 50%;
                background: linear-gradient(135deg, rgba(50, 100, 180, 0.95), rgba(30, 70, 140, 0.95));
                border: 2px solid rgba(70, 130, 220, 0.6);
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 0 0 rgba(70, 130, 220, 0.6);
                cursor: pointer;
                display: none;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                color: #fff;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                backdrop-filter: blur(10px);
                animation: pulse-shadow 2s ease-in-out infinite;
            }
            #autods-panel-toggle-btn:hover {
                background: linear-gradient(135deg, rgba(70, 130, 220, 0.95), rgba(50, 100, 180, 0.95));
                border-color: rgba(100, 160, 255, 0.8);
                transform: translateY(-50%) scale(1.1);
                box-shadow: 0 6px 20px rgba(70, 130, 220, 0.5);
            }
            #autods-panel-toggle-btn:active {
                transform: translateY(-50%) scale(0.95);
            }
            #autods-panel-toggle-btn.visible {
                display: flex;
            }
            
            /* ðŸ†• Styling when button is inside autods-floating-helpers */
            #autods-floating-helpers #autods-panel-toggle-btn {
                position: static !important;
                transform: none !important;
                display: block !important;
                margin-bottom: 8px;
                width: 100%;
                background: linear-gradient(135deg, rgba(137, 180, 250, 0.2), rgba(139, 233, 253, 0.2));
                border: 1px solid rgba(137, 180, 250, 0.4);
                border-radius: 6px;
                color: #89b4fa;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
                text-align: center;
                padding: 8px 12px;
            }
            
            #autods-floating-helpers #autods-panel-toggle-btn:hover {
                background: linear-gradient(135deg, rgba(137, 180, 250, 0.3), rgba(139, 233, 253, 0.3));
                border-color: rgba(137, 180, 250, 0.6);
            }
            
            #autods-floating-helpers #autods-panel-toggle-btn:active {
                transform: scale(0.98) !important;
            }
            
            @keyframes pulse-shadow {
                0%, 100% {
                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 0 0 rgba(70, 130, 220, 0.6);
                }
                50% {
                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 0 8px rgba(70, 130, 220, 0);
                }
            }
            @media (max-width: 480px) {
                #autods-panel-toggle-btn {
                    display: none !important;
                }
            }
        `;
        doc.head ? doc.head.appendChild(style) : doc.documentElement.appendChild(style);
    }

    function ensureBodyLayoutClass(doc) {
        if (!doc) return;
        const apply = () => {
            if (doc.body) {
                doc.body.classList.add('autods-layout-ready');
            }
        };

        if (doc.body) {
            apply();
        } else {
            doc.addEventListener('DOMContentLoaded', apply, { once: true });
        }
    }

    function setPanelOffset(doc, widthPx) {
        if (!doc) return;
        const width = Math.max(MIN_PANEL_WIDTH_PX, Number(widthPx) || PANEL_WIDTH_PX);
        doc.documentElement.style.setProperty('--autods-panel-width', `${width}px`);
        ensureBodyLayoutClass(doc);
    }

    function createPatchFromPath(path, value) {
        if (!path) return {};
        const keys = path.split('.');
        return keys.reduceRight((acc, key) => ({ [key]: acc }), value);
    }

    function pickTarget(candidates, mode = 'lowest_hp') {
        if (!Array.isArray(candidates) || candidates.length === 0) return null;
        const pool = [...candidates];
        switch (mode) {
            case 'highest_hp':
                pool.sort((a, b) => (b.hp ?? 0) - (a.hp ?? 0));
                return pool[0];
            case 'random':
                return pool[Math.floor(Math.random() * pool.length)];
            case 'first':
                pool.sort((a, b) => (a.index ?? 0) - (b.index ?? 0));
                return pool[0];
            case 'lowest_hp':
            default:
                pool.sort((a, b) => (a.hp ?? Infinity) - (b.hp ?? Infinity));
                return pool[0];
        }
    }

    function resolveAttackButton(dom, battleConfig = {}, isPvP = false) {
        // For PvP battles, always use Power Slash (data-skill-id="-1")
        if (isPvP) {
            const powerSlash = dom.query('.attack-btn[data-skill-id="-1"]:not([disabled])')
                || dom.query('button[data-skill-id="-1"]:not([disabled])');
            if (powerSlash) return powerSlash;
        }

        const desiredSkillId = battleConfig.attackSkillId ?? 0;
        if (Number.isFinite(desiredSkillId)) {
            const targeted = dom.query(`.attack-btn[data-skill-id="${desiredSkillId}"]:not([disabled])`)
                || dom.query(`button[data-skill-id="${desiredSkillId}"]:not([disabled])`);
            if (targeted) return targeted;
        }

        // Prefer non-disabled buttons
        const fallback = dom.query('.attack-btn:not([disabled])')
            || dom.query('button.attack-btn:not([disabled])')
            || dom.query('.attack-btn')
            || dom.query('button.attack-btn');
        return fallback || null;
    }

    function selectSmartSkill(currentDamage, targetDamage, skillsConfig) {
        // Calculate remaining damage needed to reach target
        const remainingDamage = targetDamage - currentDamage;

        if (remainingDamage <= 0) {
            return null; // Target already reached
        }

        // Convert skills config to array and sort by damage limit (descending)
        const skills = Object.values(skillsConfig).sort((a, b) => b.damageLimit - a.damageLimit);

        // Find the highest damage skill that won't overshoot the target
        for (const skill of skills) {
            if (skill.damageLimit > 0 && skill.damageLimit <= remainingDamage) {
                return skill;
            }
        }

        // If no skill fits perfectly, use the lowest damage skill (Slash)
        return skills[skills.length - 1]; // Returns Slash (skillId: 0, damageLimit: 0)
    }

    function resolveSmartAttackButton(dom, currentDamage, targetDamage, battleConfig = {}) {
        const smartConfig = battleConfig.smartDamage;

        if (!smartConfig || !smartConfig.enabled || !smartConfig.skills) {
            // Fallback to regular skill selection if smart damage is disabled
            return resolveAttackButton(dom, battleConfig, false);
        }

        // Select the optimal skill based on remaining damage
        const selectedSkill = selectSmartSkill(currentDamage, targetDamage, smartConfig.skills);

        if (!selectedSkill) {
            return null; // Target already reached
        }

        // Try to find the button for the selected skill
        const skillButton = dom.query(`.attack-btn[data-skill-id="${selectedSkill.skillId}"]`)
            || dom.query(`button[data-skill-id="${selectedSkill.skillId}"]`);

        if (skillButton && !skillButton.disabled) {
            return { button: skillButton, skill: selectedSkill };
        }

        // If the optimal skill button is not available, try the next best option
        const skills = Object.values(smartConfig.skills)
            .sort((a, b) => b.damageLimit - a.damageLimit)
            .filter(s => s.skillId !== selectedSkill.skillId);

        for (const skill of skills) {
            const btn = dom.query(`.attack-btn[data-skill-id="${skill.skillId}"]`)
                || dom.query(`button[data-skill-id="${skill.skillId}"]`);
            if (btn && !btn.disabled && skill.damageLimit <= (targetDamage - currentDamage)) {
                return { button: btn, skill };
            }
        }

        // Last resort: use Slash (lowest damage)
        const slashSkill = Object.values(smartConfig.skills).find(s => s.damageLimit === 0);
        const slashButton = dom.query(`.attack-btn[data-skill-id="${slashSkill?.skillId ?? 0}"]`)
            || dom.query('button[data-skill-id="0"]');

        if (slashButton) {
            return { button: slashButton, skill: slashSkill };
        }

        // Ultimate fallback
        return { button: resolveAttackButton(dom, battleConfig, false), skill: null };
    }

    function readBattleStats(dom) {
        // Damage: regular battles use #yourDamageValue, dungeon pages use #myDmg
        const damageNode = dom.query('#yourDamageValue, #myDmg, .your-damage, [data-player-damage], #damageText, .damage-text');
        let damageText = '';
        if (damageNode) {
            damageText = damageNode.getAttribute?.('data-player-damage') ?? damageNode.textContent ?? '';
        }
        // Create temp service for legacy function
        const tempNumbers = createNumberFormattingService();
        const damage = tempNumbers.parse(damageText) ?? 0;

        // Monster HP: #hpText contains the formatted HP text (e.g., "â¤ï¸ 24,067,289 / 24,570,000 HP")
        const hpNode = dom.query('#hpText, .monster-hp, .hp-text, [data-monster-hp]');
        let monsterHp = null;
        let monsterMaxHp = null;

        if (hpNode) {
            const hpText = hpNode.textContent ?? '';
            // Extract current HP and max HP from text like "â¤ï¸ 24,067,289 / 24,570,000 HP"
            const tempNumbers = createNumberFormattingService();
            const parts = hpText.split('/');
            if (parts.length >= 2) {
                monsterHp = tempNumbers.parse(parts[0]);
                monsterMaxHp = tempNumbers.parse(parts[1]);
            } else {
                // Fallback: try to get single HP value
                monsterHp = tempNumbers.parse(hpText);
            }
        }

        return { damage, monsterHp, monsterMaxHp };
    }

    function queryXPathFirst(xpath, root = document) {
        try {
            const result = document.evaluate(xpath, root, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
            return result.singleNodeValue || null;
        } catch (error) {
            console.warn('[AutoDS][xpath] Failed to evaluate', xpath, error);
            return null;
        }
    }

    async function waitForSelector(selector, { timeout = 5000, interval = 100, root = document } = {}) {
        const end = Date.now() + timeout;
        while (Date.now() < end) {
            const node = root.querySelector(selector);
            if (node) return node;
            await sleep(interval);
        }
        return null;
    }

    async function waitForAny(selectors, options = {}) {
        for (const selector of selectors) {
            const node = await waitForSelector(selector, options);
            if (node) return node;
        }
        return null;
    }

    function parseGaugeText(text) {
        if (!text) return null;
        const tempNumbers = createNumberFormattingService();
        const parts = text.split('/');
        if (parts.length >= 2) {
            const current = tempNumbers.parse(parts[0]);
            const max = tempNumbers.parse(parts[1]);
            if (current !== null || max !== null) {
                return { current, max };
            }
        }
        const value = tempNumbers.parse(text);
        if (value === null) return null;
        return { current: value, max: null };
    }

    function extractGaugeFromElement(element) {
        if (!element) return null;
        const { dataset } = element;
        const dataCurrent = dataset?.current ?? dataset?.value ?? element.getAttribute?.('data-current') ?? element.getAttribute?.('data-value') ?? element.getAttribute?.('aria-valuenow');
        const dataMax = dataset?.max ?? element.getAttribute?.('data-max') ?? element.getAttribute?.('aria-valuemax');
        const tempNumbers = createNumberFormattingService();
        let current = dataCurrent ? tempNumbers.parse(dataCurrent) : null;
        let max = dataMax ? tempNumbers.parse(dataMax) : null;

        if (current === null) {
            const aria = element.getAttribute?.('aria-valuenow');
            if (aria) current = tempNumbers.parse(aria);
        }
        if (max === null) {
            const ariaMax = element.getAttribute?.('aria-valuemax');
            if (ariaMax) max = tempNumbers.parse(ariaMax);
        }

        if (current === null) {
            const textValue = element.textContent ?? '';
            const gauge = parseGaugeText(textValue);
            if (gauge) {
                current = gauge.current;
                max = max ?? gauge.max;
            }
        }

        if ((current === null || max === null) && element.parentElement) {
            const parentGauge = parseGaugeText(element.parentElement.textContent ?? '');
            if (parentGauge) {
                if (current === null) current = parentGauge.current;
                if (max === null) max = parentGauge.max;
            }
        }

        if (current === null && max === null) return null;
        return { current, max };
    }

    function readGauge(selectors = [], options = {}) {
        for (const selector of selectors) {
            const element = document.querySelector(selector);
            const gauge = extractGaugeFromElement(element);
            if (gauge) return gauge;
        }

        if (Array.isArray(options.xpath)) {
            for (const xpath of options.xpath) {
                const element = queryXPathFirst(xpath);
                const gauge = extractGaugeFromElement(element);
                if (gauge) return gauge;
            }
        } else if (typeof options.xpath === 'string') {
            const element = queryXPathFirst(options.xpath);
            const gauge = extractGaugeFromElement(element);
            if (gauge) return gauge;
        }

        if (options.fallback) {
            const gauge = parseGaugeText(options.fallback);
            if (gauge) return gauge;
        }

        return null;
    }

    // REMOVED: joinBattleDirectly() - replaced by context.http.joinBattle() (Phase 2 Migration)
    // REMOVED: joinDungeonBattleDirectly() - replaced by context.http.joinDungeonBattle() (Phase 2 Migration)
    // REMOVED: lootMonsterDirectly() - replaced by context.http.lootMonster() (Phase 2 Migration)
    // REMOVED: lootGuildDungeonDirectly() - replaced by context.http.lootGuildDungeon() (Phase 2 Migration)

    // DEPRECATED: Legacy wrappers for backward compatibility
    // All code should migrate to context.userSession methods
    // These wrappers will be removed in Phase 4
    
    /**
     * @deprecated Use context.userSession.getUserId() instead
     * Legacy wrapper for backward compatibility with existing code
     * 
     * Get user ID from cookie (demon cookie).
     * @returns {string|null} User ID or null if not found
     */
    function getUserIdFromCookie() {
        try {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; demon=`);
            if (parts.length === 2) {
                const userId = parts.pop().split(';').shift();
                return userId || null;
            }
        } catch (error) {
            console.warn('[AutoDS] Failed to read userId from cookie:', error);
        }
        return null;
    }

    /**
     * @deprecated Use context.userSession.ensureUserId() instead
     * Legacy wrapper for backward compatibility with existing code
     * 
     * Auto-detect and update user ID in config if not set.
     * Should be called during bootstrap or module activation.
     * @param {object} context - Context object with config
     * @returns {string|null} User ID (detected or existing)
     */
    function ensureUserId(context) {
        // If context has userSession service, use it (Phase 3+)
        if (context?.userSession?.ensureUserId) {
            return context.userSession.ensureUserId();
        }
        
        // Fallback to legacy implementation (before Phase 3)
        if (!context || !context.config || typeof context.config.get !== 'function') {
            console.warn('[AutoDS] ensureUserId: context.config invÃ¡lido');
            return null;
        }

        const cfg = context.config.get();
        
        if (cfg.core?.userId) {
            return cfg.core.userId;
        }

        // Try userSession service first, fallback to cookie parsing
        const tempService = context.userSession || { getUserId: () => {
            try {
                const cookie = document.cookie.split(';').find(c => c.trim().startsWith('demon='));
                return cookie ? cookie.split('=')[1]?.trim() : null;
            } catch { return null; }
        }};
        const userId = tempService.getUserId();
        
        if (userId) {
            if (context.logger && typeof context.logger.info === 'function') {
                context.logger.info(`ðŸ” User ID auto-detectado: ${userId}`);
            }
            if (typeof context.config.update === 'function') {
                context.config.update({ core: { userId } });
            }
            return userId;
        } else {
            if (context.logger && typeof context.logger.warn === 'function') {
                context.logger.warn('âš ï¸ User ID nÃ£o encontrado. Auto-join e outras funÃ§Ãµes podem nÃ£o funcionar.');
            }
            return null;
        }
    }

    /**
     * @deprecated Use context.userSession.startAutoDetect() instead
     * Legacy wrapper for backward compatibility with existing code
     * 
     * Periodically check and update user ID if missing.
     * Useful for detecting login after script loads.
     * @param {object} context - Context object
     * @param {number} intervalMs - Check interval in milliseconds (default: 5000)
     */
    function startUserIdAutoDetect(context, intervalMs = 5000) {
        // If context has userSession service, use it (Phase 3+)
        if (context?.userSession?.startAutoDetect) {
            return context.userSession.startAutoDetect(intervalMs);
        }
        
        // Fallback to legacy implementation (before Phase 3)
        if (!context || !context.config || typeof context.config.get !== 'function') {
            console.warn('[AutoDS] startUserIdAutoDetect: context.config invÃ¡lido');
            return null;
        }

        const checkUserId = () => {
            try {
                const cfg = context.config.get();
                
                if (!cfg.core?.userId) {
                    const tempService = context.userSession || { getUserId: () => {
                        try {
                            const cookie = document.cookie.split(';').find(c => c.trim().startsWith('demon='));
                            return cookie ? cookie.split('=')[1]?.trim() : null;
                        } catch { return null; }
                    }};
                    const userId = tempService.getUserId();
                    if (userId) {
                        if (context.logger && typeof context.logger.info === 'function') {
                            context.logger.info(`âœ… User ID detectado apÃ³s login: ${userId}`);
                        }
                        if (typeof context.config.update === 'function') {
                            context.config.update({ core: { userId } });
                        }
                        
                        if (context.events && typeof context.events.emit === 'function') {
                            context.events.emit('autods:userId:detected', { userId });
                        }
                    }
                }
            } catch (error) {
                console.error('[AutoDS] Erro no checkUserId:', error);
            }
        };

        checkUserId();

        const intervalId = setInterval(checkUserId, intervalMs);

        if (!context.scheduler) {
            context.scheduler = { intervals: [] };
        }
        context.scheduler.intervals = context.scheduler.intervals || [];
        context.scheduler.intervals.push(intervalId);

        return intervalId;
    }

    /**
     * Add "Join Now" or "Fight Now" button next to existing Join/Fight buttons.
     * This button will call joinBattleDirectly() or joinDungeonBattleDirectly() before navigating.
     * @param {HTMLElement} originalButton - The original Join/Fight button
     * @param {string} monsterId - Monster ID or dgmid
     * @param {string} buttonLabel - Label for the new button (e.g., "Join Now", "Fight Now")
     * @param {object} context - Context object
     * @param {string} instanceId - Instance ID (for dungeons, optional)
     * @param {boolean} autoNavigate - Whether to navigate after successful join (default: true)
     */
    function addDirectJoinButton(originalButton, monsterId, buttonLabel, context, instanceId = null, autoNavigate = false) {
        // Check if button already exists
        if (originalButton.nextElementSibling?.classList.contains('autods-direct-join')) {
            // context.logger.debug(`[DirectJoin] Button already exists for monster ${monsterId}`);
            return;
        }

        // context.logger.debug(`[DirectJoin] Creating button for monster ${monsterId}${instanceId ? ` (instance ${instanceId})` : ''}`);

        const directButton = document.createElement('button');
        directButton.className = 'autods-direct-join';
        directButton.textContent = `âš¡ ${buttonLabel}`;
        directButton.setAttribute('data-monster-id', monsterId);
        if (instanceId) {
            directButton.setAttribute('data-instance-id', instanceId);
        }
        directButton.style.cssText = `
            margin-left: 8px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #a6e3a1 0%, #94e2d5 100%);
            color: #1e1e2e;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;

        directButton.addEventListener('mouseenter', () => {
            directButton.style.transform = 'translateY(-1px)';
            directButton.style.filter = 'brightness(1.1)';
        });

        directButton.addEventListener('mouseleave', () => {
            directButton.style.transform = '';
            directButton.style.filter = '';
        });

        directButton.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();

            // context.logger.info(`[DirectJoin] ðŸ–±ï¸ Button clicked for monster ${monsterId}`);

            // VERIFICAÃ‡ÃƒO INTELIGENTE: SÃ³ usar direct join em pÃ¡ginas wave/dungeon
            // Se jÃ¡ estiver em battle.php, usar mÃ©todo tradicional (click)
            const currentPath = window.location.pathname;
            const isOnWavePage = /active_wave\.php|guild_dungeon_location\.php/i.test(currentPath);
            const isOnBattlePage = /battle\.php|dungeon_battle\.php/i.test(currentPath);

            if (isOnBattlePage) {
                // context.logger.info(`[DirectJoin] âš ï¸ JÃ¡ estÃ¡ em pÃ¡gina de batalha. Usando mÃ©todo tradicional (click).`);
                originalButton.click();
                return;
            }

            if (!isOnWavePage) {
                // context.logger.warn(`[DirectJoin] âš ï¸ PÃ¡gina nÃ£o reconhecida para direct join. Usando mÃ©todo tradicional.`);
                originalButton.click();
                return;
            }

            directButton.disabled = true;
            const originalText = directButton.textContent;
            directButton.textContent = 'â³ Joining...';

            try {
                // Detect if this is a dungeon page
                const isDungeon = /guild_dungeon_location\.php/i.test(currentPath);
                
                if (isDungeon) {
                    // Use instanceId from data attribute if available
                    let dgmid = monsterId;
                    let dungeonInstanceId = instanceId || directButton.getAttribute('data-instance-id');
                    
                    // Fallback: Extract from button's href or nearby link
                    if (!dungeonInstanceId) {
                        let battleUrl = null;
                        
                        // Try to get href from button itself (if it's an <a> tag)
                        if (originalButton.tagName === 'A') {
                            battleUrl = originalButton.href;
                        } else {
                            // Try to find nearby link (support both dungeon_battle.php and battle.php with dgmid)
                            const card = originalButton.closest('.mon, .monster-card');
                            const link = card?.querySelector('a[href*="battle.php"][href*="dgmid"], a[href*="dungeon_battle.php"]');
                            battleUrl = link?.href;
                        }
                        
                        if (!battleUrl) {
                            throw new Error('Could not find battle URL for dungeon');
                        }
                        
                        const dgmidMatch = battleUrl.match(/[?&]dgmid=(\d+)/);
                        const instanceMatch = battleUrl.match(/[?&]instance_id=(\d+)/);
                        
                        if (!dgmidMatch || !instanceMatch) {
                            throw new Error('Could not extract dgmid or instance_id from URL');
                        }
                        
                        dgmid = dgmidMatch[1];
                        dungeonInstanceId = instanceMatch[1];
                    }
                    
                    // Use context.http instead of legacy function
                    const userId = context.userSession?.getUserId() || context.config.get().core.userId;
                    const result = await context.http.joinDungeonBattle(dgmid, dungeonInstanceId, userId);
                    
                    context.logger.debug(`[DirectJoin] Join result:`, result);
                    
                    if (result.success) {
                        context.logger.info(`[DirectJoin] âœ… Join successful: ${result.message}`);
                        
                        context.notifications.success(result.message || 'Joined dungeon successfully!');
                        
                        // Only navigate if autoNavigate is enabled (manual clicks should navigate, auto mode should not)
                        if (autoNavigate) {
                            const battleUrl = `battle.php?dgmid=${dgmid}&instance_id=${dungeonInstanceId}`;
                            context.logger.info(`[DirectJoin] Navigating to ${battleUrl}`);
                            setTimeout(() => {
                                window.location.href = battleUrl;
                            }, 500); // Small delay to allow other requests to complete
                        }
                    } else {
                        // FALLBACK: Se API falhou, usar mÃ©todo tradicional
                        context.logger.warn(`[DirectJoin] âš ï¸ API join falhou: ${result.message}. Usando fallback (click).`);
                        context.notifications.warn('API join failed, using traditional method...');
                        originalButton.click();
                    }
                } else {
                    // Regular wave battle - using direct fetch to bypass Cloudflare
                    const userId = context.userSession?.getUserId();
                    context.logger.debug(`[DirectJoin] User ID from cookie: ${userId || 'NOT FOUND'}`);
                    
                    if (!userId) {
                        throw new Error('User ID not found. Please make sure you are logged in.');
                    }

                    context.logger.info(`[DirectJoin] Using direct fetch to user_join_battle.php (monster: ${monsterId}, user: ${userId})...`);
                    
                    // Use direct fetch with same headers as example to bypass Cloudflare
                    // IMPORTANT: referrer must be the battle page, not the current page
                    const battleUrl = `https://demonicscans.org/battle.php?id=${monsterId}`;
                    const response = await fetch("https://demonicscans.org/user_join_battle.php", {
                        "credentials": "include",
                        "headers": {
                            "User-Agent": navigator.userAgent,
                            "Accept": "*/*",
                            "Accept-Language": "pt-BR,pt;q=0.8,en-US;q=0.5,en;q=0.3",
                            "Content-Type": "application/x-www-form-urlencoded",
                            "Sec-Fetch-Dest": "empty",
                            "Sec-Fetch-Mode": "cors",
                            "Sec-Fetch-Site": "same-origin"
                        },
                        "referrer": battleUrl,
                        "body": `monster_id=${monsterId}&user_id=${userId}`,
                        "method": "POST",
                        "mode": "cors"
                    });

                    const text = await response.text();
                    context.logger.debug(`[DirectJoin] Response: ${text.substring(0, 200)}`);

                    // Check if join was successful
                    if (text.toLowerCase().includes('success')) {
                        context.logger.info(`[DirectJoin] âœ… Join successful!`);
                        
                        context.notifications.success('Joined successfully!');
                        
                        // Only navigate if autoNavigate is enabled (manual clicks should navigate, auto mode should not)
                        if (autoNavigate) {
                            const battleUrl = `battle.php?id=${monsterId}`;
                            context.logger.info(`[DirectJoin] Navigating to ${battleUrl}`);
                            setTimeout(() => {
                                window.location.href = battleUrl;
                            }, 500); // Small delay to allow other requests to complete
                        }
                    } else {
                        // FALLBACK: Se nÃ£o detectou sucesso, usar mÃ©todo tradicional
                        context.logger.warn(`[DirectJoin] âš ï¸ Join response nÃ£o indicou sucesso: ${text}. Usando fallback (click).`);
                        context.notifications.warn('Join response unclear, using traditional method...');
                        originalButton.click();
                    }
                }
            } catch (error) {
                context.logger.error(`[DirectJoin] âŒ Error: ${error.message}`, error);
                
                // FALLBACK FINAL: Em caso de qualquer erro, usar mÃ©todo tradicional
                context.logger.warn(`[DirectJoin] Usando fallback final (click) devido ao erro.`);
                
                context.notifications.warn(`Join error, using traditional method...`);

                try {
                    originalButton.click();
                } catch (clickError) {
                    context.logger.error(`[DirectJoin] Fallback click tambÃ©m falhou:`, clickError);
                    alert(`Failed to join: ${error.message}`);
                }

                directButton.disabled = false;
                directButton.textContent = originalText;
            }
        });

        // Insert after original button
        originalButton.parentNode.insertBefore(directButton, originalButton.nextSibling);
        // context.logger.debug(`[DirectJoin] Button inserted for monster ${monsterId}`);
    }

    function createStorage({ namespace }) {
        const keyFor = key => `${namespace}:${key}`;

        function get(key, fallback) {
            try {
                if (IS_TAMPERMONKEY) {
                    const raw = GM_getValue(keyFor(key));
                    if (raw === undefined || raw === null || raw === '') return fallback;
                    return JSON.parse(raw);
                }
                const raw = window.localStorage.getItem(keyFor(key));
                if (raw === null || raw === '') return fallback;
                return JSON.parse(raw);
            } catch (error) {
                console.warn('[AutoDS][storage] Failed to read key', key, error);
                return fallback;
            }
        }

        function set(key, value) {
            try {
                const payload = JSON.stringify(value);
                if (IS_TAMPERMONKEY) {
                    GM_setValue(keyFor(key), payload);
                } else {
                    window.localStorage.setItem(keyFor(key), payload);
                }
            } catch (error) {
                console.warn('[AutoDS][storage] Failed to persist key', key, error);
            }
        }

        function remove(key) {
            try {
                if (IS_TAMPERMONKEY) {
                    GM_deleteValue(keyFor(key));
                } else {
                    window.localStorage.removeItem(keyFor(key));
                }
            } catch (error) {
                console.warn('[AutoDS][storage] Failed to remove key', key, error);
            }
        }

        return { get, set, remove };
    }

    // ==================== LOG FLOATER ====================
    // Floating log viewer that shows script activity without opening console
    
    const logFloaterState = {
        logs: [],
        maxLogs: 50,
        minimized: false,
        container: null,
        logList: null,
        initialized: false,
        enabled: true
    };
    
    function createLogFloater(config = {}) {
        if (logFloaterState.initialized) return;
        logFloaterState.initialized = true;
        
        // Check if enabled
        if (config.enabled === false) {
            logFloaterState.enabled = false;
            return;
        }
        
        // Create styles
        const style = document.createElement('style');
        style.textContent = `
            #autods-log-floater {
                position: fixed;
                bottom: 40px;
                left: 40px;
                width: 400px;
                max-height: 300px;
                background: rgba(20, 20, 30, 0.95);
                border: 1px solid #444;
                border-radius: 8px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 11px;
                z-index: 2147483640;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
                overflow: hidden;
                transition: all 0.3s ease;
            }
            #autods-log-floater.minimized {
                width: 180px;
                max-height: 36px;
            }
            #autods-log-floater-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 8px 12px;
                background: linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%);
                border-bottom: 1px solid #444;
                cursor: pointer;
                user-select: none;
            }
            #autods-log-floater-header:hover {
                background: linear-gradient(135deg, #3a3a4a 0%, #2a2a3a 100%);
            }
            #autods-log-floater-title {
                color: #8af;
                font-weight: bold;
                font-size: 12px;
                display: flex;
                align-items: center;
                gap: 6px;
            }
            #autods-log-floater-title .status-dot {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: #4f4;
                animation: pulse 2s infinite;
            }
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.5; }
            }
            #autods-log-floater-controls {
                display: flex;
                gap: 8px;
            }
            #autods-log-floater-controls button {
                background: transparent;
                border: none;
                color: #888;
                cursor: pointer;
                font-size: 14px;
                padding: 2px 6px;
                border-radius: 4px;
                transition: all 0.2s;
            }
            #autods-log-floater-controls button:hover {
                color: #fff;
                background: rgba(255,255,255,0.1);
            }
            #autods-log-floater-content {
                max-height: 260px;
                overflow-y: auto;
                padding: 4px 0;
            }
            #autods-log-floater.minimized #autods-log-floater-content {
                display: none;
            }
            .autods-log-entry {
                padding: 4px 12px;
                border-bottom: 1px solid rgba(255,255,255,0.05);
                display: flex;
                gap: 8px;
                align-items: flex-start;
                word-break: break-word;
            }
            .autods-log-entry:hover {
                background: rgba(255,255,255,0.03);
            }
            .autods-log-entry .time {
                color: #666;
                font-size: 10px;
                white-space: nowrap;
                min-width: 55px;
            }
            .autods-log-entry .level {
                font-size: 10px;
                font-weight: bold;
                min-width: 40px;
                text-transform: uppercase;
            }
            .autods-log-entry .level.debug { color: #888; }
            .autods-log-entry .level.info { color: #4af; }
            .autods-log-entry .level.warn { color: #fa4; }
            .autods-log-entry .level.error { color: #f44; }
            .autods-log-entry .msg {
                color: #ddd;
                flex: 1;
                line-height: 1.4;
            }
            .autods-log-entry.debug .msg { color: #888; }
            .autods-log-entry.info .msg { color: #ddd; }
            .autods-log-entry.warn .msg { color: #fda; }
            .autods-log-entry.error .msg { color: #faa; }
            #autods-log-floater-content::-webkit-scrollbar {
                width: 6px;
            }
            #autods-log-floater-content::-webkit-scrollbar-track {
                background: transparent;
            }
            #autods-log-floater-content::-webkit-scrollbar-thumb {
                background: #444;
                border-radius: 3px;
            }
            #autods-log-floater-content::-webkit-scrollbar-thumb:hover {
                background: #555;
            }
            #autods-log-floater-badge {
                background: #f44;
                color: white;
                font-size: 10px;
                padding: 1px 5px;
                border-radius: 8px;
                margin-left: 6px;
                display: none;
            }
            #autods-log-floater.minimized #autods-log-floater-badge.has-new {
                display: inline-block;
            }
        `;
        document.head.appendChild(style);
        
        // Create container
        const container = document.createElement('div');
        container.id = 'autods-log-floater';
        container.innerHTML = `
            <div id="autods-log-floater-header">
                <div id="autods-log-floater-title">
                    <span class="status-dot"></span>
                    AutoDS Logs
                    <span id="autods-log-floater-badge">0</span>
                </div>
                <div id="autods-log-floater-controls">
                    <button id="autods-log-clear" title="Limpar logs">ðŸ—‘ï¸</button>
                    <button id="autods-log-toggle" title="Minimizar/Expandir">âž–</button>
                </div>
            </div>
            <div id="autods-log-floater-content"></div>
        `;
        document.body.appendChild(container);
        
        logFloaterState.container = container;
        logFloaterState.logList = container.querySelector('#autods-log-floater-content');
        
        // Event handlers
        const header = container.querySelector('#autods-log-floater-header');
        const toggleBtn = container.querySelector('#autods-log-toggle');
        const clearBtn = container.querySelector('#autods-log-clear');
        const badge = container.querySelector('#autods-log-floater-badge');
        
        let newCount = 0;
        
        header.addEventListener('click', (e) => {
            if (e.target.closest('button')) return;
            toggleFloater();
        });
        
        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFloater();
        });
        
        clearBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            clearLogs();
        });
        
        function toggleFloater() {
            logFloaterState.minimized = !logFloaterState.minimized;
            container.classList.toggle('minimized', logFloaterState.minimized);
            toggleBtn.textContent = logFloaterState.minimized ? 'âž•' : 'âž–';
            if (!logFloaterState.minimized) {
                newCount = 0;
                badge.textContent = '0';
                badge.classList.remove('has-new');
            }
        }
        
        function clearLogs() {
            logFloaterState.logs = [];
            logFloaterState.logList.innerHTML = '';
            newCount = 0;
            badge.textContent = '0';
            badge.classList.remove('has-new');
        }
        
        // Apply initial minimized state from config
        if (config.minimized) {
            logFloaterState.minimized = true;
            container.classList.add('minimized');
            toggleBtn.textContent = 'âž•';
        }
        
        // Store badge reference for updates
        logFloaterState.badge = badge;
        logFloaterState.updateBadge = () => {
            if (logFloaterState.minimized) {
                newCount++;
                badge.textContent = newCount > 99 ? '99+' : newCount.toString();
                badge.classList.add('has-new');
            }
        };
    }
    
    function addLogToFloater(level, message, config = {}) {
        // Skip if disabled
        if (logFloaterState.enabled === false) return;
        
        if (!logFloaterState.initialized) {
            // Defer creation until DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    createLogFloater(config);
                    addLogToFloater(level, message, config);
                });
                return;
            }
            createLogFloater(config);
        }
        
        // Check if still disabled after init
        if (logFloaterState.enabled === false) return;
        
        // Skip debug logs in floater to reduce noise
        if (level === 'debug') return;
        
        const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        
        // Create log entry
        const entry = document.createElement('div');
        entry.className = `autods-log-entry ${level}`;
        entry.innerHTML = `
            <span class="time">${time}</span>
            <span class="level ${level}">${level}</span>
            <span class="msg">${escapeHtml(message)}</span>
        `;
        
        // Add to list
        logFloaterState.logList.appendChild(entry);
        
        // Keep only maxLogs entries
        while (logFloaterState.logList.children.length > logFloaterState.maxLogs) {
            logFloaterState.logList.removeChild(logFloaterState.logList.firstChild);
        }
        
        // Auto-scroll to bottom
        logFloaterState.logList.scrollTop = logFloaterState.logList.scrollHeight;
        
        // Update badge if minimized
        logFloaterState.updateBadge?.();
    }
    
    function toggleLogFloaterVisibility(enabled) {
        if (logFloaterState.container) {
            logFloaterState.container.style.display = enabled ? 'block' : 'none';
            logFloaterState.enabled = enabled;
        }
    }

    /**
     * Performance profiling utility
     * Measures execution time of operations for optimization
     * 
     * @example
     * performanceProfiler.start('attack-loop');
     * await doAttacks();
     * performanceProfiler.end('attack-loop', logger); // Logs: â±ï¸ [PERF] attack-loop: 1234.56ms
     */
    const performanceProfiler = {
        timers: new Map(),
        
        /**
         * Start timing an operation
         * @param {string} label - Unique label for this timer
         */
        start(label) {
            this.timers.set(label, performance.now());
        },
        
        /**
         * End timing and optionally log result
         * @param {string} label - Timer label
         * @param {Object} logger - Optional logger to output result
         * @returns {number|null} Duration in milliseconds, or null if timer not found
         */
        end(label, logger = null) {
            const start = this.timers.get(label);
            if (!start) return null;
            
            const duration = performance.now() - start;
            this.timers.delete(label);
            
            if (logger) {
                logger.debug(`â±ï¸ [PERF] ${label}: ${duration.toFixed(2)}ms`);
            }
            
            return duration;
        },
        
        /**
         * Wrap an async function with automatic timing
         * @param {string} label - Timer label
         * @param {function} fn - Async function to wrap
         * @param {Object} logger - Optional logger
         * @returns {function} Wrapped function
         */
        measure(label, fn, logger = null) {
            return async (...args) => {
                this.start(label);
                try {
                    const result = await fn(...args);
                    this.end(label, logger);
                    return result;
                } catch (error) {
                    this.end(label, logger);
                    throw error;
                }
            };
        }
    };

    function createLogger(level = 'info', floaterConfig = {}) {
        let currentLevel = level;
        const minIndex = () => LEVELS.indexOf(currentLevel);
        const shouldLog = type => LEVELS.indexOf(type) >= minIndex();

        function log(type, message, metadata) {
            if (!shouldLog(type)) return;
            const stamp = new Date().toISOString();
            const payload = metadata !== undefined ? [message, metadata] : [message];
            const prefix = `[AutoDS][${type.toUpperCase()}][${stamp}]`;
            console[type === 'error' ? 'error' : type === 'warn' ? 'warn' : 'log'](prefix, ...payload);
            
            // Also send to floater (only message, not metadata to keep it clean)
            addLogToFloater(type, message, floaterConfig);
        }

        return {
            debug: (msg, meta) => log('debug', msg, meta),
            info: (msg, meta) => log('info', msg, meta),
            warn: (msg, meta) => log('warn', msg, meta),
            error: (msg, meta) => log('error', msg, meta),
            setLevel: (newLevel) => {
                if (!LEVELS.includes(newLevel)) {
                    console.warn(`Invalid log level: ${newLevel}. Valid levels: ${LEVELS.join(', ')}`);
                    return;
                }
                currentLevel = newLevel;
                console.log(`ðŸ“Š Log level changed to: ${newLevel}`);
            },
            getLevel: () => currentLevel
        };
    }

    function createDomService(logger) {
        const warnedSelectors = new Set();

        function query(selector, root = document) {
            return root.querySelector(selector);
        }

        function queryAll(selector, root = document) {
            return Array.from(root.querySelectorAll(selector));
        }

        function require(selector, description, root = document) {
            const element = query(selector, root);
            if (!element && !warnedSelectors.has(selector)) {
                warnedSelectors.add(selector);
                logger.warn(`Missing DOM node: ${description} (${selector})`);
            }
            return element;
        }

        function create(tag, options = {}) {
            const el = document.createElement(tag);
            Object.assign(el, options);
            return el;
        }

        return { query, queryAll, require, create };
    }

    function createScheduler(logger) {
        const timers = new Map();

        function track(handle, type) {
            timers.set(handle, type);
            return handle;
        }

        function addInterval(fn, delay, label = 'interval') {
            const wrapped = () => {
                try {
                    fn();
                } catch (error) {
                    logger.error(`Interval "${label}" failed`, error);
                }
            };
            return track(setInterval(wrapped, delay), 'interval');
        }

        function addTimeout(fn, delay, label = 'timeout') {
            const handle = setTimeout(() => {
                timers.delete(handle);
                try {
                    fn();
                } catch (error) {
                    logger.error(`Timeout "${label}" failed`, error);
                }
            }, delay);
            return track(handle, 'timeout');
        }

        function clear(handle) {
            if (!timers.has(handle)) return;
            const type = timers.get(handle);
            if (type === 'interval') {
                clearInterval(handle);
            } else {
                clearTimeout(handle);
            }
            timers.delete(handle);
        }

        function disposeAll() {
            timers.forEach((type, handle) => {
                if (type === 'interval') {
                    clearInterval(handle);
                } else {
                    clearTimeout(handle);
                }
            });
            timers.clear();
        }

        return { addInterval, addTimeout, clear, disposeAll };
    }

    function createEventBus() {
        const target = new EventTarget();
        return {
            on: (type, handler) => target.addEventListener(type, handler),
            off: (type, handler) => target.removeEventListener(type, handler),
            emit: (type, detail) => target.dispatchEvent(new CustomEvent(type, { detail }))
        };
    }

    function deepMerge(target, source) {
        const output = Array.isArray(target) ? [...target] : { ...target };
        if (typeof source !== 'object' || source === null) return output;
        Object.keys(source).forEach(key => {
            const srcVal = source[key];
            if (Array.isArray(srcVal)) {
                output[key] = [...srcVal];
            } else if (typeof srcVal === 'object' && srcVal !== null) {
                output[key] = deepMerge(output[key] || {}, srcVal);
            } else {
                output[key] = srcVal;
            }
        });
        return output;
    }

    function createConfig(storage, events) {
        function importLegacyFarming(config, savedExists) {
            // NOTE: Legacy farming import disabled in v0.8.0-alpha
            // The 'farm' section was removed as part of UI redesign
            // All farming functionality consolidated into ultraFast* modules
            if (typeof window === 'undefined' || !window.localStorage) return false;
            let changed = false;
            try {
                const legacy = window.localStorage;
                // Legacy farm configuration is no longer supported
                // This function is kept for backward compatibility but does nothing
                // Users should use ultraFast* configuration instead
            } catch (error) {
                console.warn('[AutoDS][config] Legacy farming import failed', error);
            }
            return changed;
        }

        function syncLegacyFarming(config) {
            // NOTE: Legacy farming sync disabled in v0.8.0-alpha
            // The 'farm' section was removed as part of UI redesign
            // This function is kept for backward compatibility but does nothing
            if (typeof window === 'undefined' || !window.localStorage) return;
            try {
                // Legacy farm configuration sync is no longer supported
                // No action needed
            } catch (error) {
                // Silently ignore legacy sync errors
            }
        }

        function importLegacyPvP(config, savedExists) {
            if (typeof window === 'undefined' || !window.localStorage) return false;
            let changed = false;
            try {
                const legacy = window.localStorage;
                const legacyEnabled = legacy.getItem('veyra-pvp-automation');
                if (legacyEnabled !== null && (!savedExists || config.pvp.enabled === DEFAULT_CONFIG.pvp.enabled)) {
                    const boolValue = legacyEnabled === 'true';
                    if (config.pvp.enabled !== boolValue) {
                        config.pvp.enabled = boolValue;
                        changed = true;
                    }
                }

                const legacyMode = legacy.getItem('pvp-automation-mode');
                if (legacyMode && (!savedExists || config.pvp.autoMode === DEFAULT_CONFIG.pvp.autoMode)) {
                    const mappedMode = legacyMode === 'x' ? 'limited' : 'all';
                    if (config.pvp.autoMode !== mappedMode) {
                        config.pvp.autoMode = mappedMode;
                        changed = true;
                    }
                }

                const legacyCount = parseInt(legacy.getItem('pvp-automation-x-count'), 10);
                if (!Number.isNaN(legacyCount) && (!savedExists || config.pvp.limitedBattles === DEFAULT_CONFIG.pvp.limitedBattles)) {
                    if (config.pvp.limitedBattles !== legacyCount) {
                        config.pvp.limitedBattles = legacyCount;
                        changed = true;
                    }
                }

                const legacySurrender = legacy.getItem('pvp-auto-surrend');
                if (legacySurrender !== null && (!savedExists || config.pvp.autoSurrender === DEFAULT_CONFIG.pvp.autoSurrender)) {
                    const boolValue = legacySurrender === 'true';
                    if (config.pvp.autoSurrender !== boolValue) {
                        config.pvp.autoSurrender = boolValue;
                        changed = true;
                    }
                }
            } catch (error) {
                console.warn('[AutoDS][config] Legacy PvP import failed', error);
            }
            return changed;
        }

        function syncLegacyPvP(config) {
            if (typeof window === 'undefined' || !window.localStorage) return;
            try {
                const legacy = window.localStorage;
                legacy.setItem('veyra-pvp-automation', Boolean(config.pvp.enabled).toString());
                legacy.setItem('pvp-auto-surrend', Boolean(config.pvp.autoSurrender).toString());
                const legacyMode = config.pvp.autoMode === 'limited' ? 'x' : 'all';
                legacy.setItem('pvp-automation-mode', legacyMode);
                legacy.setItem('pvp-automation-x-count', String(config.pvp.limitedBattles ?? DEFAULT_CONFIG.pvp.limitedBattles));
                if (config.pvp.autoMode === 'limited') {
                    legacy.setItem('pvp-automation-x-remaining', String(Math.max(0, config.pvp.limitedBattles ?? 0)));
                }
            } catch (error) {
                console.warn('[AutoDS][config] Legacy PvP sync failed', error);
            }
        }

        function load() {
            const saved = storage.get('config', null);
            let config = deepMerge({}, DEFAULT_CONFIG);
            if (saved) {
                config = deepMerge(config, saved);
            }
            const farmingChanged = importLegacyFarming(config, Boolean(saved));
            const pvpChanged = importLegacyPvP(config, Boolean(saved));
            if (!saved && (farmingChanged || pvpChanged)) {
                storage.set('config', config);
            }
            syncLegacyFarming(config);
            syncLegacyPvP(config);
            return config;
        }

        let cache = load();

        function save(newConfig) {
            cache = deepMerge({}, newConfig);
            storage.set('config', cache);
            syncLegacyFarming(cache);
            syncLegacyPvP(cache);
            events?.emit('autods:config:updated', { config: get() });
        }

        function get() {
            return deepMerge({}, cache);
        }

        function update(patch) {
            const merged = deepMerge(cache, patch);
            save(merged);
            return merged;
        }

        return { get, save, update };
    }

    // ==================== INVENTORY SERVICE ====================
    // Centralized inventory management and item usage
    // Eliminates ~200 lines of duplicated code
    
    /**
     * Create centralized inventory service
     * Manages item usage and inventory data fetching
     * 
     * @param {Object} context - Script context (logger, config, etc.)
     * @returns {Object} Inventory service
     * @returns {function(): Promise<Object>} fetchInventoryData - Fetch all inventory data from /inventory.php
     * @returns {function(): Promise<boolean>} useFullStaminaPotion - Use 1 Full Stamina Potion (item 35)
     * @returns {function(number): Promise<boolean>} useSmallStaminaPotion - Use N Small Stamina Potions (item 30)
     * @returns {function(): Promise<boolean>} useExpPotion - Use 1 EXP Potion (item 97)
     * @returns {function(number): Promise<boolean>} useHealPotion - Use N Heal Potions (item 50)
     * 
     * @example
     * const inv = context.inventory;
     * const data = await inv.fetchInventoryData();
     * // { small: { invId: 123, quantity: 50, itemId: 30 }, full: {...}, ... }
     * 
     * const success = await inv.useFullStaminaPotion();
     * if (success) console.log('FSP used!');
     * 
     * await inv.useSmallStaminaPotion(3); // Use 3 SSP
     */
    function createInventoryService(context) {
        const { logger } = context;
        
        const ITEM_IDS = {
            SMALL_STAMINA_POTION: 30,
            FULL_STAMINA_POTION: 35,
            EXP_POTION: 97,
            HEAL_POTION: 50
        };
        
        async function fetchInventoryData() {
            try {
                const response = await fetch('https://demonicscans.org/inventory.php', {
                    credentials: 'include'
                });
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                const inventory = {};
                const buttons = doc.querySelectorAll('button[onclick*="useItem"]');
                
                buttons.forEach(btn => {
                    const onclick = btn.getAttribute('onclick') || '';
                    const match = onclick.match(/useItem\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*['"]([^'"]+)['"]\s*,\s*(\d+)\s*\)/);
                    
                    if (match) {
                        const [, invId, itemId, itemName, quantity] = match;
                        const itemIdNum = parseInt(itemId, 10);
                        
                        if (itemIdNum === ITEM_IDS.SMALL_STAMINA_POTION) {
                            inventory.small = { invId, quantity: parseInt(quantity, 10), itemId: itemIdNum };
                        } else if (itemIdNum === ITEM_IDS.FULL_STAMINA_POTION) {
                            inventory.full = { invId, quantity: parseInt(quantity, 10), itemId: itemIdNum };
                        } else if (itemIdNum === ITEM_IDS.EXP_POTION) {
                            inventory.exp = { invId, quantity: parseInt(quantity, 10), itemId: itemIdNum };
                        } else if (itemIdNum === ITEM_IDS.HEAL_POTION) {
                            inventory.heal = { invId, quantity: parseInt(quantity, 10), itemId: itemIdNum };
                        }
                    }
                });
                
                return inventory;
            } catch (error) {
                logger.error('Failed to fetch inventory:', error);
                return {};
            }
        }
        
        async function useItem(invId, itemName) {
            try {
                logger.info(`ðŸ’Š Usando ${itemName}...`);
                
                const response = await fetch('https://demonicscans.org/use_item.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    credentials: 'include',
                    body: `inv_id=${invId}`
                });
                
                const text = await response.text();
                const lower = text.trim().toLowerCase();
                const success = lower.includes('success') || lower.includes('used');
                
                if (success) {
                    logger.info(`âœ… ${itemName} usado com sucesso!`);
                } else {
                    logger.warn(`âš ï¸ Falha ao usar ${itemName}: ${text.substring(0, 100)}`);
                }
                
                return success;
            } catch (error) {
                logger.error(`âŒ Erro ao usar ${itemName}:`, error);
                return false;
            }
        }
        
        return {
            fetchInventoryData,
            
            async useFullStaminaPotion() {
                const inv = await fetchInventoryData();
                const fsp = inv.full;
                
                if (!fsp || !fsp.invId || !fsp.quantity || fsp.quantity < 1) {
                    logger.warn('ðŸ’Š Sem Full Stamina Potion disponÃ­vel');
                    return false;
                }
                
                logger.info(`ðŸ’Š FSP disponÃ­vel: ${fsp.quantity}x (inv_id: ${fsp.invId})`);
                return useItem(fsp.invId, 'Full Stamina Potion');
            },
            
            async useSmallStaminaPotion(quantity = 1) {
                const inv = await fetchInventoryData();
                const ssp = inv.small;
                
                if (!ssp || !ssp.invId || !ssp.quantity || ssp.quantity < quantity) {
                    logger.warn(`ðŸ’Š Sem Small Stamina Potion disponÃ­vel (precisa: ${quantity}, tem: ${ssp?.quantity || 0})`);
                    return false;
                }
                
                logger.info(`ðŸ’Š SSP disponÃ­vel: ${ssp.quantity}x - usando ${quantity}x`);
                const results = await Promise.all(
                    Array.from({ length: quantity }, () => useItem(ssp.invId, 'Small Stamina Potion'))
                );
                
                return results.every(r => r);
            },
            
            async useExpPotion() {
                const inv = await fetchInventoryData();
                const exp = inv.exp;
                
                if (!exp || !exp.invId || !exp.quantity || exp.quantity < 1) {
                    logger.warn('ðŸ’Š Sem EXP Potion disponÃ­vel');
                    return false;
                }
                
                logger.info(`ðŸ’Š EXP Potion disponÃ­vel: ${exp.quantity}x`);
                return useItem(exp.invId, 'EXP Potion');
            },
            
            async useHealPotion() {
                const inv = await fetchInventoryData();
                const heal = inv.heal;
                
                if (!heal || !heal.invId || !heal.quantity || heal.quantity < 1) {
                    logger.warn('ðŸ’Š Sem Heal Potion disponÃ­vel');
                    return false;
                }
                
                logger.info(`ðŸ’Š Heal Potion disponÃ­vel: ${heal.quantity}x`);
                return useItem(heal.invId, 'Heal Potion');
            }
        };
    }

    // ==================== HTTP SERVICE ====================
    // Centralized HTTP request handling (fetch and GM_xmlhttpRequest)
    // Eliminates boilerplate and provides consistent error handling
    
    /**
     * Create centralized HTTP service
     * Provides unified API for HTTP requests with automatic error detection
     * 
     * â­ STRATEGY: Uses fetch API first (less Cloudflare-sensitive) with GM_xmlhttpRequest as fallback
     * Supports both fetch (native, preferred) and GM_xmlhttpRequest (CORS bypass, fallback)
     * 
     * @param {Object} context - Script context (logger, config, etc.)
     * @returns {Object} HTTP service
     * 
     * Primary methods (use fetch, Cloudflare-proof):
     * @returns {function(string, Object): Promise<Object>} get - GET request via fetch (preferred)
     * @returns {function(string, string, Object): Promise<Object>} post - POST request via fetch (preferred)
     * @returns {function(string, Object): Promise<Object>} fetchGet - GET request via fetch (explicit)
     * @returns {function(string, string, Object): Promise<Object>} fetchPost - POST request via fetch (explicit)
     * 
     * Fallback methods (use GM_xmlhttpRequest if fetch fails):
     * @returns {function(string, Object): Promise<Object>} gmGet - GET request via GM (fallback)
     * @returns {function(string, string, Object): Promise<Object>} gmPost - POST request via GM (fallback)
     * 
     * Game-specific endpoints:
     * @returns {function(string, string): Promise<Object>} joinBattle - Join wave battle (wave monster)
     * @returns {function(string, string): Promise<Object>} joinDungeonBattle - Join dungeon battle (dgmid + instance_id)
     * @returns {function(string, string): Promise<Object>} lootMonster - Loot wave monster
     * @returns {function(string, string, string): Promise<Object>} lootGuildDungeon - Loot guild dungeon monster
     * @returns {function(string): Promise<Object>} useItem - Use inventory item (inv_id)
     * @returns {function(): Promise<Object>} getInventory - Fetch inventory page HTML
     * 
     * @example
     * const http = context.http;
     * 
     * // Join dungeon battle (uses fetch first)
     * const result = await http.joinDungeonBattle('386752', '1522');
     * if (result.success) console.log('Joined!');
     * 
     * // Loot monster (uses fetch first)
     * await http.lootMonster('123456', userId);
     * 
     * // Custom request
     * const data = await http.post('/custom_endpoint.php', 'param=value');
     */
    function createHttpService(context) {
        const { logger } = context;
        
        const BASE_URL = 'https://demonicscans.org';
        
        /**
         * Make HTTP request using GM_xmlhttpRequest (bypasses CORS)
         * @param {Object} options - Request options
         * @returns {Promise<Object>} Response object with success, data, message
         */
        function gmRequest(options) {
            const {
                method = 'GET',
                url,
                headers = {},
                body = null,
                parseJson = true,
                timeout = 10000
            } = options;
            
            const fullUrl = url.startsWith('http') ? url : `${BASE_URL}${url}`;
            
            const defaultHeaders = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Referer': window.location.href,
                ...headers
            };
            
            return new Promise((resolve) => {
                logger.debug(`[HTTP] ${method} ${fullUrl}`);
                
                GM_xmlhttpRequest({
                    method,
                    url: fullUrl,
                    headers: defaultHeaders,
                    data: body,
                    timeout,
                    onload: (response) => {
                        const text = response.responseText || '';
                        
                        // Detect Cloudflare/403/500 errors
                        const isCloudflareBlock = text.includes('Cloudflare') || text.includes('cf-') || text.includes('Just a moment');
                        const is403Forbidden = response.status === 403;
                        const is500Error = response.status >= 500;
                        
                        if (isCloudflareBlock || is403Forbidden || is500Error) {
                            const reason = isCloudflareBlock ? 'Cloudflare protection' : `HTTP ${response.status}`;
                            logger.warn(`[HTTP] Request blocked: ${reason}`);
                            resolve({
                                success: false,
                                message: `Blocked by ${reason}`,
                                cloudflareBlock: isCloudflareBlock,
                                status: response.status,
                                raw: text
                            });
                            return;
                        }
                        
                        // Parse response
                        if (parseJson) {
                            try {
                                const data = JSON.parse(text);
                                resolve({
                                    success: true,
                                    data,
                                    status: response.status,
                                    message: data.message || ''
                                });
                            } catch (e) {
                                // Assume success if 2xx status
                                if (response.status >= 200 && response.status < 300) {
                                    resolve({
                                        success: true,
                                        data: null,
                                        raw: text,
                                        status: response.status,
                                        message: 'Request succeeded (non-JSON)'
                                    });
                                } else {
                                    logger.error('[HTTP] JSON parse error:', e);
                                    resolve({
                                        success: false,
                                        error: 'JSON parse error',
                                        raw: text,
                                        status: response.status
                                    });
                                }
                            }
                        } else {
                            resolve({
                                success: response.status >= 200 && response.status < 300,
                                data: text,
                                raw: text,
                                status: response.status
                            });
                        }
                    },
                    onerror: (error) => {
                        logger.error('[HTTP] Request error:', error);
                        resolve({
                            success: false,
                            error: 'Network error',
                            message: 'Network error occurred'
                        });
                    },
                    ontimeout: () => {
                        logger.warn('[HTTP] Request timeout');
                        resolve({
                            success: false,
                            error: 'Timeout',
                            message: 'Request timed out'
                        });
                    }
                });
            });
        }
        
        /**
         * Make HTTP request using fetch API
         * @param {Object} options - Request options
         * @returns {Promise<Object>} Response object
         */
        async function fetchRequest(options) {
            const {
                method = 'GET',
                url,
                headers = {},
                body = null,
                parseJson = true,
                timeout = 10000
            } = options;
            
            const fullUrl = url.startsWith('http') ? url : `${BASE_URL}${url}`;
            
            const defaultHeaders = {
                'User-Agent': navigator.userAgent,
                'Accept': '*/*',
                'Accept-Language': 'pt-BR,pt;q=0.8,en-US;q=0.5,en;q=0.3',
                'Content-Type': 'application/x-www-form-urlencoded',
                'Sec-GPC': '1',
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Site': 'same-origin',
                'Priority': 'u=0',
                ...headers
            };
            
            try {
                logger.debug(`[HTTP] ${method} ${fullUrl}`);
                if (body) {
                    logger.debug(`[HTTP] Body: ${body.substring ? body.substring(0, 100) : JSON.stringify(body)}`);
                }
                
                const response = await fetch(fullUrl, {
                    method,
                    headers: defaultHeaders,
                    credentials: 'include',
                    body,
                    signal: AbortSignal.timeout(timeout)
                });
                
                if (!response.ok) {
                    logger.warn(`[HTTP] Response not OK: ${response.status} ${response.statusText}`);
                    const errorText = await response.text();
                    logger.warn(`[HTTP] Error response body: ${errorText.substring(0, 200)}`);
                    return {
                        success: false,
                        status: response.status,
                        message: `HTTP ${response.status}: ${response.statusText}`,
                        errorBody: errorText
                    };
                }
                
                const text = await response.text();
                
                if (parseJson) {
                    try {
                        const data = JSON.parse(text);
                        
                        // Check if server returned an error status (e.g., status: "error")
                        const serverSuccess = data.status === 'success' || data.success === true || !data.status;
                        
                        return {
                            success: serverSuccess,
                            data,
                            status: response.status,
                            message: data.message || '',
                            serverStatus: data.status // Original server status field
                        };
                    } catch (e) {
                        logger.error('[HTTP] JSON parse error:', e);
                        return {
                            success: false,
                            error: 'JSON parse error',
                            raw: text,
                            status: response.status
                        };
                    }
                } else {
                    // Plain text response - check for success indicators
                    const lowerText = text.trim().toLowerCase();
                    const isSuccess = lowerText.startsWith('you have successfully') || 
                                     lowerText.includes('joined') ||
                                     lowerText.includes('success');
                    
                    return {
                        success: isSuccess,
                        data: text,
                        raw: text,
                        message: text.trim(),
                        status: response.status
                    };
                }
            } catch (error) {
                logger.error('[HTTP] Fetch error:', error);
                return {
                    success: false,
                    error: error.message,
                    message: error.message
                };
            }
        }
        
        return {
            /**
             * GET request using fetch API (preferred)
             */
            get(url, options = {}) {
                return fetchRequest({ method: 'GET', url, ...options });
            },
            
            /**
             * POST request using fetch API (preferred)
             */
            post(url, body, options = {}) {
                logger.debug(`[HTTP.post] Called with url=${url}, body=${body ? 'present' : 'MISSING'}`);
                if (body && typeof body === 'string') {
                    logger.debug(`[HTTP.post] Body content: ${body.substring(0, 150)}`);
                }
                return fetchRequest({ method: 'POST', url, body, ...options });
            },
            
            /**
             * GET request using fetch API (explicit)
             */
            fetchGet(url, options = {}) {
                return fetchRequest({ method: 'GET', url, ...options });
            },
            
            /**
             * POST request using fetch API (explicit)
             */
            fetchPost(url, body, options = {}) {
                return fetchRequest({ method: 'POST', url, body, ...options });
            },
            
            /**
             * GET request using GM_xmlhttpRequest (fallback only)
             */
            gmGet(url, options = {}) {
                return gmRequest({ method: 'GET', url, ...options });
            },
            
            /**
             * POST request using GM_xmlhttpRequest (fallback only)
             */
            gmPost(url, body, options = {}) {
                return gmRequest({ method: 'POST', url, body, ...options });
            },
            
            // ========== Game-specific endpoints ==========
            
            /**
             * Join battle directly
             * Returns plain text response: "You have successfully joined the battle."
             */
            async joinBattle(monsterId, userId) {
                if (!monsterId) {
                    logger.error(`âŒ joinBattle called with invalid monsterId: ${monsterId}`);
                    return { error: 'Invalid monsterId', status: 400 };
                }
                if (!userId) {
                    logger.error(`âŒ joinBattle called with invalid userId: ${userId}`);
                    return { error: 'Invalid userId', status: 400 };
                }
                
                const body = `monster_id=${monsterId}&user_id=${userId}`;
                logger.debug(`ðŸ“¤ Sending JOIN request - monster_id=${monsterId}, user_id=${userId}`);
                
                return this.post('/user_join_battle.php', body, {
                    headers: {
                        'Referer': `${BASE_URL}/active_wave.php`,
                        'Sec-GPC': '1',
                        'Alt-Used': 'demonicscans.org',
                        'Sec-Fetch-Dest': 'empty',
                        'Sec-Fetch-Mode': 'cors',
                        'Sec-Fetch-Site': 'same-origin',
                        'Priority': 'u=0'
                    },
                    parseJson: false  // Plain text response, not JSON
                });
            },
            
            /**
             * Join dungeon battle
             * Uses dungeon_join_battle.php endpoint (NOT user_join_battle.php)
             * Returns plain text response: "You have successfully joined..."
             */
            async joinDungeonBattle(dgmid, instanceId) {
                const body = `dgmid=${dgmid}&instance_id=${instanceId}`;
                return this.post('/dungeon_join_battle.php', body, {
                    headers: {
                        'Referer': `${BASE_URL}/guild_dungeon_location.php`,
                        'Sec-GPC': '1',
                        'Alt-Used': 'demonicscans.org',
                        'Sec-Fetch-Dest': 'empty',
                        'Sec-Fetch-Mode': 'cors',
                        'Sec-Fetch-Site': 'same-origin',
                        'Priority': 'u=0'
                    },
                    parseJson: false  // Plain text response, not JSON
                });
            },
            
            /**
             * Loot monster rewards
             */
            async lootMonster(monsterId, userId) {
                const body = `monster_id=${monsterId}&user_id=${userId}`;
                return this.post('/loot.php', body, {
                    headers: {
                        'Referer': `${BASE_URL}/battle.php?id=${monsterId}`
                    }
                });
            },
            
            /**
             * Loot guild dungeon monster
             */
            async lootGuildDungeon(dgmid, instanceId, userId) {
                const body = `instance_id=${encodeURIComponent(instanceId)}&dgmid=${encodeURIComponent(dgmid)}&user_id=${encodeURIComponent(userId)}`;
                return this.post('/dungeon_loot.php', body, {
                    headers: {
                        'Referer': `${BASE_URL}/battle.php?dgmid=${dgmid}&instance_id=${instanceId}`
                    }
                });
            },
            
            /**
             * Use item from inventory
             */
            async useItem(invId) {
                const body = `inv_id=${invId}`;
                return this.fetchPost('/use_item.php', body, {
                    parseJson: false
                });
            },
            
            /**
             * Fetch inventory data
             */
            async getInventory() {
                return this.fetchGet('/inventory.php', {
                    parseJson: false
                });
            },
            
            // ========== OPTIMIZED FETCH METHODS (Cloudflare-proof) ==========
            // These methods use direct fetch with correct headers/referrer to bypass Cloudflare
            
            /**
             * Generic optimized fetch with Cloudflare-proof headers
             * @param {string} endpoint - Endpoint path or full URL
             * @param {Object} options - Request options
             * @returns {Promise<Object>} Response object
             */
            async fetchDirect(endpoint, { body, referrer, parseJson = true, method = 'POST', customHeaders = null } = {}) {
                const url = endpoint.startsWith('http') ? endpoint : `${BASE_URL}${endpoint}`;
                
                try {
                    logger.debug(`[HTTP:Direct] ${method} ${endpoint}`);
                    
                    // Default headers
                    const headers = {
                        'User-Agent': navigator.userAgent,
                        'Accept': '*/*',
                        'Accept-Language': 'pt-BR,pt;q=0.8,en-US;q=0.5,en;q=0.3',
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Sec-Fetch-Dest': 'empty',
                        'Sec-Fetch-Mode': 'cors',
                        'Sec-Fetch-Site': 'same-origin'
                    };
                    
                    // Merge custom headers if provided
                    if (customHeaders) {
                        Object.assign(headers, customHeaders);
                    }
                    
                    const response = await fetch(url, {
                        credentials: 'include',
                        headers,
                        referrer: referrer || window.location.href,
                        body,
                        method,
                        mode: 'cors'
                    });
                    
                    const text = await response.text();
                    
                    if (parseJson) {
                        try {
                            const data = JSON.parse(text);
                            const serverSuccess = data.status === 'success' || data.success === true;
                            
                            return {
                                success: serverSuccess,
                                data,
                                status: response.status,
                                message: data.message || '',
                                raw: text
                            };
                        } catch (e) {
                            logger.error('[HTTP:Direct] JSON parse error:', e);
                            return {
                                success: false,
                                error: 'JSON parse error',
                                raw: text,
                                status: response.status
                            };
                        }
                    } else {
                        // Plain text response
                        const lowerText = text.trim().toLowerCase();
                        const isSuccess = lowerText.includes('success') || 
                                         lowerText.includes('joined') ||
                                         lowerText.includes('you have') ||
                                         lowerText === 'updated' ||
                                         lowerText === 'added';
                        
                        return {
                            success: isSuccess,
                            data: text,
                            raw: text,
                            message: text.trim(),
                            status: response.status
                        };
                    }
                } catch (error) {
                    logger.error('[HTTP:Direct] Fetch error:', error);
                    return {
                        success: false,
                        error: error.message,
                        message: error.message
                    };
                }
            },
            
            /**
             * Attack monster using optimized fetch (Cloudflare-proof)
             * @param {string} monsterId - Monster ID or dgmid
             * @param {number} skillId - Skill ID (-4 to 0)
             * @param {number} staminaCost - Stamina cost for the skill
             * @param {Object} options - Additional options
             * @returns {Promise<Object>} Attack result
             */
            async attackMonsterDirect(monsterId, skillId, staminaCost, { isDungeon = false, instanceId = null, referrer = null } = {}) {
                let body, battleUrl;
                
                if (isDungeon && instanceId) {
                    // Dungeon attack
                    body = `instance_id=${instanceId}&dgmid=${monsterId}&skill_id=${skillId}&stamina_cost=${staminaCost}`;
                    battleUrl = referrer || `${BASE_URL}/battle.php?dgmid=${monsterId}&instance_id=${instanceId}`;
                } else {
                    // Wave attack
                    body = `monster_id=${monsterId}&skill_id=${skillId}&stamina_cost=${staminaCost}`;
                    battleUrl = referrer || `${BASE_URL}/battle.php?id=${monsterId}`;
                }
                
                return this.fetchDirect('/damage.php', {
                    body,
                    referrer: battleUrl,
                    parseJson: true
                });
            },
            
            /**
             * Loot monster using optimized fetch (Cloudflare-proof)
             * @param {string} monsterId - Monster ID
             * @param {string} userId - User ID
             * @param {string} referrer - Referrer URL (battle page)
             * @returns {Promise<Object>} Loot result
             */
            async lootMonsterDirect(monsterId, userId, referrer = null) {
                const body = `monster_id=${monsterId}&user_id=${userId}`;
                const battleUrl = referrer || `${BASE_URL}/battle.php?id=${monsterId}`;
                
                return this.fetchDirect('/loot.php', {
                    body,
                    referrer: battleUrl,
                    parseJson: true
                });
            },
            
            /**
             * Loot dungeon monster using optimized fetch (Cloudflare-proof)
             * TODO: Get example request to verify body format
             * @param {string} dgmid - Dungeon monster ID
             * @param {string} instanceId - Instance ID
             * @param {string} userId - User ID
             * @param {string} referrer - Referrer URL (dungeon page)
             * @returns {Promise<Object>} Loot result
             */
            async lootDungeonMonsterDirect(dgmid, instanceId, userId, referrer = null) {
                // TODO: Verify body format when example is available
                const body = `instance_id=${instanceId}&dgmid=${dgmid}&user_id=${userId}`;
                const dungeonUrl = referrer || `${BASE_URL}/guild_dungeon_location.php?instance_id=${instanceId}`;
                
                return this.fetchDirect('/dungeon_loot.php', {
                    body,
                    referrer: dungeonUrl,
                    parseJson: true
                });
            },
            
            /**
             * Use potion using optimized fetch (Cloudflare-proof)
             * @param {string} invId - Inventory item ID
             * @param {string} referrer - Referrer URL (battle page)
             * @returns {Promise<Object>} Use item result
             */
            async usePotionDirect(invId, referrer = null) {
                const body = `inv_id=${invId}`;
                const battleUrl = referrer || window.location.href;
                
                return this.fetchDirect('/use_item.php', {
                    body,
                    referrer: battleUrl,
                    parseJson: false  // No response, page reloads
                });
            },
            
            /**
             * Start PvP matchmaking (Cloudflare-proof)
             * Redirects to pvp_battle.php if successful
             * @returns {Promise<Object>} Matchmaking result with redirect status
             */
            async startPvpMatchmaking() {
                const body = 'go=1';
                
                return this.fetchDirect('/pvp_matchmake.php', {
                    body,
                    referrer: 'https://demonicscans.org/pvp.php',
                    parseJson: true,
                    method: 'POST'
                });
            },
            
            /**
             * Attack in PvP battle (Cloudflare-proof)
             * @param {number} skillId - Skill ID (0 = Slash/1 token, -1 = Power Slash/5 tokens)
             * @returns {Promise<Object>} Attack result with HP and damage info
             */
            async attackPvpDirect(skillId = 0) {
                const body = `skill_id=${skillId}`;
                
                return this.fetchDirect('/pvp_attack.php', {
                    body,
                    referrer: 'https://demonicscans.org/pvp_battle.php',
                    parseJson: true,
                    method: 'POST'
                });
            }
        };
    }

    // ==================== NOTIFICATION SERVICE ====================
    // Centralized notification/toast handling
    // Provides consistent UI feedback across all modules
    
    /**
     * Create centralized notification service
     * Manages user notifications and toasts with fallback support
     * Uses native window.showNotification() if available, custom toasts otherwise
     * 
     * @param {Object} context - Script context (logger, config, etc.)
     * @returns {Object} Notification service
     * 
     * Main methods:
     * @returns {function(string, number): void} success - Show success notification (green)
     * @returns {function(string, number): void} error - Show error notification (red, 10s default)
     * @returns {function(string, number): void} warn - Show warning notification (orange)
     * @returns {function(string, number): void} info - Show info notification (blue)
     * 
     * Game-specific shortcuts:
     * @returns {function(number, number): void} staminaLow - Show low stamina warning
     * @returns {function(string, number): void} battleComplete - Show battle completion
     * @returns {function(string, number): void} itemUsed - Show item usage confirmation
     * @returns {function(string, Object): void} lootClaimed - Show loot summary
     * @returns {function(string): void} autoPaused - Show automation pause reason
     * 
     * @example
     * const notify = context.notifications;
     * 
     * notify.success('Battle completed!');
     * notify.error('Attack failed!', 5000);
     * notify.staminaLow(50, 100); // current, required
     * notify.lootClaimed('Dragon', { gold: 1000, exp: 5000 });
     */
    function createNotificationService(context) {
        const { logger, config } = context;
        
        /**
         * Show notification using native game function or custom toast
         */
        function show(message, type = 'info', duration = 4500) {
            // Use native showNotification if available
            if (typeof window.showNotification === 'function') {
                window.showNotification(message, type);
            } else {
                // Fallback: create custom toast
                createToast(message, type, duration);
            }
            
            // Always log as well
            const emoji = {
                success: 'âœ…',
                error: 'âŒ',
                warning: 'âš ï¸',
                info: 'â„¹ï¸'
            }[type] || 'â„¹ï¸';
            
            logger.info(`${emoji} ${message}`);
        }
        
        /**
         * Create custom toast notification
         */
        function createToast(message, type, duration) {
            const toast = document.createElement('div');
            toast.className = `autods-toast autods-toast-${type}`;
            toast.textContent = message;
            
            // Toast styles
            const colors = {
                success: { bg: '#10b981', text: '#fff' },
                error: { bg: '#ef4444', text: '#fff' },
                warning: { bg: '#f59e0b', text: '#fff' },
                info: { bg: '#3b82f6', text: '#fff' }
            };
            
            const color = colors[type] || colors.info;
            
            toast.style.cssText = `
                background: ${color.bg};
                color: ${color.text};
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                font-size: 14px;
                font-weight: 500;
                max-width: 300px;
                word-wrap: break-word;
                animation: autods-toast-slide-in 0.3s ease-out;
            `;
            
            const container = getOrCreateToastContainer();
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'autods-toast-fade-out 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }
        
        /**
         * Get or create toast container
         */
        function getOrCreateToastContainer() {
            let container = document.getElementById('autods-toast-container');
            
            if (!container) {
                container = document.createElement('div');
                container.id = 'autods-toast-container';
                container.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 2147483646;
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    pointer-events: none;
                `;
                
                // Inject animations
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes autods-toast-slide-in {
                        from {
                            transform: translateX(400px);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                    
                    @keyframes autods-toast-fade-out {
                        from {
                            opacity: 1;
                        }
                        to {
                            opacity: 0;
                            transform: translateY(-20px);
                        }
                    }
                    
                    .autods-toast {
                        pointer-events: auto;
                        cursor: default;
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(container);
            }
            
            return container;
        }
        
        return {
            /**
             * Show success notification
             */
            success(message, duration) {
                show(message, 'success', duration);
            },
            
            /**
             * Show error notification
             */
            error(message, duration = 10000) {
                show(message, 'error', duration);
            },
            
            /**
             * Show warning notification
             */
            warn(message, duration) {
                show(message, 'warning', duration);
            },
            
            /**
             * Show info notification
             */
            info(message, duration) {
                show(message, 'info', duration);
            },
            
            // ========== Game-specific shortcuts ==========
            
            /**
             * Stamina low warning
             */
            staminaLow(current, required) {
                this.warn(`âš¡ Stamina baixa: ${current}/${required}`);
            },
            
            /**
             * Battle completed
             */
            battleComplete(monsterName, damage) {
                this.success(`âš”ï¸ ${monsterName} completado! ${formatNumber(damage)} dano`);
            },
            
            /**
             * Item used notification
             */
            itemUsed(itemName, remaining) {
                this.info(`ðŸ’Š ${itemName} usado! Restam: ${remaining}`);
            },
            
            /**
             * Loot claimed notification
             */
            lootClaimed(monsterName, rewards) {
                const parts = [];
                if (rewards.exp) parts.push(`${formatNumber(rewards.exp)} EXP`);
                if (rewards.gold) parts.push(`${formatNumber(rewards.gold)} Gold`);
                const rewardStr = parts.length > 0 ? ` (${parts.join(', ')})` : '';
                this.success(`ðŸŽ Loot obtido: ${monsterName}${rewardStr}`);
            },
            
            /**
             * Auto-pause notification
             */
            autoPaused(reason) {
                this.warn(`â¸ï¸ AutomaÃ§Ã£o pausada: ${reason}`);
            }
        };
    }

    // ==================== COMBAT SERVICE ====================
    // Centralized combat operations (attacks, damage parsing)
    // Eliminates ~400 lines of duplicated code
    
    /**
     * Create centralized combat service
     * Handles all attack types (WAVE, DUNGEON, PVP) with unified API
     * Includes automatic damage parsing and battle state detection
     * 
     * @param {Object} context - Script context (logger, config, etc.)
     * @returns {Object} Combat service
     * 
     * Attack methods:
     * @returns {function(string, number): Promise<Object>} attackWaveMonster - Attack wave monster (monster_id, skill_id)
     * @returns {function(string, string, number): Promise<Object>} attackDungeonMonster - Attack dungeon monster (dgmid, instance_id, skill_id)
     * @returns {function(number): Promise<Object>} attackPvpOpponent - Attack PvP opponent (skill_id)
     * 
     * Utility methods:
     * @returns {function(Array, function): Promise<Array>} attackMultiple - Execute multiple attacks in parallel
     * @returns {function(number, string): number} getSkillCost - Get stamina/token cost for skill
     * 
     * Attack response format:
     * {
     *   success: boolean,
     *   damageDealt: number,
     *   stamina: number,
     *   hp: { value: number, max: number },
     *   battleEnded: boolean,
     *   message: string,
     *   data: Object // Original server response
     * }
     * 
     * Skill IDs and costs:
     * - 0: Slash (1 stamina)
     * - -1: Power Slash (10 stamina / 5 tokens)
     * - -2: Heroic Slash (50 stamina)
     * - -3: Ultimate Slash (100 stamina)
     * - -4: Legendary Slash (200 stamina)
     * 
     * @example
     * const combat = context.combat;
     * 
     * // Attack wave monster
     * const result = await combat.attackWaveMonster('123456', -2);
     * if (result.success) {
     *   console.log(`Dealt ${result.damageDealt} damage!`);
     *   if (result.battleEnded) console.log('Monster died!');
     * }
     * 
     * // Attack dungeon monster
     * await combat.attackDungeonMonster('386752', '1522', -1);
     * 
     * // Get skill cost
     * const cost = combat.getSkillCost(-2); // 50 stamina
     */
    function createCombatService(context) {
        const { logger } = context;
        
        const SKILL_COSTS = {
            STAMINA: { '0': 1, '-1': 10, '-2': 50, '-3': 100, '-4': 200 },
            PVP_TOKENS: { '0': 1, '-1': 5 }
        };
        
        const ENDPOINTS = {
            WAVE: 'https://demonicscans.org/damage.php',
            PVP: 'https://demonicscans.org/pvp_attack.php',
            DUNGEON: 'https://demonicscans.org/damage.php' // Guild dungeons use damage.php, not dungeon_attack.php
        };
        
        function sendAttack({ type, monsterId, skillId, instanceId, referer }) {
            return new Promise((resolve) => {
                const endpoint = ENDPOINTS[type];
                
                // Calculate stamina cost (both WAVE and DUNGEON attacks require stamina)
                const staminaCost = (type === 'WAVE' || type === 'DUNGEON') 
                    ? (SKILL_COSTS.STAMINA[skillId.toString()] || 1) 
                    : 0;
                
                // Build body parameters based on attack type
                let bodyData;
                if (type === 'PVP') {
                    bodyData = `skill=${skillId}`;
                } else if (type === 'DUNGEON') {
                    // Guild dungeon attack - same format as WAVE but with dgmid instead of monster_id
                    bodyData = `instance_id=${instanceId}&dgmid=${monsterId}&skill_id=${skillId}&stamina_cost=${staminaCost}`;
                } else {
                    // WAVE attack - correct parameter names from original implementation
                    bodyData = `monster_id=${monsterId}&skill_id=${skillId}&stamina_cost=${staminaCost}`;
                }
                
                GM_xmlhttpRequest({
                    method: 'POST',
                    url: endpoint,
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Referer': referer || endpoint
                    },
                    data: bodyData,
                    onload: (response) => {
                        try {
                            const data = JSON.parse(response.responseText);
                            resolve(parseAttackResponse(data, type));
                        } catch (e) {
                            resolve({ success: false, data: null, message: 'JSON parse error', error: 'Parse error' });
                        }
                    },
                    onerror: () => {
                        resolve({ success: false, data: null, message: 'Network error', error: 'Network error' });
                    },
                    ontimeout: () => {
                        resolve({ success: false, data: null, message: 'Timeout', error: 'Timeout' });
                    }
                });
            });
        }
        
        function parseAttackResponse(data, type) {
            // Robust success check: convert to string and trim (handles boolean/string/number)
            const success = String(data.status).trim() === 'success' || data.success === true;
            
            if (success) {
                return {
                    success: true,
                    data,
                    damageDealt: extractDamage(data),
                    stamina: data.stamina || data.current_stamina,
                    battleEnded: detectBattleEnd(data),
                    message: data.message || ''
                };
            }
            
            return {
                success: false,
                data,
                damageDealt: 0,
                battleEnded: detectBattleEnd(data),
                error: data.error,
                message: data.message || data.error || ''
            };
        }
        
        function extractDamage(data) {
            if (data.damage) return parseInt(data.damage, 10) || 0;
            if (data.your_damage) return parseInt(data.your_damage, 10) || 0;
            
            const match = data.message?.match(/<strong>([\d,]+)<\/strong>/);
            return match ? parseInt(match[1].replace(/,/g, ''), 10) : 0;
        }
        
        function detectBattleEnd(data) {
            const msg = (data.message || data.error || '').toLowerCase();
            return msg.includes('dead') || 
                   msg.includes('ended') || 
                   msg.includes('completed') ||
                   msg.includes('victory') ||
                   data.battle_ended === true;
        }
        
        return {
            async attackWaveMonster(monsterId, skillId) {
                return sendAttack({
                    type: 'WAVE',
                    monsterId,
                    skillId,
                    referer: `https://demonicscans.org/battle.php?id=${monsterId}`
                });
            },
            
            async attackPvpOpponent(skillId) {
                return sendAttack({
                    type: 'PVP',
                    skillId,
                    referer: 'https://demonicscans.org/pvp_battle.php'
                });
            },
            
            async attackDungeonMonster(dgmid, instanceId, skillId) {
                return sendAttack({
                    type: 'DUNGEON',
                    monsterId: dgmid,
                    instanceId,
                    skillId,
                    referer: `https://demonicscans.org/battle.php?dgmid=${dgmid}&instance_id=${instanceId}`
                });
            },
            
            async attackMultiple(targets, attackFn) {
                return Promise.all(targets.map(target => attackFn(target)));
            },
            
            getSkillCost(skillId, type = 'STAMINA') {
                const costs = type === 'PVP' ? SKILL_COSTS.PVP_TOKENS : SKILL_COSTS.STAMINA;
                return costs[skillId.toString()] || 1;
            },
            
            // ========== OPTIMIZED ATTACK METHODS (Cloudflare-proof) ==========
            // These methods use direct fetch with correct headers to bypass Cloudflare
            
            /**
             * Attack wave monster using optimized fetch (Cloudflare-proof)
             * Same API as attackWaveMonster but uses fetchDirect internally
             * @param {string} monsterId - Monster ID
             * @param {number} skillId - Skill ID
             * @returns {Promise<Object>} Attack result with parsed damage
             */
            async attackWaveMonsterDirect(monsterId, skillId) {
                const staminaCost = this.getSkillCost(skillId);
                const referrer = `https://demonicscans.org/battle.php?id=${monsterId}`;
                
                const result = await context.http.attackMonsterDirect(monsterId, skillId, staminaCost, {
                    isDungeon: false,
                    referrer
                });
                
                if (result.success && result.data) {
                    return {
                        success: true,
                        data: result.data,
                        damageDealt: extractDamage(result.data),
                        stamina: result.data.stamina || result.data.current_stamina,
                        battleEnded: detectBattleEnd(result.data),
                        message: result.data.message || ''
                    };
                }
                
                // Check if monster is already dead
                const errorMsg = (result.data?.message || result.message || result.error || '').toLowerCase();
                if (errorMsg.includes('already dead') || errorMsg.includes('monster is dead')) {
                    return {
                        success: false,
                        dead: true,
                        data: null,
                        message: 'Monster is already dead',
                        error: result.error
                    };
                }
                
                return {
                    success: false,
                    data: null,
                    message: result.data?.message || result.message || 'Attack failed',
                    error: result.error
                };
            },
            
            /**
             * Attack dungeon monster using optimized fetch (Cloudflare-proof)
             * Same API as attackDungeonMonster but uses fetchDirect internally
             * @param {string} dgmid - Dungeon monster ID
             * @param {string} instanceId - Instance ID
             * @param {number} skillId - Skill ID
             * @returns {Promise<Object>} Attack result with parsed damage
             */
            async attackDungeonMonsterDirect(dgmid, instanceId, skillId) {
                const staminaCost = this.getSkillCost(skillId);
                const referrer = `https://demonicscans.org/battle.php?dgmid=${dgmid}&instance_id=${instanceId}`;
                
                const result = await context.http.attackMonsterDirect(dgmid, skillId, staminaCost, {
                    isDungeon: true,
                    instanceId,
                    referrer
                });
                
                if (result.success && result.data) {
                    return {
                        success: true,
                        data: result.data,
                        damageDealt: extractDamage(result.data),
                        stamina: result.data.stamina || result.data.current_stamina,
                        battleEnded: detectBattleEnd(result.data),
                        message: result.data.message || ''
                    };
                }
                
                // Check if monster is already dead
                const errorMsg = (result.data?.message || result.message || result.error || '').toLowerCase();
                if (errorMsg.includes('already dead') || errorMsg.includes('monster is dead')) {
                    return {
                        success: false,
                        dead: true,
                        data: null,
                        message: 'Monster is already dead',
                        error: result.error
                    };
                }
                
                return {
                    success: false,
                    data: null,
                    message: result.data?.message || result.message || 'Attack failed',
                    error: result.error
                };
            }
        };
    }

    // ==================== BATTLE STATS SERVICE ====================
    // Centralized battle statistics reading from DOM
    // Eliminates ~150 lines of duplicated code across modules
    
    /**
     * Create centralized battle stats service
     * Provides unified API for reading battle-related stats from DOM
     * 
     * @param {Object} context - Script context (logger, dom, etc.)
     * @returns {Object} Battle stats service
     * 
     * Main methods:
     * @returns {function(): Object} getCurrent - Get all current battle stats
     * @returns {function(): Object} getPlayerHP - Get player HP (current, max, percent)
     * @returns {function(): Object} getMonsterHP - Get monster HP (current, max, percent)
     * @returns {function(): Object} isBattleEnded - Check if battle ended
     * @returns {function(): number} getCurrentDamage - Get current damage dealt
     * @returns {function(): Object} getMonsterPhase - Detect monster phase (1-5 based on HP %)
     * 
     * Stats object format:
     * {
     *   damage: number,           // Current damage dealt
     *   monsterHp: number,        // Monster current HP
     *   monsterMaxHp: number,     // Monster max HP
     *   playerHp: number,         // Player current HP
     *   playerMaxHp: number,      // Player max HP
     *   monsterName: string       // Monster name
     * }
     * 
     * HP object format:
     * {
     *   current: number,
     *   max: number,
     *   percent: number  // 0-100
     * }
     * 
     * @example
     * const stats = context.battleStats;
     * 
     * // Get all stats
     * const current = stats.getCurrent();
     * // { damage: 1500000, monsterHp: 8000000, monsterMaxHp: 10000000, ... }
     * 
     * // Get specific stats
     * const playerHp = stats.getPlayerHP();
     * // { current: 1800, max: 2000, percent: 90 }
     * 
     * const monsterHp = stats.getMonsterHP();
     * // { current: 8000000, max: 10000000, percent: 80 }
     * 
     * // Check battle status
     * const ended = stats.isBattleEnded();
     * // { ended: true, reason: 'monster_dead' } or { ended: false, reason: null }
     * 
     * // Get current damage
     * const damage = stats.getCurrentDamage(); // 1500000
     * 
     * // Detect monster phase
     * const phase = stats.getMonsterPhase();
     * // { phase: 4, percent: 65, threshold: '50-75%' }
     */
    function createBattleStatsService(context) {
        const { logger, dom } = context;
        
        return {
            /**
             * Get all current battle stats from DOM
             * @returns {Object} Battle stats object
             */
            getCurrent() {
                try {
                    // Read current damage - OPTIMIZE: try selectors first before expensive full scan
                    let damage = 0;
                    const damageEl = document.querySelector('#yourDamageValue, [data-your-damage], .your-damage-value');
                    if (damageEl?.textContent) {
                        damage = numberFromText(damageEl.textContent) || 0;
                    }
                    
                    // Fallback: scan for "DMG: X" text only if selector failed
                    if (damage === 0) {
                        const damageTextElements = Array.from(document.querySelectorAll('*')).filter(el => 
                            el.textContent && /DMG:\s*[\d,]+/.test(el.textContent) && el.children.length === 0
                        );
                        if (damageTextElements.length > 0) {
                            const damageMatch = damageTextElements[0].textContent.match(/DMG:\s*([\d,]+)/);
                            if (damageMatch) {
                                damage = numberFromText(damageMatch[1]) || 0;
                            }
                        }
                    }
                    
                    // Read monster HP - OPTIMIZE: try direct selectors first
                    let monsterHp = null;
                    let monsterMaxHp = null;
                    
                    // Strategy 1: Try direct HP selector first (fastest)
                    const hpTextEl = document.querySelector('#hpText, .monster-hp, .hp-text, [data-monster-hp]');
                    if (hpTextEl) {
                        const hpText = hpTextEl.textContent?.trim();
                        if (hpText) {
                            const parts = hpText.split('/').map(s => s.trim());
                            if (parts.length >= 2) {
                                monsterHp = numberFromText(parts[0]);
                                monsterMaxHp = numberFromText(parts[1]);
                            } else {
                                monsterHp = numberFromText(hpText);
                            }
                        }
                    }
                    
                    // Strategy 2 (fallback): Find "HP" label followed by strong tags
                    if (monsterHp === null) {
                        const hpLabels = Array.from(document.querySelectorAll('*')).filter(el => 
                            el.textContent?.trim() === 'HP' && el.tagName !== 'STRONG'
                        );
                    
                    for (const label of hpLabels) {
                        const parent = label.parentElement;
                        if (parent) {
                            const strongs = parent.querySelectorAll('strong');
                            if (strongs.length >= 1) {
                                monsterHp = numberFromText(strongs[0].textContent);
                                // Look for "/ number" text after the strong tag
                                const siblings = Array.from(parent.childNodes);
                                for (let i = 0; i < siblings.length; i++) {
                                    const node = siblings[i];
                                    if (node.nodeType === Node.TEXT_NODE && node.textContent.includes('/')) {
                                        const maxMatch = node.textContent.match(/\/\s*([\d,]+)/);
                                        if (maxMatch) {
                                            monsterMaxHp = numberFromText(maxMatch[1]);
                                            break;
                                        }
                                    }
                                }
                                if (monsterHp !== null) break;
                            }
                        }
                    }
                    }
                    
                    // Strategy 3: Look for pattern "â¤ï¸ 0 / 40,000,000 HP"
                    if (monsterHp === null) {
                        const hpPattern = Array.from(document.querySelectorAll('*')).filter(el => 
                            el.textContent && /â¤ï¸\s*[\d,]+\s*\/\s*[\d,]+\s*HP/.test(el.textContent) && el.children.length === 0
                        );
                        if (hpPattern.length > 0) {
                            const hpMatch = hpPattern[0].textContent.match(/â¤ï¸\s*([\d,]+)\s*\/\s*([\d,]+)\s*HP/);
                            if (hpMatch) {
                                monsterHp = numberFromText(hpMatch[1]);
                                monsterMaxHp = numberFromText(hpMatch[2]);
                            }
                        }
                    }
                    
                    // Fallback to old selectors
                    if (monsterHp === null) {
                        const monsterHpEl = document.querySelector('[data-monster-hp], #monsterHP, .monster-hp');
                        if (monsterHpEl) {
                            const hpText = monsterHpEl.textContent?.trim();
                            if (hpText) {
                                const parts = hpText.split('/').map(s => numberFromText(s.trim()));
                                if (parts.length === 2) {
                                    monsterHp = parts[0];
                                    monsterMaxHp = parts[1];
                                } else {
                                    monsterHp = numberFromText(hpText);
                                }
                            }
                            
                            const currentHpAttr = monsterHpEl.getAttribute('data-current-hp');
                            const maxHpAttr = monsterHpEl.getAttribute('data-max-hp');
                            if (currentHpAttr) monsterHp = numberFromText(currentHpAttr);
                            if (maxHpAttr) monsterMaxHp = numberFromText(maxHpAttr);
                        }
                    }
                    
                    // Read player HP (from "ðŸ’š Your HP 157,750 / 157,750" or "ðŸ’š 157,750 / 157,750 HP")
                    let playerHp = null;
                    let playerMaxHp = null;
                    
                    const playerHpPattern = Array.from(document.querySelectorAll('*')).filter(el => 
                        el.textContent && /ðŸ’š.*?[\d,]+\s*\/\s*[\d,]+/.test(el.textContent) && el.children.length === 0
                    );
                    
                    if (playerHpPattern.length > 0) {
                        const hpMatch = playerHpPattern[0].textContent.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                        if (hpMatch) {
                            playerHp = numberFromText(hpMatch[1]);
                            playerMaxHp = numberFromText(hpMatch[2]);
                        }
                    }
                    
                    // Fallback to old selectors
                    if (playerHp === null) {
                        const playerHpEl = document.querySelector('#pHpText, [data-player-hp], .player-hp');
                        if (playerHpEl) {
                            const hpText = playerHpEl.textContent?.trim();
                            if (hpText) {
                                const parts = hpText.split('/').map(s => numberFromText(s.trim()));
                                if (parts.length === 2) {
                                    playerHp = parts[0];
                                    playerMaxHp = parts[1];
                                } else {
                                    playerHp = numberFromText(hpText);
                                }
                            }
                        }
                    }
                    
                    // Read monster name (from "ðŸ§Ÿ Lizardman Flamecaster" or "ðŸ§Ÿ Lizardman Shadowclaw DEAD")
                    let monsterName = null;
                    
                    // Strategy 1: Use legacy selectors (same as getCurrentMonsterName in battleModule)
                    const selectors = [
                        '.card-title',           // Guild dungeon & battle page
                        '.panel strong',         // Regular dungeon
                        '.monster-name',         // Battle page
                        '.battle-monster-name',  // Alternative
                        '[data-monster-name]'    // Data attribute
                    ];
                    
                    for (const selector of selectors) {
                        const node = document.querySelector(selector);
                        if (node) {
                            let rawText = node.textContent?.trim() || node.getAttribute?.('data-monster-name')?.trim();
                            if (rawText) {
                                // Remove all emoji characters using Unicode ranges
                                let cleaned = rawText.replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '');
                                
                                // Remove "DEAD" badge
                                cleaned = cleaned.replace(/\s*DEAD\s*$/i, '');
                                
                                // Clean up extra whitespace
                                cleaned = cleaned.trim();
                                
                                // Validate: must have content and not be HP/DMG text
                                if (cleaned.length > 2 && 
                                    !cleaned.includes('HP') && 
                                    !cleaned.includes('DMG') &&
                                    !cleaned.includes('/')) {
                                    monsterName = cleaned;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Strategy 2: Extract from page title (legacy fallback)
                    if (!monsterName) {
                        const titleMatch = document.title.match(/Battle:\s*(.+?)(?:\s*-|$)/i);
                        if (titleMatch) {
                            monsterName = titleMatch[1].trim();
                        }
                    }

                    
                    return {
                        damage,
                        monsterHp,
                        monsterMaxHp,
                        playerHp,
                        playerMaxHp,
                        monsterName
                    };
                } catch (error) {
                    logger.warn(`[BattleStats] Failed to read stats: ${error.message}`);
                    return {
                        damage: 0,
                        monsterHp: null,
                        monsterMaxHp: null,
                        playerHp: null,
                        playerMaxHp: null,
                        monsterName: null
                    };
                }
            },
            
            /**
             * Get player HP stats
             * @returns {Object} HP object { current, max, percent }
             */
            getPlayerHP() {
                const stats = this.getCurrent();
                const current = stats.playerHp || 0;
                const max = stats.playerMaxHp || 0;
                const percent = max > 0 ? Math.round((current / max) * 100) : 0;
                
                return { current, max, percent };
            },
            
            /**
             * Get monster HP stats
             * @returns {Object} HP object { current, max, percent }
             */
            getMonsterHP() {
                const stats = this.getCurrent();
                const current = stats.monsterHp || 0;
                const max = stats.monsterMaxHp || current || 0;
                const percent = max > 0 ? Math.round((current / max) * 100) : 0;
                
                return { current, max, percent };
            },
            
            /**
             * Check if battle has ended
             * @returns {Object} { ended: boolean, reason: string|null }
             */
            isBattleEnded() {
                const monsterHp = this.getMonsterHP();
                const playerHp = this.getPlayerHP();
                
                // Monster dead
                if (monsterHp.current <= 0) {
                    return { ended: true, reason: 'monster_dead' };
                }
                
                // Player dead
                if (playerHp.current <= 0) {
                    return { ended: true, reason: 'player_dead' };
                }
                
                // Check for victory/defeat modals
                const victoryModal = document.querySelector('.modal-victory, [data-battle-result="victory"]');
                if (victoryModal && victoryModal.style.display !== 'none') {
                    return { ended: true, reason: 'victory_modal' };
                }
                
                const defeatModal = document.querySelector('.modal-defeat, [data-battle-result="defeat"]');
                if (defeatModal && defeatModal.style.display !== 'none') {
                    return { ended: true, reason: 'defeat_modal' };
                }
                
                return { ended: false, reason: null };
            },
            
            /**
             * Get current damage dealt
             * @returns {number} Damage value
             */
            getCurrentDamage() {
                const stats = this.getCurrent();
                return stats.damage || 0;
            },
            
            /**
             * Detect monster phase based on HP percentage
             * Phase 1: 100-75% HP
             * Phase 2: 75-50% HP
             * Phase 3: 50-25% HP
             * Phase 4: 25-10% HP
             * Phase 5: 10-0% HP
             * 
             * @returns {Object} { phase: number, percent: number, threshold: string }
             */
            getMonsterPhase() {
                const hp = this.getMonsterHP();
                const percent = hp.percent;
                
                if (percent >= 75) {
                    return { phase: 1, percent, threshold: '75-100%' };
                } else if (percent >= 50) {
                    return { phase: 2, percent, threshold: '50-75%' };
                } else if (percent >= 25) {
                    return { phase: 3, percent, threshold: '25-50%' };
                } else if (percent >= 10) {
                    return { phase: 4, percent, threshold: '10-25%' };
                } else {
                    return { phase: 5, percent, threshold: '0-10%' };
                }
            }
        };
    }

    // ==================== MONSTER SCANNER SERVICE ====================
    // Centralized monster card scanning and parsing
    // Eliminates ~200 lines of duplicated code across modules
    
    /**
     * Create centralized monster scanner service
     * Provides unified API for scanning and parsing monster cards from wave/dungeon pages
     * 
     * @param {Object} context - Script context (logger, dom, etc.)
     * @returns {Object} Monster scanner service
     * 
     * Main methods:
     * @returns {function(Object): Array<Monster>} scanWaveMonsters - Scan monsters from active_wave.php
     * @returns {function(Object): Array<DungeonMonster>} scanDungeonMonsters - Scan monsters from guild_dungeon_location.php
     * @returns {function(Array, string): Array} sortByPriority - Sort monsters by priority mode
     * 
     * Monster object format (wave):
     * {
     *   type: 'wave',
     *   monsterId: string,
     *   name: string,
     *   hp: number,
     *   maxHp: number|null,
     *   isDead: boolean,
     *   canJoin: boolean,
     *   hasJoined: boolean,
     *   battleUrl: string|null,
     *   card: HTMLElement
     * }
     * 
     * DungeonMonster object format:
     * {
     *   type: 'dungeon',
     *   dgmid: string,
     *   instanceId: string,
     *   name: string,
     *   hp: number,
     *   maxHp: number,
     *   currentDamage: number,
     *   hasJoined: boolean,
     *   needsLoot: boolean,
     *   card: HTMLElement
     * }
     * 
     * Filter options:
     * {
     *   monsterNames: string[],     // Filter by name (case-insensitive, partial match)
     *   minHp: number,              // Minimum HP
     *   maxHp: number,              // Maximum HP
     *   onlyAlive: boolean,         // Only alive monsters (wave)
     *   onlyDead: boolean,          // Only dead monsters (wave)
     *   onlyNotJoined: boolean,     // Only not joined (dungeon)
     *   onlyNeedsLoot: boolean      // Only needs loot (dungeon)
     * }
     * 
     * Priority modes:
     * - 'lowest_hp': Sort by lowest HP first
     * - 'highest_hp': Sort by highest HP first
     * - 'lowest_damage': Sort by lowest damage first (dungeon)
     * - 'highest_damage': Sort by highest damage first (dungeon)
     * - 'random': Random order
     * 
     * @example
     * const scanner = context.monsterScanner;
     * 
     * // Scan wave monsters
     * const waveMonsters = scanner.scanWaveMonsters({
     *   monsterNames: ['Bonecrusher', 'Dragon'],
     *   minHp: 100000,
     *   onlyAlive: true
     * });
     * // [{ type: 'wave', monsterId: '123', name: 'Bonecrusher', ... }, ...]
     * 
     * // Scan dungeon monsters
     * const dungeonMonsters = scanner.scanDungeonMonsters({
     *   monsterNames: ['Magus'],
     *   onlyNotJoined: true
     * });
     * // [{ type: 'dungeon', dgmid: '386752', instanceId: '1522', ... }, ...]
     * 
     * // Sort by priority
     * const sorted = scanner.sortByPriority(monsters, 'lowest_hp');
     */
    function createMonsterScannerService(context) {
        const { logger } = context;
        
        return {
            /**
             * Scan monsters from active_wave.php
             * @param {Object} filters - Filter options
             * @returns {Array<Monster>} Array of wave monsters
             */
            scanWaveMonsters(filters = {}) {
                const cards = document.querySelectorAll('.monster-card, [data-monster-card]');
                const monsters = [];
                
                for (const card of cards) {
                    const monster = this.parseWaveMonster(card);
                    if (!monster) continue;
                    
                    // Apply filters
                    if (filters.monsterNames?.length && !this.matchesName(monster.name, filters.monsterNames)) continue;
                    if (filters.minHp && monster.hp < filters.minHp) continue;
                    if (filters.maxHp && monster.hp > filters.maxHp) continue;
                    if (filters.onlyAlive && monster.isDead) continue;
                    if (filters.onlyDead && !monster.isDead) continue;
                    if (filters.onlyNotJoined && monster.hasJoined) continue;
                    
                    monsters.push(monster);
                }
                
                logger.debug(`[MonsterScanner] Scanned ${monsters.length} wave monsters (${cards.length} cards total)`);
                return monsters;
            },
            
            /**
             * Scan monsters from guild_dungeon_location.php
             * @param {Object} filters - Filter options
             * @returns {Array<DungeonMonster>} Array of dungeon monsters
             */
            scanDungeonMonsters(filters = {}) {
                const cards = document.querySelectorAll('.mon, [data-dungeon-monster]');
                logger.debug(`[MonsterScanner] Found ${cards.length} dungeon cards in DOM`);
                
                const monsters = [];
                let parsedCount = 0;
                let failedCount = 0;
                
                for (const card of cards) {
                    const monster = this.parseDungeonMonster(card);
                    if (!monster) {
                        failedCount++;
                        continue;
                    }
                    
                    parsedCount++;
                    logger.debug(`[MonsterScanner] Parsed: ${monster.name} (HP: ${context.numbers.format(monster.hp)}/${context.numbers.format(monster.maxHp)}, Joined: ${monster.hasJoined})`);
                    
                    // Apply filters
                    if (filters.monsterNames?.length && !this.matchesName(monster.name, filters.monsterNames)) {
                        logger.debug(`[MonsterScanner] Filtered by name: ${monster.name}`);
                        continue;
                    }
                    if (filters.minHp && monster.hp < filters.minHp) {
                        logger.debug(`[MonsterScanner] Filtered by minHp: ${monster.name} (${context.numbers.format(monster.hp)} < ${context.numbers.format(filters.minHp)})`);
                        continue;
                    }
                    if (filters.maxHp && monster.hp > filters.maxHp) {
                        logger.debug(`[MonsterScanner] Filtered by maxHp: ${monster.name}`);
                        continue;
                    }
                    if (filters.onlyNotJoined && monster.hasJoined) {
                        logger.debug(`[MonsterScanner] Filtered by onlyNotJoined: ${monster.name} (already joined)`);
                        continue;
                    }
                    if (filters.onlyNeedsLoot && !monster.needsLoot) {
                        logger.debug(`[MonsterScanner] Filtered by onlyNeedsLoot: ${monster.name}`);
                        continue;
                    }
                    
                    monsters.push(monster);
                }
                
                logger.info(`[MonsterScanner] Result: ${monsters.length} monsters passed filters (${parsedCount} parsed, ${failedCount} failed, ${cards.length} total cards)`);
                return monsters;
            },
            
            /**
             * Parse wave monster card
             * @private
             * @param {HTMLElement} card - Monster card element
             * @returns {Monster|null} Parsed monster or null if invalid
             */
            parseWaveMonster(card) {
                try {
                    // Extract monster ID
                    const monsterId = card.getAttribute('data-monster-id') || 
                                     card.querySelector('[data-monster-id]')?.getAttribute('data-monster-id');
                    
                    if (!monsterId) {
                        // Debug: log card structure when monsterId is missing
                        const cardId = card.id || 'no-id';
                        const cardClass = card.className || 'no-class';
                        const cardHTML = card.outerHTML?.substring(0, 100) || 'no-html';
                        logger.warn(`âš ï¸ [MonsterScanner] Card sem data-monster-id: id="${cardId}", class="${cardClass}", html="${cardHTML}..."`);
                        return null;
                    }
                    
                    // Extract name
                    const nameNode = card.querySelector('h3, h4, .monster-name, .card-title, [data-monster-name]');
                    const name = nameNode ? nameNode.textContent.trim() : 'Unknown';
                    
                    // Extract HP - structure: .stat-row > .stat-icon.hp + .stat-main > .stat-value
                    let hp = 0;
                    let maxHp = null;
                    
                    // Try new structure first (stat-row with HP label)
                    const statRows = card.querySelectorAll('.stat-row');
                    for (const row of statRows) {
                        const label = row.querySelector('.stat-label');
                        if (label?.textContent?.trim() === 'HP') {
                            const valueNode = row.querySelector('.stat-value');
                            if (valueNode) {
                                const hpText = valueNode.textContent?.trim();
                                if (hpText) {
                                    // Parse "1,000,000 / 2,000,000" or "1,000,000 HP"
                                    const parts = hpText.split('/').map(s => numberFromText(s.trim()));
                                    if (parts.length === 2) {
                                        hp = parts[0] || 0;
                                        maxHp = parts[1] || null;
                                    } else {
                                        hp = numberFromText(hpText) || 0;
                                    }
                                }
                            }
                            break;
                        }
                    }
                    
                    // Fallback to old selectors
                    if (hp === 0 && maxHp === null) {
                        const hpNode = card.querySelector('[data-stat="hp"], [data-hp], .hp-text, .monster-hp');
                        if (hpNode) {
                            const hpText = hpNode.textContent?.trim();
                            if (hpText) {
                                const parts = hpText.split('/').map(s => numberFromText(s.trim()));
                                if (parts.length === 2) {
                                    hp = parts[0] || 0;
                                    maxHp = parts[1] || null;
                                } else {
                                    hp = numberFromText(hpText) || 0;
                                }
                            }
                            
                            // Try data attributes
                            const currentHpAttr = hpNode.getAttribute('data-current-hp');
                            const maxHpAttr = hpNode.getAttribute('data-max-hp');
                            if (currentHpAttr) hp = numberFromText(currentHpAttr) || 0;
                            if (maxHpAttr) maxHp = numberFromText(maxHpAttr);
                        }
                    }
                    
                    // Check if dead
                    const isDead = card.getAttribute('data-dead') === '1' || 
                                  card.classList.contains('dead') ||
                                  hp <= 0;
                    
                    // Extract join button
                    const button = card.querySelector('.join-btn, .btn-join, button.join-btn, [data-action="join"]');
                    const buttonText = button?.textContent?.toLowerCase() || '';
                    const canJoin = buttonText.includes('join') && !buttonText.includes('continue');
                    const hasJoined = !canJoin && (buttonText.includes('continue') || buttonText.includes('fight'));
                    
                    // Extract battle URL
                    const link = card.querySelector('a[href*="battle.php"], a[href*="dungeon_battle.php"]');
                    const battleUrl = link?.href || null;
                    
                    return {
                        type: 'wave',
                        monsterId,
                        name,
                        hp,
                        maxHp,
                        isDead,
                        canJoin,
                        hasJoined,
                        battleUrl,
                        card
                    };
                } catch (error) {
                    logger.warn(`[MonsterScanner] Failed to parse wave monster: ${error.message}`);
                    return null;
                }
            },
            
            /**
             * Parse dungeon monster card
             * @private
             * @param {HTMLElement} card - Monster card element
             * @returns {DungeonMonster|null} Parsed monster or null if invalid
             */
            parseDungeonMonster(card) {
                try {
                    // Extract dgmid and instance_id from link href
                    const link = card.querySelector('a.btn[href*="battle.php"], a[href*="battle.php"]');
                    if (!link) {
                        logger.debug('[MonsterScanner] Card without battle link:', card);
                        return null;
                    }
                    
                    const href = link.getAttribute('href');
                    if (!href) {
                        logger.debug('[MonsterScanner] Link without href:', link);
                        return null;
                    }
                    
                    const dgmidMatch = href.match(/dgmid=(\d+)/);
                    const instanceMatch = href.match(/instance_id=(\d+)/);
                    
                    if (!dgmidMatch || !instanceMatch) {
                        logger.debug(`[MonsterScanner] Invalid href format: ${href}`);
                        return null;
                    }
                    
                    const dgmid = dgmidMatch[1];
                    const instanceId = instanceMatch[1];
                    
                    // Extract name (dungeon structure: text node inside font-weight:700 div)
                    let name = 'Unknown';
                    
                    // Strategy 1: Find div with font-weight:700 (dungeon structure)
                    const nameDiv = card.querySelector('div[style*="font-weight:700"], div[style*="font-weight: 700"]');
                    if (nameDiv) {
                        // Get all text content but skip pills/badges
                        let fullText = '';
                        for (const node of nameDiv.childNodes) {
                            if (node.nodeType === Node.TEXT_NODE) {
                                fullText += node.textContent || '';
                            }
                        }
                        
                        // Clean up the text
                        name = fullText.trim()
                            .replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '') // Remove emoji
                            .replace(/\s*dead\s*$/i, '')  // Remove "dead" suffix
                            .replace(/\s+/g, ' ')         // Normalize whitespace
                            .trim();
                        
                        if (name.length <= 2) name = 'Unknown';
                    }
                    
                    // Strategy 2: Fallback to element selectors (wave structure)
                    if (name === 'Unknown') {
                        const nameElement = card.querySelector('h3, .monster-name, [data-monster-name]');
                        if (nameElement) {
                            name = nameElement.textContent.trim()
                                              .replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '')
                                              .replace(/\s*dead\s*$/i, '')
                                              .replace(/\s+/g, ' ')
                                              .trim();
                        }
                    }
                    
                    // Extract HP (format: "21,972,853 / 25,000,000 HP")
                    let hp = 0;
                    let maxHp = 0;
                    
                    // Strategy 1: Look for .muted div with HP text
                    const mutedDivs = card.querySelectorAll('.muted, div[style*="font-size:12px"]');
                    for (const div of mutedDivs) {
                        const text = div.textContent?.trim() || '';
                        // Match pattern: "NUMBER / NUMBER HP" or "NUMBER/NUMBER HP"
                        if (/\d[\d,]*\s*\/\s*\d[\d,]*\s*HP/i.test(text)) {
                            const parts = text.split('/').map(s => context.numbers.parse(s.trim()));
                            if (parts.length >= 2 && parts[0] && parts[1]) {
                                hp = parts[0];
                                maxHp = parts[1];
                                break;
                            }
                        }
                    }
                    
                    // Strategy 2: Fallback to old selectors (for wave compatibility)
                    if (hp === 0 && maxHp === 0) {
                        const hpNode = card.querySelector('[data-stat="hp"], [data-hp], .hp-text');
                        if (hpNode) {
                            const hpText = hpNode.textContent?.trim();
                            if (hpText) {
                                const parts = hpText.split('/').map(s => context.numbers.parse(s.trim()));
                                if (parts.length === 2) {
                                    hp = parts[0] || 0;
                                    maxHp = parts[1] || 0;
                                } else {
                                    hp = context.numbers.parse(hpText) || 0;
                                }
                            }
                        }
                    }
                    
                    // Extract current damage (nÃ£o disponÃ­vel na lista, precisa buscar na pÃ¡gina de batalha)
                    let currentDamage = 0;
                    
                    // Check if joined (CRITICAL: distinguish between "joined" and "not joined")
                    let hasJoined = false;
                    const pills = card.querySelectorAll('.pill, .badge, span.pill');
                    for (const pill of pills) {
                        const text = pill.textContent?.trim().toLowerCase() || '';
                        // Exact match for "joined" (not "not joined")
                        if (text === 'joined') {
                            hasJoined = true;
                            break;
                        }
                        // "not joined" means NOT joined
                        if (text === 'not joined') {
                            hasJoined = false;
                            break;
                        }
                    }
                    
                    // Check if needs loot (look for "not looted" pill)
                    const notLootedPill = Array.from(card.querySelectorAll('.pill, .badge')).find(pill =>
                        /not looted/i.test(pill.textContent)
                    );
                    const needsLoot = !!notLootedPill;
                    
                    return {
                        type: 'dungeon',
                        dgmid,
                        instanceId,
                        name,
                        hp,
                        maxHp,
                        currentDamage,
                        hasJoined,
                        needsLoot,
                        card
                    };
                } catch (error) {
                    logger.warn(`[MonsterScanner] Failed to parse dungeon monster: ${error.message}`);
                    return null;
                }
            },
            
            /**
             * Check if monster name matches any filter name
             * @private
             * @param {string} monsterName - Monster name to check
             * @param {string[]} filterNames - Array of filter names
             * @returns {boolean} True if matches any filter
             */
            matchesName(monsterName, filterNames) {
                if (!filterNames || filterNames.length === 0) return true;
                
                const nameLower = monsterName.toLowerCase();
                return filterNames.some(filter => {
                    const filterLower = filter.toLowerCase();
                    return nameLower.includes(filterLower);
                });
            },
            
            /**
             * Sort monsters by priority mode
             * @param {Array} monsters - Array of monsters
             * @param {string} mode - Priority mode (lowest_hp, highest_hp, lowest_damage, highest_damage, random)
             * @returns {Array} Sorted array (does not mutate original)
             */
            sortByPriority(monsters, mode = 'lowest_hp') {
                const sorted = [...monsters];
                
                switch (mode) {
                    case 'lowest_hp':
                        sorted.sort((a, b) => (a.hp || 0) - (b.hp || 0));
                        break;
                    case 'highest_hp':
                        sorted.sort((a, b) => (b.hp || 0) - (a.hp || 0));
                        break;
                    case 'lowest_damage':
                        sorted.sort((a, b) => (a.currentDamage || 0) - (b.currentDamage || 0));
                        break;
                    case 'highest_damage':
                        sorted.sort((a, b) => (b.currentDamage || 0) - (a.currentDamage || 0));
                        break;
                    case 'random':
                        sorted.sort(() => Math.random() - 0.5);
                        break;
                    default:
                        logger.warn(`[MonsterScanner] Unknown priority mode: ${mode}, using lowest_hp`);
                        sorted.sort((a, b) => (a.hp || 0) - (b.hp || 0));
                }
                
                return sorted;
            }
        };
    }

    // ==================== USER SESSION SERVICE ====================
    // Centralized user session management
    // Eliminates ~80 lines of duplicated code
    
    /**
     * Create centralized user session service
     * Manages user ID, login state, and user info extraction
     * 
     * @param {Object} context - Script context (logger, config, scheduler, etc.)
     * @returns {Object} User session service
     * 
     * Main methods:
     * @returns {function(): string|null} getUserId - Get user ID from cookie
     * @returns {function(): string|null} ensureUserId - Ensure user ID is set in config (auto-detect)
     * @returns {function(): boolean} isLoggedIn - Check if user is logged in
     * @returns {function(number): number} startAutoDetect - Start periodic user ID check
     * @returns {function(): Object} getUserInfo - Get user info (id, username, level)
     * 
     * UserInfo object format:
     * {
     *   userId: string|null,
     *   username: string|null,
     *   level: number|null
     * }
     * 
     * @example
     * const session = context.userSession;
     * 
     * // Get user ID
     * const userId = session.getUserId(); // '12345' or null
     * 
     * // Ensure user ID is set (auto-detect if missing)
     * const userId = session.ensureUserId(); // Auto-updates config
     * 
     * // Check login status
     * if (!session.isLoggedIn()) {
     *   console.log('Not logged in');
     * }
     * 
     * // Get user info
     * const info = session.getUserInfo();
     * // { userId: '12345', username: 'Player', level: 50 }
     * 
     * // Start auto-detect (checks every 5s)
     * const intervalId = session.startAutoDetect(5000);
     */
    function createUserSessionService(context) {
        const { logger, config, scheduler } = context;
        
        return {
            /**
             * Get user ID from cookie (demon cookie)
             * @returns {string|null} User ID or null if not found
             */
            getUserId() {
                try {
                    const cookies = document.cookie.split(';');
                    for (const cookie of cookies) {
                        const [name, value] = cookie.trim().split('=');
                        if (name === 'demon') {
                            return value || null;
                        }
                    }
                    return null;
                } catch (error) {
                    logger.warn(`[UserSession] Failed to read cookie: ${error.message}`);
                    return null;
                }
            },
            
            /**
             * Ensure user ID is set in config (auto-detect if missing)
             * Updates config if user ID is detected but not saved
             * @returns {string|null} User ID (from config or detected)
             */
            ensureUserId() {
                try {
                    // Check if already in config
                    const cfg = config.get();
                    if (cfg.core?.userId) {
                        return cfg.core.userId;
                    }
                    
                    // Try to detect from cookie
                    const detected = this.getUserId();
                    if (detected) {
                        config.update({ core: { userId: detected } });
                        logger.info(`âœ… User ID auto-detected and saved: ${detected}`);
                        return detected;
                    }
                    
                    logger.warn('âš ï¸ User ID not found in cookie (not logged in?)');
                    return null;
                } catch (error) {
                    logger.error(`[UserSession] Failed to ensure user ID: ${error.message}`);
                    return null;
                }
            },
            
            /**
             * Check if user is logged in
             * @returns {boolean} True if logged in (has user ID cookie)
             */
            isLoggedIn() {
                return !!this.getUserId();
            },
            
            /**
             * Start periodic check for user ID
             * Useful for detecting login after script loads
             * @param {number} intervalMs - Check interval in milliseconds (default: 5000)
             * @returns {number} Interval ID (can be used to stop with scheduler.clearInterval)
             */
            startAutoDetect(intervalMs = 5000) {
                const intervalId = scheduler.addInterval(() => {
                    const cfg = config.get();
                    if (!cfg.core?.userId) {
                        const detected = this.getUserId();
                        if (detected) {
                            config.update({ core: { userId: detected } });
                            logger.info(`âœ… User ID auto-detected: ${detected}`);
                        }
                    }
                }, intervalMs, 'User ID Auto-Detect');
                
                logger.debug(`[UserSession] Auto-detect started (interval: ${intervalMs}ms, id: ${intervalId})`);
                return intervalId;
            },
            
            /**
             * Get user info from page
             * Extracts user ID, username, and level from DOM
             * @returns {Object} UserInfo object { userId, username, level }
             */
            getUserInfo() {
                try {
                    const userId = this.getUserId();
                    
                    // Try to extract username
                    const usernameEl = document.querySelector('[data-username], .username, .player-name, #username');
                    const username = usernameEl?.textContent?.trim() || null;
                    
                    // Try to extract level
                    const levelEl = document.querySelector('[data-level], .level, .player-level, #level');
                    const levelText = levelEl?.textContent?.trim();
                    const level = levelText ? numberFromText(levelText) : null;
                    
                    return {
                        userId,
                        username,
                        level
                    };
                } catch (error) {
                    logger.warn(`[UserSession] Failed to get user info: ${error.message}`);
                    return {
                        userId: null,
                        username: null,
                        level: null
                    };
                }
            }
        };
    }

    // ==================== NUMBER FORMATTING SERVICE ====================
    // Centralized number parsing and formatting
    // Eliminates ~50 lines of duplicated code
    
    /**
     * Create centralized number formatting service
     * Provides unified API for number parsing, formatting, and calculations
     * 
     * @returns {Object} Number formatting service
     * 
     * Main methods:
     * @returns {function(string): number|null} parse - Parse number from text
     * @returns {function(number): string} format - Format number with thousands separators
     * @returns {function(number): string} formatCompact - Format number as compact (1.2M, 3.4K)
     * @returns {function(number, number): number} calculateDamageVsDefense - Calculate damage vs defense
     * 
     * @example
     * const numbers = context.numbers;
     * 
     * // Parse numbers
     * numbers.parse('1,234,567 HP');      // 1234567
     * numbers.parse('ðŸ’° 1,000,000');      // 1000000
     * numbers.parse('Level 50');          // 50
     * 
     * // Format numbers
     * numbers.format(1234567);            // "1,234,567"
     * numbers.formatCompact(1234567);     // "1.23M"
     * numbers.formatCompact(1234);        // "1.23K"
     * 
     * // Calculate damage
     * const damage = numbers.calculateDamageVsDefense(400, 25);
     * // 1000 Ã— (ATK - DEF)^0.25
     */
    function createNumberFormattingService() {
        const NUMBER_FORMAT = new Intl.NumberFormat('en-US');
        
        return {
            /**
             * Parse number from text (removes commas, extracts digits)
             * @param {string} text - Text containing number
             * @returns {number|null} Parsed number or null if not found
             */
            parse(text) {
                if (!text) return null;
                
                try {
                    // Normalize whitespace
                    const normalized = String(text).replace(/\s+/g, ' ');
                    
                    // Match digit sequences (with commas, dots, spaces)
                    const match = normalized.match(/[\d][\d.,\s]*/);
                    if (!match) return null;
                    
                    // Remove non-digits
                    const digits = match[0].replace(/[^\d]/g, '');
                    if (!digits) return null;
                    
                    const parsed = parseInt(digits, 10);
                    return Number.isNaN(parsed) ? null : parsed;
                } catch (error) {
                    return null;
                }
            },
            
            /**
             * Format number with thousands separators
             * @param {number} value - Number to format
             * @returns {string} Formatted number (e.g., "1,234,567")
             */
            format(value) {
                if (value === null || value === undefined || Number.isNaN(value)) {
                    return 'â€”';
                }
                return NUMBER_FORMAT.format(Math.round(value));
            },
            
            /**
             * Format number as compact (1.2M, 3.4K, etc.)
             * @param {number} value - Number to format
             * @returns {string} Compact formatted number
             */
            formatCompact(value) {
                if (value === null || value === undefined || Number.isNaN(value)) {
                    return 'â€”';
                }
                
                if (value >= 1e9) return (value / 1e9).toFixed(2) + 'B';
                if (value >= 1e6) return (value / 1e6).toFixed(2) + 'M';
                if (value >= 1e3) return (value / 1e3).toFixed(2) + 'K';
                
                return this.format(value);
            },
            
            /**
             * Calculate damage vs defense (game formula)
             * Formula: DMG = 1000 Ã— (ATK - DEF)^0.25
             * @param {number} attack - Attack value
             * @param {number} defense - Defense value
             * @returns {number} Calculated damage (0 if ATK <= DEF)
             */
            calculateDamageVsDefense(attack, defense) {
                if (attack <= defense) return 0;
                return Math.round(1000 * Math.pow(attack - defense, 0.25));
            }
        };
    }

    // ==================== UNIFIED LOOT SERVICE ====================
    // Centralized loot management across all game modes (wave, dungeon, single)
    // Provides unified API for looting with level up/stamina checks and detailed modal
    
    /**
     * Create unified loot service
     * Provides unified API for looting monsters across all game modes
     * 
     * @param {Object} context - Script context (logger, http, numbers, etc.)
     * @returns {Object} Unified loot service
     * 
     * Main methods:
     * @returns {function(string, string): Promise<Object>} lootWaveMonster - Loot single wave monster
     * @returns {function(string, string, string): Promise<Object>} lootDungeonMonster - Loot single dungeon monster
     * @returns {function(Array, string): Promise<Object>} lootMultiple - Loot multiple monsters in parallel
     * @returns {function(): Object} createSummary - Create new loot summary object
     * @returns {function(Object, Object): void} updateSummary - Update summary with loot result
     * @returns {function(Object): Object} aggregateByType - Aggregate monsters by type with rates
     * @returns {function(): Object|null} checkLevelUp - Check if player leveled up
     * @returns {function(): boolean} checkStaminaFull - Check if stamina is full
     * @returns {function(Object, string): void} showDetailedModal - Show detailed loot modal
     * 
     * Summary object format:
     * {
     *   drops: number,                 // Total monsters looted
     *   exp: number,                   // Total EXP gained
     *   gold: number,                  // Total gold gained
     *   items: Map<string, Object>,    // Items obtained (key: "name|rarity")
     *   monsters: Map<string, Object>, // Monsters looted (key: monsterName.toLowerCase())
     *   messages: string[]             // Loot messages/errors
     * }
     * 
     * Monster entry format (in summary.monsters Map):
     * {
     *   name: string,      // Display name
     *   exp: number,       // Total EXP from this type
     *   gold: number,      // Total gold from this type
     *   count: number      // Number of monsters looted
     * }
     * 
     * Item entry format (in summary.items Map):
     * {
     *   displayName: string,  // Item name
     *   rarity: string,       // Item rarity (COMMON, RARE, EPIC, LEGENDARY, MYTHICAL)
     *   quantity: number      // Total quantity obtained
     * }
     * 
     * Loot result format:
     * {
     *   success: boolean,
     *   exp: number,
     *   gold: number,
     *   items: Array<{NAME, RARITY, QUANTITY}>,
     *   monsterName: string,
     *   message: string
     * }
     * 
     * @example
     * const loot = context.loot;
     * 
     * // Loot single wave monster
     * const result = await loot.lootWaveMonster('2718588', 'userId123');
     * // { success: true, exp: 3000, gold: 10000, items: [...], monsterName: 'Troll Brawler' }
     * 
     * // Loot multiple monsters
     * const targets = [
     *   { monsterId: '2718588', type: 'wave', name: 'Troll Brawler' },
     *   { dgmid: '456', instanceId: '123', type: 'dungeon', name: 'Dragon' }
     * ];
     * const summary = await loot.lootMultiple(targets, 'userId123');
     * 
     * // Show detailed modal
     * loot.showDetailedModal(summary, 'Wave Farming');
     */
    function createLootService(context) {
        const { logger, http, numbers, notifications, stamina } = context;
        
        // RARITY ICONS AND COLORS
        const RARITY_CONFIG = {
            MYTHICAL: { icon: 'ðŸ”®', color: '#FF1493', label: 'MYTHICAL' },
            LEGENDARY: { icon: 'â­', color: '#FFD700', label: 'LEGENDARY' },
            EPIC: { icon: 'ðŸ’œ', color: '#9D5CFF', label: 'EPIC' },
            RARE: { icon: 'ðŸ’™', color: '#4A9EFF', label: 'RARE' },
            UNCOMMON: { icon: 'ðŸ’š', color: '#4CAF50', label: 'UNCOMMON' },
            COMMON: { icon: 'âšª', color: '#9E9E9E', label: 'COMMON' }
        };
        
        const RARITY_ORDER = ['MYTHICAL', 'LEGENDARY', 'EPIC', 'RARE', 'UNCOMMON', 'COMMON'];
        
        /**
         * Store initial player XP info for level up detection
         */
        let initialExpInfo = null;
        
        /**
         * Loot single wave monster
         * @param {string} monsterId - Monster ID
         * @param {string} userId - User ID
         * @param {string} monsterName - Monster name (optional, for display)
         * @returns {Promise<Object>} Loot result
         */
        async function lootWaveMonster(monsterId, userId, monsterName = 'Unknown Monster') {
            try {
                logger.debug(`[Loot] Looting wave monster ${monsterId} (${monsterName})...`);
                
                const response = await http.lootMonster(monsterId, userId);
                
                if (!response.success) {
                    return {
                        success: false,
                        exp: 0,
                        gold: 0,
                        items: [],
                        monsterName,
                        message: response.error || 'Failed to loot monster'
                    };
                }
                
                const data = response.data || {};
                const rewards = data.rewards || {};
                const exp = rewards.exp || 0;
                const gold = rewards.gold || 0;
                const damage = rewards.damage_dealt || 0;
                const items = data.items || [];
                
                logger.debug(`[Loot] Wave monster looted: ${monsterName} (+${exp} XP, +${gold} Gold, ${damage} DMG, ${items.length} items)`);
                
                return {
                    success: true,
                    exp,
                    gold,
                    damage,
                    items,
                    monsterName,
                    message: data.message || 'Looted successfully'
                };
            } catch (error) {
                logger.error(`[Loot] Error looting wave monster ${monsterId}: ${error.message}`);
                return {
                    success: false,
                    exp: 0,
                    gold: 0,
                    items: [],
                    monsterName,
                    message: error.message
                };
            }
        }
        
        /**
         * Loot single dungeon monster
         * @param {string} dgmid - Dungeon monster ID
         * @param {string} instanceId - Instance ID
         * @param {string} userId - User ID
         * @param {string} monsterName - Monster name (optional, for display)
         * @returns {Promise<Object>} Loot result
         */
        async function lootDungeonMonster(dgmid, instanceId, userId, monsterName = 'Unknown Monster') {
            try {
                logger.debug(`[Loot] Looting dungeon monster ${dgmid} (instance ${instanceId}, ${monsterName})...`);
                
                const response = await http.lootGuildDungeon(dgmid, instanceId, userId);
                
                if (!response.success) {
                    return {
                        success: false,
                        exp: 0,
                        gold: 0,
                        items: [],
                        monsterName,
                        message: response.error || 'Failed to loot dungeon monster'
                    };
                }
                
                const data = response.data || {};
                const rewards = data.rewards || {};
                const exp = rewards.exp || 0;
                const gold = rewards.gold || 0;
                const damage = rewards.damage_dealt || 0;
                const items = data.items || [];
                
                logger.debug(`[Loot] Dungeon monster looted: ${monsterName} (+${exp} XP, +${gold} Gold, ${damage} DMG, ${items.length} items)`);
                
                return {
                    success: true,
                    exp,
                    gold,
                    damage,
                    items,
                    monsterName,
                    message: data.message || 'Looted successfully'
                };
            } catch (error) {
                logger.error(`[Loot] Error looting dungeon monster ${dgmid}: ${error.message}`);
                return {
                    success: false,
                    exp: 0,
                    gold: 0,
                    items: [],
                    monsterName: 'Unknown',
                    message: error.message
                };
            }
        }
        
        /**
         * Create new loot summary object
         * @returns {Object} Empty summary
         */
        function createSummary() {
            return {
                drops: 0,
                exp: 0,
                gold: 0,
                damage: 0,
                items: new Map(),
                monsters: new Map(),
                messages: []
            };
        }
        
        /**
         * Update summary with loot result
         * @param {Object} summary - Summary object to update
         * @param {Object} result - Loot result from lootWaveMonster/lootDungeonMonster
         */
        function updateSummary(summary, result) {
            if (!result.success) {
                summary.messages.push(result.message);
                return;
            }
            
            // Update totals
            summary.drops += 1;
            summary.exp += result.exp;
            summary.gold += result.gold;
            summary.damage += result.damage || 0;
            
            // Update monster stats
            const monsterKey = result.monsterName.toLowerCase();
            const existing = summary.monsters.get(monsterKey);
            
            if (existing) {
                existing.count += 1;
                existing.exp += result.exp;
                existing.gold += result.gold;
                existing.damage += result.damage || 0;
            } else {
                summary.monsters.set(monsterKey, {
                    name: result.monsterName,
                    exp: result.exp,
                    gold: result.gold,
                    damage: result.damage || 0,
                    count: 1
                });
            }
            
            // Update items (TIER field, not RARITY!)
            for (const item of result.items) {
                const itemName = item.NAME || item.name || 'Unknown Item';
                const itemRarity = (item.TIER || item.tier || item.RARITY || item.rarity || 'COMMON').toUpperCase();
                const itemQuantity = item.QUANTITY || item.quantity || 1;
                const itemDropRatio = item.DROP_RATIO || item.drop_ratio || null;
                const itemKey = `${itemName}|${itemRarity}`;
                
                const existingItem = summary.items.get(itemKey);
                if (existingItem) {
                    existingItem.quantity += itemQuantity;
                } else {
                    summary.items.set(itemKey, {
                        displayName: itemName,
                        rarity: itemRarity,
                        quantity: itemQuantity,
                        dropRatio: itemDropRatio
                    });
                }
            }
        }
        
        /**
         * Loot multiple monsters in parallel batches
         * @param {Array} targets - Array of target objects { monsterId/dgmid, type, name, instanceId? }
         * @param {string} userId - User ID
         * @param {Object} options - Options { batchSize: number, checkLevelUp: boolean, checkStamina: boolean }
         * @returns {Promise<Object>} Summary object
         */
        async function lootMultiple(targets, userId, options = {}) {
            const {
                batchSize = 10,
                checkLevelUp = true,
                checkStamina = true
            } = options;
            
            const summary = createSummary();
            
            // Store initial XP for level up detection
            if (checkLevelUp) {
                initialExpInfo = getPlayerExpInfo();
            }
            
            logger.info(`[Loot] Starting batch loot: ${targets.length} targets, batch size ${batchSize}`);
            
            // Process in batches
            for (let i = 0; i < targets.length; i += batchSize) {
                const batch = targets.slice(i, i + batchSize);
                
                // Check level up between batches
                if (checkLevelUp && i > 0 && initialExpInfo) {
                    const levelUpInfo = checkLevelUpInternal();
                    if (levelUpInfo.leveledUp) {
                        logger.info(`ðŸŽ‰ LEVEL UP detectado! Parando loot... (Batch ${Math.floor(i / batchSize) + 1})`);
                        summary.messages.push('âš ï¸ Loot stopped: Level up detected');
                        break;
                    }
                }
                
                // Check stamina full
                if (checkStamina) {
                    const staminaFull = checkStaminaFullInternal();
                    if (staminaFull) {
                        logger.info(`âš¡ Stamina recuperada! Parando loot... (Batch ${Math.floor(i / batchSize) + 1})`);
                        summary.messages.push('âš ï¸ Loot stopped: Stamina full recovered');
                        break;
                    }
                }
                
                logger.debug(`[Loot] Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(targets.length / batchSize)}...`);
                
                // Loot batch in parallel
                const promises = batch.map(target => {
                    if (target.type === 'dungeon') {
                        return lootDungeonMonster(target.dgmid, target.instanceId, userId, target.name);
                    } else {
                        return lootWaveMonster(target.monsterId, userId, target.name);
                    }
                });
                
                const results = await Promise.all(promises);
                
                // Update summary
                for (const result of results) {
                    updateSummary(summary, result);
                }
                
                // Small delay between batches
                if (i + batchSize < targets.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            logger.info(`[Loot] Batch loot complete: ${summary.drops}/${targets.length} looted, +${summary.exp} XP, +${summary.gold} Gold`);
            
            return summary;
        }
        
        /**
         * Get player XP info for level up detection
         * @returns {Object|null} { currentExp, maxExp, percent }
         */
        function getPlayerExpInfo() {
            try {
                // Strategy 1: Look for .gtb-exp-top (new UI)
                const gtbExpTop = document.querySelector('.gtb-exp-top');
                if (gtbExpTop) {
                    const text = gtbExpTop.textContent;
                    const match = text.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                    if (match) {
                        const currentExp = numbers.parse(match[1]);
                        const maxExp = numbers.parse(match[2]);
                        const percent = maxExp > 0 ? Math.round((currentExp / maxExp) * 100) : 0;
                        
                        logger.debug(`[Loot] XP parsed from .gtb-exp-top: ${currentExp} / ${maxExp}`);
                        return { currentExp, maxExp, percent };
                    }
                }
                
                // Strategy 2: Look for .gtb-exp or .exp-bar
                const expBar = document.querySelector('.gtb-exp, .exp-bar, [class*="exp"]');
                if (expBar) {
                    const text = expBar.textContent;
                    const match = text.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                    if (match) {
                        const currentExp = numbers.parse(match[1]);
                        const maxExp = numbers.parse(match[2]);
                        const percent = maxExp > 0 ? Math.round((currentExp / maxExp) * 100) : 0;
                        
                        logger.debug(`[Loot] XP parsed from exp bar: ${currentExp} / ${maxExp}`);
                        return { currentExp, maxExp, percent };
                    }
                }
                
                // Strategy 3: Fallback to searching all elements (original logic)
                const expElements = Array.from(document.querySelectorAll('*')).filter(el => {
                    const text = el.textContent;
                    return text && /\d+[\s,]*\/[\s,]*\d+/.test(text) && 
                           (text.toLowerCase().includes('exp') || text.toLowerCase().includes('xp'));
                });
                
                if (expElements.length > 0) {
                    const text = expElements[0].textContent;
                    const match = text.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                    if (match) {
                        const currentExp = numbers.parse(match[1]);
                        const maxExp = numbers.parse(match[2]);
                        const percent = maxExp > 0 ? Math.round((currentExp / maxExp) * 100) : 0;
                        
                        logger.debug(`[Loot] XP parsed from fallback: ${currentExp} / ${maxExp}`);
                        return { currentExp, maxExp, percent };
                    }
                }
                
                return null;
            } catch (error) {
                logger.warn(`[Loot] Failed to get player XP info: ${error.message}`);
                return null;
            }
        }
        
        /**
         * Check if player leveled up (internal)
         * @returns {Object} { leveledUp: boolean, oldExp, newExp }
         */
        function checkLevelUpInternal() {
            if (!initialExpInfo) {
                return { leveledUp: false };
            }
            
            const currentExpInfo = getPlayerExpInfo();
            if (!currentExpInfo) {
                return { leveledUp: false };
            }
            
            // Level up detection: current XP dropped OR max XP increased
            const leveledUp = currentExpInfo.currentExp < initialExpInfo.currentExp ||
                            currentExpInfo.maxExp > initialExpInfo.maxExp;
            
            return {
                leveledUp,
                oldExp: initialExpInfo,
                newExp: currentExpInfo
            };
        }
        
        /**
         * Check if stamina is full (internal)
         * @returns {boolean} True if stamina is at maximum
         */
        function checkStaminaFullInternal() {
            try {
                // Use context.stamina service (from Phase 1)
                if (!context.stamina || typeof context.stamina.read !== 'function') {
                    return false;
                }
                
                const staminaInfo = context.stamina.read();
                if (!staminaInfo) return false;
                
                return staminaInfo.current >= staminaInfo.max;
            } catch (error) {
                logger.warn(`[Loot] Failed to check stamina: ${error.message}`);
                return false;
            }
        }
        
        /**
         * Aggregate monsters by type with rate calculations
         * @param {Object} summary - Summary object
         * @returns {Array} Array of { name, count, exp, gold, damage, expRate, goldRate, damageRate }
         */
        function aggregateByType(summary) {
            const aggregated = [];
            
            for (const [key, monster] of summary.monsters) {
                aggregated.push({
                    name: monster.name,
                    count: monster.count,
                    exp: monster.exp,
                    gold: monster.gold,
                    damage: monster.damage || 0,
                    expRate: monster.count > 0 ? Math.round(monster.exp / monster.count) : 0,
                    goldRate: monster.count > 0 ? Math.round(monster.gold / monster.count) : 0,
                    damageRate: monster.count > 0 ? Math.round(monster.damage / monster.count) : 0
                });
            }
            
            // Sort by count descending
            aggregated.sort((a, b) => b.count - a.count);
            
            return aggregated;
        }
        
        /**
         * Show detailed loot modal with per-type statistics
         * @param {Object} summary - Summary object
         * @param {string} scope - Scope label (e.g., 'Wave Farming', 'Dungeon Clearing')
         */
        function showDetailedModal(summary, scope = 'Loot Session') {
            try {
                // Build monster statistics table
                const monsterStats = aggregateByType(summary);
                let monsterTable = '';
                
                if (monsterStats.length > 0) {
                    monsterTable = '<table style="width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 11px;">';
                    monsterTable += '<thead><tr style="background: #2a2a2a; border-bottom: 2px solid #444;">';
                    monsterTable += '<th style="padding: 5px; text-align: left;">Monster</th>';
                    monsterTable += '<th style="padding: 5px; text-align: center;">Qty</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">XP</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">XP/Mob</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">Gold</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">Gold/Mob</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">Damage</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">DMG/Mob</th>';
                    monsterTable += '</tr></thead><tbody>';
                    
                    for (const monster of monsterStats) {
                        monsterTable += '<tr style="border-bottom: 1px solid #333;">';
                        monsterTable += `<td style="padding: 6px; font-weight: bold;">${monster.name}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: center; color: #4a90e2;">${monster.count}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #50fa7b;">${numbers.format(monster.exp)}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #8be9fd;">${numbers.format(monster.expRate)}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #f1fa8c;">${numbers.format(monster.gold)}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #ffb86c;">${numbers.format(monster.goldRate)}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #ff79c6;">${numbers.format(monster.damage)}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #bd93f9;">${numbers.format(monster.damageRate)}</td>`;
                        monsterTable += '</tr>';
                    }
                    
                    monsterTable += '</tbody></table>';
                }
                
                // Build items list grouped by rarity
                let itemsList = '';
                
                if (summary.items.size > 0) {
                    // Group items by rarity
                    const itemsByRarity = {};
                    for (const rarity of RARITY_ORDER) {
                        itemsByRarity[rarity] = [];
                    }
                    
                    for (const [key, item] of summary.items) {
                        const rarity = item.rarity.toUpperCase();
                        if (itemsByRarity[rarity]) {
                            itemsByRarity[rarity].push(item);
                        } else {
                            itemsByRarity['COMMON'].push(item);
                        }
                    }
                    
                    // Build HTML for each rarity
                    for (const rarity of RARITY_ORDER) {
                        const items = itemsByRarity[rarity];
                        if (items.length === 0) continue;
                        
                        const config = RARITY_CONFIG[rarity] || RARITY_CONFIG.COMMON;
                        itemsList += `<div style="margin: 10px 0;">`;
                        itemsList += `<div style="font-weight: bold; color: ${config.color}; margin-bottom: 5px;">`;
                        itemsList += `${config.icon} [${config.label}]</div>`;
                        itemsList += '<ul style="margin: 0; padding-left: 20px;">';
                        
                        for (const item of items) {
                            const dropInfo = item.dropRatio !== null && item.dropRatio !== undefined 
                                ? ` <span style="color: #ffb86c; font-size: 10px;">(${item.dropRatio}%)</span>` 
                                : '';
                            itemsList += `<li style="margin: 3px 0;">${item.displayName} <span style="color: #888;">x${item.quantity}</span>${dropInfo}</li>`;
                        }
                        
                        itemsList += '</ul></div>';
                    }
                }
                
                // Build complete modal HTML
                const modalHTML = `
                    <div style="font-family: Arial, sans-serif; color: #fff;">
                        <h2 style="margin: 0 0 15px 0; padding: 0; font-size: 20px; border-bottom: 2px solid #444; padding-bottom: 10px;">
                            ðŸŽ ${scope} - Loot Summary
                        </h2>
                        
                        ${monsterStats.length > 0 ? `
                            <div style="margin: 15px 0;">
                                <h3 style="font-size: 16px; margin: 0 0 10px 0;">Monstros Loteados por Tipo:</h3>
                                ${monsterTable}
                            </div>
                        ` : ''}
                        
                        <div style="background: #1a1a1a; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <h3 style="font-size: 16px; margin: 0 0 10px 0;">TOTAIS:</h3>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
                                <div>
                                    <div style="color: #888; font-size: 11px;">Loots</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #4a90e2;">${summary.drops}</div>
                                </div>
                                <div>
                                    <div style="color: #888; font-size: 11px;">EXP</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #50fa7b;">${numbers.format(summary.exp)}</div>
                                </div>
                                <div>
                                    <div style="color: #888; font-size: 11px;">Gold</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #f1fa8c;">${numbers.format(summary.gold)}</div>
                                </div>
                                <div>
                                    <div style="color: #888; font-size: 11px;">Damage</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #ff79c6;">${numbers.format(summary.damage)}</div>
                                </div>
                            </div>
                            ${summary.damage > 0 ? `
                            <div style="margin-top: 10px; padding: 8px; background: #2a2a2a; border-radius: 4px; font-size: 11px; color: #888; text-align: center;">
                                ðŸ“Š EficiÃªncia: <span style="color: #8be9fd;">${(summary.exp / summary.damage).toFixed(3)} XP/HP</span> | <span style="color: #ffb86c;">${(summary.gold / summary.damage).toFixed(5)} Gold/HP</span>
                            </div>
                            ` : ''}
                        </div>
                        
                        ${itemsList ? `
                            <div style="margin: 15px 0;">
                                <h3 style="font-size: 16px; margin: 0 0 10px 0; padding-top: 10px; border-top: 1px solid #444;">ITENS OBTIDOS:</h3>
                                ${itemsList}
                            </div>
                        ` : '<div style="color: #888; font-style: italic; margin: 15px 0;">Nenhum item obtido.</div>'}
                        
                        ${summary.messages.length > 0 ? `
                            <div style="margin: 15px 0; padding: 10px; background: #2a2a2a; border-radius: 5px; border-left: 3px solid #FFD700;">
                                ${summary.messages.map(msg => `<div style="margin: 3px 0;">âš ï¸ ${msg}</div>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
                
                // Show modal using floating helpers module
                const floatingHelpers = context.moduleRegistry?.getModule('floatingHelpers');
                if (floatingHelpers && typeof floatingHelpers.openQuickLootModal === 'function') {
                    // Pass summary directly - openQuickLootModal expects Map objects
                    floatingHelpers.openQuickLootModal(context, summary, scope);
                } else {
                    // Fallback: use notification
                    notifications.success(`Loot complete: ${summary.drops} monsters, +${numbers.format(summary.exp)} XP, +${numbers.format(summary.gold)} Gold`, 8000);
                }
                
            } catch (error) {
                logger.error(`[Loot] Failed to show detailed modal: ${error.message}`);
                // Fallback notification
                notifications.success(
                    `Loot: ${summary.drops} monsters, +${numbers.format(summary.exp)} XP, +${numbers.format(summary.gold)} Gold`,
                    5000
                );
            }
        }
        
        // ========== OPTIMIZED LOOT METHODS (Cloudflare-proof) ==========
        
        /**
         * Loot wave monster using optimized fetch (Cloudflare-proof)
         * Same API as lootWaveMonster but uses fetchDirect internally
         * @param {string} monsterId - Monster ID
         * @param {string} userId - User ID
         * @param {string} monsterName - Monster name (optional)
         * @returns {Promise<Object>} Loot result
         */
        async function lootWaveMonsterDirect(monsterId, userId, monsterName = 'Unknown Monster') {
            try {
                logger.debug(`[Loot:Direct] Looting wave monster ${monsterId} (${monsterName})...`);
                
                const referrer = `https://demonicscans.org/battle.php?id=${monsterId}`;
                const response = await http.lootMonsterDirect(monsterId, userId, referrer);
                
                if (!response.success) {
                    return {
                        success: false,
                        exp: 0,
                        gold: 0,
                        items: [],
                        monsterName,
                        message: response.message || 'Failed to loot'
                    };
                }
                
                const data = response.data || {};
                const rewards = data.rewards || {};
                const exp = rewards.exp || 0;
                const gold = rewards.gold || 0;
                const damage = rewards.damage_dealt || 0;
                const items = data.items || [];
                
                logger.debug(`[Loot:Direct] Looted: ${monsterName} (+${exp} XP, +${gold} Gold, ${damage} DMG, ${items.length} items)`);
                
                return {
                    success: true,
                    exp,
                    gold,
                    damage,
                    items,
                    monsterName,
                    message: data.message || 'Looted successfully'
                };
            } catch (error) {
                logger.error(`[Loot:Direct] Error: ${error.message}`);
                return {
                    success: false,
                    exp: 0,
                    gold: 0,
                    items: [],
                    monsterName,
                    message: error.message
                };
            }
        }
        
        /**
         * Loot dungeon monster using optimized fetch (Cloudflare-proof)
         * TODO: Verify body format when example is available
         * @param {string} dgmid - Dungeon monster ID
         * @param {string} instanceId - Instance ID
         * @param {string} userId - User ID
         * @param {string} monsterName - Monster name (optional)
         * @returns {Promise<Object>} Loot result
         */
        async function lootDungeonMonsterDirect(dgmid, instanceId, userId, monsterName = 'Unknown Monster') {
            try {
                logger.debug(`[Loot:Direct] Looting dungeon monster ${dgmid} (instance ${instanceId}, ${monsterName})...`);
                
                const referrer = `https://demonicscans.org/guild_dungeon_location.php?instance_id=${instanceId}`;
                const response = await http.lootDungeonMonsterDirect(dgmid, instanceId, userId, referrer);
                
                if (!response.success) {
                    return {
                        success: false,
                        exp: 0,
                        gold: 0,
                        items: [],
                        monsterName,
                        message: response.message || 'Failed to loot dungeon'
                    };
                }
                
                const data = response.data || {};
                const rewards = data.rewards || {};
                const exp = rewards.exp || 0;
                const gold = rewards.gold || 0;
                const damage = rewards.damage_dealt || 0;
                const items = data.items || [];
                
                logger.debug(`[Loot:Direct] Dungeon looted: ${monsterName} (+${exp} XP, +${gold} Gold, ${damage} DMG, ${items.length} items)`);
                
                return {
                    success: true,
                    exp,
                    gold,
                    damage,
                    items,
                    monsterName,
                    message: data.message || 'Looted successfully'
                };
            } catch (error) {
                logger.error(`[Loot:Direct] Error: ${error.message}`);
                return {
                    success: false,
                    exp: 0,
                    gold: 0,
                    items: [],
                    monsterName,
                    message: error.message
                };
            }
        }
        
        return {
            lootWaveMonster,
            lootDungeonMonster,
            lootMultiple,
            createSummary,
            updateSummary,
            aggregateByType,
            showDetailedModal,
            
            // Optimized methods (Cloudflare-proof)
            lootWaveMonsterDirect,
            lootDungeonMonsterDirect,
            
            // Public wrappers for checks
            checkLevelUp() {
                initialExpInfo = getPlayerExpInfo();
                return checkLevelUpInternal();
            },
            
            checkStaminaFull() {
                return checkStaminaFullInternal();
            },
            
            // Utility: reset initial XP (call before starting new loot session)
            resetLevelUpCheck() {
                initialExpInfo = getPlayerExpInfo();
                logger.debug('[Loot] Level up check reset');
            }
        };
    }

    // ==================== DATA EXTRACTOR SERVICE ====================
    // Centralized data extraction from stats/pets/inventory pages
    // Provides unified API for reading player data
    
    /**
     * Create data extractor service
     * Extracts player stats, pets, and equipment from DOM
     * 
     * @param {Object} context - Script context
     * @returns {Object} Data extractor service
     * 
     * @example
     * const extractor = context.dataExtractor;
     * 
     * // Extract all data
     * const data = await extractor.extractAll();
     * // { stats: {...}, pets: {...}, equipment: {...} }
     * 
     * // Extract specific data
     * const stats = await extractor.extractStats();
     * const pets = await extractor.extractPets();
     * const equipment = await extractor.extractEquipment();
     */
    function createDataExtractorService(context) {
        const { logger, http, storage } = context;
        const CACHE_TTL_MS = 3600000; // 1 hour
        
        // Cache keys
        const CACHE_KEYS = {
            stats: 'dataExtractor.stats',
            pets: 'dataExtractor.pets',
            equipment: 'dataExtractor.equipment'
        };
        
        /**
         * Check if cached data is still valid
         */
        function isCacheValid(key) {
            const cached = storage.get(key);
            if (!cached || !cached.timestamp) return false;
            return (Date.now() - cached.timestamp) < CACHE_TTL_MS;
        }
        
        /**
         * Extract base stats from stats.php
         * @returns {Promise<Object>} { base_attack, base_defense, max_stamina, current_stamina, level }
         */
        async function extractStats() {
            logger.debug('ðŸ” Extracting player stats...');
            
            // Check cache first
            if (isCacheValid(CACHE_KEYS.stats)) {
                const cached = storage.get(CACHE_KEYS.stats);
                logger.debug('âœ… Using cached stats data');
                return cached.data;
            }
            
            try {
                // Fetch stats page HTML
                const response = await fetch('https://demonicscans.org/stats.php', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Extract base stats from stat cards
                const stats = {
                    base_attack: 0,
                    base_defense: 0,
                    max_stamina: 0,
                    current_stamina: 0,
                    level: 0,
                    unspent_points: 0
                };
                
                // Strategy 1: Find stat values in "Current Stats" section using regex
                const bodyText = doc.body.textContent;
                
                // Extract from "Current Stats" section - values appear directly after labels (no space)
                // Pattern: "ATTACK1110" or "ATTACK 1110" or "ATTACK\n1110"
                const attackMatch = bodyText.match(/ATTACK\s*(\d[\d,]*)/);
                const defenseMatch = bodyText.match(/DEFENSE\s*(\d[\d,]*)/);
                const staminaMatch = bodyText.match(/MAX STAMINA\s*(\d[\d,]*)/);
                
                if (attackMatch) {
                    stats.base_attack = parseInt(attackMatch[1].replace(/,/g, '')) || 0;
                }
                if (defenseMatch) {
                    stats.base_defense = parseInt(defenseMatch[1].replace(/,/g, '')) || 0;
                }
                if (staminaMatch) {
                    stats.max_stamina = parseInt(staminaMatch[1].replace(/,/g, '')) || 0;
                }
                
                // Strategy 2: If regex fails, use DOM traversal
                if (stats.base_attack === 0) {
                    const allElements = Array.from(doc.querySelectorAll('*'));
                    
                    // Find "Current Stats" section
                    const currentStatsHeading = allElements.find(el => 
                        el.textContent.includes('ðŸ“ˆ Current Stats') || 
                        el.textContent.includes('Current Stats')
                    );
                    
                    if (currentStatsHeading) {
                        const statsSection = currentStatsHeading.closest('div') || currentStatsHeading.parentElement;
                        if (statsSection) {
                            // Extract ATTACK
                            const attackLabel = Array.from(statsSection.querySelectorAll('*')).find(el => 
                                el.textContent.trim() === 'ATTACK'
                            );
                            if (attackLabel && attackLabel.nextElementSibling) {
                                const value = attackLabel.nextElementSibling.textContent.trim().replace(/['"]/g, '');
                                stats.base_attack = parseInt(value.replace(/,/g, '')) || 0;
                            }
                            
                            // Extract DEFENSE
                            const defenseLabel = Array.from(statsSection.querySelectorAll('*')).find(el => 
                                el.textContent.trim() === 'DEFENSE'
                            );
                            if (defenseLabel && defenseLabel.nextElementSibling) {
                                const value = defenseLabel.nextElementSibling.textContent.trim().replace(/['"]/g, '');
                                stats.base_defense = parseInt(value.replace(/,/g, '')) || 0;
                            }
                            
                            // Extract MAX STAMINA
                            const staminaLabel = Array.from(statsSection.querySelectorAll('*')).find(el => 
                                el.textContent.trim() === 'MAX STAMINA'
                            );
                            if (staminaLabel && staminaLabel.nextElementSibling) {
                                const value = staminaLabel.nextElementSibling.textContent.trim().replace(/['"]/g, '');
                                stats.max_stamina = parseInt(value.replace(/,/g, '')) || 0;
                            }
                        }
                    }
                }
                
                // Extract current stamina from top bar
                const staminaText = bodyText.match(/ðŸ’ª\s*(\d[\d,]*)\s*\/\s*(\d[\d,]*)/);
                if (staminaText) {
                    stats.current_stamina = parseInt(staminaText[1].replace(/,/g, '')) || 0;
                    // Also update max_stamina from top bar if not found
                    if (stats.max_stamina === 0) {
                        stats.max_stamina = parseInt(staminaText[2].replace(/,/g, '')) || 0;
                    }
                }
                
                // Extract level
                const levelText = bodyText.match(/LV\s*(\d+)/i);
                if (levelText) {
                    stats.level = parseInt(levelText[1]) || 0;
                }
                
                // Extract unspent points
                const unspentText = bodyText.match(/Unspent Points[\s\S]*?(\d+)/i);
                if (unspentText) {
                    stats.unspent_points = parseInt(unspentText[1]) || 0;
                }
                
                logger.info(`ðŸ“Š Extracted stats: ATK ${stats.base_attack}, DEF ${stats.base_defense}, STAM ${stats.max_stamina}`);
                
                // Cache result
                storage.set(CACHE_KEYS.stats, {
                    data: stats,
                    timestamp: Date.now()
                });
                
                return stats;
            } catch (error) {
                logger.error('âŒ Failed to extract stats', { error });
                return {
                    base_attack: 0,
                    base_defense: 0,
                    max_stamina: 0,
                    current_stamina: 0,
                    level: 0,
                    unspent_points: 0
                };
            }
        }
        
        /**
         * Parse effect text to extract all bonus types
         * @param {string} effectText - Raw effect text from pet card
         * @returns {Object} Parsed effects with numeric values
         */
        function parseEffects(effectText) {
            const effects = {
                // PvM Effects
                extra_damage_monsters: 0,      // % extra damage to monsters
                armor_penetration: 0,          // % armor penetration
                heal_on_damage: 0,             // % heal on damage received
                
                // Universal Effects
                stamina_save: 0,               // % chance to not consume stamina/tokens
                crit_rate: 0,                  // % critical rate increase
                crit_damage: 0,                // % critical damage increase
                stamina_cost_mult: 1.0,        // Multiplier for stamina cost (default 1.0)
                
                // PvP Effects
                atk_def_swap: 0,               // % ATK/DEF swap
                steal_stat: 0,                 // % steal opponent stat
                team_conversion: 0,            // % conversion between teams
                def_boost: 0,                  // % DEF boost (defender)
                
                // Metadata
                is_pve_only: false,
                is_pvp_only: false,
                is_universal: false
            };
            
            if (!effectText) return effects;
            
            const lower = effectText.toLowerCase();
            
            // Detect scope
            if (lower.includes('pve only') || lower.includes('pvm only')) {
                effects.is_pve_only = true;
            } else if (lower.includes('pvp only')) {
                effects.is_pvp_only = true;
            } else {
                effects.is_universal = true;
            }
            
            // Parse PvM effects
            const extraDmgMatch = effectText.match(/(\d+(?:\.\d+)?)\s*%\s*(?:Extra Damage To Monsters|extra damage to monsters)/i);
            if (extraDmgMatch) effects.extra_damage_monsters = parseFloat(extraDmgMatch[1]);
            
            const armorPenMatch = effectText.match(/Armor Penetration\s+by\s+(\d+(?:\.\d+)?)\s*%/i);
            if (armorPenMatch) effects.armor_penetration = parseFloat(armorPenMatch[1]);
            
            const healMatch = effectText.match(/Heals?\s+You\s+by\s+(\d+(?:\.\d+)?)\s*%/i);
            if (healMatch) effects.heal_on_damage = parseFloat(healMatch[1]);
            
            // Parse universal effects
            const staminaSaveMatch = effectText.match(/(\d+(?:\.\d+)?)\s*%\s*Your\s+attacks\s+won'?t\s+consume/i);
            if (staminaSaveMatch) effects.stamina_save = parseFloat(staminaSaveMatch[1]);
            
            const critRateMatch = effectText.match(/Critical\s+Rate\s+By\s+(\d+(?:\.\d+)?)\s*%/i);
            if (critRateMatch) effects.crit_rate = parseFloat(critRateMatch[1]);
            
            const critDmgMatch = effectText.match(/Critical\s+Damage\s+By\s+(\d+(?:\.\d+)?)\s*%/i);
            if (critDmgMatch) effects.crit_damage = parseFloat(critDmgMatch[1]);
            
            const staminaCostMatch = effectText.match(/stamina\s+cost\s+by\s+x(\d+(?:\.\d+)?)/i);
            if (staminaCostMatch) effects.stamina_cost_mult = parseFloat(staminaCostMatch[1]);
            
            // Parse PvP effects
            const swapMatch = effectText.match(/swap\s+(\d+(?:\.\d+)?)\s*%/i);
            if (swapMatch) effects.atk_def_swap = parseFloat(swapMatch[1]);
            
            const stealMatch = effectText.match(/steal\s+(\d+(?:\.\d+)?)\s*%/i);
            if (stealMatch) effects.steal_stat = parseFloat(stealMatch[1]);
            
            const conversionMatch = effectText.match(/increase.*?by\s+(\d+(?:\.\d+)?)\s*%\s+of/i);
            if (conversionMatch) effects.team_conversion = parseFloat(conversionMatch[1]);
            
            const defBoostMatch = effectText.match(/\+\s*(\d+(?:\.\d+)?)\s*%\s*DEF/i);
            if (defBoostMatch) effects.def_boost = parseFloat(defBoostMatch[1]);
            
            return effects;
        }
        
        /**
         * Extract pets from pets.php
         * @returns {Promise<Object>} { equipped_attack_team, total_attack_pets_atk, total_attack_pets_def, available_pets }
         */
        async function extractPets() {
            logger.debug('ðŸ” Extracting pets data...');
            
            // Check cache first
            if (isCacheValid(CACHE_KEYS.pets)) {
                const cached = storage.get(CACHE_KEYS.pets);
                logger.debug('âœ… Using cached pets data');
                return cached.data;
            }
            
            try {
                // Fetch pets page HTML
                const response = await fetch('https://demonicscans.org/pets.php', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                const pets = {
                    equipped_attack_team: [],
                    total_attack_pets_atk: 0,
                    total_attack_pets_def: 0,
                    pvm_damage_bonus_percent: 0,  // Total PvM damage bonus from pets
                    available_pets: []
                };
                
                // Extract pet names from DOM (img alt attributes)
                const allPetImages = Array.from(doc.querySelectorAll('img[alt]')).filter(img => {
                    const text = img.parentElement?.parentElement?.textContent || '';
                    return text.includes('Lv.') && text.includes('ATK');
                });
                
                const bodyText = doc.body.textContent;
                
                // Find equipped pets section
                const equippedMatch = bodyText.match(/âš”ï¸ Equipped Pets â€” Attack Team([\s\S]*?)(?:ðŸ¾ Pet Inventory|$)/);
                
                if (equippedMatch) {
                    const equippedSection = equippedMatch[1];
                    
                    // Split by pet cards (using stars as delimiter)
                    const petBlocks = equippedSection.split(/â˜…+/);
                    let petIndex = 0;
                    
                    for (const block of petBlocks) {
                        if (!block.trim()) continue;
                        
                        // Extract name from DOM img alt
                        let name = 'Unknown Pet';
                        if (petIndex < allPetImages.length) {
                            name = allPetImages[petIndex].alt;
                            petIndex++;
                        }
                        
                        // Extract stats: "ðŸ§ª Lv. 80 | ðŸ”ª 703 ATK | ðŸ›¡ï¸ 703 DEF"
                        const statsMatch = block.match(/ðŸ§ª\s*Lv\.\s*(\d+)\s*\|\s*ðŸ”ª\s*(\d+)\s*ATK\s*\|\s*ðŸ›¡ï¸\s*(\d+)\s*DEF/);
                        if (!statsMatch) continue;
                        
                        const level = parseInt(statsMatch[1]) || 0;
                        const attack = parseInt(statsMatch[2]) || 0;
                        const defense = parseInt(statsMatch[3]) || 0;
                        
                        // Extract effects: "âš¡ 24.8% Extra Damage To Monsters"
                        const effectsMatch = block.match(/âš¡\s*([^\n]+)/);
                        const effectText = effectsMatch ? effectsMatch[1].trim() : '';
                        
                        // Parse all effect types using comprehensive patterns
                        const effects = parseEffects(effectText);
                        
                        // Accumulate PvM damage bonus
                        if (effects.extra_damage_monsters > 0) {
                            pets.pvm_damage_bonus_percent += effects.extra_damage_monsters;
                        }
                        
                        pets.equipped_attack_team.push({
                            name,
                            level,
                            attack,
                            defense,
                            effect: effectText,
                            parsed_effects: effects
                        });
                        
                        pets.total_attack_pets_atk += attack;
                        pets.total_attack_pets_def += defense;
                    }
                }
                
                // Parse ALL available pets (including inventory)
                const inventoryMatch = bodyText.match(/ðŸ¾ Pet Inventory([\s\S]*?)(?:ðŸ¥š Eggs|$)/);
                
                if (inventoryMatch) {
                    const inventorySection = inventoryMatch[1];
                    const petBlocks = inventorySection.split(/â˜…+/);
                    
                    // Continue from where equipped pets ended
                    let petIndex = pets.equipped_attack_team.length;
                    
                    for (const block of petBlocks) {
                        if (!block.trim()) continue;
                        
                        // Extract name from DOM img alt (skip already used equipped pets)
                        let name = 'Unknown Pet';
                        if (petIndex < allPetImages.length) {
                            name = allPetImages[petIndex].alt;
                            petIndex++;
                        }
                        
                        const statsMatch = block.match(/ðŸ§ª\s*Lv\.\s*(\d+)\s*\|\s*ðŸ”ª\s*(\d+)\s*ATK\s*\|\s*ðŸ›¡ï¸\s*(\d+)\s*DEF/);
                        if (!statsMatch) continue;
                        
                        const level = parseInt(statsMatch[1]) || 0;
                        const attack = parseInt(statsMatch[2]) || 0;
                        const defense = parseInt(statsMatch[3]) || 0;
                        
                        const effectsMatch = block.match(/âš¡\s*([^\n]+)/);
                        const effectText = effectsMatch ? effectsMatch[1].trim() : '';
                        const effects = parseEffects(effectText);
                        
                        // Only add if not already in equipped list
                        const alreadyEquipped = pets.equipped_attack_team.some(p => p.name === name && p.level === level);
                        if (!alreadyEquipped) {
                            pets.available_pets.push({
                                name,
                                level,
                                attack,
                                defense,
                                effect: effectText,
                                parsed_effects: effects
                            });
                        }
                    }
                }
                
                logger.info(`ðŸ¾ Extracted pets: ${pets.equipped_attack_team.length} equipped, ${pets.available_pets.length} available (ATK ${pets.total_attack_pets_atk}, DEF ${pets.total_attack_pets_def})`);
                
                // Cache result
                storage.set(CACHE_KEYS.pets, {
                    data: pets,
                    timestamp: Date.now()
                });
                
                return pets;
            } catch (error) {
                logger.error('âŒ Failed to extract pets', { error });
                return {
                    equipped_attack_team: [],
                    total_attack_pets_atk: 0,
                    total_attack_pets_def: 0,
                    available_pets: []
                };
            }
        }
        
        /**
         * Extract equipment from inventory.php
         * @returns {Promise<Object>} { equipped_attack_set, total_equipped_atk, total_equipped_def }
         */
        async function extractEquipment() {
            logger.debug('ðŸ” Extracting equipment data...');
            
            // Check cache first
            if (isCacheValid(CACHE_KEYS.equipment)) {
                const cached = storage.get(CACHE_KEYS.equipment);
                logger.debug('âœ… Using cached equipment data');
                return cached.data;
            }
            
            try {
                // Fetch inventory page HTML
                const response = await fetch('https://demonicscans.org/inventory.php', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Get manual bonuses from config (auto-extraction not possible)
                const manualBonuses = context.config.get('equipmentBonuses');
                
                // Use defaults if config doesn't exist yet
                const defaultBonuses = {
                    extra_damage_monsters: 28,
                    armor_penetration: 0,
                    crit_rate: 0,
                    crit_damage: 0,
                    stamina_save: 0,
                    heal_on_damage: 0
                };
                
                const bonuses = manualBonuses || defaultBonuses;
                
                logger.debug(`ðŸ“¦ Equipment bonuses from config: Extra DMG ${bonuses.extra_damage_monsters}%`);
                
                const equipment = {
                    equipped_attack_set: {},
                    total_equipped_atk: 0,
                    total_equipped_def: 0,
                    equipment_effects: {
                        extra_damage_monsters: bonuses.extra_damage_monsters ?? defaultBonuses.extra_damage_monsters,
                        armor_penetration: bonuses.armor_penetration ?? defaultBonuses.armor_penetration,
                        crit_rate: bonuses.crit_rate ?? defaultBonuses.crit_rate,
                        crit_damage: bonuses.crit_damage ?? defaultBonuses.crit_damage,
                        stamina_save: bonuses.stamina_save ?? defaultBonuses.stamina_save,
                        heal_on_damage: bonuses.heal_on_damage ?? defaultBonuses.heal_on_damage
                    }
                };
                
                // Find equipped items section
                const bodyText = doc.body.textContent;
                const equippedMatch = bodyText.match(/ðŸ›¡ï¸ Equipped Items â€” Attack Set([\s\S]*?)(?:âš”ï¸ Equipment|$)/);
                
                if (equippedMatch) {
                    const equippedSection = equippedMatch[1];
                    
                    // Parse stats: "ðŸ”ª 180 ATK Â· ðŸ›¡ï¸ 0 DEF"
                    const statsRegex = /ðŸ”ª\s*(\d+)\s*ATK\s*Â·\s*ðŸ›¡ï¸\s*(\d+)\s*DEF/gi;
                    const matches = [...equippedSection.matchAll(statsRegex)];
                    
                    for (const match of matches) {
                        const attack = parseInt(match[1]) || 0;
                        const defense = parseInt(match[2]) || 0;
                        
                        equipment.total_equipped_atk += attack;
                        equipment.total_equipped_def += defense;
                    }
                }
                
                // Note: Equipment bonuses are configured manually in config.equipmentBonuses
                // Auto-extraction not available because bonuses are in dynamic modals (Info buttons)
                
                const equipEffects = equipment.equipment_effects;
                const totalBonus = equipEffects.extra_damage_monsters + equipEffects.armor_penetration + equipEffects.crit_rate + equipEffects.crit_damage;
                logger.info(`âš”ï¸ Extracted equipment: ATK ${equipment.total_equipped_atk}, DEF ${equipment.total_equipped_def}, Bonuses ${totalBonus.toFixed(1)}%`);
                
                // Cache result
                storage.set(CACHE_KEYS.equipment, {
                    data: equipment,
                    timestamp: Date.now()
                });
                
                return equipment;
            } catch (error) {
                logger.error('âŒ Failed to extract equipment', { error });
                return {
                    equipped_attack_set: {},
                    total_equipped_atk: 0,
                    total_equipped_def: 0
                };
            }
        }
        
        /**
         * Extract all data (stats + pets + equipment)
         * @returns {Promise<Object>} { stats, pets, equipment }
         */
        async function extractAll() {
            logger.info('ðŸ”„ Extracting all player data...');
            
            const [stats, pets, equipment] = await Promise.all([
                extractStats(),
                extractPets(),
                extractEquipment()
            ]);
            
            // Create combined list of all pets for build analysis
            const allAvailablePets = [
                ...(pets.equipped_attack_team || []),
                ...(pets.available_pets || [])
            ];
            
            return { 
                stats, 
                pets, 
                equipment,
                allAvailablePets
            };
        }
        
        /**
         * Clear all cached data
         */
        function clearCache() {
            storage.remove(CACHE_KEYS.stats);
            storage.remove(CACHE_KEYS.pets);
            storage.remove(CACHE_KEYS.equipment);
            logger.debug('ðŸ—‘ï¸ Data extractor cache cleared');
        }
        
        /**
         * Force refresh all data (clears cache and re-extracts)
         * @returns {Promise<Object>} Fresh data
         */
        async function forceRefresh() {
            logger.info('ðŸ”„ Force refreshing all player data...');
            clearCache();
            return await extractAll();
        }
        
        /**
         * Analyze pet impact for different combat scenarios
         * @param {Array} pets - Array of equipped pets with parsed_effects
         * @returns {Object} Impact analysis with scores and recommendations
         */
        function analyzePetImpact(pets) {
            const analysis = {
                pvm: {
                    total_score: 0,
                    contributors: [],
                    damage_multiplier: 1.0,  // Final damage multiplier
                    breakdown: {}
                },
                pvp_attacker: {
                    total_score: 0,
                    contributors: [],
                    breakdown: {}
                },
                pvp_defender: {
                    total_score: 0,
                    contributors: [],
                    breakdown: {}
                },
                universal: {
                    total_score: 0,
                    contributors: [],
                    breakdown: {}
                }
            };
            
            if (!pets || pets.length === 0) return analysis;
            
            for (const pet of pets) {
                const effects = pet.parsed_effects;
                if (!effects) continue;
                
                // PvM Scoring
                if (effects.is_pve_only || effects.is_universal) {
                    let pvmScore = 0;
                    const breakdown = [];
                    
                    if (effects.extra_damage_monsters > 0) {
                        const score = effects.extra_damage_monsters * 3.0;
                        pvmScore += score;
                        breakdown.push(`${effects.extra_damage_monsters}% Extra Damage (Ã—3.0) = ${score.toFixed(1)}`);
                        analysis.pvm.damage_multiplier += (effects.extra_damage_monsters / 100);
                    }
                    
                    if (effects.armor_penetration > 0) {
                        const score = effects.armor_penetration * 2.0;
                        pvmScore += score;
                        breakdown.push(`${effects.armor_penetration}% Armor Pen (Ã—2.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.heal_on_damage > 0) {
                        const score = effects.heal_on_damage * 1.0;
                        pvmScore += score;
                        breakdown.push(`${effects.heal_on_damage}% Heal (Ã—1.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.crit_rate > 0) {
                        const score = effects.crit_rate * 1.5;
                        pvmScore += score;
                        breakdown.push(`${effects.crit_rate}% Crit Rate (Ã—1.5) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.crit_damage > 0) {
                        const score = effects.crit_damage * 1.2;
                        pvmScore += score;
                        breakdown.push(`${effects.crit_damage}% Crit Damage (Ã—1.2) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.stamina_save > 0) {
                        const score = effects.stamina_save * 1.0;
                        pvmScore += score;
                        breakdown.push(`${effects.stamina_save}% Stamina Save (Ã—1.0) = ${score.toFixed(1)}`);
                    }
                    
                    // Penalty for increased stamina cost
                    if (effects.stamina_cost_mult > 1.0) {
                        const penalty = (effects.stamina_cost_mult - 1.0) * 50;
                        pvmScore -= penalty;
                        breakdown.push(`Ã—${effects.stamina_cost_mult} Stamina Cost (penalty) = -${penalty.toFixed(1)}`);
                    }
                    
                    if (pvmScore > 0) {
                        analysis.pvm.total_score += pvmScore;
                        analysis.pvm.contributors.push({
                            pet: pet.name,
                            score: pvmScore,
                            breakdown: breakdown.join(' | ')
                        });
                    }
                }
                
                // PvP Attacker Scoring
                if (effects.is_pvp_only || effects.is_universal) {
                    let atkScore = 0;
                    const breakdown = [];
                    
                    if (effects.steal_stat > 0) {
                        const score = effects.steal_stat * 3.0;
                        atkScore += score;
                        breakdown.push(`${effects.steal_stat}% Steal ATK (Ã—3.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.team_conversion > 0) {
                        const score = effects.team_conversion * 2.5;
                        atkScore += score;
                        breakdown.push(`${effects.team_conversion}% Team Conversion (Ã—2.5) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.atk_def_swap > 0) {
                        const score = effects.atk_def_swap * 2.0;
                        atkScore += score;
                        breakdown.push(`${effects.atk_def_swap}% ATK/DEF Swap (Ã—2.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.crit_rate > 0) {
                        const score = effects.crit_rate * 1.5;
                        atkScore += score;
                        breakdown.push(`${effects.crit_rate}% Crit Rate (Ã—1.5) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.crit_damage > 0) {
                        const score = effects.crit_damage * 1.2;
                        atkScore += score;
                        breakdown.push(`${effects.crit_damage}% Crit Damage (Ã—1.2) = ${score.toFixed(1)}`);
                    }
                    
                    if (atkScore > 0) {
                        analysis.pvp_attacker.total_score += atkScore;
                        analysis.pvp_attacker.contributors.push({
                            pet: pet.name,
                            score: atkScore,
                            breakdown: breakdown.join(' | ')
                        });
                    }
                }
                
                // PvP Defender Scoring
                if (effects.is_pvp_only || effects.is_universal) {
                    let defScore = 0;
                    const breakdown = [];
                    
                    if (effects.steal_stat > 0) {
                        const score = effects.steal_stat * 3.0;
                        defScore += score;
                        breakdown.push(`${effects.steal_stat}% Steal DEF (Ã—3.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.team_conversion > 0) {
                        const score = effects.team_conversion * 2.5;
                        defScore += score;
                        breakdown.push(`${effects.team_conversion}% Team Conversion (Ã—2.5) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.def_boost > 0) {
                        const score = effects.def_boost * 2.0;
                        defScore += score;
                        breakdown.push(`${effects.def_boost}% DEF Boost (Ã—2.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.atk_def_swap > 0) {
                        const score = effects.atk_def_swap * 2.0;
                        defScore += score;
                        breakdown.push(`${effects.atk_def_swap}% ATK/DEF Swap (Ã—2.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (defScore > 0) {
                        analysis.pvp_defender.total_score += defScore;
                        analysis.pvp_defender.contributors.push({
                            pet: pet.name,
                            score: defScore,
                            breakdown: breakdown.join(' | ')
                        });
                    }
                }
                
                // Universal effects (apply to all scenarios)
                if (effects.stamina_save > 0 || effects.crit_rate > 0 || effects.crit_damage > 0) {
                    let uniScore = 0;
                    const breakdown = [];
                    
                    if (effects.stamina_save > 0) {
                        uniScore += effects.stamina_save * 1.0;
                        breakdown.push(`${effects.stamina_save}% Stamina Save`);
                    }
                    if (effects.crit_rate > 0) {
                        uniScore += effects.crit_rate * 1.5;
                        breakdown.push(`${effects.crit_rate}% Crit Rate`);
                    }
                    if (effects.crit_damage > 0) {
                        uniScore += effects.crit_damage * 1.2;
                        breakdown.push(`${effects.crit_damage}% Crit Damage`);
                    }
                    
                    if (uniScore > 0) {
                        analysis.universal.total_score += uniScore;
                        analysis.universal.contributors.push({
                            pet: pet.name,
                            score: uniScore,
                            breakdown: breakdown.join(' | ')
                        });
                    }
                }
            }
            
            // Sort contributors by score (descending)
            analysis.pvm.contributors.sort((a, b) => b.score - a.score);
            analysis.pvp_attacker.contributors.sort((a, b) => b.score - a.score);
            analysis.pvp_defender.contributors.sort((a, b) => b.score - a.score);
            analysis.universal.contributors.sort((a, b) => b.score - a.score);
            
            return analysis;
        }
        
        /**
         * Analyze all possible pet combinations to find optimal builds
         * @param {Object} data - Player data with stats, all pets, equipment
         * @param {number} monsterDefense - Target monster defense for PvM calculations
         * @returns {Object} Build recommendations for each scenario
         */
        function analyzeOptimalBuilds(data, monsterDefense = 0) {
            const { stats, equipment } = data;
            const allPets = data.allAvailablePets || [];
            
            if (!stats || !allPets || allPets.length === 0) {
                return {
                    pvm: { builds: [], note: 'No pets available' },
                    pvp_attacker: { builds: [], note: 'No pets available' },
                    pvp_defender: { builds: [], note: 'No pets available' }
                };
            }
            
            // Generate all combinations of 3 pets (C(n,3) where n = total pets)
            const combinations = [];
            const n = allPets.length;
            
            if (n < 3) {
                return {
                    pvm: { builds: [], note: 'Need at least 3 pets' },
                    pvp_attacker: { builds: [], note: 'Need at least 3 pets' },
                    pvp_defender: { builds: [], note: 'Need at least 3 pets' }
                };
            }
            
            // Generate all combinations of 3 pets
            for (let i = 0; i < n - 2; i++) {
                for (let j = i + 1; j < n - 1; j++) {
                    for (let k = j + 1; k < n; k++) {
                        combinations.push([allPets[i], allPets[j], allPets[k]]);
                    }
                }
            }
            
            logger.info(`ðŸ” Analyzing ${combinations.length} pet combinations...`);
            
            // Evaluate each combination for PvM
            const pvmBuilds = combinations.map(pets => {
                const totalAtk = pets.reduce((sum, p) => sum + (p.attack || 0), 0);
                const totalDef = pets.reduce((sum, p) => sum + (p.defense || 0), 0);
                
                // Calculate damage bonus from pets
                let damageBonus = 0;
                let armorPen = 0;
                let critRate = 0;
                let critDamage = 0;
                let staminaSave = 0;
                let heal = 0;
                let staminaCostMult = 1.0;
                
                pets.forEach(pet => {
                    const eff = pet.parsed_effects || {};
                    damageBonus += eff.extra_damage_monsters || 0;
                    armorPen += eff.armor_penetration || 0;
                    critRate += eff.crit_rate || 0;
                    critDamage += eff.crit_damage || 0;
                    staminaSave += eff.stamina_save || 0;
                    heal += eff.heal_on_damage || 0;
                    if (eff.stamina_cost_mult > 1.0) staminaCostMult *= eff.stamina_cost_mult;
                });
                
                // Add equipment bonuses
                const equipEff = equipment.equipment_effects || {};
                damageBonus += equipEff.extra_damage_monsters || 0;
                armorPen += equipEff.armor_penetration || 0;
                critRate += equipEff.crit_rate || 0;
                critDamage += equipEff.crit_damage || 0;
                staminaSave += equipEff.stamina_save || 0;
                heal += equipEff.heal_on_damage || 0;
                
                // Calculate expected damage (using skill -1 = 10 stamina for comparison)
                const stamina_cost = 10;
                const base = 225;
                const equip_bonus = equipment.total_equipped_atk || 0;
                const user_atk_bonus = stats.base_attack || 0;
                const subtotal = (base + equip_bonus + totalAtk + user_atk_bonus) * stamina_cost;
                const baseDamage = subtotal * (1 + (damageBonus / 100));
                
                // Apply crit multiplier (simplified: if crit rate > 50%, assume 1.5x average boost)
                const critMultiplier = critRate > 50 ? 1 + ((critRate / 100) * (1 + critDamage / 100) * 0.5) : 1.0;
                const expectedDamage = baseDamage * critMultiplier;
                
                // Calculate score (weighted)
                const score = (
                    (damageBonus * 3.0) +
                    (armorPen * 2.0) +
                    (critRate * 1.5) +
                    (critDamage * 1.2) +
                    (staminaSave * 1.0) +
                    (heal * 1.0) +
                    (totalAtk / 10) // Stats contribution
                ) - ((staminaCostMult - 1.0) * 50);
                
                return {
                    pets: pets.map(p => p.name),
                    totalAtk,
                    totalDef,
                    damageBonus,
                    armorPen,
                    critRate,
                    critDamage,
                    staminaSave,
                    heal,
                    expectedDamage: Math.round(expectedDamage),
                    score: Math.round(score * 10) / 10,
                    equipmentBonus: {
                        damage: equipEff.extra_damage_monsters || 0,
                        armorPen: equipEff.armor_penetration || 0,
                        critRate: equipEff.crit_rate || 0,
                        critDamage: equipEff.crit_damage || 0
                    }
                };
            });
            
            // Evaluate for PvP Attacker
            const pvpAttackerBuilds = combinations.map(pets => {
                const totalAtk = pets.reduce((sum, p) => sum + (p.attack || 0), 0);
                const totalDef = pets.reduce((sum, p) => sum + (p.defense || 0), 0);
                
                let stealStat = 0;
                let teamConversion = 0;
                let atkDefSwap = 0;
                let critRate = 0;
                let critDamage = 0;
                
                pets.forEach(pet => {
                    const eff = pet.parsed_effects || {};
                    stealStat += eff.steal_stat || 0;
                    teamConversion += eff.team_conversion || 0;
                    atkDefSwap += eff.atk_def_swap || 0;
                    critRate += eff.crit_rate || 0;
                    critDamage += eff.crit_damage || 0;
                });
                
                const score = (
                    (stealStat * 3.0) +
                    (teamConversion * 2.5) +
                    (atkDefSwap * 2.0) +
                    (critRate * 1.5) +
                    (critDamage * 1.2) +
                    (totalAtk / 10)
                );
                
                return {
                    pets: pets.map(p => p.name),
                    totalAtk,
                    totalDef,
                    stealStat,
                    teamConversion,
                    atkDefSwap,
                    critRate,
                    critDamage,
                    score: Math.round(score * 10) / 10
                };
            });
            
            // Evaluate for PvP Defender
            const pvpDefenderBuilds = combinations.map(pets => {
                const totalAtk = pets.reduce((sum, p) => sum + (p.attack || 0), 0);
                const totalDef = pets.reduce((sum, p) => sum + (p.defense || 0), 0);
                
                let stealStat = 0;
                let teamConversion = 0;
                let defBoost = 0;
                let atkDefSwap = 0;
                
                pets.forEach(pet => {
                    const eff = pet.parsed_effects || {};
                    stealStat += eff.steal_stat || 0;
                    teamConversion += eff.team_conversion || 0;
                    defBoost += eff.def_boost || 0;
                    atkDefSwap += eff.atk_def_swap || 0;
                });
                
                const score = (
                    (stealStat * 3.0) +
                    (teamConversion * 2.5) +
                    (defBoost * 2.0) +
                    (atkDefSwap * 2.0) +
                    (totalDef / 10)
                );
                
                return {
                    pets: pets.map(p => p.name),
                    totalAtk,
                    totalDef,
                    stealStat,
                    teamConversion,
                    defBoost,
                    atkDefSwap,
                    score: Math.round(score * 10) / 10
                };
            });
            
            // Sort and return top 5 for each category
            pvmBuilds.sort((a, b) => b.expectedDamage - a.expectedDamage);
            pvpAttackerBuilds.sort((a, b) => b.score - a.score);
            pvpDefenderBuilds.sort((a, b) => b.score - a.score);
            
            return {
                pvm: {
                    builds: pvmBuilds.slice(0, 5),
                    total_combinations: combinations.length
                },
                pvp_attacker: {
                    builds: pvpAttackerBuilds.slice(0, 5),
                    total_combinations: combinations.length
                },
                pvp_defender: {
                    builds: pvpDefenderBuilds.slice(0, 5),
                    total_combinations: combinations.length
                }
            };
        }
        
        return {
            extractStats,
            extractPets,
            extractEquipment,
            extractAll,
            clearCache,
            forceRefresh,
            analyzePetImpact,
            analyzeOptimalBuilds
        };
    }
    
    // ==================== DAMAGE CALCULATOR SERVICE ====================
    // Centralized damage calculation for PvM and PvP
    // Implements verified game formulas
    
    /**
     * Create damage calculator service
     * Calculates damage/power based on game formulas
     * 
     * @param {Object} context - Script context
     * @returns {Object} Damage calculator service
     * 
     * @example
     * const calc = context.damageCalculator;
     * 
     * // Calculate PvM damage
     * const damage = calc.calculatePvMDamage({
     *   base_attack: 1110,
     *   equip_attack: 720,
     *   pet_attack: 1721,
     *   skill_id: -2,
     *   monster_defense: 50
     * });
     * // { damage: 2688250, breakdown: {...} }
     * 
     * // Calculate PvP power
     * const attackerPower = calc.calculatePvPAttacker({...});
     * const defenderPower = calc.calculatePvPDefender({...});
     */
    function createDamageCalculatorService(context) {
        const { logger } = context;
        
        // Skill stamina costs
        const SKILL_COSTS = {
            0: 1,      // Slash
            '-1': 10,  // Power Slash
            '-2': 50,  // Heroic Slash
            '-3': 100, // Ultimate Slash
            '-4': 200  // Legendary Slash
        };
        
        /**
         * Calculate PvM damage using verified formula
         * 
         * Formula:
         * PvM_Damage = (225 + equip_bonus + pet_bonus + user_atk_bonus) Ã— stamina_cost Ã— (1 + pet_effects_percent/100)
         * 
         * Where:
         * - equip_bonus = max(30, equip_atk - m_def/2) Ã— 20
         * - pet_bonus = max(30, pet_atk - m_def/2) Ã— 20
         * - user_atk_bonus = 1000 Ã— max(30, user_atk - m_def)^0.25
         * - pet_effects_percent = sum of all "X% Extra Damage To Monsters" effects
         * 
         * @param {Object} params - Calculation parameters
         * @param {number} params.base_attack - Base attack stat
         * @param {number} params.equip_attack - Total equipment attack
         * @param {number} params.pet_attack - Total pet attack
         * @param {number} params.skill_id - Skill ID (0, -1, -2, -3, -4)
         * @param {number} params.monster_defense - Monster defense value
         * @param {number} [params.pet_damage_bonus_percent=0] - Total % damage bonus from pets
         * @param {number} [params.equip_damage_bonus_percent=0] - Total % damage bonus from equipment
         * @returns {Object} { damage, breakdown }
         */
        function calculatePvMDamage({ base_attack, equip_attack, pet_attack, skill_id, monster_defense, pet_damage_bonus_percent = 0, equip_damage_bonus_percent = 0 }) {
            const m_def = monster_defense || 0;
            const stamina_cost = SKILL_COSTS[String(skill_id)] || 1;
            
            // Calculate components
            const base = 225;
            
            const equip_component = Math.max(30, equip_attack - m_def / 2);
            const equip_bonus = equip_component * 20;
            
            const pet_component = Math.max(30, pet_attack - m_def / 2);
            const pet_bonus = pet_component * 20;
            
            const user_atk_component = Math.max(30, base_attack - m_def);
            const user_atk_bonus = 1000 * Math.pow(user_atk_component, 0.25);
            
            const skill_damage = 0; // No skill bonus in base formula
            
            const subtotal = base + equip_bonus + pet_bonus + skill_damage + user_atk_bonus;
            const damage_before_bonus = subtotal * stamina_cost;
            
            // Apply percentage bonuses from pets and equipment
            const total_bonus_percent = pet_damage_bonus_percent + equip_damage_bonus_percent;
            const bonus_multiplier = 1 + (total_bonus_percent / 100);
            const final_damage = Math.round(damage_before_bonus * bonus_multiplier);
            
            return {
                damage: final_damage,
                breakdown: {
                    base,
                    equip_contribution: Math.round(equip_bonus),
                    pet_contribution: Math.round(pet_bonus),
                    skill_damage,
                    user_attack_contribution: Math.round(user_atk_bonus),
                    subtotal: Math.round(subtotal),
                    stamina_multiplier: stamina_cost,
                    damage_before_bonus: Math.round(damage_before_bonus),
                    pet_bonus_percent: pet_damage_bonus_percent,
                    equip_bonus_percent: equip_damage_bonus_percent,
                    total_bonus_percent,
                    bonus_multiplier: bonus_multiplier.toFixed(2),
                    total: final_damage
                }
            };
        }
        
        /**
         * Calculate PvP Attacker power
         * 
         * Formula:
         * Power = atk_base + 0.7Ã—def_base + 0.3Ã—pets_atk + 0.4Ã—equip_atk + 0.3Ã—pets_def + 0.2Ã—equip_def
         * 
         * @param {Object} params - Calculation parameters
         * @param {number} params.base_attack - Base attack stat
         * @param {number} params.base_defense - Base defense stat
         * @param {number} params.equip_attack - Total equipment attack
         * @param {number} params.equip_defense - Total equipment defense
         * @param {number} params.pet_attack - Total pet attack
         * @param {number} params.pet_defense - Total pet defense
         * @returns {Object} { power, breakdown }
         */
        function calculatePvPAttacker({ base_attack, base_defense, equip_attack, equip_defense, pet_attack, pet_defense }) {
            const power = 
                base_attack +
                (0.7 * base_defense) +
                (0.3 * pet_attack) +
                (0.4 * equip_attack) +
                (0.3 * pet_defense) +
                (0.2 * equip_defense);
            
            return {
                power: Math.round(power * 10) / 10, // Round to 1 decimal
                breakdown: {
                    base_attack: base_attack,
                    base_defense_contribution: Math.round(0.7 * base_defense * 10) / 10,
                    pet_attack_contribution: Math.round(0.3 * pet_attack * 10) / 10,
                    equip_attack_contribution: Math.round(0.4 * equip_attack * 10) / 10,
                    pet_defense_contribution: Math.round(0.3 * pet_defense * 10) / 10,
                    equip_defense_contribution: Math.round(0.2 * equip_defense * 10) / 10,
                    total: Math.round(power * 10) / 10
                }
            };
        }
        
        /**
         * Calculate PvP Defender power
         * 
         * Formula:
         * Power = def_base + 0.7Ã—atk_base + 0.3Ã—pets_atk + 0.2Ã—eq_atk + 0.3Ã—pets_def + 0.4Ã—eq_def
         * 
         * @param {Object} params - Calculation parameters
         * @param {number} params.base_attack - Base attack stat
         * @param {number} params.base_defense - Base defense stat
         * @param {number} params.equip_attack - Total equipment attack
         * @param {number} params.equip_defense - Total equipment defense
         * @param {number} params.pet_attack - Total pet attack
         * @param {number} params.pet_defense - Total pet defense
         * @returns {Object} { power, breakdown }
         */
        function calculatePvPDefender({ base_attack, base_defense, equip_attack, equip_defense, pet_attack, pet_defense }) {
            const power = 
                base_defense +
                (0.7 * base_attack) +
                (0.3 * pet_attack) +
                (0.2 * equip_attack) +
                (0.3 * pet_defense) +
                (0.4 * equip_defense);
            
            return {
                power: Math.round(power * 10) / 10, // Round to 1 decimal
                breakdown: {
                    base_defense: base_defense,
                    base_attack_contribution: Math.round(0.7 * base_attack * 10) / 10,
                    pet_attack_contribution: Math.round(0.3 * pet_attack * 10) / 10,
                    equip_attack_contribution: Math.round(0.2 * equip_attack * 10) / 10,
                    pet_defense_contribution: Math.round(0.3 * pet_defense * 10) / 10,
                    equip_defense_contribution: Math.round(0.4 * equip_defense * 10) / 10,
                    total: Math.round(power * 10) / 10
                }
            };
        }
        
        /**
         * Calculate damage/power with current player data
         * Automatically extracts data and calculates all values
         * 
         * @param {Object} dataExtractor - Data extractor service
         * @param {number} monster_defense - Monster defense (for PvM)
         * @param {number} skill_id - Skill ID (for PvM)
         * @returns {Promise<Object>} { pvm, pvp_attacker, pvp_defender }
         */
        async function calculateWithCurrentData(dataExtractor, monster_defense = 50, skill_id = -2) {
            logger.info('ðŸ§® Calculating damage with current player data...');
            
            const { stats, pets, equipment } = await dataExtractor.extractAll();
            
            // Get equipment bonuses (including manual config bonuses)
            const equipEffects = equipment.equipment_effects || {};
            const equipDamageBonus = equipEffects.extra_damage_monsters || 0;
            
            const pvm = calculatePvMDamage({
                base_attack: stats.base_attack,
                equip_attack: equipment.total_equipped_atk,
                pet_attack: pets.total_attack_pets_atk,
                skill_id,
                monster_defense,
                pet_damage_bonus_percent: pets.pvm_damage_bonus_percent || 0,
                equip_damage_bonus_percent: equipDamageBonus
            });
            
            const pvp_attacker = calculatePvPAttacker({
                base_attack: stats.base_attack,
                base_defense: stats.base_defense,
                equip_attack: equipment.total_equipped_atk,
                equip_defense: equipment.total_equipped_def,
                pet_attack: pets.total_attack_pets_atk,
                pet_defense: pets.total_attack_pets_def
            });
            
            const pvp_defender = calculatePvPDefender({
                base_attack: stats.base_attack,
                base_defense: stats.base_defense,
                equip_attack: equipment.total_equipped_atk,
                equip_defense: equipment.total_equipped_def,
                pet_attack: pets.total_attack_pets_atk,
                pet_defense: pets.total_attack_pets_def
            });
            
            logger.info(`âœ… PvM: ${formatNumber(pvm.damage)} | PvP ATK: ${pvp_attacker.power} | PvP DEF: ${pvp_defender.power}`);
            
            return {
                pvm,
                pvp_attacker,
                pvp_defender,
                player_data: { stats, pets, equipment }
            };
        }
        
        return {
            calculatePvMDamage,
            calculatePvPAttacker,
            calculatePvPDefender,
            calculateWithCurrentData
        };
    }

    function createUiRoot(config) {
        if (!config.core.shadowDom) {
            let container = document.getElementById('autods-root');
            if (!container) {
                container = document.createElement('div');
                container.id = 'autods-root';
                document.documentElement.appendChild(container);
            }
            return { root: container, shadow: container };
        }

        let host = document.getElementById('autods-root');
        if (!host) {
            host = document.createElement('div');
            host.id = 'autods-root';
            document.documentElement.appendChild(host);
        }
        let shadow = host.shadowRoot;
        if (!shadow) {
            shadow = host.attachShadow({ mode: 'open' });
            shadow.innerHTML = `<style>
                :host { all: initial; font-family: 'Segoe UI', system-ui, sans-serif; color: #e5e5e5; }
            </style>
            <div id="autods-app"></div>`;
        }
        return { root: host, shadow: shadow.getElementById('autods-app') };
    }

    function createModuleRegistry(logger) {
        const modules = [];

        function register(module) {
            modules.push(module);
        }

        function initAll(context) {
            modules.forEach(module => {
                try {
                    module.init?.(context);
                } catch (error) {
                    logger.error(`Module ${module.id} failed to initialise`, error);
                }
            });
        }

        function activateFor(context) {
            modules.forEach(module => {
                try {
                    if (module.match?.(context)) {
                        module.activate?.(context);
                    }
                } catch (error) {
                    logger.error(`Module ${module.id} failed to activate`, error);
                }
            });
        }

        function getModule(id) {
            return modules.find(m => m.id === id);
        }

        return { register, initAll, activateFor, getModule, modules };
    }

    // --- Feature Module Skeletons --------------------------------------------------------

    const waveModule = {
        id: 'waveAutomation',
        match: ({ location }) => /active_wave\.php/i.test(location.pathname),
        init() {
            this.state = {
                running: false,
                staminaWaiting: false,
                notifiedMaxBattles: false,
                lastTarget: null,
                lastWaveUrl: null,
                ultraFastStats: {
                    attackCount: 0,
                    damageDealt: 0,
                    potionsUsed: 0,
                    monstersCompleted: 0,
                    startTime: null
                }
            };
        },
        activate(context) {
            const cfgRoot = context.config.get();
            const cfgWave = cfgRoot.wave;
            
            // Log detailed guard condition checks
            context.logger?.info?.('[WaveModule] activate() chamado | core.enabled=' + cfgRoot.core?.enabled + ' | wave=' + (cfgWave ? 'existe' : 'null') + ' | wave.enabled=' + cfgWave?.enabled);
            
            if (!cfgRoot.core.enabled) {
                context.logger?.info?.('[WaveModule] âŒ Guard falhou: core.enabled=false');
                if (this.state) this.state.running = false;
                return;
            }
            
            if (!cfgWave) {
                context.logger?.info?.('[WaveModule] âŒ Guard falhou: wave config nÃ£o existe');
                if (this.state) this.state.running = false;
                return;
            }
            
            if (cfgWave.enabled === false) {
                context.logger?.info?.('[WaveModule] âŒ Guard falhou: wave.enabled=false');
                if (this.state) this.state.running = false;
                return;
            }
            
            context.logger?.info?.('[WaveModule] âœ… Guardas passadas! Continuando...');
            
            if (!this.state) this.init(context);
            if (this.state.running) {
                context.logger?.info?.('[WaveModule] âš ï¸ JÃ¡ estÃ¡ rodando (state.running=true)');
                return;
            }
            
            this.state.running = true;
            context.logger?.info?.('[WaveModule] Estado: running=true, iniciando async loop...');

            (async () => {
                try {
                    // Check if Ultra Fast Mode is enabled
                    context.logger?.info?.('[WaveModule] Verificando modo: ultraFastMode=' + cfgWave.ultraFastMode);
                    if (cfgWave.ultraFastMode) {
                        context.logger.info('âš¡ Wave Ultra Fast Mode ativo - iniciando loop eterno');
                        await this.runUltraFastLoop(context);
                    } else {
                        await this.runLoop(context);
                    }
                } catch (error) {
                    context.logger.error('Falha na rotina de ondas', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },
        
        /**
         * Ultra Fast Loop - joins and attacks directly from active_wave.php
         * Similar to Ultra Fast Dungeon but for wave battles
         */
        async runUltraFastLoop(context) {
            const { logger, dom } = context;
            
            this.state.ultraFastStats = {
                attackCount: 0,
                damageDealt: 0,
                potionsUsed: 0,
                monstersCompleted: 0,
                startTime: Date.now()
            };
            
            logger.info('âš¡ Ultra Fast Wave iniciado - Loop eterno ativado');
            
            // Debug: Log initial state
            const initialPathname = context.location?.pathname || window.location?.pathname || '';
            const isActivePage = /active_wave\.php/i.test(initialPathname);
            logger.debug(`[UltraFastLoop] Pathname: ${initialPathname}`);
            logger.debug(`[UltraFastLoop] isActivePage: ${isActivePage}`);
            
            if (!isActivePage) {
                logger.error(`âŒ [UltraFastLoop] NÃƒO estÃ¡ em active_wave.php! Pathname: ${initialPathname}`);
                return;
            }
            
            let loopCount = 0;
            while (/active_wave\.php/i.test(context.location.pathname)) {
                loopCount++;
                if (loopCount === 1) {
                    logger.info(`âœ… [UltraFastLoop] Entrou no while loop - INÃCIO`);
                }
                
                const cfg = context.config.get();
                logger.debug(`[UltraFastLoop] IteraÃ§Ã£o ${loopCount}: core=${cfg.core?.enabled}, wave.enabled=${cfg.wave?.enabled}, ultraFast=${cfg.wave?.ultraFastMode}`);
                
                if (!cfg.core.enabled || cfg.wave?.enabled === false || !cfg.wave?.ultraFastMode) {
                    logger.info(`âš¡ Ultra Fast Wave desativado via configuraÃ§Ã£o (iteraÃ§Ã£o ${loopCount}).`);
                    break;
                }
                
                // ðŸŽ¯ PRIORIDADE: Se Special Boss Farm estiver ativo E processando bosses, pausar Ultra Fast Wave
                if (cfg.specialBossFarm?.enabled) {
                    const specialBossModule = context.moduleRegistry.getModule('specialBossFarm');
                    if (specialBossModule?.state?.running && specialBossModule?.state?.activeBosses > 0) {
                        logger.info(`ðŸ‘‘ Special Boss Farm processando ${specialBossModule.state.activeBosses} boss(es) - pausando Ultra Fast Wave...`);
                        await sleep(5000); // Aguardar 5s e verificar novamente
                        continue;
                    }
                }
                
                const ultraCfg = cfg.wave.ultraFastConfig || {};
                
                // 1. Check stamina
                const currentStamina = context.stamina.getCurrent();
                const skillId = ultraCfg.skillId ?? -2;
                const skillCost = context.combat.getSkillCost(skillId);
                
                if (currentStamina < skillCost) {
                    // Check if should use FSP
                    if ((ultraCfg.autoFSP || ultraCfg.lootDeadBeforeFSP) && currentStamina < (ultraCfg.minStaminaForFSP || 100)) {
                        logger.info(`â³ Stamina insuficiente (${currentStamina}/${skillCost}). Tentando recuperar...`);
                        
                        // ðŸ†• Verificar se jÃ¡ tentamos loot dead e devemos ir direto para FSP
                        const skipLootDead = sessionStorage.getItem('autods_skip_loot_dead_use_fsp');
                        
                        // ðŸ†• ANTES de usar FSP, tentar lootar dead monsters para possÃ­vel level up
                        if (ultraCfg.lootDeadBeforeFSP !== false && !skipLootDead) {
                            logger.info('ðŸ’€ [LOOT DEAD] Tentando lootar dead monsters...');
                            const deadMonstersLooted = await this.tryLootDeadMonstersBeforeFSP(context);
                            
                            if (deadMonstersLooted) {
                                // Verificar se stamina recuperou com level up
                                const newStamina = context.stamina.getCurrent();
                                logger.info(`ðŸ’€ [LOOT DEAD] Processo concluÃ­do! Nova stamina: ${newStamina}`);
                                if (newStamina >= skillCost) {
                                    logger.info('ðŸŽ‰ Stamina recuperada apÃ³s loot! Level up detectado.');
                                    await this.ensureAliveMonstersView(context);
                                    continue; // Continuar loop sem usar FSP
                                }
                                logger.info(`ðŸ’€ [LOOT DEAD] Stamina ainda baixa (${newStamina}). Tentando FSP...`);
                            }
                            // Se retornou false, a flag jÃ¡ foi setada dentro da funÃ§Ã£o
                            // A pÃ¡gina pode ter recarregado, entÃ£o este cÃ³digo pode nÃ£o executar
                        } else if (skipLootDead) {
                            logger.info('ðŸ’€ [LOOT DEAD] Flag detectada - pulando loot dead, indo direto para FSP...');
                            // Limpar flag apÃ³s usar
                            sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                        }
                        
                        // Tentar usar FSP
                        logger.info(`ðŸ’Š [FSP] autoFSP=${ultraCfg.autoFSP} - Verificando opÃ§Ã£o FSP...`);
                        if (!ultraCfg.autoFSP) {
                            logger.info('ðŸ’Š [FSP] autoFSP estÃ¡ DESATIVADO. NÃ£o usarÃ¡ FSP.');
                        } else {
                            logger.info('ðŸ’Š [FSP] Usando Full Stamina Potion...');
                            const fspUsed = await context.inventory.useFullStaminaPotion();
                            if (fspUsed) {
                                logger.info('ðŸ’Š [FSP] FSP usada com sucesso! Recarregando pÃ¡gina...');
                                // Limpar flag ao usar FSP com sucesso
                                sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                                await sleep(500);
                                window.location.reload();
                                return;
                            } else {
                                logger.info('ðŸ’Š [FSP] Falha ao usar FSP ou sem FSP disponÃ­vel.');
                            }
                        }
                    }
                    
                    // Wait for stamina regen
                    logger.info(`â³ Stamina baixa (${currentStamina}). Aguardando regeneraÃ§Ã£o...`);
                    await sleep(30000); // 30s wait
                    continue;
                }
                
                // 2. Scan ALL eligible targets (not joined yet)
                const newTargets = this.scanUltraFastTargets(context, cfg);
                
                // 3. Count ongoing battles (already joined)
                const ongoingCount = this.countOngoingBattles(context);
                
                // 4. If no new targets but has ongoing battles, attack them
                if (newTargets.length === 0 && ongoingCount > 0) {
                    logger.info(`âš”ï¸ ${ongoingCount} batalhas em andamento - atacando...`);
                    await this.attackOngoingBattles(context, cfg);
                    
                    // Refresh to check for new targets
                    await sleep(5000);
                    window.location.reload();
                    continue;
                }
                
                // 5. If no targets at all, wait and refresh
                if (newTargets.length === 0 && ongoingCount === 0) {
                    logger.debug('Nenhum alvo disponÃ­vel. Aguardando 15s...');
                    await sleep(15000);
                    window.location.reload();
                    continue;
                }
                
                // 6. SAFE MODE CHECK: Don't join if already >10 continues active
                if (ongoingCount > 10) {
                    logger.warn(`âš ï¸ MUITAS BATALHAS ATIVAS (${ongoingCount} > 10)! Modo seguro: apenas atacando batalhas em andamento.`);
                    logger.info('ðŸ’¡ NÃ£o serÃ¡ feito join em novos monstros para evitar sobrecarga do servidor.');
                    
                    // Attack ongoing battles only, then reload
                    const ongoingBattles = this.getOngoingBattles(context);
                    if (ongoingBattles.length > 0) {
                        await this.attackUltraFastBattles(context, ongoingBattles, cfg);
                    }
                    
                    // Wait and reload to check if some battles completed
                    await sleep(10000);
                    window.location.reload();
                    continue;
                }
                
                // 7. JOIN ALL ELIGIBLE TARGETS AT ONCE (like Ultra Fast Farm does)
                // This bypasses the maxConcurrentBattles limit by joining before the server can enforce it
                logger.info(`ðŸš€ PRE-FLIGHT JOIN: Entrando em ${newTargets.length} batalha(s) SIMULTANEAMENTE...`);
                
                const joinedTargets = await this.joinUltraFastBattles(context, newTargets);
                
                logger.info(`ðŸ“Š Pre-Flight Join: ${joinedTargets.length}/${newTargets.length} joins bem-sucedidos`);
                
                // 8. Attack ALL battles (newly joined + ongoing)
                if (joinedTargets.length > 0) {
                    await this.attackUltraFastBattles(context, joinedTargets, cfg);
                }
                
                // Also attack any ongoing battles that weren't in joinedTargets
                if (ongoingCount > 0) {
                    // Find ongoing battles that weren't in newTargets
                    const ongoingBattles = this.getOngoingBattles(context);
                    const newTargetIds = new Set(newTargets.map(t => t.monsterId));
                    const additionalOngoing = ongoingBattles.filter(t => !newTargetIds.has(t.monsterId));
                    
                    if (additionalOngoing.length > 0) {
                        logger.info(`âš”ï¸ Atacando ${additionalOngoing.length} batalha(s) adicionais em andamento...`);
                        await this.attackUltraFastBattles(context, additionalOngoing, cfg);
                    }
                }
                
                // 9. Refresh page to continue loop
                await sleep(2000);
                window.location.reload();
            }
            
            // Log final stats
            const duration = (Date.now() - this.state.ultraFastStats.startTime) / 1000;
            logger.info(`âš¡ Ultra Fast Wave finalizado - Ataques: ${this.state.ultraFastStats.attackCount}, Dano: ${formatNumber(this.state.ultraFastStats.damageDealt)}, Tempo: ${duration.toFixed(1)}s`);
        },
        
        /**
         * Get list of ongoing battles (already joined)
         */
        getOngoingBattles(context) {
            const { dom } = context;
            const cards = dom.queryAll('.monster-card');
            const ongoing = [];
            
            for (const card of cards) {
                const button = card.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button');
                const buttonText = button?.textContent?.toLowerCase() || '';
                
                if (!buttonText.includes('continue')) continue;
                
                const link = card.querySelector('a[href*="battle.php"][href*="id="]');
                const battleUrl = link?.href;
                const monsterIdMatch = battleUrl?.match(/[?&]id=(\d+)/);
                const monsterId = monsterIdMatch ? monsterIdMatch[1] : null;
                
                if (!monsterId) continue;
                
                const nameNode = card.querySelector('h3, h4, .monster-name, .card-title');
                const name = nameNode ? nameNode.textContent.trim() : 'Unknown';
                
                ongoing.push({ name, monsterId, battleUrl });
            }
            
            return ongoing;
        },
        

        
        /**
         * ðŸ†• Tenta lootar dead monsters antes de usar FSP
         * Retorna true se fez loot (pode ter subido de nÃ­vel)
         */
        async tryLootDeadMonstersBeforeFSP(context) {
            const { logger } = context;
            
            // 1. PRIMEIRO: Alternar para dead monsters view para poder ver quantos hÃ¡
            logger.info('ðŸ’€ [LOOT DEAD] Alternando para view de dead monsters...');
            const switchedToDead = await this.switchToDeadMonstersView(context);
            if (!switchedToDead) {
                logger.warn('âš ï¸ [LOOT DEAD] NÃ£o foi possÃ­vel mudar para view de dead monsters');
                return false;
            }
            
            // 2. Aguardar pÃ¡gina atualizar + retry loop para conexÃµes lentas
            logger.info('ðŸ’€ [LOOT DEAD] Aguardando pÃ¡gina atualizar (com retry para conexÃµes lentas)...');
            let unclaimedCount = 0;
            const maxRetries = 5;
            const retryDelays = [1000, 1500, 2000, 3000, 4000]; // Aumenta progressivamente
            
            for (let retryIdx = 0; retryIdx < maxRetries; retryIdx++) {
                await sleep(retryDelays[retryIdx]);
                unclaimedCount = this.getUnclaimedKillsCount();
                logger.debug(`ðŸ’€ [LOOT DEAD] Tentativa ${retryIdx + 1}/${maxRetries}: ${unclaimedCount} dead monsters encontrados`);
                
                // Se encontrou algum, pode continuar
                if (unclaimedCount > 0) {
                    logger.info(`ðŸ’€ [LOOT DEAD] âœ… Dead monsters detectados na tentativa ${retryIdx + 1}`);
                    break;
                }
            }
            
            logger.info(`ðŸ’€ [LOOT DEAD] Dead monsters encontrados (final): ${unclaimedCount}`);
            
            if (unclaimedCount === 0) {
                logger.info('ðŸ’€ [LOOT DEAD] Nenhum dead monster para lootar.');
                // ðŸ†• Setar flag ANTES de voltar para alive view (pois pode recarregar)
                logger.info('ðŸ’€ [LOOT DEAD] Setando flag para usar FSP apÃ³s reload...');
                sessionStorage.setItem('autods_skip_loot_dead_use_fsp', 'true');
                logger.info('ðŸ’€ [LOOT DEAD] Voltando para alive view...');
                await this.switchToAliveMonstersView(context);
                await sleep(1000);
                return false;
            }
            
            logger.info(`ðŸ’€ [LOOT DEAD] ${unclaimedCount} dead monsters disponÃ­veis - executando loot...`);
            
            // 3. Executar Ultra Fast Loot nos dead monsters
            const looted = await this.executeQuickDeadLoot(context);
            logger.info(`ðŸ’€ [LOOT DEAD] Loot executado: ${looted ? 'SUCESSO' : 'FALHA'}`);
            
            // 4. Voltar para alive monsters view
            logger.info('ðŸ’€ [LOOT DEAD] Voltando para alive monsters view...');
            await this.switchToAliveMonstersView(context);
            await sleep(1000);
            
            // 5. NÃƒO recarregar aqui - deixar o cÃ³digo principal decidir
            // A stamina serÃ¡ verificada apÃ³s retornar
            
            return looted;
        },
        
        /**
         * ObtÃ©m contador de dead monsters (Unclaimed kills)
         * Mais robusto: tenta mÃºltiplas formas de detecÃ§Ã£o para conexÃµes lentas
         */
        getUnclaimedKillsCount() {
            // MÃ©todo 1: Procurar por "ðŸ’€ Unclaimed kills: X" ou "Unclaimed kills: X" no texto
            const pageText = document.body.textContent || '';
            let match = pageText.match(/Unclaimed kills:\s*(\d+)/i);
            if (match) {
                const count = parseInt(match[1], 10) || 0;
                if (count > 0) return count;
            }
            
            // MÃ©todo 2: Procurar por "X kills" (formato comum)
            match = pageText.match(/(\d+)\s+kills?/i);
            if (match) {
                const count = parseInt(match[1], 10) || 0;
                if (count > 0) return count;
            }
            
            // MÃ©todo 3: Contar monster cards com HP = 0 (dead)
            const monsterCards = document.querySelectorAll('.monster-card');
            let deadCount = 0;
            for (const card of monsterCards) {
                // Procurar por "0 / X" ou "0/X" pattern no card
                const cardText = card.textContent || '';
                if (/\b0\s*\/\s*\d+/.test(cardText)) {
                    deadCount++;
                }
                
                // Alternativa: verificar classe ou data attribute
                const hpElement = card.querySelector('.hp-value, [data-stat="hp"], .hp, [data-hp]');
                if (hpElement) {
                    const hpText = hpElement.textContent || '';
                    if (hpText.includes('0 /') || hpText.startsWith('0/') || hpText === '0') {
                        deadCount++;
                    }
                }
            }
            
            return Math.max(0, deadCount);
        },
        
        /**
         * Verifica se estÃ¡ na view de dead monsters
         */
        isDeadMonstersView() {
            const toggleBtn = document.querySelector('button[onclick*="toggleDead"], #toggleDeadBtn');
            if (toggleBtn) {
                const text = toggleBtn.textContent || '';
                return text.includes('Show Alive') || text.includes('ðŸ™ˆ');
            }
            
            // Alternativa: verificar se URL tem dead=1 ou se botÃ£o tem emoji especÃ­fico
            const buttons = document.querySelectorAll('button');
            for (const btn of buttons) {
                const text = btn.textContent || '';
                if (text.includes('Show Alive')) return true;
                if (text.includes('Show unclaimed')) return false;
            }
            
            return false;
        },
        
        /**
         * Muda para view de dead monsters
         */
        async switchToDeadMonstersView(context) {
            const { logger } = context;
            
            if (this.isDeadMonstersView()) {
                logger.debug('ðŸ’€ JÃ¡ estÃ¡ na view de dead monsters');
                return true;
            }
            
            // Procurar botÃ£o "Show unclaimed monsters" (ðŸ‘ï¸)
            const buttons = document.querySelectorAll('button');
            for (const btn of buttons) {
                const text = btn.textContent || '';
                if (text.includes('Show unclaimed') || (text.includes('ðŸ‘ï¸') && text.includes('unclaimed'))) {
                    logger.info('ðŸ’€ Mudando para unclaimed monsters view...');
                    btn.click();
                    await sleep(500);
                    return true;
                }
            }
            
            logger.warn('âš ï¸ BotÃ£o de toggle para dead monsters nÃ£o encontrado');
            return false;
        },
        
        /**
         * Muda para view de alive monsters
         */
        async switchToAliveMonstersView(context) {
            const { logger } = context;
            
            if (!this.isDeadMonstersView()) {
                logger.debug('âœ… JÃ¡ estÃ¡ na view de alive monsters');
                return true;
            }
            
            // Procurar botÃ£o "Show Alive monsters" (ðŸ™ˆ)
            const buttons = document.querySelectorAll('button');
            for (const btn of buttons) {
                const text = btn.textContent || '';
                if (text.includes('Show Alive') || (text.includes('ðŸ™ˆ') && text.includes('Alive'))) {
                    logger.info('âœ… Voltando para alive monsters view...');
                    btn.click();
                    await sleep(500);
                    return true;
                }
            }
            
            logger.warn('âš ï¸ BotÃ£o de toggle para alive monsters nÃ£o encontrado');
            return false;
        },
        
        /**
         * Garante que estÃ¡ na view de alive monsters
         */
        async ensureAliveMonstersView(context) {
            return this.switchToAliveMonstersView(context);
        },
        
        /**
         * Executa loot rÃ¡pido nos dead monsters visÃ­veis
         * âœ¨ Delega para ultraFastLootModule para reutilizar toda a lÃ³gica paralela
         */
        async executeQuickDeadLoot(context) {
            const { logger } = context;
            
            const BOSS_HP_THRESHOLD = 100_000_000_000;
            
            // Encontrar dead monsters
            let cards = Array.from(document.querySelectorAll('.monster-card[data-dead="1"]'));
            
            // Se nÃ£o encontrou, procurar por HP = 0
            if (cards.length === 0) {
                cards = Array.from(document.querySelectorAll('.monster-card'));
                cards = cards.filter(card => {
                    const hpText = card.textContent || '';
                    return hpText.includes('0 /') || /HP[:\s]*0[^0-9]/.test(hpText);
                });
            }
            
            logger.info(`ðŸ’€ [LOOT] Encontrados ${cards.length} monster cards para analisar`);
            
            // Coletar targets vÃ¡lidos (filtrando bosses 100B+)
            const lootTargets = [];
            let bossesFiltered = 0;
            
            for (const card of cards) {
                let monsterId = card.getAttribute('data-monster-id');
                
                if (!monsterId) {
                    const link = card.querySelector('a[href*="battle.php"]');
                    if (link) {
                        const match = link.href.match(/[?&]id=(\d+)/);
                        monsterId = match ? match[1] : null;
                    }
                }
                
                if (!monsterId) continue;
                
                const nameElement = card.querySelector('h3, .monster-name, .card-title');
                const monsterName = nameElement ? nameElement.textContent.trim() : 'Unknown';
                
                // Extract HP and filter bosses
                const hpRow = Array.from(card.querySelectorAll('.stat-row')).find(row => row.querySelector('.stat-icon.hp'));
                const hpValueNode = hpRow?.querySelector('.stat-value');
                const hpText = hpValueNode?.textContent ?? '';
                const hpMatch = hpText.match(/(\d{1,3}(?:,\d{3})*|\d+)\s*\/\s*(\d{1,3}(?:,\d{3})*|\d+)/);
                const hp = hpMatch ? numberFromText(hpMatch[2]) : null;
                
                // Skip bosses (100B+ HP)
                if (hp && hp >= BOSS_HP_THRESHOLD) {
                    logger.warn(`ðŸ‘‘ ${monsterName}: Ignorado (boss com ${formatNumber(hp)} HP)`);
                    bossesFiltered++;
                    continue;
                }
                
                lootTargets.push({
                    type: 'wave',
                    monsterId: monsterId,
                    name: monsterName
                });
            }
            
            if (lootTargets.length === 0) {
                logger.info(`ðŸ’€ [LOOT] Nenhum dead monster para lootar (${bossesFiltered} bosses filtrados)`);
                return false;
            }
            
            logger.info(`ðŸ’° [LOOT] ${lootTargets.length} dead monsters para lootar (${bossesFiltered} bosses filtrados)`);
            
            // Delegar para ultraFastLootModule que jÃ¡ tem toda a lÃ³gica paralela
            const ultraFastLootModule = context.moduleRegistry.getModule('ultraFastLoot');
            if (ultraFastLootModule && typeof ultraFastLootModule.lootBatchParallel === 'function') {
                // Usar mÃ³dulo para loot paralelo
                const summary = ultraFastLootModule.createLootSummary();
                const batchSize = context.config.get().ultraFastLoot?.maxParallelLoots || 10;
                
                // Processar em batches
                for (let i = 0; i < lootTargets.length; i += batchSize) {
                    const batch = lootTargets.slice(i, i + batchSize);
                    await ultraFastLootModule.lootBatchParallel(context, batch, summary);
                    
                    // Delay entre batches
                    if (i + batchSize < lootTargets.length) {
                        await sleep(context.config.get().ultraFastLoot?.delayBetweenLoots || 100);
                    }
                }
                
                logger.info(`ðŸŽ‰ [LOOT] CONCLUÃDO: ${summary.drops}/${lootTargets.length} loots bem-sucedidos`);
                if (context.loot?.showDetailedModal) {
                    context.loot.showDetailedModal(summary, 'Dead Monsters Quick Loot');
                }
                
                return summary.drops > 0;
            } else {
                // Fallback: usar loot service se ultraFastLootModule nÃ£o disponÃ­vel
                logger.warn('âš ï¸ [LOOT] ultraFastLootModule nÃ£o disponÃ­vel, usando fallback...');
                
                const userId = context.userSession.getUserId();
                if (!userId) {
                    logger.error('âŒ [LOOT] User ID nÃ£o encontrado');
                    return false;
                }
                
                const summary = await context.loot.lootMultiple(lootTargets, userId, {
                    batchSize: context.config.get().ultraFastLoot?.maxParallelLoots || 10,
                    checkLevelUp: true,
                    checkStamina: true
                });
                
                logger.info(`ðŸŽ‰ [LOOT] CONCLUÃDO: ${summary.drops}/${lootTargets.length} loots bem-sucedidos`);
                if (context.loot?.showDetailedModal) {
                    context.loot.showDetailedModal(summary, 'Dead Monsters Quick Loot');
                }
                
                return summary.drops > 0;
            }
        },
        
        /**
         * DEPRECATED: Use context.loot.lootWaveMonster() instead
         * Kept for backward compatibility but redirects to unified service
         */
        performQuickLoot(context, target) {
            return context.loot.lootWaveMonster(target.monsterId, context.userSession.getUserId(), target.name || 'Unknown');
        },
        
        scanUltraFastTargets(context, cfg) {
            const { logger } = context;
            
            // Extract filters from ultraFastConfig (or fallback to wave.monsterFilter for backward compat)
            const ultraCfg = cfg.wave?.ultraFastConfig || {};
            const monsterFilter = ultraCfg.monsterFilter || cfg.wave?.monsterFilter || {};
            const includeNames = Array.isArray(monsterFilter.includeNames) ? monsterFilter.includeNames.filter(Boolean) : [];
            const excludeNames = Array.isArray(monsterFilter.excludeNames) ? monsterFilter.excludeNames.filter(Boolean) : [];
            
            // Use Monster Scanner Service with include names (backward compat)
            const monsters = context.monsterScanner.scanWaveMonsters({
                monsterNames: includeNames.length > 0 ? includeNames : undefined,
                minHp: cfg.wave.minMobHp,
                onlyNotJoined: true, // Ultra Fast only attacks new targets
                onlyAlive: true // Skip dead monsters
            });
            
            if (!monsters.length) {
                logger.debug('[UltraFastWave] No monsters found after filters');
                return [];
            }
            
            // Apply exclude filter to remaining monsters
            let filtered = monsters;
            if (excludeNames.length > 0) {
                filtered = monsters.filter(monster => {
                    const monsterNameLower = (monster.name || '').toLowerCase();
                    return !excludeNames.some(excludeName => 
                        monsterNameLower.includes(excludeName.toLowerCase())
                    );
                });
                if (filtered.length < monsters.length) {
                    logger.debug(`[UltraFastWave] Filtered out ${monsters.length - filtered.length} monsters by exclude names`);
                }
            }
            
            // Convert to Ultra Fast format
            const targets = filtered.map(monster => ({
                card: monster.card,
                name: monster.name,
                hp: monster.hp,
                monsterId: monster.monsterId,
                battleUrl: `battle.php?id=${monster.monsterId}`,
                button: monster.card?.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button')
            }));
            
            // Sort by priority
            const mode = cfg.wave.priorityMode || 'lowest_hp';
            if (mode === 'lowest_hp') {
                targets.sort((a, b) => (a.hp || 0) - (b.hp || 0));
            } else if (mode === 'highest_hp') {
                targets.sort((a, b) => (b.hp || 0) - (a.hp || 0));
            } else if (mode === 'random') {
                targets.sort(() => Math.random() - 0.5);
            }
            
            return targets;
        },
        
        /**
         * Fetch current damage for a battle - reads from DOM card first (no HTTP needed)
         * Falls back to HTTP request if card not found
         * 
         * Strategy:
         * 1. ðŸš€ Try to read from monster card in current page (fast, no HTTP)
         * 2. ðŸ“¡ If not found, fetch from battle.php (slower, may be blocked by Cloudflare)
         */
        async fetchBattleDamage(context, monsterId) {
            const { logger, numbers, dom } = context;
            
            // 1ï¸âƒ£ Try to read damage from monster card in current page (FASTEST - no HTTP)
            try {
                const card = dom.query(`[data-monster-id="${monsterId}"]`);
                if (card) {
                    // Get damage from data attribute: data-userdmg="5330150"
                    const damageAttr = card.getAttribute('data-userdmg');
                    if (damageAttr) {
                        const damage = parseInt(damageAttr, 10);
                        if (!isNaN(damage) && damage >= 0) {
                            logger.debug(`[FetchDamage] ${monsterId}: Lido do card - ${formatNumber(damage)}`);
                            return { success: true, damage, source: 'card' };
                        }
                    }
                    
                    // Fallback: try to read from "You: X,XXX,XXX" text
                    const damageText = card.querySelector('.party-chip')?.textContent || '';
                    const textMatch = damageText.match(/You:\s*([0-9,]+)/i);
                    if (textMatch) {
                        const damage = numbers.parse(textMatch[1]);
                        logger.debug(`[FetchDamage] ${monsterId}: Lido do texto - ${formatNumber(damage)}`);
                        return { success: true, damage, source: 'text' };
                    }
                }
            } catch (e) {
                // Silently continue to HTTP fallback
            }
            
            // 2ï¸âƒ£ Card not found or no damage attribute - try HTTP fetch (slower, may be blocked)
            try {
                const url = `/battle.php?id=${monsterId}`;
                // Use current page URL as referer (includes event/wave params)
                const currentUrl = context.location?.href || window.location.href;
                const result = await context.http.get(url, {
                    headers: {
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                        'Referer': currentUrl
                    }
                });
                
                if (!result.success) {
                    logger.debug(`[FetchDamage] ${monsterId}: HTTP falhou`);
                    return { success: false, damage: 0 };
                }
                
                const html = result.data;
                
                // ValidaÃ§Ã£o: verificar se Ã© HTML vÃ¡lido
                if (html.length < 500 || !html.includes('<body')) {
                    logger.debug(`[FetchDamage] ${monsterId}: Resposta invÃ¡lida (${html.length} bytes)`);
                    return { success: true, damage: 0, source: 'http-empty' };
                }
                
                // Try to find damage value in HTML (ordem de prioridade)
                const damageMatch = html.match(/id="yourDamageValue"[^>]*>([0-9,]+)<\/span>/i) 
                                  || html.match(/DMG:\s*<span[^>]*>([0-9,]+)<\/span>/i)
                                  || html.match(/Your Damage[^<]*<[^>]*>([0-9,]+)<\/span>/i)
                                  || html.match(/damage[^>]*>.*?([0-9,]+)/i);
                
                if (damageMatch) {
                    const damage = numbers.parse(damageMatch[1]);
                    logger.debug(`[FetchDamage] ${monsterId}: HTTP - ${formatNumber(damage)}`);
                    return { success: true, damage, source: 'http' };
                } else {
                    // Check if battle is invalid/ended
                    if (html.includes('Invalid') || html.includes('not found') || html.includes('ended') || html.includes('dead')) {
                        return { success: false, invalid: true, damage: 0 };
                    } else {
                        return { success: true, damage: 0, source: 'http-zero' };
                    }
                }
            } catch (error) {
                logger.debug(`[FetchDamage] Error for ${monsterId}:`, error);
                return { success: false, damage: 0 };
            }
        },
        
        /**
         * Fetch current damages for multiple battles in parallel
         */
        async fetchCurrentDamages(context, targets) {
            const { logger } = context;
            
            logger.info(`ðŸ“Š Buscando dano atual de ${targets.length} batalha(s)...`);
            
            const startTime = Date.now();
            const results = await Promise.all(
                targets.map(async (target) => {
                    const result = await this.fetchBattleDamage(context, target.monsterId);
                    return { target, result };
                })
            );
            const duration = Date.now() - startTime;
            
            let skippedCount = 0;
            let zeroCount = 0;
            for (const { target, result } of results) {
                if (result.success) {
                    target.currentDamage = result.damage;
                    if (result.damage > 0) {
                        logger.debug(`  ${target.name}: ${formatNumber(result.damage)} dano existente`);
                    } else {
                        zeroCount++;
                    }
                } else if (result.invalid) {
                    target.invalid = true;
                    skippedCount++;
                }
            }
            
            // logger.info(`ðŸ“Š Danos atuais obtidos em ${duration}ms (${skippedCount} invÃ¡lidos, ${zeroCount} com 0 dano)`);
        },
        
        countOngoingBattles(context) {
            const cards = context.dom.queryAll('.monster-card');
            let count = 0;
            
            for (const card of cards) {
                const button = card.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button');
                const buttonText = button?.textContent?.toLowerCase() || '';
                
                if (buttonText.includes('continue')) {
                    count++;
                }
            }
            
            return count;
        },
        
        async joinUltraFastBattles(context, targets) {
            const { logger } = context;
            const cfg = context.config.get();
            const userId = cfg.core?.userId;
            
            if (!userId) {
                logger.warn('âš ï¸ UserId nÃ£o configurado. NÃ£o Ã© possÃ­vel usar Ultra Fast Mode sem userId.');
                return [];
            }
            
            const joinedTargets = [];
            
            // Join all targets in parallel
            const joinPromises = targets.map(target => 
                context.http.joinBattle(target.monsterId, userId)
                    .then(result => ({ target, result }))
                    .catch(error => ({ target, result: { success: false, message: error.message } }))
            );
            
            const results = await Promise.all(joinPromises);
            
            for (const { target, result } of results) {
                if (result.success) {
                    joinedTargets.push(target);
                    logger.debug(`âœ… Joined: ${target.name} (ID: ${target.monsterId})`);
                } else if (result.cloudflareBlock) {
                    // Cloudflare blocked - still count as joined since battle exists
                    joinedTargets.push(target);
                    logger.debug(`âš ï¸ ${target.name}: Cloudflare block mas tentando atacar mesmo assim`);
                } else {
                    logger.debug(`âš ï¸ Join falhou: ${target.name} - ${result.message}`);
                }
            }
            
            return joinedTargets;
        },
        
        /**
         * Send attack using centralized combat service (Cloudflare-proof)
         */
        async sendWaveAttack(context, monsterId, skillId) {
            return context.combat.attackWaveMonsterDirect(monsterId, skillId);
        },
        
        async attackUltraFastBattles(context, targets, cfg) {
            const { logger } = context;
            const ultraCfg = cfg.wave.ultraFastConfig || {};
            const skillId = ultraCfg.skillId ?? -2;
            const parallelAttacks = ultraCfg.parallelAttacks || 10;
            const baseDamageTarget = ultraCfg.damageTarget || 3000000;
            const skillCosts = { '0': 1, '-1': 10, '-2': 50, '-3': 100, '-4': 200 };
            const skillCost = skillCosts[skillId.toString()] || 1;
            
            // 1. First fetch current damage for all targets
            await this.fetchCurrentDamages(context, targets);
            
            // 2. Filter out targets that already reached threshold or are invalid
            // Apply special boss logic: General/King/Empress/Bastion need 50M minimum
            const validTargets = targets.filter(t => {
                if (t.invalid) {
                    logger.debug(`â­ï¸ ${t.name}: Batalha invÃ¡lida, pulando`);
                    return false;
                }
                
                // Get effective damage target for this monster
                const effectiveDamageTarget = getEffectiveDamageTarget(t.name, baseDamageTarget);
                t.effectiveDamageTarget = effectiveDamageTarget;
                
                if (isSpecialBoss(t.name) && effectiveDamageTarget > baseDamageTarget) {
                    logger.info(`ðŸ‘‘ ${t.name}: Boss especial detectado - alvo: ${formatNumber(effectiveDamageTarget)} (mÃ­nimo 50M para loot)`);
                }
                
                if ((t.currentDamage || 0) >= effectiveDamageTarget) {
                    logger.info(`âœ… ${t.name}: JÃ¡ atingiu threshold (${formatNumber(t.currentDamage)}/${formatNumber(effectiveDamageTarget)})`);
                    this.state.ultraFastStats.monstersCompleted++;
                    return false;
                }
                return true;
            });
            
            if (validTargets.length === 0) {
                logger.info(`âœ… Todos os alvos jÃ¡ atingiram o threshold ou sÃ£o invÃ¡lidos`);
                return;
            }
            
            logger.info(`ðŸš€ PRE-FLIGHT ATTACK: ${validTargets.length} monstros precisam de ataque, alvo base ${formatNumber(baseDamageTarget)} dano`);
            
            // 3. Attack all targets in rounds until damage target reached
            const targetStates = validTargets.map(t => ({
                ...t,
                currentDamage: t.currentDamage || 0, // Preserve existing damage
                attackCount: 0,
                completed: false,
                dead: false
            }));
            
            let rounds = 0;
            const maxRounds = 100; // Safety limit
            let roundsWithoutProgress = 0;
            const maxRoundsWithoutProgress = 3; // Stop if 3 rounds without any success
            
            while (rounds < maxRounds) {
                rounds++;
                
                // Check stamina (recalculate each round to account for attacks)
                let currentStamina = context.stamina.getCurrent();
                if (currentStamina < skillCost) {
                    logger.info(`â³ Stamina insuficiente (${currentStamina}/${skillCost}). Tentando recuperar...`);
                    
                    // ðŸ†• Verificar se jÃ¡ tentamos loot dead e devemos ir direto para FSP
                    const skipLootDead = sessionStorage.getItem('autods_skip_loot_dead_use_fsp');
                    
                    // ðŸ†• Tentar loot de dead monsters para possÃ­vel level up
                    if (ultraCfg.lootDeadBeforeFSP !== false && !skipLootDead) {
                        logger.info('ðŸ’€ [LOOT DEAD] Tentando lootar dead monsters...');
                        const looted = await this.tryLootDeadMonstersBeforeFSP(context);
                        if (looted) {
                            currentStamina = context.stamina.getCurrent();
                            logger.info(`ðŸ’€ [LOOT DEAD] Loot concluÃ­do! Nova stamina: ${currentStamina}`);
                            if (currentStamina >= skillCost) {
                                logger.info(`ðŸŽ‰ Stamina recuperada (${currentStamina})! Continuando ataques...`);
                                await this.ensureAliveMonstersView(context);
                                continue; // Continuar loop de ataques
                            }
                            logger.info(`ðŸ’€ [LOOT DEAD] Stamina ainda baixa (${currentStamina}/${skillCost}). Tentando FSP...`);
                        }
                        // Se retornou false, a flag jÃ¡ foi setada dentro da funÃ§Ã£o
                    } else if (skipLootDead) {
                        logger.info('ðŸ’€ [LOOT DEAD] Flag detectada - pulando loot dead, indo direto para FSP...');
                        sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                    }
                    
                    // Re-check stamina after loot dead attempt
                    currentStamina = context.stamina.getCurrent();
                    
                    // Tentar usar FSP se stamina ainda insuficiente
                    if (currentStamina < skillCost) {
                        logger.info(`ðŸ’Š [FSP] autoFSP=${ultraCfg.autoFSP} - Verificando opÃ§Ã£o FSP...`);
                        if (!ultraCfg.autoFSP) {
                            logger.info('ðŸ’Š [FSP] autoFSP estÃ¡ DESATIVADO. NÃ£o usarÃ¡ FSP.');
                        } else {
                            logger.info('ðŸ’Š [FSP] Usando Full Stamina Potion...');
                            const fspUsed = await context.inventory.useFullStaminaPotion();
                            if (fspUsed) {
                                logger.info('ðŸ’Š [FSP] FSP usada com sucesso! Recarregando pÃ¡gina...');
                                sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                                await sleep(500);
                                window.location.reload();
                                return;
                            } else {
                                logger.info('ðŸ’Š [FSP] Falha ao usar FSP ou sem FSP disponÃ­vel.');
                            }
                        }
                        
                        logger.info('â³ Sem opÃ§Ãµes de recuperaÃ§Ã£o. Parando ataques.');
                        break;
                    } else {
                        // Stamina recovered by loot dead
                        logger.info(`âœ… Stamina recuperada por loot dead (${currentStamina}). Continuando...`);
                        continue;
                    }
                }
                
                // Filter active targets (not completed, not dead)
                const activeTargets = targetStates.filter(t => !t.completed && !t.dead);
                
                if (activeTargets.length === 0) {
                    logger.info(`âœ… Todos os alvos completados ou mortos`);
                    break;
                }
                
                // Re-read stamina before calculating batch (stamina updates after attacks)
                currentStamina = context.stamina.getCurrent();
                
                // Calculate batch size based on stamina
                const possibleAttacks = Math.floor(currentStamina / skillCost);
                const batchSize = Math.min(possibleAttacks, parallelAttacks, activeTargets.length);
                
                if (batchSize <= 0) break;
                
                // Select targets for this batch (round-robin)
                const batchTargets = activeTargets.slice(0, batchSize);
                
                logger.debug(`âš”ï¸ Rodada ${rounds}: Atacando ${batchTargets.length} monstros em PARALELO...`);
                
                // Prepare attack promises
                const attackPromises = batchTargets.map(targetState => ({
                    targetState,
                    execute: () => this.sendWaveAttack(context, targetState.monsterId, skillId)
                }));
                
                // Execute all attacks simultaneously
                const startTime = Date.now();
                const results = await Promise.all(
                    attackPromises.map(async ({ targetState, execute }) => {
                        try {
                            const result = await execute();
                            return { targetState, result };
                        } catch (error) {
                            return { targetState, result: { success: false, error: error.message } };
                        }
                    })
                );
                const duration = Date.now() - startTime;
                
                // Process results
                let successCount = 0;
                let totalBatchDamage = 0;
                
                for (const { targetState, result } of results) {
                    if (result.success) {
                        const damageDealt = result.damageDealt || 0;
                        targetState.currentDamage += damageDealt;
                        targetState.attackCount++;
                        totalBatchDamage += damageDealt;
                        successCount++;
                        
                        this.state.ultraFastStats.attackCount++;
                        this.state.ultraFastStats.damageDealt += damageDealt;
                        
                        // Check if target reached (use individual effective target)
                        const targetDamage = targetState.effectiveDamageTarget || baseDamageTarget;
                        if (targetState.currentDamage >= targetDamage) {
                            targetState.completed = true;
                            const specialIcon = isSpecialBoss(targetState.name) ? 'ðŸ‘‘ ' : '';
                            logger.info(`âœ… ${specialIcon}${targetState.name}: Alvo atingido! ${formatNumber(targetState.currentDamage)} dano em ${targetState.attackCount} ataques`);
                            this.state.ultraFastStats.monstersCompleted++;
                        }
                        
                        // Update stamina display
                        if (result.stamina !== undefined) {
                            const staminaEl = document.querySelector('#stamina_span');
                            if (staminaEl) staminaEl.textContent = result.stamina.toLocaleString();
                        }
                    } else if (result.dead) {
                        targetState.dead = true;
                        logger.info(`ðŸ’€ ${targetState.name}: Monstro morto/invÃ¡lido`);
                        this.state.ultraFastStats.monstersCompleted++;
                    }
                }
                
                if (successCount > 0) {
                    logger.debug(`  ${successCount} hits, +${formatNumber(totalBatchDamage)} dano (${duration}ms)`);
                    roundsWithoutProgress = 0; // Reset counter on success
                } else {
                    roundsWithoutProgress++;
                    logger.warn(`âš ï¸ Rodada ${rounds}: Nenhum ataque bem-sucedido (${batchTargets.length} tentativas)`);
                    
                    // Check stamina again - might have been consumed without success
                    const currentStaminaCheck = context.stamina.getCurrent();
                    if (currentStaminaCheck < skillCost) {
                        logger.warn(`â³ Stamina insuficiente apÃ³s rodada (${currentStaminaCheck}/${skillCost})`);
                        break;
                    }
                    
                    // Check if stuck in loop without progress
                    if (roundsWithoutProgress >= maxRoundsWithoutProgress) {
                        logger.warn(`âŒ ${maxRoundsWithoutProgress} rodadas sem progresso. Parando ataques.`);
                        break;
                    }
                }
                
                // Small delay between rounds
                await sleep(ultraCfg.minDelayBetweenAttacks || 30);
            }
            
            // Summary
            for (const t of targetStates) {
                if (!t.completed && !t.dead && t.attackCount > 0) {
                    logger.info(`â¸ï¸ ${t.name}: ${formatNumber(t.currentDamage)}/${formatNumber(t.effectiveDamageTarget || baseDamageTarget)} (${t.attackCount} ataques)`);
                }
            }
        },
        
        async attackOngoingBattles(context, cfg) {
            const { logger, dom } = context;
            const ultraCfg = cfg.wave.ultraFastConfig || {};
            const skillId = ultraCfg.skillId ?? -2;
            const parallelAttacks = ultraCfg.parallelAttacks || 10;
            const baseDamageTarget = ultraCfg.damageTarget || 3000000;
            const skillCosts = { '0': 1, '-1': 10, '-2': 50, '-3': 100, '-4': 200 };
            const skillCost = skillCosts[skillId.toString()] || 1;
            
            // Find ongoing battles
            const cards = dom.queryAll('.monster-card');
            const ongoingTargets = [];
            
            for (const card of cards) {
                const button = card.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button');
                const buttonText = button?.textContent?.toLowerCase() || '';
                
                if (!buttonText.includes('continue')) continue;
                
                // Get battle link
                const link = card.querySelector('a[href*="battle.php"][href*="id="]');
                const battleUrl = link?.href;
                const monsterIdMatch = battleUrl?.match(/[?&]id=(\d+)/);
                const monsterId = monsterIdMatch ? monsterIdMatch[1] : null;
                
                if (!monsterId) continue;
                
                // Extract monster name
                const nameNode = card.querySelector('h3, h4, .monster-name, .card-title');
                const name = nameNode ? nameNode.textContent.trim() : 'Unknown';
                
                ongoingTargets.push({ name, monsterId, battleUrl, currentDamage: 0 });
            }
            
            if (ongoingTargets.length === 0) {
                return;
            }
            
            // 1. Fetch current damage for all ongoing battles
            await this.fetchCurrentDamages(context, ongoingTargets);
            
            // 2. Filter out targets that already reached threshold
            // Apply special boss logic: General/King/Empress/Bastion need 50M minimum
            const validTargets = ongoingTargets.filter(t => {
                if (t.invalid) {
                    logger.debug(`â­ï¸ ${t.name}: Batalha invÃ¡lida, pulando`);
                    return false;
                }
                
                // Get effective damage target for this monster
                const effectiveDamageTarget = getEffectiveDamageTarget(t.name, baseDamageTarget);
                t.effectiveDamageTarget = effectiveDamageTarget;
                
                if (isSpecialBoss(t.name) && effectiveDamageTarget > baseDamageTarget) {
                    logger.info(`ðŸ‘‘ ${t.name}: Boss especial detectado - alvo: ${formatNumber(effectiveDamageTarget)} (mÃ­nimo 50M para loot)`);
                }
                
                if ((t.currentDamage || 0) >= effectiveDamageTarget) {
                    logger.info(`âœ… ${t.name}: JÃ¡ atingiu threshold (${formatNumber(t.currentDamage)}/${formatNumber(effectiveDamageTarget)})`);
                    this.state.ultraFastStats.monstersCompleted++;
                    return false;
                }
                return true;
            });
            
            if (validTargets.length === 0) {
                logger.info(`âœ… Todas as batalhas em andamento jÃ¡ atingiram o threshold`);
                return;
            }
            
            logger.info(`ðŸš€ PRE-FLIGHT: ${validTargets.length} batalha(s) precisam de ataque...`);
            
            // Use same strategy as attackUltraFastBattles but with ongoing targets
            const targetStates = validTargets.map(t => ({
                ...t,
                currentDamage: t.currentDamage || 0, // Preserve existing damage
                attackCount: 0,
                completed: false,
                dead: false,
                effectiveDamageTarget: t.effectiveDamageTarget || baseDamageTarget
            }));
            
            let rounds = 0;
            const maxRounds = 100;
            
            while (rounds < maxRounds) {
                rounds++;
                
                const currentStamina = context.stamina.getCurrent();
                if (currentStamina < skillCost) {
                    logger.info(`â³ Stamina insuficiente (${currentStamina}/${skillCost}). Tentando recuperar...`);
                    
                    // ðŸ†• Verificar se jÃ¡ tentamos loot dead e devemos ir direto para FSP
                    const skipLootDead = sessionStorage.getItem('autods_skip_loot_dead_use_fsp');
                    
                    // ðŸ†• Tentar loot de dead monsters para possÃ­vel level up
                    if (ultraCfg.lootDeadBeforeFSP !== false && !skipLootDead) {
                        logger.info('ðŸ’€ [LOOT DEAD] Tentando lootar dead monsters...');
                        const looted = await this.tryLootDeadMonstersBeforeFSP(context);
                        if (looted) {
                            const newStamina = context.stamina.getCurrent();
                            logger.info(`ðŸ’€ [LOOT DEAD] Loot concluÃ­do! Nova stamina: ${newStamina}`);
                            if (newStamina >= skillCost) {
                                logger.info(`ðŸŽ‰ Stamina recuperada (${newStamina})! Continuando ataques...`);
                                await this.ensureAliveMonstersView(context);
                                continue; // Continuar loop de ataques
                            }
                            logger.info(`ðŸ’€ [LOOT DEAD] Stamina ainda baixa (${newStamina}). Tentando FSP...`);
                        }
                        // Se retornou false, a flag jÃ¡ foi setada dentro da funÃ§Ã£o
                    } else if (skipLootDead) {
                        logger.info('ðŸ’€ [LOOT DEAD] Flag detectada - pulando loot dead, indo direto para FSP...');
                        sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                    }
                    
                    // Tentar usar FSP se disponÃ­vel
                    logger.info(`ðŸ’Š [FSP] autoFSP=${ultraCfg.autoFSP} - Verificando opÃ§Ã£o FSP...`);
                    if (!ultraCfg.autoFSP) {
                        logger.info('ðŸ’Š [FSP] autoFSP estÃ¡ DESATIVADO. NÃ£o usarÃ¡ FSP.');
                    } else {
                        logger.info('ðŸ’Š [FSP] Usando Full Stamina Potion...');
                        const fspUsed = await context.inventory.useFullStaminaPotion();
                        if (fspUsed) {
                            logger.info('ðŸ’Š [FSP] FSP usada com sucesso! Recarregando pÃ¡gina...');
                            sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                            await sleep(500);
                            window.location.reload();
                            return;
                        } else {
                            logger.info('ðŸ’Š [FSP] Falha ao usar FSP ou sem FSP disponÃ­vel.');
                        }
                    }
                    
                    logger.info('â³ Sem opÃ§Ãµes de recuperaÃ§Ã£o. Parando ataques.');
                    break;
                }
                
                const activeTargets = targetStates.filter(t => !t.completed && !t.dead);
                
                if (activeTargets.length === 0) {
                    logger.info(`âœ… Todos os alvos completados ou mortos`);
                    break;
                }
                
                const possibleAttacks = Math.floor(currentStamina / skillCost);
                const batchSize = Math.min(possibleAttacks, parallelAttacks, activeTargets.length);
                
                if (batchSize <= 0) break;
                
                const batchTargets = activeTargets.slice(0, batchSize);
                
                // Use GM_xmlhttpRequest via sendWaveAttack
                const attackPromises = batchTargets.map(targetState => ({
                    targetState,
                    execute: () => this.sendWaveAttack(context, targetState.monsterId, skillId)
                }));
                
                const startTime = Date.now();
                const results = await Promise.all(
                    attackPromises.map(async ({ targetState, execute }) => {
                        try {
                            const result = await execute();
                            return { targetState, result };
                        } catch (error) {
                            return { targetState, result: { success: false, error: error.message } };
                        }
                    })
                );
                const duration = Date.now() - startTime;
                
                let successCount = 0;
                let totalBatchDamage = 0;
                
                for (const { targetState, result } of results) {
                    if (result.success) {
                        const damageDealt = result.damageDealt || 0;
                        targetState.currentDamage += damageDealt;
                        targetState.attackCount++;
                        totalBatchDamage += damageDealt;
                        successCount++;
                        
                        this.state.ultraFastStats.attackCount++;
                        this.state.ultraFastStats.damageDealt += damageDealt;
                        
                        // Check if target reached (use individual effective target)
                        const targetDamage = targetState.effectiveDamageTarget || baseDamageTarget;
                        if (targetState.currentDamage >= targetDamage) {
                            targetState.completed = true;
                            const specialIcon = isSpecialBoss(targetState.name) ? 'ðŸ‘‘ ' : '';
                            logger.info(`âœ… ${specialIcon}${targetState.name}: Alvo atingido! ${formatNumber(targetState.currentDamage)} dano`);
                            this.state.ultraFastStats.monstersCompleted++;
                        }
                        
                        if (result.stamina !== undefined) {
                            const staminaEl = document.querySelector('#stamina_span');
                            if (staminaEl) staminaEl.textContent = result.stamina.toLocaleString();
                        }
                    } else if (result.dead) {
                        targetState.dead = true;
                        logger.info(`ðŸ’€ ${targetState.name}: Monstro morto/invÃ¡lido`);
                        this.state.ultraFastStats.monstersCompleted++;
                    }
                }
                
                if (successCount > 0) {
                    logger.debug(`  Rodada ${rounds}: ${successCount} hits, +${formatNumber(totalBatchDamage)} dano (${duration}ms)`);
                }
                
                await sleep(ultraCfg.minDelayBetweenAttacks || 30);
            }
            
            // Summary
            for (const t of targetStates) {
                if (!t.completed && !t.dead && t.attackCount > 0) {
                    logger.info(`â¸ï¸ ${t.name}: ${formatNumber(t.currentDamage)}/${formatNumber(t.effectiveDamageTarget || baseDamageTarget)} (${t.attackCount} ataques)`);
                }
            }
        },
        
        async runLoop(context) {
            const { logger } = context;
            while (/active_wave\.php/i.test(context.location.pathname)) {
                const currentUrl = context.window?.location?.href || window.location.href;
                if (currentUrl && this.state.lastWaveUrl !== currentUrl) {
                    this.state.lastWaveUrl = currentUrl;
                    context.storage.set(STORAGE_KEYS.lastWaveUrl, currentUrl);
                }

                const cfg = context.config.get();
                if (!cfg.core.enabled || cfg.wave?.enabled === false) {
                    logger.info('AutomaÃ§Ã£o de ondas desativada via configuraÃ§Ã£o.');
                    break;
                }

                const waitingStamina = await this.ensureStamina(context, cfg);
                if (waitingStamina) {
                    continue;
                }

                const result = this.scanAndJoin(context, cfg);
                if (result === 'joined') {
                    await sleepRandom(cfg.battle?.delayBaseMs ?? 1200, cfg.battle?.delayVariation ?? 0.25, cfg.battle?.randomizeDelays ?? true);
                    break; // NavegaÃ§Ã£o para a batalha assume o controle.
                }

                // âš ï¸ SAFE MODE: Mais de 10 continues, aguardar sem fazer joins
                if (result?.status === 'safeMode') {
                    const safeWaitInterval = 10000; // 10 segundos
                    logger.warn(`â³ Safe Mode ativo: ${result.continueCount} batalhas simultÃ¢neas. Aguardando ${Math.round(safeWaitInterval / 1000)}s...`);
                    context.events.emit('autods:wave:safeMode', {
                        continueCount: result.continueCount,
                        waitInterval: safeWaitInterval,
                        timestamp: Date.now()
                    });
                    await sleep(safeWaitInterval);
                    context.window.location.reload();
                    return;
                }

                if (result?.status === 'maxBattles' || result === 'maxBattles') {
                    const reloadInterval = cfg.wave?.maxBattlesReloadMs ?? 30000; // 30 segundos padrÃ£o
                    context.events.emit('autods:wave:maxBattles', {
                        continueCount: result.continueCount || 5,
                        limit: cfg.wave.maxConcurrentBattles ?? 5,
                        reloadInterval,
                        timestamp: Date.now()
                    });
                    logger.info(`Aguardando ${Math.round(reloadInterval / 1000)}s antes de recarregar a pÃ¡gina...`);
                    await sleepRandom(reloadInterval, 0.1, true);
                    context.events.emit('autods:wave:reloading', { timestamp: Date.now() });
                    logger.info('Recarregando pÃ¡gina para verificar batalhas disponÃ­veis...');
                    context.window.location.reload();
                    return; // Aguarda o reload
                }

                logger.debug('Nenhum alvo elegÃ­vel. Nova varredura em 15s.');
                await sleepRandom(15000, cfg.battle?.delayVariation ?? 0.25, cfg.battle?.randomizeDelays ?? true);
            }
        },
        async ensureStamina(context, cfg) {
            if (!cfg.stamina) return false;
            const staminaNode = context.dom.query('#stamina_span, [data-player-stamina]');
            if (!staminaNode) return false;
            const staminaText = staminaNode.getAttribute?.('data-player-stamina') ?? staminaNode.textContent ?? '';
            const currentStamina = numberFromText(staminaText);
            const threshold = cfg.stamina.minThreshold ?? 0;
            if (currentStamina !== null && currentStamina < threshold) {
                if (!this.state.staminaWaiting) {
                    context.logger.warn(`Stamina baixa (${formatNumber(currentStamina)} < ${formatNumber(threshold)}). Aguardando regeneraÃ§Ã£o.`);
                    this.state.staminaWaiting = true;
                }
                await sleepRandom(cfg.stamina.checkIntervalMs ?? 300000, 0.05, true);
                return true;
            }
            if (this.state.staminaWaiting) {
                context.logger.info('Stamina recuperada; retomando varredura de ondas.');
                this.state.staminaWaiting = false;
            }
            return false;
        },
        scanAndJoin(context, cfg) {
            const { logger, dom } = context;
            const cards = dom.queryAll('.monster-card');
            if (!cards.length) {
                logger.debug('Nenhum card de monstro encontrado na tela de ondas.');
                return 'noEligible';
            }

            const continueCount = cards.reduce((count, card) => {
                // Updated selector to include new button structure
                const button = card.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button');
                if (button && /continue/i.test(button.textContent || '')) {
                    return count + 1;
                }
                return count;
            }, 0);

            const limit = cfg.wave.maxConcurrentBattles ?? 5;
            
            // âš ï¸ SEGURANÃ‡A: Se mais de 10 continues, apenas verificar dano (nÃ£o fazer joins)
            if (continueCount > 10) {
                logger.warn(`âš ï¸ MUITAS BATALHAS ATIVAS (${continueCount} > 10)! Modo seguro: aguardando completar batalhas.`);
                logger.info('ðŸ’¡ NÃ£o serÃ¡ feito join em novos monstros para evitar sobrecarga do servidor.');
                return { status: 'safeMode', continueCount };
            }
            
            if (continueCount >= limit) {
                if (!this.state.notifiedMaxBattles) {
                    logger.info(`MÃ¡ximo de batalhas simultÃ¢neas em andamento (${continueCount}/${limit}).`);
                    this.state.notifiedMaxBattles = true;
                }
                return { status: 'maxBattles', continueCount };
            }
            this.state.notifiedMaxBattles = false;

            // Parse monsterNames from CSV format (string) to array
            let monsterNamesList = [];
            if (cfg.wave.monsterNames) {
                if (Array.isArray(cfg.wave.monsterNames)) {
                    // Already an array
                    monsterNamesList = cfg.wave.monsterNames.filter(Boolean);
                } else if (typeof cfg.wave.monsterNames === 'string') {
                    // Parse CSV string: split by newlines or commas
                    monsterNamesList = cfg.wave.monsterNames
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                }
            }

            const filters = Array.isArray(monsterNamesList)
                ? monsterNamesList.filter(Boolean).map(name => name.toLowerCase())
                : [];

            const candidates = cards.map((card, index) => {
                const nameNode = card.querySelector('h3, h4, .monster-name, .card-title');
                const rawName = nameNode ? nameNode.textContent.trim() : 'Unknown';
                const hpNode = card.querySelector('[data-stat="hp"], .hp-text, .hp-value, .monster-hp, .hp-bar + div, .hp');
                const hpText = hpNode ? hpNode.getAttribute?.('data-current-hp') ?? hpNode.textContent ?? '' : '';
                const hp = numberFromText(hpText);
                // Updated selector to include new button structure: .btn-join, #join-battle
                const button = card.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button');
                const link = card.querySelector('a[href*="battle.php"][href*="id="]');
                const action = button || link;
                const actionType = button ? (/(?:\bcontinue\b)/i.test(button.textContent || '') ? 'continue' : 'join') : 'link';
                return {
                    card,
                    index,
                    name: rawName,
                    nameLower: rawName.toLowerCase(),
                    hp,
                    action,
                    actionType
                };
            }).filter(monster => {
                if (!monster.action) return false;
                if (monster.actionType === 'continue') return false;
                if (filters.length && !filters.some(filter => monster.nameLower.includes(filter))) return false;
                if (monster.hp !== null && cfg.wave.minMobHp && monster.hp < cfg.wave.minMobHp) return false;
                return true;
            });

            if (!candidates.length) {
                logger.debug('Nenhum monstro elegÃ­vel apÃ³s aplicar filtros de nome/HP.');
                return 'noEligible';
            }

            const target = pickTarget(candidates, cfg.wave.priorityMode);
            if (!target) {
                logger.debug('Nenhum alvo selecionado pelo modo de prioridade.');
                return 'noEligible';
            }

            logger.info(`Entrando em ${target.name} (HP ~ ${formatNumber(target.hp)})`);
            context.events.emit('autods:wave:join', {
                monster: target.name,
                hp: target.hp,
                timestamp: Date.now()
            });
            const waveUrl = context.window?.location?.href || window.location.href;
            if (waveUrl) {
                this.state.lastWaveUrl = waveUrl;
                context.storage.set(STORAGE_KEYS.lastWaveUrl, waveUrl);
            }

            // Join battle directly via API if possible
            const userId = cfg.core?.userId;
            const link = target.card.querySelector('a[href*="battle.php"][href*="id="]');
            const battleUrl = link?.href;
            const monsterIdMatch = battleUrl?.match(/[?&]id=(\d+)/);
            const monsterId = monsterIdMatch ? monsterIdMatch[1] : null;

            if (userId && monsterId) {
                (async () => {
                    try {
                        logger.info(`ðŸŽ¯ Tentando join direto na batalha ${monsterId}...`);
                        const result = await context.http.joinBattle(monsterId, userId);
                        
                        // VERIFICAÃ‡ÃƒO INTELIGENTE: Se Cloudflare bloqueou, usar mÃ©todo tradicional
                        if (result.cloudflareBlock) {
                            logger.warn(`âš ï¸ Cloudflare bloqueou requisiÃ§Ã£o direta. Usando mÃ©todo tradicional (click).`);
                            if (target.action instanceof HTMLElement) {
                                target.action.click();
                            } else if (battleUrl) {
                                window.location.href = battleUrl;
                            }
                            return;
                        }
                        
                        if (result.success) {
                            logger.info(`âœ… ${result.message}`);
                            // Navigate to battle page after successful join
                            if (battleUrl) {
                                window.location.href = battleUrl;
                            } else if (target.action instanceof HTMLElement) {
                                target.action.click();
                            }
                        } else {
                            logger.warn(`âš ï¸ Join direto falhou: ${result.message}. Usando mÃ©todo tradicional.`);
                            // Fallback to traditional join
                            if (target.action instanceof HTMLElement) {
                                target.action.click();
                            } else if (battleUrl) {
                                window.location.href = battleUrl;
                            }
                        }
                    } catch (error) {
                        logger.error(`Erro no join direto: ${error.message}`);
                        // Fallback to traditional join
                        if (target.action instanceof HTMLElement) {
                            target.action.click();
                        } else if (battleUrl) {
                            window.location.href = battleUrl;
                        }
                    }
                })();
            } else {
                // No userId or monsterId, use traditional method
                logger.debug(`Usando mÃ©todo tradicional (userId: ${userId}, monsterId: ${monsterId})`);
                if (target.action instanceof HTMLElement) {
                    target.action.click();
                } else if (target.action && typeof target.action.href === 'string') {
                    window.location.href = target.action.href;
                }
            }

            this.state.lastTarget = { name: target.name, hp: target.hp, timestamp: Date.now() };
            return 'joined';
        }
    };

    const waveUiModule = {
        id: 'waveUiEnhancements',
        match: ({ location }) => /active_wave\.php/i.test(location.pathname),
        init() {
            this.state = {
                continueBattlesExpanded: true,
                lootExpanded: true,
                filterSettings: {
                    nameFilter: '',
                    hideImg: false,
                    sortOrder: 'default'
                }
            };
        },
        activate(context) {
            if (!this.state) this.init(context);

            // Wait for DOM to be ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    this.initMonsterSorting(context);
                    this.initMonsterFilter(context);
                });
            } else {
                this.initMonsterSorting(context);
                this.initMonsterFilter(context);
            }
        },
        initMonsterFilter(context) {
            const monsterContainer = context.dom.query('.monster-container');
            if (!monsterContainer) return;

            // Load saved filter settings
            const savedSettings = context.storage.get('waveFilterSettings', this.state.filterSettings);
            this.state.filterSettings = { ...this.state.filterSettings, ...savedSettings };

            const filterContainer = document.createElement('div');
            filterContainer.style.cssText = `
                padding: 10px;
                background: rgba(30, 30, 46, 0.8);
                border-radius: 8px;
                margin-bottom: 15px;
                display: flex;
                gap: 10px;
                align-items: center;
                justify-content: center;
                flex-wrap: wrap;
                border: 1px solid rgba(70, 130, 220, 0.3);
            `;

            filterContainer.innerHTML = `
                <input type="text" id="monster-name-filter" placeholder="Filter by monster name..."
                    value="${this.state.filterSettings.nameFilter}"
                    style="padding: 8px 12px; background: rgba(20, 30, 50, 0.8); color: #e0e0e0;
                    border: 1px solid rgba(70, 130, 220, 0.4); border-radius: 6px; min-width: 200px;
                    font-size: 13px; transition: all 0.2s;">
                <select id="monster-sort-order"
                    style="padding: 8px 12px; background: rgba(20, 30, 50, 0.8); color: #e0e0e0;
                    border: 1px solid rgba(70, 130, 220, 0.4); border-radius: 6px; font-size: 13px;
                    cursor: pointer; transition: all 0.2s;">
                    <option value="default" ${this.state.filterSettings.sortOrder === 'default' ? 'selected' : ''}>Default Order</option>
                    <option value="hp-asc" ${this.state.filterSettings.sortOrder === 'hp-asc' ? 'selected' : ''}>HP: Low â†’ High</option>
                    <option value="hp-desc" ${this.state.filterSettings.sortOrder === 'hp-desc' ? 'selected' : ''}>HP: High â†’ Low</option>
                    <option value="name-asc" ${this.state.filterSettings.sortOrder === 'name-asc' ? 'selected' : ''}>Name: A â†’ Z</option>
                    <option value="name-desc" ${this.state.filterSettings.sortOrder === 'name-desc' ? 'selected' : ''}>Name: Z â†’ A</option>
                </select>
                <label style="display: flex; align-items: center; gap: 6px; color: #b8c5d6; cursor: pointer;">
                    <input type="checkbox" id="hide-img-monsters" ${this.state.filterSettings.hideImg ? 'checked' : ''}
                        style="cursor: pointer; width: 16px; height: 16px;">
                    <span style="font-size: 13px;">Hide images</span>
                </label>
                <button id="clear-filters"
                    style="padding: 8px 16px; background: linear-gradient(135deg, rgba(243, 139, 168, 0.6), rgba(203, 116, 139, 0.7));
                    color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;
                    transition: all 0.2s; box-shadow: 0 2px 8px rgba(0,0,0,0.2);">
                    Clear Filters
                </button>
            `;

            const contentArea = context.dom.query('.content-area') || monsterContainer.parentElement;
            if (contentArea) {
                contentArea.insertBefore(filterContainer, monsterContainer);
            }

            // Apply saved filters immediately
            if (this.state.filterSettings.nameFilter || this.state.filterSettings.hideImg) {
                setTimeout(() => this.applyMonsterFilters(context), 100);
            }
            
            // Apply saved sort order immediately
            if (this.state.filterSettings.sortOrder && this.state.filterSettings.sortOrder !== 'default') {
                setTimeout(() => this.applySortOrder(context), 150);
            }

            // Event listeners
            const nameInput = document.getElementById('monster-name-filter');
            const sortSelect = document.getElementById('monster-sort-order');
            const hideImgCheck = document.getElementById('hide-img-monsters');
            const clearBtn = document.getElementById('clear-filters');

            if (nameInput) {
                nameInput.addEventListener('input', () => {
                    this.state.filterSettings.nameFilter = nameInput.value;
                    context.storage.set('waveFilterSettings', this.state.filterSettings);
                    this.applyMonsterFilters(context);
                });
            }

            if (sortSelect) {
                sortSelect.addEventListener('change', () => {
                    this.state.filterSettings.sortOrder = sortSelect.value;
                    context.storage.set('waveFilterSettings', this.state.filterSettings);
                    this.applySortOrder(context);
                });
            }

            if (hideImgCheck) {
                hideImgCheck.addEventListener('change', () => {
                    this.state.filterSettings.hideImg = hideImgCheck.checked;
                    context.storage.set('waveFilterSettings', this.state.filterSettings);
                    this.applyMonsterFilters(context);
                });
            }

            if (clearBtn) {
                clearBtn.addEventListener('click', () => {
                    this.state.filterSettings = { nameFilter: '', hideImg: false, sortOrder: 'default' };
                    context.storage.set('waveFilterSettings', this.state.filterSettings);
                    if (nameInput) nameInput.value = '';
                    if (sortSelect) sortSelect.value = 'default';
                    if (hideImgCheck) hideImgCheck.checked = false;
                    this.applyMonsterFilters(context);
                    this.applySortOrder(context);
                    context.ui?.showToast?.(context, 'info', 'Filters Cleared', 'All filters have been reset');
                });
            }
        },
        applyMonsterFilters(context) {
            const nameFilter = this.state.filterSettings.nameFilter.toLowerCase();
            const hideImg = this.state.filterSettings.hideImg;
            const monsters = context.dom.queryAll('.monster-card');

            monsters.forEach(monster => {
                let shouldShow = true;

                // Name filter
                if (nameFilter) {
                    const nameNode = context.dom.query('h3, h4, .monster-name, .card-title', monster);
                    const monsterName = nameNode ? nameNode.textContent.toLowerCase() : '';
                    shouldShow = monsterName.includes(nameFilter);
                }

                // Image hiding
                if (hideImg) {
                    const img = context.dom.query('img', monster);
                    if (img) img.style.display = 'none';
                } else {
                    const img = context.dom.query('img', monster);
                    if (img) img.style.display = '';
                }

                monster.style.display = shouldShow ? '' : 'none';
            });
        },
        applySortOrder(context) {
            const sortOrder = this.state.filterSettings.sortOrder || 'default';
            if (sortOrder === 'default') return;

            // Ordena monstros dentro de cada seÃ§Ã£o individualmente
            const sections = ['continue', 'loot', 'join'];
            
            sections.forEach(sectionType => {
                const sectionContent = context.dom.query(`[data-content="${sectionType}"]`);
                if (!sectionContent) return;

                // Busca o container interno dentro da seÃ§Ã£o
                const sectionContainer = context.dom.query('.monster-container', sectionContent);
                if (!sectionContainer) return;

                const monsters = context.dom.queryAll('.monster-card', sectionContainer);
                if (monsters.length === 0) return;

                // Extract monster data for sorting
                const monsterData = monsters.map(card => {
                    const nameNode = context.dom.query('h3, h4, .monster-name, .card-title', card);
                    const name = nameNode ? nameNode.textContent.trim() : '';
                    
                    // Extract HP from progress bar or HP text
                    let currentHp = 0;
                    let maxHp = 0;
                    
                    // Try HP text first (e.g., "1,234,567 / 2,000,000 HP")
                    const hpText = card.querySelector('.hp-text, .monster-hp, .stat-value');
                    if (hpText) {
                        const hpMatch = hpText.textContent.match(/([0-9,]+)\s*\/\s*([0-9,]+)/);
                        if (hpMatch) {
                            currentHp = parseInt(hpMatch[1].replace(/,/g, ''), 10);
                            maxHp = parseInt(hpMatch[2].replace(/,/g, ''), 10);
                        }
                    }
                    
                    // Try progress bar width as fallback
                    if (currentHp === 0) {
                        const hpBar = card.querySelector('.progress-bar, .hp-bar, .hp-fill, [role="progressbar"]');
                        if (hpBar) {
                            const width = hpBar.style.width;
                            const percentMatch = width.match(/([0-9.]+)%/);
                            if (percentMatch) {
                                const percent = parseFloat(percentMatch[1]);
                                if (!isNaN(percent) && maxHp > 0) {
                                    currentHp = Math.round((percent / 100) * maxHp);
                                }
                            }
                        }
                    }

                    return { card, name, currentHp, maxHp };
                });

                // Sort based on order
                switch (sortOrder) {
                    case 'hp-asc':
                        monsterData.sort((a, b) => a.currentHp - b.currentHp);
                        break;
                    case 'hp-desc':
                        monsterData.sort((a, b) => b.currentHp - a.currentHp);
                        break;
                    case 'name-asc':
                        monsterData.sort((a, b) => a.name.localeCompare(b.name));
                        break;
                    case 'name-desc':
                        monsterData.sort((a, b) => b.name.localeCompare(a.name));
                        break;
                }

                // Re-append cards in sorted order to the section container
                monsterData.forEach(({ card }) => {
                    sectionContainer.appendChild(card);
                });
            });

            // context.logger.debug(`[WaveUI] Sorted monsters by ${sortOrder} within each section`);
        },
        initMonsterSorting(context) {
            const monsterContainer = context.dom.query('.monster-container');
            if (!monsterContainer) return;

            // Load saved expansion states
            const savedStates = context.storage.get('waveSectionStates', {
                continueBattlesExpanded: this.state.continueBattlesExpanded,
                lootExpanded: this.state.lootExpanded
            });
            this.state.continueBattlesExpanded = savedStates.continueBattlesExpanded;
            this.state.lootExpanded = savedStates.lootExpanded;

            const continueBattleSection = document.createElement('div');
            continueBattleSection.className = 'monster-section';
            continueBattleSection.innerHTML = `
                <div class="monster-section-header" data-section="continue">
                    <h3 style="color: #f38ba8; margin: 0; flex: 1;">
                        âš”ï¸ Continue Battle 
                        <span class="section-count" data-count="continue" style="
                            background: rgba(243, 139, 168, 0.3);
                            padding: 2px 8px;
                            border-radius: 12px;
                            font-size: 12px;
                            margin-left: 8px;
                            border: 1px solid rgba(243, 139, 168, 0.5);
                        ">0</span>
                    </h3>
                    <button class="section-toggle-btn" data-toggle="continue">${this.state.continueBattlesExpanded ? 'âˆ’' : '+'}</button>
                </div>
                <div class="monster-section-content" data-content="continue" style="display: ${this.state.continueBattlesExpanded ? 'block' : 'none'};">
                    <div class="monster-container" style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px;"></div>
                </div>
            `;

            const lootSection = document.createElement('div');
            lootSection.className = 'monster-section';
            lootSection.innerHTML = `
                <div class="monster-section-header" data-section="loot">
                    <h3 style="color: #f9e2af; margin: 0; flex: 1;">
                        ðŸ’° Available Loot
                        <span class="section-count" data-count="loot" style="
                            background: rgba(249, 226, 175, 0.3);
                            padding: 2px 8px;
                            border-radius: 12px;
                            font-size: 12px;
                            margin-left: 8px;
                            border: 1px solid rgba(249, 226, 175, 0.5);
                        ">0</span>
                    </h3>
                    <button class="section-toggle-btn" data-toggle="loot">${this.state.lootExpanded ? 'âˆ’' : '+'}</button>
                </div>
                <div class="monster-section-content" data-content="loot" style="display: ${this.state.lootExpanded ? 'block' : 'none'};">
                    <div class="monster-container" style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px;"></div>
                </div>
            `;

            const joinBattleSection = document.createElement('div');
            joinBattleSection.className = 'monster-section';
            joinBattleSection.innerHTML = `
                <div class="monster-section-header">
                    <h3 style="color: #a6e3a1; margin: 0; flex: 1;">
                        âš¡ Join a Battle
                        <span class="section-count" data-count="join" style="
                            background: rgba(166, 227, 161, 0.3);
                            padding: 2px 8px;
                            border-radius: 12px;
                            font-size: 12px;
                            margin-left: 8px;
                            border: 1px solid rgba(166, 227, 161, 0.5);
                        ">0</span>
                    </h3>
                </div>
                <div class="monster-section-content" data-content="join">
                    <div class="monster-container" style="display: flex; flex-wrap: wrap; gap: 15px;"></div>
                </div>
            `;

            // Categorize monsters based on button text
            const monsterCards = Array.from(context.dom.queryAll('.monster-card'));
            const continueCards = [];
            const lootCards = [];
            const joinCards = [];

            monsterCards.forEach(card => {
                // Try multiple selectors for buttons
                const button = card.querySelector('.join-btn, button.join-btn, .btn, button, a.btn');
                const buttonText = button ? button.textContent.toLowerCase().trim() : '';

                // Check button text to categorize (priority order: Continue > Loot > Join)
                if (buttonText.includes('continue')) {
                    continueCards.push(card);
                } else if (buttonText.includes('loot')) {
                    lootCards.push(card);
                } else if (buttonText.includes('join') || buttonText.includes('âš¡') || buttonText === 'fight') {
                    joinCards.push(card);
                } else {
                    // If no clear indicator, check if monster is dead (data-dead="1" or HP is 0)
                    const isDead = card.getAttribute('data-dead') === '1' ||
                                   card.querySelector('.hp-fill[style*="width:0"]') ||
                                   card.querySelector('.hp-fill[style*="width: 0"]') ||
                                   card.querySelector('.monster-img.grayscale');

                    if (isDead) {
                        lootCards.push(card);
                    } else {
                        joinCards.push(card);
                    }
                }
            });

            // Sort join cards by HP (descending - highest HP first for easier targeting)
            joinCards.sort((a, b) => {
                const hpA = this.extractHP(a);
                const hpB = this.extractHP(b);
                return hpB - hpA;
            });

            // Clear and rebuild container
            monsterContainer.innerHTML = '';

            if (continueCards.length > 0) {
                const continueContent = continueBattleSection.querySelector('[data-content="continue"] .monster-container');
                continueCards.forEach(card => continueContent.appendChild(card));
                monsterContainer.appendChild(continueBattleSection);
                
                // Update counter
                const continueCount = continueBattleSection.querySelector('[data-count="continue"]');
                if (continueCount) continueCount.textContent = continueCards.length;
            }

            if (lootCards.length > 0) {
                const lootContent = lootSection.querySelector('[data-content="loot"] .monster-container');
                lootCards.forEach(card => lootContent.appendChild(card));
                monsterContainer.appendChild(lootSection);
                
                // Update counter
                const lootCount = lootSection.querySelector('[data-count="loot"]');
                if (lootCount) lootCount.textContent = lootCards.length;
            }

            if (joinCards.length > 0) {
                const joinContent = joinBattleSection.querySelector('.monster-section-content .monster-container');
                joinCards.forEach(card => joinContent.appendChild(card));
                monsterContainer.appendChild(joinBattleSection);
                
                // Update counter
                const joinCount = joinBattleSection.querySelector('[data-count="join"]');
                if (joinCount) joinCount.textContent = joinCards.length;
            }

            // Add toggle functionality
            const continueToggle = continueBattleSection.querySelector('[data-toggle="continue"]');
            const lootToggle = lootSection.querySelector('[data-toggle="loot"]');

            if (continueToggle) {
                continueToggle.addEventListener('click', () => {
                    this.state.continueBattlesExpanded = !this.state.continueBattlesExpanded;
                    const content = continueBattleSection.querySelector('[data-content="continue"]');
                    content.style.display = this.state.continueBattlesExpanded ? 'block' : 'none';
                    continueToggle.textContent = this.state.continueBattlesExpanded ? 'âˆ’' : '+';
                    context.storage.set('waveSectionStates', {
                        continueBattlesExpanded: this.state.continueBattlesExpanded,
                        lootExpanded: this.state.lootExpanded
                    });
                });
            }

            if (lootToggle) {
                lootToggle.addEventListener('click', () => {
                    this.state.lootExpanded = !this.state.lootExpanded;
                    const content = lootSection.querySelector('[data-content="loot"]');
                    content.style.display = this.state.lootExpanded ? 'block' : 'none';
                    lootToggle.textContent = this.state.lootExpanded ? 'âˆ’' : '+';
                    context.storage.set('waveSectionStates', {
                        continueBattlesExpanded: this.state.continueBattlesExpanded,
                        lootExpanded: this.state.lootExpanded
                    });
                });
            }

            // Log categorization results
            context.logger.info(`[WaveUI] Categorized monsters: Continue=${continueCards.length}, Loot=${lootCards.length}, Join=${joinCards.length}`);

            // Add styles
            this.addMonsterSectionStyles(context);
        },
        extractHP(card) {
            const hpNode = card.querySelector('[data-stat="hp"], .hp-text, .hp-value, .monster-hp, .hp-bar + div, .hp');
            const hpText = hpNode ? hpNode.textContent : '';
            return numberFromText(hpText) || 0;
        },
        addMonsterSectionStyles(context) {
            if (document.getElementById('autods-monster-section-styles')) return;

            const style = document.createElement('style');
            style.id = 'autods-monster-section-styles';
            style.textContent = `
                .monster-section {
                    margin-bottom: 20px;
                    background: rgba(30, 30, 46, 0.6);
                    border-radius: 10px;
                    overflow: hidden;
                    border: 1px solid rgba(70, 130, 220, 0.25);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                }
                
                /* Continue Battle section - Red/Pink theme */
                .monster-section [data-section="continue"] {
                    background: linear-gradient(135deg, rgba(243, 139, 168, 0.15), rgba(203, 116, 139, 0.2));
                    border-bottom: 2px solid rgba(243, 139, 168, 0.4);
                }
                
                /* Loot section - Yellow theme */
                .monster-section [data-section="loot"] {
                    background: linear-gradient(135deg, rgba(249, 226, 175, 0.15), rgba(229, 200, 144, 0.2));
                    border-bottom: 2px solid rgba(249, 226, 175, 0.4);
                }
                
                .monster-section-header {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    padding: 14px 18px;
                    background: linear-gradient(135deg, rgba(30, 50, 100, 0.4), rgba(20, 40, 80, 0.5));
                    cursor: pointer;
                    border-bottom: 1px solid rgba(70, 130, 220, 0.2);
                    transition: background 0.2s ease;
                }
                .monster-section-header:hover {
                    background: linear-gradient(135deg, rgba(40, 70, 130, 0.5), rgba(30, 50, 100, 0.6));
                }
                .monster-section-header h3 {
                    font-size: 16px;
                    font-weight: 700;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                    display: flex;
                    align-items: center;
                }
                .section-count {
                    animation: pulse 2s ease-in-out infinite;
                }
                @keyframes pulse {
                    0%, 100% { opacity: 1; }
                    50% { opacity: 0.7; }
                }
                .section-toggle-btn {
                    background: rgba(70, 130, 220, 0.3);
                    border: 1px solid rgba(100, 160, 255, 0.4);
                    color: #e0e0e0;
                    padding: 6px 12px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 18px;
                    font-weight: bold;
                    min-width: 36px;
                    transition: all 0.2s;
                    font-family: monospace;
                }
                .section-toggle-btn:hover {
                    background: rgba(70, 130, 220, 0.5);
                    border-color: rgba(100, 160, 255, 0.6);
                    transform: scale(1.1);
                }
                .monster-section-content {
                    padding: 16px 18px;
                    background: rgba(10, 18, 30, 0.3);
                }
            `;
            document.head.appendChild(style);
        }
    };

    const dungeonWaveModule = {
        id: 'dungeonWaveAutomation',
        match: ({ location }) => /guild_dungeon_location\.php/i.test(location.pathname),
        init() {
            this.state = {
                running: false,
                processedMonsters: new Set(),
                lastScanTime: 0,
                staminaWaiting: false
            };
        },
        activate(context) {
            const cfgRoot = context.config.get();
            const cfgDungeonWave = cfgRoot.dungeonWave;
            if (!cfgRoot.core.enabled || !cfgDungeonWave || cfgDungeonWave.enabled === false) {
                if (this.state) {
                    this.state.running = false;
                }
                return;
            }
            if (!this.state) this.init(context);
            if (this.state.running) return;
            this.state.running = true;

            (async () => {
                try {
                    await this.runLoop(context);
                } catch (error) {
                    context.logger.error('Falha na rotina de dungeon wave', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },
        async runLoop(context) {
            const { logger } = context;
            while (/guild_dungeon_location\.php/i.test(context.location.pathname)) {
                const cfg = context.config.get();
                if (!cfg.core.enabled || cfg.dungeonWave?.enabled === false) {
                    logger.info('AutomaÃ§Ã£o de dungeon wave desativada via configuraÃ§Ã£o.');
                    break;
                }

                // Verificar stamina mÃ­nima antes de tentar entrar em batalha
                const staminaBlocking = await this.ensureStamina(context, cfg);
                if (staminaBlocking) {
                    continue; // Aguardar stamina regenerar
                }

                // Configurar o damage target do battleModule dinamicamente
                const currentMonsterName = this.state.currentMonsterName || '';
                const damageTarget = /magus/i.test(currentMonsterName) ? 1000000 : 3000000;

                // Atualizar config temporariamente para o battleModule
                if (cfg.battle) {
                    cfg.battle.minDamageTarget = damageTarget;
                }

                const result = this.scanAndJoin(context, cfg);
                if (result === 'joined') {
                    // Aguardar um pouco antes de verificar novamente
                    await sleepRandom(cfg.battle?.delayBaseMs ?? 1200, cfg.battle?.delayVariation ?? 0.25, cfg.battle?.randomizeDelays ?? true);
                    continue; // Volta para verificar se retornou Ã  pÃ¡gina de location
                }

                if (result === 'noEligible') {
                    logger.debug('Nenhum alvo elegÃ­vel no dungeon. Nova varredura em 15s.');
                    await sleepRandom(15000, 0.25, true);
                    continue;
                }

                if (result === 'complete') {
                    logger.info('Todos os monstros elegÃ­veis foram processados.');
                    break;
                }

                await sleepRandom(2000, 0.25, true);
            }
        },
        async ensureStamina(context, cfg) {
            if (!cfg.stamina) return false;
            const staminaNode = context.dom.query('#stamina_span, [data-player-stamina]');
            if (!staminaNode) return false;
            const staminaText = staminaNode.getAttribute?.('data-player-stamina') ?? staminaNode.textContent ?? '';
            const currentStamina = numberFromText(staminaText);
            const threshold = cfg.stamina.minThreshold ?? 0;
            if (currentStamina !== null && currentStamina < threshold) {
                if (!this.state.staminaWaiting) {
                    context.logger.warn(`[Dungeon] Stamina baixa (${formatNumber(currentStamina)} < ${formatNumber(threshold)}). Aguardando regeneraÃ§Ã£o.`);
                    this.state.staminaWaiting = true;
                }
                await sleepRandom(cfg.stamina.checkIntervalMs ?? 300000, 0.05, true);
                // Recarregar a pÃ¡gina apÃ³s aguardar
                context.logger.info('[Dungeon] Recarregando pÃ¡gina para atualizar stamina...');
                context.window.location.reload();
                return true;
            }
            if (this.state.staminaWaiting) {
                context.logger.info('[Dungeon] Stamina recuperada; retomando varredura de dungeon.');
                this.state.staminaWaiting = false;
            }
            return false;
        },
        scanAndJoin(context, cfg) {
            const { logger, dom } = context;

            // Encontrar todos os cards de monstros
            const monsterCards = dom.queryAll('.mon');
            if (!monsterCards.length) {
                logger.debug('Nenhum card de monstro encontrado na pÃ¡gina de dungeon.');
                return 'noEligible';
            }

            // Preparar filtro de nomes (nova estrutura: includeNames e excludeNames)
            const monsterFilter = cfg.dungeonWave?.monsterFilter || {};
            let includeNames = Array.isArray(monsterFilter.includeNames) 
                ? monsterFilter.includeNames.filter(Boolean).map(name => name.toLowerCase())
                : [];
            let excludeNames = Array.isArray(monsterFilter.excludeNames) 
                ? monsterFilter.excludeNames.filter(Boolean).map(name => name.toLowerCase())
                : [];
            
            // Fallback: Parse from old CSV format (dungeonWave.monsterNames)
            if (includeNames.length === 0 && cfg.dungeonWave?.monsterNames) {
                const csv = String(cfg.dungeonWave.monsterNames).trim();
                if (csv) {
                    includeNames = csv
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0)
                        .map(name => name.toLowerCase());
                }
            }
            
            // Log active filters
            if (includeNames.length > 0) {
                logger.info(`[DungeonWave] âœ“ Incluindo APENAS: ${includeNames.join(', ')}`);
            }
            if (excludeNames.length > 0) {
                logger.info(`[DungeonWave] âœ— Excluindo: ${excludeNames.join(', ')}`);
            }

            const candidates = [];

            for (const card of monsterCards) {
                // Verificar se tem pill "not joined"
                const pills = card.querySelectorAll('.pill');
                const hasNotJoined = Array.from(pills).some(pill => /not joined/i.test(pill.textContent));

                if (!hasNotJoined) continue;

                // Verificar se NÃƒO estÃ¡ morto (nÃ£o tem class "dead")
                if (card.classList.contains('dead')) continue;

                // Extrair nome do monstro
                const nameNode = card.querySelector('div[style*="font-weight:700"]');
                if (!nameNode) continue;
                
                // Pegar apenas o texto do elemento, ignorando os filhos (pill)
                // O nome estÃ¡ diretamente no final do elemento apÃ³s a div.row
                const nameText = Array.from(nameNode.childNodes)
                    .filter(node => node.nodeType === Node.TEXT_NODE)
                    .map(node => node.textContent.trim())
                    .join(' ')
                    .trim();
                
                const monsterName = nameText || nameNode.textContent.replace(/\s*(not joined|dead)\s*/gi, '').trim();
                
                // Extrair HP atual ANTES do log
                const hpNode = card.querySelector('.muted');
                const hpText = hpNode ? hpNode.textContent : '';
                const hpMatch = hpText.match(/([\d,.]+)\s*\/\s*([\d,.]+)\s*HP/);

                let currentHp = null;
                if (hpMatch) {
                    currentHp = numberFromText(hpMatch[1]);
                }
                
                logger.debug(`[DungeonWave] Card encontrado: "${monsterName}" (HP: ${currentHp ? formatNumber(currentHp) : 'N/A'})`);

                // Filtro de nome - Include (se configurado, APENAS esses)
                if (includeNames.length > 0) {
                    const nameLower = monsterName.toLowerCase();
                    const matchesInclude = includeNames.some(filter => nameLower.includes(filter));
                    if (!matchesInclude) {
                        logger.debug(`[DungeonWave] "${monsterName}" nÃ£o estÃ¡ na lista de inclusÃ£o [${includeNames.join(', ')}] - ignorado`);
                        continue;
                    }
                }

                // Filtro de nome - Exclude (pular esses)
                if (excludeNames.length > 0) {
                    const nameLower = monsterName.toLowerCase();
                    const matchesExclude = excludeNames.some(filter => nameLower.includes(filter));
                    if (matchesExclude) {
                        logger.debug(`[DungeonWave] "${monsterName}" estÃ¡ na lista de exclusÃ£o [${excludeNames.join(', ')}] - ignorado`);
                        continue;
                    }
                }

                // Filtro: HP atual maior que configurado
                const minHp = cfg.dungeonWave?.minMobHp ?? 4000000;
                if (currentHp === null || currentHp < minHp) {
                    logger.debug(`[DungeonWave] "${monsterName}": HP ${formatNumber(currentHp)} < ${formatNumber(minHp)} - ignorado`);
                    continue;
                }

                // Encontrar botÃ£o "Fight" ou link de luta (suporta mÃºltiplos formatos)
                // NOTE: Guild dungeons use battle.php?dgmid=X, not dungeon_battle.php
                const fightLink = card.querySelector('a.btn[href*="battle.php"], a.btn[href*="dgmid"], button.btn-join, #join-battle');
                if (!fightLink) {
                    logger.debug(`[DungeonWave] "${monsterName}": Nenhum link de luta encontrado - ignorado`);
                    continue;
                }
                
                logger.debug(`[DungeonWave] âœ“ "${monsterName}" adicionado aos candidatos (HP: ${formatNumber(currentHp)})`);

                candidates.push({
                    card,
                    name: monsterName,
                    hp: currentHp,
                    action: fightLink,
                    isMagus: /magus/i.test(monsterName)
                });
            }

            if (!candidates.length) {
                const hasNameFilter = includeNames.length > 0 || excludeNames.length > 0;
                const msg = hasNameFilter
                    ? 'Nenhum monstro elegÃ­vel com os filtros configurados.'
                    : 'Nenhum monstro elegÃ­vel apÃ³s aplicar filtros de HP/status.';
                logger.debug(msg);
                return 'complete';
            }
            
            logger.info(`[DungeonWave] ðŸŽ¯ ${candidates.length} candidato(s) encontrado(s) apÃ³s filtros`);

            // Aplicar modo de prioridade
            const priorityMode = cfg.dungeonWave?.priorityMode ?? 'lowest_hp';
            let target;

            switch (priorityMode) {
                case 'highest_hp':
                    target = candidates.sort((a, b) => b.hp - a.hp)[0];
                    break;
                case 'lowest_hp':
                    target = candidates.sort((a, b) => a.hp - b.hp)[0];
                    break;
                case 'random':
                    target = candidates[Math.floor(Math.random() * candidates.length)];
                    break;
                case 'first':
                default:
                    target = candidates[0];
                    break;
            }

            const damageTarget = target.isMagus
                ? (cfg.dungeonWave?.magusDamageTarget ?? 1000000)
                : (cfg.dungeonWave?.defaultDamageTarget ?? 3000000);

            logger.info(`Entrando em ${target.name} (HP: ${formatNumber(target.hp)}, Meta de Dano: ${formatNumber(damageTarget)}, Prioridade: ${priorityMode})`);

            // Salvar nome do monstro atual para configurar damage target
            this.state.currentMonsterName = target.name;

            context.events.emit('autods:dungeonWave:join', {
                monster: target.name,
                hp: target.hp,
                damageTarget: damageTarget,
                priorityMode: priorityMode,
                timestamp: Date.now()
            });

            // Join dungeon battle directly via API
            const battleUrl = target.action?.href;
            
            // Extract dgmid and instance_id from URL
            let dgmid = null;
            let instanceId = null;
            
            if (battleUrl) {
                const dgmidMatch = battleUrl.match(/[?&]dgmid=(\d+)/);
                const instanceMatch = battleUrl.match(/[?&]instance_id=(\d+)/);
                
                if (dgmidMatch) {
                    dgmid = dgmidMatch[1];
                }
                if (instanceMatch) {
                    instanceId = instanceMatch[1];
                }
            }

            if (dgmid && instanceId) {
                (async () => {
                    try {
                        logger.info(`ðŸŽ¯ Tentando join direto no dungeon battle (dgmid: ${dgmid}, instance: ${instanceId})...`);
                        const userId = getUserIdFromCookie() || context.config.get().core.userId;
                        const result = await context.http.joinDungeonBattle(dgmid, instanceId, userId);
                        
                        // VERIFICAÃ‡ÃƒO INTELIGENTE: Se Cloudflare bloqueou, usar mÃ©todo tradicional
                        if (result.cloudflareBlock) {
                            logger.warn(`âš ï¸ Cloudflare bloqueou requisiÃ§Ã£o direta. Usando mÃ©todo tradicional (click).`);
                            if (target.action instanceof HTMLElement) {
                                target.action.click();
                            } else if (battleUrl) {
                                window.location.href = battleUrl;
                            }
                            return;
                        }
                        
                        if (result.success) {
                            logger.info(`âœ… ${result.message}`);
                            // Navigate to battle page after successful join
                            if (battleUrl) {
                                window.location.href = battleUrl;
                            } else if (target.action instanceof HTMLElement) {
                                target.action.click();
                            }
                        } else {
                            logger.warn(`âš ï¸ Dungeon join direto falhou: ${result.message}. Usando mÃ©todo tradicional.`);
                            // Fallback to traditional join
                            if (target.action instanceof HTMLElement) {
                                target.action.click();
                            } else if (battleUrl) {
                                window.location.href = battleUrl;
                            }
                        }
                    } catch (error) {
                        logger.error(`Erro no dungeon join direto: ${error.message}`);
                        // Fallback to traditional join
                        if (target.action instanceof HTMLElement) {
                            target.action.click();
                        } else if (battleUrl) {
                            window.location.href = battleUrl;
                        }
                    }
                })();
            } else {
                // No dgmid or instanceId, use traditional method
                logger.debug(`Usando mÃ©todo tradicional (dgmid: ${dgmid}, instanceId: ${instanceId})`);
                if (target.action instanceof HTMLElement) {
                    target.action.click();
                } else if (target.action && typeof target.action.href === 'string') {
                    window.location.href = target.action.href;
                }
            }

            return 'joined';
        }
    };

    /**
     * Special Boss Farm Module
     * Dedicated module for farming special bosses (General, King, Empress, Bastion)
     * Ensures 50M damage minimum for special loot drops
     * Uses GM_xmlhttpRequest for direct API calls (like Ultra Fast Mode)
     */
    const specialBossFarmModule = {
        id: 'specialBossFarm',
        match: ({ location }) => /active_wave\.php/i.test(location.pathname),
        
        init(context) {
            this.state = {
                running: false,
                activeBosses: 0, // ðŸ†• Count of bosses currently being attacked (not just waiting)
                stats: {
                    bossesFound: 0,
                    bossesCompleted: 0,
                    totalAttacks: 0,
                    totalDamage: 0,
                    potionsUsed: 0,
                    startTime: null
                },
                lastCheckTime: null
            };
        },

        activate(context) {
            const cfg = context.config.get();
            if (!cfg.core.enabled || !cfg.specialBossFarm?.enabled) {
                if (this.state) this.state.running = false;
                return;
            }

            if (!this.state) this.init(context);
            if (this.state.running) return;

            this.state.running = true;
            this.state.stats.startTime = Date.now();
            
            context.logger.info('ðŸ‘‘ Special Boss Farm ativado! (Ultra Fast Mode)');

            (async () => {
                try {
                    await this.runBossFarmLoop(context);
                } catch (error) {
                    context.logger.error('[SpecialBossFarm] Erro fatal:', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },

        async runBossFarmLoop(context) {
            const { logger } = context;
            
            logger.info('ðŸ‘‘ Iniciando loop de farm de bosses especiais (Ultra Fast)...');

            while (/active_wave\.php/i.test(context.location.pathname)) {
                const cfg = context.config.get();
                
                if (!cfg.core.enabled || !cfg.specialBossFarm?.enabled) {
                    logger.info('ðŸ‘‘ Special Boss Farm desativado via configuraÃ§Ã£o.');
                    break;
                }

                const bossCfg = cfg.specialBossFarm;
                
                // 1. Scan for special bosses
                const bosses = await this.scanSpecialBosses(context, bossCfg);
                
                if (bosses.length === 0) {
                    this.state.activeBosses = 0; // ðŸ†• No bosses to attack
                    const waitTime = bossCfg.checkInterval || 300000; // 5 minutes default
                    logger.info(`ðŸ‘‘ Nenhum boss especial disponÃ­vel. Aguardando ${Math.round(waitTime / 60000)} minuto(s)...`);
                    this.state.lastCheckTime = Date.now();
                    await sleep(waitTime);
                    logger.info('ðŸ‘‘ Recarregando pÃ¡gina para verificar novamente...');
                    window.location.reload();
                    return;
                }

                logger.info(`ðŸ‘‘ ${bosses.length} boss(es) especial(is) encontrado(s)!`);
                this.state.stats.bossesFound += bosses.length;
                this.state.activeBosses = bosses.length; // ðŸ†• Mark bosses as being processed

                // 2. Join bosses via API (Ultra Fast Mode)
                const joinedBosses = await this.joinBossesViaApi(context, bosses, bossCfg);
                
                if (joinedBosses.length === 0) {
                    logger.warn('ðŸ‘‘ Falha ao entrar nas batalhas. Aguardando 30s...');
                    await sleep(30000);
                    continue;
                }

                // 3. Attack until target damage reached (via GM_xmlhttpRequest)
                const attackResult = await this.attackBossesUltraFast(context, joinedBosses, bossCfg);
                
                this.state.activeBosses = 0; // ðŸ†• Finished attacking bosses

                // 4. Decide next action based on result
                if (!attackResult.hadWork) {
                    // All bosses already completed - wait before checking again
                    const waitTime = bossCfg.checkInterval || 300000;
                    logger.info(`ðŸ‘‘ Todos os bosses jÃ¡ completados. Aguardando ${Math.round(waitTime / 60000)} minuto(s)...`);
                    this.state.lastCheckTime = Date.now();
                    await sleep(waitTime);
                    logger.info('ðŸ‘‘ Recarregando pÃ¡gina para verificar novamente...');
                    window.location.reload();
                    return;
                } else {
                    // Had work - reload quickly to check for more
                    logger.info('ðŸ‘‘ Bosses processados. Recarregando para verificar novamente...');
                    await sleep(2000);
                    window.location.reload();
                    return;
                }
            }
        },

        async scanSpecialBosses(context, cfg) {
            const { logger, dom } = context;
            const cards = dom.queryAll('.monster-card');
            
            if (!cards.length) {
                return [];
            }

            // Boss detection threshold: 100 billion (100B) HP
            const BOSS_HP_THRESHOLD = 100_000_000_000;
            const bosses = [];

            for (const card of cards) {
                // Extract monster name
                const nameNode = card.querySelector('h3, h4, .monster-name, .card-title');
                const monsterName = nameNode ? nameNode.textContent.trim() : '';

                // Extract HP - Find .stat-row with .stat-icon.hp child
                const hpRow = Array.from(card.querySelectorAll('.stat-row')).find(row => row.querySelector('.stat-icon.hp'));
                const hpValueNode = hpRow?.querySelector('.stat-value');
                const hpText = hpValueNode?.textContent ?? '';
                
                // Parse max HP from "current / max" format
                const hpMatch = hpText.match(/(\d{1,3}(?:,\d{3})*|\d+)\s*\/\s*(\d{1,3}(?:,\d{3})*|\d+)/);
                const hp = hpMatch ? numberFromText(hpMatch[2]) : null;  // hpMatch[2] is max HP

                // ðŸ†• BOSS DETECTION: Any mob with 100B+ HP is considered a boss
                if (!hp || hp < BOSS_HP_THRESHOLD) {
                    continue;
                }

                // Get button to check status
                const button = card.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button');
                const buttonText = button?.textContent?.toLowerCase() || '';
                
                // Get battle link - try multiple selectors
                let monsterId = null;
                
                // Try link with id parameter
                const link = card.querySelector('a[href*="battle.php"][href*="id="]');
                if (link) {
                    const monsterIdMatch = link.href.match(/[?&]id=(\d+)/);
                    monsterId = monsterIdMatch ? monsterIdMatch[1] : null;
                }
                
                // Fallback: try data attributes
                if (!monsterId) {
                    monsterId = card.dataset?.monsterId || card.dataset?.id || card.getAttribute('data-monster-id');
                }
                
                // Fallback: try button onclick
                if (!monsterId && button) {
                    const onclickMatch = button.getAttribute('onclick')?.match(/(\d+)/);
                    monsterId = onclickMatch ? onclickMatch[1] : null;
                }

                if (!monsterId) {
                    logger.warn(`ðŸ‘‘ ${monsterName}: NÃ£o encontrou ID do monstro`);
                    continue;
                }

                const hasJoined = buttonText.includes('continue');
                const canJoin = buttonText.includes('join') || buttonText.includes('fight');

                bosses.push({
                    card,
                    name: monsterName,
                    monsterId,
                    hp,
                    hasJoined,
                    canJoin,
                    button,
                    currentDamage: 0
                });

                logger.info(`ðŸ‘‘ Boss detectado: ${monsterName} (HP: ${formatNumber(hp)}, ID: ${monsterId}, ${hasJoined ? 'JOINED' : 'NOT JOINED'})`);
            }

            return bosses;
        },

        async joinBossesViaApi(context, bosses, cfg) {
            const { logger } = context;
            const joinedBosses = [];
            
            // Get user ID
            const userId = ensureUserId(context);
            if (!userId) {
                logger.error('ðŸ‘‘ User ID nÃ£o encontrado! NÃ£o Ã© possÃ­vel entrar nas batalhas via API.');
                return [];
            }

            logger.info(`ðŸ‘‘ Entrando em ${bosses.length} boss(es) via API...`);

            // Join all bosses in parallel
            const joinPromises = bosses.map(async (boss) => {
                if (boss.hasJoined) {
                    logger.debug(`ðŸ‘‘ ${boss.name}: JÃ¡ estÃ¡ na batalha`);
                    return { boss, success: true, alreadyJoined: true };
                }

                try {
                    const result = await context.http.joinBattle(boss.monsterId, userId);
                    return { boss, ...result };
                } catch (error) {
                    return { boss, success: false, error: error.message };
                }
            });

            const results = await Promise.all(joinPromises);

            for (const result of results) {
                if (result.success || result.alreadyJoined) {
                    logger.info(`âœ… ${result.boss.name}: ${result.alreadyJoined ? 'JÃ¡ estava na batalha' : 'Entrou via API!'}`);
                    result.boss.hasJoined = true;
                    joinedBosses.push(result.boss);
                } else {
                    logger.warn(`âŒ ${result.boss.name}: Falha ao entrar - ${result.message || result.error || 'Erro desconhecido'}`);
                }
            }

            logger.info(`ðŸ‘‘ Join Results: ${joinedBosses.length}/${bosses.length} bem-sucedidos`);
            return joinedBosses;
        },

        async attackBossesUltraFast(context, bosses, cfg) {
            const { logger } = context;
            const targetDamage = cfg.targetDamage || 50000000;
            const skillId = cfg.skillId ?? -2;
            const parallelAttacks = cfg.parallelAttacks || 5;
            const minDelayBetweenAttacks = cfg.minDelayBetweenAttacks || 30;
            const skillCosts = { '0': 1, '-1': 10, '-2': 50, '-3': 100, '-4': 200 };
            const skillCost = skillCosts[skillId.toString()] || 1;

            // 1. Fetch current damage for all bosses
            await this.fetchCurrentDamages(context, bosses);

            // 2. Filter out bosses that already reached target
            const validBosses = bosses.filter(boss => {
                if (boss.invalid) {
                    logger.warn(`ðŸ‘‘ ${boss.name}: Batalha invÃ¡lida`);
                    return false;
                }
                if (boss.currentDamage >= targetDamage) {
                    logger.info(`âœ… ${boss.name}: JÃ¡ atingiu ${formatNumber(targetDamage)} dano (atual: ${formatNumber(boss.currentDamage)})`);
                    this.state.stats.bossesCompleted++;
                    return false;
                }
                logger.info(`ðŸ‘‘ ${boss.name}: Precisa de ${formatNumber(targetDamage - boss.currentDamage)} dano (atual: ${formatNumber(boss.currentDamage)})`);
                return true;
            });

            if (validBosses.length === 0) {
                logger.info('âœ… Todos os bosses jÃ¡ atingiram o dano alvo!');
                return { hadWork: false, allCompleted: true };
            }

            logger.info(`ðŸš€ Atacando ${validBosses.length} boss(es) (Ultra Fast Mode) atÃ© ${formatNumber(targetDamage)} dano cada...`);

            // 3. Process each boss sequentially (to avoid overdamage)
            for (const boss of validBosses) {
                logger.info(`ðŸ‘‘ Processando: ${boss.name} (dano atual: ${formatNumber(boss.currentDamage)})`);
                
                const bossState = {
                    ...boss,
                    currentDamage: boss.currentDamage || 0,
                    attackCount: 0,
                    completed: false,
                    potionsUsed: 0
                };
                
                // Attack loop for this boss (same logic as Ultra Fast Boss)
                while (bossState.currentDamage < targetDamage && !bossState.dead) {
                    // Check remaining damage
                    const remainingDamage = targetDamage - bossState.currentDamage;
                    
                    if (remainingDamage <= 0) {
                        bossState.completed = true;
                        logger.info(`âœ… ðŸ‘‘ ${boss.name}: Alvo atingido! ${formatNumber(bossState.currentDamage)} dano`);
                        this.state.stats.bossesCompleted++;
                        break;
                    }
                    
                    // Check stamina (MESMO PADRÃƒO DO WAVEMODULE)
                    let currentStamina = context.stamina.getCurrent();
                    
                    if (currentStamina < skillCost) {
                        logger.info(`â³ Stamina insuficiente (${currentStamina}/${skillCost}) - tratando...`);
                        
                        // Try to use stamina potion if enabled and low
                        if (cfg.autoStaminaPotion && currentStamina < (cfg.minStaminaForPotion || 100)) {
                            logger.info('ðŸ’Š Tentando usar Full Stamina Potion...');
                            
                            try {
                                const fspUsed = await context.inventory.useFullStaminaPotion();
                                
                                if (fspUsed) {
                                    logger.info('âœ… Full Stamina Potion usada com sucesso! Recarregando pÃ¡gina...');
                                    bossState.potionsUsed++;
                                    this.state.stats.potionsUsed++;
                                    
                                    // Reload to sync stamina
                                    await sleep(1000);
                                    window.location.reload();
                                    return { hadWork: true };
                                } else {
                                    logger.info('ðŸ’Š Full Stamina Potion: Sem poÃ§Ãµes disponÃ­veis ou erro');
                                }
                            } catch (error) {
                                logger.warn('ðŸ’Š Erro ao tentar usar poÃ§Ã£o:', error.message);
                            }
                        }
                        
                        // If potion failed or disabled: wait for stamina regen (30s, same as wave module)
                        logger.info(`â³ Aguardando regeneraÃ§Ã£o de stamina (30s)...`);
                        await sleep(30000);
                        currentStamina = context.stamina.getCurrent();
                        
                        if (currentStamina < skillCost) {
                            logger.warn(`âš ï¸ Stamina AINDA insuficiente (${currentStamina}/${skillCost}) apÃ³s aguardar. Pulando ${boss.name}.`);
                            break; // Skip this boss, try next in loop
                        }
                    }
                    
                    // Calculate how many attacks to send
                    const possibleAttacks = Math.floor(currentStamina / skillCost);
                    const attackCount = Math.min(possibleAttacks, parallelAttacks);
                    
                    if (attackCount <= 0) {
                        await sleep(100);
                        continue;
                    }
                    
                    // Execute parallel attacks (same as Ultra Fast Boss)
                    const results = await this.executeBossParallelAttacks(context, boss.monsterId, skillId, attackCount);
                    
                    // Update state
                    bossState.attackCount += results.successCount;
                    bossState.currentDamage += results.totalDamage;
                    this.state.stats.totalAttacks += results.successCount;
                    this.state.stats.totalDamage += results.totalDamage;
                    
                    // Update stamina display
                    if (results.lastStamina !== null) {
                        const staminaEl = document.querySelector('#stamina_span');
                        if (staminaEl) staminaEl.textContent = Math.max(0, results.lastStamina).toLocaleString();
                    }
                    
                    // Log progress every few attacks
                    if (bossState.attackCount % 10 === 0) {
                        const progress = ((bossState.currentDamage / targetDamage) * 100).toFixed(1);
                        logger.info(`ðŸ“Š ${boss.name}: ${formatNumber(bossState.currentDamage)}/${formatNumber(targetDamage)} (${progress}%) - ${bossState.attackCount} ataques`);
                    }
                    
                    // Delay between attack batches
                    await sleep(minDelayBetweenAttacks);
                }
                
                // Boss completed
                if (bossState.completed) {
                    logger.info(`âœ… ðŸ‘‘ ${boss.name}: ConcluÃ­do com ${formatNumber(bossState.currentDamage)} dano em ${bossState.attackCount} ataques (${bossState.potionsUsed} poÃ§Ãµes)`);
                }
            }

            // Final Summary
            logger.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            logger.info('ðŸ‘‘ RESUMO DO SPECIAL BOSS FARM');
            logger.info(`ðŸ“ˆ Total: ${this.state.stats.totalAttacks} ataques, ${formatNumber(this.state.stats.totalDamage)} dano, ${this.state.stats.potionsUsed} poÃ§Ãµes`);
            logger.info(`âœ… Bosses completados: ${this.state.stats.bossesCompleted}`);
            logger.info('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            
            return { hadWork: true, allCompleted: true };
        },
        
        /**
         * Execute parallel attacks on a boss using context.combat service
         * TRATAMENTO DE STAMINA: Se algum ataque falhar por stamina insuficiente,
         * loga o erro para que o loop principal possa tratar
         * @param {string} monsterId - Monster ID
         * @param {number} skillId - Skill ID to use
         * @param {number} count - Number of parallel attacks
         * @returns {Promise<{totalDamage: number, successCount: number, lastStamina: number|null}>}
         */
        async executeBossParallelAttacks(context, monsterId, skillId, count) {
            const { logger } = context;
            const attackPromises = Array.from({ length: count }, () => 
                context.combat.attackWaveMonsterDirect(monsterId, skillId)
            );
            
            const results = await Promise.all(attackPromises);
            
            let totalDamage = 0, successCount = 0, lastStamina = null;
            for (const r of results) {
                if (r.success) {
                    totalDamage += r.damageDealt || 0;
                    successCount++;
                    if (r.stamina !== undefined) lastStamina = r.stamina;
                } else if (r.message && r.message.toLowerCase().includes('stamina')) {
                    // ðŸ†• Stamina insuficiente - recarregar pÃ¡gina
                    logger.warn(`âš ï¸ [BossAttack] Stamina insuficiente! Recarregando pÃ¡gina...`);
                    await sleep(1000);
                    window.location.reload();
                    return { totalDamage, successCount, lastStamina };
                }
            }
            
            return { totalDamage, successCount, lastStamina };
        },

        async fetchCurrentDamages(context, bosses) {
            const { logger } = context;
            logger.info(`ðŸ” Verificando dano atual de ${bosses.length} boss(es)...`);

            // Use fetchBattleDamage from waveModule (better: tries card data first, then HTTP fallback)
            const waveModule = context.moduleRegistry.getModule('waveAutomation');
            if (!waveModule) {
                logger.warn('âš ï¸ waveModule nÃ£o disponÃ­vel para fetchBattleDamage');
                return;
            }

            // Fetch damages in parallel using waveModule's optimized method
            const results = await Promise.all(
                bosses.map(boss => waveModule.fetchBattleDamage(context, boss.monsterId))
            );

            // Map results back to boss objects
            for (let i = 0; i < bosses.length; i++) {
                const boss = bosses[i];
                const result = results[i];
                
                if (result.success) {
                    boss.currentDamage = result.damage || 0;
                    logger.debug(`[FetchDamage] ${boss.name}: ${formatNumber(boss.currentDamage)} dano (fonte: ${result.source})`);
                } else {
                    boss.currentDamage = 0;
                    boss.fetchError = true;
                    
                    if (result.invalid) {
                        boss.invalid = true;
                        logger.warn(`[FetchDamage] ${boss.name}: Batalha invÃ¡lida`);
                    } else {
                        logger.debug(`[FetchDamage] ${boss.name}: Erro ao buscar dano`);
                    }
                }
            }
        }
    };

    const battleModule = {
        id: 'battleAutomation',
        match: ({ location }) => {
            const path = location.pathname;
            // Match battle.php and dungeon_battle.php, but NOT pvp_battle.php
            return (/battle\.php/i.test(path) || /dungeon_battle\.php/i.test(path)) && !/pvp.*battle/i.test(path);
        },
        init() {
            this.state = {
                running: false,
                lastLoggedDamage: null,
                lastPhase: 1,
                lastMonsterImage: null,
                phaseChangeDetectedAt: null,
                lastMonsterHp: null
            };
        },
        checkInvalidMonsterToast(context) {
            // Check for "Invalid Monster" error in toast/notification elements
            const toastSelectors = [
                '.toast-container .toast',
                '.notification',
                '.alert',
                '#system_message',
                '.error-message',
                '.Toastify__toast',
                '[role="alert"]',
                '.swal2-popup',
                '.swal2-html-container'
            ];

            for (const selector of toastSelectors) {
                const elements = document.querySelectorAll(selector);
                for (const el of elements) {
                    const text = (el.textContent || '').toLowerCase();
                    if (text.includes('invalid monster') || text.includes('invalid_monster')) {
                        context.logger.warn('ðŸš« Toast "Invalid Monster" detectado!', { text: el.textContent });
                        return true;
                    }
                }
            }
            return false;
        },
        detectMonsterPhase(context) {
            // Detect if monster is in golden phase (phase > 1)
            // Golden phase adds CSS class .monster-hp-wrap--gold to the HP container
            const hpWrap = document.querySelector('.monster-hp-wrap');
            if (!hpWrap) return { phase: 1, isGolden: false, changed: false };

            const isGolden = hpWrap.classList.contains('monster-hp-wrap--gold');

            // Try to extract phase from phase-announce banner
            const phaseAnnounce = document.querySelector('.phase-announce-inner');
            let phaseNumber = 1;
            if (phaseAnnounce) {
                const text = phaseAnnounce.textContent || '';
                const match = text.match(/PHASE\s+(\d+)/i);
                if (match) {
                    phaseNumber = parseInt(match[1], 10) || 1;
                }
            }

            // If golden class present but no phase detected, assume phase 2+
            if (isGolden && phaseNumber === 1) {
                phaseNumber = 2;
            }

            // Detect phase change by comparing with last known phase
            let changed = false;
            if (this.state && this.state.lastPhase !== phaseNumber) {
                changed = true;
                context.logger.info(`ðŸ”„ PHASE CHANGE DETECTADA! ${this.state.lastPhase} â†’ ${phaseNumber}`);
            }

            // Also detect by image change
            const monsterImage = document.querySelector('#monsterImage, .monster_image');
            if (monsterImage && this.state) {
                const currentSrc = monsterImage.src || '';
                if (this.state.lastMonsterImage && this.state.lastMonsterImage !== currentSrc) {
                    changed = true;
                    context.logger.info(`ðŸ–¼ï¸ Imagem do monstro mudou (phase change)`);
                }
                this.state.lastMonsterImage = currentSrc;
            }

            // Update state
            if (this.state && changed) {
                this.state.lastPhase = phaseNumber;
                this.state.phaseChangeDetectedAt = Date.now();
                this.state.lastLoggedDamage = null; // Reset damage tracking
            }

            return { phase: phaseNumber, isGolden, changed };
        },
        getSkillStaminaCost(button) {
            // Extract stamina cost from button text or data attribute
            if (!button) return 0;

            // Try data attribute first
            const dataStamina = button.dataset?.staminaCost || button.getAttribute('data-stamina-cost');
            if (dataStamina) {
                const cost = parseInt(dataStamina, 10);
                if (!isNaN(cost)) return cost;
            }

            // Extract from button text/name (e.g., "Power Slash (10 STAMINA)")
            const buttonText = button.dataset?.skillName || button.getAttribute('data-skill-name') || button.textContent || '';
            const match = buttonText.match(/\((\d+)\s*STAMINA\)/i);
            if (match) {
                const cost = parseInt(match[1], 10);
                if (!isNaN(cost)) return cost;
            }

            // Default: Slash costs 0 stamina
            return 0;
        },
        // REMOVED: getCurrentStamina() - use context.stamina.getCurrent() instead
        checkStaminaForAttack_OLD_REMOVE_ME(context, button) {
            const { dom } = context;

            // PRIMARY SELECTOR REMOVED - use context.stamina
            const staminaSpan = dom.query('#stamina_span');
            if (staminaSpan) {
                const text = staminaSpan.textContent || '';
                const value = numberFromText(text.trim());
                if (value !== null) {
                    context.logger.debug(`Stamina lida de #stamina_span: ${value}`);
                    return value;
                }
            }

            // Fallback: try parent element .gtb-value and parse "X / Y" format
            const gtbValue = dom.query('.gtb-value');
            if (gtbValue) {
                const text = gtbValue.textContent || '';
                const parts = text.split('/');
                if (parts.length >= 1) {
                    const current = numberFromText(parts[0]);
                    if (current !== null) {
                        context.logger.debug(`Stamina lida de .gtb-value: ${current}`);
                        return current;
                    }
                }
            }

            // Additional fallback selectors
            const selectors = [
                '[data-stamina]',
                '.stamina-value',
                '#staminaText',
                '.stamina-text'
            ];

            for (const selector of selectors) {
                const element = dom.query(selector);
                if (!element) continue;

                // Try to extract current stamina value
                const dataValue = element.dataset?.stamina || element.dataset?.current || element.getAttribute('data-current');
                if (dataValue) {
                    const value = numberFromText(dataValue);
                    if (value !== null) {
                        context.logger.debug(`Stamina lida de ${selector}: ${value}`);
                        return value;
                    }
                }

                // Parse text content
                const text = element.textContent || '';
                const parts = text.split('/');
                if (parts.length >= 1) {
                    const current = numberFromText(parts[0]);
                    if (current !== null) {
                        context.logger.debug(`Stamina lida de ${selector}: ${current}`);
                        return current;
                    }
                }
            }

            context.logger.warn('DEPRECATED: Use context.stamina.getCurrent()');
            return 0;
        },
        checkStaminaForAttack(context, button) {
            const staminaCost = this.getSkillStaminaCost(button);
            const currentStamina = context.stamina.getCurrent();

            context.logger.debug(`VerificaÃ§Ã£o de stamina: Atual=${currentStamina}, Custo=${staminaCost}`);

            if (currentStamina < staminaCost) {
                context.logger.warn(`âš ï¸ Stamina insuficiente! Atual: ${currentStamina}, NecessÃ¡rio: ${staminaCost}`);
                return false;
            }

            return true;
        },
        canAttackNow() {
            // Check if 1 second has passed since last attack (cooldown)
            try {
                const cookieStr = document.cookie;
                const match = cookieStr.match(/last_attack=(\d+)/);
                if (!match) return { ok: true, now: Date.now(), waitMs: 0 };

                const lastAttack = parseInt(match[1], 10);
                const now = Date.now();
                const elapsed = now - lastAttack;
                const cooldown = 1000; // 1 second

                if (elapsed < cooldown) {
                    return { ok: false, now, waitMs: cooldown - elapsed };
                }

                return { ok: true, now, waitMs: 0 };
            } catch (error) {
                return { ok: true, now: Date.now(), waitMs: 0 };
            }
        },
        setLastAttackTime() {
            // Set cookie with current timestamp
            const now = Date.now();
            document.cookie = `last_attack=${now}; path=/; max-age=86400`;
            return now;
        },
        activate(context) {
            const cfgRoot = context.config.get();
            const cfgBattle = cfgRoot.battle;
            if (!cfgRoot.core.enabled || !cfgBattle || cfgBattle.enabled === false) {
                if (this.state) {
                    this.state.running = false;
                }
                return;
            }
            if (!this.state) this.init(context);
            if (this.state.running) return;
            this.state.running = true;
            this.state.lastLoggedDamage = null;
            this.state.lastPhase = 1;
            this.state.lastMonsterImage = null;
            this.state.phaseChangeDetectedAt = null;
            this.state.lastMonsterHp = null;

            (async () => {
                try {
                    await this.runBattle(context);
                } catch (error) {
                    context.logger.error('Falha na rotina de batalha', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },
        async checkAndUseHeal(context) {
            const { logger, dom, config } = context;
            
            // Check if player is down
            const downMessages = dom.queryAll('.battle-actions-body, .alert, .message, .notification, .toast, .battle-message, [class*="message"], [class*="alert"], [class="battle-actions-body"]');
            let isDown = false;
            
            for (const msg of downMessages) {
                const text = (msg.textContent || '').toLowerCase();
                if (text.includes('you are down') || text.includes('heal to keep fighting')) {
                    isDown = true;
                    logger.warn('âš ï¸ Player estÃ¡ DOWN! Tentando usar heal potion...');
                    break;
                }
            }
            
            if (!isDown) return false;
            
            // Try to use heal potion
            const healPotionBtn = dom.query('#usePotionBtn');
            if (!healPotionBtn) {
                logger.error('âŒ BotÃ£o de heal potion nÃ£o encontrado');
                return false;
            }
            
            if (healPotionBtn.disabled) {
                logger.warn('âš ï¸ BotÃ£o de heal potion estÃ¡ desabilitado');
                return false;
            }
            
            try {
                logger.info('ðŸ’š Usando Heal Potion...');
                
                // Get user ID from userSession service
                const userId = context.userSession.getUserId();
                
                if (!userId) {
                    logger.error('âŒ User ID nÃ£o encontrado para usar heal potion');
                    return false;
                }
                
                // Send heal potion request
                const formData = new URLSearchParams();
                formData.set('user_id', userId);
                
                const response = await fetch('https://demonicscans.org/use_heal_potion.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    credentials: 'include',
                    body: formData.toString()
                });
                
                if (!response.ok) {
                    logger.error(`âŒ Erro ao usar heal potion: HTTP ${response.status}`);
                    return false;
                }
                
                const text = await response.text();
                const lower = text.trim().toLowerCase();
                
                if (lower.includes('success') || lower.includes('healed') || lower.includes('restored')) {
                    logger.info('âœ… Heal Potion usada com sucesso!');
                    
                    // Emit event
                    context.events.emit('autods:battle:healUsed', {
                        userId,
                        timestamp: Date.now()
                    });
                    
                    // Wait for heal to apply
                    await sleep(1500);
                    return true;
                } else {
                    logger.warn(`âš ï¸ Resposta inesperada ao usar heal potion: ${text.substring(0, 100)}`);
                    return false;
                }
            } catch (error) {
                logger.error(`âŒ Erro ao usar heal potion: ${error.message}`);
                return false;
            }
        },
        
        /**
         * Get current monster name from battle page
         * @param {object} context - Context object
         * @returns {string|null} Monster name or null
         */
        getCurrentMonsterName(context) {
            const { dom } = context;
            
            // Try multiple selectors (battle.php and dungeon pages)
            const selectors = [
                '.card-title',           // Guild dungeon
                '.panel strong',         // Regular dungeon
                '.monster-name',         // Battle page
                '.battle-monster-name',  // Alternative
                '[data-monster-name]'    // Data attribute
            ];
            
            for (const selector of selectors) {
                const node = dom.query(selector);
                if (node) {
                    const name = node.textContent?.trim() || node.getAttribute?.('data-monster-name')?.trim();
                    if (name) return name;
                }
            }
            
            // Try to extract from page title
            const titleMatch = document.title.match(/Battle:\s*(.+?)(?:\s*-|$)/i);
            if (titleMatch) return titleMatch[1].trim();
            
            return null;
        },
        
        async runBattle(context) {
            const { logger, dom } = context;

            // Check for "Invalid Monster" toast immediately on page load
            if (this.checkInvalidMonsterToast(context)) {
                logger.warn('âš ï¸ Invalid Monster detectado ao entrar na pÃ¡gina de batalha - voltando');
                this.returnToWave(context, 'invalid_monster_initial');
                return;
            }

            const joinResult = await this.tryJoinBattle(context);
            if (joinResult === 'blocked') {
                this.returnToWave(context, 'battleLimit');
                return;
            }
            
            let shouldReturnToWave = false;
            let returnReason = null;
            let attackButton = null; // Declare outside loop for stamina tracking
            const delayBase = context.config.get().battle?.delayBaseMs ?? 1000;
            const variation = context.config.get().battle?.delayVariation ?? 0.3;
            const randomize = context.config.get().battle?.randomizeDelays ?? true;

            // Detectar se estÃ¡ em dungeon_battle OU battle.php com instance_id (guild dungeons)
            const isDungeonBattle = /dungeon_battle\.php/i.test(context.location.pathname) 
                || (context.location.search && context.location.search.includes('instance_id'));
            let dungeonMonsterName = null;
            if (isDungeonBattle) {
                // Log tipo de dungeon detectado
                const isGuildDungeon = context.location.search && context.location.search.includes('instance_id');
                if (isGuildDungeon) {
                    logger.debug(`ðŸ° Guild Dungeon Battle detectado (instance_id presente na URL)`);
                }
                
                // Buscar o nome do monstro na card-title (guild dungeons) ou panel strong (dungeons normais)
                const monsterNameNode = dom.query('.card-title, .panel strong');
                if (monsterNameNode) {
                    dungeonMonsterName = monsterNameNode.textContent.trim();
                    logger.debug(`Batalha de dungeon detectada: ${dungeonMonsterName}`);
                } else {
                    logger.warn('NÃ£o foi possÃ­vel extrair nome do monstro da pÃ¡gina de dungeon');
                }
            }
            
            while (/battle\.php|dungeon_battle\.php/i.test(context.location.pathname)) {
                // Check for "Invalid Monster" toast during battle loop
                if (this.checkInvalidMonsterToast(context)) {
                    logger.warn('âš ï¸ Invalid Monster detectado durante a batalha - voltando');
                    this.returnToWave(context, 'invalid_monster_during_battle');
                    return;
                }

                const cfg = context.config.get();
                if (!cfg.core.enabled || cfg.battle?.enabled === false) {
                    context.logger.info('AutomaÃ§Ã£o de batalha desativada via configuraÃ§Ã£o.');
                    break;
                }

                // Check if player is down and needs heal
                const healUsed = await this.checkAndUseHeal(context);
                if (healUsed) {
                    // Wait a moment after healing before continuing
                    await sleepRandom(1500, 0.2, cfg.battle?.randomizeDelays ?? true);
                }

                // CRITICAL: Check if we still need to join the battle
                const joinButton = dom.query('#join-battle, button.btn-join, button.join-battle');
                if (joinButton && !joinButton.disabled) {
                    logger.info('BotÃ£o de join ainda presente. Tentando entrar na batalha...');
                    const retryJoin = await this.tryJoinBattle(context);
                    if (retryJoin === 'blocked') {
                        this.returnToWave(context, 'battleLimit');
                        return;
                    }
                    // Wait for page reload after join
                    await sleepRandom(2000, 0.2, true);
                    continue;
                }

                // Use Battle Stats Service
                const stats = context.battleStats.getCurrent();
                
                // Detect HP increase (monster respawned in new phase)
                if (this.state.lastMonsterHp !== null && stats.monsterHp !== null) {
                    if (stats.monsterHp > this.state.lastMonsterHp + 1000000) {
                        logger.info(`ðŸ”„ HP aumentou significativamente! ${formatNumber(this.state.lastMonsterHp)} â†’ ${formatNumber(stats.monsterHp)} (PHASE CHANGE)`);
                        this.state.lastMonsterHp = stats.monsterHp;
                        this.state.lastLoggedDamage = null;

                        // Wait for phase change to stabilize
                        await sleepRandom(2000, 0.3, cfg.battle?.randomizeDelays ?? true);
                        continue;
                    }
                }
                this.state.lastMonsterHp = stats.monsterHp;

                // Detect monster phase
                const phaseInfo = this.detectMonsterPhase(context);

                // If phase just changed, give it a moment to stabilize
                if (phaseInfo.changed) {
                    logger.info(`â¸ï¸ Aguardando estabilizaÃ§Ã£o apÃ³s phase change...`);
                    context.events.emit('autods:battle:phaseChange', {
                        oldPhase: this.state.lastPhase - 1,
                        newPhase: phaseInfo.phase,
                        timestamp: Date.now()
                    });

                    // Wait for page to update
                    await sleepRandom(2000, 0.3, cfg.battle?.randomizeDelays ?? true);

                    // Re-read stats after phase change (using Phase 3 service)
                    const updatedStats = context.battleStats.getCurrent();
                    logger.info(`ðŸ“Š Stats pÃ³s-phase change: Dano=${context.numbers.format(updatedStats.damage)}, HP=${context.numbers.format(updatedStats.monsterHp || 0)}`);

                    // Continue to next iteration
                    continue;
                }

                if (this.state.lastLoggedDamage !== stats.damage) {
                    const hpDisplay = stats.monsterHp === null ? 'desconhecido' : formatNumber(stats.monsterHp);
                    const phaseIndicator = phaseInfo.isGolden ? `â­ Phase ${phaseInfo.phase}` : '';
                    logger.debug(`Dano atual: ${formatNumber(stats.damage)} | HP restante: ${hpDisplay} ${phaseIndicator}`);
                    this.state.lastLoggedDamage = stats.damage;
                }

                if (stats.monsterHp !== null && stats.monsterHp <= 0) {
                    // Check if this is a phase change (HP went to 0 but will respawn)
                    // Wait a moment and check again
                    await sleep(1500);
                    const recheckStats = context.battleStats.getCurrent();
                    const recheckPhase = this.detectMonsterPhase(context);

                    if (recheckStats.monsterHp > 0 || recheckPhase.changed) {
                        logger.info('ðŸ”„ Monstro ressuscitou em nova phase! Continuando batalha...');
                        // Phase change will be handled in the next iteration
                        continue;
                    }

                    logger.info('ðŸ’€ Monstro derrotado definitivamente. Encerrando automaÃ§Ã£o da batalha.');
                    context.events.emit('autods:battle:complete', {
                        damage: stats.damage,
                        monsterHp: stats.monsterHp,
                        reason: 'enemyDefeated',
                        timestamp: Date.now()
                    });
                    shouldReturnToWave = true;
                    returnReason = 'enemyDefeated';
                    break;
                }

                // Calcular targetDamage: usar configuraÃ§Ã£o de dungeon se aplicÃ¡vel
                let targetDamage = cfg.battle?.minDamageTarget ?? 0;
                
                // Dungeon Override
                if (isDungeonBattle && cfg.dungeonWave?.enabled !== false) {
                    const isMagus = dungeonMonsterName && /magus/i.test(dungeonMonsterName);
                    logger.debug(`ðŸŽ¯ Dungeon Monster: "${dungeonMonsterName}" | Ã‰ Magus? ${isMagus ? 'SIM' : 'NÃƒO'}`);
                    if (isMagus) {
                        targetDamage = cfg.dungeonWave?.magusDamageTarget ?? 1000000;
                        damageSource = 'dungeonMagus';
                        logger.info(`âš”ï¸ Usando dano alvo Magus: ${formatNumber(targetDamage)}`);
                    } else {
                        targetDamage = cfg.dungeonWave?.defaultDamageTarget ?? 3000000;
                        damageSource = 'dungeonDefault';
                        logger.info(`âš”ï¸ Usando dano alvo padrÃ£o dungeon: ${formatNumber(targetDamage)}`);
                    }
                }
                if (targetDamage > 0 && stats.damage >= targetDamage) {
                    logger.info(`Meta de dano atingida (${formatNumber(stats.damage)} >= ${formatNumber(targetDamage)}).`);
                    context.events.emit('autods:battle:complete', {
                        damage: stats.damage,
                        monsterHp: stats.monsterHp,
                        reason: 'targetDamage',
                        targetDamage,
                        timestamp: Date.now()
                    });
                    shouldReturnToWave = true;
                    returnReason = 'targetDamage';
                    break;
                }

                // Check damage BEFORE attack to prevent unnecessary clicks
                const statsBeforeAttack = context.battleStats.getCurrent();
                if (targetDamage > 0 && statsBeforeAttack.damage >= targetDamage) {
                    logger.info(`Meta de dano jÃ¡ atingida antes do ataque (${formatNumber(statsBeforeAttack.damage)} >= ${formatNumber(targetDamage)}).`);
                    context.events.emit('autods:battle:complete', {
                        damage: statsBeforeAttack.damage,
                        monsterHp: statsBeforeAttack.monsterHp,
                        reason: 'targetDamage',
                        targetDamage,
                        timestamp: Date.now()
                    });
                    shouldReturnToWave = true;
                    returnReason = 'targetDamage';
                    break;
                }

                // Select attack button with Smart Damage if enabled
                let attackResult;
                let selectedSkill = null;

                if (cfg.battle?.smartDamage?.enabled && targetDamage > 0) {
                    // Use Smart Damage to select optimal skill
                    attackResult = resolveSmartAttackButton(dom, stats.damage, targetDamage, cfg.battle);
                    if (!attackResult || !attackResult.button) {
                        logger.warn('Smart Damage: Nenhum botÃ£o de ataque encontrado.');

                        // Check if we're stuck on join screen
                        const stuckOnJoin = dom.query('#join-battle, button.btn-join, button.join-battle');
                        if (stuckOnJoin) {
                            logger.warn('Ainda na tela de join. Aguardando reload...');
                            await sleepRandom(2000, 0.2, true);
                            continue;
                        }

                        logger.warn('Nenhum botÃ£o disponÃ­vel. Encerrando loop.');
                        break;
                    }
                    selectedSkill = attackResult.skill;
                } else {
                    // Use regular attack button selection
                    const button = resolveAttackButton(dom, cfg.battle);
                    if (!button) {
                        logger.warn('BotÃ£o de ataque nÃ£o encontrado.');

                        // Check if we're stuck on join screen
                        const stuckOnJoin = dom.query('#join-battle, button.btn-join, button.join-battle');
                        if (stuckOnJoin) {
                            logger.warn('Ainda na tela de join. Aguardando reload...');
                            await sleepRandom(2000, 0.2, true);
                            continue;
                        }

                        logger.warn('Nenhum botÃ£o disponÃ­vel. Encerrando loop.');
                        break;
                    }
                    attackResult = { button };
                }

                attackButton = attackResult.button; // Update attackButton (declared outside loop)
                if (!attackButton) {
                    logger.warn('BotÃ£o de ataque nÃ£o disponÃ­vel. Encerrando loop.');
                    break;
                }

                // Check if button is disabled or loading
                if (attackButton.disabled || attackButton.classList.contains('is-loading')) {
                    logger.debug('BotÃ£o de ataque desabilitado ou em carregamento. Aguardando...');
                    await sleepRandom(500, 0.2, cfg.battle?.randomizeDelays ?? true);
                    continue;
                }

                // Check if we have enough stamina for the selected attack
                const hasEnoughStamina = this.checkStaminaForAttack(context, attackButton);
                if (!hasEnoughStamina) {
                    const skillName = attackButton.dataset?.skillName || attackButton.getAttribute('data-skill-name') || 'Unknown';
                    const staminaCost = this.getSkillStaminaCost(attackButton);
                    const currentStamina = context.stamina.getCurrent();

                    logger.warn(`âŒ Stamina insuficiente para ${skillName}`);
                    logger.info(`Stamina atual: ${currentStamina} | NecessÃ¡rio: ${staminaCost}`);

                    context.events.emit('autods:battle:stopped', {
                        reason: 'insufficientStamina',
                        currentStamina,
                        requiredStamina: staminaCost,
                        skillName,
                        timestamp: Date.now()
                    });

                    // VERIFICAÃ‡ÃƒO INTELIGENTE: SÃ³ voltar para wave se autoBoss estiver ativo
                    // Caso contrÃ¡rio, apenas parar o loop e ficar na pÃ¡gina de batalha
                    const isAutoBossActive = cfg.autoBoss?.enabled === true;
                    
                    if (isAutoBossActive) {
                        logger.info('ðŸ”„ Auto Boss ativo: voltando para wave...');
                        shouldReturnToWave = true;
                        returnReason = 'insufficientStamina';
                    } else {
                        logger.info('â¸ï¸ Parando batalha (permanecendo na pÃ¡gina). Recarregue para retomar com stamina recuperada.');
                        context.notifications.staminaLow(currentStamina, skillCost);
                        // Apenas sair do loop sem chamar returnToWave
                        shouldReturnToWave = false;
                    }
                    break;
                }

                // Check cooldown before attacking
                const cooldownCheck = this.canAttackNow();
                if (!cooldownCheck.ok) {
                    const waitSecs = Math.ceil(cooldownCheck.waitMs / 1000);
                    logger.debug(`â³ Aguardando cooldown... ${waitSecs}s`);
                    await sleep(cooldownCheck.waitMs);
                }

                // attackUnlockerModule handles button unlocking globally
                // Click the button and set last attack time
                attackButton.click();
                this.setLastAttackTime();

                const skillRef = attackButton.dataset?.skillId ?? attackButton.getAttribute?.('data-skill-id') ?? 'default';

                if (selectedSkill) {
                    const remainingDamage = targetDamage - stats.damage;
                    logger.info(`Smart Damage: ${selectedSkill.name} selecionado (limite: ${formatNumber(selectedSkill.damageLimit)}, faltam: ${formatNumber(remainingDamage)})`);
                } else {
                    logger.debug(`Ataque disparado (skill ${skillRef}).`);
                }

                await sleepRandom(delayBase, variation, randomize);

                // Check damage AFTER attack to prevent overshooting
                const statsAfterAttack = context.battleStats.getCurrent();
                logger.debug(`VerificaÃ§Ã£o pÃ³s-ataque: dano=${formatNumber(statsAfterAttack.damage)}, meta=${formatNumber(targetDamage)}`);

                if (targetDamage > 0 && statsAfterAttack.damage >= targetDamage) {
                    logger.info(`Meta de dano atingida apÃ³s ataque (${formatNumber(statsAfterAttack.damage)} >= ${formatNumber(targetDamage)}).`);
                    context.events.emit('autods:battle:complete', {
                        damage: statsAfterAttack.damage,
                        monsterHp: statsAfterAttack.monsterHp,
                        reason: 'targetDamage',
                        targetDamage,
                        timestamp: Date.now()
                    });
                    shouldReturnToWave = true;
                    returnReason = 'targetDamage';
                    break;
                } else if (targetDamage > 0) {
                    logger.debug(`Continuando batalha: ${formatNumber(statsAfterAttack.damage)} < ${formatNumber(targetDamage)}`);
                }
            }

            if (shouldReturnToWave) {
                await sleep(600);
                this.returnToWave(context, returnReason);
            }
        },
        async tryJoinBattle(context) {
            const { dom, logger } = context;

            const limiterNotice = Array.from(document.querySelectorAll('.alert, .notification, .message, #system_message'))
                .find(el => /only join 5 monsters/i.test(el.textContent || ''));
            if (limiterNotice) {
                logger.warn('Limite de batalhas simultÃ¢neas atingido (mensagem do sistema).');
                context.events.emit('autods:battle:blocked', { timestamp: Date.now() });
                return 'blocked';
            }

            // New button structure: #join-battle (primary), or fallback to old selectors
            const joinButton = dom.query('#join-battle, button.btn-join, button.join-battle');
            if (!joinButton) {
                logger.debug('BotÃ£o de join nÃ£o encontrado - assumindo que jÃ¡ estÃ¡ na batalha.');
                return 'noop';
            }
            if (joinButton.disabled) {
                logger.debug('BotÃ£o de join desabilitado - aguardando disponibilidade.');
                return 'noop';
            }

            // Extract monster_id from URL
            const battleUrl = context.window?.location?.href || window.location.href;
            const monsterIdMatch = battleUrl.match(/[?&]id=(\d+)/);
            const monsterId = monsterIdMatch ? monsterIdMatch[1] : null;

            // Get user_id from config or auto-detect
            const cfg = context.config.get();
            let userId = cfg.core?.userId || cfg.userId || cfg.wave?.userId || cfg.battle?.userId;

            // Try to auto-detect userId from page elements
            if (!userId) {
                // Try common selectors where user ID might be stored
                const userIdElement = dom.query('[data-user-id], [data-userid], #user_id, #userId, .user-id');
                if (userIdElement) {
                    userId = userIdElement.dataset?.userId
                        || userIdElement.dataset?.userid
                        || userIdElement.getAttribute('data-user-id')
                        || userIdElement.getAttribute('data-userid')
                        || userIdElement.value
                        || userIdElement.textContent?.trim();

                    if (userId) {
                        logger.info(`User ID auto-detectado: ${userId}`);
                        // Save it to config for future use
                        context.config.update({ core: { userId } });
                    }
                }
            }

            // If we have both IDs, use AJAX request (new site behavior)
            if (monsterId && userId) {
                try {
                    logger.info(`Enviando requisiÃ§Ã£o AJAX para entrar na batalha (monster_id: ${monsterId}, user_id: ${userId}).`);

                    // Use HTTP service with Cloudflare bypass
                    const result = await context.http.joinBattle(monsterId, userId);
                    const msg = result.message || '';
                    
                    // VERIFICAÃ‡ÃƒO INTELIGENTE: Detectar bloqueio Cloudflare
                    const isCloudflareBlock = msg.includes('Cloudflare') || msg.includes('cf-') || msg.includes('Just a moment');
                    const is403Forbidden = response.status === 403;
                    const is500Error = response.status >= 500;
                    
                    if (isCloudflareBlock || is403Forbidden || is500Error) {
                        const reason = isCloudflareBlock ? 'Cloudflare protection' : `HTTP ${response.status}`;
                        logger.warn(`âš ï¸ RequisiÃ§Ã£o AJAX bloqueada por ${reason}. Usando fallback (click).`);
                        // Usar mÃ©todo tradicional (click no botÃ£o)
                        joinButton.click();
                        context.events.emit('autods:battle:join', { 
                            method: 'fallback-click',
                            reason: reason,
                            timestamp: Date.now() 
                        });
                        return 'clicked';
                    }
                    
                    const success = msg.toLowerCase().startsWith('you have successfully');

                    if (success) {
                        logger.info('Entrada na batalha confirmada via AJAX.');
                        context.events.emit('autods:battle:join', {
                            monsterId,
                            userId,
                            timestamp: Date.now()
                        });

                        // Wait a bit before reloading
                        await sleepRandom(900, 0.2, true);

                        // Reload the page to reflect the battle state
                        window.location.reload();
                        return 'joined';
                    } else {
                        logger.warn(`Falha ao entrar na batalha via AJAX: ${msg.substring(0, 200)}`);

                        // Check if it's the "already joined" or "max battles" message
                        if (/only join 5 monsters/i.test(msg)) {
                            context.events.emit('autods:battle:blocked', { timestamp: Date.now() });
                            return 'blocked';
                        }

                        // Fallback para click se AJAX falhou
                        logger.info('Usando fallback (click) apÃ³s falha AJAX.');
                        joinButton.click();
                        context.events.emit('autods:battle:join', { 
                            method: 'fallback-click-after-failure',
                            timestamp: Date.now() 
                        });
                        return 'clicked';
                    }
                } catch (error) {
                    logger.error('Erro na requisiÃ§Ã£o AJAX de entrada na batalha:', error);
                    // Fallback to clicking the button if AJAX fails
                    logger.info('Usando fallback (click) apÃ³s erro AJAX.');
                    joinButton.click();
                    context.events.emit('autods:battle:join', { 
                        method: 'fallback-click-after-error',
                        timestamp: Date.now() 
                    });
                    return 'clicked';
                }
            } else {
                if (!userId) {
                    logger.warn('User ID nÃ£o encontrado. Configure manualmente em core.userId ou o script tentarÃ¡ clicar no botÃ£o.');
                }
            }

            // Fallback: click the button (old behavior or if IDs not found)
            logger.info('Acionando botÃ£o de entrada na batalha (fallback).');
            joinButton.click();
            context.events.emit('autods:battle:join', { timestamp: Date.now() });
            await sleepRandom(1500, 0.2, true);
            return 'joined';
        },
        returnToWave(context, reason = 'unknown') {
            // LOG DETALHADO: Capturar stack trace para debug
            const stack = new Error().stack;
            const callerLine = stack?.split('\n')[2]?.trim() || 'unknown';
            context.logger.info(`ðŸ”„ returnToWave chamado | Motivo: ${reason} | Chamador: ${callerLine}`);
            
            // Special handling for dungeon battles - return to previous page
            const cfg = context.config.get();
            const isDungeonBattle = /dungeon_battle\.php/i.test(window.location.pathname) 
                || (window.location.search && window.location.search.includes('instance_id'));
            
            if (isDungeonBattle) {
                const isGuildDungeon = window.location.search && window.location.search.includes('instance_id');
                if (isGuildDungeon) {
                    context.logger.info(`ðŸ° Retornando para a localizaÃ§Ã£o da Guild Dungeon [motivo: ${reason}].`);
                } else {
                    context.logger.info(`Retornando para a pÃ¡gina anterior do dungeon [motivo: ${reason}].`);
                }
                try {
                    window.history.back();
                    return;
                } catch (error) {
                    context.logger.warn('NÃ£o foi possÃ­vel voltar Ã  pÃ¡gina anterior. Permanecendo na pÃ¡gina atual.', error);
                    return;
                }
            }

            // Normal battle.php handling - return to wave
            const origin = context.window?.location?.origin || window.location?.origin || 'https://demonicscans.org';
            const stored = context.storage.get(STORAGE_KEYS.lastWaveUrl, null);
            const configured = context.config.get().wave?.returnUrl;
            const fallback = configured || '/active_wave.php';
            let destination = typeof stored === 'string' && stored.trim().length ? stored : fallback;

            try {
                const url = new URL(destination, origin);
                
                if (/active_wave\.php/i.test(window.location.pathname) && window.location.href === url.href) {
                    context.logger.debug(`JÃ¡ estÃ¡ em ${url.href}, nÃ£o Ã© necessÃ¡rio redirecionar.`);
                    return;
                }
                context.logger.info(`Retornando para a wave (${url.href}) [motivo: ${reason}].`);
                window.location.href = url.href;
            } catch (error) {
                context.logger.warn('URL da wave invÃ¡lida, utilizando fallback padrÃ£o.', { destination, error });
                try {
                    const fallbackUrl = new URL('/active_wave.php', origin);
                    window.location.href = fallbackUrl.href;
                } catch (innerError) {
                    context.logger.error('Falha ao redirecionar para a wave.', innerError);
                }
            }
        }
    };

    // ========================================
    // FARMING MODULE (Energy farming)
    // ========================================
    const farmingModule = {
        id: 'energyFarm',
        match: ({ location }) => {
            const path = location.pathname.toLowerCase();
            return path === '/' || path === '/index.php' || path === '/signin.php' || path === '/bookmarks.php' || /\/manga\//.test(path) || /\/title\//.test(path) || /\/chapter\//.test(path);
        },
        init(context) {
            this.state = {
                running: false,
                loginAttempted: false,
                resumeHandled: false,
                automationDisabled: false,
                redirectingToLogin: false,
                missingStaminaCount: 0,  // Contador de falhas consecutivas de missing-stamina
                lastStaminaCheck: 0  // Timestamp da Ãºltima verificaÃ§Ã£o
            };
            context.logger.debug('energyFarm module initialised');
        },
        activate(context) {
            // DISABLED in v0.8.0-alpha: Energy farming module no longer supported
            // The 'farm' section was completely removed as part of UI redesign
            // Use ultraFast* modules instead for all farming automation
            return;
        },
        async run(context) {
            const path = context.location.pathname.toLowerCase();
            const isLogged = this.isLoggedIn();

            context.logger.info(`ðŸ” [DEBUG] ========== farmingModule.run ==========`);
            context.logger.info(`ðŸ” [DEBUG] PÃ¡gina: ${path}, Logado: ${isLogged}`);
            context.logger.debug(`[Farming] PÃ¡gina: ${path}, Logado: ${isLogged}`);

            // Handle signin page FIRST - highest priority (antes de resumeIfNeeded!)
            if (path === '/signin.php') {
                // If already logged in on signin page, try to resume or go home
                if (isLogged) {
                    context.logger.info('[Farming] JÃ¡ estÃ¡ logado em /signin.php. Tentando retomar...');
                    if (this.resumeIfNeeded(context)) {
                        context.logger.debug('[Farming] Redirecionando para pÃ¡gina salva');
                        return;
                    }
                    // No resume URL, go home
                    this.navigateHome(context);
                    return;
                }
                // Otherwise try auto-login or wait
                context.logger.info('[Farming] Detectada pÃ¡gina de signin - tentando login automÃ¡tico');
                await this.handleSignin(context);
                return;
            }

            // Handle bookmarks redirect from signin (already logged in scenario)
            if (path === '/bookmarks.php') {
                context.logger.info('[Farming] Redirecionado para bookmarks. Tentando retomar...');
                if (this.resumeIfNeeded(context)) {
                    context.logger.debug('[Farming] Redirecionando para pÃ¡gina salva');
                    return;
                }
                // No resume URL, go home
                this.navigateHome(context);
                return;
            }

            // Now check resume for other pages
            if (this.resumeIfNeeded(context)) {
                context.logger.debug('[Farming] Redirecionando para pÃ¡gina salva');
                return; // Redirecting to resume page
            }

            // Ensure user is logged in before proceeding
            if (!this.ensureLogin(context)) {
                context.logger.debug('[Farming] UsuÃ¡rio nÃ£o estÃ¡ logado, aguardando login');
                return;
            }

            // Check if farming is still enabled
            if (!context.config.get().farm.enabled) {
                context.logger.debug('[Farming] Farming desabilitado no config');
                return;
            }

            // Route-specific handlers
            // CRITICAL: Check /chapter/ BEFORE /title/ because URLs like /title/.../chapter/1 contain both
            if (/\/chapter\//.test(path)) {
                context.logger.info('ðŸ” [DEBUG] Detectado pÃ¡gina de capÃ­tulo! Iniciando handleChapterPage');
                context.logger.debug('[Farming] Processando pÃ¡gina de capÃ­tulo');
                await this.handleChapterPage(context);
                return;
            }

            if (path === '/' || path === '/index.php') {
                context.logger.debug('[Farming] Processando homepage');
                await this.handleHomepage(context);
                return;
            }

            if (/\/title\//.test(path) || /\/manga\//.test(path)) {
                context.logger.debug('[Farming] Processando pÃ¡gina de mangÃ¡');
                await this.handleMangaPage(context);
                return;
            }

            context.logger.info(`ðŸ” [DEBUG] Nenhuma rota matched. Path: ${path}`);
            context.logger.debug('[Farming] Nenhuma aÃ§Ã£o necessÃ¡ria nesta rota.', { path });
        },
        ensureLogin(context) {
            if (this.isLoggedIn()) {
                this.state.redirectingToLogin = false; // Reset flag when logged in
                return true;
            }

            const currentPath = context.location.pathname.toLowerCase();

            // Don't redirect if already on signin or bookmarks (redirect page)
            if (currentPath === '/signin.php' || currentPath === '/bookmarks.php') {
                return false;
            }

            // Prevent multiple redirects in quick succession
            if (this.state.redirectingToLogin) {
                context.logger.debug('JÃ¡ estÃ¡ redirecionando para login, aguardando...');
                return false;
            }

            // Save current location for resume after login
            const { resumeAfterLogin } = context.config.get().farm;
            if (resumeAfterLogin !== false) {
                sessionStorage.setItem('autods.farm.resume', context.window.location.href);
                context.logger.debug('Salvando pÃ¡gina atual para retomar apÃ³s login.', { current: context.window.location.href });
            }

            this.state.redirectingToLogin = true;
            context.logger.warn('UsuÃ¡rio nÃ£o autenticado. Redirecionando para a pÃ¡gina de login.');
            context.window.location.href = 'https://demonicscans.org/signin.php';
            return false;
        },
        isLoggedIn() {
            // Verificar se existe link de signout (mais confiÃ¡vel)
            const signoutLink = document.querySelector('a[href*="signout"], a[href*="logout"]');
            if (signoutLink) return true;

            // Verificar se NÃƒO estÃ¡ na pÃ¡gina de signin (se nÃ£o tem formulÃ¡rio de login, provavelmente estÃ¡ logado)
            const loginForm = document.querySelector('#login-container, form[action*="signin"], form[action*="login"]');
            if (!loginForm && window.location.pathname !== '/signin.php') return true;

            // VerificaÃ§Ãµes adicionais
            return Boolean(
                document.querySelector('[data-user-id]') ||
                document.querySelector('.user-info, .user-avatar, .account-box, #user_dropdown, .user-menu, .gtb-user') ||
                document.querySelector('a[href*="bookmarks"]')
            );
        },
        resumeIfNeeded(context) {
            if (this.state.resumeHandled) return false;
            this.state.resumeHandled = true;
            const resumeUrl = sessionStorage.getItem('autods.farm.resume');
            if (!resumeUrl) return false;

            // Already at the resume destination
            if (resumeUrl === context.window.location.href) {
                sessionStorage.removeItem('autods.farm.resume');
                context.logger.debug('JÃ¡ estÃ¡ na pÃ¡gina de retomada. Limpando flag.');
                return false;
            }

            // Redirect to saved page
            sessionStorage.removeItem('autods.farm.resume');
            context.logger.info('Retomando farming apÃ³s login bem-sucedido.', { resumeUrl });
            context.window.location.href = resumeUrl;
            return true; // Indica que estÃ¡ redirecionando
        },
        async handleSignin(context) {
            context.logger.info('[Farming] Processando pÃ¡gina de signin');

            // Verificar se jÃ¡ estÃ¡ logado (pode ter feito login manual)
            if (this.isLoggedIn()) {
                context.logger.info('[Farming] Login jÃ¡ efetuado, retomando farming');
                this.resumeIfNeeded(context);
                return;
            }

            const cfg = context.config.get().farm;
            
            // Verificar se credenciais estÃ£o configuradas
            const credentials = cfg.credentials || {};
            const hasCredentials = credentials.email && credentials.password;

            if (!hasCredentials) {
                context.logger.warn('âš ï¸ [Farming] Credenciais nÃ£o configuradas. Aguardando login manual...');
                context.logger.warn('Configure as credenciais no painel ou faÃ§a login manualmente.');
                
                // Aguardar e verificar periodicamente se o login foi feito manualmente
                await sleep(3000);
                if (this.isLoggedIn()) {
                    context.logger.info('[Farming] Login manual detectado! Retomando farming...');
                    this.resumeIfNeeded(context);
                } else {
                    // Tentar novamente apÃ³s 5 segundos
                    context.window.setTimeout(() => this.handleSignin(context), 5000);
                }
                return;
            }

            // Verificar se jÃ¡ tentou fazer login (evitar loops)
            if (this.state.loginAttempted) {
                context.logger.debug('[Farming] Login jÃ¡ foi tentado, aguardando resultado');
                
                // Aguardar e verificar se o login foi bem-sucedido
                await sleep(3000);
                if (this.isLoggedIn()) {
                    context.logger.info('[Farming] Login bem-sucedido! Retomando farming...');
                    this.state.loginAttempted = false; // Reset para prÃ³xima vez
                    this.resumeIfNeeded(context);
                } else {
                    context.logger.error('[Farming] Login falhou. Aguardando intervenÃ§Ã£o manual...');
                    this.state.loginAttempted = false; // Reset para permitir nova tentativa
                    await sleep(5000);
                    // Tentar novamente
                    this.handleSignin(context);
                }
                return;
            }

            // Buscar formulÃ¡rio de login
            const form = document.querySelector('#login-container form, form[action*="signin"], form[action*="login"], form[action*="auth"]');
            if (!form) {
                context.logger.warn('[Farming] FormulÃ¡rio de login nÃ£o encontrado. Aguardando...');
                await sleep(2000);
                this.handleSignin(context);
                return;
            }

            // Buscar campos de email e senha
            const emailInput = form.querySelector('input[type="email"], input[name="email"], input[name*="email" i]');
            const passwordInput = form.querySelector('input[type="password"], input[name="password"], input[name*="pass" i]');
            const submitButton = form.querySelector('button[type="submit"], input[type="submit"], input[name="submit"]');

            if (!emailInput || !passwordInput) {
                context.logger.warn('[Farming] Campos de email ou senha nÃ£o encontrados.');
                return;
            }

            // Preencher credenciais
            context.logger.info('[Farming] Preenchendo credenciais de login...');
            emailInput.value = credentials.email;
            passwordInput.value = credentials.password;
            
            // Marcar que tentou fazer login
            this.state.loginAttempted = true;

            // Aguardar um pouco antes de submeter (parecer mais humano)
            await sleep(500);

            // Submeter formulÃ¡rio
            context.logger.info('[Farming] Enviando formulÃ¡rio de login...');
            if (submitButton) {
                submitButton.click();
            } else if (typeof form.requestSubmit === 'function') {
                form.requestSubmit();
            } else {
                form.submit();
            }

            // Aguardar redirect e verificar se login foi bem-sucedido
            await sleep(3000);
            
            // Se ainda estiver na pÃ¡gina de signin apÃ³s 3s, pode ter havido erro
            if (context.location.pathname.toLowerCase() === '/signin.php') {
                context.logger.warn('[Farming] Ainda na pÃ¡gina de signin apÃ³s submeter. Verificando erro...');
                
                const errorElement = document.querySelector('.error, .alert-danger, .login-error, p.error');
                if (errorElement && errorElement.textContent.trim()) {
                    context.logger.error(`[Farming] Erro de login: ${errorElement.textContent.trim()}`);
                    context.logger.error('[Farming] Verifique suas credenciais na configuraÃ§Ã£o.');
                    this.state.loginAttempted = false;
                    return;
                }
            }
        },
        async handleHomepage(context) {
            context.logger.info('Farming: selecionando mangÃ¡ aleatÃ³rio.');
            const anchor = await waitForAny([
                '.owl-item .owl-element a[href*="/manga/"]',
                '.owl-carousel a[href*="/manga/"]',
                '.featured-slider a[href*="/manga/"]',
                'a[href*="/manga/"]'
            ], { timeout: 10000, interval: 200 });

            if (!anchor) {
                context.logger.warn('NÃ£o foi possÃ­vel localizar mangÃ¡s na pÃ¡gina inicial para iniciar o farming. Nova tentativa apÃ³s recarregar.');
                context.window.setTimeout(() => context.window.location.reload(), 4000);
                return;
            }

            const candidates = Array.from(document.querySelectorAll('.owl-item .owl-element a[href*="/manga/"]'));
            const pool = candidates.length ? candidates : [anchor];
            const target = pool[Math.floor(Math.random() * pool.length)];
            if (!target || !target.href) {
                context.logger.warn('Link de mangÃ¡ invÃ¡lido.');
                return;
            }
            context.logger.info(`Farming: navegando para ${target.href}`);
            context.window.location.href = target.href;
        },
        async handleMangaPage(context) {
            context.logger.info('Farming: localizando Ãºltimo capÃ­tulo disponÃ­vel.');
            const list = await waitForAny([
                '#chapters-list li a',
                '.chapters-list li a',
                '.chapter-list a',
                '.listing-chapters a'
            ], { timeout: 10000, interval: 200 });

            if (!list) {
                context.logger.warn('Lista de capÃ­tulos nÃ£o encontrada. Tentando novamente em breve.');
                context.window.setTimeout(() => this.handleMangaPage(context), 2000);
                return;
            }

            const chapters = Array.from(document.querySelectorAll('#chapters-list li a, .chapters-list li a, .chapter-list a, .listing-chapters a'));
            const last = chapters.length ? chapters[chapters.length - 1] : list;
            if (!last || !last.href) {
                context.logger.warn('NÃ£o foi possÃ­vel identificar o link do Ãºltimo capÃ­tulo.');
                return;
            }
            context.logger.info(`Farming: abrindo capÃ­tulo ${last.href}`);
            context.window.location.href = last.href;
        },
        async handleChapterPage(context) {
            context.logger.info('ðŸ” [DEBUG] ========== INICIANDO handleChapterPage ==========');
            context.logger.info(`ðŸ” [DEBUG] URL atual: ${context.window.location.href}`);
            context.logger.debug('[Farming] Iniciando processamento de pÃ¡gina de capÃ­tulo');

            const limitCheck = this.checkFarmingLimits(context);
            context.logger.info(`ðŸ” [DEBUG] Limite check - allowed: ${limitCheck.allowed}, reason: ${limitCheck.reason || 'nenhum'}`);

            if (!limitCheck.allowed) {
                context.logger.debug(`[Farming] Limite atingido: ${limitCheck.reason}`);
                if (limitCheck.disable) {
                    this.disableAutomation(context, limitCheck.reason);
                }
                if (limitCheck.nextDelay) {
                    context.window.setTimeout(() => this.handleChapterPage(context), limitCheck.nextDelay);
                }
                return;
            }

            context.logger.info('ðŸ” [DEBUG] Limites OK, tentando clicar na reaÃ§Ã£o...');
            context.logger.debug('[Farming] Tentando clicar na reaÃ§Ã£o...');
            const clicked = await this.clickReaction(context);
            context.logger.info(`ðŸ” [DEBUG] Resultado do clickReaction: ${clicked}`);

            if (!clicked) {
                if (!this.ensureLogin(context)) {
                    context.logger.warn('[Farming] UsuÃ¡rio nÃ£o logado, redirecionando...');
                    return;
                }
                context.logger.warn('[Farming] NÃ£o foi possÃ­vel encontrar o botÃ£o de reaÃ§Ã£o. Tentando novamente em 4s.');
                context.window.setTimeout(() => this.handleChapterPage(context), 4000);
                return;
            }

            context.logger.debug('[Farming] ReaÃ§Ã£o clicada, aguardando antes de avanÃ§ar...');
            await sleepRandom(1500, 0.25, true);
            this.goNextChapter(context);
        },
        getStamina() {
            return readGauge([
                '#stamina_span',
                '[data-player-stamina]',
                '.gtb-stat[data-stat="stamina"] .gtb-value',
                '.stamina .current'
            ], {
                xpath: [
                    '//*[@id="discuscontainer"]/div[1]/div[1]/div[2]/span[1]/span'
                ]
            });
        },
        getFarmEnergy() {
            return readGauge([
                '#farm_span',
                '[data-player-farm]',
                '.gtb-stat[data-stat="farm"] .gtb-value',
                '.farm .current'
            ], {
                xpath: [
                    '//*[@id="discuscontainer"]/div[1]/div[1]/div[2]/span[2]/span'
                ]
            });
        },
        checkFarmingLimits(context) {
            // DISABLED in v0.8.0-alpha: Farm configuration no longer supported
            // This function is kept for backward compatibility but always returns disabled
            return { allowed: false, reason: 'energy-farming-disabled' };
        },
        disableAutomation(context, reason) {
            if (this.state.automationDisabled) return;
            this.state.automationDisabled = true;
            context.logger.info(`Desativando automaÃ§Ã£o de farming: ${reason}`);
            context.config.update({ farm: { enabled: false } });
            context.events.emit('autods:farm:disabled', { reason, timestamp: Date.now() });
        },
        async clickReaction(context) {
            context.logger.info('ðŸ” [DEBUG] Iniciando clickReaction...');

            // Wait for page to fully load
            await sleepRandom(800, 0.2, true);

            // Debug: Check for chapter-reactions container
            const container = document.querySelector('.chapter-reactions');
            context.logger.info(`ðŸ” [DEBUG] Container .chapter-reactions encontrado: ${!!container}`);

            if (container) {
                context.logger.info(`ðŸ” [DEBUG] Container HTML: ${container.outerHTML.substring(0, 200)}...`);

                // Check for all reaction elements
                const allReactions = container.querySelectorAll('.reaction');
                context.logger.info(`ðŸ” [DEBUG] Quantidade de .reaction encontrados: ${allReactions.length}`);

                allReactions.forEach((reaction, index) => {
                    context.logger.info(`ðŸ” [DEBUG] Reaction ${index}: data-reaction="${reaction.getAttribute('data-reaction')}", text="${reaction.textContent.trim()}"`);
                });
            }

            // New reaction system uses div.reaction with data-reaction attributes
            let reactionDiv = document.querySelector('.chapter-reactions .reaction[data-reaction]');
            context.logger.info(`ðŸ” [DEBUG] Reaction div encontrado: ${!!reactionDiv}`);

            if (!reactionDiv) {
                // Try alternative selectors with debug
                const altSelectors = [
                    '.reaction[data-reaction]',
                    'div[data-reaction]',
                    '[data-reaction]'
                ];

                for (const selector of altSelectors) {
                    const alt = document.querySelector(selector);
                    if (alt) {
                        context.logger.info(`ðŸ” [DEBUG] Encontrado com seletor alternativo: ${selector}`);
                        reactionDiv = alt;
                        break;
                    }
                }

                if (!reactionDiv) {
                    context.logger.warn('âŒ Elemento de reaÃ§Ã£o nÃ£o encontrado em nenhum seletor.');
                    return false;
                }
            }

            context.logger.info(`ðŸ” [DEBUG] Reaction selecionado: data-reaction="${reactionDiv.getAttribute('data-reaction')}", class="${reactionDiv.className}"`);
            context.logger.info(`ðŸ” [DEBUG] Reaction HTML: ${reactionDiv.outerHTML}`);

            // Scroll into view and click
            reactionDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
            context.logger.info('ðŸ” [DEBUG] ScrollIntoView executado');

            await sleepRandom(300, 0.1, true);

            context.logger.info('ðŸ” [DEBUG] Executando click...');
            reactionDiv.click();

            context.logger.info('âœ… ReaÃ§Ã£o do capÃ­tulo acionada para farming.');
            return true;
        },
        goNextChapter(context) {
            // Try multiple selectors for next chapter button (from Smol script)
            const selectors = [
                'body > div.chapter-info > div > a.nextchap',  // Smol's selector
                'a.nextchap',
                'a[rel="next"]',
                '.next-chapter',
                '.chapter-nav .next a',
                '.chapter-navigation .next',
                'a[href*="/chapter/"][class*="next" i]'
            ];

            let link = null;
            for (const selector of selectors) {
                link = document.querySelector(selector);
                if (link && link.href) {
                    context.logger.debug(`PrÃ³ximo capÃ­tulo encontrado via: ${selector}`);
                    break;
                }
            }

            if (link && link.href) {
                context.logger.info(`âž¡ï¸ AvanÃ§ando para o prÃ³ximo capÃ­tulo: ${link.href}`);
                context.events.emit('autods:farm:chapter', { timestamp: Date.now(), href: link.href });
                context.window.location.href = link.href;
                return;
            }

            context.logger.warn('âŒ PrÃ³ximo capÃ­tulo nÃ£o encontrado. Reiniciando ciclo no dashboard.');
            this.navigateHome(context);
        },
        navigateHome(context) {
            if (context.location.pathname === '/' || context.location.pathname === '/index.php') {
                return;
            }
            context.window.location.href = 'https://demonicscans.org';
        }
    };

    // ============================================================================
    // ULTRA FAST FARM MODULE - Parallel batch operations for maximum speed
    // ============================================================================
    const ultraFastAttackModule = {
        id: 'ultraFastAttack',
        match: ({ location }) => /active_wave\.php/i.test(location.pathname),
        
        init(context) {
            this.state = {
                running: false,
                manualMode: true,  // ðŸ†• Flag para indicar modo manual (via botÃ£o)
                currentBatch: [],
                stats: {
                    totalBatches: 0,
                    totalMonsters: 0,
                    successfulJoins: 0,
                    failedJoins: 0,
                    totalAttacks: 0,
                    startTime: null
                }
            };
            // context.logger.debug('[UltraFastAttack] Module initialized');
        },

        activate(context) {
            const cfg = context.config.get();
            if (!cfg.core.enabled || !cfg.ultraFastAttack?.enabled) {
                if (this.state) this.state.running = false;
                return;
            }
            
            if (!this.state) this.init(context);
            
            // ðŸ†• SEMPRE usar modo manual (sÃ³ executa via botÃ£o)
            // NÃ£o executar automaticamente mesmo quando ativado
            this.state.manualMode = true;
            context.logger.debug('[UltraFastAttack] Module activated, waiting for manual trigger via button');
        },

        triggerManualRun(context) {
            const { logger } = context;
            const cfg = context.config.get().ultraFastAttack;
            
            if (this.state.running) {
                logger.warn('[UltraFastAttack] JÃ¡ estÃ¡ rodando');
                return;
            }

            // CHECK SAFE MODE: Don't allow join if >10 continues already active
            const slotInfo = this.checkAvailableSlots(context, cfg.maxConcurrentBattles);
            if (slotInfo.continueCount > 10) {
                logger.warn(`âš ï¸ NÃƒO Ã‰ SEGURO! ${slotInfo.continueCount} batalhas simultÃ¢neas ativas (limite: 10)`);
                logger.warn('ðŸ’¡ Aguarde completar algumas batalhas antes de iniciar Ultra Fast Farm.');
                context.notifications?.notify?.(
                    `âš ï¸ Muitas batalhas ativas (${slotInfo.continueCount} > 10). Aguarde completar algumas.`,
                    'warning'
                );
                return;
            }

            this.state.running = true;
            this.state.stats.startTime = Date.now();
            
            logger.info('âš¡ Ultra Fast Farm iniciado manualmente!');
            
            (async () => {
                try {
                    await this.runBatchFarm(context);
                } catch (error) {
                    logger.error('[UltraFastAttack] Erro fatal:', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },

        async runBatchFarm(context) {
            const cfg = context.config.get().ultraFastAttack;
            const { logger } = context;

            logger.info(`ðŸ“Š ConfiguraÃ§Ã£o: ${cfg.maxParallelBattles} batalhas paralelas, ${cfg.attacksPerMonster} ataques por mob`);

            // 0. Check available slots (count monsters with "Continue" button)
            const slotInfo = this.checkAvailableSlots(context, cfg.maxConcurrentBattles);
            const availableSlots = slotInfo.availableSlots;
            const continueCount = slotInfo.continueCount;
            
            // If more than 10 continues, only check damage on joined battles
            if (continueCount > 10) {
                logger.warn(`âš ï¸ MUITAS BATALHAS ATIVAS (${continueCount} > 10)! Modo seguro: apenas verificando dano dos monstros jÃ¡ joined.`);
                logger.info('ðŸ’¡ NÃ£o serÃ¡ feito join em novos monstros para evitar sobrecarga do servidor.');
                
                // Check damage on already joined battles
                await this.checkAndAttackJoinedMonsters(context);
                return;
            }
            
            if (availableSlots === 0) {
                logger.warn('âš ï¸ Nenhum slot disponÃ­vel! Todas as batalhas jÃ¡ foram iniciadas.');
                logger.info('ðŸ’¡ Aguarde completar algumas batalhas antes de iniciar Ultra Fast Farm.');
                if (cfg.autoReturnToWave) {
                    await sleep(2000);
                    window.location.reload();
                }
                return;
            }

            logger.info(`âœ… Slots disponÃ­veis: ${availableSlots}/${cfg.maxConcurrentBattles}`);

            // Ajustar maxParallelBattles baseado nos slots disponÃ­veis
            //const effectiveMaxBattles = Math.min(cfg.maxParallelBattles, availableSlots);
            const effectiveMaxBattles = cfg.maxParallelBattles
            
            // if (effectiveMaxBattles < cfg.maxParallelBattles) {
            //     logger.info(`âš™ï¸ Ajustando batalhas paralelas: ${cfg.maxParallelBattles} â†’ ${effectiveMaxBattles} (slots disponÃ­veis)`);
            // }

            // 1. Scan monsters from page
            const targets = await this.scanTargets(context);
            
            if (targets.length === 0) {
                logger.info('âŒ Nenhum mob disponÃ­vel para farm ultra rÃ¡pido');
                if (cfg.autoReturnToWave) {
                    await sleep(2000);
                    window.location.reload();
                }
                return;
            }

            // 2. Group into batches (usando effectiveMaxBattles ao invÃ©s de cfg.maxParallelBattles)
            const batches = [];
            for (let i = 0; i < targets.length; i += effectiveMaxBattles) {
                batches.push(targets.slice(i, i + effectiveMaxBattles));
            }

            logger.info(`ðŸŽ¯ ${targets.length} mobs encontrados â†’ ${batches.length} lotes paralelos (${effectiveMaxBattles} mobs/lote)`);

            // 3. Process each batch
            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                this.state.currentBatch = batch;
                this.state.stats.totalBatches++;

                logger.info(`âš¡ Lote ${batchIndex + 1}/${batches.length}: ${batch.length} mobs`);

                // Join all battles in parallel
                const joinResults = await this.joinBattlesParallel(context, batch);
                const successfulJoins = joinResults.filter(r => r.success);

                logger.info(`âœ… Entradas: ${successfulJoins.length}/${batch.length} bem-sucedidas`);

                if (successfulJoins.length === 0) {
                    logger.warn('âš ï¸ Nenhuma entrada bem-sucedida neste lote, pulando...');
                    continue;
                }

                // â³ CRITICAL: Aguardar servidor processar os joins antes de atacar
                // Sem esse delay, hÃ¡ race condition onde os attacks chegam antes dos joins serem processados
                const joinServerDelay = cfg.delayAfterJoin || 500; // Default 500ms
                logger.debug(`â³ Aguardando ${joinServerDelay}ms para servidor processar joins...`);
                await sleep(joinServerDelay);

                // Attack all battles in parallel (N times each)
                for (let attackRound = 0; attackRound < cfg.attacksPerMonster; attackRound++) {
                    logger.info(`âš”ï¸ Rodada de ataque ${attackRound + 1}/${cfg.attacksPerMonster}`);
                    await this.attackBattlesParallel(context, successfulJoins, cfg.skillId);
                    
                    // Small delay between attack rounds
                    if (attackRound < cfg.attacksPerMonster - 1) {
                        await sleep(300);
                    }
                }

                // Leave all battles in parallel (optional - can skip if we reload page)
                // await this.leaveBattlesParallel(context, successfulJoins);

                // Delay between batches
                if (batchIndex < batches.length - 1) {
                    logger.info(`â³ Aguardando ${cfg.delayBetweenBatches}ms antes do prÃ³ximo lote...`);
                    await sleep(cfg.delayBetweenBatches);
                }
            }

            // Summary
            const duration = Date.now() - this.state.stats.startTime;
            logger.info(`âœ¨ Farm ultra rÃ¡pido completo!`);
            logger.info(`ðŸ“Š Stats: ${this.state.stats.totalMonsters} mobs, ${this.state.stats.totalAttacks} ataques em ${(duration/1000).toFixed(1)}s`);

            // ðŸ†• Adicionar duraÃ§Ã£o aos stats
            this.state.stats.duration = duration;

            // Emit completion event (always, for stats display)
            const autoLootCfg = context.config.get().ultraFastLoot;
            const triggerLoot = autoLootCfg?.enabled && autoLootCfg?.autoLootAfterFarm;
            
            context.events.emit('autods:ultraFastAttack:complete', { 
                stats: this.state.stats,
                triggerLoot: triggerLoot,
                endTime: Date.now()
            });

            // ðŸ†• Mostrar modal com resultados
            this.showFarmResultsModal(context, this.state.stats);

            // ðŸ†• Auto-loot OU aguardar usuÃ¡rio fechar modal
            if (triggerLoot) {
                logger.info('ðŸŽ Auto-loot serÃ¡ acionado apÃ³s fechar o modal...');
                // Loot module vai cuidar do reload
            } else {
                logger.info('âœ… Ultra Fast Farm concluÃ­do! Veja os resultados no modal.');
            }
        },

        /**
         * Check available battle slots by counting monsters with "Continue" button
         * @param {object} context - Script context
         * @param {number} maxConcurrentBattles - Max concurrent battles allowed
         * @returns {object} {continueCount, availableSlots, continueButtons}
         */
        checkAvailableSlots(context, maxConcurrentBattles) {
            const { logger, dom } = context;

            // Count monsters with "Continue" button (already joined)
            const continueButtons = dom.queryAll('.monster-card').filter(card => {
                const btn = card.querySelector('.btn-primary, .btn-success, .btn-warning');
                if (!btn) return false;
                const text = btn.textContent.trim().toLowerCase();
                return text.includes('continue') || text.includes('continuar');
            });

            const activeJoins = continueButtons.length;
            const availableSlots = Math.max(0, maxConcurrentBattles - activeJoins);

            logger.debug(`ðŸ” VerificaÃ§Ã£o de slots: ${activeJoins} batalhas ativas, ${availableSlots} slots disponÃ­veis`);

            return {
                continueCount: activeJoins,
                availableSlots: availableSlots,
                continueButtons: continueButtons
            };
        },

        async checkAndAttackJoinedMonsters(context) {
            const cfg = context.config.get().ultraFastAttack;
            const { logger, dom } = context;

            logger.info('ðŸ” Verificando dano nos monstros jÃ¡ joined...');

            // Encontrar todos os cards com "Continue" button
            const joinedCards = dom.queryAll('.monster-card').filter(card => {
                const btn = card.querySelector('.btn-primary, .btn-success, .btn-warning');
                if (!btn) return false;
                const text = btn.textContent.trim().toLowerCase();
                return text.includes('continue') || text.includes('continuar');
            });

            if (joinedCards.length === 0) {
                logger.info('âŒ Nenhum monstro com "Continue" encontrado');
                return;
            }

            logger.info(`ðŸ“Š ${joinedCards.length} monstros jÃ¡ joined encontrados`);

            // Extrair dados dos monstros joined
            const targets = [];
            for (const card of joinedCards) {
                const monsterId = card.getAttribute('data-monster-id');
                if (!monsterId) continue;

                const nameNode = card.querySelector('h3, .monster-name');
                const monsterName = nameNode ? nameNode.textContent.trim() : 'Unknown';

                targets.push({
                    monsterId: monsterId,
                    name: monsterName,
                    currentHp: null  // Will be fetched if needed
                });
            }

            if (targets.length === 0) {
                logger.info('âŒ Nenhum target vÃ¡lido extraÃ­do');
                return;
            }

            logger.info(`âš”ï¸ Atacando ${targets.length} monstros jÃ¡ joined com skill ${cfg.skillId}...`);

            // Agrupar em lotes e atacar
            for (let i = 0; i < targets.length; i += cfg.maxParallelBattles) {
                const batch = targets.slice(i, i + cfg.maxParallelBattles);

                await Promise.all(batch.map(async target => {
                    try {
                        const result = await this.performAttack(context, target.monsterId, cfg.skillId);
                        if (result.success) {
                            this.state.stats.totalAttacks++;
                            logger.debug(`âœ… Ataque em ${target.name}: sucesso`);
                        } else {
                            logger.debug(`âŒ Ataque em ${target.name}: ${result.message}`);
                        }
                    } catch (error) {
                        logger.error(`âŒ Erro ao atacar ${target.name}:`, error);
                    }
                }));

                // Delay entre lotes
                if (i + cfg.maxParallelBattles < targets.length) {
                    await sleep(cfg.delayBetweenBatches);
                }
            }

            logger.info(`âœ… VerificaÃ§Ã£o e ataque concluÃ­do! ${this.state.stats.totalAttacks} ataques executados`);
        },

        async scanTargets(context) {
            const cfg = context.config.get().ultraFastAttack;
            const { logger } = context;

            // Parse monsterNames from CSV format (string) to array
            let monsterNamesList = [];
            if (cfg.monsterNames) {
                if (Array.isArray(cfg.monsterNames)) {
                    // Already an array
                    monsterNamesList = cfg.monsterNames.filter(Boolean);
                } else if (typeof cfg.monsterNames === 'string') {
                    // Parse CSV string: split by newlines or commas
                    monsterNamesList = cfg.monsterNames
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                }
            }

            // Use Monster Scanner Service
            const monsters = context.monsterScanner.scanWaveMonsters({
                monsterNames: monsterNamesList,
                minHp: cfg.minMobHp,
                onlyNotJoined: true // Only "Join" buttons, not "Continue"
            });

            logger.debug(`[UltraFastAttack] Encontrados ${monsters.length} monster cards apÃ³s filtros`);

            // Convert to Ultra Fast Farm format
            const targets = monsters.map(monster => ({
                monsterId: monster.monsterId,
                name: monster.name,
                currentHp: monster.hp,
                card: monster.card
            }));

            // Log filter results
            if (monsterNamesList && monsterNamesList.length > 0) {
                logger.debug(`[UltraFastAttack] Filtros ativos: ${monsterNamesList.join(', ')}`);
                logger.debug(`[UltraFastAttack] ${targets.length} mobs apÃ³s filtro de nome`);
            }

            // Sort by priority
            if (cfg.priorityMode === 'lowest_hp') {
                targets.sort((a, b) => a.currentHp - b.currentHp);
            } else if (cfg.priorityMode === 'highest_hp') {
                targets.sort((a, b) => b.currentHp - a.currentHp);
            } else if (cfg.priorityMode === 'random') {
                targets.sort(() => Math.random() - 0.5);
            }

            return targets;
        },

        async joinBattlesParallel(context, targets) {
            const { logger } = context;
            const userId = context.config.get().core?.userId;

            if (!userId) {
                logger.error('âŒ User ID nÃ£o configurado! Configure core.userId primeiro.');
                return [];
            }

            if (targets.length === 0) {
                return [];
            }

            // ðŸ”¥ PRE-FLIGHT ATTACK: Preparar TODAS as requisiÃ§Ãµes de join antes de enviar
            logger.info(`ðŸš€ PRE-FLIGHT JOIN: Preparando ${targets.length} requisiÃ§Ãµes simultÃ¢neas...`);
            
            // Validar targets - remover qualquer um sem monsterId
            const validTargets = targets.filter(target => {
                if (!target.monsterId) {
                    logger.warn(`âš ï¸ Skipping target ${target.name || 'unknown'} - monsterId missing!`);
                    return false;
                }
                return true;
            });
            
            if (validTargets.length === 0) {
                logger.error('âŒ Nenhum target vÃ¡lido para join!');
                return [];
            }
            
            logger.info(`âœ… ${validTargets.length}/${targets.length} targets vÃ¡lidos`);
            
            // BLOQUEIO DE NAVEGAÃ‡ÃƒO: Usar listener para prevenir navegaÃ§Ã£o acidental durante joins
            // NÃ£o conseguimos reatribuir location methods em navegadores modernos, entÃ£o usamos um listener
            const navigationBlocker = {
                blocked: true,
                originalClickHandler: null
            };
            
            // Interceptar cliques (nÃ£o deixa navegar)
            const blockClickHandler = (e) => {
                if (navigationBlocker.blocked) {
                    // Se Ã© um link externo ou botÃ£o, bloquear
                    if (e.target?.tagName === 'A' || e.target?.getAttribute?.('onclick')) {
                        logger.warn(`ðŸ”’ Clique em link bloqueado durante join: ${e.target?.href || e.target?.textContent}`);
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            };
            
            // Interceptar navigation via popstate (botÃ£o back)
            const blockPopState = (e) => {
                if (navigationBlocker.blocked) {
                    logger.warn(`ðŸ”’ NavegaÃ§Ã£o do histÃ³rico bloqueada`);
                    e.preventDefault();
                }
            };
            
            // Adicionar listeners
            document.addEventListener('click', blockClickHandler, true);
            window.addEventListener('popstate', blockPopState);
            
            const cleanupNavigation = () => {
                navigationBlocker.blocked = false;
                document.removeEventListener('click', blockClickHandler, true);
                window.removeEventListener('popstate', blockPopState);
                logger.debug('ðŸ”“ Bloqueio de navegaÃ§Ã£o removido');
            };
            
            // Criar array de funÃ§Ãµes que executam o join (nÃ£o executar ainda)
            const joinPromises = validTargets.map(target => ({
                target,
                execute: () => context.http.joinBattle(target.monsterId, userId)
            }));

            logger.info(`âš¡ Disparando ${joinPromises.length} joins SIMULTANEAMENTE...`);
            
            // Executar TODAS as requisiÃ§Ãµes ao mesmo tempo (Pre-Flight)
            const startTime = Date.now();
            const results = await Promise.all(
                joinPromises.map(async ({ target, execute }) => {
                    try {
                        const result = await execute();
                        
                        if (result.success) {
                            this.state.stats.successfulJoins++;
                            this.state.stats.totalMonsters++;
                            logger.debug(`  âœ… ${target.name}: Join bem-sucedido`);
                        } else {
                            this.state.stats.failedJoins++;
                            logger.debug(`  âš ï¸ ${target.name}: Falha - ${result.message}`);
                        }

                        return {
                            ...target,
                            success: result.success,
                            message: result.message
                        };
                    } catch (error) {
                        this.state.stats.failedJoins++;
                        logger.error(`  âŒ Erro ao entrar em ${target.name}:`, error);
                        return {
                            ...target,
                            success: false,
                            message: error.message
                        };
                    }
                })
            );
            const duration = Date.now() - startTime;
            
            // DESBLOQUEAR NAVEGAÃ‡ÃƒO
            cleanupNavigation();

            // Contar sucessos/falhas
            const successCount = results.filter(r => r.success).length;
            const failCount = results.filter(r => !r.success).length;

            logger.info(`ðŸ“Š Pre-Flight Join: ${successCount} sucessos, ${failCount} falhas (${duration}ms total)`);

            return results;
        },

        async attackBattlesParallel(context, targets, skillId) {
            const { logger } = context;

            logger.debug(`[UltraFastAttack] Atacando ${targets.length} batalhas com skill ${skillId}...`);

            // Create all attack promises
            const attackPromises = targets.map(async (target) => {
                try {
                    const result = await this.performAttack(context, target.monsterId, skillId);
                    
                    if (result.success) {
                        this.state.stats.totalAttacks++;
                        logger.debug(`âš”ï¸ Ataque em: ${target.name}`);
                    } else {
                        logger.debug(`âŒ Falha no ataque: ${target.name}`);
                    }

                    return {
                        ...target,
                        attackSuccess: result.success
                    };
                } catch (error) {
                    logger.error(`âŒ Erro ao atacar ${target.name}:`, error);
                    return {
                        ...target,
                        attackSuccess: false
                    };
                }
            });

            // Execute all in parallel
            const results = await Promise.all(attackPromises);
            return results;
        },

        async performAttack(context, monsterId, skillId) {
            // Use centralized combat service (Cloudflare-proof)
            return context.combat.attackWaveMonsterDirect(monsterId, skillId);
        },

        /**
         * Show farm results modal using floatingHelpers module
         * @param {object} context - Script context
         * @param {object} stats - Farm statistics
         */
        showFarmResultsModal(context, stats) {
            const { logger } = context;
            
            try {
                // Get floating helpers module
                const floatingHelpers = context.moduleRegistry?.getModule('floatingHelpers');
                
                if (!floatingHelpers || typeof floatingHelpers.openQuickLootModal !== 'function') {
                    logger.warn('[UltraFastAttack] Floating helpers module not available for modal display');
                    return;
                }

                // Convert stats to summary format (compatible with loot modal)
                const summary = {
                    drops: stats.totalMonsters || 0,
                    exp: 0, // Farm doesn't track EXP directly
                    gold: 0, // Farm doesn't track gold directly
                    items: new Map(), // No items from farm
                    monsters: new Map(),
                    messages: []
                };

                // Add farm-specific info to messages
                const durationSec = (stats.duration / 1000).toFixed(1);
                summary.messages.push(`âš¡ Ultra Fast Farm: ${stats.totalMonsters} mobs atacados em ${durationSec}s`);
                summary.messages.push(`âš”ï¸ ${stats.totalAttacks} ataques realizados em ${stats.totalBatches} lotes paralelos`);
                summary.messages.push(`âœ… ${stats.successfulJoins} entradas bem-sucedidas`);
                
                if (stats.failedJoins > 0) {
                    summary.messages.push(`âš ï¸ ${stats.failedJoins} entradas falharam`);
                }

                // Call modal with "Ultra Fast Farm" scope
                floatingHelpers.openQuickLootModal(context, summary, 'Ultra Fast Farm');
                
                logger.debug('[UltraFastAttack] Modal exibido com sucesso');
            } catch (error) {
                logger.error('[UltraFastAttack] Erro ao exibir modal:', error);
            }
        },

        cleanup() {
            if (this.state) {
                this.state.running = false;
            }
        }
    };

    // ============================================================================
    // ULTRA FAST LOOT MODULE - Parallel loot collection
    // ============================================================================
    const ultraFastLootModule = {
        id: 'ultraFastLoot',
        match: ({ location }) => {
            const path = location.pathname;
            return /active_wave\.php/i.test(path) || 
                   /wave\.php/i.test(path) ||
                   /guild_dungeon_location\.php/i.test(path);
        },
        
        init(context) {
            this.state = {
                running: false,
                stats: {
                    attempted: 0,
                    successful: 0,
                    failed: 0,
                    totalExp: 0,
                    totalGold: 0,
                    items: []
                }
            };
            // context.logger.debug('[UltraFastLoot] Module initialized');
        },

        activate(context) {
            const cfg = context.config.get();
            
            // Check if triggered by ultraFastAttack completion
            const autoTrigger = cfg.ultraFastLoot?.autoLootAfterFarm;
            
            // Manual trigger via UI or auto-trigger after farm
            if (!cfg.core.enabled || !cfg.ultraFastLoot?.enabled) {
                return;
            }

            // Listen for farm completion event
            if (autoTrigger) {
                context.events.on('autods:ultraFastAttack:complete', (data) => {
                    if (data.triggerLoot && !this.state.running) {
                        context.logger.info('[UltraFastLoot] Auto-triggered apÃ³s farm');
                        this.runLoot(context);
                    }
                });
            }
        },

        async runLoot(context) {
            if (this.state.running) {
                context.logger.warn('[UltraFastLoot] JÃ¡ estÃ¡ rodando');
                return;
            }

            const cfg = context.config.get().ultraFastLoot;
            const { logger, loot, numbers } = context;

            this.state.running = true;
            this.state.stats = {
                attempted: 0,
                successful: 0,
                failed: 0,
                totalExp: 0,
                totalGold: 0,
                items: []
            };

            try {
                logger.info('ðŸŽ Ultra Fast Loot iniciado!');

                // Mostrar filtros ativos
                const filtersConfig = cfg.filters || cfg.monsterFilter || {};
                let includeNames = [];
                let excludeNames = [];
                
                // Parse includeNames from both array and CSV string formats
                // Support both new format (includeNames) and legacy format (monsterNames)
                if (Array.isArray(filtersConfig.includeNames)) {
                    includeNames = filtersConfig.includeNames.filter(Boolean);
                } else if (Array.isArray(filtersConfig.monsterNames)) {
                    // Fallback: CSV data might come as array from UI
                    includeNames = filtersConfig.monsterNames.filter(Boolean);
                } else if (typeof filtersConfig.includeNames === 'string') {
                    const csv = String(filtersConfig.includeNames).trim();
                    if (csv) {
                        includeNames = csv.split(/[\n,]+/).map(s => s.trim()).filter(s => s.length > 0);
                    }
                } else if (typeof filtersConfig.monsterNames === 'string') {
                    const csv = String(filtersConfig.monsterNames).trim();
                    if (csv) {
                        includeNames = csv.split(/[\n,]+/).map(s => s.trim()).filter(s => s.length > 0);
                    }
                }
                
                // Parse excludeNames from both array and CSV string formats
                if (Array.isArray(filtersConfig.excludeNames)) {
                    excludeNames = filtersConfig.excludeNames.filter(Boolean);
                } else if (typeof filtersConfig.excludeNames === 'string') {
                    const csv = String(filtersConfig.excludeNames).trim();
                    if (csv) {
                        excludeNames = csv.split(/[\n,]+/).map(s => s.trim()).filter(s => s.length > 0);
                    }
                }
                
                const activeFilters = [];
                if (includeNames.length > 0) {
                    activeFilters.push(`Incluir: ${includeNames.join(', ')}`);
                }
                if (excludeNames.length > 0) {
                    activeFilters.push(`Excluir: ${excludeNames.join(', ')}`);
                }
                if (activeFilters.length > 0) {
                    logger.info(`ðŸ” Filtros ativos: ${activeFilters.join(' | ')}`);
                }

                // Reset level up check with initial XP
                loot.resetLevelUpCheck();
                
                const initialExpInfo = loot.checkLevelUp();
                if (initialExpInfo.oldExp) {
                    const expToLevelUp = initialExpInfo.oldExp.maxExp - initialExpInfo.oldExp.currentExp;
                    logger.info(`ðŸ“Š XP atual: ${numbers.format(initialExpInfo.oldExp.currentExp)} / ${numbers.format(initialExpInfo.oldExp.maxExp)} (${initialExpInfo.oldExp.percent.toFixed(1)}%)`);
                    logger.info(`ðŸ“Š Falta ${numbers.format(expToLevelUp)} XP para subir de nÃ­vel`);
                }

                // Scan eligible monsters
                const targets = await this.scanLootTargets(context);
                
                if (targets.length === 0) {
                    logger.info('âŒ Nenhum mob elegÃ­vel para loot');
                    this.state.running = false;
                    return;
                }

                logger.info(`ðŸŽ¯ ${targets.length} mobs para lootar`);
                if (includeNames.length > 0) {
                    logger.debug(`â„¹ï¸  Contagem APÃ“S filtro 'Incluir Nomes': ${targets.length} mobs elegÃ­veis`);
                    logger.debug(`ðŸ“‹ Filtros incluir: ${includeNames.join(', ')}`);
                }
                if (excludeNames.length > 0) {
                    logger.debug(`ðŸ“‹ Filtros excluir: ${excludeNames.join(', ')}`);
                }

                // Get user ID
                const userId = context.userSession.getUserId();
                if (!userId) {
                    logger.error('âŒ User ID nÃ£o encontrado');
                    this.state.running = false;
                    return;
                }

                // ðŸ†• ROBUSTO: Implementar loot manual com verificaÃ§Ã£o de level up apÃ³s cada batch
                // Assim conseguimos parar imediatamente quando atingir o threshold
                this.state.stats.attempted = 0;
                this.state.stats.successful = 0;
                this.state.stats.failed = 0;
                this.state.stats.totalExp = 0;
                this.state.stats.totalGold = 0;
                
                const summary = {
                    drops: 0,
                    exp: 0,
                    gold: 0,
                    items: new Map(),
                    monsters: new Map(),
                    messages: []
                };
                
                // Loot em lotes com verificaÃ§Ã£o de level up robusta
                const batchSize = cfg.maxParallelLoots || 5;
                let levelUpDetected = false;
                let looted = 0;
                
                for (let i = 0; i < targets.length; i += batchSize) {
                    if (levelUpDetected) {
                        logger.warn(`â¹ï¸  Level up detectado! Parando o loot automÃ¡tico`);
                        break;
                    }
                    
                    const batch = targets.slice(i, i + batchSize);
                    logger.debug(`ðŸ“¦ Processando batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(targets.length / batchSize)} (${batch.length} mobs)...`);
                    
                    // Fazer loot do batch
                    await this.lootBatchParallel(context, batch, summary);
                    looted += batch.length;
                    
                    // âœ… Verificar level up APÃ“S cada batch
                    const levelUpInfo = loot.checkLevelUp();
                    if (levelUpInfo.leveledUp) {
                        logger.warn(`ðŸŽ‰ LEVEL UP DETECTADO! NÃ­vel anterior: ${levelUpInfo.oldExp?.level || '?'} â†’ Novo nÃ­vel: ${levelUpInfo.newExp?.level || '?'}`);
                        logger.warn(`ðŸ“Š XP novo: ${numbers.format(levelUpInfo.newExp?.currentExp || 0)} / ${numbers.format(levelUpInfo.newExp?.maxExp || 0)}`);
                        levelUpDetected = true;
                        break; // Parar imediatamente
                    }
                    
                    // Mostrar progresso
                    logger.debug(`âœ… Batch completo - Total looted: ${looted}/${targets.length}`);
                    
                    // Pequena pausa entre batches (evitar rate limit)
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                // Update module stats (jÃ¡ foi atualizado durante lootBatchParallel)
                this.state.stats.totalExp = summary.exp;
                this.state.stats.totalGold = summary.gold;

                // Summary
                const skippedCount = targets.length - looted;
                logger.info(`âœ¨ Loot concluÃ­do!`);
                logger.info(`ðŸ“Š ${this.state.stats.successful}/${this.state.stats.attempted} loots bem-sucedidos`);
                if (skippedCount > 0) {
                    logger.info(`â­ï¸  ${skippedCount} mobs nÃ£o looteados (parado no level up)`);
                }
                logger.info(`ðŸ’° ${numbers.format(summary.gold)} Gold, ${numbers.format(summary.exp)} EXP`);
                if (summary.items.size > 0) {
                    logger.info(`ðŸŽ ${summary.items.size} tipos de itens obtidos`);
                }

                // Show detailed modal using unified service
                const isGuildDungeon = /guild_dungeon_location\.php/i.test(context.location.pathname);
                const scopeLabel = isGuildDungeon ? 'Guild Dungeon Loot' : 'Wave Loot';
                loot.showDetailedModal(summary, scopeLabel);

                // Emit completion event for stats display
                context.events.emit('autods:ultraFastLoot:complete', {
                    stats: {
                        ...this.state.stats,
                        summary: summary
                    }
                });

                logger.info('âœ… Ultra Fast Loot concluÃ­do! Veja os resultados no modal e painel lateral.');

            } catch (error) {
                logger.error('[UltraFastLoot] Erro:', error);
            } finally {
                this.state.running = false;
            }
        },

        async scanLootTargets(context) {
            const cfg = context.config.get().ultraFastLoot;
            const isGuildDungeon = /guild_dungeon_location\.php/i.test(context.location.pathname);
            const filters = cfg.filters || cfg.monsterFilter || {};
            
            // Boss detection threshold: 1 billion (1B) HP - bosses won't be auto-looted
            const BOSS_HP_THRESHOLD = 1_000_000_000;
            
            // Parse includeNames - support both array and CSV string format
            let includeNames = [];
            if (Array.isArray(filters.includeNames)) {
                includeNames = filters.includeNames.filter(Boolean);
            } else if (Array.isArray(filters.monsterNames)) {
                // Fallback: CSV data might come as array from UI
                includeNames = filters.monsterNames.filter(Boolean);
            } else if (typeof filters.includeNames === 'string') {
                // Fallback: parse CSV string from old format
                const csv = String(filters.includeNames).trim();
                if (csv) {
                    includeNames = csv
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                }
            } else if (typeof filters.monsterNames === 'string') {
                // Legacy fallback
                const csv = String(filters.monsterNames).trim();
                if (csv) {
                    includeNames = csv
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                }
            }
            
            // Parse excludeNames - support both array and CSV string format
            let excludeNames = [];
            if (Array.isArray(filters.excludeNames)) {
                excludeNames = filters.excludeNames.filter(Boolean);
            } else if (typeof filters.excludeNames === 'string') {
                // Parse CSV string
                const csv = String(filters.excludeNames).trim();
                if (csv) {
                    excludeNames = csv
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                }
            }

            let targets = [];

            if (isGuildDungeon) {
                // Guild dungeon: scan directly from monster cards (not dependent on injected buttons)
                const monsterCards = Array.from(document.querySelectorAll('.mon.dead'));
                
                context.logger.debug(`[UltraFastLoot] Found ${monsterCards.length} dead monsters in guild dungeon`);
                
                for (const card of monsterCards) {
                    // Check if has "not looted" pill
                    const notLootedPill = Array.from(card.querySelectorAll('.pill')).find(pill =>
                        /not looted/i.test(pill.textContent)
                    );

                    if (!notLootedPill) continue; // Skip if already looted

                    // Find the View button (support both dungeon_battle.php and battle.php with dgmid)
                    const viewButton = card.querySelector('a.btn[href*="battle.php"][href*="dgmid"], a.btn[href*="dungeon_battle.php"]');
                    if (!viewButton) continue;

                    // Extract dgmid and instance_id from View button href
                    const href = viewButton.getAttribute('href');
                    const dgmidMatch = href.match(/dgmid=(\d+)/);
                    const instanceMatch = href.match(/instance_id=(\d+)/);

                    if (!dgmidMatch || !instanceMatch) continue;

                    // Extract monster name and HP
                    const nameElement = card.querySelector('h3, .monster-name, [class*="name"]');
                    const monsterName = nameElement ? nameElement.textContent.trim() : '';
                    
                    // Extract HP from .stat-row with .stat-icon.hp -> .stat-value (format: "current / max")
                    const hpRow = Array.from(card.querySelectorAll('.stat-row')).find(row => row.querySelector('.stat-icon.hp'));
                    const hpValueNode = hpRow?.querySelector('.stat-value');
                    const hpText = hpValueNode?.textContent ?? '';
                    // Extract max HP (after the /) - format is "0 / 100,000,000"
                    const hpMatch = hpText.match(/(\d{1,3}(?:,\d{3})*|\d+)\s*\/\s*(\d{1,3}(?:,\d{3})*|\d+)/);
                    const hp = hpMatch ? numberFromText(hpMatch[2]) : 0; // hpMatch[2] is max HP
                    
                    // ðŸ‘‘ Skip bosses (100B+ HP) - they must be looted manually
                    if (hp && hp >= BOSS_HP_THRESHOLD) {
                        context.logger.debug(`â†©ï¸  Pulando boss ${monsterName} (HP: ${formatNumber(hp)}) - deve ser looteado manualmente`);
                        continue;
                    }

                    // Apply name filters - include check
                    if (includeNames.length > 0) {
                        if (!includeNames.some(name => monsterName.toLowerCase().includes(name.toLowerCase()))) {
                            continue; // Skip if not in whitelist
                        }
                    }
                    // Apply name filters - exclude check
                    if (excludeNames.length > 0) {
                        if (excludeNames.some(name => monsterName.toLowerCase().includes(name.toLowerCase()))) {
                            continue; // Skip if in blacklist
                        }
                    }

                    targets.push({
                        type: 'dungeon',
                        dgmid: dgmidMatch[1],
                        instanceId: instanceMatch[1],
                        name: monsterName
                    });
                }
                
                context.logger.debug(`[UltraFastLoot] Extracted ${targets.length} lootable guild monsters (after filters)`);
            } else {
                // Regular wave: only dead monsters
                let cards = [];
                
                if (cfg.onlyEligible) {
                    cards = Array.from(document.querySelectorAll('.monster-card[data-eligible="1"][data-dead="1"]'));
                } else {
                    cards = Array.from(document.querySelectorAll('.monster-card[data-dead="1"]'));
                }
                
                for (const card of cards) {
                    const monsterId = card.getAttribute('data-monster-id');
                    if (!monsterId) continue;

                    // Extract monster name and HP
                    const nameElement = card.querySelector('h3, .monster-name');
                    const monsterName = nameElement ? nameElement.textContent.trim() : '';
                    
                    // Extract HP from .stat-row with .stat-icon.hp -> .stat-value (format: "current / max")
                    const hpRow = Array.from(card.querySelectorAll('.stat-row')).find(row => row.querySelector('.stat-icon.hp'));
                    const hpValueNode = hpRow?.querySelector('.stat-value');
                    const hpText = hpValueNode?.textContent ?? '';
                    // Extract max HP (after the /) - format is "0 / 100,000,000"
                    const hpMatch = hpText.match(/(\d{1,3}(?:,\d{3})*|\d+)\s*\/\s*(\d{1,3}(?:,\d{3})*|\d+)/);
                    const hp = hpMatch ? numberFromText(hpMatch[2]) : 0; // hpMatch[2] is max HP
                    
                    // ðŸ‘‘ Skip bosses (100B+ HP) - they must be looted manually
                    if (hp && hp >= BOSS_HP_THRESHOLD) {
                        context.logger.debug(`â†©ï¸  Pulando boss ${monsterName} (HP: ${formatNumber(hp)}) - deve ser looteado manualmente`);
                        continue;
                    }

                    // Apply name filters - include check
                    if (includeNames.length > 0) {
                        if (!includeNames.some(name => monsterName.toLowerCase().includes(name.toLowerCase()))) {
                            continue; // Skip if not in whitelist
                        }
                    }
                    // Apply name filters - exclude check
                    if (excludeNames.length > 0) {
                        if (excludeNames.some(name => monsterName.toLowerCase().includes(name.toLowerCase()))) {
                            continue; // Skip if in blacklist
                        }
                    }

                    targets.push({
                        type: 'wave',
                        monsterId: monsterId,
                        name: monsterName
                    });
                }
                
                context.logger.debug(`[UltraFastLoot] Extracted ${targets.length} lootable wave monsters (after filters)`);
            }

            return targets;
        },

        async lootBatchParallel(context, batch, summary) {
            const { logger } = context;

            const lootPromises = batch.map(async (target) => {
                this.state.stats.attempted++;
                
                try {
                    const result = await this.performLoot(context, target);
                    
                    if (result.success) {
                        this.state.stats.successful++;
                        
                        // ðŸ†• Acumular em summary (compatÃ­vel com loot tradicional)
                        const exp = result.exp || 0;
                        const gold = result.gold || 0;
                        
                        summary.exp += exp;
                        summary.gold += gold;
                        summary.drops++;
                        
                        // ðŸ†• Processar itens
                        if (result.items && result.items.length > 0) {
                            result.items.forEach(item => {
                                // ðŸ†• Debug: Log estrutura do item
                                console.log('[UltraFastLoot] Processing item:', item);
                                
                                // API retorna campos em MAIÃšSCULAS: ITEM_ID, NAME, RARITY, QUANTITY
                                const itemName = item.NAME || item.name || 'Unknown Item';
                                const itemRarity = (item.RARITY || item.rarity || 'COMMON').toLowerCase();
                                const itemQty = item.QUANTITY || item.quantity || 1;
                                
                                console.log('[UltraFastLoot] Parsed item:', { itemName, itemRarity, itemQty });
                                
                                const itemKey = `${itemName}|${itemRarity}`;
                                const existing = summary.items.get(itemKey);
                                
                                if (existing) {
                                    existing.quantity += itemQty;
                                } else {
                                    summary.items.set(itemKey, {
                                        displayName: itemName,
                                        rarity: itemRarity,
                                        quantity: itemQty
                                    });
                                }
                            });
                        }
                        
                        // ðŸ†• Armazenar info do monstro
                        if (result.monsterName) {
                            const monsterKey = result.monsterName.toLowerCase();
                            const existing = summary.monsters.get(monsterKey);
                            
                            if (existing) {
                                existing.exp += exp;
                                existing.gold += gold;
                                existing.count++;
                            } else {
                                summary.monsters.set(monsterKey, {
                                    name: result.monsterName,
                                    exp: exp,
                                    gold: gold,
                                    count: 1
                                });
                            }
                        }
                        
                        logger.debug(`âœ… Loot: ${target.type} ${target.monsterId || target.dgmid} - ${exp} XP, ${gold} Gold`);
                    } else {
                        this.state.stats.failed++;
                        logger.debug(`âŒ Falha loot: ${result.message}`);
                    }

                    return result;
                } catch (error) {
                    this.state.stats.failed++;
                    logger.error('âŒ Erro no loot:', error);
                    return { success: false, message: error.message };
                }
            });

            const results = await Promise.all(lootPromises);
            return results;
        },

        async performLoot(context, target) {
            const isGuild = target.type === 'guild';
            const url = isGuild ? 
                'https://demonicscans.org/dungeon_loot.php' : 
                'https://demonicscans.org/loot.php';
            
            const body = isGuild ?
                `dgmid=${target.dgmid}&instance_id=${target.instanceId}` :
                `monster_id=${target.monsterId}`;

            // Use centralized loot service (Cloudflare-proof)
            const userId = context.userSession.getUserId();
            if (!userId) {
                return { success: false, message: 'User ID not found' };
            }
            
            if (isGuild) {
                return context.loot.lootDungeonMonsterDirect(target.dgmid, target.instanceId, userId, target.name || 'Unknown');
            } else {
                return context.loot.lootWaveMonsterDirect(target.monsterId, userId, target.name || 'Unknown');
            }
        },

        createLootSummary() {
            return {
                drops: 0,
                exp: 0,
                gold: 0,
                items: new Map(),
                monsters: new Map(),
                messages: []
            };
        },

        getPlayerExpInfo(context) {
            // Selectors para encontrar o XP do jogador
            const expSelectors = [
                '[data-player-exp]',
                '.player-exp',
                '#player_exp',
                '.exp-bar .exp-text',
                '[class*="exp"]'
            ];

            for (const selector of expSelectors) {
                const expElement = document.querySelector(selector);
                if (!expElement) continue;

                const expText = expElement.textContent.trim();
                const match = expText.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                
                if (match) {
                    const currentExp = numberFromText(match[1]);
                    const maxExp = numberFromText(match[2]);
                    
                    if (currentExp !== null && maxExp !== null && maxExp > 0) {
                        const percent = (currentExp / maxExp) * 100;
                        return {
                            currentExp,
                            maxExp,
                            percent
                        };
                    }
                }
            }

            return null;
        },

        showLootResultsModal(context, summary) {
            context.logger.info('ðŸ” [showLootResultsModal] Iniciando...');
            
            // Usar a funÃ§Ã£o do floatingHelpersModule se disponÃ­vel
            const floatingHelpers = context.moduleRegistry?.getModule('floatingHelpers');
            
            context.logger.info(`ðŸ” [showLootResultsModal] floatingHelpers encontrado: ${!!floatingHelpers}`);
            
            if (floatingHelpers && typeof floatingHelpers.openQuickLootModal === 'function') {
                const isGuildDungeon = /guild_dungeon_location\.php/i.test(context.location.pathname);
                const scopeLabel = isGuildDungeon ? 'Guild' : 'Wave';
                
                context.logger.info(`ðŸ” [showLootResultsModal] Chamando openQuickLootModal (scope: ${scopeLabel})`);
                
                try {
                    floatingHelpers.openQuickLootModal(context, summary, scopeLabel);
                    context.logger.info('âœ… [showLootResultsModal] Modal aberto com sucesso!');
                } catch (error) {
                    context.logger.error('âŒ [showLootResultsModal] Erro ao abrir modal:', error);
                }
            } else {
                // Fallback: mostrar log simples
                context.logger.warn('[UltraFastLoot] Modal nÃ£o disponÃ­vel, resultados no console');
                context.logger.info(`ðŸ“Š Total: ${formatNumber(summary.exp)} EXP, ${formatNumber(summary.gold)} Gold`);
                
                if (summary.items.size > 0) {
                    context.logger.info(`ðŸŽ Itens (${summary.items.size} tipos):`);
                    summary.items.forEach((item, key) => {
                        context.logger.info(`  - ${item.quantity}x ${item.name} (${item.rarity})`);
                    });
                }
            }
        },

        cleanup() {
            this.state.running = false;
        }
    };

    // ============================================================================
    // ULTRA FAST STAMINA FARM MODULE - Parallel chapter reactions
    // ============================================================================
    const ultraFastStaminaModule = {
        id: 'ultraFastStamina',
        match: ({ location }) => {
            // Match manga/title pages where we can get chapter lists
            const path = location.pathname;
            return /\/manga\/|\/title\//i.test(path) && !/\/chapter\//i.test(path);
        },
        
        init(context) {
            this.state = {
                running: false,
                isLoggingIn: false,  // Lock para evitar mÃºltiplos logins paralelos
                loginPromise: null,  // Promise que aguarda o login completar
                stats: {
                    attempted: 0,
                    successful: 0,
                    failed: 0,
                    alreadyReacted: 0,
                    totalReactions: 0,
                    startTime: null,
                    duration: 0
                }
            };
            // context.logger.debug('[UltraFastStamina] Module initialized');
        },

        activate(context) {
            const cfg = context.config.get();
            if (!cfg.core.enabled || !cfg.ultraFastStamina?.enabled) {
                if (this.state) this.state.running = false;
                return;
            }
            
            if (!this.state) this.init(context);
            
            // Don't auto-run, wait for manual trigger via UI
            context.logger.debug('[UltraFastStamina] Module activated, waiting for manual trigger');
        },

        async runStaminaFarm(context) {
            const { logger } = context;
            
            if (this.state.running) {
                logger.warn('[UltraFastStamina] Already running');
                return;
            }

            this.state.running = true;
            this.state.stats = {
                attempted: 0,
                successful: 0,
                failed: 0,
                alreadyReacted: 0,
                totalReactions: 0,
                startTime: Date.now(),
                duration: 0
            };

            logger.info('âš¡ Ultra Fast Stamina iniciado!');

            try {
                // 1. Get user UID from cookie
                const userUID = this.getUserUID(context);
                logger.info(`ðŸ‘¤ UserUID: ${userUID}`);

                // 2. Scan chapters from current page
                const chapters = await this.scanChapters(context);
                
                if (chapters.length === 0) {
                    logger.warn('âŒ Nenhum capÃ­tulo encontrado na pÃ¡gina');
                    return;
                }

                logger.info(`ðŸ“š ${chapters.length} capÃ­tulos encontrados`);

                // 3. Filter out already reacted chapters
                const unreactedChapters = chapters.filter(ch => {
                    const cookieName = `reacted_chap_${ch.id}`;
                    const hasReacted = this.getCookie(cookieName);
                    if (hasReacted) {
                        this.state.stats.alreadyReacted++;
                        return false;
                    }
                    return true;
                });

                logger.info(`âœ¨ ${unreactedChapters.length} capÃ­tulos sem reaÃ§Ã£o`);
                
                if (unreactedChapters.length === 0) {
                    logger.info('âœ… Todos os capÃ­tulos jÃ¡ foram reagidos!');
                    this.showResults(context);
                    return;
                }

                // 4. Group into batches
                const cfg = context.config.get().ultraFastStamina;
                const batchSize = cfg?.batchSize || 10;
                const batches = [];
                
                for (let i = 0; i < unreactedChapters.length; i += batchSize) {
                    batches.push(unreactedChapters.slice(i, i + batchSize));
                }

                logger.info(`ðŸ“¦ ${batches.length} lotes de ${batchSize} reaÃ§Ãµes`);

                // 5. Process batches
                for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                    const batch = batches[batchIndex];
                    logger.info(`âš¡ Lote ${batchIndex + 1}/${batches.length}: ${batch.length} capÃ­tulos`);

                    await this.reactBatchParallel(context, batch, userUID);

                    // Delay between batches
                    if (batchIndex < batches.length - 1) {
                        const delay = cfg?.delayBetweenBatches || 1000;
                        logger.info(`â³ Aguardando ${delay}ms antes do prÃ³ximo lote...`);
                        await sleep(delay);
                    }
                }

                // 6. Show results
                this.state.stats.duration = Date.now() - this.state.stats.startTime;
                this.showResults(context);

            } catch (error) {
                logger.error('[UltraFastStamina] Erro fatal:', error);
            } finally {
                this.state.running = false;
            }
        },

        async scanChapters(context) {
            const { logger } = context;
            const chapters = [];

            // Look for chapter links with class "chplinks"
            // Format: <a class="chplinks" href="/chaptered.php?manga=11952&chapter=145">
            const chapterLinks = document.querySelectorAll('.chplinks');
            
            logger.debug(`[UltraFastStamina] Found ${chapterLinks.length} chapter links`);

            const seenIds = new Set();

            chapterLinks.forEach(link => {
                const href = link.getAttribute('href');
                if (!href) return;

                // Extract chapter ID from URL query parameter
                // Example: /chaptered.php?manga=11952&chapter=145
                let chapterId = null;

                // 1. Try to extract from "chapter=" query parameter
                const urlParams = new URLSearchParams(href.split('?')[1] || '');
                chapterId = urlParams.get('chapter');

                // 2. If not found, try data-chapter-id attribute
                if (!chapterId) {
                    chapterId = link.getAttribute('data-chapter-id');
                }

                // 3. Try parent element data attributes
                if (!chapterId) {
                    const parent = link.closest('[data-chapter-id]');
                    if (parent) {
                        chapterId = parent.getAttribute('data-chapter-id');
                    }
                }

                // 4. Try onclick attribute (e.g., onclick="reactToChapter(12345)")
                if (!chapterId) {
                    const onclick = link.getAttribute('onclick');
                    if (onclick) {
                        const match = onclick.match(/\d+/);
                        if (match) chapterId = match[0];
                    }
                }

                if (chapterId && !seenIds.has(chapterId)) {
                    seenIds.add(chapterId);
                    chapters.push({
                        id: chapterId,
                        url: href,
                        title: link.textContent.trim()
                    });
                }
            });

            logger.debug(`[UltraFastStamina] Extracted ${chapters.length} unique chapter IDs`);

            return chapters;
        },

        async reactBatchParallel(context, batch, userUID) {
            const { logger } = context;
            const cfg = context.config.get().ultraFastStamina;
            const reactionType = cfg?.reactionType || '1'; // Default: ðŸ‘

            const promises = batch.map(async (chapter) => {
                this.state.stats.attempted++;

                try {
                    const result = await this.sendReaction(context, chapter.id, reactionType, userUID);
                    
                    if (result.success) {
                        this.state.stats.successful++;
                        this.state.stats.totalReactions++;
                        logger.debug(`âœ… ReaÃ§Ã£o enviada: ${chapter.title} (${chapter.id})`);
                        
                        // Set cookie to mark as reacted
                        this.setCookie(`reacted_chap_${chapter.id}`, reactionType, 365);
                    } else {
                        this.state.stats.failed++;
                        logger.debug(`âŒ Falha: ${chapter.title} - ${result.message}`);
                    }

                    return result;
                } catch (error) {
                    this.state.stats.failed++;
                    logger.error(`âŒ Erro: ${chapter.title}`, error);
                    return { success: false, message: error.message };
                }
            });

            await Promise.all(promises);
        },

        isLoggedOut(responseText) {
            // Check if response contains login page indicators
            return responseText && (
                responseText.includes('Sign in to your account') ||
                responseText.includes('signin.php') ||
                responseText.includes('login-container') ||
                responseText.includes('Register</a>')
            );
        },

        async autoSignin(context) {
            const { logger } = context;
            
            // Se jÃ¡ estÃ¡ logando, aguarda o resultado
            if (this.state.isLoggingIn) {
                logger.debug('â³ Aguardando login em andamento...');
                if (this.state.loginPromise) {
                    return await this.state.loginPromise;
                }
            }

            // Seta flag de login em andamento
            this.state.isLoggingIn = true;

            // Cria Promise para que outros aguardem
            this.state.loginPromise = (async () => {
                try {
                    // Get credentials from config or storage
                    const cfg = context.config.get();
                    const credentials = cfg?.credentials;
                    
                    if (!credentials?.email || !credentials?.password) {
                        logger.warn('âŒ Credenciais nÃ£o configuradas. Configure email e senha em âš™ï¸ Interface > ðŸ” Credenciais de Login');
                        return false;
                    }

                    logger.info('ðŸ”„ Fazendo login automÃ¡tico (uma Ãºnica vez)...');
                    
                    const body = `email=${encodeURIComponent(credentials.email)}&password=${encodeURIComponent(credentials.password)}&submit=Sign+In`;
                    
                    const result = await context.http.fetchDirect('/signin.php', {
                        method: 'POST',
                        body: body,
                        referrer: 'https://demonicscans.org/',
                        parseJson: false
                    });

                    // Check if login was successful
                    // "You are already signed in" = sucesso (jÃ¡ estava logado ou login completou)
                    // "Sign in to your account" = falha
                    const responseText = result.data || '';
                    const isAlreadySignedIn = responseText.includes('You are already signed in') || 
                                             responseText.includes('you will be redirected');
                    const isLoginPage = this.isLoggedOut(result.data);

                    if (isLoginPage && !isAlreadySignedIn) {
                        logger.error('âŒ Falha no login - credenciais incorretas?');
                        return false;
                    }

                    logger.info('âœ… Login bem-sucedido!');
                    await sleep(1000); // Wait for session to stabilize
                    return true;
                } catch (error) {
                    logger.error('âŒ Erro ao fazer login:', error);
                    return false;
                } finally {
                    // Limpa flag e promise
                    this.state.isLoggingIn = false;
                    this.state.loginPromise = null;
                }
            })();

            return await this.state.loginPromise;
        },

        async sendReaction(context, chapterId, reactionType, userUID) {
            // Build form-encoded body (application/x-www-form-urlencoded)
            const body = `chapterid=${encodeURIComponent(chapterId)}&reaction=${encodeURIComponent(reactionType)}&useruid=${encodeURIComponent(userUID)}`;

            // Use http.fetchDirect (Cloudflare-proof)
            try {
                const result = await context.http.fetchDirect('/postreaction.php', {
                    method: 'POST',
                    body: body,
                    referrer: window.location.href,
                    parseJson: false // Response is plain text: 'added' or 'updated'
                });
                
                // Check if we got logged out (received login page)
                if (this.isLoggedOut(result.data)) {
                    // Se nÃ£o estÃ¡ logando, inicia o login (com lock)
                    if (!this.state.isLoggingIn) {
                        context.logger.warn('âš ï¸ SessÃ£o expirada, iniciando login Ãºnico...');
                    } else {
                        context.logger.debug('â³ SessÃ£o expirada, aguardando login em andamento...');
                    }
                    
                    const loginSuccess = await this.autoSignin(context);
                    if (!loginSuccess) {
                        return {
                            success: false,
                            message: 'SessÃ£o expirada e falha no login automÃ¡tico',
                            statusCode: 401
                        };
                    }

                    // Retry the reaction after login
                    context.logger.debug('ðŸ”„ Tentando reaÃ§Ã£o novamente apÃ³s login...');
                    return this.sendReaction(context, chapterId, reactionType, userUID);
                }
                
                // fetchDirect with parseJson:false returns { success: bool, data: text }
                // Response is 'added' or 'updated' (plain text)
                return {
                    success: result.success,
                    message: result.data || result.error,
                    statusCode: result.status || 200
                };
            } catch (error) {
                return { success: false, message: error.message || 'Network error' };
            }
        },

        getUserUID(context) {
            // Try to get from cookie
            let uid = this.getCookie('useruid');
            
            if (!uid) {
                // Generate new UID
                uid = 'uid-' + Math.random().toString(36).substr(2, 16) + Date.now();
                this.setCookie('useruid', uid, 365);
                context.logger.info(`[UltraFastStamina] Generated new UserUID: ${uid}`);
            }

            return uid;
        },

        getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        },

        setCookie(name, value, days) {
            const expires = new Date();
            expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
            document.cookie = `${name}=${value}; expires=${expires.toUTCString()}; path=/`;
        },

        showResults(context) {
            const { logger } = context;
            const stats = this.state.stats;

            logger.info('âœ¨ Ultra Fast Stamina concluÃ­do!');
            logger.info(`ðŸ“Š Stats: ${stats.successful}/${stats.attempted} reaÃ§Ãµes enviadas`);
            logger.info(`â±ï¸ DuraÃ§Ã£o: ${(stats.duration / 1000).toFixed(1)}s`);

            // Get floating helpers module
            const floatingHelpers = context.moduleRegistry?.getModule('floatingHelpers');
            
            if (!floatingHelpers || typeof floatingHelpers.openQuickLootModal !== 'function') {
                logger.warn('[UltraFastStamina] Modal not available');
                return;
            }

            // Create summary in modal-compatible format
            const summary = {
                drops: stats.totalReactions,
                exp: 0,
                gold: 0,
                items: new Map(),
                monsters: new Map(),
                messages: []
            };

            const durationSec = (stats.duration / 1000).toFixed(1);
            summary.messages.push(`âš¡ Ultra Fast Stamina: ${stats.successful} reaÃ§Ãµes enviadas em ${durationSec}s`);
            summary.messages.push(`âœ… ${stats.successful} sucessos, âŒ ${stats.failed} falhas`);
            summary.messages.push(`ðŸ”„ ${stats.alreadyReacted} capÃ­tulos jÃ¡ reagidos (pulados)`);

            // Call modal
            floatingHelpers.openQuickLootModal(context, summary, 'Ultra Fast Stamina');
        },

        cleanup() {
            if (this.state) {
                this.state.running = false;
            }
        }
    };

    const ultraFastDungeonModule = {
        id: 'ultraFastDungeon',
        match: ({ location }) => /guild_dungeon_location\.php/i.test(location.pathname),
        
        init(context) {
            this.state = {
                running: false,
                stats: {
                    totalBatches: 0,
                    totalMonsters: 0,
                    successfulJoins: 0,
                    failedJoins: 0,
                    totalAttacks: 0,
                    monstersCompleted: 0,
                    startTime: null
                }
            };
            // context.logger.debug('[UltraFastDungeon] Module initialized');
        },

        activate(context) {
            const cfg = context.config.get();
            if (!cfg.core.enabled || !cfg.ultraFastDungeon?.enabled) {
                if (this.state) this.state.running = false;
                return;
            }
            
            if (!this.state) this.init(context);
            
            // Manual mode only (via button)
            context.logger.debug('[UltraFastDungeon] Module activated, waiting for manual trigger');
        },

        triggerManualRun(context) {
            const { logger } = context;
            
            if (this.state.running) {
                logger.warn('[UltraFastDungeon] JÃ¡ estÃ¡ rodando');
                return;
            }

            this.state.running = true;
            this.state.stats.startTime = Date.now();
            
            logger.info('âš¡ Ultra Fast Dungeon iniciado manualmente!');
            
            (async () => {
                try {
                    await this.runDungeonFarm(context);
                } catch (error) {
                    logger.error('[UltraFastDungeon] Erro fatal:', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },

        async runDungeonFarm(context) {
            const cfg = context.config.get().ultraFastDungeon;
            const { logger } = context;

            logger.info(`ðŸ“Š Config: ${cfg.maxParallelBattles} paralelos, ${cfg.attacksPerMonster} ataques/mob, Smart Damage: ${cfg.useSmartDamage ? 'ON' : 'OFF'}`);

            // 1. Scan dungeon monsters
            const targets = await this.scanDungeonTargets(context);
            
            if (targets.length === 0) {
                logger.info('âŒ Nenhum mob disponÃ­vel para farm ultra rÃ¡pido');
                this.showResults(context);
                return;
            }

            // 2. Group into batches
            const batches = [];
            for (let i = 0; i < targets.length; i += cfg.maxParallelBattles) {
                batches.push(targets.slice(i, i + cfg.maxParallelBattles));
            }

            logger.info(`ðŸŽ¯ ${targets.length} mobs encontrados â†’ ${batches.length} lotes (${cfg.maxParallelBattles} mobs/lote)`);

            // 3. Process each batch
            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                this.state.stats.totalBatches++;

                logger.info(`âš¡ Lote ${batchIndex + 1}/${batches.length}: ${batch.length} mobs`);

                // Join battles if not joined yet
                const joinedTargets = await this.ensureBattlesJoined(context, batch);

                if (joinedTargets.length === 0) {
                    logger.warn('âš ï¸ Nenhuma entrada bem-sucedida neste lote');
                    continue;
                }

                // Attack all battles respecting damage thresholds
                await this.attackWithSmartDamage(context, joinedTargets);

                // Delay between batches
                if (batchIndex < batches.length - 1) {
                    logger.info(`â³ Aguardando ${cfg.delayBetweenBatches}ms antes do prÃ³ximo lote...`);
                    await sleep(cfg.delayBetweenBatches);
                }
            }

            // Summary
            const duration = Date.now() - this.state.stats.startTime;
            logger.info(`âœ… Ultra Fast Dungeon concluÃ­do em ${(duration / 1000).toFixed(1)}s`);
            logger.info(`ðŸ“Š ${this.state.stats.totalAttacks} ataques, ${this.state.stats.monstersCompleted} mobs completados`);

            this.showResults(context);
        },

        async scanDungeonTargets(context) {
            const cfg = context.config.get().ultraFastDungeon;
            const { logger } = context;

            // Extract filter names from CSV format (ultraFastDungeon.monsterNames)
            // Support both old and new formats for backward compatibility
            let includeNames = [];
            let excludeNames = [];
            
            // Try new structure first (monsterFilter.includeNames/excludeNames)
            const monsterFilter = cfg.monsterFilter || {};
            if (Array.isArray(monsterFilter.includeNames)) {
                includeNames = monsterFilter.includeNames.filter(Boolean);
            }
            if (Array.isArray(monsterFilter.excludeNames)) {
                excludeNames = monsterFilter.excludeNames.filter(Boolean);
            }
            
            // Fallback to old CSV format (monsterNames from textarea)
            if (includeNames.length === 0 && cfg.monsterNames) {
                const csv = String(cfg.monsterNames).trim();
                if (csv) {
                    // Parse CSV: split by newlines or commas, trim whitespace
                    includeNames = csv
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                }
            }
            
            // Parse monster filters - suporta formato "nome" ou "nome:dano"
            const rawMonsterNames = includeNames.length > 0 ? includeNames : [];
            const monsterFilters = rawMonsterNames.map(entry => {
                const str = String(entry).trim();
                const colonIndex = str.lastIndexOf(':');
                
                if (colonIndex > 0) {
                    const namePart = str.substring(0, colonIndex).trim();
                    const damagePart = str.substring(colonIndex + 1).trim();
                    const customDamage = context.numbers.parse(damagePart);
                    
                    if (namePart && customDamage && customDamage > 0) {
                        return { name: namePart, customDamage };
                    }
                }
                
                // Formato simples (sÃ³ nome)
                return { name: str, customDamage: null };
            }).filter(f => f.name.length > 0);
            
            // Log active filters
            if (includeNames.length > 0) {
                logger.info(`[UltraFastDungeon] âœ“ Incluindo APENAS: ${includeNames.join(', ')}`);
            }
            if (excludeNames.length > 0) {
                logger.info(`[UltraFastDungeon] âœ— Excluindo: ${excludeNames.join(', ')}`);
            }
            logger.debug(`[UltraFastDungeon] Monster filters:`, monsterFilters.map(f => f.customDamage ? `${f.name}:${f.customDamage}` : f.name));

            // Use Monster Scanner Service
            const scanFilters = {
                minHp: cfg.minMobHp
            };
            
            // Only apply joined filters if explicitly enabled/disabled
            if (cfg.checkJoined && !cfg.checkNotJoined) {
                // Only joined monsters
                logger.debug('[UltraFastDungeon] Filter: Only JOINED monsters');
            } else if (cfg.checkNotJoined && !cfg.checkJoined) {
                // Only not joined monsters
                scanFilters.onlyNotJoined = true;
                logger.debug('[UltraFastDungeon] Filter: Only NOT JOINED monsters');
            } else {
                // Both (no filter)
                logger.debug('[UltraFastDungeon] Filter: BOTH joined and not joined monsters');
            }

            // Extract just the names for scanner
            if (monsterFilters.length > 0) {
                scanFilters.monsterNames = monsterFilters.map(f => f.name);
                logger.debug(`[UltraFastDungeon] Name filters: ${scanFilters.monsterNames.join(', ')}`);
            } else {
                logger.debug('[UltraFastDungeon] Name filters: ALL monsters');
            }

            let monsters = context.monsterScanner.scanDungeonMonsters(scanFilters);
            logger.info(`[UltraFastDungeon] Scanner found ${monsters.length} dungeon monsters`);

            // Apply exclude filter as secondary filter
            if (excludeNames.length > 0) {
                const beforeCount = monsters.length;
                monsters = monsters.filter(monster => {
                    const monsterNameLower = (monster.name || '').toLowerCase();
                    return !excludeNames.some(excludeName => 
                        monsterNameLower.includes(excludeName.toLowerCase())
                    );
                });
                logger.info(`[UltraFastDungeon] ApÃ³s filtro de exclusÃ£o: ${beforeCount} â†’ ${monsters.length} monstros`);
            }

            // Convert to Ultra Fast Dungeon format + add customDamageLimit
            const targets = monsters.map(monster => {
                const matchedFilter = monsterFilters.find(filter => 
                    monster.name.toLowerCase().includes(filter.name.toLowerCase())
                );

                return {
                    dgmid: monster.dgmid,
                    instanceId: monster.instanceId,
                    name: monster.name,
                    currentHp: monster.hp,
                    maxHp: monster.maxHp,
                    currentDamage: 0, // Will be fetched if joined
                    hasJoined: monster.hasJoined,
                    card: monster.card,
                    customDamageLimit: matchedFilter?.customDamage || null
                };
            });

            // Fetch current damage for joined battles
            if (targets.length > 0) {
                await this.fetchCurrentDamages(context, targets);
            }

            // Filter by threshold AFTER fetching damages
            const cfg2 = context.config.get().ultraFastDungeon;
            const filteredTargets = targets.filter(target => {
                const isMagus = /magus/i.test(target.name);
                const isSpecial = isSpecialBoss(target.name);
                
                // Priority: customDamageLimit > special boss (50M) > magus threshold > default threshold
                let damageThreshold;
                if (target.customDamageLimit) {
                    damageThreshold = target.customDamageLimit;
                    logger.debug(`[UltraFastDungeon] ${target.name}: Usando limite customizado: ${formatNumber(damageThreshold)}`);
                } else if (isSpecial) {
                    damageThreshold = Math.max(50000000, cfg2.damageThresholds.default); // 50M minimum for special bosses
                    logger.info(`[UltraFastDungeon] ðŸ‘‘ ${target.name}: Boss especial - alvo: ${formatNumber(damageThreshold)} (mÃ­nimo 50M para loot)`);
                } else {
                    damageThreshold = isMagus ? cfg2.damageThresholds.magus : cfg2.damageThresholds.default;
                }
                
                const safeThreshold = Math.floor(damageThreshold * cfg2.safetyMargin);
                
                // Calculate 20% of total HP limit (required for full EXP on kill)
                const expLimit = Math.floor(target.maxHp * 0.20);
                
                // Use the most restrictive limit
                let effectiveLimit = safeThreshold;
                if (cfg2.respectExpLimit && expLimit < safeThreshold) {
                    effectiveLimit = expLimit;
                    logger.debug(`[UltraFastDungeon] ${target.name}: Limite de EXP (20% HP) aplicado: ${formatNumber(expLimit)} < ${formatNumber(safeThreshold)}`);
                }

                target.isMagus = isMagus;
                target.maxDamage = effectiveLimit;
                target.remainingDamage = effectiveLimit - target.currentDamage;

                // Skip if already at or above threshold
                if (target.currentDamage >= effectiveLimit) {
                    logger.debug(`[UltraFastDungeon] ${target.name}: Dano ${formatNumber(target.currentDamage)} >= ${formatNumber(effectiveLimit)} (threshold) - ignorado`);
                    return false;
                }

                logger.debug(`[UltraFastDungeon] âœ“ ${target.name}: HP ${formatNumber(target.currentHp)}, Dano ${formatNumber(target.currentDamage)}/${formatNumber(effectiveLimit)} (faltam ${formatNumber(target.remainingDamage)})`);
                return true;
            });

            // Sort by priority
            this.sortTargets(filteredTargets, cfg2.priorityMode);

            return filteredTargets;
        },

        async fetchCurrentDamages(context, targets) {
            const { logger } = context;
            const joinedTargets = targets.filter(t => t.hasJoined);
            
            if (joinedTargets.length === 0) return;

            logger.info(`ðŸ” Verificando dano atual de ${joinedTargets.length} batalhas jÃ¡ iniciadas...`);

            // Fetch damages in parallel (max 5 at a time to avoid overwhelming)
            const batchSize = 5;
            for (let i = 0; i < joinedTargets.length; i += batchSize) {
                const batch = joinedTargets.slice(i, i + batchSize);
                await Promise.all(batch.map(target => this.fetchBattleDamage(context, target)));
                await sleep(200); // Small delay between batches
            }
        },

        async fetchBattleDamage(context, target) {
            const { logger } = context;

            try {
                const url = `https://demonicscans.org/battle.php?dgmid=${target.dgmid}&instance_id=${target.instanceId}`;
                const response = await fetch(url, { credentials: 'include' });
                
                if (!response.ok) {
                    logger.warn(`[Damage Fetch] HTTP ${response.status} para ${target.name}`);
                    return;
                }

                const html = await response.text();
                
                // Parse damage from HTML: DMG: <span id="yourDamageValue">5,291,020</span>
                const damageMatch = html.match(/DMG:\s*<span[^>]*>([0-9,]+)<\/span>/i);
                if (damageMatch) {
                    target.currentDamage = numberFromText(damageMatch[1]);
                    logger.debug(`[Damage Fetch] ${target.name}: ${formatNumber(target.currentDamage)} dano`);
                } else {
                    // Try alternative patterns
                    const altMatch = html.match(/yourDamageValue[^>]*>([0-9,]+)</i);
                    if (altMatch) {
                        target.currentDamage = numberFromText(altMatch[1]);
                        logger.debug(`[Damage Fetch] ${target.name}: ${formatNumber(target.currentDamage)} dano (alt)`);
                    }
                }
            } catch (error) {
                logger.warn(`[Damage Fetch] Erro ao buscar dano de ${target.name}:`, error.message);
            }
        },

        sortTargets(targets, mode) {
            switch (mode) {
                case 'lowest_damage':
                    targets.sort((a, b) => a.currentDamage - b.currentDamage);
                    break;
                case 'highest_damage':
                    targets.sort((a, b) => b.currentDamage - a.currentDamage);
                    break;
                case 'lowest_hp':
                    targets.sort((a, b) => a.currentHp - b.currentHp);
                    break;
                case 'highest_hp':
                    targets.sort((a, b) => b.currentHp - a.currentHp);
                    break;
            }
        },

        async ensureBattlesJoined(context, targets) {
            const { logger } = context;
            const joinedTargets = [];

            // Separar alvos que jÃ¡ estÃ£o joined dos que precisam join
            const alreadyJoined = targets.filter(t => t.hasJoined);
            const needJoin = targets.filter(t => !t.hasJoined);

            // Adicionar os que jÃ¡ estÃ£o joined
            alreadyJoined.forEach(target => {
                joinedTargets.push(target);
                logger.debug(`[UltraFastDungeon] ${target.name}: JÃ¡ estÃ¡ joined`);
            });

            if (needJoin.length === 0) {
                return joinedTargets;
            }

            // ðŸ”¥ PRE-FLIGHT ATTACK: Preparar TODAS as requisiÃ§Ãµes de join antes de enviar
            logger.info(`ðŸš€ PRE-FLIGHT JOIN: Preparando ${needJoin.length} requisiÃ§Ãµes simultÃ¢neas...`);
            
            // Criar array de promises para joins simultÃ¢neos
            const joinPromises = needJoin.map(target => {
                // Retornar uma funÃ§Ã£o que cria a promise (nÃ£o a promise diretamente)
                return {
                    target,
                    execute: () => context.http.joinDungeonBattle(target.dgmid, target.instanceId)
                };
            });

            logger.info(`âš¡ Disparando ${joinPromises.length} joins SIMULTANEAMENTE...`);
            
            // Executar TODAS as requisiÃ§Ãµes ao mesmo tempo (Pre-Flight)
            const startTime = Date.now();
            const results = await Promise.all(
                joinPromises.map(async ({ target, execute }) => {
                    try {
                        const result = await execute();
                        return { target, result, success: true };
                    } catch (error) {
                        logger.error(`Erro ao entrar em ${target.name}: ${error.message}`);
                        return { target, result: { success: false, message: error.message }, success: false };
                    }
                })
            );
            const duration = Date.now() - startTime;

            logger.info(`âœ… Pre-Flight concluÃ­do em ${duration}ms`);

            // Processar resultados
            let successCount = 0;
            let failCount = 0;

            results.forEach(({ target, result }) => {
                if (result.success || result.cloudflareBlock) {
                    joinedTargets.push(target);
                    this.state.stats.successfulJoins++;
                    this.state.stats.totalMonsters++;
                    successCount++;
                    logger.debug(`  âœ… ${target.name}: Join bem-sucedido`);
                } else {
                    logger.warn(`  âš ï¸ ${target.name}: Falha - ${result.message}`);
                    this.state.stats.failedJoins++;
                    failCount++;
                }
            });

            logger.info(`ðŸ“Š Pre-Flight Join: ${successCount} sucessos, ${failCount} falhas (${duration}ms total)`);

            return joinedTargets;
        },

        async attackWithSmartDamage(context, targets) {
            const cfg = context.config.get().ultraFastDungeon;
            const battleCfg = context.config.get().battle;
            const { logger } = context;

            if (targets.length === 0) {
                logger.warn('âš ï¸ Nenhum alvo para atacar');
                return;
            }

            // Inicializar estado de cada alvo
            const targetStates = targets.map(target => ({
                ...target,
                attackCount: 0,
                totalDamageDealt: 0,
                currentDamage: target.currentDamage,
                completed: false,
                skillId: battleCfg.attackSkillId || 0
            }));

            logger.info(`ðŸš€ PRE-FLIGHT ATTACK: ${targets.length} monstros, ${cfg.attacksPerMonster} ataques cada`);

            // Executar rodadas de ataque paralelo
            for (let round = 0; round < cfg.attacksPerMonster; round++) {
                // Verificar stamina antes de cada rodada
                const currentStamina = context.stamina.getCurrent();
                if (currentStamina === 0) {
                    logger.warn(`âš ï¸ Stamina em 0! Parando ataques.`);
                    logger.info(`ðŸ’¡ Aguarde a Stamina regenerar ou use uma poÃ§Ã£o de Stamina.`);
                    this.state.running = false;
                    return;
                }

                // Filtrar alvos que ainda precisam de ataque
                const activeTargets = targetStates.filter(t => !t.completed && t.attackCount < cfg.attacksPerMonster);
                
                if (activeTargets.length === 0) {
                    logger.info(`âœ… Todos os alvos atingiram threshold ou completaram ataques`);
                    break;
                }

                logger.info(`âš”ï¸ Rodada ${round + 1}/${cfg.attacksPerMonster}: Atacando ${activeTargets.length} monstros em PARALELO...`);

                // Preparar ataques para todos os alvos ativos (Pre-Flight)
                const attackPromises = activeTargets.map(targetState => {
                    // Recalcular skill se usando smart damage
                    if (cfg.useSmartDamage) {
                        // Ultra Fast Dungeon usa smartDamage de battle.smartDamage, mas sÃ³ precisa de useSmartDamage=true
                        // Se smartDamage nÃ£o estiver configurado, usar skills padrÃ£o
                        const skills = battleCfg.smartDamage?.skills || {
                            slash: { skillId: 0, damageLimit: 0, name: 'Slash' },
                            powerSlash: { skillId: -1, damageLimit: 320000, name: 'Power Slash' },
                            heroicSlash: { skillId: -2, damageLimit: 1600000, name: 'Heroic Slash' },
                            ultimateSlash: { skillId: -3, damageLimit: 3400000, name: 'Ultimate Slash' },
                            legendarySlash: { skillId: -4, damageLimit: 6800000, name: 'Legendary Slash' }
                        };
                        
                        const smartSkill = selectSmartSkill(targetState.currentDamage, targetState.maxDamage, skills);
                        if (smartSkill) {
                            targetState.skillId = smartSkill.skillId;
                            logger.debug(`  ðŸ§  ${targetState.name}: Smart damage selecionou ${smartSkill.name} (skillId: ${smartSkill.skillId}, limite: ${formatNumber(smartSkill.damageLimit)})`);
                        }
                    }

                    return {
                        targetState,
                        execute: () => this.sendAttack(context, targetState.dgmid, targetState.instanceId, targetState.skillId)
                    };
                });

                // Disparar TODOS os ataques simultaneamente
                const startTime = Date.now();
                const results = await Promise.all(
                    attackPromises.map(async ({ targetState, execute }) => {
                        try {
                            const attackResult = await execute();
                            return { targetState, attackResult, error: null };
                        } catch (error) {
                            return { targetState, attackResult: null, error };
                        }
                    })
                );
                const duration = Date.now() - startTime;

                // Processar resultados
                let successCount = 0;
                let thresholdCount = 0;

                for (const { targetState, attackResult, error } of results) {
                    if (error) {
                        logger.error(`  âŒ ${targetState.name}: Erro - ${error.message}`);
                        continue;
                    }

                    if (attackResult?.success) {
                        // Extract damage from the correct field (combat service returns it at top level)
                        const damageDealt = attackResult.damageDealt || attackResult.data?.damageDealt || 0;
                        const monsterHp = attackResult.data?.hp?.value || 0;
                        
                        targetState.attackCount++;
                        targetState.totalDamageDealt += damageDealt;
                        targetState.currentDamage += damageDealt;
                        this.state.stats.totalAttacks++;
                        successCount++;
                        
                        logger.debug(`  âœ“ ${targetState.name}: +${formatNumber(damageDealt)} dano (Total: ${formatNumber(targetState.currentDamage)}/${formatNumber(targetState.maxDamage)})`);
                        
                        // Verificar threshold
                        if (targetState.currentDamage >= targetState.maxDamage) {
                            targetState.completed = true;
                            thresholdCount++;
                            logger.info(`  ðŸŽ¯ ${targetState.name}: Threshold atingido! (${formatNumber(targetState.currentDamage)}/${formatNumber(targetState.maxDamage)})`);
                        }
                    } else {
                        logger.warn(`  âš ï¸ ${targetState.name}: Ataque falhou`);
                        targetState.attackCount++; // Contar mesmo falhando para evitar loop infinito
                    }
                }

                logger.info(`ðŸ“Š Rodada ${round + 1}: ${successCount} ataques OK, ${thresholdCount} thresholds (${duration}ms)`);

                // Pequeno delay entre rodadas (nÃ£o entre ataques individuais)
                if (round < cfg.attacksPerMonster - 1) {
                    await sleep(200);
                }
            }

            // Resumo final
            for (const targetState of targetStates) {
                logger.info(`âœ… ${targetState.name}: ${targetState.attackCount} ataques, ${formatNumber(targetState.totalDamageDealt)} dano total`);
                this.state.stats.monstersCompleted++;
            }
        },

        async sendAttack(context, dgmid, instanceId, skillId) {
            const { logger } = context;
            
            // Use centralized combat service (Cloudflare-proof)
            return context.combat.attackDungeonMonsterDirect(dgmid, instanceId, skillId);
        },

        estimateDamage(skillId) {
            // Rough damage estimates based on skill ID
            // These are very rough estimates - actual damage varies
            switch (skillId) {
                case 0: return 50000;      // Slash
                case -1: return 200000;    // Power Slash
                case -2: return 800000;    // Heroic Slash
                case -3: return 2000000;   // Ultimate Slash
                case -4: return 4000000;   // Legendary Slash
                default: return 50000;
            }
        },

        showResults(context) {
            const { logger } = context;
            const stats = this.state.stats;
            const duration = Date.now() - stats.startTime;

            logger.info('âœ¨ Ultra Fast Dungeon concluÃ­do!');
            logger.info(`ðŸ“Š Stats: ${stats.totalAttacks} ataques, ${stats.monstersCompleted} mobs`);
            logger.info(`â±ï¸ DuraÃ§Ã£o: ${(duration / 1000).toFixed(1)}s`);

            // Get floating helpers module
            const floatingHelpers = context.moduleRegistry?.getModule('floatingHelpers');
            
            if (!floatingHelpers || typeof floatingHelpers.openQuickLootModal !== 'function') {
                logger.warn('[UltraFastDungeon] Modal not available');
                return;
            }

            // Create summary
            const summary = {
                drops: 0,
                exp: 0,
                gold: 0,
                items: new Map(),
                monsters: new Map(),
                messages: []
            };

            const durationSec = (duration / 1000).toFixed(1);
            summary.messages.push(`âš¡ Ultra Fast Dungeon: ${stats.monstersCompleted} mobs em ${durationSec}s`);
            summary.messages.push(`âš”ï¸ ${stats.totalAttacks} ataques enviados`);
            summary.messages.push(`âœ… ${stats.successfulJoins} joins, âŒ ${stats.failedJoins} falhas`);

            floatingHelpers.openQuickLootModal(context, summary, 'Ultra Fast Dungeon');
        },

        cleanup() {
            if (this.state) {
                this.state.running = false;
            }
        }
    };

    const pvpModule = {
        id: 'pvpAutomation',
        match: ({ location }) => {
            const path = location.pathname;
            // Match pvp.php and pvp_battle.php
            return /pvp(\/|\.php|_battle)/i.test(path);
        },
        init(context) {
            const persistedMode = typeof sessionStorage !== 'undefined' ? sessionStorage.getItem('autods.pvp.mode') : null;
            const persistedRemaining = typeof sessionStorage !== 'undefined' ? sessionStorage.getItem('autods.pvp.remaining') : null;
            this.state = {
                active: true,
                mode: persistedMode || null,
                remaining: persistedRemaining !== null ? parseInt(persistedRemaining, 10) : null,
                lastBattle: null
            };
            if (Number.isNaN(this.state.remaining)) {
                this.state.remaining = null;
            }
            context.logger.debug('pvpAutomation module initialised');
        },
        activate(context) {
            const cfgRoot = context.config.get();
            const cfg = cfgRoot.pvp;
            
            // If ultraFastMode is enabled, skip this module (use ultraFastPvpModule instead)
            if (cfg?.ultraFastMode) {
                context.logger.debug('[pvpAutomation] Ultra Fast Mode enabled, deferring to ultraFastPvpModule');
                return;
            }
            
            if (!cfgRoot.core.enabled || !cfg?.enabled) {
                this.stop(context, 'disabled');
                return;
            }
            if (!this.state) this.init(context);
            this.ensureStateForConfig(cfg);
            const path = context.location.pathname.toLowerCase();
            if (path.includes('pvp_battle')) {
                this.handleBattle(context).catch(error => context.logger.error('Erro na rotina PvP (batalha)', error));
            } else if (path.includes('pvp.php')) {
                this.handleLobby(context).catch(error => context.logger.error('Erro na rotina PvP (lobby)', error));
            } else {
                context.logger.debug('PvP: nenhuma automaÃ§Ã£o para esta rota.', { path });
            }
        },
        ensureStateForConfig(cfg) {
            if (!this.state) return;
            if (cfg.autoMode === 'limited') {
                const limited = Math.max(0, cfg.limitedBattles ?? 0);
                if (this.state.mode !== 'limited') {
                    this.state.mode = 'limited';
                    this.state.remaining = limited;
                } else if (this.state.remaining === null) {
                    this.state.remaining = limited;
                } else if (this.state.remaining > limited) {
                    this.state.remaining = limited;
                }
            } else {
                this.state.mode = 'all';
                this.state.remaining = null;
            }
            this.persistState();
        },
        persistState() {
            if (typeof sessionStorage === 'undefined') return;
            try {
                if (this.state?.mode) {
                    sessionStorage.setItem('autods.pvp.mode', this.state.mode);
                } else {
                    sessionStorage.removeItem('autods.pvp.mode');
                }
                if (this.state?.mode === 'limited' && this.state.remaining !== null) {
                    sessionStorage.setItem('autods.pvp.remaining', String(this.state.remaining));
                } else {
                    sessionStorage.removeItem('autods.pvp.remaining');
                }
            } catch (error) {
                console.warn('[AutoDS][pvp] Failed to persist session state', error);
            }
        },
        stop(context, reason) {
            if (!this.state) return;
            if (this.state.active) {
                context.logger.info(`PvP automation pausada${reason ? `: ${reason}` : ''}`);
            }
            this.state.active = false;
            this.persistState();
        },
        async handleLobby(context) {
            const cfg = context.config.get().pvp;
            
            // Check PvP Tokens first
            const tokens = this.getPvPTokens();
            if (tokens) {
                context.logger.debug(`PvP: Tokens detected - ${tokens.current}/${tokens.max}`);
                
                if (tokens.current === 0) {
                    context.logger.warn('âš ï¸ PvP: Sem tokens disponÃ­veis (0/' + tokens.max + '). Pausando automaÃ§Ã£o.');
                    this.stop(context, 'sem tokens PvP');
                    
                    // Show notification to user
                    context.notifications.autoPaused('no PvP tokens available');
                    return;
                }
                
                // Warn if tokens are low
                if (tokens.current < 3) {
                    context.logger.warn(`âš ï¸ PvP: Tokens baixos (${tokens.current}/${tokens.max})`);
                }
            }
            
            const coins = this.getCoins();
            if (coins === null) {
                context.logger.warn('PvP: nÃ£o foi possÃ­vel determinar a quantidade de moedas.');
                this.stop(context, 'moedas desconhecidas');
                return;
            }
            if (coins <= 0) {
                this.stop(context, 'sem moedas PvP');
                return;
            }
            if (cfg.autoMode === 'limited') {
                this.state.remaining = Math.max(0, this.state.remaining ?? cfg.limitedBattles ?? 0);
                if (this.state.remaining <= 0) {
                    this.stop(context, 'limite diÃ¡rio de batalhas atingido');
                    return;
                }
            }

            const startControl = this.findStartControl();
            if (!startControl) {
                context.logger.warn('PvP: botÃ£o ou link para iniciar batalha nÃ£o encontrado.');
                return;
            }

            this.state.active = true;
            if (cfg.autoMode === 'limited') {
                this.state.remaining = Math.max(0, (this.state.remaining ?? 1) - 1);
            }
            this.persistState();

            context.logger.info('PvP: iniciando batalha automÃ¡tica.');
            this.triggerControl(startControl);
            await sleepRandom(cfg.lobbyDelayMs ?? 1200, 0.25, true);
            context.events.emit('autods:pvp:battleStart', { timestamp: Date.now() });
        },
        findStartControl() {
            const selectors = [
                '#btnStartTop',
                '#btnStartBottom',
                'form[action*="pvp_battle"] button[type="submit"]',
                'form[action*="pvpBattle"] button[type="submit"]',
                '.hero-btn[href*="pvp_battle"]',
                'a.hero-btn[href*="pvp_battle"]',
                'a[href*="pvp_battle.php"]',
                'button[href*="pvp_battle.php"]',
                'button.start-battle',
                'button[name*="pvp_start" i]',
                'button[data-action*="pvp" i]'
            ];
            for (const selector of selectors) {
                const node = document.querySelector(selector);
                if (node) return node;
            }
            return null;
        },
        triggerControl(node) {
            if (!node) return;
            if (node.tagName === 'A' && node.href) {
                window.location.href = node.href;
                return;
            }
            if (typeof node.click === 'function') {
                node.click();
                return;
            }
            const form = node.closest('form');
            if (form) {
                if (typeof form.requestSubmit === 'function') {
                    form.requestSubmit(node);
                } else {
                    form.submit();
                }
            }
        },
        getCoins() {
            const gauges = readGauge(
                ['#pvp-coins', '[data-pvp-coins]', '.pvp-coins .value', '.pvp-coins', '#pvpCoins'],
                {}
            );
            if (gauges && gauges.current !== null) {
                return gauges.current;
            }
            const candidates = Array.from(document.querySelectorAll('span, strong, b, div, td, p'))
                .slice(0, 500)
                .filter(node => /pvp\s*coins?/i.test(node.textContent || ''));
            for (const node of candidates) {
                const value = numberFromText(node.textContent);
                if (value !== null) return value;
            }
            return null;
        },
        getPvPTokens() {
            // Try reading PvP Tokens gauge (format: "âš”ï¸ 0/30")
            const gauges = readGauge(
                ['[data-pvp-tokens]', '.pvp-tokens', '#pvpTokens', '.pvp-token-count'],
                { parse: true }
            );
            if (gauges && gauges.current !== null) {
                return gauges;
            }
            
            // Fallback: search for "PvP Token" or "Token" text
            const candidates = Array.from(document.querySelectorAll('span, strong, b, div, td, p'))
                .slice(0, 500)
                .filter(node => /pvp\s*token/i.test(node.textContent || ''));
            
            for (const node of candidates) {
                const text = node.textContent || '';
                // Look for pattern like "0/30" or "0 / 30"
                const match = text.match(/(\d+)\s*\/\s*(\d+)/);
                if (match) {
                    return {
                        current: parseInt(match[1], 10),
                        max: parseInt(match[2], 10),
                        percent: (parseInt(match[1], 10) / parseInt(match[2], 10)) * 100
                    };
                }
            }
            
            return null;
        },
        async handleBattle(context) {
            const cfg = context.config.get().pvp;
            context.logger.info('PvP: controle automÃ¡tico de batalha iniciado.');
            while (/pvp_battle/.test(context.location.pathname)) {
                const freshCfg = context.config.get().pvp;
                if (!freshCfg.enabled) {
                    this.stop(context, 'config desabilitada em batalha');
                    break;
                }

                if (this.shouldSurrender(freshCfg)) {
                    if (this.performSurrender(context)) {
                        await sleepRandom(1500, 0.2, true);
                        break;
                    }
                }

                const result = this.checkBattleResult();
                if (result.done) {
                    await this.finishBattle(context, freshCfg);
                    break;
                }

                const attackButton = resolveAttackButton(context.dom, freshCfg, true);
                if (attackButton) {
                    // Double-check: verify modal hasn't appeared just before attacking
                    const preAttackCheck = this.checkBattleResult();
                    if (preAttackCheck.done) {
                        context.logger.info('PvP: modal de fim detectado antes do ataque. Parando.');
                        await this.finishBattle(context, freshCfg);
                        break;
                    }

                    // attackUnlockerModule handles button unlocking globally
                    // Just click the button directly
                    attackButton.click();
                    context.logger.debug('PvP: ataque disparado (Power Slash).');

                    // Wait for attack animation/response
                    await sleepRandom(freshCfg.attackDelayMs ?? 1500, freshCfg.attackVariation ?? 0.25, true);

                    // Check again after attack - modal may have appeared during cooldown
                    const postAttackCheck = this.checkBattleResult();
                    if (postAttackCheck.done) {
                        context.logger.info('PvP: batalha finalizada apÃ³s Ãºltimo ataque.');
                        await this.finishBattle(context, freshCfg);
                        break;
                    }
                } else {
                    // No attack button available, wait and check again
                    await sleepRandom(freshCfg.attackDelayMs ?? 1500, freshCfg.attackVariation ?? 0.25, true);
                }
            }
        },
        shouldSurrender(cfg) {
            if (!cfg.autoSurrender) return false;
            const myHp = readGauge([
                '#myHpText',
                '#player_hp',
                '.player-hp .current',
                '.player-hp',
                '[data-player-hp]'
            ], {});
            if (!myHp || myHp.current === null || !myHp.max) return false;
            const percent = (myHp.current / myHp.max) * 100;
            return percent <= (cfg.autoSurrenderThreshold ?? 10);
        },
        performSurrender(context) {
            const surrenderButton = document.querySelector('#btnSurrender, button[name="surrender" i], .btn-surrender, button[data-action="surrender" i]');
            if (surrenderButton && !surrenderButton.disabled) {
                surrenderButton.click();
                context.logger.warn('PvP: HP crÃ­tico detectado. RendiÃ§Ã£o automÃ¡tica executada.');
                context.events.emit('autods:pvp:surrender', { timestamp: Date.now() });
                return true;
            }
            return false;
        },
        checkBattleResult() {
            // Priority 1: Check for end modal with ID #endModal (most specific)
            const endModal = document.querySelector('#endModal');
            if (endModal) {
                // Use computed style since display can be changed via JS (not inline style)
                const computedStyle = window.getComputedStyle(endModal);
                const isVisible = computedStyle.display !== 'none' &&
                                 computedStyle.display !== '' &&
                                 endModal.offsetParent !== null;

                // Also check if #endBody has content (populated after battle ends)
                const endBody = document.querySelector('#endBody');
                const hasContent = endBody && endBody.textContent && endBody.textContent.trim().length > 0;

                if (isVisible || hasContent) {
                    return { done: true, node: endModal, type: 'modal' };
                }
            }

            // Priority 2: Check for other result indicators
            const victoryNode = document.querySelector('.battle-result, .result-box, .pvp-result, #battle-result, .battle-summary');
            if (victoryNode) {
                return { done: true, node: victoryNode, type: 'result' };
            }

            // Priority 3: Check for generic modals with battle end content
            const genericModal = document.querySelector('.modal, .end-modal, [data-modal], .battle-end');
            if (genericModal && genericModal.style.display !== 'none' && /victory|defeat|win|lose|ended/i.test(genericModal.textContent || '')) {
                return { done: true, node: genericModal, type: 'modal' };
            }

            // Priority 4: Check HP status (both must be checked)
            const enemyHp = readGauge([
                '#enemyHpText',
                '#enemy_hp',
                '.enemy-hp .current',
                '.enemy-hp',
                '[data-enemy-hp]'
            ], {});

            const myHp = readGauge([
                '#myHpText',
                '#player_hp',
                '.player-hp .current',
                '.player-hp',
                '[data-player-hp]'
            ], {});

            // Only consider battle done if HP reaches zero AND modal appears
            // Don't return done based on HP alone to avoid premature detection
            if ((enemyHp && enemyHp.current !== null && enemyHp.current <= 0) ||
                (myHp && myHp.current !== null && myHp.current <= 0)) {
                // HP reached zero, but wait for modal confirmation in next loop
                return { done: false, hpZero: true };
            }

            return { done: false };
        },
        async finishBattle(context, cfg) {
            context.logger.info('PvP: batalha concluÃ­da. Aguardando modal de resultado...');
            context.events.emit('autods:pvp:battleEnd', { timestamp: Date.now() });

            // Wait for modal to fully appear and be readable (1.5 seconds)
            await sleepRandom(1500, 0.3, true);

            // Check if modal is still visible using computed style
            const endModal = document.querySelector('#endModal');
            if (endModal) {
                const computedStyle = window.getComputedStyle(endModal);
                const isVisible = computedStyle.display !== 'none';
                if (isVisible) {
                    context.logger.info('PvP: modal de resultado exibido. Retornando ao lobby.');
                } else {
                    context.logger.warn('PvP: modal nÃ£o visÃ­vel, retornando ao lobby de qualquer forma.');
                }
            } else {
                context.logger.warn('PvP: modal #endModal nÃ£o encontrado, retornando ao lobby de qualquer forma.');
            }

            const returnLink = document.querySelector('a[href*="pvp.php" i]');
            if (returnLink) {
                context.logger.info('PvP: clicando no link de retorno ao lobby.');
                this.triggerControl(returnLink);
            } else {
                context.logger.info('PvP: redirecionando para lobby via URL.');
                context.window.location.href = 'https://demonicscans.org/pvp.php';
            }

            // Small delay before next battle
            await sleepRandom(cfg.cooldownBetweenBattlesMs ?? 2200, 0.2, true);
        }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ðŸš€ ULTRA FAST PVP MODULE - Maximum speed PvP automation
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const ultraFastPvpModule = {
        id: 'ultraFastPvp',
        match: ({ location }) => {
            const path = location.pathname.toLowerCase();
            return path.includes('pvp.php') || path.includes('pvp_battle');
        },
        
        init(context) {
            this.state = {
                active: false,
                isRunning: false,  // Flag to prevent duplicate activation
                battlesCompleted: 0,
                battlesWon: 0,
                battlesLost: 0,
                attacksSent: 0,
                sessionStartTime: null,
                currentBattleStartTime: null,
                running: true,  // Changed to true so the loop can execute
                rotationPatternIndex: 0,  // Which skill group in the pattern
                rotationAttackCount: 0  // Count of attacks in current skill group
            };
            
            // Listen for config changes to re-activate the module if enabled
            if (context.events && typeof context.events.on === 'function') {
                context.events.on('autods:config:updated', () => {
                    const cfg = context.config.get().pvp;
                    if (cfg?.ultraFastMode && this.match({ location: context.location })) {
                        // Re-activate the module when config changes to enabled
                        context.logger.info('[UltraFastPvP] Config changed - re-activating module');
                        this.activate(context);
                    }
                });
            }
        },
        
        activate(context) {
            try {
                if (!this.state) {
                    this.init(context);
                }
                
                // Prevent duplicate activation
                if (this.state.isRunning) {
                    return;
                }
                
                const cfgRoot = context.config.get();
                const cfg = cfgRoot.pvp;
                const path = context.location.pathname.toLowerCase();
                
                // Log FIRST - so user always sees the module is being activated
                context.logger.debug(`[UltraFastPvP] Module activated on ${path}`);
                context.logger.debug(`[UltraFastPvP] Config state - core.enabled=${cfgRoot.core?.enabled}, ultraFastMode=${cfg?.ultraFastMode}`);
                
                // Check if core automation is enabled
                if (!cfgRoot.core.enabled) {
                    context.logger.debug('[UltraFastPvP] Core automation disabled globally');
                    return;
                }
                
                // Check if Ultra Fast Mode is enabled (main control)
                if (!cfg?.ultraFastMode) {
                    context.logger.debug('[UltraFastPvP] Ultra Fast Mode disabled - enable in UI');
                    return;
                }
                
                // Mark as running
                this.state.isRunning = true;
                
                // All conditions met - start automation
                if (path.includes('pvp_battle')) {
                    this.handleUltraFastBattle(context).catch(error => {
                        context.logger.error('Ultra Fast PvP battle error:', error);
                        this.state.isRunning = false;
                    });
                } else if (path.includes('pvp.php')) {
                    context.logger.info('[UltraFastPvP] Starting matchmaking loop');
                    this.runAutoMatchmakingLoop(context).catch(error => {
                        context.logger.error('Ultra Fast PvP matchmaking error:', error);
                        this.state.isRunning = false;
                    });
                }
            } catch (error) {
                context.logger.error('Ultra Fast PvP FATAL ERROR:', error);
                this.state.isRunning = false;
            }
        },
        
        cleanup() {
            this.state.running = false;
            this.state.active = false;
        },
        
        /**
         * Main automated matchmaking loop (runs when on pvp.php)
         * Continuously tries to find battles until tokens run out
         */
        async runAutoMatchmakingLoop(context) {
            const { logger } = context;
            const cfg = context.config.get().pvp;
            
            if (!cfg?.ultraFastMode) {
                logger.info('[UltraFastPvP] ultraFastMode desativado, abortando');
                return;
            }
            
            // Initialize session start time
            if (!this.state.sessionStartTime) {
                this.state.sessionStartTime = Date.now();
            }
            
            let attemptCount = 0;
            const maxAttempts = 100;  // Safety limit
            
            logger.info('ðŸŸï¸ Ultra Fast PvP: Starting auto matchmaking loop...');
            
            while (this.state.running && attemptCount < maxAttempts) {
                attemptCount++;
                logger.debug(`[UltraFastPvP] Tentativa ${attemptCount}/${maxAttempts}`);
                
                // Check if Ultra Fast Mode is still enabled
                const freshCfg = context.config.get().pvp;
                if (!freshCfg?.ultraFastMode) {
                    logger.info('â¸ï¸ Ultra Fast PvP disabled via config');
                    break;
                }
                
                // Check tokens from page
                const tokens = this.getPvpTokens();
                if (!tokens) {
                    logger.warn('âš ï¸ Could not read PvP tokens from page');
                    await sleep(1000);
                    continue;
                }
                
                logger.debug(`âš”ï¸ PvP Tokens: ${tokens.current}/${tokens.max}`);
                
                // Check if we have tokens
                if (tokens.current < 1) {
                    logger.warn('âš ï¸ No tokens available');
                    logger.info('â³ Aguardando 1 hora para regenerar tokens...');
                    
                    // Wait 1 hour
                    await sleep(3600000);
                    
                    // Reload the page
                    logger.info('ðŸ”„ Recarregando pÃ¡gina...');
                    window.location.reload();
                    return;
                }
                
                // Start matchmaking via API
                logger.info('ðŸŽ¯ Starting matchmaking...');
                const matchResult = await context.http.startPvpMatchmaking();
                logger.debug(`[UltraFastPvP] Matchmaking result: ${matchResult.success ? 'âœ…' : 'âŒ'} - ${matchResult.error || matchResult.message}`);
                
                if (!matchResult.success) {
                    logger.warn(`âŒ Matchmaking failed: ${matchResult.error || matchResult.message}`);
                    await sleep(2000);
                    continue;
                }
                
                logger.info('âœ… Matchmaking successful, waiting for battle page to load...');
                
                // Wait for battle page to load (indicated by URL change)
                await sleep(1500);
                
                // Check if we're now on the battle page
                let currentPath = window.location.pathname.toLowerCase();
                if (currentPath.includes('pvp_battle')) {
                    logger.info('âœ¨ Battle page loaded, starting battle automation...');
                    await this.handleUltraFastBattle(context);
                    
                    // After battle ends, we should be back on lobby
                    // Repeat the loop for the next battle
                    await sleep(1000);
                } else {
                    logger.warn('âš ï¸ Matchmaking found, but page did not change. Looking for Start Matching button...');
                    
                    // Try to find and click the Start Matching button
                    let battleBtn = document.getElementById('btnStartTop');
                    
                    // Fallback: Look for button with "Start Matching" text
                    if (!battleBtn) {
                        const buttons = Array.from(document.querySelectorAll('button'));
                        battleBtn = buttons.find(btn => btn.textContent.includes('Start Matching'));
                    }
                    
                    if (battleBtn) {
                        battleBtn.click();
                        await sleep(2000);  // Wait longer for battle page to load
                        currentPath = window.location.pathname.toLowerCase();
                        if (currentPath.includes('pvp_battle')) {
                            logger.info('âœ¨ Battle page loaded after button click, starting battle automation...');
                            await this.handleUltraFastBattle(context);
                            await sleep(1000);
                        } else {
                            logger.warn('âš ï¸ Still not on battle page after button click');
                            await sleep(2000);
                        }
                    } else {
                        logger.warn('âš ï¸ Could not find Start Matching button on page');
                        await sleep(2000);
                    }
                }
            }
            
            logger.info('ðŸ Auto matchmaking loop ended');
            this.state.isRunning = false;  // Reset the running flag
        },
        
        /**
         * Get the next skill ID based on smart rotation pattern or fallback to configured skill
         */
        getNextSkill(ultraCfg) {
            if (!ultraCfg.useSmartRotation) {
                return ultraCfg.skillId ?? 0;
            }
            
            const pattern = ultraCfg.smartRotationPattern || [];
            if (pattern.length === 0) {
                return ultraCfg.skillId ?? 0;
            }
            
            const currentGroup = pattern[this.state.rotationPatternIndex];
            const skill = currentGroup.skill;
            
            // Increment counters for next call
            this.state.rotationAttackCount++;
            
            if (this.state.rotationAttackCount >= currentGroup.count) {
                // Move to next skill group
                this.state.rotationPatternIndex = (this.state.rotationPatternIndex + 1) % pattern.length;
                this.state.rotationAttackCount = 0;
            }
            
            return skill;
        },
        
        /**
         * Handle Ultra Fast Battle - Attack as fast as possible
         */
        async handleUltraFastBattle(context) {
            const { logger } = context;
            const cfg = context.config.get().pvp;
            const ultraCfg = cfg.ultraFastConfig || {};
            
            this.state.running = true;
            this.state.currentBattleStartTime = Date.now();
            
            // Reset rotation counters at start of battle
            this.state.rotationPatternIndex = 0;
            this.state.rotationAttackCount = 0;
            
            const minDelay = ultraCfg.minDelayBetweenAttacks ?? 100;
            
            const rotationMode = ultraCfg.useSmartRotation ? ' [Smart Rotation]' : '';
            logger.info(`âš”ï¸ Ultra Fast PvP Battle Started!${rotationMode}`);
            
            let attackCount = 0;
            let consecutiveErrors = 0;
            const maxConsecutiveErrors = 5;
            
            // Main attack loop - attack until battle ends
            while (this.state.running) {
                // Check if Ultra Fast Mode is still enabled
                const freshCfg = context.config.get().pvp;
                if (!freshCfg?.ultraFastMode) {
                    logger.info('â¸ï¸ Ultra Fast PvP disabled via config, stopping');
                    break;
                }
                
                // Check if we're still on battle page
                const currentPath = window.location.pathname.toLowerCase();
                if (!currentPath.includes('pvp_battle')) {
                    logger.info('ðŸ”„ No longer on battle page, battle ended');
                    break;
                }
                
                // Check DOM for battle end
                if (this.isBattleEnded()) {
                    logger.info('ðŸ Battle ended (detected via DOM)');
                    break;
                }
                
                // Get skill for this attack (either from rotation or config)
                const attackSkill = this.getNextSkill(ultraCfg);
                
                // Send attack via API
                const result = await context.http.attackPvpDirect(attackSkill);
                attackCount++;
                this.state.attacksSent++;
                
                if (result.success && result.data) {
                    consecutiveErrors = 0;
                    const data = result.data;
                    
                    // Log damage dealt/taken
                    if (data.your_damage || data.enemy_damage) {
                        logger.debug(`âš”ï¸ Hit #${attackCount}: You dealt ${data.your_damage} dmg, took ${data.enemy_damage} dmg`);
                    }
                    
                    // Check if battle ended from response
                    if (data.ended === 1) {
                        logger.info(`ðŸ Battle ended (response indicated) after ${attackCount} attacks`);
                        // Check who won
                        const myHp = data.my_hp;
                        const enemyHp = data.enemy_hp;
                        if (myHp > 0 && enemyHp <= 0) {
                            this.state.battlesWon++;
                            logger.info('ðŸ† Victory!');
                        } else if (myHp <= 0) {
                            this.state.battlesLost++;
                            logger.info('ðŸ’€ Defeat!');
                        }
                        break;
                    }
                    
                    // Check HP to detect death
                    if (data.my_hp !== undefined && data.my_hp <= 0) {
                        logger.info('ðŸ’€ You died - battle lost');
                        this.state.battlesLost++;
                        break;
                    }
                    if (data.enemy_hp !== undefined && data.enemy_hp <= 0) {
                        logger.info('ðŸ† Enemy defeated - battle won!');
                        this.state.battlesWon++;
                        break;
                    }
                    
                    // Check remaining tokens
                    if (data.attacker_tokens !== undefined) {
                        logger.debug(`ðŸ“Š Your tokens: ${data.attacker_tokens}`);
                    }
                } else {
                    consecutiveErrors++;
                    logger.warn(`âš ï¸ Attack error (${consecutiveErrors}/${maxConsecutiveErrors}): ${result.message || result.error}`);
                    
                    if (consecutiveErrors >= maxConsecutiveErrors) {
                        logger.warn('âŒ Too many consecutive errors, checking if battle ended via DOM...');
                        await sleep(500);
                        
                        if (this.isBattleEnded()) {
                            logger.info('ðŸ Battle ended (confirmed via DOM)');
                            break;
                        }
                        
                        // Reset error count and continue
                        consecutiveErrors = 0;
                    }
                }
                
                // Minimal delay between attacks
                if (minDelay > 0) {
                    await sleep(minDelay);
                }
            }
            
            // Battle finished
            this.state.battlesCompleted++;
            this.state.running = false;
            
            const battleDuration = Date.now() - this.state.currentBattleStartTime;
            logger.info(`âœ… Battle #${this.state.battlesCompleted} completed in ${(battleDuration / 1000).toFixed(1)}s (${attackCount} attacks)`);
            
            // Show stats every 5 battles
            if (this.state.battlesCompleted % 5 === 0) {
                this.showStats(context);
            }
            
            // Wait for page to redirect back to lobby
            logger.info('â³ Waiting for return to lobby...');
            await sleep(2000);
            
            // Try to click the return link if modal is showing
            const returnLink = document.querySelector('a[href*="pvp.php" i]');
            if (returnLink) {
                logger.info('â†©ï¸ Clicking return to lobby link...');
                returnLink.click();
                await sleep(1000);
            }
            
            // Note: isRunning will be reset by runAutoMatchmakingLoop when it continues
        },
        
        /**
         * Check PvP tokens from page
         */
        getPvpTokens() {
            // Look for token display in the info box: "âš”ï¸ 30 /30"
            const tokenElements = Array.from(document.querySelectorAll('*')).filter(el => {
                return el.textContent.match(/âš”ï¸\s*(\d+)\s*\/\s*(\d+)/);
            });
            
            for (const el of tokenElements) {
                const match = el.textContent.match(/âš”ï¸\s*(\d+)\s*\/\s*(\d+)/);
                if (match) {
                    return { 
                        current: parseInt(match[1], 10), 
                        max: parseInt(match[2], 10) 
                    };
                }
            }
            
            // Fallback: search for generic number pattern
            const allText = document.body.innerText;
            const lobbyMatch = allText.match(/PvP Tokens[^]*?(\d+)\s*\/\s*(\d+)/i);
            if (lobbyMatch) {
                return { 
                    current: parseInt(lobbyMatch[1], 10), 
                    max: parseInt(lobbyMatch[2], 10) 
                };
            }
            
            return null;
        },
        
        /**
         * Check if battle ended via DOM
         */
        isBattleEnded() {
            const endModal = document.querySelector('#endModal');
            if (endModal) {
                const style = window.getComputedStyle(endModal);
                if (style.display !== 'none') {
                    return true;
                }
            }
            
            // Check for result text indicators
            const bodyText = document.body.innerText || '';
            if (bodyText.includes('Victory') || bodyText.includes('Defeat')) {
                return true;
            }
            
            return false;
        },
        
        /**
         * Show session statistics
         */
        showStats(context) {
            const { logger } = context;
            const duration = this.state.sessionStartTime ? 
                (Date.now() - this.state.sessionStartTime) / 1000 : 0;
            
            const winRate = this.state.battlesCompleted > 0 ?
                ((this.state.battlesWon / this.state.battlesCompleted) * 100).toFixed(1) : 0;
            
            logger.info(`ðŸ“Š Ultra Fast PvP Stats:
  â”œâ”€ Battles: ${this.state.battlesCompleted} (${this.state.battlesWon}W/${this.state.battlesLost}L) - ${winRate}% win rate
  â”œâ”€ Total Attacks: ${this.state.attacksSent}
  â””â”€ Session Duration: ${(duration / 60).toFixed(1)} minutes`);
            
            // Show notification
            context.notifications.info(`ðŸŸï¸ PvP: ${this.state.battlesCompleted} battles (${winRate}% win)`);
        }
    };

    const attackUnlockerModule = {
        id: 'attackUnlocker',
        match: ({ location }) => {
            const path = location.pathname;
            // Active on any battle page (battle.php, pvp_battle.php, dungeon pages, etc)
            return /battle/i.test(path) || /dungeon/i.test(path) || /boss/i.test(path);
        },
        init(context) {
            this.state = {
                injected: false,
                intervalId: null
            };
            context.logger.debug('attackUnlocker module initialised');
        },
        activate(context) {
            // Check if feature is enabled
            const cfg = context.config.get();
            if (cfg.core?.unlockAttackButtons === false) {
                context.logger.debug('Attack unlocker desabilitado via configuraÃ§Ã£o');
                this.cleanup();
                return;
            }

            if (this.state.injected) return;

            // context.logger.info('ðŸ”“ Ativando desbloqueio permanente de botÃµes de ataque...');

            // Strategy 1: Neutralize the lockAttackButtons function
            this.injectGlobalBypass(context);

            // Strategy 2: Continuously unlock buttons via interval
            this.startButtonUnlocker(context);

            // Strategy 3: Intercept clicks to force unlock just-in-time
            this.interceptClicks(context);

            this.state.injected = true;
            context.logger.info('âœ… Desbloqueio de ataques ativo! VocÃª pode atacar sem delay de 1s.');
        },
        cleanup() {
            if (this.state.intervalId) {
                clearInterval(this.state.intervalId);
                this.state.intervalId = null;
            }
            this.state.injected = false;
        },
        injectGlobalBypass(context) {
            try {
                const script = document.createElement('script');
                script.textContent = `
                    (function() {
                        // Backup original function if needed for debugging
                        window._originalLockAttackButtons = window.lockAttackButtons;

                        // Override lockAttackButtons with no-op
                        // window.lockAttackButtons = function(lock) {
                        //     console.log('[AutoDS] ðŸ”“ Attack lock bypassed (lockAttackButtons neutralized)');
                        //     // Do nothing - attacks remain unlocked
                        // };

                        // Also intercept any setTimeout/setInterval that might re-enable locks
                        const originalSetTimeout = window.setTimeout;
                        window.setTimeout = function(fn, delay, ...args) {
                            // If it's trying to unlock buttons after 1000ms, do it immediately
                            if (delay === 1000 && typeof fn === 'function') {
                                const fnStr = fn.toString();
                                if (fnStr.includes('disabled') || fnStr.includes('lockAttack')) {
                                    // console.log('[AutoDS] ðŸ”“ Intercepted delayed unlock, executing immediately');
                                    delay = 0; // Execute immediately
                                }
                            }
                            return originalSetTimeout.call(window, fn, delay, ...args);
                        };

                        console.log('[AutoDS] âœ… Global attack bypass injected');
                    })();
                `;
                document.documentElement.appendChild(script);
                script.remove();

                context.logger.info('âœ… Bypass global de lockAttackButtons injetado');
            } catch (error) {
                context.logger.warn('Falha ao injetar bypass global', error);
            }
        },
        startButtonUnlocker(context) {
            // Clear any existing interval
            if (this.state.intervalId) {
                clearInterval(this.state.intervalId);
            }

            // Continuously unlock all attack buttons every 50ms
            this.state.intervalId = setInterval(() => {
                const buttons = document.querySelectorAll('.attack-btn[disabled], button.attack-btn[disabled], button[data-skill-id][disabled]');
                if (buttons.length > 0) {
                    buttons.forEach(btn => {
                        btn.removeAttribute('disabled');
                        btn.disabled = false;
                        btn.classList.remove('disabled', 'btn-disabled', 'attack-disabled');
                    });
                    // Only log when we actually unlock something
                    // context.logger.debug(`ðŸ”“ Desbloqueados ${buttons.length} botÃµes de ataque`);
                }
            }, 50); // Check every 50ms for fast response

            // Cleanup on page unload
            window.addEventListener('beforeunload', () => {
                if (this.state.intervalId) {
                    clearInterval(this.state.intervalId);
                }
            }, { once: true });

            context.logger.info('âœ… Intervalo de desbloqueio automÃ¡tico iniciado (50ms)');
        },
        interceptClicks(context) {
            // Add click listener to all attack buttons (current and future)
            document.addEventListener('click', (event) => {
                const target = event.target;

                // Check if it's an attack button
                if (target &&
                    (target.classList.contains('attack-btn') ||
                     target.dataset?.skillId !== undefined ||
                     target.getAttribute?.('data-skill-id') !== null)) {

                    // Force unlock just before click processes
                    target.removeAttribute('disabled');
                    target.disabled = false;
                    target.classList.remove('disabled', 'btn-disabled', 'attack-disabled');

                    // context.logger.debug('ðŸ”“ BotÃ£o de ataque desbloqueado via interceptor de clique');
                }
            }, true); // Use capture phase to intercept before other handlers

            context.logger.info('âœ… Interceptor de cliques instalado');
        }
    };

    // DEPRECATED: autoJoinBattleModule removed in v0.1.29-alpha
    // Functionality replaced by directJoinButtonsModule which injects explicit "âš¡ Join Now" buttons
    // instead of intercepting native button clicks (better UX, no conflicts)

    /**
     * Module to inject "Join Now" and "Fight Now" buttons
     * Always active on wave and dungeon pages
     */
    const directJoinButtonsModule = {
        id: 'directJoinButtons',
        match: ({ location }) => {
            const path = location.pathname;
            return /active_wave\.php/i.test(path) || /guild_dungeon_location\.php/i.test(path);
        },
        init() {
            this.state = {
                buttonsInjected: false
            };
        },
        activate(context) {
            if (!this.state) this.init();
            
            // Always inject buttons, regardless of automation being enabled
            this.injectButtons(context);
        },
        injectButtons(context) {
            const { logger, dom, location } = context;
            
            // Wait for DOM to be fully loaded
            setTimeout(() => {
                const isWavePage = /active_wave\.php/i.test(location.pathname);
                const isDungeonPage = /guild_dungeon_location\.php/i.test(location.pathname);
                
                // Updated selectors: include .mon and .wave-monster
                const cards = dom.queryAll('.monster-card, .dungeon-monster-card, .mon, .wave-monster');
                
                if (!cards.length) {
                    // logger.debug('[DirectJoinButtons] No monster cards found on page');
                    return;
                }

                // logger.debug(`[DirectJoinButtons] Found ${cards.length} monster cards`);
                let buttonsAdded = 0;

                cards.forEach((card, index) => {
                    // Find the Join/Fight button - try multiple selectors
                    let actionButton = card.querySelector('button.join-btn');
                    
                    if (!actionButton) {
                        actionButton = card.querySelector('button.fight-btn');
                    }
                    
                    if (!actionButton) {
                        actionButton = card.querySelector('button.btn-join');
                    }
                    
                    if (!actionButton) {
                        actionButton = card.querySelector('#join-battle');
                    }
                    
                    // NEW: Try to find <a> with "Fight" or "Join" text
                    if (!actionButton) {
                        const links = card.querySelectorAll('a.btn');
                        for (const link of links) {
                            if (/join|fight/i.test(link.textContent || '')) {
                                actionButton = link;
                                break;
                            }
                        }
                    }
                    
                    if (!actionButton) {
                        // Fallback: find any button with "join" or "fight" text
                        const buttons = card.querySelectorAll('button');
                        for (const btn of buttons) {
                            if (/join|fight/i.test(btn.textContent || '')) {
                                actionButton = btn;
                                break;
                            }
                        }
                    }
                    
                    if (!actionButton) {
                        // logger.debug(`[DirectJoinButtons] Card ${index}: No action button found`);
                        return;
                    }
                    
                    // Only add to "Join"/"Fight" buttons, not "Continue" buttons
                    const buttonText = actionButton.textContent || '';
                    if (/continue/i.test(buttonText)) {
                        // logger.debug(`[DirectJoinButtons] Card ${index}: Skipping "Continue" button`);
                        return;
                    }
                    
                    // Extract monster ID from link or button
                    let monsterId = null;
                    let instanceId = null; // For guild dungeons
                    
                    // Try to get from nearby link first (dungeon_battle.php or battle.php)
                    const battleLink = card.querySelector('a[href*="battle.php?"], a[href*="battle.php&"], a[href*="dungeon_battle.php?"], a[href*="dungeon_battle.php&"]');
                    if (battleLink) {
                        const href = battleLink.getAttribute('href') || '';
                        // For dungeon: extract dgmid instead of id
                        const dgmidMatch = href.match(/[?&]dgmid=(\d+)/);
                        if (dgmidMatch) {
                            monsterId = dgmidMatch[1];
                            // Also extract instance_id for guild dungeons
                            const instanceMatch = href.match(/[?&]instance_id=(\d+)/);
                            if (instanceMatch) {
                                instanceId = instanceMatch[1];
                            }
                        } else {
                            const monsterIdMatch = href.match(/[?&]id=(\d+)/);
                            if (monsterIdMatch) {
                                monsterId = monsterIdMatch[1];
                            }
                        }
                    }
                    
                    // Try to get from button's href if it's an <a> tag
                    if (!monsterId && actionButton.tagName === 'A') {
                        const href = actionButton.getAttribute('href') || '';
                        const dgmidMatch = href.match(/[?&]dgmid=(\d+)/);
                        if (dgmidMatch) {
                            monsterId = dgmidMatch[1];
                        } else {
                            const monsterIdMatch = href.match(/[?&]id=(\d+)/);
                            if (monsterIdMatch) {
                                monsterId = monsterIdMatch[1];
                            }
                        }
                    }
                    
                    // Try to get from button's parent anchor
                    if (!monsterId && actionButton.parentElement?.tagName === 'A') {
                        const href = actionButton.parentElement.href;
                        const dgmidMatch = href?.match(/[?&]dgmid=(\d+)/);
                        if (dgmidMatch) {
                            monsterId = dgmidMatch[1];
                        } else {
                            const monsterIdMatch = href?.match(/[?&]id=(\d+)/);
                            if (monsterIdMatch) {
                                monsterId = monsterIdMatch[1];
                            }
                        }
                    }
                    
                    // Try to get from button onclick
                    if (!monsterId) {
                        const onclick = actionButton.getAttribute('onclick') || '';
                        const onclickMatch = onclick.match(/id[=:](\d+)/i);
                        if (onclickMatch) {
                            monsterId = onclickMatch[1];
                        }
                    }
                    
                    if (!monsterId) {
                        logger.debug(`[DirectJoinButtons] Card ${index}: No monster ID found`);
                        return;
                    }
                    
                    // Determine button label based on page type
                    const buttonLabel = isWavePage ? 'Join Now' : 'Fight Now';
                    
                    // Add direct join button (pass instanceId for guild dungeons)
                    // logger.debug(`[DirectJoinButtons] Card ${index}: Adding "${buttonLabel}" for monster ${monsterId}${instanceId ? ` (instance ${instanceId})` : ''}`);
                    addDirectJoinButton(actionButton, monsterId, buttonLabel, context, instanceId);
                    buttonsAdded++;
                });

                logger.info(`[DirectJoinButtons] âœ… Added ${buttonsAdded} direct join buttons to ${cards.length} cards`);
                this.state.buttonsInjected = true;
            }, 1000); // Wait 1 second for DOM to stabilize
        },
        cleanup() {
            this.state.buttonsInjected = false;
        }
    };

    /**
     * Collections Organizer Module
     * Automatically reorganizes the collections page to show claimed collections at the end
     */
    const collectionsOrganizerModule = {
        id: 'collectionsOrganizer',
        match: ({ location }) => /collections\.php/i.test(location.pathname),
        
        init(context) {
            // context.logger.debug('[CollectionsOrganizer] Module initialized');
        },
        
        activate(context) {
            context.logger.info('[CollectionsOrganizer] Activating on collections page');
            
            // Wait for page to load, then reorganize
            const reorganize = () => {
                try {
                    this.reorganizeCollections(context);
                } catch (error) {
                    context.logger.error('[CollectionsOrganizer] Failed to reorganize:', { error });
                }
            };
            
            // Try immediately
            if (document.readyState === 'complete') {
                reorganize();
            } else {
                window.addEventListener('load', reorganize);
            }
            
            // Also observe DOM changes in case content loads dynamically
            const observer = new MutationObserver(() => {
                const grid = document.querySelector('.grid');
                if (grid && grid.children.length > 0) {
                    observer.disconnect();
                    reorganize();
                }
            });
            
            observer.observe(document.body, { childList: true, subtree: true });
            
            // Store for cleanup
            this.observer = observer;
        },
        
        reorganizeCollections(context) {
            const grid = context.dom.query('.grid');
            
            if (!grid) {
                context.logger.warn('[CollectionsOrganizer] Grid container not found');
                return;
            }
            
            const cards = context.dom.queryAll('.card', grid);
            
            if (cards.length === 0) {
                context.logger.warn('[CollectionsOrganizer] No collection cards found');
                return;
            }
            
            context.logger.debug(`[CollectionsOrganizer] Found ${cards.length} collection cards`);
            
            // Extract completion percentage from each card
            const cardsWithData = cards.map(card => {
                const button = context.dom.query('button', card);
                const isClaimed = button && button.textContent.includes('Claimed');
                
                // Find percentage text (e.g., "35%", "100%")
                let percentage = 0;
                const percentText = card.textContent.match(/(\d+)%/);
                if (percentText) {
                    percentage = parseInt(percentText[1], 10);
                }
                
                // Get title for logging
                const titleEl = context.dom.query('.title', card);
                const title = titleEl ? titleEl.textContent.trim() : 'Unknown';
                
                return {
                    card,
                    isClaimed,
                    percentage,
                    title
                };
            });
            
            // Separate claimed and unclaimed collections
            const claimed = cardsWithData.filter(item => item.isClaimed);
            const unclaimed = cardsWithData.filter(item => !item.isClaimed);
            
            // Sort unclaimed by percentage (highest to lowest)
            unclaimed.sort((a, b) => b.percentage - a.percentage);
            
            // Sort claimed by percentage (highest to lowest) - optional, but keeps consistency
            claimed.sort((a, b) => b.percentage - a.percentage);
            
            context.logger.info(`[CollectionsOrganizer] Found ${claimed.length} claimed and ${unclaimed.length} unclaimed collections`);
            
            if (unclaimed.length > 0) {
                context.logger.debug('[CollectionsOrganizer] Unclaimed sorted by %:', 
                    unclaimed.map(item => `${item.title}: ${item.percentage}%`).join(', '));
            }
            
            // Add visual indicator to claimed collections
            claimed.forEach(item => {
                const card = item.card;
                if (!card.classList.contains('autods-claimed')) {
                    card.classList.add('autods-claimed');
                    card.style.opacity = '0.7';
                    card.style.order = '999';
                }
            });
            
            // Reorder: unclaimed first (sorted by %), then claimed (sorted by %)
            const fragment = document.createDocumentFragment();
            
            // Add unclaimed collections first (highest % first)
            unclaimed.forEach(item => {
                fragment.appendChild(item.card);
            });
            
            // Add claimed collections at the end (highest % first)
            claimed.forEach(item => {
                fragment.appendChild(item.card);
            });
            
            // Clear grid and append reorganized cards
            grid.innerHTML = '';
            grid.appendChild(fragment);
            
            context.logger.info('[CollectionsOrganizer] âœ“ Collections reorganized by completion %');
            
            // Show notification
            context.notifications.success(`ðŸ“š Collections organized: sorted by completion (${claimed.length} claimed at bottom)`);
            
            // Add custom styles for better visual separation
            this.injectStyles(context);
        },
        
        injectStyles(context) {
            if (document.getElementById('autods-collections-styles')) {
                return; // Already injected
            }
            
            const style = document.createElement('style');
            style.id = 'autods-collections-styles';
            style.textContent = `
                /* Collections Organizer Styles */
                .autods-claimed {
                    position: relative;
                }
                
                .autods-claimed::before {
                    content: 'âœ“ CLAIMED';
                    position: absolute;
                    top: 8px;
                    right: 8px;
                    background: linear-gradient(135deg, rgba(166, 227, 161, 0.9), rgba(148, 226, 213, 0.9));
                    color: #1e1e2e;
                    padding: 4px 12px;
                    border-radius: 12px;
                    font-size: 10px;
                    font-weight: 700;
                    letter-spacing: 0.5px;
                    z-index: 10;
                    box-shadow: 0 2px 8px rgba(166, 227, 161, 0.4);
                    text-transform: uppercase;
                }
                
                .autods-claimed {
                    opacity: 0.7 !important;
                    transition: opacity 0.3s ease, transform 0.3s ease;
                }
                
                .autods-claimed:hover {
                    opacity: 1 !important;
                    transform: translateY(-2px);
                }
                
                /* Add separator before claimed section */
                .grid .autods-claimed:first-of-type {
                    margin-top: 32px;
                    padding-top: 32px;
                    border-top: 2px dashed rgba(137, 180, 250, 0.3);
                }
                
                /* Add label before first claimed item */
                .grid .autods-claimed:first-of-type::after {
                    content: 'Claimed Collections';
                    position: absolute;
                    top: -28px;
                    left: 0;
                    font-size: 14px;
                    font-weight: 600;
                    color: rgba(166, 227, 161, 0.9);
                    text-transform: uppercase;
                    letter-spacing: 1px;
                }
            `;
            
            document.head.appendChild(style);
            context.logger.debug('[CollectionsOrganizer] Styles injected');
        },
        
        cleanup() {
            if (this.observer) {
                this.observer.disconnect();
            }
            
            // Remove custom styles
            const styleEl = document.getElementById('autods-collections-styles');
            if (styleEl) {
                styleEl.remove();
            }
            
            // Remove custom classes
            document.querySelectorAll('.autods-claimed').forEach(el => {
                el.classList.remove('autods-claimed');
                el.style.opacity = '';
                el.style.order = '';
            });
        }
    };

    const imageBlockModule = {
        id: 'imageBlocker',
        match: () => true,
        init(context) {
            context.logger.debug('imageBlocker module initialised');
            if (context.config.get().imageBlocker.enabled) {
                this.enable(context);
            }
            // Remove background pattern from wave pages
            this.removeWaveBackground(context);
            // Hide gate-info divs on all pages
            this.hideGateInfo(context);
        },
        activate(context) {
            const enabled = context.config.get().imageBlocker.enabled;
            if (!enabled) {
                this.disable(context);
                return;
            }
            if (!this.shouldBlockCurrentPath(context)) {
                this.disable(context);
                context.logger.debug('Image blocking bypassed on guild route.');
                return;
            }
            this.enable(context);
            // Remove background pattern from wave pages
            this.removeWaveBackground(context);
            // Hide gate-info divs on all pages
            this.hideGateInfo(context);
        },
        enable(context) {
            if (this.styleEl) return;
            if (!this.shouldBlockCurrentPath(context)) return;
            context.logger.info('Enabling image blocking');
            const style = document.createElement('style');
            style.id = 'autods-image-blocker';
            style.textContent = 'img { display: none !important; }';
            (document.head || document.documentElement).appendChild(style);
            this.styleEl = style;
        },
        disable(context) {
            if (!this.styleEl) return;
            context.logger.info('Disabling image blocking');
            this.styleEl.remove();
            this.styleEl = null;
        },
        removeWaveBackground(context) {
            const pathname = context.location?.pathname || window.location?.pathname || '';
            
            // Only apply to active_wave.php
            // if (!/active_wave\.php/i.test(pathname)) return;
            
            // Check if style already exists
            if (document.getElementById('autods-wave-bg-remover')) return;
            
            context.logger.info('Removing wave page background pattern');
            
            const style = document.createElement('style');
            style.id = 'autods-wave-bg-remover';
            style.textContent = `
                body {
                    background-image: none !important;
                    background-color: rgb(28, 29, 33) !important;
                }
            `;
            (document.head || document.documentElement).appendChild(style);
        },
        hideGateInfo(context) {
            // Check if style already exists
            if (document.getElementById('autods-gate-info-hider')) return;
            
            context.logger.info('Hiding gate-info divs');
            
            const style = document.createElement('style');
            style.id = 'autods-gate-info-hider';
            style.textContent = `
                div.gate-info {
                    display: none !important;
                }
            `;
            (document.head || document.documentElement).appendChild(style);
        },
        shouldBlockCurrentPath(context) {
            const pathname = context.location?.pathname || window.location?.pathname || '';
            // Bloquear imagens em todas as pÃ¡ginas exceto guild e dungeon_info
            if (/^\/guild/i.test(pathname)) return false;
            if (/dungeon_info\.php/i.test(pathname)) return false;
            return true;
        }
    };

    const dungeonLootHelperModule = {
        id: 'dungeonLootHelper',
        match: ({ location }) => {
            const path = location.pathname;
            return /guild_dungeon_location\.php/i.test(path);
        },
        init(context) {
            this.state = {
                injected: false
            };
            context.logger.debug('dungeonLootHelper module initialised');
        },
        activate(context) {
            if (this.state.injected) return;

            context.logger.info('ðŸŽ Adicionando botÃµes de loot rÃ¡pido nas dungeon locations...');

            // Add custom styles for loot buttons
            this.injectStyles();

            // Wait for monsters to load
            setTimeout(() => {
                this.injectLootButtons(context);
                this.state.injected = true;
                
                // Add "Loot All" button after individual buttons are injected
                setTimeout(() => {
                    addGuildDungeonLootAllButton();
                }, 500);
            }, 500);
        },
        injectStyles() {
            if (document.getElementById('autods-loot-btn-styles')) return;

            const style = document.createElement('style');
            style.id = 'autods-loot-btn-styles';
            style.textContent = `
                .autods-loot-btn {
                    background: linear-gradient(135deg, #10b981, #059669) !important;
                    border: 2px solid #34d399 !important;
                    color: white !important;
                    padding: 6px 12px !important;
                    font-weight: 600 !important;
                    transition: all 0.2s ease !important;
                    cursor: pointer !important;
                    box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3) !important;
                }
                .autods-loot-btn:hover:not(:disabled) {
                    background: linear-gradient(135deg, #059669, #047857) !important;
                    border-color: #10b981 !important;
                    transform: translateY(-2px) !important;
                    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.5) !important;
                }
                .autods-loot-btn:active:not(:disabled) {
                    transform: translateY(0) !important;
                    box-shadow: 0 1px 4px rgba(16, 185, 129, 0.3) !important;
                }
                .autods-loot-btn:disabled {
                    opacity: 0.6 !important;
                    cursor: not-allowed !important;
                }
            `;
            document.head.appendChild(style);
        },
        injectLootButtons(context) {
            // Find all monster cards with "not looted" status
            const monsterCards = document.querySelectorAll('.mon.dead');

            let injectedCount = 0;

            monsterCards.forEach(card => {
                // Check if has "not looted" pill
                const notLootedPill = Array.from(card.querySelectorAll('.pill')).find(pill =>
                    /not looted/i.test(pill.textContent)
                );

                if (!notLootedPill) return; // Skip if already looted or not eligible

                // Find the View button (support both dungeon_battle.php and battle.php with dgmid)
                const viewButton = card.querySelector('a.btn[href*="battle.php"][href*="dgmid"], a.btn[href*="dungeon_battle.php"]');
                if (!viewButton) return;

                // Extract dgmid and instance_id from View button href
                const href = viewButton.getAttribute('href');
                const dgmidMatch = href.match(/dgmid=(\d+)/);
                const instanceMatch = href.match(/instance_id=(\d+)/);

                if (!dgmidMatch || !instanceMatch) return;

                const dgmid = dgmidMatch[1];
                const instanceId = instanceMatch[1];

                // Check if loot button already exists
                if (card.querySelector('.autods-loot-btn')) return;

                // Extract monster name from card
                const monsterNameEl = card.querySelector('strong, .h, [style*="font-weight:700"]');
                const monsterName = monsterNameEl?.textContent?.trim() || `Monster ${dgmid}`;
                
                // Create loot button
                const lootBtn = document.createElement('button');
                lootBtn.className = 'btn autods-loot-btn';
                lootBtn.style.marginLeft = '8px';
                lootBtn.innerHTML = 'ðŸŽ Loot';
                lootBtn.dataset.dgmid = dgmid;
                lootBtn.dataset.instanceId = instanceId;
                lootBtn.dataset.monsterName = monsterName;

                // Add click handler
                lootBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    await this.handleLootClick(context, lootBtn, dgmid, instanceId, monsterName, notLootedPill);
                });

                // Insert button next to View button
                viewButton.parentElement.appendChild(lootBtn);
                injectedCount++;
            });

            if (injectedCount > 0) {
                context.logger.info(`âœ… ${injectedCount} botÃµes de loot adicionados`);
            } else {
                context.logger.debug('Nenhum monstro elegÃ­vel para loot encontrado');
            }
        },
        async handleLootClick(context, button, dgmid, instanceId, monsterName, notLootedPill) {
            const originalText = button.innerHTML;
            const originalDisabled = button.disabled;

            try {
                button.disabled = true;
                button.innerHTML = 'â³ Lootando...';

                context.logger.debug(`Claiming loot for monster ${dgmid} (${monsterName})`);

                // Use unified loot service
                const result = await context.loot.lootDungeonMonster(dgmid, instanceId, context.userSession.getUserId(), monsterName);

                if (!result.success) {
                    const msg = result.message || 'Failed to loot';
                    this.showNotification(msg, 'error');
                    
                    if (/cloudflare/i.test(msg)) {
                        context.notifications.error('âŒ Bloqueio Cloudflare: O loot automÃ¡tico foi bloqueado. Por favor, faÃ§a o loot manualmente.', 10000);
                        context.notifications.error('âŒ Bloqueio Cloudflare: FaÃ§a o loot manualmente clicando no botÃ£o "Loot" do monstro.', 10000);
                    }
                    
                    button.disabled = originalDisabled;
                    button.innerHTML = originalText;
                    return;
                }

                // Success!
                this.showNotification(`Loot claimed! +${result.exp} XP, +${result.gold} Gold`, 'success');
                context.logger.info(`âœ… Loot claimed for ${monsterName}: +${result.exp} XP, +${result.gold} Gold, ${result.items.length} items`);

                // Update UI: change pill from "not looted" to "looted"
                notLootedPill.className = 'pill';
                notLootedPill.textContent = 'looted';
                notLootedPill.removeAttribute('title');

                // Remove the loot button
                button.remove();

                // Show custom loot popup with rewards
                this.showLootPopup({
                    status: 'success',
                    message: result.message,
                    rewards: {
                        exp: result.exp,
                        gold: result.gold,
                        damage_dealt: result.damage || 0
                    },
                    items: result.items
                });
            } catch (error) {
                context.logger.error('Error claiming loot', error);
                this.showNotification(error?.message || 'Server error', 'error');
                button.disabled = originalDisabled;
                button.innerHTML = originalText;
            }
        },
        showLootPopup(data) {
            const rewards = data.rewards || {};
            const exp = rewards.exp || 0;
            const gold = rewards.gold || 0;
            const items = Array.isArray(data.items) ? data.items : [];

            // Create popup container
            const popup = document.createElement('div');
            popup.className = 'autods-loot-popup';
            popup.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0.8);
                background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                border: 2px solid #10b981;
                border-radius: 16px;
                padding: 24px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 40px rgba(16, 185, 129, 0.3);
                z-index: 999999;
                min-width: 320px;
                max-width: 500px;
                opacity: 0;
                animation: lootPopupIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            `;

            // Build popup content
            let html = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 48px; margin-bottom: 8px;">ðŸŽ</div>
                    <h3 style="margin: 0; color: #10b981; font-size: 20px; font-weight: 700;">Loot Collected!</h3>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 20px;">
                    <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 12px; text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 4px;">â­</div>
                        <div style="font-size: 18px; font-weight: 700; color: #60a5fa;">${context.numbers.format(exp)}</div>
                        <div style="font-size: 11px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">EXP</div>
                    </div>
                    <div style="background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px; padding: 12px; text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 4px;">ðŸ’°</div>
                        <div style="font-size: 18px; font-weight: 700; color: #fbbf24;">${context.numbers.format(gold)}</div>
                        <div style="font-size: 11px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Gold</div>
                    </div>
                </div>
            `;

            if (items.length > 0) {
                html += `
                    <div style="margin-top: 16px;">
                        <div style="font-size: 12px; font-weight: 600; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.8px; margin-bottom: 12px; text-align: center;">
                            ðŸ“¦ Items (${items.length})
                        </div>
                        <div style="display: grid; gap: 8px; max-height: 200px; overflow-y: auto;">
                `;

                items.forEach(item => {
                    const itemName = item.NAME || 'Unknown Item';
                    const tier = item.TIER ? String(item.TIER).toLowerCase() : 'common';
                    const tierColors = {
                        legendary: '#f59e0b',
                        epic: '#a855f7',
                        rare: '#3b82f6',
                        uncommon: '#10b981',
                        common: '#6b7280'
                    };
                    const tierColor = tierColors[tier] || tierColors.common;

                    html += `
                        <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-left: 3px solid ${tierColor}; border-radius: 6px; padding: 8px 12px; display: flex; align-items: center; gap: 10px;">
                            <div style="font-size: 20px;">ðŸ“œ</div>
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-size: 13px; font-weight: 600; color: #e2e8f0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${this.escapeHtml(itemName)}</div>
                                ${item.TIER ? `<div style="font-size: 10px; color: ${tierColor}; text-transform: uppercase; font-weight: 600; letter-spacing: 0.5px;">${this.escapeHtml(item.TIER)}</div>` : ''}
                            </div>
                            ${item.DROP_RATIO != null ? `<div style="font-size: 10px; color: #94a3b8; white-space: nowrap;">${item.DROP_RATIO}%</div>` : ''}
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            } else {
                html += `
                    <div style="text-align: center; padding: 16px; color: #64748b; font-size: 13px;">
                        No items dropped this time
                    </div>
                `;
            }

            html += `
                <div style="margin-top: 20px; text-align: center;">
                    <button class="autods-loot-popup-close" style="
                        background: linear-gradient(135deg, #10b981, #059669);
                        border: none;
                        color: white;
                        padding: 10px 24px;
                        border-radius: 8px;
                        font-weight: 600;
                        cursor: pointer;
                        font-size: 13px;
                        transition: all 0.2s ease;
                        box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
                    ">
                        âœ¨ Awesome!
                    </button>
                </div>
            `;

            popup.innerHTML = html;

            // Add animation styles
            if (!document.getElementById('autods-loot-popup-styles')) {
                const style = document.createElement('style');
                style.id = 'autods-loot-popup-styles';
                style.textContent = `
                    @keyframes lootPopupIn {
                        to {
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1);
                        }
                    }
                    @keyframes lootPopupOut {
                        to {
                            opacity: 0;
                            transform: translate(-50%, -50%) scale(0.8);
                        }
                    }
                    .autods-loot-popup-close:hover {
                        background: linear-gradient(135deg, #059669, #047857) !important;
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.5) !important;
                    }
                    .autods-loot-popup-close:active {
                        transform: translateY(0);
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(popup);

            // Close button handler
            const closeBtn = popup.querySelector('.autods-loot-popup-close');
            const closePopup = () => {
                popup.style.animation = 'lootPopupOut 0.2s ease-out forwards';
                setTimeout(() => popup.remove(), 200);
            };

            closeBtn.addEventListener('click', closePopup);

            // Auto-close after 5 seconds if no items, 8 seconds if has items
            const autoCloseDelay = items.length > 0 ? 8000 : 5000;
            setTimeout(closePopup, autoCloseDelay);

            // Close on Escape key
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closePopup();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        },
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },
        showNotification(message, type = 'info') {
            // Try to use page's showNotification if available
            if (typeof window.showNotification === 'function') {
                window.showNotification(message, type);
            } else {
                // Fallback to console
                console.log(`[Dungeon Loot] ${type.toUpperCase()}: ${message}`);
            }
        },
        formatNumber(value) {
            try {
                return new Intl.NumberFormat().format(Number(value) || 0);
            } catch {
                return value;
            }
        }
    };

    function normaliseHref(href, origin = window.location?.origin || 'https://demonicscans.org') {
        if (!href) return '/';
        try {
            const url = new URL(href, origin);
            return url.pathname || '/';
        } catch (error) {
            if (href.startsWith('/')) return href;
            return `/${href}`;
        }
    }

    function prettifyLabel(pathname) {
        if (!pathname || pathname === '/') return 'InÃ­cio';
        const base = pathname.split('?')[0].split('#')[0];
        const parts = base.split('/').filter(Boolean);
        if (!parts.length) return 'InÃ­cio';
        const last = parts[parts.length - 1];
        const cleaned = last.replace(/\.[^/.]+$/, '').replace(/[_-]+/g, ' ').trim();
        if (!cleaned) return pathname;
        return cleaned.replace(/\b\w/g, char => char.toUpperCase());
    }

    const floatingHelpersModule = {
        id: 'floatingHelpers',
        match: () => true,
        init(context) {
            this.state = {
                container: null,
                expPotionTimer: null,
                expPotionEndTime: null,
                inventoryData: null,
                damageCalculatorVisible: false
            };
            this.POTION_STORAGE_KEY = 'autods_exp_potion_timer';
        },
        activate(context) {
            const cfg = context.config.get();
            console.log('[FloatingHelpers] Activate called. Config:', cfg.floatingHelpers);

            if (!cfg.floatingHelpers || !cfg.floatingHelpers.enabled) {
                console.log('[FloatingHelpers] Module disabled in config');
                return;
            }

            console.log('[FloatingHelpers] Creating container...');
            this.createFloatingContainer(context, cfg);
            this.restoreExpPotionTimer(context);
            
            // Register event listeners for Ultra Fast stats
            context.events.on('autods:ultraFastAttack:complete', (data) => {
                console.log('[FloatingHelpers] Ultra Fast Attack complete event received:', data);
                if (data.stats) {
                    this.updateUltraFastStats(context, { ...data.stats, endTime: Date.now() }, 'attack');
                }
            });

            context.events.on('autods:ultraFastLoot:complete', (data) => {
                console.log('[FloatingHelpers] Ultra Fast Loot complete event received:', data);
                if (data.stats) {
                    this.updateUltraFastStats(context, data.stats, 'loot');
                }
            });
            
            // ðŸ†• Listen for config changes to update loot button appearance
            context.events.on('config:change', () => {
                const newCfg = context.config.get();
                if (newCfg.floatingHelpers?.enabled && this.state.container) {
                    // Recreate loot box if Ultra Fast Loot toggle changed
                    this.recreateLootBox(context);
                    
                    // ðŸ†• Recreate farm box if Ultra Fast Farm toggle changed
                    this.recreateFarmBox(context);
                }
            });
            
            // ðŸ†• Listen for autods:config:updated to handle panel config changes
            context.events.on('autods:config:updated', () => {
                const newCfg = context.config.get();
                if (newCfg.floatingHelpers?.enabled && this.state.container) {
                    // Recreate farm box when enabled/disabled from panel
                    this.recreateFarmBox(context);
                }
            });
            
            console.log('[FloatingHelpers] Activation complete');
        },
        createFloatingContainer(context, cfg) {
            console.log('[FloatingHelpers] createFloatingContainer called');
            const existing = document.getElementById('autods-floating-helpers');
            if (existing) {
                console.log('[FloatingHelpers] Removing existing container');
                existing.remove();
            }

            const container = document.createElement('div');
            container.id = 'autods-floating-helpers';
            container.setAttribute('data-position', cfg.floatingHelpers.position);
            container.setAttribute('data-minimized', '0'); // Estado inicial: expandido

            // Base inline styles (position handled by CSS based on data-position)
            container.style.cssText = `
                top: ${cfg.floatingHelpers.topOffset};
            `;

            console.log('[FloatingHelpers] Container created with position:', cfg.floatingHelpers.position);

            // Adicionar botÃ£o de toggle minimizar/maximizar (mobile only)
            const toggleBtn = document.createElement('button');
            toggleBtn.id = 'autods-floating-helpers-toggle';
            toggleBtn.textContent = 'â–² Minimizar';
            toggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isMinimized = container.getAttribute('data-minimized') === '1';
                container.setAttribute('data-minimized', isMinimized ? '0' : '1');
                toggleBtn.textContent = isMinimized ? 'â–² Minimizar' : 'â–¼ Expandir';
                console.log('[FloatingHelpers] Toggle:', isMinimized ? 'Expandido' : 'Minimizado');
            });
            container.appendChild(toggleBtn);

            // Adicionar botÃ£o de loot rÃ¡pido
            if (cfg.floatingHelpers.loot.enabled && cfg.floatingHelpers.loot.showFloating) {
                console.log('[FloatingHelpers] Adding loot box');
                container.appendChild(this.createLootBox(context, cfg));
            }

            // Adicionar botÃ£o de Ultra Fast Stamina
            if (cfg.ultraFastStamina?.enabled) {
                console.log('[FloatingHelpers] Adding stamina box');
                container.appendChild(this.createStaminaBox(context, cfg));
            }

            // Adicionar botÃ£o de Ultra Fast Attack
            if (cfg.ultraFastAttack?.enabled) {
                console.log('[FloatingHelpers] Adding attack box');
                container.appendChild(this.createFarmBox(context, cfg));
            }

            // Adicionar 4 botÃµes principais de abas (Farm, Dungeon, PvP, Boss)
            console.log('[FloatingHelpers] Adding main tab buttons');
            container.appendChild(this.createMainTabButtons(context, cfg));

            console.log('[FloatingHelpers] Appending container to body. Children:', container.children.length);
            document.body.appendChild(container);
            this.state.container = container;

            console.log('[FloatingHelpers] Container appended. Element in DOM:', !!document.getElementById('autods-floating-helpers'));

            // Handle window resize para mostrar/esconder toggle
            const handleResize = () => {
                if (window.innerWidth <= 480) {
                    toggleBtn.style.display = 'block';
                } else {
                    toggleBtn.style.display = 'none';
                    // Em desktop, sempre expandir
                    container.setAttribute('data-minimized', '0');
                }
            };
            window.addEventListener('resize', handleResize);

            // Integrar botÃ£o nativo de battle drawer (ðŸ§ª)
            this.integrateBattleDrawerButton(context);

            // Adicionar botÃ£o de Damage Calculator (apÃ³s items)
            console.log('[FloatingHelpers] Adding damage calculator button');
            this.state.container.appendChild(this.createDamageCalculatorButton(context, cfg));

            // Ocultar popup nativo se configurado
            if (cfg.floatingHelpers.hideNativePopup) {
                this.hideNativeBattleConsumables(context);
            }

            // Removido: updateAllPotionCounts (fetch bloqueado pelo site)
        },
        createPotionBox(context, type, label, cfg) {
            const box = document.createElement('div');
            box.className = `potion-box potion-${type}`;
            box.style.cssText = `
                background: rgba(30, 30, 46, 0.95);
                border: 2px solid rgba(137, 180, 250, 0.5);
                border-radius: 8px;
                padding: 8px;
                min-width: 60px;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
            `;

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: 24px; line-height: 1;';
            icon.textContent = type === 'small' ? 'ðŸ§ª' : 'âš—ï¸';

            const count = document.createElement('div');
            count.className = `potion-count-${type}`;
            count.style.cssText = 'font-size: 11px; color: #a6e3a1; font-weight: bold;';
            count.textContent = '0';

            box.appendChild(icon);
            box.appendChild(count);

            // Full Stamina e Small Stamina agora abrem o BattleDrawer
            const openDrawerBtn = document.createElement('button');
            openDrawerBtn.textContent = type === 'full' ? 'Use' : 'Open';
            openDrawerBtn.style.cssText = `
                background: #89b4fa;
                color: #1e1e2e;
                border: none;
                padding: 3px 8px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
                font-weight: bold;
                margin-top: 2px;
            `;
            openDrawerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.openBattleDrawer(context);
            });
            box.appendChild(openDrawerBtn);

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'translateX(-4px)';
                box.style.boxShadow = '0 4px 12px rgba(137, 180, 250, 0.4)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'translateX(0)';
                box.style.boxShadow = 'none';
            });

            return box;
        },
        createExpPotionBox(context, cfg) {
            const box = document.createElement('div');
            box.className = 'potion-box potion-exp';
            box.style.cssText = `
                background: rgba(30, 30, 46, 0.95);
                border: 2px solid rgba(249, 226, 175, 0.5);
                border-radius: 8px;
                padding: 8px;
                min-width: 60px;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
            `;

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: 24px; line-height: 1;';
            icon.textContent = 'âœ¨';

            const count = document.createElement('div');
            count.className = 'potion-count-exp';
            count.style.cssText = 'font-size: 11px; color: #f9e2af; font-weight: bold;';
            count.textContent = '0';

            const timerDisplay = document.createElement('div');
            timerDisplay.className = 'exp-potion-timer';
            timerDisplay.style.cssText = 'font-size: 10px; color: #f9e2af; display: none;';
            timerDisplay.textContent = '00:00';

            const useBtn = document.createElement('button');
            useBtn.textContent = 'Use';
            useBtn.style.cssText = `
                background: #f9e2af;
                color: #1e1e2e;
                border: none;
                padding: 3px 8px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
                font-weight: bold;
                margin-top: 2px;
            `;
            useBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.useExpPotion(context);
            });

            box.appendChild(icon);
            box.appendChild(count);
            box.appendChild(timerDisplay);
            box.appendChild(useBtn);

            return box;
        },
        createLootBox(context, cfg) {
            const box = document.createElement('div');
            box.className = 'loot-box autods-floating-loot-btn';  // ðŸ†• Adicionada classe para seleÃ§Ã£o
            
            // Verificar se Ultra Fast Loot estÃ¡ ativo
            const ultraFastEnabled = context.config.get().ultraFastLoot?.enabled;
            
            box.style.cssText = `
                background: ${ultraFastEnabled ? 'linear-gradient(135deg, #fab387 0%, #f38ba8 100%)' : 'rgba(50, 50, 70, 0.8)'};
                border: 2px solid ${ultraFastEnabled ? '#fab387' : 'rgba(100, 100, 100, 0.5)'};
                border-radius: 6px;
                padding: 8px 12px;
                color: ${ultraFastEnabled ? '#000' : '#aaa'};
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                min-height: 36px;
                position: relative;
            `;

            // Badge de Ultra Fast (se ativo)
            if (ultraFastEnabled) {
                const badge = document.createElement('div');
                badge.style.cssText = `
                    position: absolute;
                    top: -4px;
                    right: -4px;
                    background: linear-gradient(135deg, #fab387 0%, #f38ba8 100%);
                    color: #1e1e2e;
                    font-size: 10px;
                    font-weight: bold;
                    padding: 2px 4px;
                    border-radius: 4px;
                    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                    z-index: 1;
                `;
                badge.textContent = 'âš¡';
                badge.title = 'Ultra Fast Loot Ativo';
                box.appendChild(badge);
            }

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: clamp(18px, 5vw, 24px); line-height: 1;';
            icon.textContent = 'ðŸ’°';
            icon.className = 'loot-icon';  // ðŸ†• Classe para o Ã­cone

            const label = document.createElement('div');
            label.style.cssText = `font-size: clamp(10px, 2vw, 12px); color: inherit; font-weight: bold;`;
            label.textContent = ultraFastEnabled ? 'Fast' : 'Loot';
            label.className = 'loot-label';  // ðŸ†• Classe para o label

            box.appendChild(icon);
            box.appendChild(label);

            box.addEventListener('click', () => {
                this.performQuickLoot(context);
            });

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = ultraFastEnabled 
                    ? '0 4px 12px rgba(250, 179, 135, 0.4)' 
                    : '0 4px 12px rgba(137, 180, 250, 0.3)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
            });

            return box;
        },

        createStaminaBox(context, cfg) {
            const box = document.createElement('div');
            box.className = 'stamina-box autods-floating-stamina-btn';
            
            const ultraFastEnabled = context.config.get().ultraFastStamina?.enabled;
            
            box.style.cssText = `
                background: ${ultraFastEnabled ? 'linear-gradient(135deg, #89dceb 0%, #74c7ec 100%)' : 'rgba(50, 50, 70, 0.8)'};
                border: 2px solid ${ultraFastEnabled ? '#89dceb' : 'rgba(100, 100, 100, 0.5)'};
                border-radius: 6px;
                padding: 8px 12px;
                color: ${ultraFastEnabled ? '#000' : '#aaa'};
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                min-height: 36px;
                position: relative;
            `;

            // Badge de Ultra Fast
            const badge = document.createElement('div');
            badge.style.cssText = `
                position: absolute;
                top: -4px;
                right: -4px;
                background: linear-gradient(135deg, #89dceb 0%, #74c7ec 100%);
                color: #1e1e2e;
                font-size: 10px;
                font-weight: bold;
                padding: 2px 4px;
                border-radius: 4px;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                z-index: 1;
            `;
            badge.textContent = 'âš¡';
            badge.title = 'Ultra Fast Stamina';
            box.appendChild(badge);

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: clamp(18px, 5vw, 24px); line-height: 1;';
            icon.textContent = 'âš¡';
            icon.className = 'stamina-icon';

            const label = document.createElement('div');
            label.style.cssText = 'font-size: clamp(10px, 2vw, 12px); color: inherit; font-weight: bold;';
            label.textContent = 'Stamina';
            label.className = 'stamina-label';

            box.appendChild(icon);
            box.appendChild(label);

            box.addEventListener('click', async () => {
                context.logger.info('âš¡ Iniciando Ultra Fast Stamina...');
                
                // Get module
                const ultraStaminaModule = context.moduleRegistry?.getModule('ultraFastStamina');
                if (!ultraStaminaModule) {
                    context.logger.error('Ultra Fast Stamina module nÃ£o encontrado');
                    context.notifications.error('Ultra Fast Stamina module nÃ£o encontrado!');
                    return;
                }

                // Run
                try {
                    await ultraStaminaModule.runStaminaFarm(context);
                } catch (error) {
                    context.logger.error('Erro ao executar Ultra Fast Stamina:', error);
                    context.notifications.error('Erro ao executar Ultra Fast Stamina!');
                }
            });

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = ultraFastEnabled 
                    ? '0 4px 12px rgba(137, 220, 235, 0.4)' 
                    : '0 4px 12px rgba(137, 180, 250, 0.3)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
            });

            return box;
        },

        createFarmBox(context, cfg) {
            const box = document.createElement('div');
            box.className = 'farm-box autods-floating-farm-btn';
            
            const ultraFastEnabled = context.config.get().ultraFastAttack?.enabled;
            
            box.style.cssText = `
                background: ${ultraFastEnabled ? 'linear-gradient(135deg, #89b4fa 0%, #a6e3a1 100%)' : 'rgba(50, 50, 70, 0.8)'};
                border: 2px solid ${ultraFastEnabled ? '#89b4fa' : 'rgba(100, 100, 100, 0.5)'};
                border-radius: 6px;
                padding: 8px 12px;
                color: ${ultraFastEnabled ? '#000' : '#aaa'};
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                min-height: 36px;
                position: relative;
            `;

            // Badge de Ultra Fast (se ativo)
            if (ultraFastEnabled) {
                const badge = document.createElement('div');
                badge.style.cssText = `
                    position: absolute;
                    top: -4px;
                    right: -4px;
                    background: linear-gradient(135deg, #89b4fa 0%, #74c7ec 100%);
                    color: #1e1e2e;
                    font-size: 10px;
                    font-weight: bold;
                    padding: 2px 4px;
                    border-radius: 4px;
                    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                    z-index: 1;
                `;
                badge.textContent = 'âš¡';
                badge.title = 'Ultra Fast Farm Ativo';
                box.appendChild(badge);
            }

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: clamp(18px, 5vw, 24px); line-height: 1;';
            icon.textContent = 'âš”ï¸';
            icon.className = 'farm-icon';

            const label = document.createElement('div');
            label.style.cssText = `font-size: clamp(10px, 2vw, 12px); color: inherit; font-weight: bold;`;
            label.textContent = 'Attack';
            label.className = 'farm-label';

            box.appendChild(icon);
            box.appendChild(label);

            box.addEventListener('click', () => {
                const pathname = window.location?.pathname || '';
                // Apenas executar em active_wave.php
                if (!/active_wave\.php/i.test(pathname)) {
                    context.logger.warn('[FloatingHelpers] Farm box sÃ³ funciona em active_wave.php');
                    context.notifications.warn('Farm: acesse uma pÃ¡gina de wave!');
                    return;
                }
                
                // Executar ultraFastAttackModule para um batch Ãºnico de operaÃ§Ãµes
                context.logger.info('[FloatingHelpers] ðŸš€ Iniciando Ultra Fast Attack (batch Ãºnico)...');
                
                // Ativar ultraFastAttack config se necessÃ¡rio
                const cfg = context.config.get();
                if (!cfg.ultraFastAttack?.enabled) {
                    context.config.update({
                        ultraFastAttack: { enabled: true }
                    });
                }
                
                // Chamar triggerManualRun do ultraFastAttackModule
                const ultraFastAttackModule = context.moduleRegistry?.getModule('ultraFastAttack');
                if (ultraFastAttackModule && typeof ultraFastAttackModule.triggerManualRun === 'function') {
                    context.logger.info('[FloatingHelpers] âœ… Disparando ultraFastAttackModule.triggerManualRun()');
                    ultraFastAttackModule.triggerManualRun(context);
                } else {
                    context.logger.error('[FloatingHelpers] âŒ Ultra Fast Farm module nÃ£o encontrado ou nÃ£o tem triggerManualRun!');
                    context.notifications.error('Farm box: mÃ³dulo nÃ£o encontrado!');
                }
            });

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = ultraFastEnabled 
                    ? '0 4px 12px rgba(137, 180, 250, 0.4)' 
                    : '0 4px 12px rgba(137, 180, 250, 0.3)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
            });

            return box;
        },
        
        recreateLootBox(context) {
            const cfg = context.config.get();
            
            // Find existing loot box using context.dom
            const existingLootBox = context.dom.query('.autods-floating-loot-btn', this.state.container);
            if (!existingLootBox) return;
            
            // Create new loot box with updated appearance
            const newLootBox = this.createLootBox(context, cfg);
            
            // Replace in DOM
            existingLootBox.replaceWith(newLootBox);
            
            console.log('[FloatingHelpers] Loot box recreated with Ultra Fast status update');
        },

        createDamageCalculatorButton(context, cfg) {
            const box = document.createElement('div');
            box.className = 'damage-calculator-box';
            
            const calcVisible = this.state.damageCalculatorVisible || false;
            
            box.style.cssText = `
                background: ${calcVisible ? 'linear-gradient(135deg, #cba6f7 0%, #89b4fa 100%)' : 'rgba(50, 50, 70, 0.8)'};
                border: 2px solid ${calcVisible ? '#cba6f7' : 'rgba(100, 100, 100, 0.5)'};
                border-radius: 6px;
                padding: 8px 12px;
                color: ${calcVisible ? '#000' : '#aaa'};
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                min-height: 36px;
                position: relative;
            `;

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: clamp(16px, 5vw, 16px); line-height: 1;';
            icon.textContent = 'ðŸ§®';

            const label = document.createElement('div');
            label.style.cssText = 'font-size: clamp(10px, 2vw, 12px); color: inherit; font-weight: bold;';
            label.textContent = 'Calc';

            box.appendChild(icon);
            box.appendChild(label);

            box.addEventListener('click', () => {
                this.toggleDamageCalculator(context);
            });

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = calcVisible 
                    ? '0 4px 12px rgba(203, 166, 247, 0.4)' 
                    : '0 4px 12px rgba(137, 180, 250, 0.3)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
            });

            return box;
        },

        createMainTabButtons(context, cfg) {
            const container = document.createElement('div');
            container.id = 'autods-main-tab-buttons';
            container.style.cssText = `
                display: flex;
                flex-direction: column;
                gap: 6px;
                margin-top: 8px;
                padding-top: 8px;
                border-top: 1px solid rgba(100, 100, 100, 0.3);
                width: 100%;
            `;

            // 4 botÃµes principais: Farm, Dungeon, PvP, Boss
            const buttons = [
                { id: 'dungeon', label: 'Dungeon', emoji: 'ðŸ°', config: 'ultraFastDungeon.enabled' },
                { id: 'farm', label: 'Farm', emoji: 'âš”ï¸', config: 'wave.ultraFastMode' },
                { id: 'pvp', label: 'PvP', emoji: 'ðŸ†', config: 'pvp.ultraFastMode' },
                { id: 'boss', label: 'Boss', emoji: 'ðŸ‘‘', config: 'specialBossFarm.enabled' }
            ];

            buttons.forEach(btn => {
                const button = document.createElement('button');
                button.id = `autods-main-btn-${btn.id}`;
                button.dataset.action = `toggle-${btn.id}`;
                button.title = `Toggle ${btn.label} mode`;
                
                // Get current state
                const cfg = context.config.get();
                const parts = btn.config.split('.');
                let enabled = cfg;
                for (const part of parts) {
                    enabled = enabled?.[part];
                }

                button.style.cssText = `
                    background: ${enabled ? 'linear-gradient(135deg, #89b4fa 0%, #a6e3a1 100%)' : 'rgba(50, 50, 70, 0.8)'};
                    border: 2px solid ${enabled ? '#89b4fa' : 'rgba(100, 100, 100, 0.5)'};
                    border-radius: 6px;
                    padding: 8px 12px;
                    color: ${enabled ? '#000' : '#aaa'};
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.2s;
                    font-size: clamp(11px, 2vw, 12px);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 4px;
                    min-height: 36px;
                    width: 100%;
                `;

                button.innerHTML = `<span style="font-size: 16px;">${btn.emoji}</span> ${btn.label}${btn.id === 'dungeon' ? ' âš¡' : ''}`;

                button.addEventListener('click', async () => {
                    // Comportamento especial para Dungeon: executa em vez de toggle
                    if (btn.id === 'dungeon') {
                        context.logger.info('ðŸ° Executando Ultra Fast Dungeon...');
                        const dungeonModule = context.moduleRegistry?.getModule('ultraFastDungeon');
                        if (!dungeonModule) {
                            context.logger.error('Ultra Fast Dungeon module nÃ£o encontrado');
                            context.notifications.error('Dungeon: mÃ³dulo nÃ£o encontrado!');
                            return;
                        }
                        try {
                            if (typeof dungeonModule.triggerManualRun === 'function') {
                                await dungeonModule.triggerManualRun(context);
                            } else {
                                context.logger.error('Dungeon: mÃ©todo triggerManualRun nÃ£o existe');
                                context.notifications.error('Dungeon nÃ£o estÃ¡ configurado corretamente!');
                            }
                        } catch (error) {
                            context.logger.error('Erro ao executar Dungeon:', error);
                            context.notifications.error('Erro ao executar Dungeon!');
                        }
                        return;
                    }
                    
                    // Comportamento especial para Farm: toggle ativa/desativa
                    if (btn.id === 'farm') {
                        const pathname = window.location?.pathname || '';
                        // Apenas executar em active_wave.php
                        if (!/active_wave\.php/i.test(pathname)) {
                            context.logger.warn('[FloatingHelpers] Farm sÃ³ funciona em active_wave.php');
                            context.notifications.warn('Farm: acesse uma pÃ¡gina de wave!');
                            return;
                        }
                        
                        const cfg = context.config.get();
                        const waveEnabled = cfg.wave?.ultraFastMode || false;
                        const newValue = !waveEnabled;  // Toggle
                        
                        if (newValue) {
                            // ATIVAR Farm
                            context.logger.info('[FloatingHelpers] ðŸš€ Iniciando Ultra Fast Farm (loop contÃ­nuo)...');
                            
                            // Atualizar config: ativar core, wave.enabled E ultraFastMode
                            context.config.update({
                                core: { enabled: true },
                                wave: {
                                    enabled: true,
                                    ultraFastMode: true
                                }
                            });
                            
                            // Reset e ativar o mÃ³dulo
                            setTimeout(() => {
                                const waveModule = context.moduleRegistry?.getModule('waveAutomation');
                                if (waveModule) {
                                    // Reset state
                                    if (waveModule.state) {
                                        waveModule.state.running = false;
                                        waveModule.state.staminaWaiting = false;
                                        waveModule.state.notifiedMaxBattles = false;
                                    }
                                    
                                    // Activate
                                    if (typeof waveModule.activate === 'function') {
                                        waveModule.activate(context);
                                        context.logger.info('[FloatingHelpers] âœ… Ultra Fast Farm iniciado!');
                                    }
                                }
                            }, 20);
                        } else {
                            // DESATIVAR Farm
                            context.logger.info('[FloatingHelpers] â¹ï¸ Parando Ultra Fast Farm...');
                            context.config.update({
                                wave: {
                                    enabled: false,
                                    ultraFastMode: false
                                }
                            });
                            context.logger.info('[FloatingHelpers] âœ… Ultra Fast Farm parado!');
                        }
                        
                        // Update button appearance
                        button.style.background = newValue ? 'linear-gradient(135deg, #89b4fa 0%, #a6e3a1 100%)' : 'rgba(50, 50, 70, 0.8)';
                        button.style.borderColor = newValue ? '#89b4fa' : 'rgba(100, 100, 100, 0.5)';
                        button.style.color = newValue ? '#000' : '#aaa';
                        
                        return;
                    }
                    
                    // Comportamento padrÃ£o para PvP, Boss: toggle flag
                    const cfg = context.config.get();
                    const parts = btn.config.split('.');
                    let obj = cfg;
                    for (let i = 0; i < parts.length - 1; i++) {
                        obj = obj[parts[i]];
                    }
                    const lastPart = parts[parts.length - 1];
                    const newValue = !obj[lastPart];

                    // Update config
                    const patch = createPatchFromPath(btn.config, newValue);
                    context.config.update(patch);

                    // Update button appearance
                    button.style.background = newValue ? 'linear-gradient(135deg, #89b4fa 0%, #a6e3a1 100%)' : 'rgba(50, 50, 70, 0.8)';
                    button.style.borderColor = newValue ? '#89b4fa' : 'rgba(100, 100, 100, 0.5)';
                    button.style.color = newValue ? '#000' : '#aaa';

                    context.logger.info(`[FloatingHelpers] ${btn.label} mode ${newValue ? 'enabled' : 'disabled'}`);
                });

                button.addEventListener('mouseenter', () => {
                    button.style.transform = 'scale(1.05)';
                    button.style.boxShadow = '0 4px 12px rgba(137, 180, 250, 0.3)';
                });
                button.addEventListener('mouseleave', () => {
                    button.style.transform = 'scale(1)';
                    button.style.boxShadow = 'none';
                });

                container.appendChild(button);
            });

            return container;
        },

        toggleDamageCalculator(context) {
            this.state.damageCalculatorVisible = !this.state.damageCalculatorVisible;
            
            const damageCalcModule = context.moduleRegistry?.getModule('damageCalculator');
            if (!damageCalcModule) {
                context.logger.warn('[FloatingHelpers] Damage Calculator module not found');
                return;
            }

            if (this.state.damageCalculatorVisible) {
                damageCalcModule.show(context);
            } else {
                damageCalcModule.hide(context);
            }
        },

        recreateFarmBox(context) {
            const cfg = context.config.get();
            
            // Se Attack nÃ£o estÃ¡ habilitado, remover o botÃ£o
            if (!cfg.ultraFastAttack?.enabled) {
                const existingFarmBox = this.state.container?.querySelector('.autods-floating-farm-btn');
                if (existingFarmBox) {
                    existingFarmBox.remove();
                    console.log('[FloatingHelpers] Attack box removed (disabled)');
                }
                return;
            }
            
            // Se Attack estÃ¡ habilitado mas botÃ£o nÃ£o existe, criar
            const existingFarmBox = this.state.container?.querySelector('.autods-floating-farm-btn');
            if (!existingFarmBox) {
                // Inserir apÃ³s o botÃ£o de stamina (se existir) ou ao final
                const staminaBox = this.state.container?.querySelector('.autods-floating-stamina-btn');
                const newFarmBox = this.createFarmBox(context, cfg);
                
                if (staminaBox) {
                    staminaBox.insertAdjacentElement('afterend', newFarmBox);
                } else {
                    this.state.container?.appendChild(newFarmBox);
                }
                
                console.log('[FloatingHelpers] Farm box created (enabled)');
                return;
            }
            
            // Se jÃ¡ existe, apenas atualizar aparÃªncia
            const newFarmBox = this.createFarmBox(context, cfg);
            existingFarmBox.replaceWith(newFarmBox);
            
            console.log('[FloatingHelpers] Farm box recreated with Ultra Fast status update');
        },
        
        integrateBattleDrawerButton(context) {
            // Procurar o botÃ£o nativo de battle drawer
            const nativeButton = document.getElementById('openBattleDrawerBtn');
            if (!nativeButton) {
                context.logger.debug('[FloatingHelpers] BotÃ£o nativo #openBattleDrawerBtn nÃ£o encontrado');
                return;
            }

            // Esconder o botÃ£o da sua posiÃ§Ã£o original
            nativeButton.style.display = 'none';

            // Criar uma cÃ³pia estilizada para o floating helpers
            const box = document.createElement('div');
            box.className = 'battle-drawer-box';
            box.style.cssText = `
                background: linear-gradient(135deg, #f9e2af 0%, #fab387 100%);
                border: 2px solid #f9e2af;
                border-radius: 6px;
                padding: 8px 12px;
                color: #000;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                min-height: 36px;
            `;

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: clamp(16px, 5vw, 16px); line-height: 1;';
            icon.textContent = 'ðŸ§ª';

            const label = document.createElement('div');
            label.style.cssText = 'font-size: clamp(10px, 2vw, 12px); color: inherit; font-weight: bold;';
            label.textContent = 'Items';

            box.appendChild(icon);
            box.appendChild(label);

            // Ao clicar no box, clicar no botÃ£o nativo
            box.addEventListener('click', () => {
                nativeButton.click();
                const closeAction = document.querySelector('[data-action="close-panel"]');
                if (closeAction) {
                    closeAction.click();
                } else {
                    context.logger.debug('[FloatingHelpers] Fechar painel nÃ£o encontrado apÃ³s abrir drawer');
                }
            });

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = '0 4px 12px rgba(249, 226, 175, 0.4)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
            });

            // Adicionar o box ao container
            const container = this.state.container;
            if (container) {
                container.appendChild(box);
                context.logger.debug('[FloatingHelpers] BotÃ£o de Battle Drawer integrado');
            }
        },
        openBattleDrawer(context) {
            // Abrir o Battle Drawer nativo da pÃ¡gina adicionando a classe 'drawer-open' ao body
            context.logger.info('[FloatingHelpers] Abrindo Battle Drawer');

            const body = context.document.body;
            if (body) {
                body.classList.add('drawer-open');

                // Verificar se o drawer existe
                const drawer = context.document.getElementById('battleDrawer');
                if (drawer) {
                    context.logger.debug('[FloatingHelpers] Battle Drawer aberto com sucesso');
                } else {
                    context.logger.warn('[FloatingHelpers] Battle Drawer (#battleDrawer) nÃ£o encontrado na pÃ¡gina');

                    // Tentar usar o botÃ£o nativo como fallback
                    const openBtn = context.document.getElementById('openBattleDrawerBtn');
                    if (openBtn) {
                        context.logger.debug('[FloatingHelpers] Clicando no botÃ£o nativo de abrir drawer');
                        openBtn.click();
                    }
                }
            }
        },
        createUltraFastStatsBox(context) {
            const box = document.createElement('div');
            box.className = 'ultra-fast-stats-box';
            box.id = 'autods-ultra-stats';
            box.style.cssText = `
                background: rgba(30, 30, 46, 0.95);
                border: 2px solid rgba(203, 166, 247, 0.5);
                border-radius: 8px;
                padding: 10px;
                min-width: 120px;
                cursor: pointer;
                transition: all 0.2s;
                display: none;
                flex-direction: column;
                gap: 6px;
            `;

            const header = document.createElement('div');
            header.style.cssText = 'display: flex; align-items: center; gap: 6px; font-size: 12px; color: #cba6f7; font-weight: bold;';
            
            const icon = document.createElement('span');
            icon.textContent = 'âš¡';
            icon.style.cssText = 'font-size: 18px;';
            
            const title = document.createElement('span');
            title.textContent = 'Ultra Fast';
            
            header.appendChild(icon);
            header.appendChild(title);

            const statsContainer = document.createElement('div');
            statsContainer.className = 'ultra-stats-content';
            statsContainer.style.cssText = 'font-size: 10px; color: #cdd6f4; line-height: 1.4;';

            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'âœ•';
            closeBtn.style.cssText = `
                background: rgba(203, 166, 247, 0.2);
                color: #cba6f7;
                border: none;
                padding: 2px 6px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
                margin-top: 4px;
                align-self: flex-end;
            `;
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                box.style.display = 'none';
            });

            box.appendChild(header);
            box.appendChild(statsContainer);
            box.appendChild(closeBtn);

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'translateX(-4px)';
                box.style.boxShadow = '0 4px 12px rgba(203, 166, 247, 0.4)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'translateX(0)';
                box.style.boxShadow = 'none';
            });

            return box;
        },
        updateUltraFastStats(context, stats, type) {
            console.log('[FloatingHelpers] updateUltraFastStats called:', { type, stats });
            
            let box = document.getElementById('autods-ultra-stats');
            
            if (!box) {
                const container = this.state.container;
                if (!container) {
                    console.warn('[FloatingHelpers] Container not found for stats box');
                    return;
                }
                
                console.log('[FloatingHelpers] Creating new stats box');
                box = this.createUltraFastStatsBox(context);
                container.appendChild(box);
            }

            const statsContent = box.querySelector('.ultra-stats-content');
            if (!statsContent) {
                console.warn('[FloatingHelpers] Stats content not found');
                return;
            }

            let html = '';
            
            if (type === 'farm') {
                const duration = stats.duration ? (stats.duration / 1000).toFixed(1) : 
                               (stats.endTime ? ((stats.endTime - stats.startTime) / 1000).toFixed(1) : 0);
                html = `
                    <div style="margin-bottom: 4px; color: #a6e3a1; font-weight: bold;">ðŸŒ¾ Farm Complete!</div>
                    <div>â±ï¸ ${duration}s</div>
                    <div>ðŸ“¦ ${stats.totalBatches || 0} lotes</div>
                    <div>ðŸ‘¹ ${stats.totalMonsters || 0} mobs</div>
                    <div style="color: #a6e3a1;">âœ… ${stats.successfulJoins || 0} entradas</div>
                    ${(stats.failedJoins || 0) > 0 ? `<div style="color: #f38ba8;">âŒ ${stats.failedJoins} falhas</div>` : ''}
                    <div>âš”ï¸ ${stats.totalAttacks || 0} ataques</div>
                `;
            } else if (type === 'loot') {
                // ðŸ†• Usar dados do summary se disponÃ­vel
                const summary = stats.summary;
                const exp = summary ? summary.exp : (stats.totalExp || 0);
                const gold = summary ? summary.gold : (stats.totalGold || 0);
                const itemCount = summary ? summary.items.size : (stats.items?.length || 0);
                
                html = `
                    <div style="margin-bottom: 4px; color: #f9e2af; font-weight: bold;">ðŸ’° Loot Complete!</div>
                    <div>ðŸ“¦ ${stats.attempted || 0} mobs</div>
                    <div style="color: #a6e3a1;">âœ… ${stats.successful || 0} loots</div>
                    ${(stats.failed || 0) > 0 ? `<div style="color: #f38ba8;">âŒ ${stats.failed} falhas</div>` : ''}
                    <div>âœ¨ ${formatNumber(exp)} EXP</div>
                    <div>ðŸ’° ${formatNumber(gold)} Gold</div>
                    ${itemCount > 0 ? `<div>ðŸŽ ${itemCount} ${summary ? 'tipos' : 'itens'}</div>` : ''}
                `;
            }

            console.log('[FloatingHelpers] Setting stats HTML:', html);
            statsContent.innerHTML = html;
            box.style.display = 'flex';
            
            console.log('[FloatingHelpers] Stats box visibility:', box.style.display, 'in DOM:', document.body.contains(box));

            // Auto-hide apÃ³s 30 segundos
            setTimeout(() => {
                if (box && box.style.display !== 'none') {
                    box.style.display = 'none';
                }
            }, 30000);
        },
        hideNativeBattleConsumables(context) {
            // Procurar o popup nativo de Battle Consumables
            const nativePopup = context.document.querySelector('[data-battle-consumables], .battle-consumables-popup, #battleConsumables');
            
            if (nativePopup) {
                nativePopup.style.display = 'none';
                context.logger.debug('[FloatingHelpers] Popup nativo de Battle Consumables ocultado');
            } else {
                // Tentar encontrar pelo conteÃºdo (complementary role com "Battle Consumables")
                const complementaries = context.document.querySelectorAll('complementary, [role="complementary"]');
                for (const elem of complementaries) {
                    const heading = elem.querySelector('generic, div, h1, h2, h3, h4, h5, h6');
                    if (heading && heading.textContent.includes('Battle Consumables')) {
                        elem.style.display = 'none';
                        context.logger.debug('[FloatingHelpers] Popup nativo encontrado e ocultado via texto');
                        break;
                    }
                }
            }
        },
        // REMOVIDO: usePotions() - fetch bloqueado pelo site (HTTP 403)
        // REMOVIDO: useExpPotion() - fetch bloqueado pelo site (HTTP 403)
        // REMOVIDO: fetchInventoryData() - fetch bloqueado pelo site (HTTP 403)
        // REMOVIDO: updateAllPotionCounts() - fetch bloqueado pelo site (HTTP 403)
        // REMOVIDO: startExpPotionTimer() - depende de funÃ§Ãµes removidas
        // REMOVIDO: updateExpPotionTimer() - depende de funÃ§Ãµes removidas
        // REMOVIDO: stopExpPotionTimer() - depende de funÃ§Ãµes removidas
        // REMOVIDO: restoreExpPotionTimer() - depende de funÃ§Ãµes removidas
        async useExpPotion(context) {
            // Verificar se temos dados do inventÃ¡rio
            if (!this.state.inventoryData || !this.state.inventoryData.exp) {
                context.logger.warn('Dados do inventÃ¡rio nÃ£o disponÃ­veis. Atualizando...');
                await this.updateAllPotionCounts(context);
            }

            const itemData = this.state.inventoryData.exp;
            if (!itemData || !itemData.invId) {
                context.logger.error('Exp Potion S nÃ£o encontrada no inventÃ¡rio');
                context.notifications.error('Exp Potion S not found in inventory');
                return;
            }

            if (itemData.quantity < 1) {
                context.logger.warn('Exp Potion S indisponÃ­vel');
                context.notifications.error('No Exp Potions available');
                return;
            }

            try {
                context.logger.info('Usando EXP Potion...');

                // Preparar dados para envio (igual ao jogo)
                const params = new URLSearchParams();
                params.set('inv_id', itemData.invId.toString());

                // Usar HTTP service com Cloudflare bypass
                const result = await context.http.usePotionDirect(itemData.invId.toString(), window.location.href);

                if (!result.success) {
                    throw new Error(`Falha na requisiÃ§Ã£o: ${result.message || 'Unknown error'}`);
                }
                const lower = result.message.trim().toLowerCase();

                if (lower.includes('success')) {
                    context.logger.info('âœ… EXP Potion usado com sucesso!');

                    // Notificar sucesso
                    context.notifications.success('Used Exp Potion S!');

                    // Iniciar timer de 1 hora
                    this.startExpPotionTimer(context);

                    // Atualizar contador local (sem fetch)
                    const newQuantity = itemData.quantity - 1;
                    this.state.inventoryData.exp.quantity = newQuantity;

                    const countElement = document.querySelector('.potion-count-exp');
                    if (countElement) {
                        countElement.textContent = newQuantity.toString();
                    }

                    // Emitir evento
                    context.events.emit('autods:potion:use', {
                        type: 'exp',
                        name: 'EXP Potion',
                        remaining: newQuantity,
                        timestamp: Date.now()
                    });

                    // Recarregar pÃ¡gina para sincronizar (igual ao jogo)
                    setTimeout(() => {
                        location.reload();
                    }, 500);
                } else {
                    throw new Error(responseText.slice(0, 200) || 'Failed to use item.');
                }
            } catch (error) {
                context.logger.error(`Erro ao usar EXP Potion: ${error.message}`);
                context.notifications.error(error.message || 'Server error.');
            }
        },
        startExpPotionTimer(context) {
            this.state.expPotionEndTime = Date.now() + (60 * 60 * 1000); // 1 hora
            localStorage.setItem(this.POTION_STORAGE_KEY, this.state.expPotionEndTime.toString());

            if (this.state.expPotionTimer) {
                clearInterval(this.state.expPotionTimer);
            }

            this.state.expPotionTimer = setInterval(() => {
                this.updateExpPotionTimer(context);
            }, 1000);

            this.updateExpPotionTimer(context);
        },
        updateExpPotionTimer(context) {
            if (!this.state.expPotionEndTime) return;

            const remaining = this.state.expPotionEndTime - Date.now();
            if (remaining <= 0) {
                this.stopExpPotionTimer(context);
                return;
            }

            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            const timerElement = document.querySelector('.exp-potion-timer');
            if (timerElement) {
                timerElement.textContent = display;
                timerElement.style.display = 'block';
            }
        },
        stopExpPotionTimer(context) {
            if (this.state.expPotionTimer) {
                clearInterval(this.state.expPotionTimer);
                this.state.expPotionTimer = null;
            }
            this.state.expPotionEndTime = null;
            localStorage.removeItem(this.POTION_STORAGE_KEY);

            const timerElement = document.querySelector('.exp-potion-timer');
            if (timerElement) {
                timerElement.style.display = 'none';
            }
        },
        restoreExpPotionTimer(context) {
            const stored = localStorage.getItem(this.POTION_STORAGE_KEY);
            if (!stored) return;

            const endTime = parseInt(stored, 10);
            if (endTime > Date.now()) {
                this.state.expPotionEndTime = endTime;
                this.state.expPotionTimer = setInterval(() => {
                    this.updateExpPotionTimer(context);
                }, 1000);
                this.updateExpPotionTimer(context);
            } else {
                localStorage.removeItem(this.POTION_STORAGE_KEY);
            }
        },
        // REMOVED: fetchInventoryData() - use context.inventory.fetchInventoryData() instead
        async updateAllPotionCounts(context) {
            console.log('[FloatingHelpers] Updating potion counts...');
            const inventory = await context.inventory.fetchInventoryData();

            console.log('[FloatingHelpers] Inventory data:', inventory);

            // Armazenar inv_ids no estado para uso posterior
            if (!this.state.inventoryData) {
                this.state.inventoryData = {};
            }
            this.state.inventoryData = inventory;

            // Atualizar elementos do DOM
            ['small', 'full', 'exp'].forEach(type => {
                const element = document.querySelector(`.potion-count-${type}`);
                if (element) {
                    element.textContent = inventory[type].quantity.toString();
                    console.log(`[FloatingHelpers] Updated ${type} count to ${inventory[type].quantity}`);
                }
            });
        },
        getPlayerExpInfo() {
            // Tentar encontrar a barra de XP na pÃ¡gina
            // Formato esperado: "175,842 / 810,100" ou similar
            const expSelectors = [
                '.gtb-exp-top span:last-child',      // Top toolbar
                '.side-exp-top span:last-child',     // Sidebar
                '[class*="exp"] span:contains("/")', // GenÃ©rico
                '.exp-text',
                '#exp_text'
            ];

            for (const selector of expSelectors) {
                const expElement = document.querySelector(selector);
                if (!expElement) continue;

                const expText = expElement.textContent.trim();
                const match = expText.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                
                if (match) {
                    const currentExp = numberFromText(match[1]);
                    const maxExp = numberFromText(match[2]);
                    
                    if (currentExp !== null && maxExp !== null && maxExp > 0) {
                        const percent = (currentExp / maxExp) * 100;
                        return {
                            currentExp,
                            maxExp,
                            percent
                        };
                    }
                }
            }

            // Se nÃ£o encontrou pela estrutura, tentar via regex no body
            const bodyText = document.body?.textContent || '';
            const expMatch = bodyText.match(/EXP[:\s]*([\d,]+)\s*\/\s*([\d,]+)/i);
            
            if (expMatch) {
                const currentExp = numberFromText(expMatch[1]);
                const maxExp = numberFromText(expMatch[2]);
                
                if (currentExp !== null && maxExp !== null && maxExp > 0) {
                    const percent = (currentExp / maxExp) * 100;
                    return {
                        currentExp,
                        maxExp,
                        percent
                    };
                }
            }

            return null;
        },
        async performQuickLoot(context) {
            context.logger.info('Executando loot rÃ¡pido...');

            // Verificar se estamos em pÃ¡gina de dungeon/wave ou guild dungeon
            const isWavePage = window.location.pathname.includes('active_wave.php') ||
                              window.location.pathname.includes('wave.php');
            const isGuildDungeon = window.location.pathname.includes('guild_dungeon_location.php');

            if (!isWavePage && !isGuildDungeon) {
                context.logger.warn('Loot rÃ¡pido disponÃ­vel apenas em pÃ¡ginas de dungeon');
                return;
            }

            const cfg = context.config.get();
            
            // ðŸ†• VERIFICAR SE ULTRA FAST LOOT ESTÃ ATIVO
            const ultraFastEnabled = cfg.ultraFastLoot?.enabled;
            
            if (ultraFastEnabled) {
                context.logger.info('âš¡ Ultra Fast Loot estÃ¡ ativo! Usando modo paralelo...');
                
                // Obter referÃªncia ao mÃ³dulo ultraFastLoot usando o mÃ©todo getModule
                const ultraFastLootModule = context.moduleRegistry?.getModule('ultraFastLoot');
                
                if (ultraFastLootModule && typeof ultraFastLootModule.runLoot === 'function') {
                    // Executar Ultra Fast Loot
                    await ultraFastLootModule.runLoot(context);
                    return; // Sair - Ultra Fast Loot jÃ¡ cuidou de tudo
                } else {
                    context.logger.warn('âš ï¸ Ultra Fast Loot module nÃ£o encontrado, usando loot tradicional...');
                }
            }
            
            // FALLBACK: Loot tradicional (cÃ³digo original)
            let userId = cfg.core?.userId;

            if (!userId) {
                context.logger.warn('User ID nÃ£o configurado. Tentando detectar...');
                ensureUserId(context);
                userId = context.config.get().core?.userId;
            }

            if (!userId) {
                context.logger.error('âŒ User ID nÃ£o detectado. FaÃ§a login e tente novamente.');
                context.notifications.error('User ID not found. Please login.');
                return;
            }

            // ðŸ†• Verificar XP do jogador antes de iniciar loot
            const playerExpInfo = this.getPlayerExpInfo();
            if (playerExpInfo) {
                const expToLevelUp = playerExpInfo.maxExp - playerExpInfo.currentExp;
                context.logger.info(`ðŸ“Š XP atual: ${formatNumber(playerExpInfo.currentExp)} / ${formatNumber(playerExpInfo.maxExp)} (${playerExpInfo.percent.toFixed(1)}%)`);
                context.logger.info(`ðŸ“Š Falta ${formatNumber(expToLevelUp)} XP para subir de nÃ­vel`);
            }

            // Para guild dungeons, buscar botÃµes especÃ­ficos
            if (isGuildDungeon) {
                const guildLootButtons = Array.from(document.querySelectorAll('.autods-loot-btn'));

                if (guildLootButtons.length === 0) {
                    context.logger.info('Nenhum monstro elegÃ­vel para loot no guild dungeon');
                    return;
                }

                // ðŸ†• Feedback visual inicial
                context.logger.info(`ðŸŽ Feedback: Iniciando loot de ${guildLootButtons.length} monstros...`);
                
                // Usar toast do sistema
                if (context.ui?.showToast) {
                    context.ui.showToast(context, 'info', 'Loot All', `Iniciando loot de ${guildLootButtons.length} monstros...`);
                } else {
                    context.notifications.info(`ðŸŽ Iniciando loot de ${guildLootButtons.length} monstros...`);
                }
                
                // Atualizar botÃ£o do floating helper se existir
                const lootHelperBtn = document.querySelector('.autods-floating-loot-btn');
                const lootIcon = lootHelperBtn?.querySelector('.loot-icon');
                const lootLabel = lootHelperBtn?.querySelector('.loot-label');
                
                context.logger.debug(`[LootAll] BotÃ£o encontrado: ${!!lootHelperBtn}, Icon: ${!!lootIcon}, Label: ${!!lootLabel}`);
                
                if (lootHelperBtn && lootIcon && lootLabel) {
                    lootIcon.textContent = 'â³';
                    lootLabel.textContent = `0/${guildLootButtons.length}`;
                    lootHelperBtn.disabled = true;
                    lootHelperBtn.style.opacity = '0.6';
                    lootHelperBtn.style.cursor = 'wait';
                    
                    // Guardar referÃªncias para restauraÃ§Ã£o
                    this.state.lootAllButton = lootHelperBtn;
                    this.state.lootAllIcon = lootIcon;
                    this.state.lootAllLabel = lootLabel;
                }

                // Use unified loot service
                const targets = [];
                
                for (const button of guildLootButtons) {
                    const dgmid = button.getAttribute('data-dgmid');
                    const instanceId = button.getAttribute('data-instance-id') || button.dataset.instanceId;
                    
                    if (!dgmid || !instanceId) continue;
                    
                    const card = button.closest?.('.mon, .monster-card, .card, .monster-row, .list-group-item') || null;
                    const storedName = button.getAttribute('data-monster-name') || button.dataset?.monsterName;
                    const monsterName = this.extractMonsterName(card, storedName || `Mob ${dgmid}`);
                    
                    targets.push({
                        type: 'dungeon',
                        dgmid: dgmid,
                        instanceId: instanceId,
                        name: monsterName
                    });
                }
                
                const summary = await context.loot.lootMultiple(targets, userId, {
                    batchSize: 1, // One at a time for UI feedback
                    checkLevelUp: true,
                    checkStamina: false
                });

                try {
                    context.logger.info(`âœ… Loot de guild dungeon concluÃ­do: ${summary.drops}/${guildLootButtons.length} loots bem-sucedidos`);
                    
                    // Show which monsters were looted
                    const monsterNames = Array.from(summary.monsters.values()).map(m => m.name).join(' | ');
                    context.logger.info(`âœ… [Dungeon] Mobs: ${monsterNames}`);
                    
                    const failed = guildLootButtons.length - summary.drops;
                    // Mostrar notificaÃ§Ã£o de erro se todas as tentativas falharam
                    if (failed > 0 && summary.drops === 0) {
                        const errorMsg = `âŒ Falha no Loot de Dungeon: Todas as ${failed} tentativas foram bloqueadas pelo Cloudflare. Use o botÃ£o individual de loot em cada monstro.`;
                        context.notifications.error(errorMsg);
                        showErrorNotification(errorMsg, 10000, context.logger);
                        context.logger.error(errorMsg);
                    } else if (failed > 0) {
                        const warningMsg = `âš ï¸ Loot de Dungeon parcialmente concluÃ­do: ${summary.drops} sucessos, ${failed} bloqueados pelo Cloudflare.`;
                        context.notifications.warn(warningMsg);
                        context.logger.warn(warningMsg);
                    }

                    context.events.emit('autods:loot:quick', {
                        method: 'guild_dungeon',
                        total: guildLootButtons.length,
                        success: summary.drops,
                        failed: failed,
                        timestamp: Date.now()
                    });
                } catch (error) {
                    context.logger.error(`Erro no loot rÃ¡pido de guild dungeon: ${error.message}`);
                } finally {
                    // ðŸ†• Restaurar botÃ£o do floating helper
                    if (this.state.lootAllButton) {
                        this.state.lootAllButton.textContent = this.state.lootAllOriginalText || 'ðŸ’° Loot All';
                        this.state.lootAllButton.disabled = false;
                        this.state.lootAllButton.style.opacity = '1';
                        delete this.state.lootAllButton;
                        delete this.state.lootAllOriginalText;
                    }
                    
                    if (summary.drops > 0) {
                        context.loot.showDetailedModal(summary, 'Dungeon Quick Loot');
                    }
                }

                return;
            }

            // Para wave pages: buscar monstros elegÃ­veis para loot
            const monsterCards = Array.from(document.querySelectorAll('.monster-card'));
            const eligibleMonsters = [];

            for (const card of monsterCards) {
                // Buscar link/botÃ£o de loot
                const lootLink = card.querySelector('a[href*="battle.php"][href*="id="]');
                if (!lootLink) continue;

                const lootButton = card.querySelector('button, a');
                const buttonText = lootButton?.textContent || '';

                // Verificar se o botÃ£o Ã© "Loot" (nÃ£o "Join" ou "Continue")
                if (!/loot/i.test(buttonText)) continue;

                // Extrair monster ID
                const monsterIdMatch = lootLink.href.match(/[?&]id=(\d+)/);
                if (!monsterIdMatch) continue;

                const monsterId = monsterIdMatch[1];
                const monsterName = this.extractMonsterName(card, lootButton?.getAttribute('data-monster-name') || lootButton?.dataset?.monsterName || `Mob ${monsterId}`);
                eligibleMonsters.push({ monsterId, card, button: lootButton, monsterName });
            }

            if (eligibleMonsters.length === 0) {
                context.logger.info('Nenhum monstro elegÃ­vel para loot na wave');
                return;
            }

            // ðŸ†• Feedback visual inicial para wave
            context.notifications.info(`ðŸŽ Iniciando loot de ${eligibleMonsters.length} monstros...`);
            
            // Atualizar botÃ£o do floating helper se existir
            const lootHelperBtn = document.querySelector('.autods-floating-loot-btn');
            const lootIcon = lootHelperBtn?.querySelector('.loot-icon');
            const lootLabel = lootHelperBtn?.querySelector('.loot-label');
            
            if (lootHelperBtn && lootIcon && lootLabel) {
                lootIcon.textContent = 'â³';
                lootLabel.textContent = `0/${eligibleMonsters.length}`;
                lootHelperBtn.disabled = true;
                lootHelperBtn.style.opacity = '0.6';
                lootHelperBtn.style.cursor = 'wait';
                
                // Armazenar referÃªncias para restauraÃ§Ã£o
                this.state.lootAllIcon = lootIcon;
                this.state.lootAllLabel = lootLabel;
                this.state.lootAllButton = lootHelperBtn;
            }

            // Use unified loot service
            const targets = eligibleMonsters.map(m => ({
                monsterId: m.monsterId,
                type: 'wave',
                name: m.monsterName
            }));
            
            const summary = await context.loot.lootMultiple(targets, userId, {
                batchSize: 1, // One at a time for UI feedback
                checkLevelUp: true,
                checkStamina: false // Don't check stamina for quick loot
            });

            try {
                context.logger.info(`âœ… Loot de wave concluÃ­do: ${summary.drops}/${eligibleMonsters.length} loots bem-sucedidos`);
                
                // Show which monsters were looted
                const monsterNames = Array.from(summary.monsters.values()).map(m => m.name).join(' | ');
                context.logger.info(`âœ… [Wave] Mobs: ${monsterNames}`);
                
                const failed = eligibleMonsters.length - summary.drops;
                
                // Mostrar notificaÃ§Ã£o de erro se todas as tentativas falharam
                if (failed > 0 && summary.drops === 0) {
                    const errorMsg = `âŒ Falha no Loot: Todas as ${failed} tentativas foram bloqueadas pelo Cloudflare. Use o botÃ£o individual de loot em cada monstro.`;
                    
                    context.notifications.error(errorMsg);
                    showErrorNotification(errorMsg, 10000, context.logger);
                    context.logger.error(errorMsg);
                } else if (failed > 0) {
                    const warningMsg = `âš ï¸ Loot parcialmente concluÃ­do: ${summary.drops} sucessos, ${failed} bloqueados pelo Cloudflare.`;
                    context.notifications.warn(warningMsg);
                    context.logger.warn(warningMsg);
                }

                context.events.emit('autods:loot:quick', {
                    method: 'wave',
                    total: eligibleMonsters.length,
                    success: summary.drops,
                    failed: failed,
                    timestamp: Date.now()
                });

                // Recarregar para atualizar status
            } catch (error) {
                context.logger.error(`Erro no loot rÃ¡pido de wave: ${error.message}`);
            } finally {
                // ðŸ†• Restaurar botÃ£o do floating helper
                if (this.state.lootAllButton && this.state.lootAllIcon && this.state.lootAllLabel) {
                    this.state.lootAllIcon.textContent = 'ðŸ’°';
                    this.state.lootAllLabel.textContent = 'Loot';
                    this.state.lootAllButton.disabled = false;
                    this.state.lootAllButton.style.opacity = '1';
                    this.state.lootAllButton.style.cursor = 'pointer';
                }
                
                // Limpar referÃªncias
                this.state.lootAllIcon = null;
                this.state.lootAllLabel = null;
                this.state.lootAllButton = null;
                
                if (summary.drops > 0) {
                    context.loot.showDetailedModal(summary, 'Wave Quick Loot');
                }
            }
        },
        createLootSummary() {
            return {
                drops: 0,
                exp: 0,
                gold: 0,
                items: new Map(),
                monsters: new Map(),
                messages: []
            };
        },
        getFirstNonNull(obj, keys) {
            if (!obj || !keys || !keys.length) {
                return undefined;
            }

            for (const key of keys) {
                if (key == null) {
                    continue;
                }

                const variants = new Set([
                    key,
                    String(key).toLowerCase(),
                    String(key).toUpperCase(),
                    String(key).replace(/[_-](\w)/g, (_, c) => (c ? c.toUpperCase() : '')),
                    String(key).replace(/[_-](\w)/g, (_, c) => (c ? c.toUpperCase() : '')).replace(/^(.)/, (match) => match.toUpperCase()),
                    String(key).replace(/[_-](\w)/g, (_, c) => (c ? c.toUpperCase() : '')).replace(/^(.)/, (match) => match.toLowerCase())
                ]);

                for (const variant of variants) {
                    if (Object.prototype.hasOwnProperty.call(obj, variant) && obj[variant] != null) {
                        return obj[variant];
                    }
                }
            }

            return undefined;
        },
        createItemKey(name, rarity) {
            const base = String(name || '').trim().toLowerCase();
            const rarityKey = String(rarity || '').trim().toLowerCase();
            return rarityKey ? `${base}|${rarityKey}` : base;
        },
        createMonsterKey(name, id) {
            const base = String(name || '').trim().toLowerCase();
            const identifier = id ? String(id).trim().toLowerCase() : '';
            if (base) {
                return base;
            }
            return identifier || '';
        },
        normalizeRarity(item) {
            const raw = this.getFirstNonNull(item, ['rarity', 'rarityName', 'rarity_name', 'rarity-level', 'grade', 'quality', 'tier']);
            if (!raw) {
                return '';
            }
            return String(raw).trim();
        },
        normalizeDescription(item) {
            const raw = this.getFirstNonNull(item, ['description', 'desc', 'details', 'info', 'note', 'tooltip']);
            if (!raw) {
                return '';
            }
            return String(raw).trim();
        },
        getRarityStyling(rarity) {
            if (!rarity) {
                return {
                    background: 'rgba(148,163,184,0.18)',
                    border: 'rgba(148,163,184,0.35)',
                    color: '#e2e8f0'
                };
            }

            const value = String(rarity).trim().toLowerCase();
            switch (value) {
                case 'common':
                case 'comum':
                    return { background: 'rgba(148,163,184,0.18)', border: 'rgba(148,163,184,0.35)', color: '#e2e8f0' };
                case 'uncommon':
                case 'incomum':
                    return { background: 'rgba(74,222,128,0.18)', border: 'rgba(74,222,128,0.35)', color: '#bbf7d0' };
                case 'rare':
                case 'raro':
                    return { background: 'rgba(59,130,246,0.18)', border: 'rgba(59,130,246,0.35)', color: '#93c5fd' };
                case 'epic':
                case 'Ã©pico':
                    return { background: 'rgba(168,85,247,0.18)', border: 'rgba(168,85,247,0.35)', color: '#d8b4fe' };
                case 'legendary':
                case 'lendÃ¡rio':
                    return { background: 'rgba(249,115,22,0.18)', border: 'rgba(249,115,22,0.35)', color: '#fdba74' };
                case 'mythic':
                case 'mythical':
                case 'mÃ­tico':
                    return { background: 'rgba(236,72,153,0.18)', border: 'rgba(236,72,153,0.35)', color: '#f9a8d4' };
                case 'unique':
                case 'exotic':
                case 'exÃ³tico':
                    return { background: 'rgba(14,165,233,0.2)', border: 'rgba(14,165,233,0.4)', color: '#7dd3fc' };
                default:
                    return { background: 'rgba(148,163,184,0.18)', border: 'rgba(148,163,184,0.35)', color: '#e2e8f0' };
            }
        },
        formatRatio(value) {
            if (!Number.isFinite(value) || value === 0) {
                return null;
            }

            const absolute = Math.abs(value);
            let fractionDigits = 2;

            if (absolute < 1) {
                fractionDigits = absolute < 0.01 ? 5 : 3;
            }

            const formatted = value.toFixed(fractionDigits);
            return formatted.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
        },
        extractMonsterName(card, fallbackName) {
            if (!card) {
                return fallbackName || '';
            }

            const direct = card.getAttribute?.('data-monster-name');
            if (direct && direct.trim()) {
                return direct.trim();
            }

            const selectors = [
                '[data-name]',
                '.monster-name',
                '.monster-title',
                '.monster-card-title',
                '.card-title',
                '.name',
                'h1',
                'h2',
                'h3',
                'h4',
                '.title'
            ];

            for (const selector of selectors) {
                const element = card.querySelector?.(selector);
                if (element && element.textContent) {
                    const text = element.textContent.trim();
                    if (text) {
                        return text.replace(/\s+/g, ' ');
                    }
                }
            }

            if (fallbackName) {
                return fallbackName;
            }

            return '';
        },
        escapeHtml(value) {
            return String(value ?? '').replace(/[&<>"']/g, (char) => {
                switch (char) {
                    case '&': return '&amp;';
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '"': return '&quot;';
                    case "'": return '&#39;';
                    default: return char;
                }
            });
        },
        sanitizeHtml(doc, html) {
            if (!html) {
                return null;
            }
            const wrapper = doc.createElement('span');
            wrapper.innerHTML = String(html);
            wrapper.querySelectorAll('script, style').forEach(el => el.remove());
            wrapper.querySelectorAll('*').forEach(el => {
                Array.from(el.attributes).forEach(attr => {
                    if (/^on/i.test(attr.name)) {
                        el.removeAttribute(attr.name);
                    }
                });
            });
            return wrapper;
        },
        /**
         * @deprecated LEGACY METHOD - Not used anymore. All loot operations now use context.loot service.
         * Kept for backward compatibility only.
         */
        recordLootResult(summary, result, metadata = {}) {
            if (!summary || !result) {
                return;
            }

            summary.drops += 1;

            const rewards = result.rewards || {};
            const expValue = Number(rewards.exp ?? rewards.xp ?? rewards.experience ?? 0);
            if (Number.isFinite(expValue) && expValue > 0) {
                summary.exp += expValue;
            }

            const goldValue = Number(rewards.gold ?? rewards.coins ?? rewards.money ?? 0);
            if (Number.isFinite(goldValue) && goldValue > 0) {
                summary.gold += goldValue;
            }

            const rawRewards = result.rawRewards || rewards || {};
            const perDamage = rawRewards?.per_damage ?? rawRewards?.perDamage ?? rawRewards?.perDamageStats ?? {};
            const expPerHp = Number(this.getFirstNonNull(perDamage, ['exp_per_hp', 'expPerHp', 'exp_per_HP', 'exp-per-hp']));
            const goldPerHp = Number(this.getFirstNonNull(perDamage, ['gold_per_hp', 'goldPerHp', 'gold_per_HP', 'gold-per-hp']));
            const damageDealt = Number(this.getFirstNonNull(rawRewards, ['damage_dealt', 'damageDealt', 'damage', 'total_damage', 'totalDamage']));

            const resolvedName = this.extractMonsterName(metadata.card, metadata.monsterName) || metadata.monsterName || (metadata.monsterId ? `Mob ${metadata.monsterId}` : 'Mob');
            const monsterKey = this.createMonsterKey(resolvedName, metadata.monsterId || resolvedName);
            let monsterEntry = summary.monsters.get(monsterKey);
            if (!monsterEntry) {
                monsterEntry = {
                    name: resolvedName,
                    id: metadata.monsterId ?? null,
                    scope: metadata.scope || null,
                    count: 0,
                    exp: 0,
                    gold: 0,
                    damage: 0,
                    expPerHp: null,
                    goldPerHp: null
                };
            }

            monsterEntry.count += 1;
            if (Number.isFinite(expValue) && expValue > 0) {
                monsterEntry.exp += expValue;
            }
            if (Number.isFinite(goldValue) && goldValue > 0) {
                monsterEntry.gold += goldValue;
            }
            if (Number.isFinite(damageDealt) && damageDealt > 0) {
                monsterEntry.damage += damageDealt;
            }
            if (Number.isFinite(expPerHp) && expPerHp > 0) {
                monsterEntry.expPerHp = expPerHp;
            }
            if (Number.isFinite(goldPerHp) && goldPerHp > 0) {
                monsterEntry.goldPerHp = goldPerHp;
            }

            summary.monsters.set(monsterKey, monsterEntry);

            if (Array.isArray(result.items)) {
                result.items.forEach(item => {
                    if (!item) {
                        return;
                    }

                    const rawName = this.getFirstNonNull(item, ['name', 'title', 'item_name', 'label', 'id']);
                    const baseName = (rawName ? String(rawName) : 'Item').trim() || 'Item';
                    const rarity = this.normalizeRarity(item);
                    const description = this.normalizeDescription(item);
                    const emojiRaw = this.getFirstNonNull(item, ['emoji', 'icon_emoji', 'symbol']);
                    const emoji = emojiRaw ? String(emojiRaw).trim() : '';
                    const displayName = emoji ? `${emoji} ${baseName}` : baseName;
                    const qtyValue = this.getFirstNonNull(item, ['quantity', 'qty', 'amount', 'count', 'stack']);
                    const qtyRaw = Number(qtyValue ?? 1);
                    const quantity = Number.isFinite(qtyRaw) && qtyRaw > 0 ? qtyRaw : 1;
                    const iconRaw = this.getFirstNonNull(item, ['icon', 'icon_url', 'iconUrl', 'image', 'image_url', 'imageUrl', 'img', 'IMAGE_URL', 'thumbnail']);
                    const icon = iconRaw ? String(iconRaw) : '';

                    const key = this.createItemKey(baseName, rarity);
                    const existing = summary.items.get(key);
                    if (existing) {
                        existing.quantity += quantity;
                        if (!existing.description && description) {
                            existing.description = description;
                        }
                        if (!existing.icon && icon) {
                            existing.icon = icon;
                        }
                    } else {
                        summary.items.set(key, {
                            name: baseName,
                            displayName,
                            rarity,
                            description,
                            icon,
                            quantity
                        });
                    }
                });
            }

            if (result.message) {
                const message = String(result.message).trim();
                if (message) {
                    summary.messages.push(message);
                }
            }

            if (result.note) {
                const note = String(result.note).trim();
                if (note) {
                    summary.messages.push(note);
                }
            }
        },
        formatLootItems(summary) {
            if (!summary || !summary.items || summary.items.size === 0) {
                return '';
            }

            const entries = [];
            summary.items.forEach(item => {
                if (!item) {
                    return;
                }

                        const raritySuffix = item.rarity ? ` - ${item.rarity}` : '';
                entries.push(`${formatNumber(item.quantity)}x ${item.displayName}${raritySuffix}`);
            });

            return entries.join(', ');
        },
        formatMonsterSummary(summary) {
            if (!summary || !summary.monsters || summary.monsters.size === 0) {
                return '';
            }

            const entries = [];
            summary.monsters.forEach(monster => {
                if (!monster) {
                    return;
                }

                const name = monster.name || monster.id || 'Mob';
                const parts = [];

                if (Number.isFinite(monster.exp) && monster.exp > 0) {
                    parts.push(`${formatNumber(monster.exp)} XP`);
                }

                if (Number.isFinite(monster.gold) && monster.gold > 0) {
                    parts.push(`${formatNumber(monster.gold)} Gold`);
                }

                const ratioParts = [];
                if (Number.isFinite(monster.expPerHp) && monster.expPerHp > 0) {
                    const expRatio = this.formatRatio(monster.expPerHp);
                    if (expRatio) {
                        ratioParts.push(`EXP/HP ${expRatio}`);
                    }
                }

                if (Number.isFinite(monster.goldPerHp) && monster.goldPerHp > 0) {
                    const goldRatio = this.formatRatio(monster.goldPerHp);
                    if (goldRatio) {
                        ratioParts.push(`Gold/HP ${goldRatio}`);
                    }
                }

                const ratioText = ratioParts.length ? ` (${ratioParts.join(' â€¢ ')})` : '';
                const metrics = parts.length ? parts.join(' â€¢ ') : null;
                entries.push(metrics ? `${name}: ${metrics}${ratioText}` : `${name}${ratioText}`);
            });

            return entries.length ? `Mobs: ${entries.join(' | ')}` : '';
        },
        /**
         * @deprecated LEGACY METHOD - Not used anymore. Use context.loot.showDetailedModal() instead.
         * Kept for backward compatibility only.
         */
        showLootSummary(context, summary, scopeLabel) {
            if (!summary || summary.drops === 0) {
                return;
            }

            const parts = [];

            if (summary.exp > 0) {
                parts.push(`${formatNumber(summary.exp)} EXP`);
            }

            if (summary.gold > 0) {
                parts.push(`${formatNumber(summary.gold)} Gold`);
            }

            const itemsText = this.formatLootItems(summary);
            if (itemsText) {
                parts.push(itemsText);
            }

            const monstersText = this.formatMonsterSummary(summary);
            if (monstersText) {
                parts.push(monstersText);
            }

            const fallbackMessage = summary.messages.length ? summary.messages[summary.messages.length - 1] : 'Loot concluÃ­do.';
            const message = parts.length ? parts.join(' â€¢ ') : fallbackMessage.replace(/<[^>]+>/g, '');
            const prefix = scopeLabel ? `[${scopeLabel}] ` : '';
            const fullMessage = `${prefix}${message}`;

            context.notifications.success(fullMessage);

            context.logger.info(`[QuickLoot] ${fullMessage}`);

            this.openQuickLootModal(context, summary, scopeLabel);
        },
        openQuickLootModal(context, summary, scopeLabel) {
            try {
                const doc = context.document || document;
                const host = doc.body;
                if (!host) {
                    return;
                }

                const existing = doc.getElementById('autods-quickloot-modal');
                if (existing) {
                    existing.remove();
                }

                const overlay = doc.createElement('div');
                overlay.id = 'autods-quickloot-modal';
                overlay.style.cssText = `
                    position: fixed;
                    inset: 0;
                    background: rgba(8, 15, 28, 0.65);
                    backdrop-filter: blur(4px);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 2147483646;
                    animation: autods-quickloot-fade-in 0.18s ease-out;
                `;

                const card = doc.createElement('div');
                card.style.cssText = `
                    background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
                    border: 1px solid rgba(148, 163, 184, 0.35);
                    border-radius: 16px;
                    padding: 20px;
                    min-width: 320px;
                    max-width: 520px;
                    width: min(520px, calc(100vw - 40px));
                    max-height: 82vh;
                    overflow-y: auto;
                    color: #e2e8f0;
                    box-shadow: 0 20px 60px rgba(8, 15, 28, 0.55);
                    display: flex;
                    flex-direction: column;
                    gap: 12px;
                    font-family: 'Segoe UI', system-ui, sans-serif;
                `;

                const title = doc.createElement('div');
                title.style.cssText = 'display:flex;justify-content:space-between;align-items:center;gap:12px;';
                const heading = doc.createElement('h3');
                heading.textContent = scopeLabel ? `${scopeLabel} Quick Loot` : 'Quick Loot';
                heading.style.cssText = 'margin:0;font-size:16px;font-weight:700;color:#93c5fd;';

                const closeBtn = doc.createElement('button');
                closeBtn.textContent = 'Ã—';
                closeBtn.title = 'Fechar resumo';
                closeBtn.style.cssText = `
                    background: rgba(148, 163, 184, 0.1);
                    border: 1px solid rgba(148, 163, 184, 0.4);
                    border-radius: 8px;
                    color: #e2e8f0;
                    width: 28px;
                    height: 28px;
                    font-size: 16px;
                    line-height: 1;
                    cursor: pointer;
                `;

                const totals = doc.createElement('div');
                totals.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;font-size:13px;';

                if (summary.exp > 0) {
                    const expChip = doc.createElement('span');
                    expChip.textContent = `${formatNumber(summary.exp)} EXP`;
                    expChip.style.cssText = 'padding:6px 10px;background:rgba(59,130,246,0.18);border:1px solid rgba(59,130,246,0.35);border-radius:10px;color:#93c5fd;font-weight:600;';
                    totals.appendChild(expChip);
                }

                const hasGold = summary.gold > 0;
                if (hasGold) {
                    const goldChip = doc.createElement('span');
                    goldChip.textContent = `${formatNumber(summary.gold)} Gold`;
                    goldChip.style.cssText = 'padding:6px 10px;background:rgba(250,204,21,0.18);border:1px solid rgba(250,204,21,0.35);border-radius:10px;color:#facc15;font-weight:600;';
                    totals.appendChild(goldChip);
                }

                if (summary.drops > 0) {
                    const countChip = doc.createElement('span');
                    countChip.textContent = `${summary.drops} loot${summary.drops === 1 ? '' : 's'}`;
                    countChip.style.cssText = 'padding:6px 10px;background:rgba(148,163,184,0.15);border:1px solid rgba(148,163,184,0.35);border-radius:10px;color:#cbd5f5;font-weight:600;';
                    totals.appendChild(countChip);
                }

                const closeModal = () => overlay.remove();
                closeBtn.addEventListener('click', closeModal);
                overlay.addEventListener('click', (event) => {
                    if (event.target === overlay) {
                        closeModal();
                    }
                });

                title.appendChild(heading);
                title.appendChild(closeBtn);
                card.appendChild(title);
                if (totals.childNodes.length) {
                    card.appendChild(totals);
                }

                if (summary.monsters && summary.monsters.size > 0) {
                    const monsterBlock = doc.createElement('div');
                    monsterBlock.style.cssText = 'font-size:13px;line-height:1.5;background:rgba(17,24,39,0.85);border:1px solid rgba(59,130,246,0.22);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:8px;';

                    const monsterHeading = doc.createElement('div');
                    monsterHeading.textContent = 'Mobs Lootados';
                    monsterHeading.style.cssText = 'font-size:13px;font-weight:700;color:#93c5fd;text-transform:uppercase;letter-spacing:0.04em;';
                    monsterBlock.appendChild(monsterHeading);

                    const monsterList = doc.createElement('div');
                    monsterList.style.cssText = 'display:flex;flex-direction:column;gap:8px;';

                    summary.monsters.forEach(monster => {
                        if (!monster) {
                            return;
                        }

                        const row = doc.createElement('div');
                        row.style.cssText = 'display:flex;flex-direction:column;gap:6px;background:rgba(15,23,42,0.65);border-radius:12px;padding:12px;border:1px solid rgba(148,163,184,0.18);';

                        const header = doc.createElement('div');
                        header.style.cssText = 'display:flex;flex-wrap:wrap;align-items:center;gap:8px;font-weight:600;color:#f8fafc;';

                        const nameSpan = doc.createElement('span');
                        const monsterName = monster.name || monster.id || 'Mob';
                        nameSpan.textContent = monster.count > 1 ? `${monsterName} Ã—${monster.count}` : monsterName;
                        header.appendChild(nameSpan);

                        const ratioChips = [];
                        if (Number.isFinite(monster.expPerHp) && monster.expPerHp > 0) {
                            const chip = doc.createElement('span');
                            chip.textContent = `EXP/HP ${this.formatRatio(monster.expPerHp)}`;
                            chip.style.cssText = 'margin-left:auto;padding:4px 8px;background:rgba(59,130,246,0.18);border:1px solid rgba(59,130,246,0.35);border-radius:999px;font-size:11px;color:#93c5fd;font-weight:600;';
                            ratioChips.push(chip);
                        }

                        if (Number.isFinite(monster.goldPerHp) && monster.goldPerHp > 0) {
                            const chip = doc.createElement('span');
                            chip.textContent = `Gold/HP ${this.formatRatio(monster.goldPerHp)}`;
                            chip.style.cssText = 'padding:4px 8px;background:rgba(250,204,21,0.18);border:1px solid rgba(250,204,21,0.35);border-radius:999px;font-size:11px;color:#facc15;font-weight:600;';
                            ratioChips.push(chip);
                        }

                        if (ratioChips.length) {
                            ratioChips.forEach(chip => header.appendChild(chip));
                        }

                        row.appendChild(header);

                        const metrics = doc.createElement('div');
                        metrics.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;font-size:12px;';

                        if (Number.isFinite(monster.exp) && monster.exp > 0) {
                            const expChip = doc.createElement('span');
                            expChip.textContent = `${formatNumber(monster.exp)} EXP`;
                            expChip.style.cssText = 'padding:6px 10px;background:rgba(59,130,246,0.15);border:1px solid rgba(59,130,246,0.3);border-radius:10px;color:#bfdbfe;font-weight:600;';
                            metrics.appendChild(expChip);
                        }

                        if (Number.isFinite(monster.gold) && monster.gold > 0) {
                            const goldChip = doc.createElement('span');
                            goldChip.textContent = `${formatNumber(monster.gold)} Gold`;
                            goldChip.style.cssText = 'padding:6px 10px;background:rgba(250,204,21,0.12);border:1px solid rgba(250,204,21,0.28);border-radius:10px;color:#fde68a;font-weight:600;';
                            metrics.appendChild(goldChip);
                        }

                        if (Number.isFinite(monster.damage) && monster.damage > 0) {
                            const damageChip = doc.createElement('span');
                            damageChip.textContent = `${formatNumber(monster.damage)} Dano`;
                            damageChip.style.cssText = 'padding:6px 10px;background:rgba(248,113,113,0.12);border:1px solid rgba(248,113,113,0.28);border-radius:10px;color:#fecaca;font-weight:600;';
                            metrics.appendChild(damageChip);
                        }

                        if (metrics.childNodes.length) {
                            row.appendChild(metrics);
                        }

                        monsterList.appendChild(row);
                    });

                    monsterBlock.appendChild(monsterList);
                    card.appendChild(monsterBlock);
                }

                if (summary.items && summary.items.size > 0) {
                    const itemsContainer = doc.createElement('div');
                    itemsContainer.style.cssText = 'display:flex;flex-direction:column;gap:10px;background:rgba(30,41,59,0.8);border:1px solid rgba(148,163,184,0.25);border-radius:12px;padding:12px;';

                    const itemsHeading = doc.createElement('div');
                    itemsHeading.textContent = 'Itens Obtidos';
                    itemsHeading.style.cssText = 'font-size:13px;font-weight:700;color:#bae6fd;text-transform:uppercase;letter-spacing:0.04em;';
                    itemsContainer.appendChild(itemsHeading);

                    const list = doc.createElement('ul');
                    list.style.cssText = 'margin:0;padding-left:18px;display:flex;flex-direction:column;gap:6px;font-size:12px;color:#e2e8f0;';
                    summary.items.forEach(item => {
                        if (!item) {
                            return;
                        }

                        const li = doc.createElement('li');
                        li.style.cssText = 'display:flex;flex-direction:column;gap:2px;background:rgba(15,23,42,0.65);border-radius:10px;padding:10px;border:1px solid rgba(148,163,184,0.18);';

                        const header = doc.createElement('div');
                        header.style.cssText = 'display:flex;align-items:center;gap:8px;font-weight:600;color:#f8fafc;';

                        if (item.icon) {
                            const iconImg = doc.createElement('img');
                            iconImg.src = item.icon;
                            iconImg.alt = item.displayName;
                            iconImg.style.cssText = 'width:20px;height:20px;border-radius:4px;object-fit:cover;border:1px solid rgba(148,163,184,0.25);';
                            header.appendChild(iconImg);
                        }

                        const titleSpan = doc.createElement('span');
                        titleSpan.textContent = `${formatNumber(item.quantity)}Ã— ${item.displayName}`;
                        header.appendChild(titleSpan);

                        if (item.rarity) {
                            const rarityBadge = doc.createElement('span');
                            rarityBadge.textContent = item.rarity.toUpperCase();
                            const rarityStyle = this.getRarityStyling(item.rarity);
                            rarityBadge.style.cssText = `margin-left:auto;padding:4px 8px;border-radius:999px;font-size:11px;font-weight:600;` +
                                `background:${rarityStyle.background};border:1px solid ${rarityStyle.border};color:${rarityStyle.color};`;
                            header.appendChild(rarityBadge);
                        }

                        li.appendChild(header);

                        if (item.description) {
                            const descriptionBlock = doc.createElement('div');
                            descriptionBlock.style.cssText = 'font-size:11px;line-height:1.4;color:#cbd5f5;opacity:0.9;';
                            const sanitized = this.sanitizeHtml(doc, item.description);
                            if (sanitized) {
                                descriptionBlock.appendChild(sanitized);
                            } else {
                                descriptionBlock.textContent = item.description;
                            }
                            li.appendChild(descriptionBlock);
                        }

                        list.appendChild(li);
                    });

                    itemsContainer.appendChild(list);
                    card.appendChild(itemsContainer);
                }

                if (summary.messages.length) {
                    const lastMessage = summary.messages[summary.messages.length - 1];
                    const messageBlock = doc.createElement('div');
                    messageBlock.style.cssText = 'font-size:12px;color:#cbd5f5;opacity:0.85;';
                    const sanitized = this.sanitizeHtml(doc, lastMessage);
                    if (sanitized) {
                        messageBlock.appendChild(sanitized);
                    } else {
                        messageBlock.textContent = lastMessage;
                    }
                    card.appendChild(messageBlock);
                }

                overlay.appendChild(card);
                host.appendChild(overlay);

                // Inject simple animation style once
                if (!doc.getElementById('autods-quickloot-modal-style')) {
                    const style = doc.createElement('style');
                    style.id = 'autods-quickloot-modal-style';
                    style.textContent = `
                        @keyframes autods-quickloot-fade-in {
                            from { opacity: 0; transform: scale(0.96); }
                            to { opacity: 1; transform: scale(1); }
                        }
                    `;
                    doc.head?.appendChild(style);
                }
            } catch (error) {
                context.logger.error(`Erro ao renderizar quick loot modal: ${error.message}`);
            }
        },
        cleanup() {
            // Limpar observers
            if (this.state.observers && Array.isArray(this.state.observers)) {
                this.state.observers.forEach(observer => {
                    try {
                        observer.disconnect();
                    } catch (error) {
                        console.warn('[FloatingHelpers] Erro ao desconectar observer:', error);
                    }
                });
                this.state.observers = [];
            }

            // Limpar timer de EXP potion
            if (this.state.expPotionTimer) {
                clearInterval(this.state.expPotionTimer);
                this.state.expPotionTimer = null;
            }

            // Remover container
            if (this.state.container) {
                this.state.container.remove();
                this.state.container = null;
            }
        }
    };

    const uiShellModule = {
        id: 'uiShell',
        match: () => true,
        init(context) {
            // Armazenar context para uso em addLog
            this._context = context;

            if (!this.state) {
                this.state = {
                    log: [],
                    logViewExpanded: false, // Controla se mostra todos os logs ou apenas 8
                    wave: { lastJoin: null },
                    battle: { lastResult: null },
                    farm: { lastPause: null },
                    farmProgress: { chapters: 0 },
                    pvp: { inBattle: false, lastResult: null },
                    toasts: []
                };
            }

            ensureLayoutStyles(context.document);
            ensureFloatingHelpersStyles(context.document);
            setPanelOffset(context.document, PANEL_WIDTH_PX);

            const { shadow } = context.ui;
            if (!shadow.querySelector('#autods-ui-style')) {
                const style = document.createElement('style');
                style.id = 'autods-ui-style';
                style.textContent = `
                    /* ========================================
                       AUTODS MODERN UI - Design System
                       Catppuccin-inspired Dark Theme
                       ======================================== */
                    
                    :host {
                        all: initial;
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
                        
                        /* Base Colors */
                        --bg-base: #11111b;
                        --bg-surface: #181825;
                        --bg-overlay: #1e1e2e;
                        --bg-mantle: #292945;
                        
                        /* Accent Colors */
                        --accent-primary: #89b4fa;
                        --accent-secondary: #cba6f7;
                        --accent-tertiary: #f5c2e7;
                        
                        /* Semantic Colors */
                        --success: #a6e3a1;
                        --warning: #f9e2af;
                        --error: #f38ba8;
                        --info: #89dceb;
                        
                        /* Text Colors */
                        --text-primary: #cdd6f4;
                        --text-secondary: #bac2de;
                        --text-muted: #7f849c;
                        
                        /* Borders & Dividers */
                        --border-subtle: rgba(137, 180, 250, 0.1);
                        --border-normal: rgba(137, 180, 250, 0.2);
                        --border-strong: rgba(137, 180, 250, 0.3);
                        
                        /* Shadows */
                        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
                        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
                        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
                        --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.6);
                        
                        /* Spacing Scale */
                        --space-1: 0.25rem;
                        --space-2: 0.5rem;
                        --space-3: 0.75rem;
                        --space-4: 1rem;
                        --space-5: 1.25rem;
                        --space-6: 1.5rem;
                        --space-8: 2rem;
                        
                        /* Border Radius */
                        --radius-sm: 0.25rem;
                        --radius-md: 0.5rem;
                        --radius-lg: 0.75rem;
                        --radius-xl: 1rem;
                        --radius-full: 9999px;
                        
                        /* Typography */
                        --text-xs: 0.55rem;
                        --text-sm: 0.675rem;
                        --text-base: 0.7rem;
                        --text-lg: 0.8rem;
                        --text-xl: 0.9rem;
                        
                        --leading-tight: 1.25;
                        --leading-normal: 1.5;
                        --leading-relaxed: 1.75;
                        
                        --weight-normal: 400;
                        --weight-medium: 500;
                        --weight-semibold: 600;
                        --weight-bold: 700;
                    }

                    #autods-shell {
                        position: fixed;
                        top: 0;
                        right: 0;
                        z-index: 99999999999;
                        background: linear-gradient(135deg, var(--bg-surface) 0%, var(--bg-base) 100%);
                        border: 1px solid var(--border-normal);
                        border-radius: var(--radius-xl) 0 0 var(--radius-xl);
                        color: var(--text-primary);
                        min-width: 280px;
                        width: var(--autods-panel-width, 380px);
                        max-width: 540px;
                        height: 100vh;
                        box-shadow: var(--shadow-xl);
                        font-size: var(--text-sm);
                        line-height: var(--leading-normal);
                        backdrop-filter: blur(12px);
                        overflow: hidden auto;
                        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s ease;
                    }
                    
                    #autods-shell[data-mobile-collapsed="1"] {
                        opacity: 0;
                        pointer-events: none;
                    }
                    
                    #autods-shell[data-mobile-collapsed="0"] {
                        opacity: 1;
                        pointer-events: auto;
                    }
                    
                    .autods-layout {
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-4);
                        min-height: 100%;
                    }
                    
                    .autods-panel {
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-4);
                        padding: var(--space-4);
                    }
                    /* Header Modernizado */
                    .autods-header {
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-2);
                        padding-bottom: var(--space-3);
                        border-bottom: 1px solid var(--border-subtle);
                    }
                    
                    .autods-header-main {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        gap: var(--space-3);
                    }
                    
                    .autods-header-title {
                        display: flex;
                        align-items: baseline;
                        gap: var(--space-3);
                        flex: 1;
                        min-width: 0;
                    }
                    
                    .autods-header-main strong {
                        font-size: var(--text-lg);
                        font-weight: var(--weight-bold);
                        letter-spacing: 0.02em;
                        color: var(--accent-primary);
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                        background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
                        -webkit-background-clip: text;
                        -webkit-text-fill-color: transparent;
                        background-clip: text;
                    }
                    
                    .autods-chip {
                        display: inline-flex;
                        align-items: center;
                        gap: var(--space-1);
                        padding: var(--space-1) var(--space-3);
                        border-radius: var(--radius-full);
                        font-size: var(--text-xs);
                        background: linear-gradient(135deg, rgba(137, 180, 250, 0.2) 0%, rgba(203, 166, 247, 0.2) 100%);
                        color: var(--accent-primary);
                        border: 1px solid var(--border-normal);
                        font-weight: var(--weight-semibold);
                        flex-shrink: 0;
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-panel-close {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 2.5rem;
                        height: 2.5rem;
                        background: var(--bg-overlay);
                        border: 1px solid var(--border-normal);
                        border-radius: var(--radius-md);
                        color: var(--text-secondary);
                        font-size: var(--text-xl);
                        line-height: 1;
                        cursor: pointer;
                        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                        flex-shrink: 0;
                        padding: 0;
                    }
                    
                    .autods-panel-close:hover {
                        background: linear-gradient(135deg, rgba(243, 139, 168, 0.3), rgba(235, 160, 172, 0.3));
                        border-color: var(--error);
                        color: var(--error);
                        transform: scale(1.05);
                        box-shadow: var(--shadow-md);
                    }
                    
                    .autods-panel-close:active {
                        transform: scale(0.95);
                    }
                    
                    .autods-route {
                        font-size: var(--text-xs);
                        color: var(--text-muted);
                        font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
                        word-break: break-all;
                        padding: var(--space-2) var(--space-3);
                        background: var(--bg-overlay);
                        border-radius: var(--radius-md);
                        border: 1px solid var(--border-subtle);
                    }
                    .autods-section { display: flex; flex-direction: column; gap: 6px; }
                    .autods-section-header { display: flex; align-items: center; gap: 8px; justify-content: space-between; padding: 0 2px; flex-wrap: nowrap; }
                    .autods-section-header h4 { flex: 1; margin: 0; font-size: 11px; font-weight: 700; letter-spacing: 0.45px; text-transform: uppercase; color: rgba(140, 190, 255, 0.9); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; min-width: 0; }
                    .autods-section-actions { display: inline-flex; align-items: center; gap: 4px; flex-shrink: 0; flex-wrap: nowrap; }
                    .autods-section-actions button { background: none; border: 1px solid rgba(70, 130, 220, 0.3); color: rgba(200, 220, 255, 0.9); font-size: 9px; padding: 3px 6px; border-radius: 6px; cursor: pointer; transition: background 0.2s ease, border 0.2s ease; white-space: nowrap; }
                    .autods-section-actions button:hover { background: rgba(70, 130, 220, 0.25); border-color: rgba(70, 130, 220, 0.5); }
                    @media (max-width: 480px) {
                        .autods-section-actions button { font-size: 8px; padding: 2px 5px; }
                    }
                    .autods-section-collapse { background: none; border: 1px solid rgba(70, 130, 220, 0.4); color: rgba(200, 220, 255, 0.9); border-radius: 50%; width: 20px; height: 20px; font-size: 11px; line-height: 1; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.2s ease, transform 0.2s ease; flex-shrink: 0; }
                    .autods-section-collapse:hover { background: rgba(70, 130, 220, 0.3); }
                    .autods-section[data-collapsed="1"] .autods-section-collapse { transform: rotate(-90deg); }
                    .autods-section-body { display: flex; flex-direction: column; gap: 8px; }
                    .autods-config-body { display: grid; gap: 10px; }
                    @media (min-width: 520px) {
                        .autods-config-body { grid-template-columns: minmax(270px, 1fr) 200px; align-items: start; }
                    }
                    .autods-config-forms { display: flex; flex-direction: column; gap: 10px; }
                    .autods-config-group { background: rgba(10, 20, 35, 0.7); border: 1px solid rgba(70, 130, 220, 0.25); border-radius: 10px; padding: 10px 12px; display: flex; flex-direction: column; gap: 8px; }
                    .autods-config-group h5 { margin: 0; font-size: 11px; text-transform: uppercase; letter-spacing: 0.45px; color: rgba(140, 190, 255, 0.9); }
                    .autods-config-field { display: flex; flex-direction: column; gap: 4px; font-size: 11px; }
                    .autods-config-field label { font-weight: 600; color: rgba(200, 220, 255, 0.9); display: flex; justify-content: space-between; gap: 8px; }
                    .autods-config-field small { color: rgba(180, 200, 235, 0.6); font-size: 10px; font-weight: 400; }
                    .autods-config-field input,
                    .autods-config-field select,
                    .autods-config-field textarea { width: 100%; background: rgba(20, 40, 70, 0.4); border: 1px solid rgba(70, 130, 220, 0.3); border-radius: 8px; color: #e8f0ff; padding: 6px 8px; font-size: 11px; font-family: inherit; resize: vertical; min-height: 30px; }
                    .autods-config-field textarea { min-height: 48px; }
                    .autods-config-field input:focus,
                    .autods-config-field select:focus,
                    .autods-config-field textarea:focus { outline: none; border-color: rgba(70, 130, 220, 0.6); box-shadow: 0 0 0 1px rgba(70, 130, 220, 0.4); }
                    .autods-config-field input.invalid,
                    .autods-config-field select.invalid,
                    .autods-config-field textarea.invalid { border-color: #ff6b6b; box-shadow: 0 0 0 1px rgba(255,107,107,0.35); }
                    .autods-section[data-collapsed="1"] .autods-section-body { display: none; }
                    .autods-toggle-list { display: flex; flex-direction: column; gap: 6px; }
                    .autods-toggle { display: flex; align-items: center; justify-content: space-between; gap: 6px; padding: 6px 8px; background: rgba(255,255,255,0.05); border-radius: 9px; transition: background 0.2s ease; }
                    .autods-toggle:hover { background: rgba(255,255,255,0.08); }
                    .autods-toggle span.label { font-weight: 600; color: #f1f5f4; font-size: 11px; }
                    .autods-toggle input[type="checkbox"] { width: 34px; height: 16px; accent-color: #4a9eff; cursor: pointer; }
                    .autods-log { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 5px; max-height: 120px; overflow-y: auto; }
                    .autods-log li { display: flex; align-items: baseline; gap: 6px; padding: 5px 7px; border-radius: 8px; background: rgba(20, 40, 70, 0.4); font-size: 11px; border-left: 3px solid transparent; }
                    .autods-log li .time { font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size: 10px; color: rgba(120, 180, 255, 0.8); }
                    .autods-log li .message { flex: 1; color: #e8f0ff; }
                    .autods-log li[data-level="warn"] { border-left-color: #f7b733; }
                    .autods-log li[data-level="error"] { border-left-color: #ff6b6b; }
                    .autods-log li[data-level="success"] { border-left-color: #4a9eff; }
                    .autods-log li[data-level="info"] { border-left-color: rgba(70, 130, 220, 0.7); }
                    .autods-log li.empty { justify-content: center; color: rgba(229,229,229,0.55); border-left-color: transparent; }
                    .autods-metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px; }
                    .autods-metric-card { background: rgba(20, 40, 80, 0.4); border-radius: 9px; padding: 8px 10px; display: flex; flex-direction: column; gap: 3px; border: 1px solid rgba(70, 130, 220, 0.25); }
                    .autods-metric-card strong { font-size: 19px; font-weight: 700; color: #b8d8ff; letter-spacing: 0.8px; }
                    .autods-metric-card span.label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.55px; color: rgba(140, 190, 255, 0.75); }
                    .autods-metric-card span.sub { font-size: 10px; color: rgba(120, 170, 235, 0.6); }
                    .autods-toast-container { position: fixed; inset: auto 16px 16px auto; display: flex; flex-direction: column; gap: 8px; pointer-events: none; }
                    .autods-toast { display: flex; gap: 8px; align-items: flex-start; background: rgba(10, 20, 35, 0.95); border: 1px solid rgba(70, 130, 220, 0.4); border-radius: 9px; padding: 8px 10px; box-shadow: 0 10px 20px rgba(0,0,0,0.35); pointer-events: auto; animation: fade-in 0.2s ease forwards; font-size: 11px; }
                    .autods-toast .body { display: flex; flex-direction: column; gap: 2px; }
                    .autods-toast .title { font-weight: 600; color: #a8d0ff; font-size: 11px; }
                    .autods-toast .message { font-size: 11px; color: rgba(200, 220, 255, 0.9); }
                    .autods-toast .time { font-size: 10px; color: rgba(140, 180, 235, 0.7); }
                    .autods-toast[data-level="warn"] { border-color: #f7b733; }
                    .autods-toast[data-level="error"] { border-color: #ff6b6b; }
                    .autods-toast[data-level="success"] { border-color: #4a9eff; }
                    .autods-toast[data-level="info"] { border-color: rgba(70, 130, 220, 0.6); }
                    @keyframes fade-in { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

                    /* Mobile-First Responsive Design */
                    @media (max-width: 768px) {
                        #autods-shell { width: 85vw !important; max-width: 400px; border-radius: 0 12px 12px 0; font-size: 11px; }
                        .autods-panel { padding: 12px; gap: 10px; }
                        .autods-header-main strong { font-size: 12px; }
                        .autods-chip { font-size: 9px; padding: 1px 6px; }
                        .autods-section-header h4 { font-size: 10px; }
                        .autods-section-actions button { font-size: 8px; padding: 2px 5px; }
                        .autods-config-field { font-size: 10px; }
                        .autods-config-field input,
                        .autods-config-field select,
                        .autods-config-field textarea { font-size: 10px; padding: 5px 7px; min-height: 28px; }
                        .autods-config-field textarea { min-height: 42px; }
                        .autods-metrics-grid { grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)); gap: 6px; }
                        .autods-metric-card { padding: 6px 8px; }
                        .autods-metric-card strong { font-size: 16px; }
                        .autods-log { max-height: 100px; font-size: 10px; }
                        .autods-log li { font-size: 10px; padding: 4px 6px; }
                        .autods-toggle span.label { font-size: 10px; }
                        .autods-toast { font-size: 10px; padding: 7px 9px; }
                    }

                    @media (max-width: 480px) {
                        #autods-shell { width: 100vw !important; max-width: 100vw; border-radius: 0; height: 100vh; border: none; border-right: 1px solid rgba(70, 130, 220, 0.35); }
                        #autods-shell[data-mobile-collapsed="1"] { opacity: 0; pointer-events: none; }
                        .autods-panel { padding: 10px; gap: 8px; }
                        .autods-header-main { flex-direction: row !important; align-items: center !important; gap: 6px; }
                        .autods-header-title { flex-direction: row; align-items: center; gap: 6px; }
                        .autods-header-main strong { font-size: 11px; }
                        .autods-chip { font-size: 8px; padding: 1px 5px; }
                        .autods-panel-close { width: 32px; height: 32px; font-size: 18px; }
                        .autods-route { font-size: 10px; }
                        .autods-section { gap: 4px; }
                        .autods-section-header { gap: 6px; padding: 0; }
                        .autods-section-header h4 { font-size: 9px; letter-spacing: 0.3px; }
                        .autods-section-actions { gap: 3px; }
                        .autods-section-actions button { font-size: 7px; padding: 2px 4px; border-radius: 5px; }
                        .autods-section-collapse { width: 18px; height: 18px; font-size: 10px; }
                        .autods-section-body { gap: 6px; }
                        .autods-config-group { padding: 8px 10px; gap: 6px; border-radius: 8px; }
                        .autods-config-group h5 { font-size: 10px; }
                        .autods-config-field { gap: 3px; font-size: 9px; }
                        .autods-config-field label { gap: 6px; }
                        .autods-config-field small { font-size: 9px; }
                        .autods-config-field input,
                        .autods-config-field select,
                        .autods-config-field textarea { font-size: 9px; padding: 5px 6px; min-height: 26px; border-radius: 6px; }
                        .autods-config-field textarea { min-height: 38px; }
                        .autods-toggle { padding: 5px 6px; border-radius: 7px; }
                        .autods-toggle span.label { font-size: 9px; }
                        .autods-toggle input[type="checkbox"] { width: 30px; height: 14px; }
                        .autods-metrics-grid { grid-template-columns: repeat(2, 1fr); gap: 5px; }
                        .autods-metric-card { padding: 6px 7px; gap: 2px; border-radius: 7px; }
                        .autods-metric-card strong { font-size: 15px; letter-spacing: 0.5px; }
                        .autods-metric-card span.label { font-size: 9px; letter-spacing: 0.4px; }
                        .autods-metric-card span.sub { font-size: 9px; }
                        .autods-log { max-height: 90px; gap: 4px; }
                        .autods-log li { padding: 4px 5px; gap: 5px; font-size: 9px; border-radius: 6px; }
                        .autods-log li .time { font-size: 9px; }
                        .autods-toast-container { inset: auto 8px 8px auto; gap: 6px; max-width: calc(100vw - 16px); }
                        .autods-toast { font-size: 9px; padding: 6px 7px; gap: 6px; border-radius: 7px; max-width: 100%; }
                        .autods-toast .title { font-size: 10px; }
                        .autods-toast .message { font-size: 9px; line-height: 1.3; }
                        .autods-toast .time { font-size: 9px; }
                    }

                    @media (max-width: 360px) {
                        .autods-panel { padding: 8px; gap: 6px; }
                        .autods-header-main strong { font-size: 10px; }
                        .autods-chip { font-size: 7px; }
                        .autods-section-header h4 { font-size: 8px; }
                        .autods-section-actions button { font-size: 6px; padding: 2px 3px; }
                        .autods-config-field input,
                        .autods-config-field select,
                        .autods-config-field textarea { font-size: 8px; padding: 4px 5px; }
                        .autods-metric-card strong { font-size: 13px; }
                        .autods-metrics-grid { grid-template-columns: 1fr 1fr; }
                    }

                    /* Tab System Modernizado */
                    .autods-tabs-main {
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-1);
                        padding: var(--space-2) var(--space-3);
                        background: var(--bg-overlay);
                        border-bottom: 2px solid var(--border-normal);
                        overflow-x: auto;
                        scroll-behavior: smooth;
                        -webkit-overflow-scrolling: touch;
                        flex-wrap: nowrap;
                    }

                    .autods-tabs-main .autods-tab {
                        flex: 0 1 auto;
                        padding: var(--space-2) var(--space-3);
                        white-space: nowrap;
                        min-width: 75px;
                        font-size: 12px;
                    }

                    .autods-tabs-content {
                        padding: var(--space-4);
                        background: var(--bg-base);
                    }

                    .autods-tab-content {
                        display: none;
                        animation: fadeIn 0.2s ease-in-out;
                    }

                    .autods-tab-content[style*="display: block"] {
                        display: block;
                    }

                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }

                    /* Mobile Responsiveness for Tab System */
                    @media (max-width: 768px) {
                        .autods-tabs-main {
                            gap: var(--space-1);
                            padding: var(--space-2) var(--space-3);
                            overflow-x: auto;
                        }

                        .autods-tabs-main .autods-tab {
                            padding: var(--space-2) var(--space-3);
                            min-width: 70px;
                            font-size: 12px;
                        }

                        .autods-tabs-content {
                            padding: var(--space-3);
                        }

                        #autods-main-tab-buttons {
                            flex-wrap: wrap;
                            gap: var(--space-1);
                        }

                        #autods-main-tab-buttons button {
                            min-width: 70px;
                            padding: 8px 12px;
                            font-size: 12px;
                        }
                    }

                    @media (max-width: 480px) {
                        .autods-tabs-main {
                            gap: 4px;
                            padding: 8px 10px;
                            border-bottom: 1px solid var(--border-normal);
                        }

                        .autods-tabs-main .autods-tab {
                            padding: 8px 10px;
                            min-width: 60px;
                            font-size: 11px;
                            flex: 0 1 auto;
                            border-radius: 6px;
                        }

                        .autods-tabs-main .autods-tab.active {
                            min-height: 36px;
                        }

                        .autods-tabs-content {
                            padding: var(--space-2);
                        }

                        .autods-tab-content {
                            padding: 8px 0;
                        }

                        .autods-config-field {
                            gap: 4px;
                        }

                        .autods-config-field input,
                        .autods-config-field select,
                        .autods-config-field textarea {
                            font-size: 13px;
                            min-height: 40px;
                        }

                        #autods-main-tab-buttons {
                            position: fixed;
                            bottom: 8px;
                            right: 8px;
                            flex-direction: column;
                            gap: 6px;
                            z-index: 9999;
                        }

                        #autods-main-tab-buttons button {
                            min-width: 48px;
                            min-height: 48px;
                            padding: 10px;
                            font-size: 20px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        }
                    }

                    @media (max-width: 360px) {
                        .autods-tabs-main {
                            gap: 2px;
                            padding: 6px 8px;
                        }

                        .autods-tabs-main .autods-tab {
                            padding: 6px 8px;
                            min-width: 50px;
                            font-size: 10px;
                        }

                        .autods-tabs-content {
                            padding: 8px;
                        }

                        #autods-main-tab-buttons button {
                            min-width: 44px;
                            min-height: 44px;
                            padding: 8px;
                        }

                        .autods-config-field input,
                        .autods-config-field select,
                        .autods-config-field textarea {
                            font-size: 12px;
                            min-height: 38px;
                        }
                    }

                    /* Config Dropdowns Modernizados */
                    .autods-config-groups {
                        padding: var(--space-3);
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-3);
                    }
                    
                    .autods-config-dropdown {
                        background: var(--bg-surface);
                        border-radius: var(--radius-lg);
                        border: 1px solid var(--border-subtle);
                        overflow: hidden;
                        transition: all 0.3s ease;
                    }
                    
                    .autods-config-dropdown:hover {
                        border-color: var(--border-normal);
                        box-shadow: var(--shadow-md);
                    }
                    
                    .autods-dropdown-header {
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        width: 100%;
                        padding: var(--space-4);
                        background: linear-gradient(180deg, var(--bg-mantle) 0%, transparent 100%);
                        border: none;
                        color: var(--text-primary);
                        cursor: pointer;
                        transition: all 0.2s ease;
                        font-size: var(--text-base);
                        font-weight: var(--weight-semibold);
                        font-family: inherit;
                        gap: var(--space-3);
                    }
                    
                    .autods-dropdown-header:hover {
                        background: linear-gradient(180deg, rgba(137, 180, 250, 0.1) 0%, transparent 100%);
                    }
                    
                    .dropdown-icon {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 1.25rem;
                        height: 1.25rem;
                        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        font-size: var(--text-sm);
                        color: var(--accent-primary);
                    }
                    
                    .autods-dropdown-header.active .dropdown-icon {
                        transform: rotate(90deg);
                    }
                    
                    .dropdown-title {
                        flex: 1;
                        text-align: left;
                        display: flex;
                        align-items: center;
                        gap: var(--space-2);
                    }
                    
                    .dropdown-status {
                        font-size: var(--text-xs);
                        padding: var(--space-1) var(--space-3);
                        border-radius: var(--radius-full);
                        font-weight: var(--weight-semibold);
                        display: inline-flex;
                        align-items: center;
                        gap: var(--space-1);
                    }
                    
                    .dropdown-status[data-active="true"] {
                        background: linear-gradient(135deg, rgba(166, 227, 161, 0.3), rgba(148, 226, 213, 0.3));
                        color: var(--success);
                        border: 1px solid rgba(166, 227, 161, 0.4);
                    }
                    
                    .dropdown-status[data-active="false"] {
                        background: rgba(127, 132, 156, 0.2);
                        color: var(--text-muted);
                        border: 1px solid var(--border-subtle);
                    }
                    
                    .autods-dropdown-content {
                        padding: var(--space-4);
                        border-top: 1px solid var(--border-subtle);
                        animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    }
                    
                    @keyframes slideDown {
                        from {
                            opacity: 0;
                            max-height: 0;
                            padding-top: 0;
                            padding-bottom: 0;
                        }
                        to {
                            opacity: 1;
                            max-height: 2000px;
                            padding-top: var(--space-4);
                            padding-bottom: var(--space-4);
                        }
                    }

                    /* Tabs Modernizadas */
                    .autods-tabs {
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-1);
                        margin-bottom: var(--space-4);
                        padding: var(--space-1);
                        background: var(--bg-overlay);
                        border-radius: var(--radius-lg);
                        border: 1px solid var(--border-subtle);
                        position: relative;
                    }
                    
                    .autods-tab {
                        flex: 1;
                        padding: var(--space-3) var(--space-4);
                        background: transparent;
                        border: none;
                        border-radius: var(--radius-md);
                        color: var(--text-muted);
                        cursor: pointer;
                        font-size: var(--text-sm);
                        font-weight: var(--weight-medium);
                        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        text-align: center;
                        font-family: inherit;
                        position: relative;
                        z-index: 1;
                    }
                    
                    .autods-tab:hover {
                        color: var(--text-secondary);
                        background: rgba(137, 180, 250, 0.05);
                    }
                    
                    .autods-tab.active {
                        background: linear-gradient(135deg, rgba(137, 180, 250, 0.2), rgba(203, 166, 247, 0.2));
                        color: var(--accent-primary);
                        font-weight: var(--weight-semibold);
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-tab.active::after {
                        content: '';
                        position: absolute;
                        bottom: -4px;
                        left: 50%;
                        transform: translateX(-50%);
                        width: 60%;
                        height: 3px;
                        background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
                        border-radius: var(--radius-full);
                    }
                    
                    .autods-tab-content {
                        display: none;
                        animation: fadeIn 0.3s ease-out;
                    }
                    
                    .autods-tab-content.active {
                        display: block;
                    }
                    
                    @keyframes fadeIn {
                        from {
                            opacity: 0;
                            transform: translateY(8px);
                        }
                        to {
                            opacity: 1;
                            transform: translateY(0);
                        }
                    }

                    /* Form Fields Modernizados */
                    .autods-field-row {
                        display: flex;
                        gap: var(--space-3);
                        margin-bottom: var(--space-3);
                        flex-wrap: wrap;
                    }
                    
                    .autods-field {
                        flex: 1;
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-2);
                        min-width: 120px;
                    }
                    
                    .autods-field-small {
                        flex: 0 0 100px;
                    }
                    
                    .autods-field > span {
                        font-size: var(--text-xs);
                        font-weight: var(--weight-medium);
                        color: var(--text-secondary);
                        text-transform: uppercase;
                        letter-spacing: 0.05em;
                    }
                    
                    .autods-field input,
                    .autods-field select,
                    .autods-field textarea {
                        padding: var(--space-3) var(--space-4);
                        background: var(--bg-overlay);
                        border: 2px solid var(--border-normal);
                        border-radius: var(--radius-lg);
                        color: var(--text-primary);
                        font-size: var(--text-sm);
                        font-family: inherit;
                        resize: vertical;
                        transition: all 0.2s ease;
                    }
                    
                    .autods-field input::placeholder,
                    .autods-field textarea::placeholder {
                        color: var(--text-muted);
                    }
                    
                    .autods-field input:hover,
                    .autods-field select:hover,
                    .autods-field textarea:hover {
                        border-color: var(--border-strong);
                    }
                    
                    .autods-field input:focus,
                    .autods-field select:focus,
                    .autods-field textarea:focus {
                        outline: none;
                        border-color: var(--accent-primary);
                        box-shadow: 0 0 0 3px rgba(137, 180, 250, 0.1);
                        background: var(--bg-base);
                    }
                    
                    .autods-field output {
                        display: block;
                        text-align: center;
                        margin-top: var(--space-1);
                        font-size: var(--text-sm);
                        font-weight: var(--weight-semibold);
                        color: var(--success);
                        padding: var(--space-1) var(--space-2);
                        background: rgba(166, 227, 161, 0.1);
                        border-radius: var(--radius-md);
                    }
                    
                    .autods-field small {
                        font-size: var(--text-xs);
                        color: var(--text-muted);
                        font-style: italic;
                        margin-top: var(--space-1);
                        line-height: var(--leading-relaxed);
                    }

                    /* Checkboxes Modernizados */
                    .autods-checkbox {
                        display: flex;
                        align-items: center;
                        gap: var(--space-3);
                        padding: var(--space-3) var(--space-4);
                        background: var(--bg-overlay);
                        border: 1px solid var(--border-subtle);
                        border-radius: var(--radius-lg);
                        cursor: pointer;
                        font-size: var(--text-sm);
                        margin: var(--space-2) 0;
                        transition: all 0.2s ease;
                    }
                    
                    .autods-checkbox:hover {
                        background: rgba(137, 180, 250, 0.1);
                        border-color: var(--border-normal);
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-checkbox input {
                        width: 1.25rem;
                        height: 1.25rem;
                        cursor: pointer;
                        accent-color: var(--accent-primary);
                        position: relative;
                    }
                    
                    .autods-checkbox input:checked {
                        filter: drop-shadow(0 0 4px rgba(137, 180, 250, 0.5));
                    }
                    
                    .autods-checkbox:has(input:checked) {
                        background: linear-gradient(135deg, rgba(137, 180, 250, 0.15), rgba(203, 166, 247, 0.15));
                        border-color: var(--accent-primary);
                    }

                    /* Subsections Modernizadas */
                    .autods-subsection {
                        margin: var(--space-4) 0;
                        padding: var(--space-4);
                        background: var(--bg-overlay);
                        border-radius: var(--radius-lg);
                        border: 1px solid var(--border-subtle);
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-subsection h5 {
                        margin: 0 0 var(--space-3) 0;
                        font-size: var(--text-sm);
                        font-weight: var(--weight-semibold);
                        text-transform: uppercase;
                        letter-spacing: 0.05em;
                        color: var(--accent-primary);
                        display: flex;
                        align-items: center;
                        gap: var(--space-2);
                    }
                    
                    .autods-subsection h5::before {
                        content: '';
                        width: 3px;
                        height: 1rem;
                        background: linear-gradient(180deg, var(--accent-primary), var(--accent-secondary));
                        border-radius: var(--radius-full);
                    }
                    
                    .autods-subsection-title {
                        margin: var(--space-5) 0 var(--space-3) 0;
                        font-size: var(--text-sm);
                        font-weight: var(--weight-bold);
                        letter-spacing: 0.05em;
                        text-transform: uppercase;
                        color: var(--accent-secondary);
                        border-bottom: 2px solid var(--border-normal);
                        padding-bottom: var(--space-2);
                        display: flex;
                        align-items: center;
                        gap: var(--space-2);
                    }

                    /* Warning Message Modernizada */
                    .autods-warning {
                        margin: var(--space-3) 0;
                        padding: var(--space-4);
                        background: linear-gradient(135deg, rgba(249, 226, 175, 0.15), rgba(251, 191, 36, 0.1));
                        border: 1px solid var(--warning);
                        border-left: 4px solid var(--warning);
                        border-radius: var(--radius-lg);
                        font-size: var(--text-sm);
                        line-height: var(--leading-relaxed);
                        color: var(--warning);
                        display: flex;
                        gap: var(--space-3);
                        align-items: flex-start;
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-warning::before {
                        content: 'âš ï¸';
                        font-size: var(--text-lg);
                        flex-shrink: 0;
                    }
                    
                    /* Info Message Modernizada */
                    .autods-info {
                        margin: var(--space-3) 0;
                        padding: var(--space-4);
                        background: linear-gradient(135deg, rgba(137, 220, 235, 0.15), rgba(137, 180, 250, 0.1));
                        border: 1px solid var(--info);
                        border-left: 4px solid var(--info);
                        border-radius: var(--radius-lg);
                        font-size: var(--text-sm);
                        line-height: var(--leading-relaxed);
                        color: var(--info);
                        display: flex;
                        gap: var(--space-3);
                        align-items: flex-start);
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-info::before {
                        content: 'â„¹ï¸';
                        font-size: var(--text-lg);
                        flex-shrink: 0;
                    }
                    
                    /* Button System Modernizado */
                    .autods-btn {
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        gap: var(--space-2);
                        padding: var(--space-3) var(--space-5);
                        border-radius: var(--radius-lg);
                        border: 2px solid var(--border-normal);
                        background: linear-gradient(135deg, rgba(137, 180, 250, 0.2), rgba(203, 166, 247, 0.2));
                        color: var(--accent-primary);
                        font-size: var(--text-sm);
                        font-weight: var(--weight-medium);
                        cursor: pointer;
                        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                        font-family: inherit;
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .autods-btn::before {
                        content: '';
                        position: absolute;
                        inset: 0;
                        background: linear-gradient(135deg, transparent, rgba(137, 180, 250, 0.2));
                        opacity: 0;
                        transition: opacity 0.3s ease;
                    }
                    
                    .autods-btn:hover {
                        border-color: var(--accent-primary);
                        box-shadow: 0 0 0 3px rgba(137, 180, 250, 0.1), var(--shadow-md);
                        transform: translateY(-2px);
                    }
                    
                    .autods-btn:hover::before {
                        opacity: 1;
                    }
                    
                    .autods-btn:active {
                        transform: translateY(0) scale(0.98);
                    }
                    
                    .autods-btn-success {
                        background: linear-gradient(135deg, rgba(166, 227, 161, 0.3), rgba(148, 226, 213, 0.3));
                        border-color: var(--success);
                        color: var(--success);
                    }
                    
                    .autods-btn-success:hover {
                        border-color: var(--success);
                        box-shadow: 0 0 0 3px rgba(166, 227, 161, 0.1), var(--shadow-md);
                    }
                    
                    .autods-btn-danger {
                        background: linear-gradient(135deg, rgba(243, 139, 168, 0.3), rgba(235, 160, 172, 0.3));
                        border-color: var(--error);
                        color: var(--error);
                    }
                    
                    .autods-btn-danger:hover {
                        border-color: var(--error);
                        box-shadow: 0 0 0 3px rgba(243, 139, 168, 0.1), var(--shadow-md);
                    }

                    /* Skill Grid */
                    .autods-skill-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 8px; padding: 8px; background: rgba(20, 20, 30, 0.4); border-radius: 4px; }
                    .autods-skill { display: flex; flex-direction: column; gap: 2px; }
                    .autods-skill span { font-size: 9px; color: #89b4fa; }
                    .autods-skill input { padding: 4px; font-size: 11px; background: rgba(30, 30, 46, 0.6); border: 1px solid rgba(137, 180, 250, 0.3); border-radius: 4px; color: #e0e0e0; font-family: inherit; }



                    /* Events Mini */
                    .autods-events-mini { margin-top: auto; padding-top: 8px; border-top: 1px solid rgba(70, 130, 220, 0.3); }
                    .autods-events-header { display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: rgba(30, 30, 46, 0.6); border-radius: 6px 6px 0 0; font-size: 11px; font-weight: 600; }
                    .autods-events-header button { background: none; border: none; color: rgba(200, 220, 255, 0.9); font-size: 14px; cursor: pointer; padding: 0; transition: transform 0.2s; }
                    .autods-events-header button:hover { transform: scale(1.1); }
                    .autods-events-list { max-height: 100px; overflow-y: auto; padding: 4px; background: rgba(20, 20, 30, 0.4); border-radius: 0 0 6px 6px; }
                    .autods-events-list .autods-log { margin: 0; padding: 0; max-height: none; }

                    /* Responsive Design Modernizado */
                    
                    /* Tablet (768px - 1024px) */
                    @media (max-width: 1024px) {
                        #autods-shell {
                            width: 400px;
                        }
                    }
                    
                    /* Mobile Large (481px - 768px) */
                    @media (max-width: 768px) {
                        :host {
                            --space-4: 0.875rem;
                            --space-6: 1.25rem;
                        }
                        
                        #autods-shell {
                            width: 90vw;
                            max-width: 420px;
                            font-size: calc(var(--text-sm) * 0.95);
                        }
                        
                        .autods-header-main strong {
                            font-size: var(--text-base);
                        }
                        
                        .autods-tab {
                            font-size: var(--text-sm);
                            padding: var(--space-3);
                        }
                        
                        .autods-tab {
                            font-size: var(--text-xs);
                            padding: var(--space-2) var(--space-3);
                        }
                        
                        .autods-field input,
                        .autods-field select,
                        .autods-field textarea {
                            font-size: var(--text-xs);
                            padding: var(--space-2) var(--space-3);
                        }
                        
                        .autods-checkbox {
                            font-size: var(--text-xs);
                            padding: var(--space-2) var(--space-3);
                        }
                        
                        .autods-btn {
                            padding: var(--space-2) var(--space-4);
                            font-size: var(--text-xs);
                        }
                    }

                    /* Mobile (320px - 480px) */
                    @media (max-width: 480px) {
                        :host {
                            --space-4: 0.75rem;
                            --space-6: 1rem;
                            --text-base: 0.9375rem;
                        }
                        
                        #autods-shell {
                            width: 100vw !important;
                            max-width: 100vw;
                            border-radius: 0;
                            border-right: 1px solid var(--border-normal);
                        }
                        
                        .autods-panel {
                            padding: var(--space-3);
                        }
                        
                        .autods-header-main strong {
                            font-size: var(--text-sm);
                        }
                        
                        .autods-chip {
                            font-size: 0.65rem;
                            padding: 0 var(--space-2);
                        }
                        
                        .autods-dropdown-header {
                            font-size: var(--text-xs);
                            padding: var(--space-2);
                        }
                        
                        .autods-tab {
                            font-size: 0.7rem;
                            padding: var(--space-1) var(--space-2);
                        }
                        
                        .autods-field-row {
                            flex-direction: column;
                        }
                        
                        .autods-field input,
                        .autods-field select,
                        .autods-field textarea {
                            font-size: 0.8rem;
                            padding: var(--space-2);
                        }
                        
                        .autods-checkbox {
                            font-size: 0.8rem;
                            padding: var(--space-2);
                        }
                        
                        .autods-skill-grid {
                            grid-template-columns: 1fr;
                        }
                        
                        .autods-btn {
                            width: 100%;
                            padding: var(--space-3);
                        }
                    }
                    
                    /* Mobile Extra Small (< 360px) */
                    @media (max-width: 360px) {
                        .autods-dropdown-header {
                            font-size: 0.7rem;
                        }
                    }
                `;
                shadow.appendChild(style);
            }

            if (!shadow.querySelector('#autods-toast-root')) {
                const toastHost = document.createElement('div');
                toastHost.id = 'autods-toast-root';
                shadow.appendChild(toastHost);
                this.createToastContainer(toastHost, context);
            } else if (!this.toastContainer) {
                this.createToastContainer(shadow.querySelector('#autods-toast-root'), context);
            }

            let container = shadow.querySelector('#autods-shell');
            if (!container) {
                container = context.dom.create('div', { id: 'autods-shell' });
                container.innerHTML = this.template(context);
                shadow.appendChild(container);
            }

            // Create mobile toggle button in document (not shadow DOM) so it's always visible
            this.ensureMobileToggle(context, container);
            // Create desktop toggle button (visible when panel is collapsed)
            this.ensureDesktopToggle(context, container);

            // Show desktop toggle button if panel is minimized
            if (this.desktopToggleButton && container.getAttribute('data-mobile-collapsed') === '1') {
                this.desktopToggleButton.classList.add('visible');
            }

            this.cacheElements(container);
            this.bind(context);
            this.render(context);
            
            // Restore dropdown states after DOM is fully ready
            requestAnimationFrame(() => {
                this.restoreDropdownStates(context);
            });
            
            // Check for Ultra Fast Boss auto-resume after potion reload
            setTimeout(() => {
                this.checkAndResumeUltraFastBoss(context);
            }, 1500);
        },
        template(context) {
            const uiConfig = context.config.get().ui || {};
            const panelStates = uiConfig.panelStates || {};
            const cfg = context.config.get();
            return `
                <div class="autods-layout">
                    <div class="autods-panel">
                        <div class="autods-header">
                            <div class="autods-header-main">
                                <div class="autods-header-title">
                                    <strong>AutoDS</strong>
                                    <span class="autods-chip">v<span data-meta="version"></span></span>
                                </div>
                                <button type="button" class="autods-panel-close" data-action="close-panel" aria-label="Minimizar" title="Minimizar (Ctrl+Shift+P)">âœ•</button>
                            </div>
                            <div class="autods-route"><code data-meta="route"></code></div>
                        </div>

                        <!-- Tab Navigation -->
                        <div class="autods-tabs-main">
                            <button class="autods-tab active" data-tab="quick">ðŸŽ¯ RÃ¡pido</button>
                            <button class="autods-tab" data-tab="ultrafastfarm">âš”ï¸ Ultra Fast Farm</button>
                            <button class="autods-tab" data-tab="specialboss">ðŸ‘‘ Special Boss</button>
                            <button class="autods-tab" data-tab="ultrafastattack">âš¡ Ultra Fast Attack</button>
                            <button class="autods-tab" data-tab="ultrafastloot">ðŸŽ Ultra Fast Loot</button>
                            <button class="autods-tab" data-tab="boss">ðŸ‰ Boss</button>
                            <button class="autods-tab" data-tab="dungeon">ðŸ° Dungeon</button>
                            <button class="autods-tab" data-tab="battle">ðŸ—¡ï¸ Battle</button>
                            <button class="autods-tab" data-tab="pvp">ðŸ† PvP</button>
                            <button class="autods-tab" data-tab="interface">âš™ï¸ Interface</button>
                        </div>

                        <!-- Tab Contents -->
                        <div class="autods-tabs-content">
                            <!-- Tab: RÃ¡pido -->
                            <div class="autods-tab-content active" data-tab-content="quick">
                                <div class="autods-status-panel">
                                    <h3>ðŸ“Š Status Geral</h3>
                                    <div class="autods-status-grid">
                                        <div class="autods-status-item">
                                            <label class="autods-checkbox">
                                                <input type="checkbox" data-config="core.enabled" data-label="Core" data-toast="0" />
                                                <span>ðŸ”Œ Core Habilitado</span>
                                            </label>
                                        </div>
                                        <div class="autods-status-item">
                                            <label class="autods-checkbox">
                                                <input type="checkbox" data-config="wave.ultraFastMode" data-label="Ultra Fast Wave" data-toast="0" />
                                                <span>âš¡ Ultra Fast Farm</span>
                                            </label>
                                        </div>
                                        <div class="autods-status-item">
                                            <label class="autods-checkbox">
                                                <input type="checkbox" data-config="ultraFastDungeon.enabled" data-label="Ultra Fast Dungeon" data-toast="0" />
                                                <span>ðŸ° Ultra Fast Dungeon</span>
                                            </label>
                                        </div>
                                        <div class="autods-status-item">
                                            <label class="autods-checkbox">
                                                <input type="checkbox" data-config="pvp.ultraFastMode" data-label="Ultra Fast PvP" data-toast="0" />
                                                <span>ðŸ† Ultra Fast PvP</span>
                                            </label>
                                        </div>
                                        <div class="autods-status-item">
                                            <label class="autods-checkbox">
                                                <input type="checkbox" data-config="specialBossFarm.enabled" data-label="Special Boss Farm" data-toast="0" />
                                                <span>ðŸ‘‘ Special Boss Farm</span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Tab: Ultra Fast Farm -->
                            <div class="autods-tab-content" data-tab-content="ultrafastfarm">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">âš”ï¸ Ultra Fast Farm</h4>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="wave.ultraFastMode" data-label="Ultra Fast Wave" data-toast="0" />
                                    <span>âš¡ Ativar Ultra Fast Mode</span>
                                </label>
                                <p class="autods-info" style="font-size:11px;">Modo paralelo de ataques rÃ¡pidos apÃ³s entrar na batalha.</p>
                                
                                <h6 style="margin-top:10px;margin-bottom:6px;font-size:11px;color:#aaa;">ðŸŽ¯ Filtro de Monstros</h6>
                                <label class="autods-field">
                                    <span>Incluir (Whitelist)</span>
                                    <textarea data-config="wave.ultraFastConfig.monsterFilter.includeNames" data-config-format="csv" data-label="Incluir Monstros" placeholder="Deixar vazio para incluir todos. Um nome por linha. Ex:
Orc Warrior
Troll Brawler" rows="2"></textarea>
                                </label>
                                <label class="autods-field">
                                    <span>Excluir (Blacklist)</span>
                                    <textarea data-config="wave.ultraFastConfig.monsterFilter.excludeNames" data-config-format="csv" data-label="Excluir Monstros" placeholder="Monstros a ignorar. Um nome por linha. Ex:
Mini Boss
Event Monster" rows="2"></textarea>
                                </label>
                                <p class="autods-info" style="font-size:10px;margin-top:4px;">Use <strong>Incluir</strong> para atacar APENAS esses monstros, ou <strong>Excluir</strong> para pular certos monstros.</p>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Skill</span>
                                        <select data-config="wave.ultraFastConfig.skillId" data-config-format="int" data-label="Ultra Fast Skill">
                                            <option value="0">Slash (1)</option>
                                            <option value="-1">Power (10)</option>
                                            <option value="-2">Heroic (50)</option>
                                            <option value="-3">Ultimate (100)</option>
                                            <option value="-4">Legendary (200)</option>
                                        </select>
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Dano Alvo</span>
                                        <input type="number" data-config="wave.ultraFastConfig.damageTarget" data-config-format="int" data-label="Dano Alvo" min="100000" step="100000" />
                                    </label>
                                </div>
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Ataques //</span>
                                        <input type="number" data-config="wave.ultraFastConfig.parallelAttacks" data-config-format="int" data-label="Ataques Paralelos" min="1" max="20" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="wave.ultraFastConfig.minDelayBetweenAttacks" data-config-format="int" data-label="Delay" min="10" step="10" />
                                    </label>
                                </div>
                                
                                <h6 style="margin-top:10px;margin-bottom:6px;font-size:11px;color:#aaa;">ðŸ’Š Auto Full Stamina Potion</h6>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="wave.ultraFastConfig.autoFSP" data-label="Auto FSP" data-toast="0" />
                                    <span>ðŸ’Š Auto FSP quando stamina baixa</span>
                                </label>
                                <label class="autods-field autods-field-small">
                                    <span>Stamina MÃ­n para FSP</span>
                                    <input type="number" data-config="wave.ultraFastConfig.minStaminaForFSP" data-config-format="int" data-label="Stamina MÃ­n FSP" min="0" step="10" />
                                </label>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="wave.ultraFastConfig.lootDeadBeforeFSP" data-label="Loot Dead antes FSP" data-toast="0" />
                                    <span>ðŸ’€ Lootar Dead Monsters antes de usar FSP</span>
                                </label>
                                <p class="autods-info" style="font-size:10px;margin-top:4px;">Tenta lootar dead monsters para recuperar stamina via level up antes de gastar FSP.</p>
                            </div>

                            <!-- Tab: Special Boss Farm -->
                            <div class="autods-tab-content" data-tab-content="specialboss">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">ðŸ‘‘ Special Boss Farm</h4>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="specialBossFarm.enabled" data-label="Special Boss Farm" data-toast="0" />
                                    <span>ðŸ‘‘ Farm Bosses Especiais (General/King/Empress/Bastion)</span>
                                </label>
                                <p class="autods-info" style="font-size:11px;">MÃ³dulo dedicado para garantir 50M de dano em bosses raros com loot especial.</p>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Dano Alvo</span>
                                        <input type="number" data-config="specialBossFarm.targetDamage" data-config-format="int" data-label="Dano Alvo Boss" value="50000000" min="1000000" step="1000000" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Skill</span>
                                        <select data-config="specialBossFarm.skillId" data-config-format="int" data-label="Boss Skill">
                                            <option value="0">Slash (1)</option>
                                            <option value="-1">Power (10)</option>
                                            <option value="-2">Heroic (50)</option>
                                            <option value="-3">Ultimate (100)</option>
                                            <option value="-4">Legendary (200)</option>
                                        </select>
                                    </label>
                                </div>
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Ataques //</span>
                                        <input type="number" data-config="specialBossFarm.parallelAttacks" data-config-format="int" data-label="Parallel" min="1" max="10" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="specialBossFarm.minDelayBetweenAttacks" data-config-format="int" data-label="Delay" min="10" step="10" />
                                    </label>
                                </div>
                                
                                <h6 style="margin-top:10px;margin-bottom:6px;font-size:11px;color:#aaa;">ðŸ’Š Auto Stamina Potion</h6>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="specialBossFarm.autoStaminaPotion" data-label="Auto Potion" data-toast="0" />
                                    <span>ðŸ’Š Usar poÃ§Ã£o automaticamente quando necessÃ¡rio</span>
                                </label>
                                <label class="autods-field autods-field-small">
                                    <span>Stamina MÃ­n</span>
                                    <input type="number" data-config="specialBossFarm.minStaminaForPotion" data-config-format="int" data-label="Min Stamina" min="0" step="10" />
                                </label>
                                
                                <h6 style="margin-top:10px;margin-bottom:6px;font-size:11px;color:#aaa;">â±ï¸ Tempo de Espera</h6>
                                <label class="autods-field">
                                    <span>Intervalo sem Boss (min)</span>
                                    <input type="number" data-config="specialBossFarm.checkInterval" data-config-format="int" data-label="Check Interval" min="60000" step="60000" value="300000" />
                                </label>
                                <p class="autods-info" style="font-size:10px;margin-top:4px;">Tempo de espera se nÃ£o encontrar bosses antes de recarregar (padrÃ£o: 5 minutos).</p>
                            </div>

                            <!-- Tab: Ultra Fast Attack -->
                            <div class="autods-tab-content" data-tab-content="ultrafastattack">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">âš¡ Ultra Fast Attack</h4>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastAttack.enabled" data-label="Ultra Fast Attack" data-toast="0" />
                                    <span>âš¡ Ativar Ultra Fast Attack (via botÃ£o Farm)</span>
                                </label>
                                <p class="autods-info" style="font-size:11px;">OperaÃ§Ãµes de ataque em lote paralelo via botÃ£o flutuante Farm. Modo manual.</p>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Max Paralelos</span>
                                        <input type="number" data-config="ultraFastAttack.maxParallelBattles" data-config-format="int" data-label="Max Paralelos" min="1" max="20" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Max Concurrent</span>
                                        <input type="number" data-config="ultraFastAttack.maxConcurrentBattles" data-config-format="int" data-label="Max Concurrent" min="1" max="10" />
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Ataques/Mob</span>
                                        <input type="number" data-config="ultraFastAttack.attacksPerMonster" data-config-format="int" data-label="Ataques" min="1" max="10" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Skill</span>
                                        <select data-config="ultraFastAttack.skillId" data-config-format="int" data-label="Skill">
                                            <option value="0">Slash (1)</option>
                                            <option value="-1">Power (10)</option>
                                            <option value="-2">Heroic (50)</option>
                                            <option value="-3">Ultimate (100)</option>
                                            <option value="-4">Legendary (200)</option>
                                        </select>
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="ultraFastAttack.delayBetweenBatches" data-config-format="int" data-label="Delay" min="100" step="100" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Prioridade</span>
                                        <select data-config="ultraFastAttack.priorityMode" data-label="Prioridade">
                                            <option value="lowest_hp">â†“ HP</option>
                                            <option value="highest_hp">â†‘ HP</option>
                                            <option value="random">ðŸŽ² AleatÃ³rio</option>
                                        </select>
                                    </label>
                                </div>
                                
                                <label class="autods-field">
                                    <span>Nomes de Monstros</span>
                                    <textarea data-config="ultraFastAttack.monsterNames" data-config-format="csv" data-label="Monstros Attack" placeholder="Deixar vazio para todos. Um por linha. Ex:
Orc Warrior
Troll Brawler" rows="2"></textarea>
                                </label>
                                <p class="autods-info" style="font-size:10px;margin-top:4px;">Deixe vazio para atacar todos os monstros disponÃ­veis.</p>
                            </div>

                            <!-- Tab: Ultra Fast Loot -->
                            <div class="autods-tab-content" data-tab-content="ultrafastloot">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">ðŸŽ Ultra Fast Loot</h4>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastLoot.enabled" data-label="Ultra Fast Loot" data-toast="0" />
                                    <span>ðŸŽ Ativar Ultra Fast Loot (via botÃ£o Loot)</span>
                                </label>
                                <p class="autods-info" style="font-size:11px;">Loot automÃ¡tico em paralelo. Trabalha melhor apÃ³s Ultra Fast Attack.</p>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Max Paralelos</span>
                                        <input type="number" data-config="ultraFastLoot.maxParallelLoots" data-config-format="int" data-label="Max Paralelos Loot" min="1" max="20" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="ultraFastLoot.delayBetweenLoots" data-config-format="int" data-label="Delay Loot" min="50" step="50" />
                                    </label>
                                </div>
                                
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastLoot.autoLootAfterFarm" data-label="Auto Loot" data-toast="0" />
                                    <span>âš¡ Auto-loot apÃ³s Ultra Fast Attack completar</span>
                                </label>
                                <p class="autods-info" style="font-size:10px; margin-top: 4px;">Se ativado, iniciarÃ¡ automaticamente o loot apÃ³s farm terminar.</p>
                                
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastLoot.onlyEligible" data-label="Only Eligible" data-toast="0" />
                                    <span>âœ“ Apenas monstros que vocÃª entrou</span>
                                </label>
                                <p class="autods-info" style="font-size:10px; margin-top: 4px;">Se desativado, looterÃ¡ monstros que outros jogadores mataram.</p>
                                
                                <label class="autods-field">
                                    <span>Incluir Nomes</span>
                                    <textarea data-config="ultraFastLoot.filters.monsterNames" data-config-format="csv" data-label="Incluir Loot" placeholder="Deixar vazio para todos os mobs. Um por linha. Ex:
Orc Warrior
Troll Brawler" rows="2"></textarea>
                                </label>
                                <p class="autods-info" style="font-size:10px; margin-top: 4px;">Whitelist: apenas estes mobs serÃ£o looteados.</p>
                                
                                <label class="autods-field">
                                    <span>Excluir Nomes</span>
                                    <textarea data-config="ultraFastLoot.filters.excludeNames" data-config-format="csv" data-label="Excluir Loot" placeholder="Deixar vazio para nenhuma exclusÃ£o. Um por linha. Ex:
Minion
Scout" rows="2"></textarea>
                                </label>
                                <p class="autods-info" style="font-size:10px; margin-top: 4px;">Blacklist: estes mobs serÃ£o ignorados.</p>
                                
                                <p class="autods-info" style="font-size:10px; margin-top: 12px; padding: 8px; background: rgba(74, 158, 255, 0.1); border-left: 3px solid #4a9eff; border-radius: 3px;">âš ï¸ Mobs com 100B+ HP sÃ£o automaticamente ignorados (bosses para loot manual)</p>
                            </div>

                            <!-- Tab: Ultra Fast Boss -->
                            <div class="autods-tab-content" data-tab-content="boss">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">ðŸ‰ Ultra Fast Boss</h4>
                                <p class="autods-info" style="font-size:11px; margin-bottom: 12px;">âš ï¸ Navegue para battle.php ou dungeon_battle.php antes de usar. Clique em Start para iniciar.</p>
                                
                                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                    <button type="button" class="autods-btn autods-btn-primary" data-action="boss-start" style="flex: 1; background: linear-gradient(135deg, #4a2a6a 0%, #2a4a6a 100%); border: 1px solid #8af; color: #8af; padding: 8px 12px; border-radius: 4px; cursor: pointer;">â–¶ï¸ Start</button>
                                    <button type="button" class="autods-btn autods-btn-secondary" data-action="boss-stop" style="flex: 1; background: linear-gradient(135deg, #6a2a2a 0%, #4a3a2a 100%); border: 1px solid #f88; color: #f88; padding: 8px 12px; border-radius: 4px; cursor: pointer;">â¹ï¸ Stop</button>
                                    <button type="button" class="autods-btn autods-btn-secondary" data-action="boss-reset" style="flex: 1; background: linear-gradient(135deg, #3a4a2a 0%, #2a4a3a 100%); border: 1px solid #8f8; color: #8f8; padding: 8px 12px; border-radius: 4px; cursor: pointer;">ðŸ”„ Reset</button>
                                </div>
                                
                                <div id="autods-boss-status" style="background: rgba(74, 42, 106, 0.3); padding: 8px; border-radius: 4px; border-left: 3px solid #8af; margin-bottom: 12px; display: none;">
                                    <div style="font-size: 12px; color: #8af; line-height: 1.5;">
                                        <div><strong>Dano:</strong> <span id="autods-boss-damage">0</span></div>
                                        <div><strong>Ataques:</strong> <span id="autods-boss-attacks">0</span></div>
                                        <div><strong>DPS:</strong> <span id="autods-boss-dps">0</span></div>
                                        <div><strong>PoÃ§Ãµes:</strong> <span id="autods-boss-potions">0</span></div>
                                    </div>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Alvo Dano</span>
                                        <input type="number" data-config="ultraFastBoss.targetDamage" data-config-format="int" data-label="Target Damage" min="1000000" step="1000000" value="1000000000" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Skill</span>
                                        <select data-config="ultraFastBoss.skillId" data-config-format="int" data-label="Boss Skill">
                                            <option value="0">Slash (1)</option>
                                            <option value="-1">Power (10)</option>
                                            <option value="-2">Heroic (50)</option>
                                            <option value="-3">Ultimate (100)</option>
                                            <option value="-4">Legendary (200)</option>
                                        </select>
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Ataques //</span>
                                        <input type="number" data-config="ultraFastBoss.parallelAttacks" data-config-format="int" data-label="Parallel" min="1" max="20" value="10" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="ultraFastBoss.minDelayBetweenAttacks" data-config-format="int" data-label="Delay" min="10" step="10" value="30" />
                                    </label>
                                </div>
                                
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastBoss.autoPotion" data-label="Auto Potion" data-toast="0" />
                                    <span>ðŸ’Š Usar Full Stamina Potion automaticamente</span>
                                </label>
                                <p class="autods-info" style="font-size:10px; margin-top: 8px;">Usar Full Stamina Potion (FSP) automaticamente quando stamina acabar.</p>
                            </div>
                            <div class="autods-tab-content" data-tab-content="dungeon">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">âš¡ Ultra Fast Dungeon</h4>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field">
                                        <span>Monstros</span>
                                        <textarea data-config="ultraFastDungeon.monsterNames" data-config-format="csv" data-label="Monstros Dungeon Ultra Fast" placeholder="Um nome por linha. Ex:
Ancient Dragon
Magus" rows="2"></textarea>
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field">
                                        <span>Prioridade</span>
                                        <select data-config="ultraFastDungeon.priorityMode" data-label="Prioridade">
                                            <option value="lowest_damage">â†“ Dano</option>
                                            <option value="highest_damage">â†‘ Dano</option>
                                            <option value="lowest_hp">â†“ HP</option>
                                            <option value="highest_hp">â†‘ HP</option>
                                        </select>
                                    </label>
                                    <label class="autods-field">
                                        <span>HP MÃ­n</span>
                                        <input type="number" data-config="ultraFastDungeon.minMobHp" data-config-format="int" data-label="HP MÃ­n" min="0" step="100000" />
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field">
                                        <span>Ataques por Monstro</span>
                                        <input type="number" data-config="ultraFastDungeon.attacksPerMonster" data-config-format="int" data-label="Ataques" min="1" max="10" />
                                    </label>
                                    <label class="autods-field">
                                        <span>Ataques //</span>
                                        <input type="number" data-config="ultraFastDungeon.maxParallelBattles" data-config-format="int" data-label="Paralelos" min="1" max="20" />
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="ultraFastDungeon.delayBetweenBatches" data-config-format="int" data-label="Delay" min="100" step="100" />
                                    </label>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>ðŸ§  Smart Damage</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="ultraFastDungeon.useSmartDamage" data-label="Smart Damage" data-toast="0" />
                                        <span>ðŸ§  Usar Smart Damage para respeitar limites</span>
                                    </label>
                                    
                                    <div class="autods-field-row">
                                        <label class="autods-field autods-field-small">
                                            <span>Dano Default</span>
                                            <input type="number" data-config="ultraFastDungeon.damageThresholds.default" data-config-format="int" data-label="Default" />
                                        </label>
                                        <label class="autods-field autods-field-small">
                                            <span>Dano Magus</span>
                                            <input type="number" data-config="ultraFastDungeon.damageThresholds.magus" data-config-format="int" data-label="Magus" />
                                        </label>
                                    </div>
                                    
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="ultraFastDungeon.respectExpLimit" data-label="Respect Exp Limit" data-toast="0" />
                                        <span>Nunca exceder 20% HP para full EXP</span>
                                    </label>
                                </div>
                                
                                <div class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastDungeon.checkJoined" data-label="Check Joined" data-toast="0" />
                                    <span>Verificar monstros que jÃ¡ entrei</span>
                                </div>
                                <div class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastDungeon.checkNotJoined" data-label="Check Not Joined" data-toast="0" />
                                    <span>Verificar monstros que nÃ£o entrei</span>
                                </div>
                                
                                <p class="autods-info" style="font-size: 11px; margin-top: 12px;">
                                    ðŸ’¡ Stamina mÃ­nima compartilhada com Wave.
                                </p>
                            </div>

                            <!-- Tab: Battle -->
                            <div class="autods-tab-content" data-tab-content="battle">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">ðŸ—¡ï¸ Battle Config</h4>
                                
                                <div class="autods-subsection">
                                    <h5>ðŸ§  Smart Damage</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="battle.smartDamage.enabled" data-label="Smart Damage" data-toast="0" />
                                        <span>Ativar Smart Damage AutomÃ¡tico</span>
                                    </label>
                                    
                                    <div class="autods-skill-grid" style="margin-top: 12px;">
                                        <label class="autods-skill">
                                            <span>Power Slash</span>
                                            <input type="number" data-config="battle.smartDamage.skills.powerSlash.damageLimit" data-config-format="int" data-label="Power Limit" />
                                        </label>
                                        <label class="autods-skill">
                                            <span>Heroic Slash</span>
                                            <input type="number" data-config="battle.smartDamage.skills.heroicSlash.damageLimit" data-config-format="int" data-label="Heroic Limit" />
                                        </label>
                                        <label class="autods-skill">
                                            <span>Ultimate Slash</span>
                                            <input type="number" data-config="battle.smartDamage.skills.ultimateSlash.damageLimit" data-config-format="int" data-label="Ultimate Limit" />
                                        </label>
                                        <label class="autods-skill">
                                            <span>Legendary Slash</span>
                                            <input type="number" data-config="battle.smartDamage.skills.legendarySlash.damageLimit" data-config-format="int" data-label="Legendary Limit" />
                                        </label>
                                    </div>
                                    <p class="autods-info" style="font-size: 10px; margin-top: 8px;">
                                        Smart Damage seleciona skill automÃ¡tico conforme o dano atual se aproxima dos limites.
                                    </p>
                                </div>
                                
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="battle.randomizeDelays" data-label="Randomize Delays" data-toast="0" />
                                    <span>Randomizar delays (anti-bot detection)</span>
                                </label>
                            </div>

                            <!-- Tab: PvP -->
                            <div class="autods-tab-content" data-tab-content="pvp">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">ðŸ† Ultra Fast PvP</h4>
                                
                                <label class="autods-checkbox" style="background: linear-gradient(135deg, #2a1a3a 0%, #1a2a3a 100%); padding: 8px; border-radius: 6px; border: 1px solid #8af; margin-bottom: 12px;">
                                    <input type="checkbox" data-config="pvp.ultraFastMode" data-label="Ultra Fast PvP" data-toast="0" />
                                    <span>âš¡ Ultra Fast Mode (API direto)</span>
                                </label>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field">
                                        <span>Modo</span>
                                        <select data-config="pvp.autoMode" data-label="Modo PvP">
                                            <option value="all">Todas as batalhas</option>
                                            <option value="limited">Limitado</option>
                                        </select>
                                    </label>
                                    <label class="autods-field">
                                        <span>Limite</span>
                                        <input type="number" data-config="pvp.limitedBattles" data-config-format="int" data-label="Limite" min="1" />
                                    </label>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>âš¡ Ultra Fast Config</h5>
                                    <div class="autods-field-row">
                                        <label class="autods-field">
                                            <span>Skill</span>
                                            <select data-config="pvp.ultraFastConfig.skillId" data-config-format="int" data-label="Skill PvP">
                                                <option value="0">Slash (1 token)</option>
                                                <option value="-1">Power Slash (5 tokens, 10x)</option>
                                            </select>
                                        </label>
                                        <label class="autods-field">
                                            <span>Delay Min (ms)</span>
                                            <input type="number" data-config="pvp.ultraFastConfig.minDelayBetweenAttacks" data-config-format="int" data-label="Delay Min" min="0" max="1000" step="10" />
                                        </label>
                                    </div>
                                    
                                    <label class="autods-checkbox" style="margin-top: 12px; background: linear-gradient(135deg, #1a3a2a 0%, #2a1a3a 100%); padding: 8px; border-radius: 6px; border: 1px solid #8fa;">
                                        <input type="checkbox" data-config="pvp.ultraFastConfig.useSmartRotation" data-label="Smart Rotation" data-toast="0" />
                                        <span>ðŸ”„ Smart Skill Rotation</span>
                                    </label>
                                    
                                    <div id="smartRotationConfig" style="margin-top: 10px; padding: 10px; background: rgba(26, 58, 42, 0.3); border-radius: 6px; border: 1px solid #4a8;">
                                        <div style="font-size: 12px; color: #aaf; margin-bottom: 8px; line-height: 1.4;">
                                            <strong>Configurar RotaÃ§Ã£o:</strong> Skill ID | Qtd
                                        </div>
                                        
                                        <div id="rotationItems" style="max-height: 300px; overflow-y: auto;">
                                            <!-- Items de rotaÃ§Ã£o serÃ£o inseridos aqui dinamicamente -->
                                        </div>
                                        
                                        <button id="addRotationItem" style="
                                            width: 100%;
                                            margin-top: 8px;
                                            padding: 6px 12px;
                                            background: linear-gradient(135deg, #2a4a2a 0%, #1a3a2a 100%);
                                            border: 1px solid #6a8;
                                            color: #aef;
                                            border-radius: 4px;
                                            cursor: pointer;
                                            font-size: 12px;
                                            font-weight: bold;
                                        ">âž• Adicionar Skill</button>
                                    </div>
                                    
                                    <label class="autods-field">
                                        <span>Max Batalhas/SessÃ£o</span>
                                        <input type="number" data-config="pvp.ultraFastConfig.maxConsecutiveBattles" data-config-format="int" data-label="Max Batalhas" min="0" />
                                    </label>
                                    <label class="autods-checkbox" style="margin-top: 8px;">
                                        <input type="checkbox" data-config="pvp.ultraFastConfig.autoContinueBattles" data-label="Auto Continue" data-toast="0" />
                                        <span>Auto-iniciar prÃ³xima batalha</span>
                                    </label>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="pvp.ultraFastConfig.autoReturnToLobby" data-label="Auto Return" data-toast="0" />
                                        <span>Auto-retornar ao lobby</span>
                                    </label>
                                </div>
                                
                                <label class="autods-checkbox" style="margin-top: 12px;">
                                    <input type="checkbox" data-config="pvp.autoSurrender" data-label="Auto Surrender" data-toast="0" />
                                    <span>Auto Surrender (HP < 10%)</span>
                                </label>
                                <label class="autods-field autods-field-small">
                                    <span>Limite Surrender (%)</span>
                                    <input type="number" data-config="pvp.autoSurrenderThreshold" data-config-format="int" data-label="Threshold" min="1" max="100" />
                                </label>
                            </div>

                            <!-- Tab: Interface -->
                            <div class="autods-tab-content" data-tab-content="interface">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">âš™ï¸ Interface & Config</h4>
                                
                                <div class="autods-subsection">
                                    <h5>ðŸ“Š Log Floater</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="ui.logFloater.enabled" data-label="Log Floater" data-toast="0" />
                                        <span>Exibir Log Flutuante</span>
                                    </label>
                                    <label class="autods-field">
                                        <span>PosiÃ§Ã£o</span>
                                        <select data-config="ui.logFloater.position" data-label="Log Position">
                                            <option value="bottom-right">Inferior Direita</option>
                                            <option value="bottom-left">Inferior Esquerda</option>
                                            <option value="top-right">Superior Direita</option>
                                            <option value="top-left">Superior Esquerda</option>
                                        </select>
                                    </label>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>ðŸ”” Toast Notifications</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="ui.toasts.enabled" data-label="Toasts" data-toast="0" />
                                        <span>Ativar notificaÃ§Ãµes tipo toast</span>
                                    </label>
                                    <label class="autods-field">
                                        <span>PosiÃ§Ã£o</span>
                                        <select data-config="ui.toasts.position" data-label="Toast Position">
                                            <option value="bottom-right">Inferior Direita</option>
                                            <option value="bottom-left">Inferior Esquerda</option>
                                            <option value="top-right">Superior Direita</option>
                                            <option value="top-left">Superior Esquerda</option>
                                        </select>
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>DuraÃ§Ã£o (ms)</span>
                                        <input type="number" data-config="ui.toasts.durationMs" data-config-format="int" data-label="Duration" min="1000" step="500" />
                                    </label>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>ðŸŽ€ Floating Helpers</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="floatingHelpers.enabled" data-label="Floating Helpers" data-toast="0" />
                                        <span>Exibir botÃµes flutuantes</span>
                                    </label>
                                    <label class="autods-field">
                                        <span>PosiÃ§Ã£o</span>
                                        <select data-config="floatingHelpers.position" data-label="Helpers Position">
                                            <option value="right">Direita</option>
                                            <option value="left">Esquerda</option>
                                        </select>
                                    </label>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="floatingHelpers.loot.enabled" data-label="Loot" data-toast="0" />
                                        <span>BotÃµes de loot</span>
                                    </label>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>ï¿½ï¸ Bloqueador de Imagens</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="imageBlocker.enabled" data-label="Image Blocker" data-toast="0" />
                                        <span>Bloquear imagens (melhora performance)</span>
                                    </label>
                                    <p class="autods-info" style="font-size: 11px; color: #aaa; margin-top: 8px;">
                                        Carrega a pÃ¡gina mais rÃ¡pido bloqueando todas as imagens. Recarregue a pÃ¡gina para ativar.
                                    </p>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>ï¿½ðŸ” Credenciais de Login</h5>
                                    <p class="autods-info" style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                                        Salve suas credenciais para re-login automÃ¡tico (opcional).
                                    </p>
                                    <label class="autods-field">
                                        <span>Email/UsuÃ¡rio</span>
                                        <input type="email" data-config="credentials.email" data-label="Email" placeholder="seu@email.com" />
                                    </label>
                                    <label class="autods-field">
                                        <span>Senha</span>
                                        <input type="password" data-config="credentials.password" data-label="Senha" placeholder="â—â—â—â—â—â—â—â—" />
                                    </label>
                                    <p class="autods-info" style="font-size: 10px; color: #f88; margin-top: 8px;">
                                        âš ï¸ As credenciais sÃ£o salvas localmente. Nunca compartilhe seu config com outras pessoas.
                                    </p>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>ðŸ”§ Sistema</h5>
                                    <label class="autods-field">
                                        <span>NÃ­vel de Log</span>
                                        <select data-config="core.logLevel" data-label="Log Level">
                                            <option value="debug">Debug</option>
                                            <option value="info">Info</option>
                                            <option value="warn">Aviso</option>
                                            <option value="error">Erro</option>
                                        </select>
                                    </label>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="core.shadowDom" data-label="Shadow DOM" data-toast="0" />
                                        <span>Usar Shadow DOM (isolamento de estilos)</span>
                                    </label>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="core.unlockAttackButtons" data-label="Unlock Attack Buttons" data-toast="0" />
                                        <span>Sempre desbloquear botÃµes de ataque</span>
                                    </label>
                                </div>
                            </div>

                        </div> <!-- fim autods-tabs-content -->
                            
                        </div> <!-- fim autods-tabs-main -->
                            
                    </div>
                </div>
            `;
        },
        cacheElements(container) {
            this.elements = {
                container,
                layout: container.querySelector('.autods-layout'),
                toggles: Array.from(container.querySelectorAll('[data-config]')),
                route: container.querySelector('[data-meta="route"]'),
                version: container.querySelector('[data-meta="version"]'),
                sections: {
                    configs: container.querySelector('[data-section="configs"]'),
                    automation: container.querySelector('[data-section="automation"]'),
                    events: container.querySelector('[data-section="events"]')
                },
                sectionBodies: {
                    configs: container.querySelector('[data-section-body="configs"]'),
                    automation: container.querySelector('[data-section-body="automation"]'),
                    events: container.querySelector('[data-section-body="events"]')
                },
                sectionToggles: {
                    configs: container.querySelector('[data-section-toggle="configs"]'),
                    automation: container.querySelector('[data-section-toggle="automation"]'),
                    events: container.querySelector('[data-section-toggle="events"]')
                },
                log: container.querySelector('#autods-status-log'),
                toolbar: this.toolbar || null,
                toolbarLinks: this.toolbarLinks || null
            };
        },
        bind(context) {
            if (this.bound) return;
            this.bound = true;

            console.log('[UIShell] bind() called - setting up event listeners');
            console.log('[UIShell] container:', this.elements.container);

            this.elements.container.addEventListener('change', event => {
                const target = event.target;
                if (!(target instanceof HTMLInputElement || target instanceof HTMLSelectElement || target instanceof HTMLTextAreaElement)) return;
                if (!target.dataset.config) return;
                this.onConfigInputChange(context, target);
            });

            // Handle range input live updates
            this.elements.container.addEventListener('input', event => {
                const target = event.target;
                if (target instanceof HTMLInputElement && target.type === 'range') {
                    // Find associated output element
                    const outputId = target.id ? `${target.id}-output` : null;
                    const output = outputId ? this.elements.container.querySelector(`#${outputId}`) : target.nextElementSibling;
                    
                    if (output && output.tagName === 'OUTPUT') {
                        const format = target.dataset.configFormat || '';
                        const precision = parseInt(target.dataset.configPrecision || '0', 10);
                        let displayValue = target.value;
                        
                        if (format === 'percent') {
                            displayValue = `${displayValue}%`;
                        } else if (precision > 0) {
                            displayValue = parseFloat(target.value).toFixed(precision);
                        }
                        
                        output.textContent = displayValue;
                    }
                }
            });

            this.elements.container.addEventListener('click', event => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) return;
                console.log('[UIShell] Click event:', target.tagName, target.className, target.dataset.action);
                
                // Debug: Log boss button clicks specifically
                if (target.dataset.action?.includes('boss') || target.closest('[data-action*="boss"]')) {
                    console.log('[UIShell] ðŸ‰ Boss button detected! Action:', target.dataset.action);
                    console.log('[UIShell] Target element:', target);
                    console.log('[UIShell] Closest selector match:', target.closest('[data-action]'));
                }

                // Handle main tabs (RÃ¡pido, Farm, Dungeon, Battle, PvP, Interface)
                const mainTab = target.closest('.autods-tabs-main .autods-tab');
                if (mainTab) {
                    event.preventDefault();
                    const tabName = mainTab.dataset.tab;
                    
                    // Update active tab button
                    this.elements.container.querySelectorAll('.autods-tabs-main .autods-tab').forEach(t => {
                        t.classList.toggle('active', t === mainTab);
                    });
                    
                    // Update active tab content
                    this.elements.container.querySelectorAll('.autods-tab-content').forEach(c => {
                        c.style.display = c.dataset.tabContent === tabName ? 'block' : 'none';
                    });
                    
                    // Save state
                    const cfg = context.config.get();
                    const patch = createPatchFromPath('ui.activeTab', tabName);
                    context.config.update(patch);
                    return;
                }

                // Handle dropdown toggles
                const toggleBtn = target.closest('[data-toggle]');
                if (toggleBtn) {
                    event.preventDefault();
                    const groupId = toggleBtn.dataset.toggle;
                    const content = this.elements.container.querySelector(`[data-content="${groupId}"]`);
                    if (content) {
                        const isOpen = content.style.display !== 'none';
                        
                        // Toggle state
                        content.style.display = isOpen ? 'none' : 'block';
                        toggleBtn.classList.toggle('active', !isOpen);
                        
                        // Save state in config
                        const currentConfig = context.config.get();
                        const currentStates = currentConfig.ui?.dropdownStates || {};
                        currentStates[groupId] = !isOpen;
                        const patch = createPatchFromPath('ui.dropdownStates', currentStates);
                        context.config.update(patch);
                        
                        // context.logger.debug(`[UI] Dropdown "${groupId}" ${!isOpen ? 'aberto' : 'fechado'}, estado salvo`);
                    }
                    return;
                }
                
                // Handle tabs
                const tab = target.closest('.autods-tab');
                if (tab) {
                    event.preventDefault();
                    const tabName = tab.dataset.tab;
                    const parent = tab.closest('.autods-dropdown-content');
                    if (parent) {
                        // Update active tab
                        parent.querySelectorAll('.autods-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        
                        // Update content
                        parent.querySelectorAll('.autods-tab-content').forEach(c => c.classList.remove('active'));
                        const targetContent = parent.querySelector(`[data-tab-content="${tabName}"]`);
                        if (targetContent) {
                            targetContent.classList.add('active');
                        }
                    }
                    return;
                }

                // Close panel button
                if (target.matches('[data-action="close-panel"]') || target.closest('[data-action="close-panel"]')) {
                    event.preventDefault();
                    const shell = this.elements.container; // container IS the #autods-shell
                    if (shell) {
                        const isCollapsed = shell.getAttribute('data-mobile-collapsed') === '1';

                        if (isCollapsed) {
                            // Reabrir painel
                            shell.setAttribute('data-mobile-collapsed', '0');
                            document.body.classList.add('autods-layout-ready');
                            document.body.classList.add('autods-shell-open');
                            if (window.innerWidth <= 480) {
                                document.body.classList.add('autods-panel-visible');
                            }
                            // Update mobile toggle button if it exists
                            if (this.mobileToggleButton) {
                                this.mobileToggleButton.textContent = 'âœ•';
                                this.mobileToggleButton.setAttribute('aria-label', 'Fechar painel');
                            }
                            // Hide desktop toggle button
                            if (this.desktopToggleButton) {
                                this.desktopToggleButton.classList.remove('visible');
                            }
                        } else {
                            // Minimizar painel
                            shell.setAttribute('data-mobile-collapsed', '1');
                            document.body.classList.remove('autods-layout-ready');
                            document.body.classList.remove('autods-shell-open');
                            if (window.innerWidth <= 480) {
                                document.body.classList.remove('autods-panel-visible');
                            }
                            // Update mobile toggle button if it exists
                            if (this.mobileToggleButton) {
                                this.mobileToggleButton.textContent = 'â˜°';
                                this.mobileToggleButton.setAttribute('aria-label', 'Abrir painel');
                            }
                            // Show desktop toggle button (only on desktop)
                            if (this.desktopToggleButton && window.innerWidth > 480) {
                                this.desktopToggleButton.classList.add('visible');
                            }
                            this.showToast(context, 'info', 'Painel minimizado', 'Pressione Ctrl+Shift+P ou clique no botÃ£o flutuante para reabrir.');
                        }
                    }
                    return;
                }

                const sectionToggle = target.closest('[data-section-toggle]');
                if (sectionToggle) {
                    event.preventDefault();
                    const sectionId = sectionToggle.getAttribute('data-section-toggle');
                    this.toggleSection(context, sectionId);
                    return;
                }

                if (target.matches('[data-action="toggle-log-view"]') || target.closest('[data-action="toggle-log-view"]')) {
                    event.preventDefault();
                    this.state.logViewExpanded = !this.state.logViewExpanded;
                    const btn = target.matches('[data-action="toggle-log-view"]') ? target : target.closest('[data-action="toggle-log-view"]');
                    btn.textContent = this.state.logViewExpanded ? 'ðŸ”¼' : 'ðŸ‘ï¸';
                    btn.title = this.state.logViewExpanded ? 'Mostrar menos' : 'Mostrar todos';
                    this.render(context);
                }

                // Smart Rotation: Add rotation item
                if (target.id === 'addRotationItem' || target.closest('#addRotationItem')) {
                    event.preventDefault();
                    const cfg = context.config.get();
                    const pattern = cfg.pvp?.ultraFastConfig?.smartRotationPattern || [];
                    
                    // Add new item
                    const newItem = { skill: 0, count: 1 };
                    pattern.push(newItem);
                    
                    // Save to config
                    const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', pattern);
                    context.config.update(patch);
                    
                    // Re-render the rotation items
                    this.renderSmartRotationItems(context);
                    return;
                }

                // Smart Rotation: Remove rotation item
                const removeBtn = target.closest('[data-rotation-remove]');
                if (removeBtn) {
                    event.preventDefault();
                    const index = parseInt(removeBtn.dataset.rotationRemove, 10);
                    const cfg = context.config.get();
                    const pattern = cfg.pvp?.ultraFastConfig?.smartRotationPattern || [];
                    
                    pattern.splice(index, 1);
                    if (pattern.length === 0) {
                        pattern.push({ skill: 0, count: 1 });
                    }
                    
                    const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', pattern);
                    context.config.update(patch);
                    
                    this.renderSmartRotationItems(context);
                    return;
                }

                // Smart Rotation: Change skill or count
                const rotationSelect = target.closest('[data-rotation-skill]');
                if (rotationSelect && target.dataset.rotationSkill) {
                    event.preventDefault();
                    const index = parseInt(target.dataset.rotationSkill, 10);
                    const cfg = context.config.get();
                    const pattern = cfg.pvp?.ultraFastConfig?.smartRotationPattern || [];
                    
                    if (pattern[index]) {
                        pattern[index].skill = parseInt(target.value, 10);
                        const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', pattern);
                        context.config.update(patch);
                    }
                    return;
                }

                const rotationCount = target.closest('[data-rotation-count]');
                if (rotationCount && target.dataset.rotationCount) {
                    event.preventDefault();
                    const index = parseInt(target.dataset.rotationCount, 10);
                    const cfg = context.config.get();
                    const pattern = cfg.pvp?.ultraFastConfig?.smartRotationPattern || [];
                    
                    if (pattern[index]) {
                        pattern[index].count = parseInt(target.value, 10) || 1;
                        const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', pattern);
                        context.config.update(patch);
                    }
                    return;
                }

                // Ultra Fast Boss controls
                if (target.matches('[data-action="boss-start"]') || target.closest('[data-action="boss-start"]')) {
                    event.preventDefault();
                    console.log('[UI] âœ… Boss START button handler triggered!');
                    context.logger.info('[UI] ðŸ‰ Iniciando Ultra Fast Boss...');
                    this.startUltraFastBoss(context);
                    return;
                }

                if (target.matches('[data-action="boss-stop"]') || target.closest('[data-action="boss-stop"]')) {
                    event.preventDefault();
                    console.log('[UI] âœ… Boss STOP button handler triggered!');
                    context.logger.info('[UI] ðŸ›‘ Parando Ultra Fast Boss...');
                    this.stopUltraFastBoss(context);
                    return;
                }

                if (target.matches('[data-action="boss-reset"]') || target.closest('[data-action="boss-reset"]')) {
                    event.preventDefault();
                    console.log('[UI] âœ… Boss RESET button handler triggered!');
                    context.logger.info('[UI] ðŸ”„ Resetando Ultra Fast Boss...');
                    this.resetUltraFastBoss(context);
                    return;
                }
            });

            const render = () => this.render(context);
            const addLog = (level, message, timestamp) => this.addLog(level, message, timestamp);

            this.handlers = {
                configUpdated: render,
                farmDisabled: evt => {
                    const reason = evt?.detail?.reason || 'motivo desconhecido';
                    this.state.farm.lastPause = { reason, timestamp: Date.now() };
                    addLog('warn', `Farming pausado: ${reason}`);
                    this.showToast(context, 'warn', 'Farming pausado', reason);
                },
                waveJoin: evt => {
                    const detail = evt?.detail || {};
                    this.state.wave.lastJoin = {
                        monster: detail.monster,
                        hp: detail.hp,
                        timestamp: detail.timestamp || Date.now()
                    };
                    const monster = detail.monster || 'alvo desconhecido';
                    addLog('info', `Wave ingressou em ${monster}`, detail.timestamp);
                    this.showToast(context, 'info', 'Wave', `Entrando em ${monster}.`);
                },
                battleComplete: evt => {
                    const detail = evt?.detail || {};
                    this.state.battle.lastResult = {
                        damage: detail.damage,
                        reason: detail.reason,
                        targetDamage: detail.targetDamage,
                        timestamp: detail.timestamp || Date.now()
                    };
                    const reasonLabel = detail.reason === 'targetDamage' ? 'meta atingida' : 'inimigo derrotado';
                    addLog('success', `Batalha concluÃ­da (${reasonLabel})`, detail.timestamp);
                    this.showToast(context, 'success', 'Batalha PvE', `ConcluÃ­da: ${reasonLabel}.`);
                },
                battleBlocked: () => {
                    addLog('warn', 'Limite de batalhas alcanÃ§ado (5 simultÃ¢neas).', Date.now());
                    this.showToast(context, 'warn', 'Batalhas bloqueadas', 'Limite de 5 batalhas atingido.');
                },
                battleJoin: evt => {
                    addLog('info', 'Entrando em batalha PvE.', evt?.detail?.timestamp || Date.now());
                },
                pvpStart: evt => {
                    this.state.pvp.inBattle = true;
                    addLog('info', 'PvP: batalha iniciada.', evt?.detail?.timestamp || Date.now());
                    this.showToast(context, 'info', 'PvP', 'Batalha iniciada.');
                },
                pvpEnd: evt => {
                    this.state.pvp.inBattle = false;
                    this.state.pvp.lastResult = { timestamp: evt?.detail?.timestamp || Date.now(), reason: 'completed' };
                    addLog('success', 'PvP: batalha concluÃ­da.', evt?.detail?.timestamp || Date.now());
                    this.showToast(context, 'success', 'PvP', 'Batalha concluÃ­da.');
                },
                pvpSurrender: evt => {
                    this.state.pvp.inBattle = false;
                    this.state.pvp.lastResult = { timestamp: evt?.detail?.timestamp || Date.now(), reason: 'surrender' };
                    addLog('warn', 'PvP: rendiÃ§Ã£o automÃ¡tica executada.', evt?.detail?.timestamp || Date.now());
                    this.showToast(context, 'warn', 'PvP', 'RendiÃ§Ã£o automÃ¡tica executada.');
                },
                ready: evt => {
                    addLog('success', `AutomaÃ§Ã£o pronta (v${evt?.detail?.version || SCRIPT_VERSION}).`, Date.now());
                    this.showToast(context, 'success', 'AutoDS', 'AutomaÃ§Ã£o inicializada.');
                },
                farmChapter: evt => {
                    const detail = evt?.detail || {};
                    this.state.farmProgress.chapters += 1;
                    const origin = context.location?.origin || 'https://demonicscans.org';
                    const href = detail.href ? new URL(detail.href, origin).pathname : null;
                    addLog('info', 'CapÃ­tulo farm concluÃ­do.', detail.timestamp || Date.now());
                    this.showToast(context, 'info', 'Farming', href ? `AvanÃ§ando para ${href}.` : 'CapÃ­tulo concluÃ­do.');
                },
                farmLimitReached: evt => {
                    const detail = evt?.detail || {};
                    const reason = detail.reason === 'farm-energy-full' ? 'Energia de farming cheia (1000/1000)' : 'Limite atingido';
                    addLog('warn', `Farming parou: ${reason}`, detail.timestamp || Date.now());
                    this.showToast(context, 'warn', 'Farming', reason);
                },
                waveMaxBattles: evt => {
                    const detail = evt?.detail || {};
                    const count = detail.continueCount || 5;
                    const limit = detail.limit || 5;
                    const interval = Math.round((detail.reloadInterval || 30000) / 1000);
                    addLog('warn', `Batalhas simultÃ¢neas no limite (${count}/${limit}). Reload em ${interval}s.`, detail.timestamp);
                    this.showToast(context, 'warn', 'Wave', `Limite de batalhas (${count}/${limit}). Aguardando...`);
                },
                waveReloading: evt => {
                    addLog('info', 'Recarregando pÃ¡gina para verificar batalhas disponÃ­veis...', evt?.detail?.timestamp || Date.now());
                }
            };

            context.events.on('autods:config:updated', this.handlers.configUpdated);
            context.events.on('autods:farm:disabled', this.handlers.farmDisabled);
            context.events.on('autods:farm:limit-reached', this.handlers.farmLimitReached);
            context.events.on('autods:wave:join', this.handlers.waveJoin);
            context.events.on('autods:battle:complete', this.handlers.battleComplete);
            context.events.on('autods:battle:blocked', this.handlers.battleBlocked);
            context.events.on('autods:battle:join', this.handlers.battleJoin);
            context.events.on('autods:pvp:battleStart', this.handlers.pvpStart);
            context.events.on('autods:pvp:battleEnd', this.handlers.pvpEnd);
            context.events.on('autods:pvp:surrender', this.handlers.pvpSurrender);
            context.events.on('autods:farm:chapter', this.handlers.farmChapter);
            context.events.on('autods:ready', this.handlers.ready);
        },
        addLog(level, message, timestamp = Date.now()) {
            if (!this.state) return;
            this.state.log.unshift({ level, message, timestamp });

            // Manter atÃ© MAX_PERSISTENT_LOGS no storage, mas apenas 8 visÃ­veis por padrÃ£o
            if (this.state.log.length > MAX_PERSISTENT_LOGS) {
                this.state.log = this.state.log.slice(0, MAX_PERSISTENT_LOGS);
            }

            // Auto-render apÃ³s adicionar log para garantir que eventos apareÃ§am imediatamente
            if (this._context) {
                this.render(this._context);
            }
        },
        updateStatusIndicators(context) {
            const cfg = context.config.get();
            
            // Wave status
            const waveStatus = this.elements.container.querySelector('[data-status="wave-unified"]');
            if (waveStatus) {
                const active = cfg.wave?.enabled || cfg.dungeonWave?.enabled;
                waveStatus.textContent = active ? 'âœ…' : 'â­•';
                waveStatus.style.background = active ? 'rgba(166, 227, 161, 0.2)' : 'rgba(100, 100, 100, 0.2)';
                waveStatus.style.color = active ? '#a6e3a1' : '#808080';
            }
            
            // Battle status
            const battleStatus = this.elements.container.querySelector('[data-status="battle"]');
            if (battleStatus) {
                const active = cfg.battle?.enabled || cfg.autoBoss?.enabled;
                battleStatus.textContent = active ? 'âœ…' : 'â­•';
                battleStatus.style.background = active ? 'rgba(166, 227, 161, 0.2)' : 'rgba(100, 100, 100, 0.2)';
                battleStatus.style.color = active ? '#a6e3a1' : '#808080';
            }
            
            // PvP status
            const pvpStatus = this.elements.container.querySelector('[data-status="pvp"]');
            if (pvpStatus) {
                const active = cfg.pvp?.enabled;
                pvpStatus.textContent = active ? 'âœ…' : 'â­•';
                pvpStatus.style.background = active ? 'rgba(166, 227, 161, 0.2)' : 'rgba(100, 100, 100, 0.2)';
                pvpStatus.style.color = active ? '#a6e3a1' : '#808080';
            }
            
            // Others status
            const othersStatus = this.elements.container.querySelector('[data-status="others"]');
            if (othersStatus) {
                const active = cfg.farm?.enabled || cfg.floatingHelpers?.enabled || cfg.imageBlock?.enabled;
                othersStatus.textContent = active ? 'âœ…' : 'â­•';
                othersStatus.style.background = active ? 'rgba(166, 227, 161, 0.2)' : 'rgba(100, 100, 100, 0.2)';
                othersStatus.style.color = active ? '#a6e3a1' : '#808080';
            }
        },
        restoreDropdownStates(context) {
            const states = context.config.get().ui?.dropdownStates || {};
            const activeTab = context.config.get().ui?.activeTab || 'quick';
            
            // Restaurar tab principal (RÃ¡pido, Farm, etc)
            const mainTabButtons = this.elements.container.querySelectorAll('.autods-tabs-main .autods-tab');
            mainTabButtons.forEach(btn => {
                if (btn.dataset.tab === activeTab) {
                    btn.classList.add('active');
                    // Show corresponding content
                    this.elements.container.querySelectorAll('.autods-tab-content').forEach(content => {
                        content.style.display = content.dataset.tabContent === activeTab ? 'block' : 'none';
                    });
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Restaurar dropdowns antigos (backward compatibility)
            Object.keys(states).forEach(groupId => {
                const isOpen = states[groupId];
                const toggleBtn = this.elements.container.querySelector(`[data-toggle="${groupId}"]`);
                const content = this.elements.container.querySelector(`[data-content="${groupId}"]`);
                
                if (toggleBtn && content) {
                    content.style.display = isOpen ? 'block' : 'none';
                    toggleBtn.classList.toggle('active', isOpen);
                }
            });
        },
        render(context) {
            if (!this.elements) return;
            const config = context.config.get();
            if (this.elements.route) {
                this.elements.route.textContent = context.location.pathname;
            }
            if (this.elements.version) {
                this.elements.version.textContent = context.version;
            }

            this.syncConfigInputs(config);

            this.applySectionStates(config);
            this.renderConfigs(context, config);
            this.renderToasts(context, config);
            
            // Render smart rotation items if they exist
            this.renderSmartRotationItems(context);
            
            // Update status indicators and restore dropdown states
            this.updateStatusIndicators(context);
            this.restoreDropdownStates(context);

            if (this.elements.log) {
                const list = this.elements.log;
                list.innerHTML = '';
                if (!this.state.log.length) {
                    const empty = document.createElement('li');
                    empty.classList.add('empty');
                    empty.textContent = 'Sem eventos recentes.';
                    list.appendChild(empty);
                } else {
                    const formatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    // Mostrar apenas 8 mais recentes por padrÃ£o, ou todos se expandido
                    const displayLimit = this.state.logViewExpanded ? this.state.log.length : 8;
                    const logsToShow = this.state.log.slice(0, displayLimit);

                    logsToShow.forEach(entry => {
                        const li = document.createElement('li');
                        li.dataset.level = entry.level;
                        const time = document.createElement('span');
                        time.className = 'time';
                        time.textContent = formatter.format(new Date(entry.timestamp));
                        const message = document.createElement('span');
                        message.className = 'message';
                        message.textContent = entry.message;
                        li.append(time, message);
                        list.appendChild(li);
                    });

                    // Mostrar indicador se hÃ¡ mais logs disponÃ­veis
                    if (!this.state.logViewExpanded && this.state.log.length > 8) {
                        const more = document.createElement('li');
                        more.classList.add('empty');
                        more.style.cssText = 'color: rgba(140, 190, 255, 0.8); font-style: italic; cursor: pointer;';
                        more.textContent = `+ ${this.state.log.length - 8} eventos anteriores (clique no ðŸ‘ï¸ para ver todos)`;
                        more.title = 'Clique no botÃ£o ðŸ‘ï¸ no cabeÃ§alho para ver todos os eventos';
                        list.appendChild(more);
                    }
                }
            }
        },
        getConfigValue(config, path) {
            if (!path) return undefined;
            const keys = path.split('.');
            let current = config;
            for (const key of keys) {
                if (current == null) return undefined;
                current = current[key];
            }
            return current;
        },
        toInputDisplayValue(element, value) {
            if (element instanceof HTMLInputElement && element.type === 'checkbox') {
                return Boolean(value);
            }
            const format = element.dataset.configFormat
                || (element instanceof HTMLSelectElement ? 'string'
                : (element instanceof HTMLInputElement && element.type === 'number' ? 'int' : 'string'));

            if (value === undefined || value === null) {
                if (format === 'csv') return '';
                return '';
            }

            const precision = parseInt(element.dataset.configPrecision || '0', 10);

            switch (format) {
                case 'percent': {
                    const scaled = Number(value) * 100;
                    if (!Number.isFinite(scaled)) return '';
                    return scaled.toFixed(Math.max(0, precision));
                }
                case 'minutes': {
                    const minutes = Number(value) / 60000;
                    if (!Number.isFinite(minutes)) return '';
                    return minutes.toFixed(Math.max(0, precision));
                }
                case 'csv':
                    if (Array.isArray(value)) {
                        return value.join('\n');
                    }
                    if (typeof value === 'string') return value;
                    return '';
                case 'float': {
                    const num = Number(value);
                    if (!Number.isFinite(num)) return '';
                    return num.toFixed(Math.max(0, precision || 2));
                }
                case 'string':
                    return String(value ?? '');
                case 'int':
                default: {
                    const num = Number(value);
                    if (!Number.isFinite(num)) return '';
                    return String(Math.round(num));
                }
            }
        },
        syncConfigInputs(config) {
            if (!this.elements?.toggles) return;
            this.elements.toggles.forEach(element => {
                const path = element.dataset.config;
                if (!path) return;
                const value = this.getConfigValue(config, path);
                if (element instanceof HTMLInputElement) {
                    if (element.type === 'checkbox') {
                        element.checked = Boolean(value);
                    } else {
                        const displayValue = this.toInputDisplayValue(element, value);
                        if (displayValue !== undefined) {
                            element.value = displayValue;
                        }
                    }
                } else if (element instanceof HTMLSelectElement || element instanceof HTMLTextAreaElement) {
                    const displayValue = this.toInputDisplayValue(element, value);
                    if (displayValue !== undefined) {
                        element.value = displayValue;
                    }
                }
            });
        },
        parseConfigInput(element) {
            if (element instanceof HTMLInputElement && element.type === 'checkbox') {
                return { value: element.checked };
            }

            const format = element.dataset.configFormat
                || (element instanceof HTMLSelectElement ? 'string'
                : (element instanceof HTMLInputElement && element.type === 'number' ? 'int' : 'string'));
            const raw = element.value?.trim?.() ?? '';
            const normalised = raw.replace(/,/g, '.');

            const ensureBounds = (numericValue) => {
                if (!(element instanceof HTMLInputElement) || element.type !== 'number') return numericValue;
                let value = numericValue;
                if (element.min !== '') {
                    const min = Number(element.min);
                    if (Number.isFinite(min)) {
                        value = Math.max(value, min);
                    }
                }
                if (element.max !== '') {
                    const max = Number(element.max);
                    if (Number.isFinite(max)) {
                        value = Math.min(value, max);
                    }
                }
                return value;
            };

            switch (format) {
                case 'percent': {
                    if (!raw && element.dataset.allowEmpty === '1') {
                        return { value: null };
                    }
                    const parsed = Number(normalised);
                    if (!Number.isFinite(parsed)) {
                        return { error: 'Valor percentual invÃ¡lido.' };
                    }
                    const bounded = Math.max(0, Math.min(100, parsed));
                    return { value: bounded / 100 };
                }
                case 'minutes': {
                    if (!raw && element.dataset.allowEmpty === '1') {
                        return { value: null };
                    }
                    const parsed = Number(normalised);
                    if (!Number.isFinite(parsed)) {
                        return { error: 'Valor em minutos invÃ¡lido.' };
                    }
                    let fixed = Math.max(0, parsed);
                    if (element instanceof HTMLInputElement) {
                        if (element.min !== '') {
                            const min = Number(element.min);
                            if (Number.isFinite(min)) {
                                fixed = Math.max(fixed, min);
                            }
                        }
                        if (element.max !== '') {
                            const max = Number(element.max);
                            if (Number.isFinite(max)) {
                                fixed = Math.min(fixed, max);
                            }
                        }
                    }
                    return { value: fixed * 60000 };
                }
                case 'csv': {
                    if (!raw) return { value: [] };
                    const entries = raw
                        .split(/[\n,]+/)
                        .map(name => name.trim())
                        .filter(name => name.length > 0);
                    return { value: entries };
                }
                case 'float': {
                    const parsed = Number(normalised);
                    if (!Number.isFinite(parsed)) {
                        return { error: 'Valor numÃ©rico invÃ¡lido.' };
                    }
                    return { value: ensureBounds(parsed) };
                }
                case 'int': {
                    if (!raw && element.dataset.allowEmpty === '1') {
                        return { value: null };
                    }
                    const parsed = Number.parseInt(normalised, 10);
                    if (!Number.isFinite(parsed)) {
                        return { error: 'Valor inteiro invÃ¡lido.' };
                    }
                    return { value: ensureBounds(parsed) };
                }
                case 'string':
                default:
                    return { value: raw };
            }
        },
        describeInputValue(element, value) {
            if (element instanceof HTMLInputElement && element.type === 'checkbox') {
                return value ? 'ativado' : 'desativado';
            }

            const format = element.dataset.configFormat
                || (element instanceof HTMLSelectElement ? 'string'
                : (element instanceof HTMLInputElement && element.type === 'number' ? 'int' : 'string'));
            const precision = parseInt(element.dataset.configPrecision || '0', 10);

            switch (format) {
                case 'percent': {
                    if (value == null) return '';
                    return `${(Number(value) * 100).toFixed(Math.max(0, precision))}%`;
                }
                case 'minutes': {
                    if (value == null) return '';
                    const minutes = Number(value) / 60000;
                    if (!Number.isFinite(minutes)) return '';
                    return `${minutes.toFixed(Math.max(0, precision))} min`;
                }
                case 'csv': {
                    if (!value || !value.length) return 'lista vazia';
                    if (Array.isArray(value)) return value.join(', ');
                    return String(value);
                }
                case 'int':
                case 'float':
                    if (value == null) return '';
                    return String(value);
                case 'string':
                default:
                    return value ? String(value) : '';
            }
        },
        updateConfigValue(context, path, value, logMessage) {
            if (!path) return;
            const currentConfig = context.config.get();
            const patch = createPatchFromPath(path, value);
            const preview = deepMerge(currentConfig, patch);
            this.syncConfigInputs(preview);
            context.config.update(patch);
            if (logMessage) {
                this.addLog('info', logMessage, Date.now());
                // render() nÃ£o Ã© mais necessÃ¡rio aqui, addLog() jÃ¡ renderiza automaticamente
            }
            context.moduleRegistry?.activateFor(context);
        },
        onConfigInputChange(context, element) {
            const path = element.dataset.config;
            if (!path) return;
            const { value, error } = this.parseConfigInput(element);
            if (error) {
                element.classList.add('invalid');
                this.showToast(context, 'error', 'ConfiguraÃ§Ãµes', error);
                this.syncConfigInputs(context.config.get());
                if (typeof element.focus === 'function') {
                    element.focus();
                    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
                        element.select?.();
                    }
                }
                return;
            }

            if (element.classList.contains('invalid')) {
                element.classList.remove('invalid');
            }

            const label = element.dataset.label || path;
            const description = this.describeInputValue(element, value);
            const isToggle = element instanceof HTMLInputElement && element.type === 'checkbox';
            const message = isToggle
                ? `${label} ${description}`
                : `${label} atualizado${description ? ` (${description})` : ''}`;

            this.updateConfigValue(context, path, value, message);

            if (element.dataset.toast !== '0') {
                this.showToast(context, 'success', 'ConfiguraÃ§Ãµes', message);
            }
        },
        toggleSection(context, sectionId) {
            if (!sectionId) return;
            const currentConfig = context.config.get();
            const nextState = !Boolean(currentConfig.ui?.panelStates?.[sectionId]);
            const patch = createPatchFromPath(`ui.panelStates.${sectionId}`, nextState);
            const preview = deepMerge(currentConfig, patch);
            this.applySectionStates(preview);
            context.config.update(patch);
        },
        createToastContainer(host, context) {
            if (!host) return;
            if (this.toastTimers && this.toastTimers.size) {
                this.toastTimers.forEach(timer => context.window?.clearTimeout?.(timer));
                this.toastTimers.clear();
            }
            host.innerHTML = '';
            const container = document.createElement('div');
            container.className = 'autods-toast-container';
            host.appendChild(container);
            this.toastRoot = host;
            this.toastContainer = container;
            this.toastTimers = new Map();
            this.updateToastPosition(context);
        },
        updateToastPosition(context, config) {
            const container = this.toastContainer;
            if (!container) return;
            const effectiveConfig = config || context.config.get();
            const position = effectiveConfig.ui?.toasts?.position || 'bottom-right';
            container.style.top = '';
            container.style.bottom = '';
            container.style.left = '';
            container.style.right = '';
            switch (position) {
                case 'top-left':
                    container.style.top = '16px';
                    container.style.left = '16px';
                    break;
                case 'top-right':
                    container.style.top = '16px';
                    container.style.right = '16px';
                    break;
                case 'bottom-left':
                    container.style.bottom = '16px';
                    container.style.left = '16px';
                    break;
                case 'bottom-right':
                default:
                    container.style.bottom = '16px';
                    container.style.right = '16px';
                    break;
            }
        },
        removeToast(context, toastId) {
            if (!this.state?.toasts) return;
            const index = this.state.toasts.findIndex(toast => toast.id === toastId);
            if (index >= 0) {
                this.state.toasts.splice(index, 1);
            }
            if (this.toastTimers && this.toastTimers.has(toastId)) {
                const timer = this.toastTimers.get(toastId);
                context.window?.clearTimeout?.(timer);
                this.toastTimers.delete(toastId);
            }
            this.renderToasts(context);
        },
        showToast(context, level = 'info', title = '', message = '', options = {}) {
            const config = context.config.get();
            if (!config.ui?.toasts?.enabled) return;
            if (!this.toastContainer) {
                this.createToastContainer(context.ui.shadow.querySelector('#autods-toast-root'), context);
            }
            const now = Date.now();
            const duration = Math.max(0, options.durationMs ?? config.ui?.toasts?.durationMs ?? 4500);
            const toast = {
                id: `toast-${now}-${Math.random().toString(16).slice(2)}`,
                level,
                title,
                message,
                createdAt: now,
                expiresAt: duration ? now + duration : null
            };
            this.state.toasts = [toast, ...(this.state.toasts || [])].slice(0, 6);
            this.renderToasts(context, config);

            if (duration && context.window?.setTimeout) {
                this.toastTimers = this.toastTimers || new Map();
                const timerId = context.window.setTimeout(() => {
                    this.removeToast(context, toast.id);
                }, duration + 10);
                this.toastTimers.set(toast.id, timerId);
            }
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ULTRA FAST BOSS METHODS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        ultraFastBossState: {
            running: false,
            battleId: null,
            targetDamage: 0,
            skillId: -2,
            autoPotion: true,
            startTime: null,
            attackCount: 0,
            totalDamageDealt: 0,
            currentDamage: 0,
            potionsUsed: 0,
            currentStamina: 0,
            fullPotionInvId: null,
            fullPotionCount: 0
        },
        
        ultraFastBossConfig: {
            attackEndpoint: 'https://demonicscans.org/damage.php',
            potionEndpoint: 'https://demonicscans.org/use_item.php',
            skillCosts: { '0': 1, '-1': 10, '-2': 50, '-3': 100, '-4': 200 },
            skillNames: { '0': 'Slash', '-1': 'Power Slash', '-2': 'Heroic Slash', '-3': 'Ultimate Slash', '-4': 'Legendary Slash' }
        },
        
        /**
         * Render smart rotation items dynamically
         */
        renderSmartRotationItems(context) {
            const container = this.elements?.container;
            if (!container) return;
            
            const cfg = context.config.get();
            const pattern = cfg.pvp?.ultraFastConfig?.smartRotationPattern || [];
            const rotationItemsContainer = container.querySelector('#rotationItems');
            
            if (!rotationItemsContainer) return;
            
            // Clear existing items
            rotationItemsContainer.innerHTML = '';
            
            // Render each item
            pattern.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.style.cssText = `
                    display: grid;
                    grid-template-columns: 1fr 1fr auto;
                    gap: 6px;
                    margin-bottom: 8px;
                    padding: 8px;
                    background: rgba(26, 42, 58, 0.3);
                    border: 1px solid #4a8;
                    border-radius: 4px;
                    align-items: center;
                `;
                
                // Skill input (text input for custom skill numbers)
                const skillInput = document.createElement('input');
                skillInput.type = 'text';
                skillInput.style.cssText = `
                    padding: 4px;
                    background: rgba(26, 42, 58, 0.8);
                    color: #aef;
                    border: 1px solid #4a8;
                    border-radius: 3px;
                    font-size: 11px;
                    width: 100%;
                `;
                skillInput.placeholder = 'ID do Skill';
                skillInput.value = item.skill;
                skillInput.dataset.rotationSkill = index;
                skillInput.addEventListener('blur', () => {
                    const value = parseInt(skillInput.value, 10);
                    if (!isNaN(value)) {
                        const newPattern = [...pattern];
                        newPattern[index].skill = value;
                        const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', newPattern);
                        context.config.update(patch);
                    }
                });
                
                // Count input
                const countInput = document.createElement('input');
                countInput.type = 'text';
                countInput.style.cssText = `
                    padding: 4px;
                    background: rgba(26, 42, 58, 0.8);
                    color: #aef;
                    border: 1px solid #4a8;
                    border-radius: 3px;
                    font-size: 11px;
                    width: 100%;
                `;
                countInput.placeholder = 'Qtd';
                countInput.value = item.count;
                countInput.dataset.rotationCount = index;
                countInput.addEventListener('blur', () => {
                    const value = parseInt(countInput.value, 10);
                    if (!isNaN(value) && value > 0) {
                        const newPattern = [...pattern];
                        newPattern[index].count = value;
                        const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', newPattern);
                        context.config.update(patch);
                    }
                });
                
                // Remove button
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'ðŸ—‘ï¸';
                removeBtn.style.cssText = `
                    padding: 4px 8px;
                    background: rgba(139, 42, 42, 0.5);
                    border: 1px solid #a44;
                    color: #faa;
                    border-radius: 3px;
                    cursor: pointer;
                    font-size: 12px;
                    min-width: 36px;
                `;
                removeBtn.dataset.rotationRemove = index;
                removeBtn.addEventListener('click', () => {
                    const newPattern = pattern.filter((_, i) => i !== index);
                    if (newPattern.length === 0) {
                        newPattern.push({ skill: 0, count: 1 });
                    }
                    const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', newPattern);
                    context.config.update(patch);
                    this.renderSmartRotationItems(context);
                });
                
                itemEl.appendChild(skillInput);
                itemEl.appendChild(countInput);
                itemEl.appendChild(removeBtn);
                rotationItemsContainer.appendChild(itemEl);
            });
        },
        
        startUltraFastBoss(context) {
            if (this.ultraFastBossState.running) {
                this.showToast(context, 'warn', 'Ultra Fast Boss', 'JÃ¡ estÃ¡ em execuÃ§Ã£o!');
                return;
            }
            
            // Check if on battle page (battle.php or dungeon_battle.php)
            const url = new URL(window.location.href);
            const pathname = window.location.pathname;
            const isBattlePage = /battle\.php$/i.test(pathname) || /dungeon_battle\.php$/i.test(pathname);
            
            // Get battle ID from various possible params
            let battleId = url.searchParams.get('id') || url.searchParams.get('dgmid') || url.searchParams.get('monster_id');
            const instanceId = url.searchParams.get('instance_id');
            
            // Detect battle type
            const isDungeon = /dungeon_battle\.php/i.test(pathname) || url.searchParams.has('dgmid') || url.searchParams.has('instance_id');
            
            if (!battleId || !isBattlePage) {
                this.showToast(context, 'error', 'Ultra Fast Boss', 'Navegue atÃ© battle.php ou dungeon_battle.php primeiro!');
                return;
            }
            
            // Check if boss ID changed - reset counters if so
            const previousBossId = this.ultraFastBossState.battleId;
            if (previousBossId && previousBossId !== battleId) {
                this.addLog('info', `ðŸ”„ Boss ID mudou (${previousBossId} â†’ ${battleId}), resetando contadores...`);
            }
            
            // Get config
            const cfg = context.config.get().ultraFastBoss || {};
            
            // Initialize state (reset counters if boss changed)
            const keepCounters = previousBossId === battleId;
            this.ultraFastBossState = {
                running: true,
                battleId: battleId,
                instanceId: instanceId,
                isDungeon: isDungeon,
                targetDamage: cfg.targetDamage || 1000000000,
                skillId: cfg.skillId ?? -2,
                autoPotion: cfg.autoPotion !== false,
                parallelAttacks: cfg.parallelAttacks || 10,
                minDelay: cfg.minDelayBetweenAttacks || 30,
                startTime: keepCounters ? (this.ultraFastBossState.startTime || Date.now()) : Date.now(),
                attackCount: keepCounters ? (this.ultraFastBossState.attackCount || 0) : 0,
                totalDamageDealt: keepCounters ? (this.ultraFastBossState.totalDamageDealt || 0) : 0,
                currentDamage: context.numbers.parse(document.querySelector('#yourDamageValue')?.textContent) || 0,
                potionsUsed: keepCounters ? (this.ultraFastBossState.potionsUsed || 0) : 0,
                healsUsed: keepCounters ? (this.ultraFastBossState.healsUsed || 0) : 0,
                currentStamina: 0,
                fullPotionInvId: null,
                fullPotionCount: 0
            };
            
            const battleType = isDungeon ? 'ðŸ° Dungeon Boss' : 'ðŸ‰ Boss';
            this.showToast(context, 'success', 'Ultra Fast Boss', `${battleType} iniciando! Alvo: ${context.numbers.formatCompact(this.ultraFastBossState.targetDamage)}`);
            this.addLog('info', `${battleType} iniciado - Alvo: ${context.numbers.formatCompact(this.ultraFastBossState.targetDamage)}, ID: ${battleId}${instanceId ? ', Instance: ' + instanceId : ''}`);
            
            // Update UI
            this.updateBossStatusUI(context);
            
            // Start the main loop
            this.runUltraFastBossLoop(context);
        },
        
        stopUltraFastBoss(context) {
            if (!this.ultraFastBossState.running) {
                this.showToast(context, 'warn', 'Ultra Fast Boss', 'NÃ£o estÃ¡ em execuÃ§Ã£o!');
                return;
            }
            
            this.ultraFastBossState.running = false;
            
            const elapsed = ((Date.now() - this.ultraFastBossState.startTime) / 1000).toFixed(1);
            const dps = this.ultraFastBossState.totalDamageDealt / (elapsed || 1);
            
            this.showToast(context, 'info', 'Ultra Fast Boss', `Parado! Dano: ${context.numbers.formatCompact(this.ultraFastBossState.currentDamage)}, DPS: ${context.numbers.formatCompact(dps)}/s`);
            this.addLog('warn', `ðŸ›‘ Ultra Fast Boss parado - Dano: ${context.numbers.formatCompact(this.ultraFastBossState.currentDamage)}, Ataques: ${this.ultraFastBossState.attackCount}, PoÃ§Ãµes: ${this.ultraFastBossState.potionsUsed}`);
            
            this.updateBossStatusUI(context);
        },
        
        resetUltraFastBoss(context) {
            // Stop if running
            if (this.ultraFastBossState.running) {
                this.ultraFastBossState.running = false;
            }
            
            // Clear sessionStorage
            sessionStorage.removeItem('UltraFastBoss_Progress');
            
            // Reset state completely
            this.ultraFastBossState = {
                running: false,
                battleId: null,
                instanceId: null,
                isDungeon: false,
                targetDamage: 0,
                skillId: -2,
                autoPotion: true,
                parallelAttacks: 10,
                minDelay: 30,
                startTime: null,
                attackCount: 0,
                totalDamageDealt: 0,
                currentDamage: 0,
                potionsUsed: 0,
                healsUsed: 0,
                currentStamina: 0,
                fullPotionInvId: null,
                fullPotionCount: 0
            };
            
            // Update UI to show reset state
            const { shadow } = context.ui;
            const statusDiv = shadow.querySelector('#autods-boss-status');
            if (statusDiv) statusDiv.style.display = 'none';
            
            this.showToast(context, 'success', 'Ultra Fast Boss', 'Contadores resetados!');
            this.addLog('info', 'ðŸ”„ Ultra Fast Boss - Contadores resetados');
        },
        
        async runUltraFastBossLoop(context) {
            const state = this.ultraFastBossState;
            const cfg = this.ultraFastBossConfig;
            
            // Get initial data
            state.currentStamina = context.numbers.parse(document.querySelector('#stamina_span')?.textContent) || 0;
            const potionBtn = document.querySelector('button.potion-use-btn[data-item="35"]');
            if (potionBtn) {
                state.fullPotionInvId = potionBtn.dataset.inv;
                state.fullPotionCount = parseInt(potionBtn.dataset.max || '0', 10);
            }
            
            const skillCost = cfg.skillCosts[state.skillId.toString()] || 1;
            
            while (state.running) {
                // Check player HP - if dead, need heal potion
                const playerHP = this.getPlayerHP(context);
                if (playerHP.current <= 0) {
                    this.addLog('warn', 'ðŸ’€ HP zerado! Tentando usar Heal Potion...');
                    const healResult = await this.useHealPotion(context);
                    
                    if (healResult.success) {
                        state.healsUsed++;
                        
                        // Page will likely reload after heal - save progress
                        const progress = {
                            battleId: state.battleId,
                            instanceId: state.instanceId,
                            isDungeon: state.isDungeon,
                            targetDamage: state.targetDamage,
                            skillId: state.skillId,
                            autoPotion: state.autoPotion,
                            parallelAttacks: state.parallelAttacks,
                            minDelay: state.minDelay,
                            currentDamage: state.currentDamage,
                            totalDamageDealt: state.totalDamageDealt,
                            attackCount: state.attackCount,
                            potionsUsed: state.potionsUsed,
                            healsUsed: state.healsUsed,
                            startTime: state.startTime,
                            autoResume: true
                        };
                        sessionStorage.setItem('UltraFastBoss_Progress', JSON.stringify(progress));
                        
                        // Wait for server to process, then reload
                        await sleep(500);
                        window.location.reload();
                        return;
                    } else {
                        this.showToast(context, 'error', 'Ultra Fast Boss', 'HP zerado e sem Heal Potions!');
                        this.addLog('error', 'âŒ NÃ£o foi possÃ­vel usar Heal Potion - parando');
                        state.running = false;
                        break;
                    }
                }
                
                // Check target reached
                if (state.currentDamage >= state.targetDamage) {
                    this.showToast(context, 'success', 'ðŸŽ‰ Ultra Fast Boss', `META ATINGIDA! ${context.numbers.formatCompact(state.currentDamage)}`);
                    this.addLog('success', `ðŸŽ‰ Ultra Fast Boss - META ATINGIDA: ${context.numbers.formatCompact(state.currentDamage)}`);
                    state.running = false;
                    break;
                }
                
                // Check stamina
                if (state.currentStamina < skillCost) {
                    if (!state.autoPotion) {
                        this.showToast(context, 'warn', 'Ultra Fast Boss', 'Stamina esgotada! Sem poÃ§Ãµes configuradas.');
                        state.running = false;
                        break;
                    }
                    
                    // Use potion and reload
                    this.addLog('info', 'ðŸ’Š Usando Full Stamina Potion...');
                    const potionResult = await this.useBossPotion(context);
                    
                    if (potionResult.success) {
                        state.potionsUsed++;
                        
                        // Save progress and reload
                        const progress = {
                            battleId: state.battleId,
                            instanceId: state.instanceId,
                            isDungeon: state.isDungeon,
                            targetDamage: state.targetDamage,
                            skillId: state.skillId,
                            autoPotion: state.autoPotion,
                            parallelAttacks: state.parallelAttacks,
                            minDelay: state.minDelay,
                            currentDamage: state.currentDamage,
                            totalDamageDealt: state.totalDamageDealt,
                            attackCount: state.attackCount,
                            potionsUsed: state.potionsUsed,
                            healsUsed: state.healsUsed,
                            startTime: state.startTime,
                            autoResume: true
                        };
                        sessionStorage.setItem('UltraFastBoss_Progress', JSON.stringify(progress));
                        
                        this.addLog('info', 'ðŸ”„ Recarregando pÃ¡gina para sincronizar stamina...');
                        window.location.reload();
                        return;
                    } else {
                        this.showToast(context, 'error', 'Ultra Fast Boss', 'Falha ao usar poÃ§Ã£o!');
                        state.running = false;
                        break;
                    }
                }
                
                // Calculate attacks
                const possibleAttacks = Math.floor(state.currentStamina / skillCost);
                const attackCount = Math.min(possibleAttacks, state.parallelAttacks);
                
                if (attackCount <= 0) {
                    await sleep(100);
                    continue;
                }
                
                // Execute parallel attacks (pass isDungeon and instanceId for proper endpoint)
                const results = await this.executeBossParallelAttacks(context, state.battleId, state.skillId, attackCount, state.isDungeon, state.instanceId);
                
                state.attackCount += results.successCount;
                state.totalDamageDealt += results.totalDamage;
                state.currentDamage += results.totalDamage;
                state.currentStamina = results.lastStamina !== null ? results.lastStamina : Math.max(0, state.currentStamina - (attackCount * skillCost));
                
                // Update DOM display
                const damageEl = document.querySelector('#yourDamageValue');
                if (damageEl) damageEl.textContent = state.currentDamage.toLocaleString();
                const staminaEl = document.querySelector('#stamina_span');
                if (staminaEl) staminaEl.textContent = Math.max(0, state.currentStamina).toLocaleString();
                
                // Update UI
                this.updateBossStatusUI(context);
                
                await sleep(state.minDelay);
            }
            
            // Final stats
            const elapsed = ((Date.now() - state.startTime) / 1000).toFixed(1);
            const dps = state.totalDamageDealt / (elapsed || 1);
            this.addLog('success', `âœ… Ultra Fast Boss finalizado - Dano: ${context.numbers.formatCompact(state.currentDamage)}, DPS: ${context.numbers.formatCompact(dps)}/s, Tempo: ${elapsed}s`);
            
            this.updateBossStatusUI(context);
        },
        
        async executeBossParallelAttacks(context, battleId, skillId, count, isDungeon = false, instanceId = null) {
            // Use centralized combat service for both wave and dungeon attacks
            const attackPromises = Array.from({ length: count }, async () => {
                try {
                    if (isDungeon && instanceId) {
                        return await context.combat.attackDungeonMonsterDirect(battleId, instanceId, skillId);
                    } else {
                        return await context.combat.attackWaveMonsterDirect(battleId, skillId);
                    }
                } catch (error) {
                    return { success: false };
                }
            });
            
            const results = await Promise.all(attackPromises);
            
            let totalDamage = 0, successCount = 0, lastStamina = null;
            for (const r of results) {
                if (r.success) {
                    totalDamage += r.damageDealt || 0;
                    successCount++;
                    if (r.stamina !== undefined) lastStamina = r.stamina;
                }
            }
            
            return { totalDamage, successCount, lastStamina };
        },
        
        async useBossPotion(context) {
            // Use centralized inventory service for Full Stamina Potion
            try {
                const result = await context.inventory.useFullStaminaPotion();
                return { success: result };
            } catch (error) {
                return { success: false };
            }
        },
        
        /**
         * Get current player HP from DOM
         * @returns {{ current: number, max: number }} Player HP
         */
        getPlayerHP(context) {
            // Try #pHpText first: "ðŸ’š 27,000 / 44,500 HP"
            const hpText = document.querySelector('#pHpText');
            if (hpText) {
                const text = hpText.textContent || '';
                const match = text.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                if (match) {
                    return {
                        current: context.numbers.parse(match[1]),
                        max: context.numbers.parse(match[2])
                    };
                }
            }
            
            // Fallback to .card-sub: "27,000 / 44,500"
            const cardSub = document.querySelector('.battle-card.player-card .card-sub, .player-card .card-sub');
            if (cardSub) {
                const text = cardSub.textContent || '';
                const match = text.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                if (match) {
                    return {
                        current: context.numbers.parse(match[1]),
                        max: context.numbers.parse(match[2])
                    };
                }
            }
            
            // Fallback: #pHpFill width percentage
            const hpFill = document.querySelector('#pHpFill');
            if (hpFill) {
                const widthStr = hpFill.style.width || '0%';
                const pct = parseFloat(widthStr) || 0;
                // Without max, assume 100% means alive
                return { current: pct > 0 ? 1 : 0, max: 100 };
            }
            
            return { current: 0, max: 0 };
        },
        
        /**
         * Use Heal Potion to restore player HP
         * @returns {Promise<{ success: boolean }>}
         */
        async useHealPotion(context) {
            this.addLog('info', 'ðŸ’š Usando Heal Potion...');
            
            // Use centralized inventory service for Heal Potion
            try {
                const result = await context.inventory.useHealPotion();
                if (result) {
                    this.addLog('success', 'âœ… Heal Potion usada com sucesso!');
                    // Wait for HP to update
                    await sleep(1000);
                    return { success: true };
                } else {
                    this.addLog('warn', 'âš ï¸ Sem Heal Potions disponÃ­veis!');
                    return { success: false };
                }
            } catch (error) {
                this.addLog('error', `âŒ Erro ao usar heal: ${error.message}`);
                return { success: false };
            }
        },
        
        updateBossStatusUI(context) {
            const state = this.ultraFastBossState;
            const { shadow } = context.ui;
            const { numbers } = context;
            
            const statusDiv = shadow.querySelector('#autods-boss-status');
            if (statusDiv) statusDiv.style.display = 'block';
            
            const runningEl = shadow.querySelector('#autods-boss-running');
            if (runningEl) runningEl.textContent = state.running ? 'ðŸŸ¢ Executando' : 'ðŸ”´ Parado';
            
            const bossIdEl = shadow.querySelector('#autods-boss-id');
            if (bossIdEl) {
                const typeIcon = state.isDungeon ? 'ðŸ°' : 'ðŸ‰';
                const idText = state.battleId ? `${typeIcon} ${state.battleId}${state.instanceId ? ' (inst:' + state.instanceId + ')' : ''}` : '-';
                bossIdEl.textContent = idText;
            }
            
            const damageEl = shadow.querySelector('#autods-boss-damage');
            if (damageEl) damageEl.textContent = numbers.formatCompact(state.currentDamage);
            
            const targetEl = shadow.querySelector('#autods-boss-target');
            if (targetEl) targetEl.textContent = numbers.formatCompact(state.targetDamage);
            
            const progressEl = shadow.querySelector('#autods-boss-progress');
            if (progressEl) {
                const pct = state.targetDamage > 0 ? ((state.currentDamage / state.targetDamage) * 100).toFixed(1) : 0;
                progressEl.textContent = `${pct}%`;
            }
            
            const attacksEl = shadow.querySelector('#autods-boss-attacks');
            if (attacksEl) attacksEl.textContent = state.attackCount.toLocaleString();
            
            const potionsEl = shadow.querySelector('#autods-boss-potions');
            if (potionsEl) potionsEl.textContent = state.potionsUsed.toString();
            
            const healsEl = shadow.querySelector('#autods-boss-heals');
            if (healsEl) healsEl.textContent = (state.healsUsed || 0).toString();
        },
        
        checkAndResumeUltraFastBoss(context) {
            const saved = sessionStorage.getItem('UltraFastBoss_Progress');
            if (!saved) return;
            
            try {
                const progress = JSON.parse(saved);
                if (progress.autoResume) {
                    sessionStorage.removeItem('UltraFastBoss_Progress');
                    
                    const battleType = progress.isDungeon ? 'ðŸ° Dungeon Boss' : 'ðŸ‰ Boss';
                    this.addLog('info', `ðŸ”„ Resumindo ${battleType} apÃ³s reload...`);
                    
                    this.ultraFastBossState = {
                        running: true,
                        battleId: progress.battleId,
                        instanceId: progress.instanceId || null,
                        isDungeon: progress.isDungeon || false,
                        targetDamage: progress.targetDamage,
                        skillId: progress.skillId,
                        autoPotion: progress.autoPotion,
                        parallelAttacks: progress.parallelAttacks || 10,
                        minDelay: progress.minDelay || 30,
                        startTime: progress.startTime,
                        attackCount: progress.attackCount,
                        totalDamageDealt: progress.totalDamageDealt,
                        currentDamage: progress.currentDamage,
                        potionsUsed: progress.potionsUsed,
                        healsUsed: progress.healsUsed || 0,
                        currentStamina: 0,
                        fullPotionInvId: null,
                        fullPotionCount: 0
                    };
                    
                    this.showToast(context, 'info', 'Ultra Fast Boss', 'Resumindo apÃ³s poÃ§Ã£o...');
                    this.updateBossStatusUI(context);
                    this.runUltraFastBossLoop(context);
                }
            } catch (e) {
                sessionStorage.removeItem('UltraFastBoss_Progress');
            }
        },
        
        pruneExpiredToasts() {
            if (!this.state?.toasts?.length) return false;
            const now = Date.now();
            const beforeLength = this.state.toasts.length;
            this.state.toasts = this.state.toasts.filter(toast => toast.expiresAt == null || toast.expiresAt > now);
            return beforeLength !== this.state.toasts.length;
        },
        renderToasts(context, config) {
            const container = this.toastContainer;
            const effectiveConfig = config || context.config.get();
            if (!container || !effectiveConfig.ui) return;

            const enabled = Boolean(effectiveConfig.ui.toasts?.enabled);
            this.updateToastPosition(context, effectiveConfig);

            if (!enabled) {
                container.innerHTML = '';
                container.style.display = 'none';
                return;
            }

            container.style.display = '';
            this.pruneExpiredToasts();

            container.innerHTML = '';
            if (!this.state.toasts.length) {
                return;
            }

            this.state.toasts.forEach(toast => {
                const el = document.createElement('div');
                el.className = 'autods-toast';
                el.dataset.level = toast.level || 'info';

                const body = document.createElement('div');
                body.className = 'body';
                const titleEl = document.createElement('div');
                titleEl.className = 'title';
                titleEl.textContent = toast.title || 'AutoDS';
                const messageEl = document.createElement('div');
                messageEl.className = 'message';
                messageEl.textContent = toast.message || '';
                const timeEl = document.createElement('div');
                timeEl.className = 'time';
                const formatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                timeEl.textContent = formatter.format(new Date(toast.createdAt));

                body.appendChild(titleEl);
                body.appendChild(messageEl);
                body.appendChild(timeEl);
                el.appendChild(body);

                if (toast.expiresAt != null) {
                    el.addEventListener('click', () => this.removeToast(context, toast.id));
                }

                container.appendChild(el);
            });
        },
        // REMOVIDO: Modal de ConfiguraÃ§Ãµes AvanÃ§adas (substituÃ­do por configuraÃ§Ãµes inline no painel)
        applySectionStates(config) {
            if (!this.elements) return;
            const states = config.ui?.panelStates || {};
            const ids = ['stats', 'configs', 'automation', 'status', 'events'];
            ids.forEach(id => {
                const section = this.elements.sections?.[id];
                const body = this.elements.sectionBodies?.[id];
                const toggle = this.elements.sectionToggles?.[id];
                const collapsed = Boolean(states[id]);
                if (section) {
                    section.setAttribute('data-collapsed', collapsed ? '1' : '0');
                }
                if (body) {
                    body.hidden = collapsed;
                }
                if (toggle) {
                    toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
                    toggle.textContent = collapsed ? 'â–¸' : 'â–¾';
                }
            });
        },
        ensureMobileToggle(context, panelContainer) {
            const doc = context.document;
            if (!doc) return;

            // Check if toggle button already exists
            let toggleButton = doc.getElementById('autods-mobile-toggle-btn');
            if (toggleButton) {
                this.mobileToggleButton = toggleButton;
                return;
            }

            // Create the toggle button in the main document (not shadow DOM)
            toggleButton = doc.createElement('button');
            toggleButton.id = 'autods-mobile-toggle-btn';
            toggleButton.type = 'button';
            toggleButton.className = 'autods-mobile-toggle';
            toggleButton.setAttribute('aria-label', 'Toggle painel');
            toggleButton.textContent = 'â˜°';

            // Add styles to main document if not already present
            if (!doc.getElementById('autods-mobile-toggle-style')) {
                const style = doc.createElement('style');
                style.id = 'autods-mobile-toggle-style';
                style.textContent = `
                    .autods-mobile-toggle {
                        display: none;
                        position: fixed;
                        bottom: 90px;
                        left: 10px;
                        z-index: 2147483647;
                        width: 44px;
                        height: 44px;
                        background: rgba(20, 40, 70, 0.95);
                        border: 2px solid rgba(70, 130, 220, 0.5);
                        border-radius: 12px;
                        color: #a8d0ff;
                        font-size: 20px;
                        cursor: pointer;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                        backdrop-filter: blur(10px);
                        align-items: center;
                        justify-content: center;
                        transition: all 0.2s ease;
                    }
                    .autods-mobile-toggle:hover {
                        background: rgba(30, 60, 100, 0.95);
                        border-color: rgba(100, 160, 255, 0.7);
                        transform: scale(1.05);
                    }
                    .autods-mobile-toggle:active {
                        transform: scale(0.95);
                    }
                    @media (max-width: 480px) {
                        .autods-mobile-toggle {
                            display: flex !important;
                        }
                    }
                `;
                doc.head.appendChild(style);
            }

            // Add click handler
            toggleButton.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();

                const shell = panelContainer;
                if (!shell) return;

                const isCollapsed = shell.getAttribute('data-mobile-collapsed') === '1';
                shell.setAttribute('data-mobile-collapsed', isCollapsed ? '0' : '1');
                toggleButton.textContent = isCollapsed ? 'âœ•' : 'â˜°';
                toggleButton.setAttribute('aria-label', isCollapsed ? 'Fechar painel' : 'Toggle painel');

                // Toggle body class for mobile overflow control
                if (window.innerWidth <= 480) {
                    doc.body.classList.toggle('autods-panel-visible', isCollapsed);
                }
            });

            // Insert button into document body
            const placeButton = () => {
                if (doc.body && !toggleButton.parentElement) {
                    doc.body.appendChild(toggleButton);
                    return true;
                }
                return false;
            };

            const placed = placeButton();
            if (!placed) {
                doc.addEventListener('DOMContentLoaded', () => {
                    placeButton();
                }, { once: true });
            }

            // Auto-collapse panel by default (desktop and mobile)
            // With external floating buttons, panel starts minimized
            panelContainer.setAttribute('data-mobile-collapsed', '1');
            doc.body.classList.remove('autods-panel-visible');

            // Handle window resize
            window.addEventListener('resize', () => {
                if (window.innerWidth > 480) {
                    panelContainer.setAttribute('data-mobile-collapsed', '0');
                    doc.body.classList.remove('autods-panel-visible');
                    doc.body.classList.add('autods-shell-open');
                    toggleButton.textContent = 'â˜°';
                }
            });

            // Close panel when clicking outside on mobile
            doc.addEventListener('click', (event) => {
                if (window.innerWidth <= 480) {
                    const target = event.target;
                    const isInsidePanel = panelContainer.contains(target) || context.ui.root.contains(target);
                    const isToggleButton = toggleButton.contains(target);

                    if (!isInsidePanel && !isToggleButton && panelContainer.getAttribute('data-mobile-collapsed') === '0') {
                        panelContainer.setAttribute('data-mobile-collapsed', '1');
                        toggleButton.textContent = 'â˜°';
                        doc.body.classList.remove('autods-panel-visible');
                        doc.body.classList.remove('autods-shell-open');
                    }
                }
            });

            // Add keyboard shortcut Ctrl+Shift+P to toggle panel
            doc.addEventListener('keydown', (event) => {
                if (event.ctrlKey && event.shiftKey && event.key === 'P') {
                    event.preventDefault();
                    const isCollapsed = panelContainer.getAttribute('data-mobile-collapsed') === '1';
                    panelContainer.setAttribute('data-mobile-collapsed', isCollapsed ? '0' : '1');
                    toggleButton.textContent = isCollapsed ? 'âœ•' : 'â˜°';
                    toggleButton.setAttribute('aria-label', isCollapsed ? 'Fechar painel' : 'Toggle painel');

                    if (window.innerWidth <= 480) {
                        doc.body.classList.toggle('autods-panel-visible', isCollapsed);
                    }
                    // Add/remove shell-open class
                    doc.body.classList.toggle('autods-shell-open', isCollapsed);
                }
            });

            this.mobileToggleButton = toggleButton;
        },
        ensureDesktopToggle(context, panelContainer) {
            const doc = context.document;
            if (!doc) return;

            // Check if toggle button already exists
            let toggleButton = doc.getElementById('autods-panel-toggle-btn');
            if (toggleButton) {
                this.desktopToggleButton = toggleButton;
                return;
            }

            // Create the toggle button in the main document (not shadow DOM)
            toggleButton = doc.createElement('button');
            toggleButton.id = 'autods-panel-toggle-btn';
            toggleButton.type = 'button';
            toggleButton.setAttribute('aria-label', 'Abrir painel');
            toggleButton.setAttribute('title', 'Abrir painel (Ctrl+Shift+P)');
            toggleButton.innerHTML = 'âš™ï¸';

            // Add click handler
            toggleButton.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();

                const shell = panelContainer;
                if (!shell) return;

                const isCollapsed = shell.getAttribute('data-mobile-collapsed') === '1';
                
                if (isCollapsed) {
                    // Reabrir painel
                    shell.setAttribute('data-mobile-collapsed', '0');
                    doc.body.classList.add('autods-layout-ready');
                    doc.body.classList.add('autods-shell-open');
                    toggleButton.setAttribute('aria-label', 'Fechar painel');
                    toggleButton.setAttribute('title', 'Fechar painel (Ctrl+Shift+P)');
                    toggleButton.classList.remove('visible');
                } else {
                    // Fechar painel
                    shell.setAttribute('data-mobile-collapsed', '1');
                    doc.body.classList.remove('autods-layout-ready');
                    doc.body.classList.remove('autods-shell-open');
                    toggleButton.setAttribute('aria-label', 'Abrir painel');
                    toggleButton.setAttribute('title', 'Abrir painel (Ctrl+Shift+P)');
                    toggleButton.classList.add('visible');
                }
            });

            // ðŸ†• Function to try inserting into floating helpers
            const tryInsertIntoFloatingHelpers = () => {
                const floatingHelpers = doc.getElementById('autods-floating-helpers');
                if (floatingHelpers && !toggleButton.parentElement) {
                    floatingHelpers.insertBefore(toggleButton, floatingHelpers.firstChild);
                    console.log('[DesktopToggle] Button inserted into autods-floating-helpers');
                    return true;
                }
                return false;
            };

            // Try immediately
            if (!tryInsertIntoFloatingHelpers()) {
                // If floating helpers not ready yet, try again with retry logic
                let retries = 0;
                const retryInterval = setInterval(() => {
                    if (tryInsertIntoFloatingHelpers()) {
                        clearInterval(retryInterval);
                    }
                    retries++;
                    if (retries > 20) { // 2 seconds (20 * 100ms)
                        clearInterval(retryInterval);
                        // Fallback: Insert into body
                        if (doc.body && !toggleButton.parentElement) {
                            doc.body.appendChild(toggleButton);
                            console.log('[DesktopToggle] Button inserted into body (floating helpers not found)');
                        }
                    }
                }, 100);
            }

            this.desktopToggleButton = toggleButton;
        },
        renderConfigs(context, config) {
            if (!this.elements) return;
            this.syncConfigInputs(config);
        }
    };

    // REMOVIDO: Quest Widget (fetch bloqueado pelo site - HTTP 403)

    // Guild Dungeon Loot All Button
    function addGuildDungeonLootAllButton() {
        // Verificar se estamos em pÃ¡gina de guild dungeon
        if (!window.location.pathname.includes('guild_dungeon_location.php')) {
            return;
        }

        // Verificar se jÃ¡ existe o botÃ£o
        if (document.getElementById('autods-guild-loot-all')) {
            return;
        }

        // Buscar o elemento "ðŸ‘¾ Monsters in this location"
        const monsterHeaders = Array.from(document.querySelectorAll('.h')).filter(h =>
            h.textContent.includes('ðŸ‘¾ Monsters in this location')
        );

        if (monsterHeaders.length === 0) {
            return;
        }

        const monsterHeader = monsterHeaders[0];

        // Contar quantos botÃµes .autods-loot-btn existem
        const lootButtons = document.querySelectorAll('.autods-loot-btn');
        if (lootButtons.length === 0) {
            return;
        }

        // Criar botÃ£o Loot All
        const lootAllBtn = document.createElement('button');
        lootAllBtn.id = 'autods-guild-loot-all';
        lootAllBtn.className = 'btn';
        lootAllBtn.style.cssText = `
            margin-left: 12px;
            background: linear-gradient(135deg, #a6e3a1 0%, #74c7ec 100%);
            color: #1e1e2e;
            border: none;
            font-weight: bold;
            padding: 6px 12px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(166, 227, 161, 0.3);
        `;
        lootAllBtn.innerHTML = `ðŸ’° Loot All (${lootButtons.length})`;
        lootAllBtn.title = 'Fazer loot de todos os monstros elegÃ­veis nesta localizaÃ§Ã£o';

        // Hover effects
        lootAllBtn.addEventListener('mouseenter', () => {
            lootAllBtn.style.transform = 'translateY(-2px)';
            lootAllBtn.style.boxShadow = '0 4px 12px rgba(166, 227, 161, 0.5)';
        });
        lootAllBtn.addEventListener('mouseleave', () => {
            lootAllBtn.style.transform = 'translateY(0)';
            lootAllBtn.style.boxShadow = '0 2px 6px rgba(166, 227, 161, 0.3)';
        });

        // Click handler
        lootAllBtn.addEventListener('click', async () => {
            const originalText = lootAllBtn.innerHTML;
            lootAllBtn.disabled = true;
            lootAllBtn.innerHTML = 'â³ Looting...';
            lootAllBtn.style.opacity = '0.6';

            try {
                const buttons = Array.from(document.querySelectorAll('.autods-loot-btn'));
                let success = 0;
                let failed = 0;

                for (let i = 0; i < buttons.length; i++) {
                    const btn = buttons[i];

                    try {
                        // Simular clique no botÃ£o
                        btn.click();

                        // Aguardar resposta
                        await new Promise(resolve => setTimeout(resolve, 500));

                        success++;
                        lootAllBtn.innerHTML = `â³ ${i + 1}/${buttons.length}...`;
                    } catch (error) {
                        failed++;
                        console.error('Erro ao fazer loot:', error);
                    }

                    // Delay entre loots
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                // Resultado final
                lootAllBtn.innerHTML = `âœ… ${success} looted!`;
                lootAllBtn.style.background = 'linear-gradient(135deg, #a6e3a1 0%, #94e2d5 100%)';

                setTimeout(() => {
                    lootAllBtn.innerHTML = originalText;
                    lootAllBtn.disabled = false;
                    lootAllBtn.style.opacity = '1';
                    lootAllBtn.style.background = 'linear-gradient(135deg, #a6e3a1 0%, #74c7ec 100%)';
                }, 2000);

            } catch (error) {
                console.error('Erro no loot all:', error);
                lootAllBtn.innerHTML = 'âŒ Error';
                lootAllBtn.style.background = 'linear-gradient(135deg, #f38ba8 0%, #eba0ac 100%)';

                setTimeout(() => {
                    lootAllBtn.innerHTML = originalText;
                    lootAllBtn.disabled = false;
                    lootAllBtn.style.opacity = '1';
                    lootAllBtn.style.background = 'linear-gradient(135deg, #a6e3a1 0%, #74c7ec 100%)';
                }, 2000);
            }
        });

        // Inserir o botÃ£o apÃ³s o header
        monsterHeader.appendChild(lootAllBtn);
    }

    // Dungeon Pills Functions
    function addDungeonPills() {
        // Verificar se estamos em pÃ¡gina de dungeon
        if (!window.location.pathname.includes('active_wave.php') &&
            !window.location.pathname.includes('wave.php')) {
            return;
        }

        const cfg = JSON.parse(localStorage.getItem('autods.v1:config') || '{}');
        if (!cfg.dungeonWave) return;

        const showDamagePills = cfg.dungeonWave.showDamagePills !== false; // default true
        const showExpPills = cfg.dungeonWave.showExpPills !== false; // default true

        if (!showDamagePills && !showExpPills) return;

        // Buscar todos os monster cards
        const monsterCards = document.querySelectorAll('.monster-card');
        if (!monsterCards.length) return;

        monsterCards.forEach(card => {
            // Evitar duplicaÃ§Ã£o
            if (card.querySelector('.dungeon-pills')) return;

            // Extrair HP atual e mÃ¡ximo
            const hpNode = card.querySelector('[data-stat="hp"], .hp-text, .hp-value, .monster-hp, .hp-bar + div, .hp');
            if (!hpNode) return;

            const hpText = hpNode.getAttribute?.('data-current-hp') ?? hpNode.textContent ?? '';

            // Parse HP (formato: "â¤ï¸ 123,456 / 1,234,567 HP" ou "123456 / 1234567")
            const hpMatch = hpText.match(/([\d,]+)\s*\/\s*([\d,]+)/);
            if (!hpMatch) return;

            const currentHP = parseInt(hpMatch[1].replace(/,/g, '')) || 0;
            const maxHP = parseInt(hpMatch[2].replace(/,/g, '')) || 0;

            if (maxHP === 0) return;

            // Calcular damage e exp esperados
            const expectedDamage = calculateExpectedDungeonDamage(currentHP, maxHP);
            const expectedExp = calculateExpectedExp(currentHP, maxHP);

            // Criar container de pills
            const pillsContainer = document.createElement('div');
            pillsContainer.className = 'dungeon-pills';
            pillsContainer.style.cssText = `
                display: flex;
                gap: 6px;
                justify-content: center;
                margin: 8px 0 4px;
                flex-wrap: wrap;
            `;

            // Adicionar pill de damage
            if (showDamagePills && expectedDamage > 0) {
                const damagePill = document.createElement('div');
                damagePill.className = 'pill-item pill-damage';
                damagePill.style.cssText = `
                    background: linear-gradient(135deg, #f38ba8 0%, #f5c2e7 100%);
                    color: #1e1e2e;
                    padding: 4px 10px;
                    border-radius: 12px;
                    font-size: 11px;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    box-shadow: 0 2px 6px rgba(243, 139, 168, 0.3);
                    transition: transform 0.2s, box-shadow 0.2s;
                    cursor: help;
                `;
                damagePill.title = `Dano estimado: ${formatNumber(expectedDamage)} (15-25% do HP atual)`;
                damagePill.innerHTML = `<span>âš”ï¸</span><span>~${formatNumber(expectedDamage)}</span>`;

                // Hover effect
                damagePill.addEventListener('mouseenter', () => {
                    damagePill.style.transform = 'translateY(-2px) scale(1.05)';
                    damagePill.style.boxShadow = '0 4px 12px rgba(243, 139, 168, 0.5)';
                });
                damagePill.addEventListener('mouseleave', () => {
                    damagePill.style.transform = 'translateY(0) scale(1)';
                    damagePill.style.boxShadow = '0 2px 6px rgba(243, 139, 168, 0.3)';
                });

                pillsContainer.appendChild(damagePill);
            }

            // Adicionar pill de exp
            if (showExpPills && expectedExp > 0) {
                const expPill = document.createElement('div');
                expPill.className = 'pill-item pill-exp';
                expPill.style.cssText = `
                    background: linear-gradient(135deg, #89dceb 0%, #74c7ec 100%);
                    color: #1e1e2e;
                    padding: 4px 10px;
                    border-radius: 12px;
                    font-size: 11px;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    box-shadow: 0 2px 6px rgba(137, 220, 235, 0.3);
                    transition: transform 0.2s, box-shadow 0.2s;
                    cursor: help;
                `;
                expPill.title = `EXP estimado: ${formatNumber(expectedExp)} (base 10% do HP + bÃ´nus de ratio)`;
                expPill.innerHTML = `<span>âœ¨</span><span>~${formatNumber(expectedExp)}</span>`;

                // Hover effect
                expPill.addEventListener('mouseenter', () => {
                    expPill.style.transform = 'translateY(-2px) scale(1.05)';
                    expPill.style.boxShadow = '0 4px 12px rgba(137, 220, 235, 0.5)';
                });
                expPill.addEventListener('mouseleave', () => {
                    expPill.style.transform = 'translateY(0) scale(1)';
                    expPill.style.boxShadow = '0 2px 6px rgba(137, 220, 235, 0.3)';
                });

                pillsContainer.appendChild(expPill);
            }

            // Inserir pills no card (apÃ³s HP bar)
            const hpBar = card.querySelector('.hp-bar');
            if (hpBar && hpBar.nextSibling) {
                hpBar.parentNode.insertBefore(pillsContainer, hpBar.nextSibling.nextSibling);
            } else {
                // Fallback: adicionar antes dos botÃµes
                const button = card.querySelector('button, .join-btn, a');
                if (button) {
                    button.parentNode.insertBefore(pillsContainer, button);
                } else {
                    card.appendChild(pillsContainer);
                }
            }
        });
    }

    // Smart Damage Calculation Functions
    function addSmartDamageDisplay() {
        if (!window.location.pathname.includes('stats.php')) return;

        const attackElement = document.getElementById('v-attack');
        if (!attackElement) return;

        const attackValue = parseInt(attackElement.textContent.replace(/,/g, '')) || 0;

        // Encontrar o card de stats (segundo card no grid)
        const statCards = document.querySelectorAll('.grid .card');
        if (statCards.length < 2) return;

        const statCard = statCards[1]; // Segundo card (Current Stats)

        // Verificar se jÃ¡ adicionamos (evitar duplicatas)
        if (statCard.querySelector('.autods-damage-calc')) return;

        // Adicionar separador
        const separator = document.createElement('hr');
        separator.style.cssText = 'border:0;border-top:1px solid #333;margin:10px 0';
        statCard.appendChild(separator);

        // Pegar valores de defesa da config ou usar padrÃ£o
        const cfg = JSON.parse(localStorage.getItem('autods.v1:config') || '{}');
        const defenseValues = cfg.smartDamageCalc?.defenseValues || [0, 25, 50];

        // Adicionar rows de damage calculation
        const tempNumbers = createNumberFormattingService();
        defenseValues.forEach(def => {
            const damage = tempNumbers.calculateDamageVsDefense(attackValue, def);

            const row = document.createElement('div');
            row.className = 'row autods-damage-calc';
            row.style.cssText = 'color: #f38ba8; cursor: help;';
            row.title = `Calculated damage against monsters with ${def} DEF\nFormula: DMG = 1000 Ã— (ATK - DEF)^0.25`;

            const label = document.createElement('span');
            label.textContent = `ATK DMG vs ${def} DEF`;

            const value = document.createElement('span');
            value.textContent = formatNumber(damage);
            value.style.fontWeight = 'bold';

            row.appendChild(label);
            row.appendChild(value);
            statCard.appendChild(row);
        });
    }

    // ========================================
    // AUTO BOSS MODULE
    // ========================================
    const autoBossModule = {
        id: 'autoBoss',
        match: ({ location }) => /battle\.php/i.test(location.pathname) && !/pvp.*battle/i.test(location.pathname),
        init(context) {
            this.state = {
                running: false,
                totalDamage: 0,
                attackCount: 0,
                potionsUsed: 0,
                startTime: null
            };
        },
        activate(context) {
            const cfg = context.config.get();
            if (!cfg.core.enabled || !cfg.autoBoss || !cfg.autoBoss.enabled) {
                if (this.state) {
                    this.state.running = false;
                }
                return;
            }

            // Don't run if regular battle automation is enabled to avoid conflicts
            if (cfg.battle?.enabled) {
                context.logger.warn('âš ï¸ AutoBoss: MÃ³dulo battle regular estÃ¡ ativado. Desative-o para usar AutoBoss.');
                return;
            }

            if (!this.state) this.init(context);
            if (this.state.running) return;

            this.state.running = true;
            this.state.startTime = Date.now();

            // Override window.confirm globally for AutoBoss to auto-accept potion usage
            if (!window._autoBossConfirmOverridden) {
                this.state.originalConfirm = window.confirm;
                window.confirm = (message) => {
                    context.logger.debug(`âœ… AutoBoss: Auto-aceitando confirm: "${message}"`);
                    return true; // Always accept
                };
                window._autoBossConfirmOverridden = true;
                context.logger.debug('ðŸ”§ AutoBoss: window.confirm() override ativado');
            }

            (async () => {
                try {
                    await this.runAutoBoss(context);
                } catch (error) {
                    context.logger.error('âŒ Falha no AutoBoss', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },
        getSkillStaminaCost(button) {
            if (!button) return 0;

            const dataStamina = button.dataset?.staminaCost || button.getAttribute('data-stamina-cost');
            if (dataStamina) {
                const cost = parseInt(dataStamina, 10);
                if (!isNaN(cost)) return cost;
            }

            const buttonText = button.dataset?.skillName || button.getAttribute('data-skill-name') || button.textContent || '';
            const match = buttonText.match(/\((\d+)\s*STAMINA\)/i);
            if (match) {
                const cost = parseInt(match[1], 10);
                if (!isNaN(cost)) return cost;
            }

            return 0;
        },
        getAllAttackButtons(dom) {
            const buttons = dom.queryAll('.attack-btn, button[data-skill-id], button.skill-button');
            return buttons.filter(btn => !btn.disabled && !btn.classList.contains('is-loading'));
        },
        selectBestAttackButton(context, buttons, currentStamina) {
            if (!buttons || buttons.length === 0) {
                context.logger.debug('âŒ AutoBoss: Nenhum botÃ£o disponÃ­vel para seleÃ§Ã£o');
                return null;
            }

            // If stamina is 0 or negative, don't try to attack
            if (currentStamina <= 0) {
                context.logger.debug('âŒ AutoBoss: Stamina = 0, nenhum ataque possÃ­vel');
                return null;
            }

            let bestButton = null;
            let highestCost = -1;

            for (const button of buttons) {
                const cost = this.getSkillStaminaCost(button);

                // Only consider buttons that we can afford
                if (cost <= currentStamina && cost > highestCost) {
                    highestCost = cost;
                    bestButton = button;
                }
            }

            if (bestButton) {
                const skillName = bestButton.dataset?.skillName || bestButton.getAttribute('data-skill-name') || 'Unknown';
                context.logger.debug(`ðŸŽ¯ AutoBoss: Selecionado ${skillName} (custo: ${highestCost} stamina, disponÃ­vel: ${currentStamina})`);
            } else {
                context.logger.debug(`âŒ AutoBoss: Nenhum ataque disponÃ­vel com stamina ${currentStamina}`);
            }

            return bestButton;
        },
        getCurrentDamage(dom) {
            const damageElement = dom.query('#totalDamage, .total-damage, [data-total-damage]');
            if (!damageElement) return 0;

            const text = damageElement.textContent || damageElement.dataset?.totalDamage || '0';
            return numberFromText(text) || 0;
        },
        getMonsterHp(dom) {
            const hpElement = dom.query('.hp-text, .monster-hp-text, [data-monster-hp]');
            if (!hpElement) return null;

            const text = hpElement.textContent || '';
            const parts = text.split('/');
            if (parts.length >= 1) {
                return numberFromText(parts[0]);
            }

            return null;
        },
        canAttackNow() {
            try {
                const cookieStr = document.cookie;
                const match = cookieStr.match(/last_attack=(\d+)/);
                if (!match) return { ok: true, waitMs: 0 };

                const lastAttack = parseInt(match[1], 10);
                const now = Date.now();
                const elapsed = now - lastAttack;
                const cooldown = 1000;

                if (elapsed < cooldown) {
                    return { ok: false, waitMs: cooldown - elapsed };
                }

                return { ok: true, waitMs: 0 };
            } catch (error) {
                return { ok: true, waitMs: 0 };
            }
        },
        setLastAttackTime() {
            const now = Date.now();
            document.cookie = `last_attack=${now}; path=/; max-age=86400`;
            return now;
        },
        async runAutoBoss(context) {
            const { logger, dom } = context;
            const cfg = context.config.get();

            const damageTarget = cfg.autoBoss?.damageTarget || 1000000000;
            const delayBase = cfg.autoBoss?.delayBaseMs || 1000;
            const variation = cfg.autoBoss?.delayVariation || 0.3;
            const randomize = cfg.autoBoss?.randomizeDelays ?? true;

            logger.info(`ðŸ¤– AutoBoss iniciado! Meta de dano: ${formatNumber(damageTarget)}`);

            // Check if we need to join the battle first
            const joinButton = dom.query('#join-battle, button.btn-join, button.join-battle');
            if (joinButton && !joinButton.disabled) {
                logger.info('ðŸšª AutoBoss: Entrando na batalha...');
                joinButton.click();
                await sleep(2000);
                // After joining, the page will reload, and the module will restart
                return;
            }

            while (true) {
                const currentCfg = context.config.get();
                if (!currentCfg.core.enabled || !currentCfg.autoBoss?.enabled) {
                    logger.info('â¹ï¸ AutoBoss: Desativado via configuraÃ§Ã£o.');
                    break;
                }

                // Check if monster is dead
                const monsterHp = this.getMonsterHp(dom);
                if (monsterHp !== null && monsterHp <= 0) {
                    logger.info('ðŸ’€ AutoBoss: Monstro derrotado!');
                    logger.info(`ðŸ“Š EstatÃ­sticas: ${this.state.attackCount} ataques, ${this.state.potionsUsed} poÃ§Ãµes usadas`);
                    break;
                }

                // Check if damage target reached
                const currentDamage = this.getCurrentDamage(dom);
                if (currentDamage >= damageTarget) {
                    logger.info(`âœ… AutoBoss: Meta de dano atingida! ${formatNumber(currentDamage)} / ${formatNumber(damageTarget)}`);
                    logger.info(`ðŸ“Š EstatÃ­sticas: ${this.state.attackCount} ataques, ${this.state.potionsUsed} poÃ§Ãµes usadas`);
                    break;
                }

                // Get current stamina
                const currentStamina = context.stamina.getCurrent();
                logger.debug(`âš¡ AutoBoss: Stamina atual: ${currentStamina}`);

                // Get all available attack buttons
                const attackButtons = this.getAllAttackButtons(dom);

                if (attackButtons.length === 0) {
                    logger.warn('âš ï¸ AutoBoss: Nenhum botÃ£o de ataque disponÃ­vel.');
                    await sleep(1000);
                    continue;
                }

                // Select best attack based on current stamina
                const bestButton = this.selectBestAttackButton(context, attackButtons, currentStamina);

                if (!bestButton) {
                    // No attack available with current stamina - need to use potion
                    logger.warn(`âš ï¸ AutoBoss: Stamina insuficiente (${currentStamina}). Tentando usar Full Stamina Potion...`);

                    // IMPORTANT: Stop trying to attack before using potion
                    await sleep(500); // Give time for any pending attacks to complete

                    const potionUsed = await context.inventory.useFullStaminaPotion();

                    if (!potionUsed) {
                        logger.error('âŒ AutoBoss: NÃ£o foi possÃ­vel usar poÃ§Ã£o. Encerrando.');
                        logger.info(`ðŸ“Š Dano total: ${formatNumber(currentDamage)} / ${formatNumber(damageTarget)}`);
                        logger.info(`ðŸ“Š EstatÃ­sticas: ${this.state.attackCount} ataques, ${this.state.potionsUsed} poÃ§Ãµes usadas`);
                        break;
                    }

                    // After using potion, page should reload and module will restart
                    // If we're still here, something went wrong
                    logger.warn('âš ï¸ AutoBoss: Esperando reload apÃ³s usar poÃ§Ã£o...');
                    await sleep(3000);

                    // Try to continue if page didn't reload
                    continue;
                }

                // Double-check stamina before attacking (to prevent HTTP 400 errors)
                const skillCost = this.getSkillStaminaCost(bestButton);
                const reCheckStamina = context.stamina.getCurrent();

                if (reCheckStamina < skillCost) {
                    logger.warn(`âš ï¸ AutoBoss: Stamina mudou! Agora: ${reCheckStamina}, necessÃ¡rio: ${skillCost}. Pulando ataque.`);
                    await sleep(500);
                    continue; // Go back to top of loop to try use potion
                }

                // Check cooldown
                const cooldownCheck = this.canAttackNow();
                if (!cooldownCheck.ok) {
                    const waitSecs = Math.ceil(cooldownCheck.waitMs / 1000);
                    logger.debug(`â³ AutoBoss: Aguardando cooldown... ${waitSecs}s`);
                    await sleep(cooldownCheck.waitMs);
                }

                // Final check: is button still enabled?
                if (bestButton.disabled || bestButton.classList.contains('is-loading')) {
                    logger.debug('âš ï¸ AutoBoss: BotÃ£o ficou desabilitado. Aguardando...');
                    await sleep(500);
                    continue;
                }

                // Attack!
                bestButton.click();
                this.setLastAttackTime();
                this.state.attackCount++;

                const skillName = bestButton.dataset?.skillName || bestButton.getAttribute('data-skill-name') || 'Ataque';
                logger.debug(`âš”ï¸ AutoBoss: ${skillName} executado! (Total: ${this.state.attackCount} ataques, Stamina restante: ~${reCheckStamina - skillCost})`);

                // Wait before next attack
                await sleepRandom(delayBase, variation, randomize);
            }

            logger.info('ðŸ AutoBoss: SessÃ£o finalizada.');
        },
        cleanup() {
            if (this.state) {
                this.state.running = false;

                // Restore original window.confirm if we overrode it
                if (window._autoBossConfirmOverridden && this.state.originalConfirm) {
                    window.confirm = this.state.originalConfirm;
                    window._autoBossConfirmOverridden = false;
                    console.log('[AutoDS] window.confirm() restaurado');
                }
            }
        }
    };

    // ==================== DAMAGE CALCULATOR MODULE ====================
    // UI widget for damage calculation and build optimization
    // Active on: stats.php, pets.php, inventory.php
    
    const damageCalculatorModule = {
        id: 'damageCalculator',
        match: ({ location }) => /\/(stats|pets|inventory)\.php/i.test(location.pathname),
        
        init(context) {
            context.logger.debug('Damage Calculator module initialized');
            this.state = {
                widget: null,
                currentTab: 'stats',
                monsterDefense: 50,
                skillId: -2,
                lastUpdate: null,
                isVisible: false
            };
        },
        
        activate(context) {
            if (!this.state) this.init(context);
            
            const cfg = context.config.get();
            if (!cfg.core.enabled) return;
            
            context.logger.info('ðŸ§® Damage Calculator widget ready (inicialmente oculto)...');
            
            // Create widget but keep it hidden initially
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    this.createWidget(context);
                    this.hide(context); // Hide on creation
                }, { once: true });
            } else {
                this.createWidget(context);
                this.hide(context); // Hide on creation
            }
        },
        
        show(context) {
            if (!this.state.widget) {
                // If widget doesn't exist, create it
                this.createWidget(context);
            }
            if (this.state.widget) {
                this.state.widget.style.display = 'block';
                this.state.isVisible = true;
                context.logger.info('ðŸ§® Damage Calculator mostrado');
            }
        },
        
        hide(context) {
            if (this.state.widget) {
                this.state.widget.style.display = 'none';
                this.state.isVisible = false;
                context.logger.info('ðŸ§® Damage Calculator ocultado');
            }
        },
        
        createWidget(context) {
            const { logger, dataExtractor, damageCalculator } = context;
            
            // Check if widget already exists
            if (document.getElementById('autods-damage-calculator')) {
                logger.debug('Damage Calculator widget already exists');
                return;
            }
            
            // Create floating widget container
            const widget = document.createElement('div');
            widget.id = 'autods-damage-calculator';
            widget.style.cssText = `
                position: fixed;
                top: 120px;
                left: 20px;
                width: 360px;
                background: linear-gradient(135deg, rgba(20, 30, 50, 0.95), rgba(30, 40, 60, 0.95));
                border: 2px solid rgba(70, 130, 220, 0.6);
                border-radius: 12px;
                padding: 0;
                z-index: 2147483645;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
                backdrop-filter: blur(10px);
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                color: #e0e0e0;
                overflow: hidden;
                transition: all 0.3s ease;
                display: none;
            `;
            
            // Save widget reference
            this.state.widget = widget;
            
            // Create widget header
            const header = document.createElement('div');
            header.style.cssText = `
                background: linear-gradient(135deg, rgba(70, 130, 220, 0.3), rgba(90, 150, 240, 0.2));
                padding: 12px 16px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 1px solid rgba(70, 130, 220, 0.4);
                cursor: move;
            `;
            header.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 18px;">ðŸ§®</span>
                    <span style="font-weight: 600; font-size: 14px;">Damage Calculator</span>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button id="autods-calc-refresh" style="
                        background: rgba(70, 180, 70, 0.3);
                        border: 1px solid rgba(70, 180, 70, 0.5);
                        color: #90ee90;
                        padding: 4px 10px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 11px;
                        transition: all 0.2s;
                    " title="Refresh data">ðŸ”„ Refresh</button>
                    <button id="autods-calc-minimize" style="
                        background: rgba(70, 130, 220, 0.3);
                        border: 1px solid rgba(70, 130, 220, 0.5);
                        color: #b8c5d6;
                        padding: 4px 10px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 11px;
                        transition: all 0.2s;
                    ">âˆ’</button>
                </div>
            `;
            
            // Create tabs
            const tabs = document.createElement('div');
            tabs.style.cssText = `
                display: flex;
                background: rgba(15, 20, 35, 0.6);
                border-bottom: 1px solid rgba(70, 130, 220, 0.3);
            `;
            
            const tabItems = [
                { id: 'stats', label: 'ðŸ“Š Stats', title: 'Player Stats' },
                { id: 'pvm', label: 'âš”ï¸ PvM', title: 'PvM Damage' },
                { id: 'pvp', label: 'ðŸ›¡ï¸ PvP', title: 'PvP Power' },
                { id: 'builds', label: 'ðŸ† Builds', title: 'Best Pet Builds' }
            ];
            
            tabItems.forEach(tab => {
                const btn = document.createElement('button');
                btn.id = `autods-calc-tab-${tab.id}`;
                btn.className = 'autods-calc-tab';
                btn.textContent = tab.label;
                btn.title = tab.title;
                btn.style.cssText = `
                    flex: 1;
                    padding: 10px;
                    background: transparent;
                    border: none;
                    color: #b8c5d6;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: 500;
                    transition: all 0.2s;
                    border-bottom: 2px solid transparent;
                `;
                
                btn.addEventListener('click', () => {
                    this.switchTab(context, tab.id);
                });
                
                tabs.appendChild(btn);
            });
            
            // Create content area
            const content = document.createElement('div');
            content.id = 'autods-calc-content';
            content.style.cssText = `
                padding: 16px;
                max-height: 500px;
                overflow-y: auto;
                font-size: 13px;
            `;
            
            // Create loading state
            content.innerHTML = `
                <div style="text-align: center; padding: 40px 20px; color: #b8c5d6;">
                    <div style="font-size: 32px; margin-bottom: 12px;">â³</div>
                    <div>Loading player data...</div>
                </div>
            `;
            
            // Assemble widget
            widget.appendChild(header);
            widget.appendChild(tabs);
            widget.appendChild(content);
            document.body.appendChild(widget);
            
            this.state.widget = widget;
            
            // Make draggable
            this.makeDraggable(header, widget);
            
            // Setup event listeners
            this.setupEventListeners(context);
            
            // Load initial data
            this.loadData(context);
            
            logger.info('âœ… Damage Calculator widget created');
        },
        
        setupEventListeners(context) {
            // Refresh button
            const refreshBtn = document.getElementById('autods-calc-refresh');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', async () => {
                    refreshBtn.textContent = 'â³';
                    refreshBtn.disabled = true;
                    await context.dataExtractor.forceRefresh();
                    await this.loadData(context);
                    refreshBtn.textContent = 'ðŸ”„ Refresh';
                    refreshBtn.disabled = false;
                });
            }
            
            // Minimize button
            const minimizeBtn = document.getElementById('autods-calc-minimize');
            const content = document.getElementById('autods-calc-content');
            if (minimizeBtn && content) {
                minimizeBtn.addEventListener('click', () => {
                    if (content.style.display === 'none') {
                        content.style.display = 'block';
                        minimizeBtn.textContent = 'âˆ’';
                    } else {
                        content.style.display = 'none';
                        minimizeBtn.textContent = '+';
                    }
                });
            }
        },
        
        async loadData(context) {
            const { logger, dataExtractor, damageCalculator } = context;
            
            try {
                logger.debug('Loading player data for calculator...');
                
                // Extract all data
                const data = await dataExtractor.extractAll();
                this.state.playerData = data;
                this.state.lastUpdate = new Date();
                
                // Calculate damage/power
                const calc = await damageCalculator.calculateWithCurrentData(
                    dataExtractor,
                    this.state.monsterDefense,
                    this.state.skillId
                );
                this.state.calculations = calc;
                
                // Update UI
                this.switchTab(context, this.state.currentTab);
                
            } catch (error) {
                logger.error('Failed to load calculator data', { error });
                const content = document.getElementById('autods-calc-content');
                if (content) {
                    content.innerHTML = `
                        <div style="text-align: center; padding: 40px 20px; color: #ff6b6b;">
                            <div style="font-size: 32px; margin-bottom: 12px;">âŒ</div>
                            <div>Failed to load data</div>
                            <div style="font-size: 11px; margin-top: 8px; opacity: 0.7;">${error.message}</div>
                        </div>
                    `;
                }
            }
        },
        
        switchTab(context, tabId) {
            this.state.currentTab = tabId;
            
            // Update tab buttons
            document.querySelectorAll('.autods-calc-tab').forEach(btn => {
                const isActive = btn.id === `autods-calc-tab-${tabId}`;
                btn.style.color = isActive ? '#fff' : '#b8c5d6';
                btn.style.background = isActive ? 'rgba(70, 130, 220, 0.3)' : 'transparent';
                btn.style.borderBottomColor = isActive ? 'rgba(70, 130, 220, 0.8)' : 'transparent';
                btn.style.fontWeight = isActive ? '600' : '500';
            });
            
            // Update content
            const content = document.getElementById('autods-calc-content');
            if (!content) return;
            
            switch (tabId) {
                case 'stats':
                    content.innerHTML = this.renderStatsTab(context);
                    break;
                case 'pvm':
                    content.innerHTML = this.renderPvMTab(context);
                    this.setupPvMListeners(context);
                    break;
                case 'pvp':
                    content.innerHTML = this.renderPvPTab(context);
                    break;
                case 'builds':
                    content.innerHTML = this.renderBuildsTab(context);
                    break;
            }
        },
        
        renderStatsTab(context) {
            if (!this.state.playerData) {
                return '<div style="text-align: center; padding: 20px; color: #b8c5d6;">No data available</div>';
            }
            
            const { stats, pets, equipment } = this.state.playerData;
            const lastUpdate = this.state.lastUpdate ? this.state.lastUpdate.toLocaleTimeString() : 'Never';
            
            // Analyze pet impact
            const analysis = context.dataExtractor.analyzePetImpact(pets.equipped_attack_team || []);
            
            return `
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div style="text-align: center; font-size: 11px; color: #888; margin-bottom: 8px;">
                        Last updated: ${lastUpdate}
                    </div>
                    
                    <div style="background: rgba(20, 30, 50, 0.5); padding: 12px; border-radius: 8px; border: 1px solid rgba(70, 130, 220, 0.3);">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #90caf9;">ðŸ“Š Base Stats</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
                            <div>Level:</div><div style="text-align: right; font-weight: 600;">${stats.level}</div>
                            <div>Attack:</div><div style="text-align: right; font-weight: 600; color: #ff6b6b;">${stats.base_attack}</div>
                            <div>Defense:</div><div style="text-align: right; font-weight: 600; color: #4dabf7;">${stats.base_defense}</div>
                            <div>Max Stamina:</div><div style="text-align: right; font-weight: 600; color: #69db7c;">${stats.max_stamina}</div>
                            <div>Current Stamina:</div><div style="text-align: right; font-weight: 600;">${stats.current_stamina}</div>
                            <div>Unspent Points:</div><div style="text-align: right; font-weight: 600; color: #ffd43b;">${stats.unspent_points}</div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(20, 30, 50, 0.5); padding: 12px; border-radius: 8px; border: 1px solid rgba(70, 130, 220, 0.3);">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #a78bfa;">ðŸ¾ Pets (Attack Team)</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px; margin-bottom: 12px;">
                            <div>Equipped:</div><div style="text-align: right; font-weight: 600;">${pets.equipped_attack_team.length}</div>
                            <div>Total Attack:</div><div style="text-align: right; font-weight: 600; color: #ff6b6b;">${pets.total_attack_pets_atk}</div>
                            <div>Total Defense:</div><div style="text-align: right; font-weight: 600; color: #4dabf7;">${pets.total_attack_pets_def}</div>
                            ${pets.pvm_damage_bonus_percent > 0 ? `
                                <div style="grid-column: 1 / -1; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);">
                                    <div style="color: #69db7c; font-weight: 600;">âš¡ PvM Bonus: +${pets.pvm_damage_bonus_percent.toFixed(1)}%</div>
                                </div>
                            ` : ''}
                        </div>
                        ${pets.equipped_attack_team.length > 0 ? `
                            <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; margin-top: 4px;">
                                <div style="font-size: 11px; color: #888; margin-bottom: 6px;">Individual Pets:</div>
                                ${pets.equipped_attack_team.map(pet => `
                                    <div style="background: rgba(15, 20, 35, 0.5); padding: 6px 8px; border-radius: 4px; margin-bottom: 4px; font-size: 11px;">
                                        <div style="font-weight: 600; color: #e0e0e0; margin-bottom: 2px;">${pet.name}</div>
                                        <div style="color: #b8c5d6;">
                                            <span style="color: #ff6b6b;">ðŸ”ª ${pet.attack}</span> Â· 
                                            <span style="color: #4dabf7;">ðŸ›¡ï¸ ${pet.defense}</span> Â· 
                                            <span style="color: #a78bfa;">ðŸ§ª Lv.${pet.level}</span>
                                        </div>
                                        ${pet.effect ? `
                                            <div style="color: ${pet.pvm_damage_bonus > 0 ? '#69db7c' : '#888'}; font-size: 10px; margin-top: 2px;">
                                                âš¡ ${pet.effect}
                                            </div>
                                        ` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                    
                    <div style="background: rgba(20, 30, 50, 0.5); padding: 12px; border-radius: 8px; border: 1px solid rgba(70, 130, 220, 0.3);">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #ffd43b;">âš”ï¸ Equipment (Attack Set)</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
                            <div>Total Attack:</div><div style="text-align: right; font-weight: 600; color: #ff6b6b;">${equipment.total_equipped_atk}</div>
                            <div>Total Defense:</div><div style="text-align: right; font-weight: 600; color: #4dabf7;">${equipment.total_equipped_def}</div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(20, 30, 50, 0.5); padding: 12px; border-radius: 8px; border: 1px solid rgba(70, 130, 220, 0.3);">
                        <div style="font-weight: 600; margin-bottom: 12px; color: #f06292;">ðŸ“Š Pet Impact Analysis</div>
                        
                        ${analysis.pvm.total_score > 0 ? `
                            <div style="margin-bottom: 12px; padding: 10px; background: rgba(105, 219, 124, 0.1); border: 1px solid rgba(105, 219, 124, 0.3); border-radius: 6px;">
                                <div style="font-weight: 600; color: #69db7c; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>âš”ï¸ PvM</span>
                                    <span style="font-size: 14px;">${analysis.pvm.total_score.toFixed(1)} pts</span>
                                </div>
                                ${analysis.pvm.contributors.map(c => `
                                    <div style="font-size: 10px; color: #b8c5d6; margin-top: 4px; padding: 4px 6px; background: rgba(15, 20, 35, 0.5); border-radius: 3px;">
                                        <div style="font-weight: 600; color: #e0e0e0;">${c.pet} (${c.score.toFixed(1)} pts)</div>
                                        <div style="color: #888; margin-top: 2px;">${c.breakdown}</div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        ${analysis.pvp_attacker.total_score > 0 ? `
                            <div style="margin-bottom: 12px; padding: 10px; background: rgba(255, 107, 107, 0.1); border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 6px;">
                                <div style="font-weight: 600; color: #ff6b6b; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>âš¡ PvP Attacker</span>
                                    <span style="font-size: 14px;">${analysis.pvp_attacker.total_score.toFixed(1)} pts</span>
                                </div>
                                ${analysis.pvp_attacker.contributors.map(c => `
                                    <div style="font-size: 10px; color: #b8c5d6; margin-top: 4px; padding: 4px 6px; background: rgba(15, 20, 35, 0.5); border-radius: 3px;">
                                        <div style="font-weight: 600; color: #e0e0e0;">${c.pet} (${c.score.toFixed(1)} pts)</div>
                                        <div style="color: #888; margin-top: 2px;">${c.breakdown}</div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        ${analysis.pvp_defender.total_score > 0 ? `
                            <div style="margin-bottom: 12px; padding: 10px; background: rgba(77, 171, 247, 0.1); border: 1px solid rgba(77, 171, 247, 0.3); border-radius: 6px;">
                                <div style="font-weight: 600; color: #4dabf7; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>ðŸ›¡ï¸ PvP Defender</span>
                                    <span style="font-size: 14px;">${analysis.pvp_defender.total_score.toFixed(1)} pts</span>
                                </div>
                                ${analysis.pvp_defender.contributors.map(c => `
                                    <div style="font-size: 10px; color: #b8c5d6; margin-top: 4px; padding: 4px 6px; background: rgba(15, 20, 35, 0.5); border-radius: 3px;">
                                        <div style="font-weight: 600; color: #e0e0e0;">${c.pet} (${c.score.toFixed(1)} pts)</div>
                                        <div style="color: #888; margin-top: 2px;">${c.breakdown}</div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        ${analysis.universal.total_score > 0 ? `
                            <div style="padding: 10px; background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.3); border-radius: 6px;">
                                <div style="font-weight: 600; color: #a78bfa; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>ðŸŒŸ Universal</span>
                                    <span style="font-size: 14px;">${analysis.universal.total_score.toFixed(1)} pts</span>
                                </div>
                                ${analysis.universal.contributors.map(c => `
                                    <div style="font-size: 10px; color: #b8c5d6; margin-top: 4px; padding: 4px 6px; background: rgba(15, 20, 35, 0.5); border-radius: 3px;">
                                        <div style="font-weight: 600; color: #e0e0e0;">${c.pet} (${c.score.toFixed(1)} pts)</div>
                                        <div style="color: #888; margin-top: 2px;">${c.breakdown}</div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        ${analysis.pvm.total_score === 0 && analysis.pvp_attacker.total_score === 0 && 
                          analysis.pvp_defender.total_score === 0 && analysis.universal.total_score === 0 ? `
                            <div style="text-align: center; padding: 16px; color: #888; font-size: 11px;">
                                No pets equipped or no effects detected
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        },
        
        renderPvMTab(context) {
            if (!this.state.calculations) {
                return '<div style="text-align: center; padding: 20px; color: #b8c5d6;">No calculations available</div>';
            }
            
            const { pvm } = this.state.calculations;
            const skills = [
                { id: 0, name: 'Slash', cost: 1 },
                { id: -1, name: 'Power Slash', cost: 10 },
                { id: -2, name: 'Heroic Slash', cost: 50 },
                { id: -3, name: 'Ultimate Slash', cost: 100 },
                { id: -4, name: 'Legendary Slash', cost: 200 }
            ];
            
            return `
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div style="background: rgba(20, 30, 50, 0.5); padding: 12px; border-radius: 8px; border: 1px solid rgba(70, 130, 220, 0.3);">
                        <div style="font-weight: 600; margin-bottom: 12px; color: #90caf9;">âš™ï¸ Settings</div>
                        
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #b8c5d6;">Monster Defense</label>
                            <input type="number" id="autods-calc-monster-def" value="${this.state.monsterDefense}" 
                                min="0" max="1000" step="1"
                                style="width: 100%; padding: 8px; background: rgba(15, 20, 35, 0.8); color: #e0e0e0; 
                                border: 1px solid rgba(70, 130, 220, 0.4); border-radius: 6px; font-size: 13px;">
                        </div>
                        
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #b8c5d6;">Skill</label>
                            <select id="autods-calc-skill" 
                                style="width: 100%; padding: 8px; background: rgba(15, 20, 35, 0.8); color: #e0e0e0; 
                                border: 1px solid rgba(70, 130, 220, 0.4); border-radius: 6px; font-size: 13px; cursor: pointer;">
                                ${skills.map(s => `
                                    <option value="${s.id}" ${s.id === this.state.skillId ? 'selected' : ''}>
                                        ${s.name} (${s.cost} stamina)
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                        
                        <button id="autods-calc-recalculate" style="
                            width: 100%;
                            margin-top: 12px;
                            padding: 10px;
                            background: linear-gradient(135deg, rgba(70, 130, 220, 0.4), rgba(90, 150, 240, 0.3));
                            border: 1px solid rgba(70, 130, 220, 0.6);
                            color: #fff;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 13px;
                            font-weight: 600;
                            transition: all 0.2s;
                        ">ðŸ”„ Recalculate</button>
                    </div>
                    
                    <div style="background: rgba(70, 180, 70, 0.1); padding: 16px; border-radius: 8px; border: 2px solid rgba(70, 180, 70, 0.4);">
                        <div style="font-weight: 600; margin-bottom: 12px; color: #69db7c; text-align: center; font-size: 14px;">
                            ðŸ’¥ Expected Damage
                        </div>
                        <div style="text-align: center; font-size: 28px; font-weight: 700; color: #fff; margin-bottom: 16px;">
                            ${context.numbers.format(pvm.damage)}
                        </div>
                        <div style="font-size: 11px; color: #b8c5d6; border-top: 1px solid rgba(70, 180, 70, 0.3); padding-top: 12px;">
                            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 6px;">
                                <div>Base:</div><div style="text-align: right;">${context.numbers.format(pvm.breakdown.base)}</div>
                                <div>Equipment:</div><div style="text-align: right;">${context.numbers.format(pvm.breakdown.equip_contribution)}</div>
                                <div>Pets:</div><div style="text-align: right;">${context.numbers.format(pvm.breakdown.pet_contribution)}</div>
                                <div>User Attack:</div><div style="text-align: right;">${context.numbers.format(pvm.breakdown.user_attack_contribution)}</div>
                                <div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 4px; font-weight: 600;">Subtotal:</div>
                                <div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 4px; text-align: right; font-weight: 600;">${context.numbers.format(pvm.breakdown.subtotal)}</div>
                                <div style="color: #ffd43b;">Ã— Stamina:</div><div style="text-align: right; color: #ffd43b;">Ã—${pvm.breakdown.stamina_multiplier}</div>
                                ${pvm.breakdown.total_bonus_percent > 0 ? `
                                    <div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 4px; color: #69db7c;">Before Bonus:</div>
                                    <div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 4px; text-align: right; color: #69db7c;">${context.numbers.format(pvm.breakdown.damage_before_bonus)}</div>
                                    ${pvm.breakdown.pet_bonus_percent > 0 ? `
                                        <div style="color: #a78bfa;">Pet Bonus:</div><div style="text-align: right; color: #a78bfa;">+${pvm.breakdown.pet_bonus_percent.toFixed(1)}%</div>
                                    ` : ''}
                                    ${pvm.breakdown.equip_bonus_percent > 0 ? `
                                        <div style="color: #ffd43b;">Equip Bonus:</div><div style="text-align: right; color: #ffd43b;">+${pvm.breakdown.equip_bonus_percent.toFixed(1)}%</div>
                                    ` : ''}
                                    <div style="color: #69db7c; font-weight: 600;">Total Bonus:</div>
                                    <div style="text-align: right; color: #69db7c; font-weight: 600;">Ã—${pvm.breakdown.bonus_multiplier}</div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        },
        
        renderPvPTab(context) {
            if (!this.state.calculations) {
                return '<div style="text-align: center; padding: 20px; color: #b8c5d6;">No calculations available</div>';
            }
            
            const { pvp_attacker, pvp_defender } = this.state.calculations;
            
            return `
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div style="background: rgba(220, 70, 70, 0.1); padding: 16px; border-radius: 8px; border: 2px solid rgba(220, 70, 70, 0.4);">
                        <div style="font-weight: 600; margin-bottom: 12px; color: #ff6b6b; text-align: center; font-size: 14px;">
                            âš”ï¸ Attacker Power
                        </div>
                        <div style="text-align: center; font-size: 28px; font-weight: 700; color: #fff; margin-bottom: 16px;">
                            ${pvp_attacker.power.toFixed(1)}
                        </div>
                        <div style="font-size: 11px; color: #b8c5d6; border-top: 1px solid rgba(220, 70, 70, 0.3); padding-top: 12px;">
                            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 6px;">
                                <div>Base Attack:</div><div style="text-align: right;">${pvp_attacker.breakdown.base_attack}</div>
                                <div>Base Defense (Ã—0.7):</div><div style="text-align: right;">${pvp_attacker.breakdown.base_defense_contribution.toFixed(1)}</div>
                                <div>Pet Attack (Ã—0.3):</div><div style="text-align: right;">${pvp_attacker.breakdown.pet_attack_contribution.toFixed(1)}</div>
                                <div>Equipment ATK (Ã—0.4):</div><div style="text-align: right;">${pvp_attacker.breakdown.equip_attack_contribution.toFixed(1)}</div>
                                <div>Pet Defense (Ã—0.3):</div><div style="text-align: right;">${pvp_attacker.breakdown.pet_defense_contribution.toFixed(1)}</div>
                                <div>Equipment DEF (Ã—0.2):</div><div style="text-align: right;">${pvp_attacker.breakdown.equip_defense_contribution.toFixed(1)}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(70, 130, 220, 0.1); padding: 16px; border-radius: 8px; border: 2px solid rgba(70, 130, 220, 0.4);">
                        <div style="font-weight: 600; margin-bottom: 12px; color: #4dabf7; text-align: center; font-size: 14px;">
                            ðŸ›¡ï¸ Defender Power
                        </div>
                        <div style="text-align: center; font-size: 28px; font-weight: 700; color: #fff; margin-bottom: 16px;">
                            ${pvp_defender.power.toFixed(1)}
                        </div>
                        <div style="font-size: 11px; color: #b8c5d6; border-top: 1px solid rgba(70, 130, 220, 0.3); padding-top: 12px;">
                            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 6px;">
                                <div>Base Defense:</div><div style="text-align: right;">${pvp_defender.breakdown.base_defense}</div>
                                <div>Base Attack (Ã—0.7):</div><div style="text-align: right;">${pvp_defender.breakdown.base_attack_contribution.toFixed(1)}</div>
                                <div>Pet Attack (Ã—0.3):</div><div style="text-align: right;">${pvp_defender.breakdown.pet_attack_contribution.toFixed(1)}</div>
                                <div>Equipment ATK (Ã—0.2):</div><div style="text-align: right;">${pvp_defender.breakdown.equip_attack_contribution.toFixed(1)}</div>
                                <div>Pet Defense (Ã—0.3):</div><div style="text-align: right;">${pvp_defender.breakdown.pet_defense_contribution.toFixed(1)}</div>
                                <div>Equipment DEF (Ã—0.4):</div><div style="text-align: right;">${pvp_defender.breakdown.equip_defense_contribution.toFixed(1)}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(255, 215, 0, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); font-size: 11px; color: #b8c5d6;">
                        <div style="margin-bottom: 6px; color: #ffd43b; font-weight: 600;">ðŸ’¡ PvP Formula Info:</div>
                        <div>Attacker: ATK + 0.7Ã—DEF + 0.3Ã—PetATK + 0.4Ã—EqATK + 0.3Ã—PetDEF + 0.2Ã—EqDEF</div>
                        <div>Defender: DEF + 0.7Ã—ATK + 0.3Ã—PetATK + 0.2Ã—EqATK + 0.3Ã—PetDEF + 0.4Ã—EqDEF</div>
                    </div>
                </div>
            `;
        },
        
        renderBuildsTab(context) {
            if (!this.state.playerData) {
                return '<div style="text-align: center; padding: 20px; color: #b8c5d6;">No data available. Click Refresh to analyze builds.</div>';
            }
            
            const { allAvailablePets } = this.state.playerData;
            
            if (!allAvailablePets || allAvailablePets.length < 3) {
                return '<div style="text-align: center; padding: 20px; color: #b8c5d6;">Need at least 3 pets to analyze builds</div>';
            }
            
            // Analyze optimal builds
            const builds = context.dataExtractor.analyzeOptimalBuilds(this.state.playerData, this.state.monsterDefense);
            
            return `
                <div style="display: flex; flex-direction: column; gap: 12px; max-height: 480px; overflow-y: auto;">
                    <div style="text-align: center; font-size: 11px; color: #888; padding: 8px; background: rgba(255,215,0,0.05); border-radius: 6px; margin-bottom: 4px;">
                        Analyzed ${builds.pvm.total_combinations || 0} combinations from ${allAvailablePets.length} pets
                    </div>
                    
                    ${builds.pvm.builds.length > 0 ? `
                        <div style="background: rgba(105, 219, 124, 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(105, 219, 124, 0.3);">
                            <div style="font-weight: 600; color: #69db7c; margin-bottom: 10px; font-size: 13px;">ðŸ† Best PvM Builds</div>
                            ${builds.pvm.builds.map((build, idx) => `
                                <div style="margin-bottom: 10px; padding: 10px; background: rgba(15, 20, 35, 0.6); border-radius: 6px; border-left: 3px solid ${idx === 0 ? '#ffd43b' : 'rgba(105, 219, 124, 0.3)'};">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                        <span style="font-weight: 600; color: ${idx === 0 ? '#ffd43b' : '#e0e0e0'}; font-size: 11px;">
                                            ${idx === 0 ? 'ðŸ‘‘ #1' : `#${idx + 1}`}
                                        </span>
                                        <span style="font-size: 12px; font-weight: 600; color: #69db7c;">
                                            ${context.numbers.format(build.expectedDamage)} dmg
                                        </span>
                                    </div>
                                    <div style="font-size: 10px; color: #b8c5d6; margin-bottom: 4px;">
                                        ${build.pets.join(' Â· ')}
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; font-size: 9px; color: #888; margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <div>ATK: ${build.totalAtk}</div>
                                        <div>DEF: ${build.totalDef}</div>
                                        ${build.damageBonus > 0 ? `<div style="color: #69db7c;">+${build.damageBonus.toFixed(1)}% DMG</div>` : ''}
                                        ${build.critRate > 0 ? `<div style="color: #ffa94d;">+${build.critRate.toFixed(1)}% Crit</div>` : ''}
                                        ${build.armorPen > 0 ? `<div style="color: #ff6b6b;">+${build.armorPen.toFixed(1)}% Pen</div>` : ''}
                                        ${build.staminaSave > 0 ? `<div style="color: #90caf9;">+${build.staminaSave.toFixed(1)}% Save</div>` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${builds.pvp_attacker.builds.length > 0 ? `
                        <div style="background: rgba(255, 107, 107, 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 107, 107, 0.3);">
                            <div style="font-weight: 600; color: #ff6b6b; margin-bottom: 10px; font-size: 13px;">âš”ï¸ Best PvP Attacker Builds</div>
                            ${builds.pvp_attacker.builds.slice(0, 3).map((build, idx) => `
                                <div style="margin-bottom: 10px; padding: 10px; background: rgba(15, 20, 35, 0.6); border-radius: 6px; border-left: 3px solid ${idx === 0 ? '#ffd43b' : 'rgba(255, 107, 107, 0.3)'};">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                        <span style="font-weight: 600; color: ${idx === 0 ? '#ffd43b' : '#e0e0e0'}; font-size: 11px;">
                                            ${idx === 0 ? 'ðŸ‘‘ #1' : `#${idx + 1}`}
                                        </span>
                                        <span style="font-size: 12px; font-weight: 600; color: #ff6b6b;">
                                            ${build.score.toFixed(1)} pts
                                        </span>
                                    </div>
                                    <div style="font-size: 10px; color: #b8c5d6; margin-bottom: 4px;">
                                        ${build.pets.join(' Â· ')}
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; font-size: 9px; color: #888; margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <div>ATK: ${build.totalAtk}</div>
                                        <div>DEF: ${build.totalDef}</div>
                                        ${build.stealStat > 0 ? `<div style="color: #ff6b6b;">Steal ${build.stealStat.toFixed(1)}%</div>` : ''}
                                        ${build.teamConversion > 0 ? `<div style="color: #a78bfa;">Conv ${build.teamConversion.toFixed(1)}%</div>` : ''}
                                        ${build.atkDefSwap > 0 ? `<div style="color: #ffd43b;">Swap ${build.atkDefSwap.toFixed(1)}%</div>` : ''}
                                        ${build.critRate > 0 ? `<div style="color: #ffa94d;">Crit ${build.critRate.toFixed(1)}%</div>` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${builds.pvp_defender.builds.length > 0 ? `
                        <div style="background: rgba(77, 171, 247, 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(77, 171, 247, 0.3);">
                            <div style="font-weight: 600; color: #4dabf7; margin-bottom: 10px; font-size: 13px;">ðŸ›¡ï¸ Best PvP Defender Builds</div>
                            ${builds.pvp_defender.builds.slice(0, 3).map((build, idx) => `
                                <div style="margin-bottom: 10px; padding: 10px; background: rgba(15, 20, 35, 0.6); border-radius: 6px; border-left: 3px solid ${idx === 0 ? '#ffd43b' : 'rgba(77, 171, 247, 0.3)'};">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                        <span style="font-weight: 600; color: ${idx === 0 ? '#ffd43b' : '#e0e0e0'}; font-size: 11px;">
                                            ${idx === 0 ? 'ðŸ‘‘ #1' : `#${idx + 1}`}
                                        </span>
                                        <span style="font-size: 12px; font-weight: 600; color: #4dabf7;">
                                            ${build.score.toFixed(1)} pts
                                        </span>
                                    </div>
                                    <div style="font-size: 10px; color: #b8c5d6; margin-bottom: 4px;">
                                        ${build.pets.join(' Â· ')}
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; font-size: 9px; color: #888; margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <div>ATK: ${build.totalAtk}</div>
                                        <div>DEF: ${build.totalDef}</div>
                                        ${build.stealStat > 0 ? `<div style="color: #4dabf7;">Steal ${build.stealStat.toFixed(1)}%</div>` : ''}
                                        ${build.teamConversion > 0 ? `<div style="color: #a78bfa;">Conv ${build.teamConversion.toFixed(1)}%</div>` : ''}
                                        ${build.defBoost > 0 ? `<div style="color: #69db7c;">+${build.defBoost.toFixed(1)}% DEF</div>` : ''}
                                        ${build.atkDefSwap > 0 ? `<div style="color: #ffd43b;">Swap ${build.atkDefSwap.toFixed(1)}%</div>` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        },
        
        setupPvMListeners(context) {
            const recalcBtn = document.getElementById('autods-calc-recalculate');
            const monsterDefInput = document.getElementById('autods-calc-monster-def');
            const skillSelect = document.getElementById('autods-calc-skill');
            
            if (!recalcBtn || !monsterDefInput || !skillSelect) return;
            
            recalcBtn.addEventListener('click', async () => {
                this.state.monsterDefense = parseInt(monsterDefInput.value) || 50;
                this.state.skillId = parseInt(skillSelect.value) || -2;
                
                recalcBtn.textContent = 'â³ Calculating...';
                recalcBtn.disabled = true;
                
                const calc = await context.damageCalculator.calculateWithCurrentData(
                    context.dataExtractor,
                    this.state.monsterDefense,
                    this.state.skillId
                );
                this.state.calculations = calc;
                
                this.switchTab(context, 'pvm');
                
                recalcBtn.textContent = 'ðŸ”„ Recalculate';
                recalcBtn.disabled = false;
            });
        },
        
        makeDraggable(header, widget) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                const rect = widget.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                header.style.cursor = 'grabbing';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                widget.style.left = (initialX + dx) + 'px';
                widget.style.top = (initialY + dy) + 'px';
                widget.style.right = 'auto';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
                header.style.cursor = 'move';
            });
        },
        
        cleanup() {
            if (this.state?.widget) {
                this.state.widget.remove();
            }
        }
    };

    function bootstrap() {
        const storage = createStorage({ namespace: STORAGE_NAMESPACE });
        const events = createEventBus();
        const config = createConfig(storage, events);
        const cfg = config.get();
        const logger = createLogger(cfg.core.logLevel || 'info', cfg.ui?.logFloater || {});
        const dom = createDomService(logger);
        const scheduler = createScheduler(logger);
        const ui = createUiRoot(cfg);
        const moduleRegistry = createModuleRegistry(logger);

        // Create temporary context for service initialization
        const tempContext = { logger, config };
        
        // Initialize Phase 1 services (Completed 11/12/2025)
        const stamina = createStaminaReader();
        const inventory = createInventoryService(tempContext);
        
        // Initialize Phase 2 services (Completed 11/12/2025)
        const http = createHttpService(tempContext);
        const notifications = createNotificationService(tempContext);
        
        // Initialize combat service AFTER http (needs http.attackWaveMonsterDirect etc.)
        const combat = createCombatService({ ...tempContext, http });
        
        // NOTE: Phase 2 services are available but not yet fully integrated
        // Old functions like joinBattleDirectly() still use GM_xmlhttpRequest directly
        // Future Phase 3 will migrate all modules to use context.http and context.notifications
        // Example usage:
        //   const result = await context.http.joinBattle(monsterId, userId);
        //   context.notifications.success('Battle joined!');
        //   context.notifications.staminaLow(current, required);

        const context = {
            version: SCRIPT_VERSION,
            storage,
            config,
            logger,
            dom,
            scheduler,
            events,
            ui,
            location: window.location,
            document,
            window,
            moduleRegistry,
            // Phase 1 centralized services
            stamina,
            inventory,
            combat,
            // Phase 2 centralized services
            http,
            notifications,
            // Phase 3 utilities
            profiler: performanceProfiler
        };
        
        // Initialize Phase 3 Services (Battle stats, monster scanning, user session, number formatting)
        context.battleStats = createBattleStatsService(context);
        context.monsterScanner = createMonsterScannerService(context);
        context.userSession = createUserSessionService(context);
        context.numbers = createNumberFormattingService();
        
        // Initialize Unified Loot Service (Phase 4 - Unified loot management)
        context.loot = createLootService(context);
        
        // Initialize Damage Calculator services (Phase 1 - Data extraction & calculations)
        context.dataExtractor = createDataExtractorService(context);
        context.damageCalculator = createDamageCalculatorService(context);
        
        // Expose services globally for console testing
        // Use unsafeWindow to ensure it's accessible in browser console
        const globalWindow = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;
        globalWindow.autoDSServices = {
            dataExtractor: context.dataExtractor,
            damageCalculator: context.damageCalculator,
            context: context,  // Expose full context for debugging
            version: SCRIPT_VERSION
        };
        logger.info('âœ… Services exposed globally: window.autoDSServices (version ' + SCRIPT_VERSION + ')');

        moduleRegistry.register(uiShellModule);
        moduleRegistry.register(floatingHelpersModule);  // Floating helpers for potions and loot
        moduleRegistry.register(damageCalculatorModule);  // Damage calculator widget (stats/pets/inventory pages)
        moduleRegistry.register(attackUnlockerModule);  // Always active on battle pages
        // moduleRegistry.register(autoJoinBattleModule);  // DEPRECATED v0.1.29 - replaced by directJoinButtonsModule
        moduleRegistry.register(directJoinButtonsModule);  // "Join Now" / "Fight Now" buttons (always visible)
        moduleRegistry.register(dungeonLootHelperModule);  // Loot buttons on dungeon locations
        moduleRegistry.register(collectionsOrganizerModule);  // Organize collections page (claimed at bottom)
        moduleRegistry.register(imageBlockModule);
        moduleRegistry.register(ultraFastPvpModule);  // Ultra Fast PvP - fastest possible attacks via GM_xmlhttpRequest
        moduleRegistry.register(pvpModule);  // PvP normal mode (fallback if ultra fast disabled)
        moduleRegistry.register(waveUiModule);  // Wave UI enhancements (independent of automation)
        moduleRegistry.register(ultraFastAttackModule);  // Ultra Fast Attack - parallel batch operations
        moduleRegistry.register(ultraFastLootModule);  // Ultra Fast Loot - parallel loot collection
        moduleRegistry.register(ultraFastStaminaModule);  // Ultra Fast Stamina - parallel chapter reactions
        moduleRegistry.register(ultraFastDungeonModule);  // Ultra Fast Dungeon - smart damage dungeon farming
        moduleRegistry.register(specialBossFarmModule);  // Special Boss Farm - dedicated farm for General/King/Empress/Bastion
        moduleRegistry.register(waveModule);
        moduleRegistry.register(dungeonWaveModule);  // Dungeon location automation
        moduleRegistry.register(autoBossModule);  // AutoBoss - high-damage boss farming
        moduleRegistry.register(battleModule);
        // NOTE: farmingModule disabled in v0.8.0-alpha (farm section removed from config)

        moduleRegistry.initAll(context);
        context.modulesCount = 19;  // Updated count (removed farmingModule)
        
        // Auto-detect user ID from cookie and start monitoring (Phase 3 service)
        context.userSession.ensureUserId();
        context.userSession.startAutoDetect(10000); // Check every 10 seconds
        
        moduleRegistry.activateFor(context);

        // REMOVIDO: Quest Widget (fetch bloqueado pelo site)

        // Inicializar Smart Damage Calculation na pÃ¡gina de stats
        if (window.location.pathname.includes('stats.php')) {
            scheduler.addTimeout(() => {
                addSmartDamageDisplay();
            }, 500, 'Smart Damage Display Init');
        }

        // Inicializar Dungeon Pills nas pÃ¡ginas de wave
        if (window.location.pathname.includes('active_wave.php') || window.location.pathname.includes('wave.php')) {
            scheduler.addTimeout(() => {
                addDungeonPills();
            }, 800, 'Dungeon Pills Init');
        }

        // Inicializar Guild Dungeon Loot All Button
        if (window.location.pathname.includes('guild_dungeon_location.php')) {
            scheduler.addTimeout(() => {
                addGuildDungeonLootAllButton();
            }, 800, 'Guild Dungeon Loot All Init');
        }

        window.addEventListener('beforeunload', () => {
            scheduler.disposeAll();
        });
        
        // Listen for log floater config changes
        events.on('config:change', () => {
            const newCfg = config.get();
            const floaterEnabled = newCfg.ui?.logFloater?.enabled !== false;
            toggleLogFloaterVisibility(floaterEnabled);
        });

        // logger.info('AutoDS Unified Automator bootstrapped', { version: SCRIPT_VERSION });
        // logger.info('ðŸ’¡ User ID detection: getUserIdFromCookie() always checks "demon" cookie');
        events.emit('autods:ready', { version: SCRIPT_VERSION });
    }

    try {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
            bootstrap();
        }
    } catch (error) {
        console.error('[AutoDS] Fatal bootstrap error', error);
    }

})();

