// ==UserScript==
// @name         DemonicScans Unified Automator
// @namespace    https://github.com/wverri/autods
// @version      0.9.6-alpha
// @description  Consolidated automation suite for DemonicScans: wave battles, PvP, farming, UI enhancements, and image blocking.
// @author       Willian Verri
// @match        https://demonicscans.org/*
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_deleteValue
// @grant        GM_addStyle
// @grant        GM_xmlhttpRequest
// @grant        unsafeWindow
// @run-at       document-start
// @license MIT
// @downloadURL https://update.greasyfork.org/scripts/553682/DemonicScans%20Unified%20Automator.user.js
// @updateURL https://update.greasyfork.org/scripts/553682/DemonicScans%20Unified%20Automator.meta.js
// ==/UserScript==

var version = GM_info.script.version;

(function unifiedAutomator() {
    'use strict';

    const SCRIPT_VERSION = version;
    
    const STORAGE_NAMESPACE = 'autods.v1';
    const IS_TAMPERMONKEY = typeof GM_getValue === 'function' && typeof GM_setValue === 'function';
    const STORAGE_KEYS = Object.freeze({
        lastWaveUrl: 'session.lastWaveUrl'
    });
    const PANEL_WIDTH_PX = 200;
    const MIN_PANEL_WIDTH_PX = 300;
    const TOOLBAR_HEIGHT_FALLBACK = 56;
    const MAX_PERSISTENT_LOGS = 100;

    const DEFAULT_CONFIG = Object.freeze({
        core: {
            enabled: true,
            logLevel: 'info',
            shadowDom: true,
            unlockAttackButtons: true,  // Always unlock attack buttons (manual + auto)
            userId: null  // User ID for AJAX requests (auto-detected or manually set)
        },
        stamina: {
            minThreshold: 0,  // Stamina m√≠nima necess√°ria para entrar em batalha (0 = sem verifica√ß√£o)
            checkIntervalMs: 300000  // 5 minutos entre verifica√ß√µes quando aguardando regenera√ß√£o
        },
        wave: {
            enabled: false,
            parallelAttacks: 10,
            skillId: -2,
            minDelayBetweenAttacks: 30,
            damageTarget: 5000000,
            autoFSP: false,
            minStaminaForFSP: 50,
            lootDeadBeforeFSP: true,
            monsterFilter: {
                includeNames: [],
                excludeNames: [],
            }
        },
        dungeonWave: {
            priorityMode: 'lowest_hp',
            minMobHp: 4000000,
            monsterFilter: {
                maxHp: 0,
                minDamage: 0,
                includeNames: [],
                excludeNames: []
            },
            loot: {
                enabled: true,
                parallelOperations: 3
            },
            defaultDamageTarget: 3000000,
            magusDamageTarget: 1000000,
            showDamagePills: true,
            showExpPills: true,
            showZeroJoined: true,
            hpFilterOptions: ['20-50%', '50-80%', '80-100%', '100%'],
            lootAllEnabled: true
        },
        battle: {
            enabled: true,
            minDamageTarget: 100000,
            attackSkillId: 0,
            delayBaseMs: 1000,
            delayVariation: 0.3,
            randomizeDelays: true,
            smartDamage: {
                enabled: true,
                skills: {
                    slash: { skillId: 0, damageLimit: 0, name: 'Slash' },
                    powerSlash: { skillId: -1, damageLimit: 1000000, name: 'Power Slash' },
                    heroicSlash: { skillId: -2, damageLimit: 6000001, name: 'Heroic Slash' },
                    ultimateSlash: { skillId: -3, damageLimit: 10000001, name: 'Ultimate Slash' },
                    legendarySlash: { skillId: -4, damageLimit: 20000001, name: 'Legendary Slash' }
                }
            }
        },
        ultraFastBoss: {
            targetDamage: 1000000000,  // 1B default target
            skillId: -2,  // Heroic Slash (50 stamina)
            autoPotion: true,  // Auto-use Full Stamina Potion
            parallelAttacks: 10,  // Number of simultaneous attacks per batch
            minDelayBetweenAttacks: 30,  // ms between attack batches
            // Runtime state (not saved)
            running: false,
            currentDamage: 0,
            attackCount: 0,
            potionsUsed: 0
        },
        credentials: {
            email: '',
            password: ''
        },
        pvp: {
            enabled: true,
            autoMode: 'all',
            limitedBattles: 10,
            autoSurrender: false,
            autoSurrenderThreshold: 10,
            ultraFastMode: true,
            ultraFastConfig: {
                skillId: 0,  // 0 = Slash (1 token), -1 = Power Slash (5 tokens, 10x damage)
                minDelayBetweenAttacks: 50,  // ms between attacks (minimum possible)
                autoReturnToLobby: true,  // Automatically return to lobby after battle
                autoContinueBattles: true,  // Automatically start new battles
                maxConsecutiveBattles: 30,  // Max battles per session (0 = unlimited)
                useSmartRotation: false,  // Use smart skill rotation pattern
                smartRotationPattern: [
                    { skill: 18, count: 1 },
                    { skill: 9, count: 1 },
                    { skill: -1, count: 1 },
                    { skill: 0, count: 9 }
                ]
            }
        },
        ui: {
            activeTab: 'profiles',
            panel: {
                width: PANEL_WIDTH_PX,
                position: null,
                activeTab: 'overview'
            },
            logFloater: {
                enabled: true,
                position: 'bottom-right',
                minimized: false
            },
            panelStates: {
                stats: false,
                automation: false,
                status: false,
                configs: false
            },
            dropdownStates: {
                'wave-unified': false,
                'battle': false,
                'pvp': false,
                'ultra-fast': false,
                'others': false
            },
            toasts: {
                enabled: true,
                durationMs: 4500,
                position: 'top-right'
            }
        },
        floatingHelpers: {
            enabled: true,
            position: 'right',
            topOffset: '50%',
            hideNativePopup: true,  // Hide native Battle Consumables popup
            potions: {
                small: { enabled: true, quantities: [1, 3, 5] },
                full: { enabled: true, quantities: [1, 3, 5] },
                exp: { enabled: true, showTimer: true }
            },
            loot: {
                enabled: true,
                showFloating: true
            }
        },
        smartDamageCalc: {
            enabled: true,
            defenseValues: [0, 25, 50],
            showInStats: true
        },
        equipmentBonuses: {
            // Manual equipment bonuses (auto-extraction not available due to dynamic modals)
            // Update these values based on your equipped items
            extra_damage_monsters: 26,  // % Extra Damage to Monsters (e.g., Scalescourge 14% + Helmet 14%)
            armor_penetration: 5,       // % Armor Penetration
            crit_rate: 0,               // % Critical Rate
            crit_damage: 0,             // % Critical Damage
            stamina_save: 0,            // % Stamina Save
            heal_on_damage: 5,          // % Heal on Damage
            note: 'Update these values manually. Check your equipped items by clicking Info buttons in inventory.php'
        },
        ultraFastAttack: {
            enabled: true,
            maxParallelBattles: 20,
            maxConcurrentBattles: 10,
            attacksPerMonster: 1,
            skillId: -2,
            delayBetweenBatches: 3000,
            delayAfterJoin: 500,
            monsterNames: [],
            minMobHp: 100000,
            priorityMode: 'lowest_hp',
            autoReturnToWave: true
        },
        ultraFastLoot: {
            enabled: true,
            maxParallelLoots: 10,
            delayBetweenLoots: 100,
            autoLootAfterFarm: false,
            onlyEligible: true,
            lootSpecialBossBeforeFSP: true,
            filters: {
                monsterNames: [],
                excludeNames: []
            }
        },
        ultraFastStamina: {
            enabled: true,  // Default: true - stamina icon always visible
            batchSize: 10,  // Number of chapters to react to simultaneously
            delayBetweenBatches: 1000,  // Delay between batches (ms)
            reactionType: '1'  // Reaction type: '1' (üëç), '2' (‚ù§Ô∏è), '3' (üòÇ), '4' (üòÆ), '5' (üò¢)
        },
        ultraFastDungeon: {
            enabled: true,
            maxParallelBattles: 20,
            attacksPerMonster: 10,
            delayBetweenBatches: 2000,
            monsterFilter: {
                maxHp: 0,
                minDamage: 0,
                includeNames: [],
                excludeNames: []
            },
            minMobHp: 1000000,
            priorityMode: 'lowest_damage',
            checkJoined: true,
            checkNotJoined: true,
            useSmartDamage: true,
            damageThresholds: {
                default: 3000000,
                magus: 1000000
            },
            safetyMargin: 1,
            respectExpLimit: true,
            monsterNames: ['magus:5000000', 'rukka:6000000', 'gorvash:20000000']
        },
        specialBossFarm: {
            enabled: true,
            targetDamage: 1000000000,
            skillId: -2,
            parallelAttacks: 5,
            minDelayBetweenAttacks: 50,
            autoStaminaPotion: true,
            minStaminaForPotion: 50,
            lootDeadBeforeFSP: true,
            checkInterval: 300000,
            bossNames: ['General', 'Seraph', 'King', 'Empress', 'Bastion', 'Oathkeeper']
        },
        imageBlocker: {
            enabled: false  // Block images to reduce bandwidth and improve performance
        },
        merchantAutoBuy: {
            enabled: false,
            checkInterval: 3600000,  // Check every hour (1h)
            autoNotify: true,  // Notify when renewal is near
            retryAfterInsufficientGold: 3600000  // Retry after 1 hour if not enough gold
        }
    });

    const LEVELS = ['debug', 'info', 'warn', 'error'];

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, Math.max(0, ms)));
    }

    function sleepRandom(baseMs = 1000, variation = 0.3, enabled = true) {
        const base = Math.max(0, baseMs);
        if (!enabled || variation <= 0) {
            return sleep(base);
        }
        const delta = base * Math.max(0, variation);
        const min = Math.max(0, base - delta);
        const max = base + delta;
        const value = Math.floor(Math.random() * (max - min + 1) + min);
        return sleep(value);
    }

    // DEPRECATED: Legacy wrappers for backward compatibility
    // All code should migrate to context.numbers.parse() instead of numberFromText()
    // These wrappers will be removed in Phase 4
    
    /**
     * @deprecated Use context.numbers.parse() instead
     * Legacy wrapper for backward compatibility with existing code
     */
    function numberFromText(text) {
        // Use global context if available
        if (typeof window !== 'undefined' && window.autoDSServices?.context?.numbers) {
            return window.autoDSServices.context.numbers.parse(text);
        }
        // Fallback
        const tempService = createNumberFormattingService();
        return tempService.parse(text);
    }

    /**
     * @deprecated Use context.numbers.format() instead
     * Legacy wrapper for backward compatibility with existing code
     */
    function formatNumber(value) {
        // Use global context if available
        if (typeof window !== 'undefined' && window.autoDSServices?.context?.numbers) {
            return window.autoDSServices.context.numbers.format(value);
        }
        // Fallback
        const tempService = createNumberFormattingService();
        return tempService.format(value);
    }

    function calculateExpectedDungeonDamage(currentHP, maxHP) {
        // C√°lculo baseado no HP atual e m√°ximo
        // Estimativa: ~15-25% do HP atual como dano esperado
        const hpRatio = currentHP / maxHP;
        const baseDamage = Math.round(currentHP * 0.20);
        const bonus = Math.round(baseDamage * hpRatio * 0.1);
        return baseDamage + bonus;
    }

    function calculateExpectedExp(currentHP, maxHP) {
        // C√°lculo de EXP esperada baseado no HP
        // Base: 10% do HP atual + b√¥nus proporcional
        const hpRatio = currentHP / maxHP;
        const baseExp = Math.round(currentHP * 0.1);
        const levelMultiplier = 1 + (hpRatio * 0.5);
        return Math.round(baseExp * levelMultiplier);
    }

    // ==================== STAMINA READER SERVICE ====================
    // Centralized stamina reading utilities
    // Eliminates ~100 lines of duplicated code across modules
    
    /**
     * Create centralized stamina reader service
     * Provides unified API for reading player stamina from various DOM locations
     * 
     * @returns {Object} Stamina reader service
     * @returns {function(): number} getCurrent - Get current stamina value (0 if not found)
     * @returns {function(): number} getMax - Get maximum stamina value (0 if not found)
     * @returns {function(): number} getPercentage - Get stamina percentage 0-100 (0 if invalid)
     * @returns {function(number): boolean} hasEnough - Check if current stamina >= required amount
     * 
     * @example
     * const stamina = createStaminaReader();
     * const current = stamina.getCurrent(); // 180
     * const max = stamina.getMax(); // 200
     * const pct = stamina.getPercentage(); // 90.0
     * const canAttack = stamina.hasEnough(50); // true if current >= 50
     */
    function createStaminaReader() {
        const STAMINA_SELECTORS = [
            '#stamina_span',
            '[data-player-stamina]',
            '.gtb-stat[data-stat="stamina"] .gtb-value',
            '.stamina .current'
        ];
        
        const STAMINA_XPATH = [
            '//*[@id="discuscontainer"]/div[1]/div[1]/div[2]/span[1]/span'
        ];
        
        return {
            getCurrent() {
                const data = readGauge(STAMINA_SELECTORS, {
                    xpath: STAMINA_XPATH,
                    parse: true,
                    warn: false
                });
                return data?.current || 0;
            },
            
            getMax() {
                const data = readGauge(STAMINA_SELECTORS, {
                    xpath: STAMINA_XPATH,
                    parse: true,
                    warn: false
                });
                return data?.max || 0;
            },
            
            getPercentage() {
                const data = readGauge(STAMINA_SELECTORS, {
                    xpath: STAMINA_XPATH,
                    parse: true,
                    warn: false
                });
                if (!data?.current || !data?.max) return 0;
                return (data.current / data.max) * 100;
            },
            
            hasEnough(required) {
                return this.getCurrent() >= required;
            }
        };
    }

    /**
     * Check if a monster is a special boss (General, King, Empress, Bastion)
     * @param {string} monsterName - Monster name to check
     * @returns {boolean} - True if special boss
     */
    function isSpecialBoss(monsterName) {
        if (!monsterName) return false;
        const nameLower = monsterName.toLowerCase();
        const keywords = ['general', 'king', 'empress', 'bastion'];
        return keywords.some(keyword => nameLower.includes(keyword));
    }

    /**
     * Get effective damage target for a monster (minimum 50M for special bosses)
     * @param {string} monsterName - Monster name
     * @param {number} configuredTarget - Configured damage target
     * @returns {number} - Effective damage target (minimum 50M for special bosses)
     */
    function getEffectiveDamageTarget(monsterName, configuredTarget) {
        const SPECIAL_BOSS_MIN_DAMAGE = 50000000; // 50M
        if (isSpecialBoss(monsterName)) {
            return Math.max(configuredTarget || 0, SPECIAL_BOSS_MIN_DAMAGE);
        }
        return configuredTarget || 0;
    }

    function escapeHtml(value) {
        return String(value ?? '').replace(/[&<>"']/g, (char) => {
            switch (char) {
                case '&': return '&amp;';
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '"': return '&quot;';
                case "'": return '&#39;';
                default: return char;
            }
        });
    }

    // showErrorNotification removed in Phase 1 cleanup

    function ensureLayoutStyles(doc) {
        if (!doc) return;
        if (doc.getElementById('autods-layout-offset-style')) return;
        const style = doc.createElement('style');
        style.id = 'autods-layout-offset-style';
        style.textContent = `
            :root {
                --autods-panel-width: 0px;
                --autods-toolbar-height: 0px;
            }
            body.autods-layout-ready {
                margin-right: var(--autods-panel-width, 0px);
                transition: margin-right 0.3s ease;
            }

            /* Mobile layout adjustments */
            @media (max-width: 768px) {
                body.autods-layout-ready {
                    margin-right: min(85vw, 400px);
                }
            }

            @media (max-width: 480px) {
                body.autods-layout-ready {
                    margin-right: 0 !important;
                }
                body.autods-layout-ready.autods-panel-visible {
                    overflow: hidden;
                }
            }
        `;
        doc.head ? doc.head.appendChild(style) : doc.documentElement.appendChild(style);
    }

    function ensureFloatingHelpersStyles(doc) {
        if (!doc) return;
        if (doc.getElementById('autods-floating-helpers-style')) return;
        const style = doc.createElement('style');
        style.id = 'autods-floating-helpers-style';
        style.textContent = `
            /* Floating Helpers Styles */
                position: fixed;
                top: 0;
                right: 0;
                bottom: 0;
                width: 220px;
                z-index: 999998;
                display: flex;
                flex-direction: column;
                padding: 16px 8px;
                background: rgba(10, 18, 30, 0.92);
                border-left: 1px solid rgba(70, 130, 220, 0.25);
                box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(10px) saturate(180%);
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease, width 0.3s ease;
                will-change: transform;
                overflow-y: auto;
                overflow-x: hidden;
                scrollbar-width: thin;
                scrollbar-color: rgba(70, 130, 220, 0.4) transparent;
            }
            #autods-shortcuts-toolbar::-webkit-scrollbar {
                width: 6px;
            }
            #autods-shortcuts-toolbar::-webkit-scrollbar-track {
                background: transparent;
            }
            #autods-shortcuts-toolbar::-webkit-scrollbar-thumb {
                background: rgba(70, 130, 220, 0.3);
                border-radius: 999px;
            }
            #autods-shortcuts-toolbar::-webkit-scrollbar-thumb:hover {
                background: rgba(70, 130, 220, 0.5);
            }
            #autods-shortcuts-toolbar[data-hidden="1"] {
                transform: translateX(100%);
                opacity: 0;
                pointer-events: none;
            }
            #autods-shortcuts-toolbar .autods-toolbar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                width: 100%;
            }
            #autods-shortcuts-toolbar .autods-toolbar-dashboard {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                font-size: 12px;
                font-weight: 700;
                text-transform: uppercase;
                letter-spacing: 1px;
                color: rgba(255, 255, 255, 0.95);
                padding: 12px 16px;
                text-align: center;
                text-decoration: none;
                background: linear-gradient(135deg, rgba(50, 100, 180, 0.6), rgba(30, 70, 140, 0.7));
                border-radius: 10px;
                border: 2px solid rgba(70, 130, 220, 0.5);
                user-select: none;
                margin-bottom: 8px;
                transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            }
            #autods-shortcuts-toolbar .autods-toolbar-dashboard:hover {
                background: linear-gradient(135deg, rgba(70, 130, 220, 0.8), rgba(50, 100, 180, 0.9));
                border-color: rgba(100, 160, 255, 0.8);
                transform: translateY(-2px);
                box-shadow: 0 6px 18px rgba(70, 130, 220, 0.4);
            }
            #autods-shortcuts-toolbar .autods-toolbar-dashboard:active {
                transform: translateY(0);
                box-shadow: 0 2px 8px rgba(70, 130, 220, 0.3);
            }
            #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-icon {
                font-size: 16px;
                line-height: 1;
            }
            #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-text {
                line-height: 1;
            }
            #autods-shortcuts-toolbar .autods-toolbar-links {
                display: flex;
                flex-direction: column;
                gap: 6px;
                width: 100%;
            }
            .autods-toolbar-heading {
                font-size: 9px;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.8px;
                color: rgba(140, 190, 255, 0.75);
                padding: 6px 12px;
                border-radius: 6px;
                background: rgba(30, 60, 120, 0.3);
                border: 1px solid rgba(70, 130, 220, 0.2);
                user-select: none;
                margin-top: 8px;
            }
            .autods-toolbar-divider {
                width: 100%;
                height: 1px;
                background: rgba(70, 130, 220, 0.2);
                margin: 4px 0;
            }
            .autods-toolbar-link {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 10px 12px;
                border-radius: 8px;
                background: rgba(20, 40, 80, 0.5);
                border: 1px solid rgba(70, 130, 220, 0.25);
                color: rgba(200, 220, 255, 0.95);
                font-size: 11px;
                font-weight: 500;
                text-decoration: none;
                line-height: 1.3;
                white-space: normal;
                word-wrap: break-word;
                transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                user-select: none;
            }
            .autods-toolbar-link:hover {
                background: rgba(50, 90, 160, 0.6);
                border-color: rgba(70, 130, 220, 0.5);
                color: rgba(255, 255, 255, 1);
                transform: translateX(-3px);
                box-shadow: -3px 0 12px rgba(70, 130, 220, 0.3);
            }
            .autods-toolbar-link:active {
                transform: translateX(-1px);
            }
            .autods-toolbar-link.active {
                background: rgba(70, 130, 220, 0.4);
                border-color: rgba(100, 160, 255, 0.7);
                color: rgba(255, 255, 255, 1);
                font-weight: 600;
                box-shadow: 0 0 20px rgba(70, 130, 220, 0.4), inset 0 0 20px rgba(70, 130, 220, 0.2);
            }
            .autods-toolbar-link .badge {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                padding: 2px 6px;
                min-width: 20px;
                font-size: 9px;
                font-weight: 600;
                border-radius: 4px;
                background: rgba(70, 130, 220, 0.3);
                border: 1px solid rgba(100, 160, 255, 0.4);
                color: rgba(255, 255, 255, 0.95);
            }

            /* Ajuste do body para n√£o ficar embaixo da toolbar */
            body {
                margin-right: 220px !important;
                transition: margin-right 0.3s ease;
            }
            body.autods-toolbar-hidden {
                margin-right: 0 !important;
            }
            
            /* üÜï When shell is open, add extra margin for the shell panel */
            body.autods-shell-open {
                margin-right: calc(220px + var(--autods-panel-width, 380px)) !important;
                transition: margin-right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }
            
            /* Mobile: shell takes full width, no extra margin from toolbar */
            @media (max-width: 480px) {
                body.autods-shell-open {
                    margin-right: 0 !important;
                }
            }

            /* Mobile-First Responsive Design para Toolbar */
            @media (max-width: 1024px) {
                #autods-shortcuts-toolbar {
                    width: 200px;
                    padding: 14px 7px;
                }
                body {
                    margin-right: 200px !important;
                }
                .autods-toolbar-dashboard {
                    font-size: 11px;
                    padding: 11px 14px;
                }
                .autods-toolbar-link {
                    padding: 9px 11px;
                    font-size: 10px;
                }
            }

            @media (max-width: 768px) {
                #autods-shortcuts-toolbar {
                    width: 180px;
                    padding: 12px 6px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard {
                    font-size: 10px;
                    padding: 10px 12px;
                    gap: 6px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-icon {
                    font-size: 14px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-inner {
                    gap: 8px;
                }
                .autods-toolbar-link {
                    padding: 8px 10px;
                    font-size: 10px;
                    gap: 5px;
                }
                .autods-toolbar-heading {
                    font-size: 8px;
                    padding: 5px 8px;
                }
                body {
                    margin-right: 180px !important;
                }
            }

            @media (max-width: 600px) {
                #autods-shortcuts-toolbar {
                    width: 64px;
                    padding: 10px 4px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard {
                    flex-direction: column;
                    padding: 12px 6px;
                    gap: 4px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-icon {
                    font-size: 18px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-text {
                    font-size: 7px;
                    letter-spacing: 0.5px;
                    writing-mode: horizontal-tb;
                    line-height: 1.1;
                }
                #autods-shortcuts-toolbar .autods-toolbar-inner {
                    gap: 6px;
                }
                .autods-toolbar-link {
                    padding: 10px 6px;
                    font-size: 0;
                    justify-content: center;
                    text-align: center;
                    min-height: 44px;
                    gap: 0;
                }
                .autods-toolbar-link::before {
                    content: attr(data-icon);
                    font-size: 16px;
                    line-height: 1;
                }
                .autods-toolbar-heading {
                    font-size: 7px;
                    padding: 6px 3px;
                    writing-mode: vertical-rl;
                    text-orientation: mixed;
                    letter-spacing: 0.5px;
                }
                .autods-toolbar-divider {
                    display: none;
                }
                .autods-toolbar-link .badge {
                    position: absolute;
                    top: 2px;
                    right: 2px;
                    font-size: 8px;
                    min-width: 16px;
                    padding: 1px 4px;
                }
                body {
                    margin-right: 64px !important;
                }
            }

            @media (max-width: 480px) {
                #autods-shortcuts-toolbar {
                    width: 56px;
                    padding: 8px 3px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard {
                    padding: 10px 5px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-icon {
                    font-size: 16px;
                }
                #autods-shortcuts-toolbar .autods-toolbar-dashboard .dashboard-text {
                    font-size: 6px;
                }
                .autods-toolbar-link {
                    padding: 8px 4px;
                    min-height: 40px;
                }
                .autods-toolbar-link::before {
                    font-size: 14px;
                }
                .autods-toolbar-heading {
                    font-size: 6px;
                    padding: 5px 2px;
                }
                body {
                    margin-right: 56px !important;
                }
            }

            /* Responsividade para telas muito pequenas */

            /* Floating Helpers Styles */
            #autods-floating-helpers {
                position: fixed;
                display: flex;
                flex-direction: column;
                gap: 8px;
                z-index: 2147483647;
                pointer-events: auto;
                transition: right 0.3s ease, left 0.3s ease, opacity 0.3s ease, flex-direction 0.3s ease;
            }

            /* Desktop: posicionar √† direita da p√°gina (canto direito) */
            @media (min-width: 769px) {
                #autods-floating-helpers[data-position="right"] {
                    right: 12px;
                }
                #autods-floating-helpers[data-position="left"] {
                    left: 12px;
                }
                #autods-floating-helpers {
                    gap: 8px;
                }
                
                /* üÜï Quando shell abre, empurrar floating helpers para a direita */
                body.autods-shell-open #autods-floating-helpers[data-position="right"] {
                    right: calc(12px + var(--autods-panel-width, 380px));
                }
            }

            /* Tablet: reduzir espa√ßamento */
            @media (max-width: 768px) and (min-width: 481px) {
                #autods-floating-helpers[data-position="right"] {
                    right: 12px;
                }
                #autods-floating-helpers[data-position="left"] {
                    left: 12px;
                }
                #autods-floating-helpers {
                    gap: 6px;
                }
            }

            /* Mobile: grid layout 2x3 ou menos em tela pequena */
            @media (max-width: 480px) {
                #autods-floating-helpers {
                    right: 12px !important;
                    left: auto !important;
                    top: auto !important;
                    bottom: 12px;
                    display: grid;
                    grid-template-columns: repeat(2, 1fr);
                    gap: 6px;
                    max-width: calc(100vw - 68px); /* 56px toolbar + 12px margin */
                    width: auto;
                    padding: 8px;
                    background: rgba(30, 30, 46, 0.9);
                    border: 2px solid rgba(137, 180, 250, 0.3);
                    border-radius: 8px;
                    transition: all 0.3s ease;
                }

                /* Estado minimizado em mobile - mostrar apenas toggle */
                #autods-floating-helpers[data-minimized="1"] {
                    grid-template-columns: 1fr;
                    padding: 4px;
                    width: auto;
                    max-width: none;
                }

                /* Esconder todos os elementos exceto toggle quando minimizado */
                #autods-floating-helpers[data-minimized="1"] > *:not(#autods-floating-helpers-toggle) {
                    display: none !important;
                }

                /* Toggle button sempre vis√≠vel */
                #autods-floating-helpers-toggle {
                    order: -1; /* For√ßar para primeiro em flex */
                    padding: 6px;
                    background: linear-gradient(135deg, rgba(137, 180, 250, 0.2), rgba(139, 233, 253, 0.2));
                    border: 1px solid rgba(137, 180, 250, 0.4);
                    border-radius: 6px;
                    color: #89b4fa;
                    font-size: 12px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    text-align: center;
                    display: block !important;
                    width: 100%;
                }

                #autods-floating-helpers-toggle:hover {
                    background: linear-gradient(135deg, rgba(137, 180, 250, 0.3), rgba(139, 233, 253, 0.3));
                    border-color: rgba(137, 180, 250, 0.6);
                }
                
                /* Container expandido para mostrar grid */
                #autods-floating-helpers[data-minimized="0"] {
                    display: flex;
                    flex-direction: column;
                }

                #autods-floating-helpers::-webkit-scrollbar {
                    display: none;
                }
                
                /* Garantir que todos os bot√µes apare√ßam em mobile */
                #autods-floating-helpers > div {
                    min-width: 0;
                    flex: 1;
                }
                
                /* Tab buttons em grid 2x2 */
                #autods-floating-helpers #autods-main-tab-buttons {
                    display: grid;
                    grid-template-columns: repeat(2, 1fr);
                    gap: 6px;
                    padding: 0;
                    margin: 0;
                    border: none;
                    padding-top: 0;
                }
            }

            /* Additional styles for floating helper boxes - REMOVED (now using inline styles) */
            /* All buttons now use standardized inline styles with gradients and colors */

            .battle-drawer-box {
                border-color: rgba(249, 226, 175, 0.5);
            }

            .battle-drawer-box:hover {
                box-shadow: 0 4px 12px rgba(249, 226, 175, 0.4);
            }

            .potion-box.potion-exp {
                border-color: rgba(249, 226, 175, 0.5);
            }

            .potion-box.potion-exp:hover {
                box-shadow: 0 4px 12px rgba(249, 226, 175, 0.4);
            }

            .loot-box {
                border-color: rgba(166, 227, 161, 0.5);
            }

            .loot-box:hover {
                box-shadow: 0 4px 12px rgba(166, 227, 161, 0.4);
            }

            @media (max-width: 480px) {
                .potion-box, .loot-box, .battle-drawer-box {
                    min-width: 50px;
                    padding: 6px;
                    flex-shrink: 0;
                }
            }

            /* Panel Toggle Button (Desktop) */
            #autods-panel-toggle-btn {
                position: fixed;
                top: 50%;
                right: 12px;
                transform: translateY(-50%);
                z-index: 9998;
                width: 48px;
                height: 48px;
                border-radius: 50%;
                background: linear-gradient(135deg, rgba(50, 100, 180, 0.95), rgba(30, 70, 140, 0.95));
                border: 2px solid rgba(70, 130, 220, 0.6);
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 0 0 rgba(70, 130, 220, 0.6);
                cursor: pointer;
                display: none;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                color: #fff;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                backdrop-filter: blur(10px);
                animation: pulse-shadow 2s ease-in-out infinite;
            }
            #autods-panel-toggle-btn:hover {
                background: linear-gradient(135deg, rgba(70, 130, 220, 0.95), rgba(50, 100, 180, 0.95));
                border-color: rgba(100, 160, 255, 0.8);
                transform: translateY(-50%) scale(1.1);
                box-shadow: 0 6px 20px rgba(70, 130, 220, 0.5);
            }
            #autods-panel-toggle-btn:active {
                transform: translateY(-50%) scale(0.95);
            }
            #autods-panel-toggle-btn.visible {
                display: flex;
            }
            
            /* üÜï Styling when button is inside autods-floating-helpers */
            #autods-floating-helpers #autods-panel-toggle-btn {
                position: static !important;
                transform: none !important;
                display: block !important;
                margin-bottom: 8px;
                width: 100%;
                background: linear-gradient(135deg, rgba(137, 180, 250, 0.2), rgba(139, 233, 253, 0.2));
                border: 1px solid rgba(137, 180, 250, 0.4);
                border-radius: 6px;
                color: #89b4fa;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
                text-align: center;
                padding: 8px 12px;
            }
            
            #autods-floating-helpers #autods-panel-toggle-btn:hover {
                background: linear-gradient(135deg, rgba(137, 180, 250, 0.3), rgba(139, 233, 253, 0.3));
                border-color: rgba(137, 180, 250, 0.6);
            }
            
            #autods-floating-helpers #autods-panel-toggle-btn:active {
                transform: scale(0.98) !important;
            }
            
            @keyframes pulse-shadow {
                0%, 100% {
                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 0 0 rgba(70, 130, 220, 0.6);
                }
                50% {
                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 0 8px rgba(70, 130, 220, 0);
                }
            }
            @media (max-width: 480px) {
                #autods-panel-toggle-btn {
                    display: none !important;
                }
            }
        `;
        doc.head ? doc.head.appendChild(style) : doc.documentElement.appendChild(style);
    }

    function ensureBodyLayoutClass(doc) {
        if (!doc) return;
        const apply = () => {
            if (doc.body) {
                doc.body.classList.add('autods-layout-ready');
            }
        };

        if (doc.body) {
            apply();
        } else {
            doc.addEventListener('DOMContentLoaded', apply, { once: true });
        }
    }

    function setPanelOffset(doc, widthPx) {
        if (!doc) return;
        const width = Math.max(MIN_PANEL_WIDTH_PX, Number(widthPx) || PANEL_WIDTH_PX);
        doc.documentElement.style.setProperty('--autods-panel-width', `${width}px`);
        ensureBodyLayoutClass(doc);
    }

    function createPatchFromPath(path, value) {
        if (!path) return {};
        const keys = path.split('.');
        return keys.reduceRight((acc, key) => ({ [key]: acc }), value);
    }

    function selectSmartSkill(currentDamage, targetDamage, skillsConfig) {
        // Calculate remaining damage needed to reach target
        const remainingDamage = targetDamage - currentDamage;

        if (remainingDamage <= 0) {
            return null; // Target already reached
        }

        // Convert skills config to array and sort by damage limit (descending)
        const skills = Object.values(skillsConfig).sort((a, b) => b.damageLimit - a.damageLimit);

        // Find the highest damage skill that won't overshoot the target
        for (const skill of skills) {
            if (skill.damageLimit > 0 && skill.damageLimit <= remainingDamage) {
                return skill;
            }
        }

        // If no skill fits perfectly, use the lowest damage skill (Slash)
        return skills[skills.length - 1]; // Returns Slash (skillId: 0, damageLimit: 0)
    }

    function queryXPathFirst(xpath, root = document) {
        try {
            const result = document.evaluate(xpath, root, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
            return result.singleNodeValue || null;
        } catch (error) {
            console.warn('[AutoDS][xpath] Failed to evaluate', xpath, error);
            return null;
        }
    }

    function parseGaugeText(text) {
        if (!text) return null;
        const tempNumbers = createNumberFormattingService();
        const parts = text.split('/');
        if (parts.length >= 2) {
            const current = tempNumbers.parse(parts[0]);
            const max = tempNumbers.parse(parts[1]);
            if (current !== null || max !== null) {
                return { current, max };
            }
        }
        const value = tempNumbers.parse(text);
        if (value === null) return null;
        return { current: value, max: null };
    }

    function extractGaugeFromElement(element) {
        if (!element) return null;
        const { dataset } = element;
        const dataCurrent = dataset?.current ?? dataset?.value ?? element.getAttribute?.('data-current') ?? element.getAttribute?.('data-value') ?? element.getAttribute?.('aria-valuenow');
        const dataMax = dataset?.max ?? element.getAttribute?.('data-max') ?? element.getAttribute?.('aria-valuemax');
        const tempNumbers = createNumberFormattingService();
        let current = dataCurrent ? tempNumbers.parse(dataCurrent) : null;
        let max = dataMax ? tempNumbers.parse(dataMax) : null;

        if (current === null) {
            const aria = element.getAttribute?.('aria-valuenow');
            if (aria) current = tempNumbers.parse(aria);
        }
        if (max === null) {
            const ariaMax = element.getAttribute?.('aria-valuemax');
            if (ariaMax) max = tempNumbers.parse(ariaMax);
        }

        if (current === null) {
            const textValue = element.textContent ?? '';
            const gauge = parseGaugeText(textValue);
            if (gauge) {
                current = gauge.current;
                max = max ?? gauge.max;
            }
        }

        if ((current === null || max === null) && element.parentElement) {
            const parentGauge = parseGaugeText(element.parentElement.textContent ?? '');
            if (parentGauge) {
                if (current === null) current = parentGauge.current;
                if (max === null) max = parentGauge.max;
            }
        }

        if (current === null && max === null) return null;
        return { current, max };
    }

    function readGauge(selectors = [], options = {}) {
        for (const selector of selectors) {
            const element = document.querySelector(selector);
            const gauge = extractGaugeFromElement(element);
            if (gauge) return gauge;
        }

        if (Array.isArray(options.xpath)) {
            for (const xpath of options.xpath) {
                const element = queryXPathFirst(xpath);
                const gauge = extractGaugeFromElement(element);
                if (gauge) return gauge;
            }
        } else if (typeof options.xpath === 'string') {
            const element = queryXPathFirst(options.xpath);
            const gauge = extractGaugeFromElement(element);
            if (gauge) return gauge;
        }

        if (options.fallback) {
            const gauge = parseGaugeText(options.fallback);
            if (gauge) return gauge;
        }

        return null;
    }

    /**
     * Add "Join Now" or "Fight Now" button next to existing Join/Fight buttons.
     * This button will call joinBattleDirectly() or joinDungeonBattleDirectly() before navigating.
     * @param {HTMLElement} originalButton - The original Join/Fight button
     * @param {string} monsterId - Monster ID or dgmid
     * @param {string} buttonLabel - Label for the new button (e.g., "Join Now", "Fight Now")
     * @param {object} context - Context object
     * @param {string} instanceId - Instance ID (for dungeons, optional)
     * @param {boolean} autoNavigate - Whether to navigate after successful join (default: true)
     */
    function addDirectJoinButton(originalButton, monsterId, buttonLabel, context, instanceId = null, autoNavigate = false) {
        // Check if button already exists
        if (originalButton.nextElementSibling?.classList.contains('autods-direct-join')) {
            // context.logger.debug(`[DirectJoin] Button already exists for monster ${monsterId}`);
            return;
        }

        // context.logger.debug(`[DirectJoin] Creating button for monster ${monsterId}${instanceId ? ` (instance ${instanceId})` : ''}`);

        const directButton = document.createElement('button');
        directButton.className = 'autods-direct-join';
        directButton.textContent = `‚ö° ${buttonLabel}`;
        directButton.setAttribute('data-monster-id', monsterId);
        if (instanceId) {
            directButton.setAttribute('data-instance-id', instanceId);
        }
        directButton.style.cssText = `
            margin-left: 8px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #a6e3a1 0%, #94e2d5 100%);
            color: #1e1e2e;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;

        directButton.addEventListener('mouseenter', () => {
            directButton.style.transform = 'translateY(-1px)';
            directButton.style.filter = 'brightness(1.1)';
        });

        directButton.addEventListener('mouseleave', () => {
            directButton.style.transform = '';
            directButton.style.filter = '';
        });

        directButton.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();

            // context.logger.info(`[DirectJoin] üñ±Ô∏è Button clicked for monster ${monsterId}`);

            // VERIFICA√á√ÉO INTELIGENTE: S√≥ usar direct join em p√°ginas wave/dungeon
            // Se j√° estiver em battle.php, usar m√©todo tradicional (click)
            const currentPath = window.location.pathname;
            const isOnWavePage = /active_wave\.php|guild_dungeon_location\.php/i.test(currentPath);
            const isOnBattlePage = /battle\.php|dungeon_battle\.php/i.test(currentPath);

            if (isOnBattlePage) {
                // context.logger.info(`[DirectJoin] ‚ö†Ô∏è J√° est√° em p√°gina de batalha. Usando m√©todo tradicional (click).`);
                originalButton.click();
                return;
            }

            if (!isOnWavePage) {
                // context.logger.warn(`[DirectJoin] ‚ö†Ô∏è P√°gina n√£o reconhecida para direct join. Usando m√©todo tradicional.`);
                originalButton.click();
                return;
            }

            directButton.disabled = true;
            const originalText = directButton.textContent;
            directButton.textContent = '‚è≥ Joining...';

            try {
                // Detect if this is a dungeon page
                const isDungeon = /guild_dungeon_location\.php/i.test(currentPath);
                
                if (isDungeon) {
                    // Use instanceId from data attribute if available
                    let dgmid = monsterId;
                    let dungeonInstanceId = instanceId || directButton.getAttribute('data-instance-id');
                    
                    // Fallback: Extract from button's href or nearby link
                    if (!dungeonInstanceId) {
                        let battleUrl = null;
                        
                        // Try to get href from button itself (if it's an <a> tag)
                        if (originalButton.tagName === 'A') {
                            battleUrl = originalButton.href;
                        } else {
                            // Try to find nearby link (support both dungeon_battle.php and battle.php with dgmid)
                            const card = originalButton.closest('.mon, .monster-card');
                            const link = card?.querySelector('a[href*="battle.php"][href*="dgmid"], a[href*="dungeon_battle.php"]');
                            battleUrl = link?.href;
                        }
                        
                        if (!battleUrl) {
                            throw new Error('Could not find battle URL for dungeon');
                        }
                        
                        const dgmidMatch = battleUrl.match(/[?&]dgmid=(\d+)/);
                        const instanceMatch = battleUrl.match(/[?&]instance_id=(\d+)/);
                        
                        if (!dgmidMatch || !instanceMatch) {
                            throw new Error('Could not extract dgmid or instance_id from URL');
                        }
                        
                        dgmid = dgmidMatch[1];
                        dungeonInstanceId = instanceMatch[1];
                    }
                    
                    // Use context.http instead of legacy function
                    const userId = context.userSession?.getUserId() || context.config.get().core.userId;
                    const result = await context.http.joinDungeonBattle(dgmid, dungeonInstanceId, userId);
                    
                    context.logger.debug(`[DirectJoin] Join result:`, result);
                    
                    if (result.success) {
                        context.logger.info(`[DirectJoin] ‚úÖ Join successful: ${result.message}`);
                        
                        context.notifications.success(result.message || 'Joined dungeon successfully!');
                        
                        // Only navigate if autoNavigate is enabled (manual clicks should navigate, auto mode should not)
                        if (autoNavigate) {
                            const battleUrl = `battle.php?dgmid=${dgmid}&instance_id=${dungeonInstanceId}`;
                            context.logger.info(`[DirectJoin] Navigating to ${battleUrl}`);
                            setTimeout(() => {
                                window.location.href = battleUrl;
                            }, 500); // Small delay to allow other requests to complete
                        }
                    } else {
                        // FALLBACK: Se API falhou, usar m√©todo tradicional
                        context.logger.warn(`[DirectJoin] ‚ö†Ô∏è API join falhou: ${result.message}. Usando fallback (click).`);
                        context.notifications.warn('API join failed, using traditional method...');
                        originalButton.click();
                    }
                } else {
                    // Regular wave battle - using direct fetch to bypass Cloudflare
                    const userId = context.userSession?.getUserId();
                    context.logger.debug(`[DirectJoin] User ID from cookie: ${userId || 'NOT FOUND'}`);
                    
                    if (!userId) {
                        throw new Error('User ID not found. Please make sure you are logged in.');
                    }

                    context.logger.info(`[DirectJoin] Using direct fetch to user_join_battle.php (monster: ${monsterId}, user: ${userId})...`);
                    
                    // Use direct fetch with same headers as example to bypass Cloudflare
                    // IMPORTANT: referrer must be the battle page, not the current page
                    const battleUrl = `https://demonicscans.org/battle.php?id=${monsterId}`;
                    const response = await fetch("https://demonicscans.org/user_join_battle.php", {
                        "credentials": "include",
                        "headers": {
                            "User-Agent": navigator.userAgent,
                            "Accept": "*/*",
                            "Accept-Language": "pt-BR,pt;q=0.8,en-US;q=0.5,en;q=0.3",
                            "Content-Type": "application/x-www-form-urlencoded",
                            "Sec-Fetch-Dest": "empty",
                            "Sec-Fetch-Mode": "cors",
                            "Sec-Fetch-Site": "same-origin"
                        },
                        "referrer": battleUrl,
                        "body": `monster_id=${monsterId}&user_id=${userId}`,
                        "method": "POST",
                        "mode": "cors"
                    });

                    const text = await response.text();
                    context.logger.debug(`[DirectJoin] Response: ${text.substring(0, 200)}`);

                    // Check if join was successful
                    if (text.toLowerCase().includes('success')) {
                        context.logger.info(`[DirectJoin] ‚úÖ Join successful!`);
                        
                        context.notifications.success('Joined successfully!');
                        
                        // Only navigate if autoNavigate is enabled (manual clicks should navigate, auto mode should not)
                        if (autoNavigate) {
                            const battleUrl = `battle.php?id=${monsterId}`;
                            context.logger.info(`[DirectJoin] Navigating to ${battleUrl}`);
                            setTimeout(() => {
                                window.location.href = battleUrl;
                            }, 500); // Small delay to allow other requests to complete
                        }
                    } else {
                        // FALLBACK: Se n√£o detectou sucesso, usar m√©todo tradicional
                        context.logger.warn(`[DirectJoin] ‚ö†Ô∏è Join response n√£o indicou sucesso: ${text}. Usando fallback (click).`);
                        context.notifications.warn('Join response unclear, using traditional method...');
                        originalButton.click();
                    }
                }
            } catch (error) {
                context.logger.error(`[DirectJoin] ‚ùå Error: ${error.message}`, error);
                
                // FALLBACK FINAL: Em caso de qualquer erro, usar m√©todo tradicional
                context.logger.warn(`[DirectJoin] Usando fallback final (click) devido ao erro.`);
                
                context.notifications.warn(`Join error, using traditional method...`);

                try {
                    originalButton.click();
                } catch (clickError) {
                    context.logger.error(`[DirectJoin] Fallback click tamb√©m falhou:`, clickError);
                    alert(`Failed to join: ${error.message}`);
                }

                directButton.disabled = false;
                directButton.textContent = originalText;
            }
        });

        // Insert after original button
        originalButton.parentNode.insertBefore(directButton, originalButton.nextSibling);
        // context.logger.debug(`[DirectJoin] Button inserted for monster ${monsterId}`);
    }

    function createStorage({ namespace }) {
        const keyFor = key => `${namespace}:${key}`;

        function get(key, fallback) {
            try {
                if (IS_TAMPERMONKEY) {
                    const raw = GM_getValue(keyFor(key));
                    if (raw === undefined || raw === null || raw === '') return fallback;
                    return JSON.parse(raw);
                }
                const raw = window.localStorage.getItem(keyFor(key));
                if (raw === null || raw === '') return fallback;
                return JSON.parse(raw);
            } catch (error) {
                console.warn('[AutoDS][storage] Failed to read key', key, error);
                return fallback;
            }
        }

        function set(key, value) {
            try {
                const payload = JSON.stringify(value);
                if (IS_TAMPERMONKEY) {
                    GM_setValue(keyFor(key), payload);
                } else {
                    window.localStorage.setItem(keyFor(key), payload);
                }
            } catch (error) {
                console.warn('[AutoDS][storage] Failed to persist key', key, error);
            }
        }

        function remove(key) {
            try {
                if (IS_TAMPERMONKEY) {
                    GM_deleteValue(keyFor(key));
                } else {
                    window.localStorage.removeItem(keyFor(key));
                }
            } catch (error) {
                console.warn('[AutoDS][storage] Failed to remove key', key, error);
            }
        }

        return { get, set, remove };
    }

    // ==================== LOG FLOATER ====================
    // Floating log viewer that shows script activity without opening console
    
    const logFloaterState = {
        logs: [],
        maxLogs: 50,
        minimized: false,
        container: null,
        logList: null,
        initialized: false,
        enabled: true
    };
    
    function createLogFloater(config = {}) {
        if (logFloaterState.initialized) return;
        logFloaterState.initialized = true;
        
        // Check if enabled
        if (config.enabled === false) {
            logFloaterState.enabled = false;
            return;
        }
        
        // Create styles
        const style = document.createElement('style');
        style.textContent = `
            #autods-log-floater {
                position: fixed;
                bottom: 40px;
                left: 40px;
                width: 400px;
                max-height: 300px;
                background: rgba(20, 20, 30, 0.95);
                border: 1px solid #444;
                border-radius: 8px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 11px;
                z-index: 2147483640;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
                overflow: hidden;
                transition: all 0.3s ease;
            }
            #autods-log-floater.minimized {
                width: 180px;
                max-height: 36px;
            }
            #autods-log-floater-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 8px 12px;
                background: linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%);
                border-bottom: 1px solid #444;
                cursor: pointer;
                user-select: none;
            }
            #autods-log-floater-header:hover {
                background: linear-gradient(135deg, #3a3a4a 0%, #2a2a3a 100%);
            }
            #autods-log-floater-title {
                color: #8af;
                font-weight: bold;
                font-size: 12px;
                display: flex;
                align-items: center;
                gap: 6px;
            }
            #autods-log-floater-title .status-dot {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: #4f4;
                animation: pulse 2s infinite;
            }
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.5; }
            }
            #autods-log-floater-controls {
                display: flex;
                gap: 8px;
            }
            #autods-log-floater-controls button {
                background: transparent;
                border: none;
                color: #888;
                cursor: pointer;
                font-size: 14px;
                padding: 2px 6px;
                border-radius: 4px;
                transition: all 0.2s;
            }
            #autods-log-floater-controls button:hover {
                color: #fff;
                background: rgba(255,255,255,0.1);
            }
            #autods-log-floater-content {
                max-height: 260px;
                overflow-y: auto;
                padding: 4px 0;
            }
            #autods-log-floater.minimized #autods-log-floater-content {
                display: none;
            }
            .autods-log-entry {
                padding: 4px 12px;
                border-bottom: 1px solid rgba(255,255,255,0.05);
                display: flex;
                gap: 8px;
                align-items: flex-start;
                word-break: break-word;
            }
            .autods-log-entry:hover {
                background: rgba(255,255,255,0.03);
            }
            .autods-log-entry .time {
                color: #666;
                font-size: 10px;
                white-space: nowrap;
                min-width: 55px;
            }
            .autods-log-entry .level {
                font-size: 10px;
                font-weight: bold;
                min-width: 40px;
                text-transform: uppercase;
            }
            .autods-log-entry .level.debug { color: #888; }
            .autods-log-entry .level.info { color: #4af; }
            .autods-log-entry .level.warn { color: #fa4; }
            .autods-log-entry .level.error { color: #f44; }
            .autods-log-entry .msg {
                color: #ddd;
                flex: 1;
                line-height: 1.4;
            }
            .autods-log-entry.debug .msg { color: #888; }
            .autods-log-entry.info .msg { color: #ddd; }
            .autods-log-entry.warn .msg { color: #fda; }
            .autods-log-entry.error .msg { color: #faa; }
            #autods-log-floater-content::-webkit-scrollbar {
                width: 6px;
            }
            #autods-log-floater-content::-webkit-scrollbar-track {
                background: transparent;
            }
            #autods-log-floater-content::-webkit-scrollbar-thumb {
                background: #444;
                border-radius: 3px;
            }
            #autods-log-floater-content::-webkit-scrollbar-thumb:hover {
                background: #555;
            }
            #autods-log-floater-badge {
                background: #f44;
                color: white;
                font-size: 10px;
                padding: 1px 5px;
                border-radius: 8px;
                margin-left: 6px;
                display: none;
            }
            #autods-log-floater.minimized #autods-log-floater-badge.has-new {
                display: inline-block;
            }
        `;
        document.head.appendChild(style);
        
        // Create container
        const container = document.createElement('div');
        container.id = 'autods-log-floater';
        container.innerHTML = `
            <div id="autods-log-floater-header">
                <div id="autods-log-floater-title">
                    <span class="status-dot"></span>
                    AutoDS Logs
                    <span id="autods-log-floater-badge">0</span>
                </div>
                <div id="autods-log-floater-controls">
                    <button id="autods-log-clear" title="Limpar logs">üóëÔ∏è</button>
                    <button id="autods-log-toggle" title="Minimizar/Expandir">‚ûñ</button>
                </div>
            </div>
            <div id="autods-log-floater-content"></div>
        `;
        document.body.appendChild(container);
        
        logFloaterState.container = container;
        logFloaterState.logList = container.querySelector('#autods-log-floater-content');
        
        // Event handlers
        const header = container.querySelector('#autods-log-floater-header');
        const toggleBtn = container.querySelector('#autods-log-toggle');
        const clearBtn = container.querySelector('#autods-log-clear');
        const badge = container.querySelector('#autods-log-floater-badge');
        
        let newCount = 0;
        
        header.addEventListener('click', (e) => {
            if (e.target.closest('button')) return;
            toggleFloater();
        });
        
        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFloater();
        });
        
        clearBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            clearLogs();
        });
        
        function toggleFloater() {
            logFloaterState.minimized = !logFloaterState.minimized;
            container.classList.toggle('minimized', logFloaterState.minimized);
            toggleBtn.textContent = logFloaterState.minimized ? '‚ûï' : '‚ûñ';
            if (!logFloaterState.minimized) {
                newCount = 0;
                badge.textContent = '0';
                badge.classList.remove('has-new');
            }
        }
        
        function clearLogs() {
            logFloaterState.logs = [];
            logFloaterState.logList.innerHTML = '';
            newCount = 0;
            badge.textContent = '0';
            badge.classList.remove('has-new');
        }
        
        // Apply initial minimized state from config
        if (config.minimized) {
            logFloaterState.minimized = true;
            container.classList.add('minimized');
            toggleBtn.textContent = '‚ûï';
        }
        
        // Store badge reference for updates
        logFloaterState.badge = badge;
        logFloaterState.updateBadge = () => {
            if (logFloaterState.minimized) {
                newCount++;
                badge.textContent = newCount > 99 ? '99+' : newCount.toString();
                badge.classList.add('has-new');
            }
        };
    }
    
    function addLogToFloater(level, message, config = {}) {
        // Skip if disabled
        if (logFloaterState.enabled === false) return;
        
        if (!logFloaterState.initialized) {
            // Defer creation until DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    createLogFloater(config);
                    addLogToFloater(level, message, config);
                });
                return;
            }
            createLogFloater(config);
        }
        
        // Check if still disabled after init
        if (logFloaterState.enabled === false) return;
        
        // Skip debug logs in floater to reduce noise
        if (level === 'debug') return;
        
        const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        
        // Create log entry
        const entry = document.createElement('div');
        entry.className = `autods-log-entry ${level}`;
        entry.innerHTML = `
            <span class="time">${time}</span>
            <span class="level ${level}">${level}</span>
            <span class="msg">${escapeHtml(message)}</span>
        `;
        
        // Add to list
        logFloaterState.logList.appendChild(entry);
        
        // Keep only maxLogs entries
        while (logFloaterState.logList.children.length > logFloaterState.maxLogs) {
            logFloaterState.logList.removeChild(logFloaterState.logList.firstChild);
        }
        
        // Auto-scroll to bottom
        logFloaterState.logList.scrollTop = logFloaterState.logList.scrollHeight;
        
        // Update badge if minimized
        logFloaterState.updateBadge?.();
    }
    
    function toggleLogFloaterVisibility(enabled) {
        if (logFloaterState.container) {
            logFloaterState.container.style.display = enabled ? 'block' : 'none';
            logFloaterState.enabled = enabled;
        }
    }


    function createLogger(level = 'info', floaterConfig = {}) {
        let currentLevel = level;
        const minIndex = () => LEVELS.indexOf(currentLevel);
        const shouldLog = type => LEVELS.indexOf(type) >= minIndex();

        function log(type, message, metadata) {
            if (!shouldLog(type)) return;
            const stamp = new Date().toISOString();
            const payload = metadata !== undefined ? [message, metadata] : [message];
            const prefix = `[AutoDS][${type.toUpperCase()}][${stamp}]`;
            console[type === 'error' ? 'error' : type === 'warn' ? 'warn' : 'log'](prefix, ...payload);
            
            // Also send to floater (only message, not metadata to keep it clean)
            addLogToFloater(type, message, floaterConfig);
        }

        return {
            debug: (msg, meta) => log('debug', msg, meta),
            info: (msg, meta) => log('info', msg, meta),
            warn: (msg, meta) => log('warn', msg, meta),
            error: (msg, meta) => log('error', msg, meta),
            setLevel: (newLevel) => {
                if (!LEVELS.includes(newLevel)) {
                    console.warn(`Invalid log level: ${newLevel}. Valid levels: ${LEVELS.join(', ')}`);
                    return;
                }
                currentLevel = newLevel;
                console.log(`üìä Log level changed to: ${newLevel}`);
            },
            getLevel: () => currentLevel
        };
    }

    function createDomService(logger) {
        const warnedSelectors = new Set();

        function query(selector, root = document) {
            return root.querySelector(selector);
        }

        function queryAll(selector, root = document) {
            return Array.from(root.querySelectorAll(selector));
        }

        function require(selector, description, root = document) {
            const element = query(selector, root);
            if (!element && !warnedSelectors.has(selector)) {
                warnedSelectors.add(selector);
                logger.warn(`Missing DOM node: ${description} (${selector})`);
            }
            return element;
        }

        function create(tag, options = {}) {
            const el = document.createElement(tag);
            Object.assign(el, options);
            return el;
        }

        return { query, queryAll, require, create };
    }

    function createScheduler(logger) {
        const timers = new Map();

        function track(handle, type) {
            timers.set(handle, type);
            return handle;
        }

        function addInterval(fn, delay, label = 'interval') {
            const wrapped = () => {
                try {
                    fn();
                } catch (error) {
                    logger.error(`Interval "${label}" failed`, error);
                }
            };
            return track(setInterval(wrapped, delay), 'interval');
        }

        function addTimeout(fn, delay, label = 'timeout') {
            const handle = setTimeout(() => {
                timers.delete(handle);
                try {
                    fn();
                } catch (error) {
                    logger.error(`Timeout "${label}" failed`, error);
                }
            }, delay);
            return track(handle, 'timeout');
        }

        function clear(handle) {
            if (!timers.has(handle)) return;
            const type = timers.get(handle);
            if (type === 'interval') {
                clearInterval(handle);
            } else {
                clearTimeout(handle);
            }
            timers.delete(handle);
        }

        function disposeAll() {
            timers.forEach((type, handle) => {
                if (type === 'interval') {
                    clearInterval(handle);
                } else {
                    clearTimeout(handle);
                }
            });
            timers.clear();
        }

        return { 
            addInterval, 
            addTimeout, 
            clear, 
            disposeAll,
            // Aliases for convenience
            repeat: addInterval,
            timeout: addTimeout,
            dispose: disposeAll
        };
    }

    function createEventBus() {
        const target = new EventTarget();
        return {
            on: (type, handler) => target.addEventListener(type, handler),
            off: (type, handler) => target.removeEventListener(type, handler),
            emit: (type, detail) => target.dispatchEvent(new CustomEvent(type, { detail }))
        };
    }

    function deepMerge(target, source) {
        const output = Array.isArray(target) ? [...target] : { ...target };
        if (typeof source !== 'object' || source === null) return output;
        Object.keys(source).forEach(key => {
            const srcVal = source[key];
            if (Array.isArray(srcVal)) {
                output[key] = [...srcVal];
            } else if (typeof srcVal === 'object' && srcVal !== null) {
                output[key] = deepMerge(output[key] || {}, srcVal);
            } else {
                output[key] = srcVal;
            }
        });
        return output;
    }

    function createConfig(storage, events) {
        function importLegacyPvP(config, savedExists) {
            if (typeof window === 'undefined' || !window.localStorage) return false;
            let changed = false;
            try {
                const legacy = window.localStorage;
                const legacyEnabled = legacy.getItem('veyra-pvp-automation');
                if (legacyEnabled !== null && (!savedExists || config.pvp.enabled === DEFAULT_CONFIG.pvp.enabled)) {
                    const boolValue = legacyEnabled === 'true';
                    if (config.pvp.enabled !== boolValue) {
                        config.pvp.enabled = boolValue;
                        changed = true;
                    }
                }

                const legacyMode = legacy.getItem('pvp-automation-mode');
                if (legacyMode && (!savedExists || config.pvp.autoMode === DEFAULT_CONFIG.pvp.autoMode)) {
                    const mappedMode = legacyMode === 'x' ? 'limited' : 'all';
                    if (config.pvp.autoMode !== mappedMode) {
                        config.pvp.autoMode = mappedMode;
                        changed = true;
                    }
                }

                const legacyCount = parseInt(legacy.getItem('pvp-automation-x-count'), 10);
                if (!Number.isNaN(legacyCount) && (!savedExists || config.pvp.limitedBattles === DEFAULT_CONFIG.pvp.limitedBattles)) {
                    if (config.pvp.limitedBattles !== legacyCount) {
                        config.pvp.limitedBattles = legacyCount;
                        changed = true;
                    }
                }

                const legacySurrender = legacy.getItem('pvp-auto-surrend');
                if (legacySurrender !== null && (!savedExists || config.pvp.autoSurrender === DEFAULT_CONFIG.pvp.autoSurrender)) {
                    const boolValue = legacySurrender === 'true';
                    if (config.pvp.autoSurrender !== boolValue) {
                        config.pvp.autoSurrender = boolValue;
                        changed = true;
                    }
                }
            } catch (error) {
                console.warn('[AutoDS][config] Legacy PvP import failed', error);
            }
            return changed;
        }

        function syncLegacyPvP(config) {
            if (typeof window === 'undefined' || !window.localStorage) return;
            try {
                const legacy = window.localStorage;
                legacy.setItem('veyra-pvp-automation', Boolean(config.pvp.enabled).toString());
                legacy.setItem('pvp-auto-surrend', Boolean(config.pvp.autoSurrender).toString());
                const legacyMode = config.pvp.autoMode === 'limited' ? 'x' : 'all';
                legacy.setItem('pvp-automation-mode', legacyMode);
                legacy.setItem('pvp-automation-x-count', String(config.pvp.limitedBattles ?? DEFAULT_CONFIG.pvp.limitedBattles));
                if (config.pvp.autoMode === 'limited') {
                    legacy.setItem('pvp-automation-x-remaining', String(Math.max(0, config.pvp.limitedBattles ?? 0)));
                }
            } catch (error) {
                console.warn('[AutoDS][config] Legacy PvP sync failed', error);
            }
        }

        function load() {
            const saved = storage.get('config', null);
            let config = deepMerge({}, DEFAULT_CONFIG);
            if (saved) {
                config = deepMerge(config, saved);
            }
            const pvpChanged = importLegacyPvP(config, Boolean(saved));
            if (!saved && pvpChanged) {
                storage.set('config', config);
            }
            syncLegacyPvP(config);
            return config;
        }

        let cache = load();

        function save(newConfig) {
            cache = deepMerge({}, newConfig);
            storage.set('config', cache);
            syncLegacyPvP(cache);
            events?.emit('autods:config:updated', { config: get() });
        }

        function get() {
            return deepMerge({}, cache);
        }

        function update(patch) {
            const merged = deepMerge(cache, patch);
            save(merged);
            return merged;
        }

        return { get, save, update };
    }

    // ==================== INVENTORY SERVICE ====================
    // Centralized inventory management and item usage
    // Eliminates ~200 lines of duplicated code
    
    /**
     * Create centralized inventory service
     * Manages item usage and inventory data fetching
     * 
     * @param {Object} context - Script context (logger, config, etc.)
     * @returns {Object} Inventory service
     * @returns {function(): Promise<Object>} fetchInventoryData - Fetch all inventory data from /inventory.php
     * @returns {function(): Promise<boolean>} useFullStaminaPotion - Use 1 Full Stamina Potion (item 35)
     * @returns {function(number): Promise<boolean>} useSmallStaminaPotion - Use N Small Stamina Potions (item 30)
     * @returns {function(): Promise<boolean>} useExpPotion - Use 1 EXP Potion (item 97)
     * @returns {function(number): Promise<boolean>} useHealPotion - Use N Heal Potions (item 50)
     * 
     * @example
     * const inv = context.inventory;
     * const data = await inv.fetchInventoryData();
     * // { small: { invId: 123, quantity: 50, itemId: 30 }, full: {...}, ... }
     * 
     * const success = await inv.useFullStaminaPotion();
     * if (success) console.log('FSP used!');
     * 
     * await inv.useSmallStaminaPotion(3); // Use 3 SSP
     */
    function createInventoryService(context) {
        const { logger } = context;
        
        const ITEM_IDS = {
            SMALL_STAMINA_POTION: 30,
            FULL_STAMINA_POTION: 35,
            EXP_POTION: 97,
            HEAL_POTION: 50
        };
        
        async function fetchInventoryData() {
            try {
                const response = await fetch('https://demonicscans.org/inventory.php', {
                    credentials: 'include'
                });
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                const inventory = {};
                const buttons = doc.querySelectorAll('button[onclick*="useItem"]');
                
                buttons.forEach(btn => {
                    const onclick = btn.getAttribute('onclick') || '';
                    const match = onclick.match(/useItem\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*['"]([^'"]+)['"]\s*,\s*(\d+)\s*\)/);
                    
                    if (match) {
                        const [, invId, itemId, itemName, quantity] = match;
                        const itemIdNum = parseInt(itemId, 10);
                        
                        if (itemIdNum === ITEM_IDS.SMALL_STAMINA_POTION) {
                            inventory.small = { invId, quantity: parseInt(quantity, 10), itemId: itemIdNum };
                        } else if (itemIdNum === ITEM_IDS.FULL_STAMINA_POTION) {
                            inventory.full = { invId, quantity: parseInt(quantity, 10), itemId: itemIdNum };
                        } else if (itemIdNum === ITEM_IDS.EXP_POTION) {
                            inventory.exp = { invId, quantity: parseInt(quantity, 10), itemId: itemIdNum };
                        } else if (itemIdNum === ITEM_IDS.HEAL_POTION) {
                            inventory.heal = { invId, quantity: parseInt(quantity, 10), itemId: itemIdNum };
                        }
                    }
                });
                
                return inventory;
            } catch (error) {
                logger.error('Failed to fetch inventory:', error);
                return {};
            }
        }
        
        async function useItem(invId, itemName) {
            try {
                logger.info(`üíä Usando ${itemName}...`);
                
                const response = await fetch('https://demonicscans.org/use_item.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    credentials: 'include',
                    body: `inv_id=${invId}`
                });
                
                const text = await response.text();
                const lower = text.trim().toLowerCase();
                const success = lower.includes('success') || lower.includes('used');
                
                if (success) {
                    logger.info(`‚úÖ ${itemName} usado com sucesso!`);
                } else {
                    logger.warn(`‚ö†Ô∏è Falha ao usar ${itemName}: ${text.substring(0, 100)}`);
                }
                
                return success;
            } catch (error) {
                logger.error(`‚ùå Erro ao usar ${itemName}:`, error);
                return false;
            }
        }
        
        return {
            fetchInventoryData,
            
            async useFullStaminaPotion() {
                const inv = await fetchInventoryData();
                const fsp = inv.full;
                
                if (!fsp || !fsp.invId || !fsp.quantity || fsp.quantity < 1) {
                    logger.warn('üíä Sem Full Stamina Potion dispon√≠vel');
                    return false;
                }
                
                logger.info(`üíä FSP dispon√≠vel: ${fsp.quantity}x (inv_id: ${fsp.invId})`);
                return useItem(fsp.invId, 'Full Stamina Potion');
            },
            
            async useSmallStaminaPotion(quantity = 1) {
                const inv = await fetchInventoryData();
                const ssp = inv.small;
                
                if (!ssp || !ssp.invId || !ssp.quantity || ssp.quantity < quantity) {
                    logger.warn(`üíä Sem Small Stamina Potion dispon√≠vel (precisa: ${quantity}, tem: ${ssp?.quantity || 0})`);
                    return false;
                }
                
                logger.info(`üíä SSP dispon√≠vel: ${ssp.quantity}x - usando ${quantity}x`);
                const results = await Promise.all(
                    Array.from({ length: quantity }, () => useItem(ssp.invId, 'Small Stamina Potion'))
                );
                
                return results.every(r => r);
            },
            
            async useExpPotion() {
                const inv = await fetchInventoryData();
                const exp = inv.exp;
                
                if (!exp || !exp.invId || !exp.quantity || exp.quantity < 1) {
                    logger.warn('üíä Sem EXP Potion dispon√≠vel');
                    return false;
                }
                
                logger.info(`üíä EXP Potion dispon√≠vel: ${exp.quantity}x`);
                return useItem(exp.invId, 'EXP Potion');
            },
            
            async useHealPotion() {
                const inv = await fetchInventoryData();
                const heal = inv.heal;
                
                if (!heal || !heal.invId || !heal.quantity || heal.quantity < 1) {
                    logger.warn('üíä Sem Heal Potion dispon√≠vel');
                    return false;
                }
                
                logger.info(`üíä Heal Potion dispon√≠vel: ${heal.quantity}x`);
                return useItem(heal.invId, 'Heal Potion');
            }
        };
    }

    // ==================== MERCHANT SERVICE ====================
    // Automated merchant purchases with weekly renewal and gold management
    
    /**
     * Create Merchant Auto-Buy service
     * Handles weekly automated purchases from merchant
     * 
     * @param {Object} context - Script context
     * @returns {Object} Merchant service
     */
    function createMerchantService(context) {
        const { logger, http, config, notifications, numbers, storage } = context;
        
        const MERCHANT_PRIORITIES = [
            { name: 'Small Stamina Potion', price: 50, priority: 1, checkPrice: true },
            { name: 'Arcane Treat S', priority: 2 },
            { name: 'Any Egg', priority: 3, oneTimeBuy: true, pattern: /Egg$/i },
            { name: 'Arcane Treat M', priority: 4 },
            { name: 'Full Stamina Potion', price: 1000, priority: 5, minGold: 10000000 }
        ];
        
        return {
            /**
             * Get current gold from page
             */
            getCurrentGold() {
                // Try merchant page goldBalance element first
                const goldBalanceEl = context.dom.query('#goldBalance');
                if (goldBalanceEl) {
                    const goldText = goldBalanceEl.textContent.trim();
                    logger.debug(`Gold text from #goldBalance: "${goldText}"`);
                    const parsed = numbers.parse(goldText);
                    logger.debug(`Parsed gold: ${parsed}`);
                    return parsed;
                }
                
                // Fallback: try generic selectors
                const goldText = context.dom.query('.gold-display, .gold-count, [class*="gold"]')?.textContent;
                if (goldText) {
                    return numbers.parse(goldText);
                }
                
                // Try to get from stats header
                const statsText = document.body.textContent;
                const goldMatch = statsText.match(/ü™ô\s*([\d,]+)/);
                if (goldMatch) {
                    return numbers.parse(goldMatch[1]);
                }
                
                logger.warn('Could not find gold amount on page');
                return 0;
            },
            
            /**
             * Check if week has passed since last purchase
             */
            shouldPerformWeeklyPurchase() {
                const lastPurchase = storage.get('merchant.lastWeeklyPurchase', 0);
                const now = Date.now();
                const weekInMs = 7 * 24 * 60 * 60 * 1000;
                const timeSince = now - lastPurchase;
                return timeSince >= weekInMs;
            },
            
            /**
             * Scan merchant page for available items
             */
            async scanMerchantItems() {
                try {
                    const result = await http.get('/merchant.php', { parseJson: false });
                    if (!result.success) {
                        logger.error('Failed to fetch merchant page:', result.message);
                        return [];
                    }
                    
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(result.data, 'text/html');
                    const items = [];
                    
                    // Parse merchant items from page - real structure
                    const itemCards = doc.querySelectorAll('.card[data-merch-id]');
                    logger.debug(`Found ${itemCards.length} card elements`);
                    
                    itemCards.forEach(card => {
                        const merchId = card.getAttribute('data-merch-id');
                        const price = parseInt(card.getAttribute('data-price'), 10) || 0;
                        const currency = card.getAttribute('data-currency');
                        const maxQuantity = parseInt(card.getAttribute('data-maxq'), 10) || 0;
                        const bought = parseInt(card.getAttribute('data-bought'), 10) || 0;
                        const remaining = maxQuantity - bought;
                        
                        const nameEl = card.querySelector('.name');
                        const name = nameEl ? nameEl.textContent.trim() : '';
                        
                        // Check if buy button is disabled
                        const buyBtn = card.querySelector('.buy-btn');
                        const disabled = buyBtn ? buyBtn.hasAttribute('disabled') : true;
                        
                        logger.debug(`Scanning: ${name}, currency="${currency}", price=${price}, remaining=${remaining}, disabled=${disabled}`);
                        
                        if (merchId && name && !disabled && remaining > 0) {
                            items.push({ 
                                name, 
                                price, 
                                merchId, 
                                remaining,
                                currency,
                                maxQuantity,
                                bought
                            });
                            logger.debug(`‚úì Added: ${name}, price: ${price} ${currency}, remaining: ${remaining}`);
                        } else if (merchId && name) {
                            logger.debug(`‚úó Skipped ${name}: disabled=${disabled}, remaining=${remaining}`);
                        }
                    });
                    
                    logger.info(`Found ${items.length} available merchant items`);
                    return items;
                } catch (error) {
                    logger.error('Error scanning merchant items:', error);
                    return [];
                }
            },
            
            /**
             * Purchase specific item
             */
            async buyItem(merchId, quantity = 1) {
                try {
                    logger.info(`Attempting to buy item (merch_id: ${merchId}, qty: ${quantity})`);
                    
                    const result = await http.post('/merchant_buy.php', `merch_id=${merchId}&qty=${quantity}`);
                    
                    if (result.success && result.data) {
                        const data = result.data;
                        
                        // Check if purchase was successful
                        if (data.status === 'success') {
                            logger.info(`‚úÖ Purchase completed! Remaining: ${data.remaining}`);
                            logger.info(`üí∞ Gold: ${data.gold}, üíé Gems: ${data.gems}`);
                            return { 
                                success: true, 
                                message: data.message,
                                remaining: data.remaining,
                                gold: data.gold,
                                gems: data.gems,
                                currency: data.currency
                            };
                        } else {
                            logger.warn(`Purchase failed: ${data.message || 'Unknown error'}`);
                            return { success: false, message: data.message || 'Purchase failed' };
                        }
                    }
                    
                    logger.warn('Purchase response invalid:', result);
                    return { success: false, message: result.message || 'Invalid response' };
                } catch (error) {
                    logger.error('Error buying item:', error);
                    return { success: false, message: error.message };
                }
            },
            
            /**
             * Perform weekly automated purchases
             */
            async performWeeklyPurchases() {
                if (!this.shouldPerformWeeklyPurchase()) {
                    const lastPurchase = storage.get('merchant.lastWeeklyPurchase', 0);
                    const nextPurchase = lastPurchase + (7 * 24 * 60 * 60 * 1000);
                    const timeLeft = nextPurchase - Date.now();
                    const hoursLeft = Math.ceil(timeLeft / (60 * 60 * 1000));
                    
                    logger.info(`‚è∞ Weekly purchase already done. Next in ${hoursLeft} hours`);
                    return { success: false, message: `Already purchased this week. Next in ${hoursLeft}h` };
                }
                
                logger.info('üõí Starting weekly merchant purchases...');
                notifications?.info('Starting merchant auto-buy');
                
                // Get current gold
                const currentGold = this.getCurrentGold();
                logger.info(`üí∞ Current gold: ${numbers.format(currentGold)}`);
                
                // Scan available items
                const items = await this.scanMerchantItems();
                if (items.length === 0) {
                    logger.warn('No merchant items found');
                    return { success: false, message: 'No items found' };
                }
                
                // Get previously bought eggs (one-time items)
                const boughtEggs = storage.get('merchant.boughtEggs', []);
                
                const results = [];
                let totalSpent = 0;
                let insufficientGold = false;
                
                // Sort by priority
                const sortedPriorities = [...MERCHANT_PRIORITIES].sort((a, b) => a.priority - b.priority);
                
                for (const priority of sortedPriorities) {
                    // Check if we have minimum gold required
                    if (priority.minGold && currentGold < priority.minGold) {
                        logger.info(`‚è© Skipping ${priority.name} (requires ${numbers.format(priority.minGold)} gold)`);
                        continue;
                    }
                    
                    // Find matching item
                    let matchingItem = null;
                    if (priority.pattern) {
                        matchingItem = items.find(item => priority.pattern.test(item.name));
                    } else {
                        matchingItem = items.find(item => item.name === priority.name);
                    }
                    
                    if (!matchingItem) {
                        logger.debug(`Item not found: ${priority.name}`);
                        continue;
                    }
                    
                    // **CRITICAL: NEVER buy with gems**
                    if (matchingItem.currency !== 'gold') {
                        logger.warn(`‚ùå SKIPPING ${matchingItem.name} - currency is ${matchingItem.currency} (ONLY BUY WITH GOLD!)`);
                        continue;
                    }
                    
                    // Check if it's a one-time buy and already bought
                    if (priority.oneTimeBuy) {
                        if (boughtEggs.includes(matchingItem.name)) {
                            logger.info(`‚è© Already bought: ${matchingItem.name} (one-time item)`);
                            continue;
                        }
                    }
                    
                    // Verify price if needed (avoid gems)
                    if (priority.checkPrice && matchingItem.price !== priority.price) {
                        logger.warn(`‚ö†Ô∏è Price mismatch for ${priority.name}: expected ${priority.price}g, found ${matchingItem.price}`);
                        logger.warn('‚ùå SKIPPING - might be wrong item!');
                        continue;
                    }
                    
                    // Check if we have enough gold
                    const goldNeeded = matchingItem.price * matchingItem.remaining;
                    if ((currentGold - totalSpent) < goldNeeded) {
                        logger.warn(`‚ö†Ô∏è Insufficient gold for ${matchingItem.name} (need ${numbers.format(goldNeeded)}, have ${numbers.format(currentGold - totalSpent)})`);
                        insufficientGold = true;
                        results.push({
                            item: matchingItem.name,
                            success: false,
                            message: 'Insufficient gold'
                        });
                        continue;
                    }
                    
                    // Purchase the item
                    logger.info(`üõí Buying ${matchingItem.name} x${matchingItem.remaining} (${numbers.format(goldNeeded)} gold)`);
                    const purchaseResult = await this.buyItem(matchingItem.merchId, matchingItem.remaining);
                    
                    if (purchaseResult.success) {
                        totalSpent += goldNeeded;
                        
                        // Track one-time purchases
                        if (priority.oneTimeBuy) {
                            boughtEggs.push(matchingItem.name);
                            storage.set('merchant.boughtEggs', boughtEggs);
                        }
                        
                        notifications?.success(`Bought ${matchingItem.name} x${matchingItem.remaining}`);
                    }
                    
                    results.push({
                        item: matchingItem.name,
                        success: purchaseResult.success,
                        message: purchaseResult.message,
                        spent: goldNeeded
                    });
                    
                    // Small delay between purchases
                    await sleep(500);
                }
                
                // Helper to get next Monday at 00:00
                const getNextMonday = () => {
                    const now = new Date();
                    const dayOfWeek = now.getDay(); // 0=Sunday, 1=Monday, 2=Tuesday, etc.
                    const daysUntilMonday = dayOfWeek === 0 ? 1 : (8 - dayOfWeek) % 7 || 7;
                    
                    const nextMonday = new Date(now);
                    nextMonday.setDate(now.getDate() + daysUntilMonday);
                    nextMonday.setHours(0, 0, 0, 0);
                    
                    return nextMonday.getTime();
                };
                
                // Update last purchase timestamp based on results
                const successCount = results.filter(r => r.success).length;
                const skippedCount = results.filter(r => !r.success && r.message !== 'Insufficient gold').length;
                
                if (successCount > 0) {
                    // Purchases were made successfully - schedule for next Monday
                    const nextMonday = getNextMonday();
                    storage.set('merchant.lastWeeklyPurchase', nextMonday - 7 * 24 * 60 * 60 * 1000); // Set as if purchased Monday last week
                    logger.info(`‚úÖ Weekly purchases complete: ${successCount}/${results.length} items bought`);
                    logger.info(`üí∞ Total spent: ${numbers.format(totalSpent)} gold`);
                    const daysUntilMonday = Math.ceil((nextMonday - Date.now()) / (24 * 60 * 60 * 1000));
                    logger.info(`‚è∞ Next merchant check scheduled for Monday in ${daysUntilMonday} days`);
                    notifications?.success(`Merchant: ${successCount} items bought! Next check on Monday`);
                } else if (insufficientGold) {
                    // Not enough gold - retry in 1 hour
                    storage.set('merchant.nextRetryTime', Date.now() + config.get().merchantAutoBuy.retryAfterInsufficientGold);
                    logger.warn('‚è∞ Insufficient gold. Will retry in 1 hour');
                    notifications?.warn('Merchant: Not enough gold, will retry in 1h');
                } else if (results.length === 0 || skippedCount === results.length) {
                    // No items available to purchase (all already bought or not in priority list)
                    // Schedule next check for next Monday (shop reset)
                    const nextMonday = getNextMonday();
                    storage.set('merchant.lastWeeklyPurchase', nextMonday - 7 * 24 * 60 * 60 * 1000); // Set as if purchased Monday last week
                    const daysUntilMonday = Math.ceil((nextMonday - Date.now()) / (24 * 60 * 60 * 1000));
                    logger.info('‚ÑπÔ∏è No items available for purchase (shop already cleared or items not in priority list)');
                    logger.info(`‚è∞ Next merchant check scheduled for Monday in ${daysUntilMonday} days`);
                    notifications?.info(`Merchant: Shop cleared, next check on Monday (in ${daysUntilMonday} days)`);
                } else {
                    logger.warn('‚ùå No purchases were successful');
                }
                
                return { success: true, results, totalSpent, insufficientGold };
            },
            
            /**
             * Check and notify if week is approaching
             */
            checkWeeklyRenewal() {
                const lastPurchase = storage.get('merchant.lastWeeklyPurchase', 0);
                
                // If never purchased before, don't show misleading negative hours
                if (lastPurchase === 0) {
                    logger.debug('‚è∞ No previous purchase - will purchase on next check');
                    return;
                }
                
                const now = Date.now();
                const nextPurchase = lastPurchase + (7 * 24 * 60 * 60 * 1000);
                const timeLeft = nextPurchase - now;
                const hoursLeft = Math.ceil(timeLeft / (60 * 60 * 1000));
                
                if (hoursLeft <= 24 && hoursLeft > 0) {
                    logger.info(`‚è∞ Merchant renewal in ${hoursLeft} hours`);
                    if (config.get().merchantAutoBuy?.autoNotify) {
                        notifications?.info(`Merchant renewal in ${hoursLeft}h`);
                    }
                } else if (hoursLeft > 24) {
                    const daysLeft = Math.floor(hoursLeft / 24);
                    logger.debug(`‚è∞ Next merchant purchase in ${daysLeft}d ${hoursLeft % 24}h`);
                } else {
                    logger.debug('‚è∞ Merchant purchase is overdue');
                }
            },
            
            /**
             * Check if it's time to retry after insufficient gold
             */
            shouldRetryAfterInsufficientGold() {
                const nextRetry = storage.get('merchant.nextRetryTime', 0);
                if (nextRetry === 0) return false;
                
                const now = Date.now();
                if (now >= nextRetry) {
                    // Clear retry timestamp
                    storage.set('merchant.nextRetryTime', 0);
                    return true;
                }
                return false;
            }
        };
    }

    // ==================== HTTP SERVICE ====================
    // Centralized HTTP request handling (fetch and GM_xmlhttpRequest)
    // Eliminates boilerplate and provides consistent error handling
    
    /**
     * Create centralized HTTP service
     * Provides unified API for HTTP requests with automatic error detection
     * 
     * ‚≠ê STRATEGY: Uses fetch API first (less Cloudflare-sensitive) with GM_xmlhttpRequest as fallback
     * Supports both fetch (native, preferred) and GM_xmlhttpRequest (CORS bypass, fallback)
     * 
     * @param {Object} context - Script context (logger, config, etc.)
     * @returns {Object} HTTP service
     * 
     * Primary methods (use fetch, Cloudflare-proof):
     * @returns {function(string, Object): Promise<Object>} get - GET request via fetch (preferred)
     * @returns {function(string, string, Object): Promise<Object>} post - POST request via fetch (preferred)
     * @returns {function(string, Object): Promise<Object>} fetchGet - GET request via fetch (explicit)
     * @returns {function(string, string, Object): Promise<Object>} fetchPost - POST request via fetch (explicit)
     * 
     * Fallback methods (use GM_xmlhttpRequest if fetch fails):
     * @returns {function(string, Object): Promise<Object>} gmGet - GET request via GM (fallback)
     * @returns {function(string, string, Object): Promise<Object>} gmPost - POST request via GM (fallback)
     * 
     * Game-specific endpoints:
     * @returns {function(string, string): Promise<Object>} joinBattle - Join wave battle (wave monster)
     * @returns {function(string, string): Promise<Object>} joinDungeonBattle - Join dungeon battle (dgmid + instance_id)
     * @returns {function(string, string): Promise<Object>} lootMonster - Loot wave monster
     * @returns {function(string, string, string): Promise<Object>} lootGuildDungeon - Loot guild dungeon monster
     * @returns {function(string): Promise<Object>} useItem - Use inventory item (inv_id)
     * @returns {function(): Promise<Object>} getInventory - Fetch inventory page HTML
     * 
     * @example
     * const http = context.http;
     * 
     * // Join dungeon battle (uses fetch first)
     * const result = await http.joinDungeonBattle('386752', '1522');
     * if (result.success) console.log('Joined!');
     * 
     * // Loot monster (uses fetch first)
     * await http.lootMonster('123456', userId);
     * 
     * // Custom request
     * const data = await http.post('/custom_endpoint.php', 'param=value');
     */
    function createHttpService(context) {
        const { logger } = context;
        
        const BASE_URL = 'https://demonicscans.org';
        
        /**
         * Make HTTP request using GM_xmlhttpRequest (bypasses CORS)
         * @param {Object} options - Request options
         * @returns {Promise<Object>} Response object with success, data, message
         */
        function gmRequest(options) {
            const {
                method = 'GET',
                url,
                headers = {},
                body = null,
                parseJson = true,
                timeout = 10000
            } = options;
            
            const fullUrl = url.startsWith('http') ? url : `${BASE_URL}${url}`;
            
            const defaultHeaders = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Referer': window.location.href,
                ...headers
            };
            
            return new Promise((resolve) => {
                logger.debug(`[HTTP] ${method} ${fullUrl}`);
                
                GM_xmlhttpRequest({
                    method,
                    url: fullUrl,
                    headers: defaultHeaders,
                    data: body,
                    timeout,
                    onload: (response) => {
                        const text = response.responseText || '';
                        
                        // Detect Cloudflare/403/500 errors
                        const isCloudflareBlock = text.includes('Cloudflare') || text.includes('cf-') || text.includes('Just a moment');
                        const is403Forbidden = response.status === 403;
                        const is500Error = response.status >= 500;
                        
                        if (isCloudflareBlock || is403Forbidden || is500Error) {
                            const reason = isCloudflareBlock ? 'Cloudflare protection' : `HTTP ${response.status}`;
                            logger.warn(`[HTTP] Request blocked: ${reason}`);
                            resolve({
                                success: false,
                                message: `Blocked by ${reason}`,
                                cloudflareBlock: isCloudflareBlock,
                                status: response.status,
                                raw: text
                            });
                            return;
                        }
                        
                        // Parse response
                        if (parseJson) {
                            try {
                                const data = JSON.parse(text);
                                resolve({
                                    success: true,
                                    data,
                                    status: response.status,
                                    message: data.message || ''
                                });
                            } catch (e) {
                                // Assume success if 2xx status
                                if (response.status >= 200 && response.status < 300) {
                                    resolve({
                                        success: true,
                                        data: null,
                                        raw: text,
                                        status: response.status,
                                        message: 'Request succeeded (non-JSON)'
                                    });
                                } else {
                                    logger.error('[HTTP] JSON parse error:', e);
                                    resolve({
                                        success: false,
                                        error: 'JSON parse error',
                                        raw: text,
                                        status: response.status
                                    });
                                }
                            }
                        } else {
                            resolve({
                                success: response.status >= 200 && response.status < 300,
                                data: text,
                                raw: text,
                                status: response.status
                            });
                        }
                    },
                    onerror: (error) => {
                        logger.error('[HTTP] Request error:', error);
                        resolve({
                            success: false,
                            error: 'Network error',
                            message: 'Network error occurred'
                        });
                    },
                    ontimeout: () => {
                        logger.warn('[HTTP] Request timeout');
                        resolve({
                            success: false,
                            error: 'Timeout',
                            message: 'Request timed out'
                        });
                    }
                });
            });
        }
        
        /**
         * Make HTTP request using fetch API
         * @param {Object} options - Request options
         * @returns {Promise<Object>} Response object
         */
        async function fetchRequest(options) {
            const {
                method = 'GET',
                url,
                headers = {},
                body = null,
                parseJson = true,
                timeout = 10000
            } = options;
            
            const fullUrl = url.startsWith('http') ? url : `${BASE_URL}${url}`;
            
            const defaultHeaders = {
                'User-Agent': navigator.userAgent,
                'Accept': '*/*',
                'Accept-Language': 'pt-BR,pt;q=0.8,en-US;q=0.5,en;q=0.3',
                'Content-Type': 'application/x-www-form-urlencoded',
                'Sec-GPC': '1',
                'Sec-Fetch-Dest': 'empty',
                'Sec-Fetch-Mode': 'cors',
                'Sec-Fetch-Site': 'same-origin',
                'Priority': 'u=0',
                ...headers
            };
            
            try {
                logger.debug(`[HTTP] ${method} ${fullUrl}`);
                if (body) {
                    logger.debug(`[HTTP] Body: ${body.substring ? body.substring(0, 100) : JSON.stringify(body)}`);
                }
                
                const response = await fetch(fullUrl, {
                    method,
                    headers: defaultHeaders,
                    credentials: 'include',
                    body,
                    signal: AbortSignal.timeout(timeout)
                });
                
                if (!response.ok) {
                    logger.warn(`[HTTP] Response not OK: ${response.status} ${response.statusText}`);
                    const errorText = await response.text();
                    logger.warn(`[HTTP] Error response body: ${errorText.substring(0, 200)}`);
                    return {
                        success: false,
                        status: response.status,
                        message: `HTTP ${response.status}: ${response.statusText}`,
                        errorBody: errorText
                    };
                }
                
                const text = await response.text();
                
                if (parseJson) {
                    try {
                        const data = JSON.parse(text);
                        
                        // Check if server returned an error status (e.g., status: "error")
                        const serverSuccess = data.status === 'success' || data.success === true || !data.status;
                        
                        return {
                            success: serverSuccess,
                            data,
                            status: response.status,
                            message: data.message || '',
                            serverStatus: data.status // Original server status field
                        };
                    } catch (e) {
                        logger.error('[HTTP] JSON parse error:', e);
                        return {
                            success: false,
                            error: 'JSON parse error',
                            raw: text,
                            status: response.status
                        };
                    }
                } else {
                    // Plain text response - check for success indicators
                    const lowerText = text.trim().toLowerCase();
                    const isSuccess = lowerText.startsWith('you have successfully') || 
                                     lowerText.includes('joined') ||
                                     lowerText.includes('success');
                    
                    return {
                        success: isSuccess,
                        data: text,
                        raw: text,
                        message: text.trim(),
                        status: response.status
                    };
                }
            } catch (error) {
                logger.error('[HTTP] Fetch error:', error);
                return {
                    success: false,
                    error: error.message,
                    message: error.message
                };
            }
        }
        
        return {
            /**
             * GET request using fetch API (preferred)
             */
            get(url, options = {}) {
                return fetchRequest({ method: 'GET', url, ...options });
            },
            
            /**
             * POST request using fetch API (preferred)
             */
            post(url, body, options = {}) {
                logger.debug(`[HTTP.post] Called with url=${url}, body=${body ? 'present' : 'MISSING'}`);
                if (body && typeof body === 'string') {
                    logger.debug(`[HTTP.post] Body content: ${body.substring(0, 150)}`);
                }
                return fetchRequest({ method: 'POST', url, body, ...options });
            },
            
            /**
             * GET request using fetch API (explicit)
             */
            fetchGet(url, options = {}) {
                return fetchRequest({ method: 'GET', url, ...options });
            },
            
            /**
             * POST request using fetch API (explicit)
             */
            fetchPost(url, body, options = {}) {
                return fetchRequest({ method: 'POST', url, body, ...options });
            },
            
            /**
             * GET request using GM_xmlhttpRequest (fallback only)
             */
            gmGet(url, options = {}) {
                return gmRequest({ method: 'GET', url, ...options });
            },
            
            /**
             * POST request using GM_xmlhttpRequest (fallback only)
             */
            gmPost(url, body, options = {}) {
                return gmRequest({ method: 'POST', url, body, ...options });
            },
            
            // ========== Game-specific endpoints ==========
            
            /**
             * Join battle directly
             * Returns plain text response: "You have successfully joined the battle."
             */
            async joinBattle(monsterId, userId) {
                if (!monsterId) {
                    logger.error(`‚ùå joinBattle called with invalid monsterId: ${monsterId}`);
                    return { error: 'Invalid monsterId', status: 400 };
                }
                if (!userId) {
                    logger.error(`‚ùå joinBattle called with invalid userId: ${userId}`);
                    return { error: 'Invalid userId', status: 400 };
                }
                
                const body = `monster_id=${monsterId}&user_id=${userId}`;
                logger.debug(`üì§ Sending JOIN request - monster_id=${monsterId}, user_id=${userId}`);
                
                return this.post('/user_join_battle.php', body, {
                    headers: {
                        'Referer': `${BASE_URL}/active_wave.php`,
                        'Sec-GPC': '1',
                        'Alt-Used': 'demonicscans.org',
                        'Sec-Fetch-Dest': 'empty',
                        'Sec-Fetch-Mode': 'cors',
                        'Sec-Fetch-Site': 'same-origin',
                        'Priority': 'u=0'
                    },
                    parseJson: false  // Plain text response, not JSON
                });
            },
            
            /**
             * Join dungeon battle
             * Uses dungeon_join_battle.php endpoint (NOT user_join_battle.php)
             * Returns plain text response: "You have successfully joined..."
             */
            async joinDungeonBattle(dgmid, instanceId) {
                const body = `dgmid=${dgmid}&instance_id=${instanceId}`;
                return this.post('/dungeon_join_battle.php', body, {
                    headers: {
                        'Referer': `${BASE_URL}/guild_dungeon_location.php`,
                        'Sec-GPC': '1',
                        'Alt-Used': 'demonicscans.org',
                        'Sec-Fetch-Dest': 'empty',
                        'Sec-Fetch-Mode': 'cors',
                        'Sec-Fetch-Site': 'same-origin',
                        'Priority': 'u=0'
                    },
                    parseJson: false  // Plain text response, not JSON
                });
            },
            
            /**
             * Loot monster rewards
             */
            async lootMonster(monsterId, userId) {
                const body = `monster_id=${monsterId}&user_id=${userId}`;
                return this.post('/loot.php', body, {
                    headers: {
                        'Referer': `${BASE_URL}/battle.php?id=${monsterId}`
                    }
                });
            },
            
            /**
             * Loot guild dungeon monster
             */
            async lootGuildDungeon(dgmid, instanceId, userId) {
                const body = `instance_id=${encodeURIComponent(instanceId)}&dgmid=${encodeURIComponent(dgmid)}&user_id=${encodeURIComponent(userId)}`;
                return this.post('/dungeon_loot.php', body, {
                    headers: {
                        'Referer': `${BASE_URL}/battle.php?dgmid=${dgmid}&instance_id=${instanceId}`
                    }
                });
            },
            
            /**
             * Use item from inventory
             */
            async useItem(invId) {
                const body = `inv_id=${invId}`;
                return this.fetchPost('/use_item.php', body, {
                    parseJson: false
                });
            },
            
            /**
             * Fetch inventory data
             */
            async getInventory() {
                return this.fetchGet('/inventory.php', {
                    parseJson: false
                });
            },
            
            // ========== OPTIMIZED FETCH METHODS (Cloudflare-proof) ==========
            // These methods use direct fetch with correct headers/referrer to bypass Cloudflare
            
            /**
             * Generic optimized fetch with Cloudflare-proof headers
             * @param {string} endpoint - Endpoint path or full URL
             * @param {Object} options - Request options
             * @returns {Promise<Object>} Response object
             */
            async fetchDirect(endpoint, { body, referrer, parseJson = true, method = 'POST', customHeaders = null } = {}) {
                const url = endpoint.startsWith('http') ? endpoint : `${BASE_URL}${endpoint}`;
                
                try {
                    logger.debug(`[HTTP:Direct] ${method} ${endpoint}`);
                    
                    // Default headers
                    const headers = {
                        'User-Agent': navigator.userAgent,
                        'Accept': '*/*',
                        'Accept-Language': 'pt-BR,pt;q=0.8,en-US;q=0.5,en;q=0.3',
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Sec-Fetch-Dest': 'empty',
                        'Sec-Fetch-Mode': 'cors',
                        'Sec-Fetch-Site': 'same-origin'
                    };
                    
                    // Merge custom headers if provided
                    if (customHeaders) {
                        Object.assign(headers, customHeaders);
                    }
                    
                    const response = await fetch(url, {
                        credentials: 'include',
                        headers,
                        referrer: referrer || window.location.href,
                        body,
                        method,
                        mode: 'cors'
                    });
                    
                    const text = await response.text();
                    
                    if (parseJson) {
                        try {
                            const data = JSON.parse(text);
                            const serverSuccess = data.status === 'success' || data.success === true;
                            
                            return {
                                success: serverSuccess,
                                data,
                                status: response.status,
                                message: data.message || '',
                                raw: text
                            };
                        } catch (e) {
                            logger.error('[HTTP:Direct] JSON parse error:', e);
                            return {
                                success: false,
                                error: 'JSON parse error',
                                raw: text,
                                status: response.status
                            };
                        }
                    } else {
                        // Plain text response
                        const lowerText = text.trim().toLowerCase();
                        const isSuccess = lowerText.includes('success') || 
                                         lowerText.includes('joined') ||
                                         lowerText.includes('you have') ||
                                         lowerText === 'updated' ||
                                         lowerText === 'added';
                        
                        return {
                            success: isSuccess,
                            data: text,
                            raw: text,
                            message: text.trim(),
                            status: response.status
                        };
                    }
                } catch (error) {
                    logger.error('[HTTP:Direct] Fetch error:', error);
                    return {
                        success: false,
                        error: error.message,
                        message: error.message
                    };
                }
            },
            
            /**
             * Attack monster using optimized fetch (Cloudflare-proof)
             * @param {string} monsterId - Monster ID or dgmid
             * @param {number} skillId - Skill ID (-4 to 0)
             * @param {number} staminaCost - Stamina cost for the skill
             * @param {Object} options - Additional options
             * @returns {Promise<Object>} Attack result
             */
            async attackMonsterDirect(monsterId, skillId, staminaCost, { isDungeon = false, instanceId = null, referrer = null } = {}) {
                let body, battleUrl;
                
                if (isDungeon && instanceId) {
                    // Dungeon attack
                    body = `instance_id=${instanceId}&dgmid=${monsterId}&skill_id=${skillId}&stamina_cost=${staminaCost}`;
                    battleUrl = referrer || `${BASE_URL}/battle.php?dgmid=${monsterId}&instance_id=${instanceId}`;
                } else {
                    // Wave attack
                    body = `monster_id=${monsterId}&skill_id=${skillId}&stamina_cost=${staminaCost}`;
                    battleUrl = referrer || `${BASE_URL}/battle.php?id=${monsterId}`;
                }
                
                return this.fetchDirect('/damage.php', {
                    body,
                    referrer: battleUrl,
                    parseJson: true
                });
            },
            
            /**
             * Loot monster using optimized fetch (Cloudflare-proof)
             * @param {string} monsterId - Monster ID
             * @param {string} userId - User ID
             * @param {string} referrer - Referrer URL (battle page)
             * @returns {Promise<Object>} Loot result
             */
            async lootMonsterDirect(monsterId, userId, referrer = null) {
                const body = `monster_id=${monsterId}&user_id=${userId}`;
                const battleUrl = referrer || `${BASE_URL}/battle.php?id=${monsterId}`;
                
                return this.fetchDirect('/loot.php', {
                    body,
                    referrer: battleUrl,
                    parseJson: true
                });
            },
            
            /**
             * Loot dungeon monster using optimized fetch (Cloudflare-proof)
             * TODO: Get example request to verify body format
             * @param {string} dgmid - Dungeon monster ID
             * @param {string} instanceId - Instance ID
             * @param {string} userId - User ID
             * @param {string} referrer - Referrer URL (dungeon page)
             * @returns {Promise<Object>} Loot result
             */
            async lootDungeonMonsterDirect(dgmid, instanceId, userId, referrer = null) {
                // TODO: Verify body format when example is available
                const body = `instance_id=${instanceId}&dgmid=${dgmid}&user_id=${userId}`;
                const dungeonUrl = referrer || `${BASE_URL}/guild_dungeon_location.php?instance_id=${instanceId}`;
                
                return this.fetchDirect('/dungeon_loot.php', {
                    body,
                    referrer: dungeonUrl,
                    parseJson: true
                });
            },
            
            /**
             * Use potion using optimized fetch (Cloudflare-proof)
             * @param {string} invId - Inventory item ID
             * @param {string} referrer - Referrer URL (battle page)
             * @returns {Promise<Object>} Use item result
             */
            async usePotionDirect(invId, referrer = null) {
                const body = `inv_id=${invId}`;
                const battleUrl = referrer || window.location.href;
                
                return this.fetchDirect('/use_item.php', {
                    body,
                    referrer: battleUrl,
                    parseJson: false  // No response, page reloads
                });
            },
            
            /**
             * Start PvP matchmaking (Cloudflare-proof)
             * Redirects to pvp_battle.php if successful
             * @returns {Promise<Object>} Matchmaking result with redirect status
             */
            async startPvpMatchmaking() {
                const body = 'go=1';
                
                return this.fetchDirect('/pvp_matchmake.php', {
                    body,
                    referrer: 'https://demonicscans.org/pvp.php',
                    parseJson: true,
                    method: 'POST'
                });
            },
            
            /**
             * Attack in PvP battle (Cloudflare-proof)
             * @param {number} skillId - Skill ID (0 = Slash/1 token, -1 = Power Slash/5 tokens)
             * @returns {Promise<Object>} Attack result with HP and damage info
             */
            async attackPvpDirect(skillId = 0) {
                const body = `skill_id=${skillId}`;
                
                return this.fetchDirect('/pvp_attack.php', {
                    body,
                    referrer: 'https://demonicscans.org/pvp_battle.php',
                    parseJson: true,
                    method: 'POST'
                });
            }
        };
    }

    // ==================== NOTIFICATION SERVICE ====================
    // Centralized notification/toast handling
    // Provides consistent UI feedback across all modules
    
    /**
     * Create centralized notification service
     * Manages user notifications and toasts with fallback support
     * Uses native window.showNotification() if available, custom toasts otherwise
     * 
     * @param {Object} context - Script context (logger, config, etc.)
     * @returns {Object} Notification service
     * 
     * Main methods:
     * @returns {function(string, number): void} success - Show success notification (green)
     * @returns {function(string, number): void} error - Show error notification (red, 10s default)
     * @returns {function(string, number): void} warn - Show warning notification (orange)
     * @returns {function(string, number): void} info - Show info notification (blue)
     * 
     * Game-specific shortcuts:
     * @returns {function(number, number): void} staminaLow - Show low stamina warning
     * @returns {function(string, number): void} battleComplete - Show battle completion
     * @returns {function(string, number): void} itemUsed - Show item usage confirmation
     * @returns {function(string, Object): void} lootClaimed - Show loot summary
     * @returns {function(string): void} autoPaused - Show automation pause reason
     * 
     * @example
     * const notify = context.notifications;
     * 
     * notify.success('Battle completed!');
     * notify.error('Attack failed!', 5000);
     * notify.staminaLow(50, 100); // current, required
     * notify.lootClaimed('Dragon', { gold: 1000, exp: 5000 });
     */
    function createNotificationService(context) {
        const { logger, config } = context;
        
        /**
         * Show notification using native game function or custom toast
         */
        function show(message, type = 'info', duration = 4500) {
            // Use native showNotification if available
            if (typeof window.showNotification === 'function') {
                window.showNotification(message, type);
            } else {
                // Fallback: create custom toast
                createToast(message, type, duration);
            }
            
            // Always log as well
            const emoji = {
                success: '‚úÖ',
                error: '‚ùå',
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            }[type] || '‚ÑπÔ∏è';
            
            logger.info(`${emoji} ${message}`);
        }
        
        /**
         * Create custom toast notification
         */
        function createToast(message, type, duration) {
            const toast = document.createElement('div');
            toast.className = `autods-toast autods-toast-${type}`;
            toast.textContent = message;
            
            // Toast styles
            const colors = {
                success: { bg: '#10b981', text: '#fff' },
                error: { bg: '#ef4444', text: '#fff' },
                warning: { bg: '#f59e0b', text: '#fff' },
                info: { bg: '#3b82f6', text: '#fff' }
            };
            
            const color = colors[type] || colors.info;
            
            toast.style.cssText = `
                background: ${color.bg};
                color: ${color.text};
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                font-size: 14px;
                font-weight: 500;
                max-width: 300px;
                word-wrap: break-word;
                animation: autods-toast-slide-in 0.3s ease-out;
            `;
            
            const container = getOrCreateToastContainer();
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'autods-toast-fade-out 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }
        
        /**
         * Get or create toast container
         */
        function getOrCreateToastContainer() {
            let container = document.getElementById('autods-toast-container');
            
            if (!container) {
                container = document.createElement('div');
                container.id = 'autods-toast-container';
                container.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 2147483646;
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    pointer-events: none;
                `;
                
                // Inject animations
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes autods-toast-slide-in {
                        from {
                            transform: translateX(400px);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                    
                    @keyframes autods-toast-fade-out {
                        from {
                            opacity: 1;
                        }
                        to {
                            opacity: 0;
                            transform: translateY(-20px);
                        }
                    }
                    
                    .autods-toast {
                        pointer-events: auto;
                        cursor: default;
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(container);
            }
            
            return container;
        }
        
        return {
            /**
             * Show success notification
             */
            success(message, duration) {
                show(message, 'success', duration);
            },
            
            /**
             * Show error notification
             */
            error(message, duration = 10000) {
                show(message, 'error', duration);
            },
            
            /**
             * Show warning notification
             */
            warn(message, duration) {
                show(message, 'warning', duration);
            },
            
            /**
             * Show info notification
             */
            info(message, duration) {
                show(message, 'info', duration);
            },
            
            // ========== Game-specific shortcuts ==========
            
            /**
             * Stamina low warning
             */
            staminaLow(current, required) {
                this.warn(`‚ö° Stamina baixa: ${current}/${required}`);
            },
            
            /**
             * Battle completed
             */
            battleComplete(monsterName, damage) {
                this.success(`‚öîÔ∏è ${monsterName} completado! ${formatNumber(damage)} dano`);
            },
            
            /**
             * Item used notification
             */
            itemUsed(itemName, remaining) {
                this.info(`üíä ${itemName} usado! Restam: ${remaining}`);
            },
            
            /**
             * Loot claimed notification
             */
            lootClaimed(monsterName, rewards) {
                const parts = [];
                if (rewards.exp) parts.push(`${formatNumber(rewards.exp)} EXP`);
                if (rewards.gold) parts.push(`${formatNumber(rewards.gold)} Gold`);
                const rewardStr = parts.length > 0 ? ` (${parts.join(', ')})` : '';
                this.success(`üéÅ Loot obtido: ${monsterName}${rewardStr}`);
            },
            
            /**
             * Auto-pause notification
             */
            autoPaused(reason) {
                this.warn(`‚è∏Ô∏è Automa√ß√£o pausada: ${reason}`);
            }
        };
    }

    // ==================== COMBAT SERVICE ====================
    // Centralized combat operations (attacks, damage parsing)
    // Eliminates ~400 lines of duplicated code
    
    /**
     * Create centralized combat service
     * Handles all attack types (WAVE, DUNGEON, PVP) with unified API
     * Includes automatic damage parsing and battle state detection
     * 
     * @param {Object} context - Script context (logger, config, etc.)
     * @returns {Object} Combat service
     * 
     * Attack methods:
     * @returns {function(string, number): Promise<Object>} attackWaveMonster - Attack wave monster (monster_id, skill_id)
     * @returns {function(string, string, number): Promise<Object>} attackDungeonMonster - Attack dungeon monster (dgmid, instance_id, skill_id)
     * @returns {function(number): Promise<Object>} attackPvpOpponent - Attack PvP opponent (skill_id)
     * 
     * Utility methods:
     * @returns {function(Array, function): Promise<Array>} attackMultiple - Execute multiple attacks in parallel
     * @returns {function(number, string): number} getSkillCost - Get stamina/token cost for skill
     * 
     * Attack response format:
     * {
     *   success: boolean,
     *   damageDealt: number,
     *   stamina: number,
     *   hp: { value: number, max: number },
     *   battleEnded: boolean,
     *   message: string,
     *   data: Object // Original server response
     * }
     * 
     * Skill IDs and costs:
     * - 0: Slash (1 stamina)
     * - -1: Power Slash (10 stamina / 5 tokens)
     * - -2: Heroic Slash (50 stamina)
     * - -3: Ultimate Slash (100 stamina)
     * - -4: Legendary Slash (200 stamina)
     * 
     * @example
     * const combat = context.combat;
     * 
     * // Attack wave monster
     * const result = await combat.attackWaveMonster('123456', -2);
     * if (result.success) {
     *   console.log(`Dealt ${result.damageDealt} damage!`);
     *   if (result.battleEnded) console.log('Monster died!');
     * }
     * 
     * // Attack dungeon monster
     * await combat.attackDungeonMonster('386752', '1522', -1);
     * 
     * // Get skill cost
     * const cost = combat.getSkillCost(-2); // 50 stamina
     */
    function createCombatService(context) {
        const { logger } = context;
        
        const SKILL_COSTS = {
            STAMINA: { '0': 1, '-1': 10, '-2': 50, '-3': 100, '-4': 200 },
            PVP_TOKENS: { '0': 1, '-1': 5 }
        };
        
        const ENDPOINTS = {
            WAVE: 'https://demonicscans.org/damage.php',
            PVP: 'https://demonicscans.org/pvp_attack.php',
            DUNGEON: 'https://demonicscans.org/damage.php' // Guild dungeons use damage.php, not dungeon_attack.php
        };
        
        function sendAttack({ type, monsterId, skillId, instanceId, referer }) {
            return new Promise((resolve) => {
                const endpoint = ENDPOINTS[type];
                
                // Calculate stamina cost (both WAVE and DUNGEON attacks require stamina)
                const staminaCost = (type === 'WAVE' || type === 'DUNGEON') 
                    ? (SKILL_COSTS.STAMINA[skillId.toString()] || 1) 
                    : 0;
                
                // Build body parameters based on attack type
                let bodyData;
                if (type === 'PVP') {
                    bodyData = `skill=${skillId}`;
                } else if (type === 'DUNGEON') {
                    // Guild dungeon attack - same format as WAVE but with dgmid instead of monster_id
                    bodyData = `instance_id=${instanceId}&dgmid=${monsterId}&skill_id=${skillId}&stamina_cost=${staminaCost}`;
                } else {
                    // WAVE attack - correct parameter names from original implementation
                    bodyData = `monster_id=${monsterId}&skill_id=${skillId}&stamina_cost=${staminaCost}`;
                }
                
                GM_xmlhttpRequest({
                    method: 'POST',
                    url: endpoint,
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Referer': referer || endpoint
                    },
                    data: bodyData,
                    onload: (response) => {
                        try {
                            const data = JSON.parse(response.responseText);
                            resolve(parseAttackResponse(data, type));
                        } catch (e) {
                            resolve({ success: false, data: null, message: 'JSON parse error', error: 'Parse error' });
                        }
                    },
                    onerror: () => {
                        resolve({ success: false, data: null, message: 'Network error', error: 'Network error' });
                    },
                    ontimeout: () => {
                        resolve({ success: false, data: null, message: 'Timeout', error: 'Timeout' });
                    }
                });
            });
        }
        
        function parseAttackResponse(data, type) {
            // Robust success check: convert to string and trim (handles boolean/string/number)
            const success = String(data.status).trim() === 'success' || data.success === true;
            
            if (success) {
                return {
                    success: true,
                    data,
                    damageDealt: extractDamage(data),
                    stamina: data.stamina || data.current_stamina,
                    battleEnded: detectBattleEnd(data),
                    message: data.message || ''
                };
            }
            
            return {
                success: false,
                data,
                damageDealt: 0,
                battleEnded: detectBattleEnd(data),
                error: data.error,
                message: data.message || data.error || ''
            };
        }
        
        function extractDamage(data) {
            if (data.damage) return parseInt(data.damage, 10) || 0;
            if (data.your_damage) return parseInt(data.your_damage, 10) || 0;
            
            const match = data.message?.match(/<strong>([\d,]+)<\/strong>/);
            return match ? parseInt(match[1].replace(/,/g, ''), 10) : 0;
        }
        
        function detectBattleEnd(data) {
            const msg = (data.message || data.error || '').toLowerCase();
            return msg.includes('dead') || 
                   msg.includes('ended') || 
                   msg.includes('completed') ||
                   msg.includes('victory') ||
                   data.battle_ended === true;
        }
        
        return {
            async attackWaveMonster(monsterId, skillId) {
                return sendAttack({
                    type: 'WAVE',
                    monsterId,
                    skillId,
                    referer: `https://demonicscans.org/battle.php?id=${monsterId}`
                });
            },
            
            async attackPvpOpponent(skillId) {
                return sendAttack({
                    type: 'PVP',
                    skillId,
                    referer: 'https://demonicscans.org/pvp_battle.php'
                });
            },
            
            async attackDungeonMonster(dgmid, instanceId, skillId) {
                return sendAttack({
                    type: 'DUNGEON',
                    monsterId: dgmid,
                    instanceId,
                    skillId,
                    referer: `https://demonicscans.org/battle.php?dgmid=${dgmid}&instance_id=${instanceId}`
                });
            },
            
            async attackMultiple(targets, attackFn) {
                return Promise.all(targets.map(target => attackFn(target)));
            },
            
            getSkillCost(skillId, type = 'STAMINA') {
                const costs = type === 'PVP' ? SKILL_COSTS.PVP_TOKENS : SKILL_COSTS.STAMINA;
                return costs[skillId.toString()] || 1;
            },
            
            // ========== OPTIMIZED ATTACK METHODS (Cloudflare-proof) ==========
            // These methods use direct fetch with correct headers to bypass Cloudflare
            
            /**
             * Attack wave monster using optimized fetch (Cloudflare-proof)
             * Same API as attackWaveMonster but uses fetchDirect internally
             * @param {string} monsterId - Monster ID
             * @param {number} skillId - Skill ID
             * @returns {Promise<Object>} Attack result with parsed damage
             */
            async attackWaveMonsterDirect(monsterId, skillId) {
                const staminaCost = this.getSkillCost(skillId);
                const referrer = `https://demonicscans.org/battle.php?id=${monsterId}`;
                
                const result = await context.http.attackMonsterDirect(monsterId, skillId, staminaCost, {
                    isDungeon: false,
                    referrer
                });
                
                if (result.success && result.data) {
                    return {
                        success: true,
                        data: result.data,
                        damageDealt: extractDamage(result.data),
                        stamina: result.data.stamina || result.data.current_stamina,
                        battleEnded: detectBattleEnd(result.data),
                        message: result.data.message || ''
                    };
                }
                
                // Check if monster is already dead
                const errorMsg = (result.data?.message || result.message || result.error || '').toLowerCase();
                if (errorMsg.includes('already dead') || errorMsg.includes('monster is dead')) {
                    return {
                        success: false,
                        dead: true,
                        data: null,
                        message: 'Monster is already dead',
                        error: result.error
                    };
                }
                
                return {
                    success: false,
                    data: null,
                    message: result.data?.message || result.message || 'Attack failed',
                    error: result.error
                };
            },
            
            /**
             * Attack dungeon monster using optimized fetch (Cloudflare-proof)
             * Same API as attackDungeonMonster but uses fetchDirect internally
             * @param {string} dgmid - Dungeon monster ID
             * @param {string} instanceId - Instance ID
             * @param {number} skillId - Skill ID
             * @returns {Promise<Object>} Attack result with parsed damage
             */
            async attackDungeonMonsterDirect(dgmid, instanceId, skillId) {
                const staminaCost = this.getSkillCost(skillId);
                const referrer = `https://demonicscans.org/battle.php?dgmid=${dgmid}&instance_id=${instanceId}`;
                
                const result = await context.http.attackMonsterDirect(dgmid, skillId, staminaCost, {
                    isDungeon: true,
                    instanceId,
                    referrer
                });
                
                if (result.success && result.data) {
                    return {
                        success: true,
                        data: result.data,
                        damageDealt: extractDamage(result.data),
                        stamina: result.data.stamina || result.data.current_stamina,
                        battleEnded: detectBattleEnd(result.data),
                        message: result.data.message || ''
                    };
                }
                
                // Check if monster is already dead
                const errorMsg = (result.data?.message || result.message || result.error || '').toLowerCase();
                if (errorMsg.includes('already dead') || errorMsg.includes('monster is dead')) {
                    return {
                        success: false,
                        dead: true,
                        data: null,
                        message: 'Monster is already dead',
                        error: result.error
                    };
                }
                
                return {
                    success: false,
                    data: null,
                    message: result.data?.message || result.message || 'Attack failed',
                    error: result.error
                };
            }
        };
    }

    // ==================== BATTLE STATS SERVICE ====================
    // Centralized battle statistics reading from DOM
    // Eliminates ~150 lines of duplicated code across modules
    
    /**
     * Create centralized battle stats service
     * Provides unified API for reading battle-related stats from DOM
     * 
     * @param {Object} context - Script context (logger, dom, etc.)
     * @returns {Object} Battle stats service
     * 
     * Main methods:
     * @returns {function(): Object} getCurrent - Get all current battle stats
     * @returns {function(): Object} getPlayerHP - Get player HP (current, max, percent)
     * @returns {function(): Object} getMonsterHP - Get monster HP (current, max, percent)
     * @returns {function(): Object} isBattleEnded - Check if battle ended
     * @returns {function(): number} getCurrentDamage - Get current damage dealt
     * @returns {function(): Object} getMonsterPhase - Detect monster phase (1-5 based on HP %)
     * 
     * Stats object format:
     * {
     *   damage: number,           // Current damage dealt
     *   monsterHp: number,        // Monster current HP
     *   monsterMaxHp: number,     // Monster max HP
     *   playerHp: number,         // Player current HP
     *   playerMaxHp: number,      // Player max HP
     *   monsterName: string       // Monster name
     * }
     * 
     * HP object format:
     * {
     *   current: number,
     *   max: number,
     *   percent: number  // 0-100
     * }
     * 
     * @example
     * const stats = context.battleStats;
     * 
     * // Get all stats
     * const current = stats.getCurrent();
     * // { damage: 1500000, monsterHp: 8000000, monsterMaxHp: 10000000, ... }
     * 
     * // Get specific stats
     * const playerHp = stats.getPlayerHP();
     * // { current: 1800, max: 2000, percent: 90 }
     * 
     * const monsterHp = stats.getMonsterHP();
     * // { current: 8000000, max: 10000000, percent: 80 }
     * 
     * // Check battle status
     * const ended = stats.isBattleEnded();
     * // { ended: true, reason: 'monster_dead' } or { ended: false, reason: null }
     * 
     * // Get current damage
     * const damage = stats.getCurrentDamage(); // 1500000
     * 
     * // Detect monster phase
     * const phase = stats.getMonsterPhase();
     * // { phase: 4, percent: 65, threshold: '50-75%' }
     */
    function createBattleStatsService(context) {
        const { logger, dom } = context;
        
        return {
            /**
             * Get all current battle stats from DOM
             * @returns {Object} Battle stats object
             */
            getCurrent() {
                try {
                    // Read current damage - OPTIMIZE: try selectors first before expensive full scan
                    let damage = 0;
                    const damageEl = document.querySelector('#yourDamageValue, [data-your-damage], .your-damage-value');
                    if (damageEl?.textContent) {
                        damage = context.numbers.parse(damageEl.textContent) || 0;
                    }
                    
                    // Fallback: scan for "DMG: X" text only if selector failed
                    if (damage === 0) {
                        const damageTextElements = Array.from(document.querySelectorAll('*')).filter(el => 
                            el.textContent && /DMG:\s*[\d,]+/.test(el.textContent) && el.children.length === 0
                        );
                        if (damageTextElements.length > 0) {
                            const damageMatch = damageTextElements[0].textContent.match(/DMG:\s*([\d,]+)/);
                            if (damageMatch) {
                                damage = numberFromText(damageMatch[1]) || 0;
                            }
                        }
                    }
                    
                    // Read monster HP - OPTIMIZE: try direct selectors first
                    let monsterHp = null;
                    let monsterMaxHp = null;
                    
                    // Strategy 1: Try direct HP selector first (fastest)
                    const hpTextEl = document.querySelector('#hpText, .monster-hp, .hp-text, [data-monster-hp]');
                    if (hpTextEl) {
                        const hpText = hpTextEl.textContent?.trim();
                        if (hpText) {
                            const parts = hpText.split('/').map(s => s.trim());
                            if (parts.length >= 2) {
                                monsterHp = numberFromText(parts[0]);
                                monsterMaxHp = numberFromText(parts[1]);
                            } else {
                                monsterHp = numberFromText(hpText);
                            }
                        }
                    }
                    
                    // Strategy 2 (fallback): Find "HP" label followed by strong tags
                    if (monsterHp === null) {
                        const hpLabels = Array.from(document.querySelectorAll('*')).filter(el => 
                            el.textContent?.trim() === 'HP' && el.tagName !== 'STRONG'
                        );
                    
                    for (const label of hpLabels) {
                        const parent = label.parentElement;
                        if (parent) {
                            const strongs = parent.querySelectorAll('strong');
                            if (strongs.length >= 1) {
                                monsterHp = numberFromText(strongs[0].textContent);
                                // Look for "/ number" text after the strong tag
                                const siblings = Array.from(parent.childNodes);
                                for (let i = 0; i < siblings.length; i++) {
                                    const node = siblings[i];
                                    if (node.nodeType === Node.TEXT_NODE && node.textContent.includes('/')) {
                                        const maxMatch = node.textContent.match(/\/\s*([\d,]+)/);
                                        if (maxMatch) {
                                            monsterMaxHp = numberFromText(maxMatch[1]);
                                            break;
                                        }
                                    }
                                }
                                if (monsterHp !== null) break;
                            }
                        }
                    }
                    }
                    
                    // Strategy 3: Look for pattern "‚ù§Ô∏è 0 / 40,000,000 HP"
                    if (monsterHp === null) {
                        const hpPattern = Array.from(document.querySelectorAll('*')).filter(el => 
                            el.textContent && /‚ù§Ô∏è\s*[\d,]+\s*\/\s*[\d,]+\s*HP/.test(el.textContent) && el.children.length === 0
                        );
                        if (hpPattern.length > 0) {
                            const hpMatch = hpPattern[0].textContent.match(/‚ù§Ô∏è\s*([\d,]+)\s*\/\s*([\d,]+)\s*HP/);
                            if (hpMatch) {
                                monsterHp = numberFromText(hpMatch[1]);
                                monsterMaxHp = numberFromText(hpMatch[2]);
                            }
                        }
                    }
                    
                    // Fallback to old selectors
                    if (monsterHp === null) {
                        const monsterHpEl = document.querySelector('[data-monster-hp], #monsterHP, .monster-hp');
                        if (monsterHpEl) {
                            const hpText = monsterHpEl.textContent?.trim();
                            if (hpText) {
                                const parts = hpText.split('/').map(s => numberFromText(s.trim()));
                                if (parts.length === 2) {
                                    monsterHp = parts[0];
                                    monsterMaxHp = parts[1];
                                } else {
                                    monsterHp = numberFromText(hpText);
                                }
                            }
                            
                            const currentHpAttr = monsterHpEl.getAttribute('data-current-hp');
                            const maxHpAttr = monsterHpEl.getAttribute('data-max-hp');
                            if (currentHpAttr) monsterHp = numberFromText(currentHpAttr);
                            if (maxHpAttr) monsterMaxHp = numberFromText(maxHpAttr);
                        }
                    }
                    
                    // Read player HP (from "üíö Your HP 157,750 / 157,750" or "üíö 157,750 / 157,750 HP")
                    let playerHp = null;
                    let playerMaxHp = null;
                    
                    const playerHpPattern = Array.from(document.querySelectorAll('*')).filter(el => 
                        el.textContent && /üíö.*?[\d,]+\s*\/\s*[\d,]+/.test(el.textContent) && el.children.length === 0
                    );
                    
                    if (playerHpPattern.length > 0) {
                        const hpMatch = playerHpPattern[0].textContent.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                        if (hpMatch) {
                            playerHp = numberFromText(hpMatch[1]);
                            playerMaxHp = numberFromText(hpMatch[2]);
                        }
                    }
                    
                    // Fallback to old selectors
                    if (playerHp === null) {
                        const playerHpEl = document.querySelector('#pHpText, [data-player-hp], .player-hp');
                        if (playerHpEl) {
                            const hpText = playerHpEl.textContent?.trim();
                            if (hpText) {
                                const parts = hpText.split('/').map(s => numberFromText(s.trim()));
                                if (parts.length === 2) {
                                    playerHp = parts[0];
                                    playerMaxHp = parts[1];
                                } else {
                                    playerHp = numberFromText(hpText);
                                }
                            }
                        }
                    }
                    
                    // Read monster name (from "üßü Lizardman Flamecaster" or "üßü Lizardman Shadowclaw DEAD")
                    let monsterName = null;
                    
                    // Strategy 1: Use legacy selectors (same as getCurrentMonsterName in battleModule)
                    const selectors = [
                        '.card-title',           // Guild dungeon & battle page
                        '.panel strong',         // Regular dungeon
                        '.monster-name',         // Battle page
                        '.battle-monster-name',  // Alternative
                        '[data-monster-name]'    // Data attribute
                    ];
                    
                    for (const selector of selectors) {
                        const node = document.querySelector(selector);
                        if (node) {
                            let rawText = node.textContent?.trim() || node.getAttribute?.('data-monster-name')?.trim();
                            if (rawText) {
                                // Remove all emoji characters using Unicode ranges
                                let cleaned = rawText.replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '');
                                
                                // Remove "DEAD" badge
                                cleaned = cleaned.replace(/\s*DEAD\s*$/i, '');
                                
                                // Clean up extra whitespace
                                cleaned = cleaned.trim();
                                
                                // Validate: must have content and not be HP/DMG text
                                if (cleaned.length > 2 && 
                                    !cleaned.includes('HP') && 
                                    !cleaned.includes('DMG') &&
                                    !cleaned.includes('/')) {
                                    monsterName = cleaned;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Strategy 2: Extract from page title (legacy fallback)
                    if (!monsterName) {
                        const titleMatch = document.title.match(/Battle:\s*(.+?)(?:\s*-|$)/i);
                        if (titleMatch) {
                            monsterName = titleMatch[1].trim();
                        }
                    }

                    
                    return {
                        damage,
                        monsterHp,
                        monsterMaxHp,
                        playerHp,
                        playerMaxHp,
                        monsterName
                    };
                } catch (error) {
                    logger.warn(`[BattleStats] Failed to read stats: ${error.message}`);
                    return {
                        damage: 0,
                        monsterHp: null,
                        monsterMaxHp: null,
                        playerHp: null,
                        playerMaxHp: null,
                        monsterName: null
                    };
                }
            },
            
            /**
             * Get player HP stats
             * @returns {Object} HP object { current, max, percent }
             */
            getPlayerHP() {
                const stats = this.getCurrent();
                const current = stats.playerHp || 0;
                const max = stats.playerMaxHp || 0;
                const percent = max > 0 ? Math.round((current / max) * 100) : 0;
                
                return { current, max, percent };
            },
            
            /**
             * Get monster HP stats
             * @returns {Object} HP object { current, max, percent }
             */
            getMonsterHP() {
                const stats = this.getCurrent();
                const current = stats.monsterHp || 0;
                const max = stats.monsterMaxHp || current || 0;
                const percent = max > 0 ? Math.round((current / max) * 100) : 0;
                
                return { current, max, percent };
            },
            
            /**
             * Check if battle has ended
             * @returns {Object} { ended: boolean, reason: string|null }
             */
            isBattleEnded() {
                const monsterHp = this.getMonsterHP();
                const playerHp = this.getPlayerHP();
                
                // Monster dead
                if (monsterHp.current <= 0) {
                    return { ended: true, reason: 'monster_dead' };
                }
                
                // Player dead
                if (playerHp.current <= 0) {
                    return { ended: true, reason: 'player_dead' };
                }
                
                // Check for victory/defeat modals
                const victoryModal = document.querySelector('.modal-victory, [data-battle-result="victory"]');
                if (victoryModal && victoryModal.style.display !== 'none') {
                    return { ended: true, reason: 'victory_modal' };
                }
                
                const defeatModal = document.querySelector('.modal-defeat, [data-battle-result="defeat"]');
                if (defeatModal && defeatModal.style.display !== 'none') {
                    return { ended: true, reason: 'defeat_modal' };
                }
                
                return { ended: false, reason: null };
            },
            
            /**
             * Get current damage dealt
             * @returns {number} Damage value
             */
            getCurrentDamage() {
                const stats = this.getCurrent();
                return stats.damage || 0;
            },
            
            /**
             * Detect monster phase based on HP percentage
             * Phase 1: 100-75% HP
             * Phase 2: 75-50% HP
             * Phase 3: 50-25% HP
             * Phase 4: 25-10% HP
             * Phase 5: 10-0% HP
             * 
             * @returns {Object} { phase: number, percent: number, threshold: string }
             */
            getMonsterPhase() {
                const hp = this.getMonsterHP();
                const percent = hp.percent;
                
                if (percent >= 75) {
                    return { phase: 1, percent, threshold: '75-100%' };
                } else if (percent >= 50) {
                    return { phase: 2, percent, threshold: '50-75%' };
                } else if (percent >= 25) {
                    return { phase: 3, percent, threshold: '25-50%' };
                } else if (percent >= 10) {
                    return { phase: 4, percent, threshold: '10-25%' };
                } else {
                    return { phase: 5, percent, threshold: '0-10%' };
                }
            }
        };
    }

    // ==================== MONSTER SCANNER SERVICE ====================
    // Centralized monster card scanning and parsing
    // Eliminates ~200 lines of duplicated code across modules
    
    /**
     * Create centralized monster scanner service
     * Provides unified API for scanning and parsing monster cards from wave/dungeon pages
     * 
     * @param {Object} context - Script context (logger, dom, etc.)
     * @returns {Object} Monster scanner service
     * 
     * Main methods:
     * @returns {function(Object): Array<Monster>} scanWaveMonsters - Scan monsters from active_wave.php
     * @returns {function(Object): Array<DungeonMonster>} scanDungeonMonsters - Scan monsters from guild_dungeon_location.php
     * @returns {function(Array, string): Array} sortByPriority - Sort monsters by priority mode
     * 
     * Monster object format (wave):
     * {
     *   type: 'wave',
     *   monsterId: string,
     *   name: string,
     *   hp: number,
     *   maxHp: number|null,
     *   isDead: boolean,
     *   canJoin: boolean,
     *   hasJoined: boolean,
     *   battleUrl: string|null,
     *   card: HTMLElement
     * }
     * 
     * DungeonMonster object format:
     * {
     *   type: 'dungeon',
     *   dgmid: string,
     *   instanceId: string,
     *   name: string,
     *   hp: number,
     *   maxHp: number,
     *   currentDamage: number,
     *   hasJoined: boolean,
     *   needsLoot: boolean,
     *   card: HTMLElement
     * }
     * 
     * Filter options:
     * {
     *   monsterNames: string[],     // Filter by name (case-insensitive, partial match)
     *   minHp: number,              // Minimum HP
     *   maxHp: number,              // Maximum HP
     *   onlyAlive: boolean,         // Only alive monsters (wave)
     *   onlyDead: boolean,          // Only dead monsters (wave)
     *   onlyNotJoined: boolean,     // Only not joined (dungeon)
     *   onlyNeedsLoot: boolean      // Only needs loot (dungeon)
     * }
     * 
     * Priority modes:
     * - 'lowest_hp': Sort by lowest HP first
     * - 'highest_hp': Sort by highest HP first
     * - 'lowest_damage': Sort by lowest damage first (dungeon)
     * - 'highest_damage': Sort by highest damage first (dungeon)
     * - 'random': Random order
     * 
     * @example
     * const scanner = context.monsterScanner;
     * 
     * // Scan wave monsters
     * const waveMonsters = scanner.scanWaveMonsters({
     *   monsterNames: ['Bonecrusher', 'Dragon'],
     *   minHp: 100000,
     *   onlyAlive: true
     * });
     * // [{ type: 'wave', monsterId: '123', name: 'Bonecrusher', ... }, ...]
     * 
     * // Scan dungeon monsters
     * const dungeonMonsters = scanner.scanDungeonMonsters({
     *   monsterNames: ['Magus'],
     *   onlyNotJoined: true
     * });
     * // [{ type: 'dungeon', dgmid: '386752', instanceId: '1522', ... }, ...]
     * 
     * // Sort by priority
     * const sorted = scanner.sortByPriority(monsters, 'lowest_hp');
     */
    function createMonsterScannerService(context) {
        const { logger } = context;
        
        return {
            /**
             * Scan monsters from active_wave.php
             * @param {Object} filters - Filter options
             * @returns {Array<Monster>} Array of wave monsters
             */
            scanWaveMonsters(filters = {}) {
                const cards = document.querySelectorAll('.monster-card, [data-monster-card]');
                const monsters = [];
                
                for (const card of cards) {
                    const monster = this.parseWaveMonster(card);
                    if (!monster) continue;
                    
                    // Apply filters
                    if (filters.monsterNames?.length && !this.matchesName(monster.name, filters.monsterNames)) continue;
                    if (filters.minHp && monster.hp < filters.minHp) continue;
                    if (filters.maxHp && monster.hp > filters.maxHp) continue;
                    if (filters.onlyAlive && monster.isDead) continue;
                    if (filters.onlyDead && !monster.isDead) continue;
                    if (filters.onlyNotJoined && monster.hasJoined) continue;
                    
                    monsters.push(monster);
                }
                
                logger.debug(`[MonsterScanner] Scanned ${monsters.length} wave monsters (${cards.length} cards total)`);
                return monsters;
            },
            
            /**
             * Scan monsters from guild_dungeon_location.php
             * @param {Object} filters - Filter options
             * @returns {Array<DungeonMonster>} Array of dungeon monsters
             */
            scanDungeonMonsters(filters = {}) {
                const cards = document.querySelectorAll('.mon, [data-dungeon-monster]');
                logger.debug(`[MonsterScanner] Found ${cards.length} dungeon cards in DOM`);
                
                const monsters = [];
                let parsedCount = 0;
                let failedCount = 0;
                
                for (const card of cards) {
                    const monster = this.parseDungeonMonster(card);
                    if (!monster) {
                        failedCount++;
                        continue;
                    }
                    
                    parsedCount++;
                    logger.debug(`[MonsterScanner] Parsed: ${monster.name} (HP: ${context.numbers.format(monster.hp)}/${context.numbers.format(monster.maxHp)}, Joined: ${monster.hasJoined})`);
                    
                    // Apply filters
                    if (filters.monsterNames?.length && !this.matchesName(monster.name, filters.monsterNames)) {
                        logger.debug(`[MonsterScanner] Filtered by name: ${monster.name}`);
                        continue;
                    }
                    if (filters.minHp && monster.hp < filters.minHp) {
                        logger.debug(`[MonsterScanner] Filtered by minHp: ${monster.name} (${context.numbers.format(monster.hp)} < ${context.numbers.format(filters.minHp)})`);
                        continue;
                    }
                    if (filters.maxHp && monster.hp > filters.maxHp) {
                        logger.debug(`[MonsterScanner] Filtered by maxHp: ${monster.name}`);
                        continue;
                    }
                    if (filters.onlyNotJoined && monster.hasJoined) {
                        logger.debug(`[MonsterScanner] Filtered by onlyNotJoined: ${monster.name} (already joined)`);
                        continue;
                    }
                    if (filters.onlyNeedsLoot && !monster.needsLoot) {
                        logger.debug(`[MonsterScanner] Filtered by onlyNeedsLoot: ${monster.name}`);
                        continue;
                    }
                    
                    monsters.push(monster);
                }
                
                logger.info(`[MonsterScanner] Result: ${monsters.length} monsters passed filters (${parsedCount} parsed, ${failedCount} failed, ${cards.length} total cards)`);
                return monsters;
            },
            
            /**
             * Parse wave monster card
             * @private
             * @param {HTMLElement} card - Monster card element
             * @returns {Monster|null} Parsed monster or null if invalid
             */
            parseWaveMonster(card) {
                try {
                    // Extract monster ID
                    const monsterId = card.getAttribute('data-monster-id') || 
                                     card.querySelector('[data-monster-id]')?.getAttribute('data-monster-id');
                    
                    if (!monsterId) {
                        // Debug: log card structure when monsterId is missing
                        const cardId = card.id || 'no-id';
                        const cardClass = card.className || 'no-class';
                        const cardHTML = card.outerHTML?.substring(0, 100) || 'no-html';
                        logger.warn(`‚ö†Ô∏è [MonsterScanner] Card sem data-monster-id: id="${cardId}", class="${cardClass}", html="${cardHTML}..."`);
                        return null;
                    }
                    
                    // Extract name
                    const nameNode = card.querySelector('h3, h4, .monster-name, .card-title, [data-monster-name]');
                    const name = nameNode ? nameNode.textContent.trim() : 'Unknown';
                    
                    // Extract HP - structure: .stat-row > .stat-icon.hp + .stat-main > .stat-value
                    let hp = 0;
                    let maxHp = null;
                    
                    // Try new structure first (stat-row with HP label)
                    const statRows = card.querySelectorAll('.stat-row');
                    for (const row of statRows) {
                        const label = row.querySelector('.stat-label');
                        if (label?.textContent?.trim() === 'HP') {
                            const valueNode = row.querySelector('.stat-value');
                            if (valueNode) {
                                const hpText = valueNode.textContent?.trim();
                                if (hpText) {
                                    // Parse "1,000,000 / 2,000,000" or "1,000,000 HP"
                                    const parts = hpText.split('/').map(s => numberFromText(s.trim()));
                                    if (parts.length === 2) {
                                        hp = parts[0] || 0;
                                        maxHp = parts[1] || null;
                                    } else {
                                        hp = numberFromText(hpText) || 0;
                                    }
                                }
                            }
                            break;
                        }
                    }
                    
                    // Fallback to old selectors
                    if (hp === 0 && maxHp === null) {
                        const hpNode = card.querySelector('[data-stat="hp"], [data-hp], .hp-text, .monster-hp');
                        if (hpNode) {
                            const hpText = hpNode.textContent?.trim();
                            if (hpText) {
                                const parts = hpText.split('/').map(s => numberFromText(s.trim()));
                                if (parts.length === 2) {
                                    hp = parts[0] || 0;
                                    maxHp = parts[1] || null;
                                } else {
                                    hp = numberFromText(hpText) || 0;
                                }
                            }
                            
                            // Try data attributes
                            const currentHpAttr = hpNode.getAttribute('data-current-hp');
                            const maxHpAttr = hpNode.getAttribute('data-max-hp');
                            if (currentHpAttr) hp = numberFromText(currentHpAttr) || 0;
                            if (maxHpAttr) maxHp = numberFromText(maxHpAttr);
                        }
                    }
                    
                    // Check if dead
                    const isDead = card.getAttribute('data-dead') === '1' || 
                                  card.classList.contains('dead') ||
                                  hp <= 0;
                    
                    // Extract join button
                    const button = card.querySelector('.join-btn, .btn-join, button.join-btn, [data-action="join"]');
                    const buttonText = button?.textContent?.toLowerCase() || '';
                    const canJoin = buttonText.includes('join') && !buttonText.includes('continue');
                    const hasJoined = !canJoin && (buttonText.includes('continue') || buttonText.includes('fight'));
                    
                    // Extract battle URL
                    const link = card.querySelector('a[href*="battle.php"], a[href*="dungeon_battle.php"]');
                    const battleUrl = link?.href || null;
                    
                    return {
                        type: 'wave',
                        monsterId,
                        name,
                        hp,
                        maxHp,
                        isDead,
                        canJoin,
                        hasJoined,
                        battleUrl,
                        card
                    };
                } catch (error) {
                    logger.warn(`[MonsterScanner] Failed to parse wave monster: ${error.message}`);
                    return null;
                }
            },
            
            /**
             * Parse dungeon monster card
             * @private
             * @param {HTMLElement} card - Monster card element
             * @returns {DungeonMonster|null} Parsed monster or null if invalid
             */
            parseDungeonMonster(card) {
                try {
                    // Extract dgmid and instance_id from link href
                    const link = card.querySelector('a.btn[href*="battle.php"], a[href*="battle.php"]');
                    if (!link) {
                        logger.debug('[MonsterScanner] Card without battle link:', card);
                        return null;
                    }
                    
                    const href = link.getAttribute('href');
                    if (!href) {
                        logger.debug('[MonsterScanner] Link without href:', link);
                        return null;
                    }
                    
                    const dgmidMatch = href.match(/dgmid=(\d+)/);
                    const instanceMatch = href.match(/instance_id=(\d+)/);
                    
                    if (!dgmidMatch || !instanceMatch) {
                        logger.debug(`[MonsterScanner] Invalid href format: ${href}`);
                        return null;
                    }
                    
                    const dgmid = dgmidMatch[1];
                    const instanceId = instanceMatch[1];
                    
                    // Extract name (dungeon structure: text node inside font-weight:700 div)
                    let name = 'Unknown';
                    
                    // Strategy 1: Find div with font-weight:700 (dungeon structure)
                    const nameDiv = card.querySelector('div[style*="font-weight:700"], div[style*="font-weight: 700"]');
                    if (nameDiv) {
                        // Get all text content but skip pills/badges
                        let fullText = '';
                        for (const node of nameDiv.childNodes) {
                            if (node.nodeType === Node.TEXT_NODE) {
                                fullText += node.textContent || '';
                            }
                        }
                        
                        // Clean up the text
                        name = fullText.trim()
                            .replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '') // Remove emoji
                            .replace(/\s*dead\s*$/i, '')  // Remove "dead" suffix
                            .replace(/\s+/g, ' ')         // Normalize whitespace
                            .trim();
                        
                        if (name.length <= 2) name = 'Unknown';
                    }
                    
                    // Strategy 2: Fallback to element selectors (wave structure)
                    if (name === 'Unknown') {
                        const nameElement = card.querySelector('h3, .monster-name, [data-monster-name]');
                        if (nameElement) {
                            name = nameElement.textContent.trim()
                                              .replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '')
                                              .replace(/\s*dead\s*$/i, '')
                                              .replace(/\s+/g, ' ')
                                              .trim();
                        }
                    }
                    
                    // Extract HP (format: "21,972,853 / 25,000,000 HP")
                    let hp = 0;
                    let maxHp = 0;
                    
                    // Strategy 1: Look for .muted div with HP text
                    const mutedDivs = card.querySelectorAll('.muted, div[style*="font-size:12px"]');
                    for (const div of mutedDivs) {
                        const text = div.textContent?.trim() || '';
                        // Match pattern: "NUMBER / NUMBER HP" or "NUMBER/NUMBER HP"
                        if (/\d[\d,]*\s*\/\s*\d[\d,]*\s*HP/i.test(text)) {
                            const parts = text.split('/').map(s => context.numbers.parse(s.trim()));
                            if (parts.length >= 2 && parts[0] && parts[1]) {
                                hp = parts[0];
                                maxHp = parts[1];
                                break;
                            }
                        }
                    }
                    
                    // Strategy 2: Fallback to old selectors (for wave compatibility)
                    if (hp === 0 && maxHp === 0) {
                        const hpNode = card.querySelector('[data-stat="hp"], [data-hp], .hp-text');
                        if (hpNode) {
                            const hpText = hpNode.textContent?.trim();
                            if (hpText) {
                                const parts = hpText.split('/').map(s => context.numbers.parse(s.trim()));
                                if (parts.length === 2) {
                                    hp = parts[0] || 0;
                                    maxHp = parts[1] || 0;
                                } else {
                                    hp = context.numbers.parse(hpText) || 0;
                                }
                            }
                        }
                    }
                    
                    // Extract current damage (n√£o dispon√≠vel na lista, precisa buscar na p√°gina de batalha)
                    let currentDamage = 0;
                    
                    // Check if joined (CRITICAL: distinguish between "joined" and "not joined")
                    let hasJoined = false;
                    const pills = card.querySelectorAll('.pill, .badge, span.pill');
                    for (const pill of pills) {
                        const text = pill.textContent?.trim().toLowerCase() || '';
                        // Exact match for "joined" (not "not joined")
                        if (text === 'joined') {
                            hasJoined = true;
                            break;
                        }
                        // "not joined" means NOT joined
                        if (text === 'not joined') {
                            hasJoined = false;
                            break;
                        }
                    }
                    
                    // Check if needs loot (look for "not looted" pill)
                    const notLootedPill = Array.from(card.querySelectorAll('.pill, .badge')).find(pill =>
                        /not looted/i.test(pill.textContent)
                    );
                    const needsLoot = !!notLootedPill;
                    
                    return {
                        type: 'dungeon',
                        dgmid,
                        instanceId,
                        name,
                        hp,
                        maxHp,
                        currentDamage,
                        hasJoined,
                        needsLoot,
                        card
                    };
                } catch (error) {
                    logger.warn(`[MonsterScanner] Failed to parse dungeon monster: ${error.message}`);
                    return null;
                }
            },
            
            /**
             * Check if monster name matches any filter name
             * @private
             * @param {string} monsterName - Monster name to check
             * @param {string[]} filterNames - Array of filter names
             * @returns {boolean} True if matches any filter
             */
            matchesName(monsterName, filterNames) {
                if (!filterNames || filterNames.length === 0) return true;
                
                const nameLower = monsterName.toLowerCase();
                return filterNames.some(filter => {
                    const filterLower = filter.toLowerCase();
                    return nameLower.includes(filterLower);
                });
            },
            
            /**
             * Sort monsters by priority mode
             * @param {Array} monsters - Array of monsters
             * @param {string} mode - Priority mode (lowest_hp, highest_hp, lowest_damage, highest_damage, random)
             * @returns {Array} Sorted array (does not mutate original)
             */
            sortByPriority(monsters, mode = 'lowest_hp') {
                const sorted = [...monsters];
                
                switch (mode) {
                    case 'lowest_hp':
                        sorted.sort((a, b) => (a.hp || 0) - (b.hp || 0));
                        break;
                    case 'highest_hp':
                        sorted.sort((a, b) => (b.hp || 0) - (a.hp || 0));
                        break;
                    case 'lowest_damage':
                        sorted.sort((a, b) => (a.currentDamage || 0) - (b.currentDamage || 0));
                        break;
                    case 'highest_damage':
                        sorted.sort((a, b) => (b.currentDamage || 0) - (a.currentDamage || 0));
                        break;
                    case 'random':
                        sorted.sort(() => Math.random() - 0.5);
                        break;
                    default:
                        logger.warn(`[MonsterScanner] Unknown priority mode: ${mode}, using lowest_hp`);
                        sorted.sort((a, b) => (a.hp || 0) - (b.hp || 0));
                }
                
                return sorted;
            }
        };
    }

    // ==================== USER SESSION SERVICE ====================
    // Centralized user session management
    // Eliminates ~80 lines of duplicated code
    
    /**
     * Create centralized user session service
     * Manages user ID, login state, and user info extraction
     * 
     * @param {Object} context - Script context (logger, config, scheduler, etc.)
     * @returns {Object} User session service
     * 
     * Main methods:
     * @returns {function(): string|null} getUserId - Get user ID from cookie
     * @returns {function(): string|null} ensureUserId - Ensure user ID is set in config (auto-detect)
     * @returns {function(): boolean} isLoggedIn - Check if user is logged in
     * @returns {function(number): number} startAutoDetect - Start periodic user ID check
     * @returns {function(): Object} getUserInfo - Get user info (id, username, level)
     * 
     * UserInfo object format:
     * {
     *   userId: string|null,
     *   username: string|null,
     *   level: number|null
     * }
     * 
     * @example
     * const session = context.userSession;
     * 
     * // Get user ID
     * const userId = session.getUserId(); // '12345' or null
     * 
     * // Ensure user ID is set (auto-detect if missing)
     * const userId = session.ensureUserId(); // Auto-updates config
     * 
     * // Check login status
     * if (!session.isLoggedIn()) {
     *   console.log('Not logged in');
     * }
     * 
     * // Get user info
     * const info = session.getUserInfo();
     * // { userId: '12345', username: 'Player', level: 50 }
     * 
     * // Start auto-detect (checks every 5s)
     * const intervalId = session.startAutoDetect(5000);
     */
    function createUserSessionService(context) {
        const { logger, config, scheduler } = context;
        
        return {
            /**
             * Get user ID from cookie (demon cookie)
             * @returns {string|null} User ID or null if not found
             */
            getUserId() {
                try {
                    const cookies = document.cookie.split(';');
                    for (const cookie of cookies) {
                        const [name, value] = cookie.trim().split('=');
                        if (name === 'demon') {
                            return value || null;
                        }
                    }
                    return null;
                } catch (error) {
                    logger.warn(`[UserSession] Failed to read cookie: ${error.message}`);
                    return null;
                }
            },
            
            /**
             * Ensure user ID is set in config (auto-detect if missing)
             * Updates config if user ID is detected but not saved
             * @returns {string|null} User ID (from config or detected)
             */
            ensureUserId() {
                try {
                    // Check if already in config
                    const cfg = config.get();
                    if (cfg.core?.userId) {
                        return cfg.core.userId;
                    }
                    
                    // Try to detect from cookie
                    const detected = this.getUserId();
                    if (detected) {
                        config.update({ core: { userId: detected } });
                        logger.info(`‚úÖ User ID auto-detected and saved: ${detected}`);
                        return detected;
                    }
                    
                    logger.warn('‚ö†Ô∏è User ID not found in cookie (not logged in?)');
                    return null;
                } catch (error) {
                    logger.error(`[UserSession] Failed to ensure user ID: ${error.message}`);
                    return null;
                }
            },
            
            /**
             * Check if user is logged in
             * @returns {boolean} True if logged in (has user ID cookie)
             */
            isLoggedIn() {
                return !!this.getUserId();
            },
            
            /**
             * Start periodic check for user ID
             * Useful for detecting login after script loads
             * @param {number} intervalMs - Check interval in milliseconds (default: 5000)
             * @returns {number} Interval ID (can be used to stop with scheduler.clearInterval)
             */
            startAutoDetect(intervalMs = 5000) {
                const intervalId = scheduler.addInterval(() => {
                    const cfg = config.get();
                    if (!cfg.core?.userId) {
                        const detected = this.getUserId();
                        if (detected) {
                            config.update({ core: { userId: detected } });
                            logger.info(`‚úÖ User ID auto-detected: ${detected}`);
                        }
                    }
                }, intervalMs, 'User ID Auto-Detect');
                
                logger.debug(`[UserSession] Auto-detect started (interval: ${intervalMs}ms, id: ${intervalId})`);
                return intervalId;
            },
            
            /**
             * Get user info from page
             * Extracts user ID, username, and level from DOM
             * @returns {Object} UserInfo object { userId, username, level }
             */
            getUserInfo() {
                try {
                    const userId = this.getUserId();
                    
                    // Try to extract username
                    const usernameEl = document.querySelector('[data-username], .username, .player-name, #username');
                    const username = usernameEl?.textContent?.trim() || null;
                    
                    // Try to extract level
                    const levelEl = document.querySelector('[data-level], .level, .player-level, #level');
                    const levelText = levelEl?.textContent?.trim();
                    const level = levelText ? numberFromText(levelText) : null;
                    
                    return {
                        userId,
                        username,
                        level
                    };
                } catch (error) {
                    logger.warn(`[UserSession] Failed to get user info: ${error.message}`);
                    return {
                        userId: null,
                        username: null,
                        level: null
                    };
                }
            }
        };
    }

    // ==================== NUMBER FORMATTING SERVICE ====================
    // Centralized number parsing and formatting
    // Eliminates ~50 lines of duplicated code
    
    /**
     * Create centralized number formatting service
     * Provides unified API for number parsing, formatting, and calculations
     * 
     * @returns {Object} Number formatting service
     * 
     * Main methods:
     * @returns {function(string): number|null} parse - Parse number from text
     * @returns {function(number): string} format - Format number with thousands separators
     * @returns {function(number): string} formatCompact - Format number as compact (1.2M, 3.4K)
     * @returns {function(number, number): number} calculateDamageVsDefense - Calculate damage vs defense
     * 
     * @example
     * const numbers = context.numbers;
     * 
     * // Parse numbers
     * numbers.parse('1,234,567 HP');      // 1234567
     * numbers.parse('üí∞ 1,000,000');      // 1000000
     * numbers.parse('Level 50');          // 50
     * 
     * // Format numbers
     * numbers.format(1234567);            // "1,234,567"
     * numbers.formatCompact(1234567);     // "1.23M"
     * numbers.formatCompact(1234);        // "1.23K"
     * 
     * // Calculate damage
     * const damage = numbers.calculateDamageVsDefense(400, 25);
     * // 1000 √ó (ATK - DEF)^0.25
     */
    function createNumberFormattingService() {
        const NUMBER_FORMAT = new Intl.NumberFormat('en-US');
        
        return {
            /**
             * Parse number from text (removes commas, extracts digits)
             * @param {string} text - Text containing number
             * @returns {number|null} Parsed number or null if not found
             */
            parse(text) {
                if (!text) return null;
                
                try {
                    // Normalize whitespace
                    const normalized = String(text).replace(/\s+/g, ' ');
                    
                    // Match digit sequences (with commas, dots, spaces)
                    const match = normalized.match(/[\d][\d.,\s]*/);
                    if (!match) return null;
                    
                    // Remove non-digits
                    const digits = match[0].replace(/[^\d]/g, '');
                    if (!digits) return null;
                    
                    const parsed = parseInt(digits, 10);
                    return Number.isNaN(parsed) ? null : parsed;
                } catch (error) {
                    return null;
                }
            },
            
            /**
             * Format number with thousands separators
             * @param {number} value - Number to format
             * @returns {string} Formatted number (e.g., "1,234,567")
             */
            format(value) {
                if (value === null || value === undefined || Number.isNaN(value)) {
                    return '‚Äî';
                }
                return NUMBER_FORMAT.format(Math.round(value));
            },
            
            /**
             * Format number as compact (1.2M, 3.4K, etc.)
             * @param {number} value - Number to format
             * @returns {string} Compact formatted number
             */
            formatCompact(value) {
                if (value === null || value === undefined || Number.isNaN(value)) {
                    return '‚Äî';
                }
                
                if (value >= 1e9) return (value / 1e9).toFixed(2) + 'B';
                if (value >= 1e6) return (value / 1e6).toFixed(2) + 'M';
                if (value >= 1e3) return (value / 1e3).toFixed(2) + 'K';
                
                return this.format(value);
            },
            
            /**
             * Calculate damage vs defense (game formula)
             * Formula: DMG = 1000 √ó (ATK - DEF)^0.25
             * @param {number} attack - Attack value
             * @param {number} defense - Defense value
             * @returns {number} Calculated damage (0 if ATK <= DEF)
             */
            calculateDamageVsDefense(attack, defense) {
                if (attack <= defense) return 0;
                return Math.round(1000 * Math.pow(attack - defense, 0.25));
            }
        };
    }

    // ==================== UNIFIED LOOT SERVICE ====================
    // Centralized loot management across all game modes (wave, dungeon, single)
    // Provides unified API for looting with level up/stamina checks and detailed modal
    
    /**
     * Create unified loot service
     * Provides unified API for looting monsters across all game modes
     * 
     * @param {Object} context - Script context (logger, http, numbers, etc.)
     * @returns {Object} Unified loot service
     * 
     * Main methods:
     * @returns {function(string, string): Promise<Object>} lootWaveMonster - Loot single wave monster
     * @returns {function(string, string, string): Promise<Object>} lootDungeonMonster - Loot single dungeon monster
     * @returns {function(Array, string): Promise<Object>} lootMultiple - Loot multiple monsters in parallel
     * @returns {function(): Object} createSummary - Create new loot summary object
     * @returns {function(Object, Object): void} updateSummary - Update summary with loot result
     * @returns {function(Object): Object} aggregateByType - Aggregate monsters by type with rates
     * @returns {function(): Object|null} checkLevelUp - Check if player leveled up
     * @returns {function(): boolean} checkStaminaFull - Check if stamina is full
     * @returns {function(Object, string): void} showDetailedModal - Show detailed loot modal
     * 
     * Summary object format:
     * {
     *   drops: number,                 // Total monsters looted
     *   exp: number,                   // Total EXP gained
     *   gold: number,                  // Total gold gained
     *   items: Map<string, Object>,    // Items obtained (key: "name|rarity")
     *   monsters: Map<string, Object>, // Monsters looted (key: monsterName.toLowerCase())
     *   messages: string[]             // Loot messages/errors
     * }
     * 
     * Monster entry format (in summary.monsters Map):
     * {
     *   name: string,      // Display name
     *   exp: number,       // Total EXP from this type
     *   gold: number,      // Total gold from this type
     *   count: number      // Number of monsters looted
     * }
     * 
     * Item entry format (in summary.items Map):
     * {
     *   displayName: string,  // Item name
     *   rarity: string,       // Item rarity (COMMON, RARE, EPIC, LEGENDARY, MYTHICAL)
     *   quantity: number      // Total quantity obtained
     * }
     * 
     * Loot result format:
     * {
     *   success: boolean,
     *   exp: number,
     *   gold: number,
     *   items: Array<{NAME, RARITY, QUANTITY}>,
     *   monsterName: string,
     *   message: string
     * }
     * 
     * @example
     * const loot = context.loot;
     * 
     * // Loot single wave monster
     * const result = await loot.lootWaveMonster('2718588', 'userId123');
     * // { success: true, exp: 3000, gold: 10000, items: [...], monsterName: 'Troll Brawler' }
     * 
     * // Loot multiple monsters
     * const targets = [
     *   { monsterId: '2718588', type: 'wave', name: 'Troll Brawler' },
     *   { dgmid: '456', instanceId: '123', type: 'dungeon', name: 'Dragon' }
     * ];
     * const summary = await loot.lootMultiple(targets, 'userId123');
     * 
     * // Show detailed modal
     * loot.showDetailedModal(summary, 'Wave Farming');
     */
    function createLootService(context) {
        const { logger, http, numbers, notifications, stamina } = context;
        
        // RARITY ICONS AND COLORS
        const RARITY_CONFIG = {
            MYTHICAL: { icon: 'üîÆ', color: '#FF1493', label: 'MYTHICAL' },
            LEGENDARY: { icon: '‚≠ê', color: '#FFD700', label: 'LEGENDARY' },
            EPIC: { icon: 'üíú', color: '#9D5CFF', label: 'EPIC' },
            RARE: { icon: 'üíô', color: '#4A9EFF', label: 'RARE' },
            UNCOMMON: { icon: 'üíö', color: '#4CAF50', label: 'UNCOMMON' },
            COMMON: { icon: '‚ö™', color: '#9E9E9E', label: 'COMMON' }
        };
        
        const RARITY_ORDER = ['MYTHICAL', 'LEGENDARY', 'EPIC', 'RARE', 'UNCOMMON', 'COMMON'];
        
        /**
         * Store initial player XP info for level up detection
         */
        let initialExpInfo = null;
        
        /**
         * Loot single wave monster
         * @param {string} monsterId - Monster ID
         * @param {string} userId - User ID
         * @param {string} monsterName - Monster name (optional, for display)
         * @returns {Promise<Object>} Loot result
         */
        async function lootWaveMonster(monsterId, userId, monsterName = 'Unknown Monster') {
            try {
                logger.debug(`[Loot] Looting wave monster ${monsterId} (${monsterName})...`);
                
                const response = await http.lootMonster(monsterId, userId);
                
                if (!response.success) {
                    return {
                        success: false,
                        exp: 0,
                        gold: 0,
                        items: [],
                        monsterName,
                        message: response.error || 'Failed to loot monster'
                    };
                }
                
                const data = response.data || {};
                const rewards = data.rewards || {};
                const exp = rewards.exp || 0;
                const gold = rewards.gold || 0;
                const damage = rewards.damage_dealt || 0;
                const items = data.items || [];
                
                logger.debug(`[Loot] Wave monster looted: ${monsterName} (+${exp} XP, +${gold} Gold, ${damage} DMG, ${items.length} items)`);
                
                return {
                    success: true,
                    exp,
                    gold,
                    damage,
                    items,
                    monsterName,
                    message: data.message || 'Looted successfully'
                };
            } catch (error) {
                logger.error(`[Loot] Error looting wave monster ${monsterId}: ${error.message}`);
                return {
                    success: false,
                    exp: 0,
                    gold: 0,
                    items: [],
                    monsterName,
                    message: error.message
                };
            }
        }
        
        /**
         * Loot single dungeon monster
         * @param {string} dgmid - Dungeon monster ID
         * @param {string} instanceId - Instance ID
         * @param {string} userId - User ID
         * @param {string} monsterName - Monster name (optional, for display)
         * @returns {Promise<Object>} Loot result
         */
        async function lootDungeonMonster(dgmid, instanceId, userId, monsterName = 'Unknown Monster') {
            try {
                logger.debug(`[Loot] Looting dungeon monster ${dgmid} (instance ${instanceId}, ${monsterName})...`);
                
                const response = await http.lootGuildDungeon(dgmid, instanceId, userId);
                
                if (!response.success) {
                    return {
                        success: false,
                        exp: 0,
                        gold: 0,
                        items: [],
                        monsterName,
                        message: response.error || 'Failed to loot dungeon monster'
                    };
                }
                
                const data = response.data || {};
                const rewards = data.rewards || {};
                const exp = rewards.exp || 0;
                const gold = rewards.gold || 0;
                const damage = rewards.damage_dealt || 0;
                const items = data.items || [];
                
                logger.debug(`[Loot] Dungeon monster looted: ${monsterName} (+${exp} XP, +${gold} Gold, ${damage} DMG, ${items.length} items)`);
                
                return {
                    success: true,
                    exp,
                    gold,
                    damage,
                    items,
                    monsterName,
                    message: data.message || 'Looted successfully'
                };
            } catch (error) {
                logger.error(`[Loot] Error looting dungeon monster ${dgmid}: ${error.message}`);
                return {
                    success: false,
                    exp: 0,
                    gold: 0,
                    items: [],
                    monsterName: 'Unknown',
                    message: error.message
                };
            }
        }
        
        /**
         * Create new loot summary object
         * @returns {Object} Empty summary
         */
        function createSummary() {
            return {
                drops: 0,
                exp: 0,
                gold: 0,
                damage: 0,
                items: new Map(),
                monsters: new Map(),
                messages: []
            };
        }
        
        /**
         * Update summary with loot result
         * @param {Object} summary - Summary object to update
         * @param {Object} result - Loot result from lootWaveMonster/lootDungeonMonster
         */
        function updateSummary(summary, result) {
            if (!result.success) {
                summary.messages.push(result.message);
                return;
            }
            
            // Update totals
            summary.drops += 1;
            summary.exp += result.exp;
            summary.gold += result.gold;
            summary.damage += result.damage || 0;
            
            // Update monster stats
            const monsterKey = result.monsterName.toLowerCase();
            const existing = summary.monsters.get(monsterKey);
            
            if (existing) {
                existing.count += 1;
                existing.exp += result.exp;
                existing.gold += result.gold;
                existing.damage += result.damage || 0;
            } else {
                summary.monsters.set(monsterKey, {
                    name: result.monsterName,
                    exp: result.exp,
                    gold: result.gold,
                    damage: result.damage || 0,
                    count: 1
                });
            }
            
            // Update items (TIER field, not RARITY!)
            for (const item of result.items) {
                const itemName = item.NAME || item.name || 'Unknown Item';
                const itemRarity = (item.TIER || item.tier || item.RARITY || item.rarity || 'COMMON').toUpperCase();
                const itemQuantity = item.QUANTITY || item.quantity || 1;
                const itemDropRatio = item.DROP_RATIO || item.drop_ratio || null;
                const itemKey = `${itemName}|${itemRarity}`;
                
                const existingItem = summary.items.get(itemKey);
                if (existingItem) {
                    existingItem.quantity += itemQuantity;
                } else {
                    summary.items.set(itemKey, {
                        displayName: itemName,
                        rarity: itemRarity,
                        quantity: itemQuantity,
                        dropRatio: itemDropRatio
                    });
                }
            }
        }
        
        /**
         * Loot multiple monsters in parallel batches
         * @param {Array} targets - Array of target objects { monsterId/dgmid, type, name, instanceId? }
         * @param {string} userId - User ID
         * @param {Object} options - Options { batchSize: number, checkLevelUp: boolean, checkStamina: boolean }
         * @returns {Promise<Object>} Summary object
         */
        async function lootMultiple(targets, userId, options = {}) {
            const {
                batchSize = 10,
                checkLevelUp = true,
                checkStamina = true
            } = options;
            
            const summary = createSummary();
            
            // Store initial XP for level up detection
            if (checkLevelUp) {
                initialExpInfo = getPlayerExpInfo();
            }
            
            logger.info(`[Loot] Starting batch loot: ${targets.length} targets, batch size ${batchSize}`);
            
            // Process in batches
            for (let i = 0; i < targets.length; i += batchSize) {
                const batch = targets.slice(i, i + batchSize);
                
                // Check level up between batches
                if (checkLevelUp && i > 0 && initialExpInfo) {
                    const levelUpInfo = checkLevelUpInternal();
                    if (levelUpInfo.leveledUp) {
                        logger.info(`üéâ LEVEL UP detectado! Parando loot... (Batch ${Math.floor(i / batchSize) + 1})`);
                        summary.messages.push('‚ö†Ô∏è Loot stopped: Level up detected');
                        break;
                    }
                }
                
                // Check stamina full
                if (checkStamina) {
                    const staminaFull = checkStaminaFullInternal();
                    if (staminaFull) {
                        logger.info(`‚ö° Stamina recuperada! Parando loot... (Batch ${Math.floor(i / batchSize) + 1})`);
                        summary.messages.push('‚ö†Ô∏è Loot stopped: Stamina full recovered');
                        break;
                    }
                }
                
                logger.debug(`[Loot] Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(targets.length / batchSize)}...`);
                
                // Loot batch in parallel
                const promises = batch.map(target => {
                    if (target.type === 'dungeon') {
                        return lootDungeonMonster(target.dgmid, target.instanceId, userId, target.name);
                    } else {
                        return lootWaveMonster(target.monsterId, userId, target.name);
                    }
                });
                
                const results = await Promise.all(promises);
                
                // Update summary
                for (const result of results) {
                    updateSummary(summary, result);
                }
                
                // Small delay between batches
                if (i + batchSize < targets.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            logger.info(`[Loot] Batch loot complete: ${summary.drops}/${targets.length} looted, +${summary.exp} XP, +${summary.gold} Gold`);
            
            return summary;
        }
        
        /**
         * Get player XP info for level up detection
         * @returns {Object|null} { currentExp, maxExp, percent }
         */
        function getPlayerExpInfo() {
            try {
                // Strategy 1: Look for .gtb-exp-top (new UI)
                const gtbExpTop = document.querySelector('.gtb-exp-top');
                if (gtbExpTop) {
                    const text = gtbExpTop.textContent;
                    const match = text.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                    if (match) {
                        const currentExp = numbers.parse(match[1]);
                        const maxExp = numbers.parse(match[2]);
                        const percent = maxExp > 0 ? Math.round((currentExp / maxExp) * 100) : 0;
                        
                        logger.debug(`[Loot] XP parsed from .gtb-exp-top: ${currentExp} / ${maxExp}`);
                        return { currentExp, maxExp, percent };
                    }
                }
                
                // Strategy 2: Look for .gtb-exp or .exp-bar
                const expBar = document.querySelector('.gtb-exp, .exp-bar, [class*="exp"]');
                if (expBar) {
                    const text = expBar.textContent;
                    const match = text.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                    if (match) {
                        const currentExp = numbers.parse(match[1]);
                        const maxExp = numbers.parse(match[2]);
                        const percent = maxExp > 0 ? Math.round((currentExp / maxExp) * 100) : 0;
                        
                        logger.debug(`[Loot] XP parsed from exp bar: ${currentExp} / ${maxExp}`);
                        return { currentExp, maxExp, percent };
                    }
                }
                
                // Strategy 3: Fallback to searching all elements (original logic)
                const expElements = Array.from(document.querySelectorAll('*')).filter(el => {
                    const text = el.textContent;
                    return text && /\d+[\s,]*\/[\s,]*\d+/.test(text) && 
                           (text.toLowerCase().includes('exp') || text.toLowerCase().includes('xp'));
                });
                
                if (expElements.length > 0) {
                    const text = expElements[0].textContent;
                    const match = text.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                    if (match) {
                        const currentExp = numbers.parse(match[1]);
                        const maxExp = numbers.parse(match[2]);
                        const percent = maxExp > 0 ? Math.round((currentExp / maxExp) * 100) : 0;
                        
                        logger.debug(`[Loot] XP parsed from fallback: ${currentExp} / ${maxExp}`);
                        return { currentExp, maxExp, percent };
                    }
                }
                
                return null;
            } catch (error) {
                logger.warn(`[Loot] Failed to get player XP info: ${error.message}`);
                return null;
            }
        }
        
        /**
         * Check if player leveled up (internal)
         * @returns {Object} { leveledUp: boolean, oldExp, newExp }
         */
        function checkLevelUpInternal() {
            if (!initialExpInfo) {
                return { leveledUp: false };
            }
            
            const currentExpInfo = getPlayerExpInfo();
            if (!currentExpInfo) {
                return { leveledUp: false };
            }
            
            // Level up detection: current XP dropped OR max XP increased
            const leveledUp = currentExpInfo.currentExp < initialExpInfo.currentExp ||
                            currentExpInfo.maxExp > initialExpInfo.maxExp;
            
            return {
                leveledUp,
                oldExp: initialExpInfo,
                newExp: currentExpInfo
            };
        }
        
        /**
         * Check if stamina is full (internal)
         * @returns {boolean} True if stamina is at maximum
         */
        function checkStaminaFullInternal() {
            try {
                // Use context.stamina service (from Phase 1)
                if (!context.stamina || typeof context.stamina.read !== 'function') {
                    return false;
                }
                
                const staminaInfo = context.stamina.read();
                if (!staminaInfo) return false;
                
                return staminaInfo.current >= staminaInfo.max;
            } catch (error) {
                logger.warn(`[Loot] Failed to check stamina: ${error.message}`);
                return false;
            }
        }
        
        /**
         * Aggregate monsters by type with rate calculations
         * @param {Object} summary - Summary object
         * @returns {Array} Array of { name, count, exp, gold, damage, expRate, goldRate, damageRate }
         */
        function aggregateByType(summary) {
            const aggregated = [];
            
            for (const [key, monster] of summary.monsters) {
                aggregated.push({
                    name: monster.name,
                    count: monster.count,
                    exp: monster.exp,
                    gold: monster.gold,
                    damage: monster.damage || 0,
                    expRate: monster.count > 0 ? Math.round(monster.exp / monster.count) : 0,
                    goldRate: monster.count > 0 ? Math.round(monster.gold / monster.count) : 0,
                    damageRate: monster.count > 0 ? Math.round(monster.damage / monster.count) : 0
                });
            }
            
            // Sort by count descending
            aggregated.sort((a, b) => b.count - a.count);
            
            return aggregated;
        }
        
        /**
         * Show detailed loot modal with per-type statistics
         * @param {Object} summary - Summary object
         * @param {string} scope - Scope label (e.g., 'Wave Farming', 'Dungeon Clearing')
         */
        function showDetailedModal(summary, scope = 'Loot Session') {
            try {
                // Build monster statistics table
                const monsterStats = aggregateByType(summary);
                let monsterTable = '';
                
                if (monsterStats.length > 0) {
                    monsterTable = '<table style="width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 11px;">';
                    monsterTable += '<thead><tr style="background: #2a2a2a; border-bottom: 2px solid #444;">';
                    monsterTable += '<th style="padding: 5px; text-align: left;">Monster</th>';
                    monsterTable += '<th style="padding: 5px; text-align: center;">Qty</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">XP</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">XP/Mob</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">Gold</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">Gold/Mob</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">Damage</th>';
                    monsterTable += '<th style="padding: 5px; text-align: right;">DMG/Mob</th>';
                    monsterTable += '</tr></thead><tbody>';
                    
                    for (const monster of monsterStats) {
                        monsterTable += '<tr style="border-bottom: 1px solid #333;">';
                        monsterTable += `<td style="padding: 6px; font-weight: bold;">${monster.name}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: center; color: #4a90e2;">${monster.count}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #50fa7b;">${numbers.format(monster.exp)}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #8be9fd;">${numbers.format(monster.expRate)}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #f1fa8c;">${numbers.format(monster.gold)}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #ffb86c;">${numbers.format(monster.goldRate)}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #ff79c6;">${numbers.format(monster.damage)}</td>`;
                        monsterTable += `<td style="padding: 6px; text-align: right; color: #bd93f9;">${numbers.format(monster.damageRate)}</td>`;
                        monsterTable += '</tr>';
                    }
                    
                    monsterTable += '</tbody></table>';
                }
                
                // Build items list grouped by rarity
                let itemsList = '';
                
                if (summary.items.size > 0) {
                    // Group items by rarity
                    const itemsByRarity = {};
                    for (const rarity of RARITY_ORDER) {
                        itemsByRarity[rarity] = [];
                    }
                    
                    for (const [key, item] of summary.items) {
                        const rarity = item.rarity.toUpperCase();
                        if (itemsByRarity[rarity]) {
                            itemsByRarity[rarity].push(item);
                        } else {
                            itemsByRarity['COMMON'].push(item);
                        }
                    }
                    
                    // Build HTML for each rarity
                    for (const rarity of RARITY_ORDER) {
                        const items = itemsByRarity[rarity];
                        if (items.length === 0) continue;
                        
                        const config = RARITY_CONFIG[rarity] || RARITY_CONFIG.COMMON;
                        itemsList += `<div style="margin: 10px 0;">`;
                        itemsList += `<div style="font-weight: bold; color: ${config.color}; margin-bottom: 5px;">`;
                        itemsList += `${config.icon} [${config.label}]</div>`;
                        itemsList += '<ul style="margin: 0; padding-left: 20px;">';
                        
                        for (const item of items) {
                            const dropInfo = item.dropRatio !== null && item.dropRatio !== undefined 
                                ? ` <span style="color: #ffb86c; font-size: 10px;">(${item.dropRatio}%)</span>` 
                                : '';
                            itemsList += `<li style="margin: 3px 0;">${item.displayName} <span style="color: #888;">x${item.quantity}</span>${dropInfo}</li>`;
                        }
                        
                        itemsList += '</ul></div>';
                    }
                }
                
                // Build complete modal HTML
                const modalHTML = `
                    <div style="font-family: Arial, sans-serif; color: #fff;">
                        <h2 style="margin: 0 0 15px 0; padding: 0; font-size: 20px; border-bottom: 2px solid #444; padding-bottom: 10px;">
                            üéÅ ${scope} - Loot Summary
                        </h2>
                        
                        ${monsterStats.length > 0 ? `
                            <div style="margin: 15px 0;">
                                <h3 style="font-size: 16px; margin: 0 0 10px 0;">Monstros Loteados por Tipo:</h3>
                                ${monsterTable}
                            </div>
                        ` : ''}
                        
                        <div style="background: #1a1a1a; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <h3 style="font-size: 16px; margin: 0 0 10px 0;">TOTAIS:</h3>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
                                <div>
                                    <div style="color: #888; font-size: 11px;">Loots</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #4a90e2;">${summary.drops}</div>
                                </div>
                                <div>
                                    <div style="color: #888; font-size: 11px;">EXP</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #50fa7b;">${numbers.format(summary.exp)}</div>
                                </div>
                                <div>
                                    <div style="color: #888; font-size: 11px;">Gold</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #f1fa8c;">${numbers.format(summary.gold)}</div>
                                </div>
                                <div>
                                    <div style="color: #888; font-size: 11px;">Damage</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #ff79c6;">${numbers.format(summary.damage)}</div>
                                </div>
                            </div>
                            ${summary.damage > 0 ? `
                            <div style="margin-top: 10px; padding: 8px; background: #2a2a2a; border-radius: 4px; font-size: 11px; color: #888; text-align: center;">
                                üìä Efici√™ncia: <span style="color: #8be9fd;">${(summary.exp / summary.damage).toFixed(3)} XP/HP</span> | <span style="color: #ffb86c;">${(summary.gold / summary.damage).toFixed(5)} Gold/HP</span>
                            </div>
                            ` : ''}
                        </div>
                        
                        ${itemsList ? `
                            <div style="margin: 15px 0;">
                                <h3 style="font-size: 16px; margin: 0 0 10px 0; padding-top: 10px; border-top: 1px solid #444;">ITENS OBTIDOS:</h3>
                                ${itemsList}
                            </div>
                        ` : '<div style="color: #888; font-style: italic; margin: 15px 0;">Nenhum item obtido.</div>'}
                        
                        ${summary.messages.length > 0 ? `
                            <div style="margin: 15px 0; padding: 10px; background: #2a2a2a; border-radius: 5px; border-left: 3px solid #FFD700;">
                                ${summary.messages.map(msg => `<div style="margin: 3px 0;">‚ö†Ô∏è ${msg}</div>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
                
                // Show modal using floating helpers module
                const floatingHelpers = context.moduleRegistry?.getModule('floatingHelpers');
                if (floatingHelpers && typeof floatingHelpers.openQuickLootModal === 'function') {
                    // Pass summary directly - openQuickLootModal expects Map objects
                    floatingHelpers.openQuickLootModal(context, summary, scope);
                } else {
                    // Fallback: use notification
                    notifications.success(`Loot complete: ${summary.drops} monsters, +${numbers.format(summary.exp)} XP, +${numbers.format(summary.gold)} Gold`, 8000);
                }
                
            } catch (error) {
                logger.error(`[Loot] Failed to show detailed modal: ${error.message}`);
                // Fallback notification
                notifications.success(
                    `Loot: ${summary.drops} monsters, +${numbers.format(summary.exp)} XP, +${numbers.format(summary.gold)} Gold`,
                    5000
                );
            }
        }
        
        // ========== OPTIMIZED LOOT METHODS (Cloudflare-proof) ==========
        
        /**
         * Loot wave monster using optimized fetch (Cloudflare-proof)
         * Same API as lootWaveMonster but uses fetchDirect internally
         * @param {string} monsterId - Monster ID
         * @param {string} userId - User ID
         * @param {string} monsterName - Monster name (optional)
         * @returns {Promise<Object>} Loot result
         */
        async function lootWaveMonsterDirect(monsterId, userId, monsterName = 'Unknown Monster') {
            try {
                logger.debug(`[Loot:Direct] Looting wave monster ${monsterId} (${monsterName})...`);
                
                const referrer = `https://demonicscans.org/battle.php?id=${monsterId}`;
                const response = await http.lootMonsterDirect(monsterId, userId, referrer);
                
                if (!response.success) {
                    return {
                        success: false,
                        exp: 0,
                        gold: 0,
                        items: [],
                        monsterName,
                        message: response.message || 'Failed to loot'
                    };
                }
                
                const data = response.data || {};
                const rewards = data.rewards || {};
                const exp = rewards.exp || 0;
                const gold = rewards.gold || 0;
                const damage = rewards.damage_dealt || 0;
                const items = data.items || [];
                
                logger.debug(`[Loot:Direct] Looted: ${monsterName} (+${exp} XP, +${gold} Gold, ${damage} DMG, ${items.length} items)`);
                
                return {
                    success: true,
                    exp,
                    gold,
                    damage,
                    items,
                    monsterName,
                    message: data.message || 'Looted successfully'
                };
            } catch (error) {
                logger.error(`[Loot:Direct] Error: ${error.message}`);
                return {
                    success: false,
                    exp: 0,
                    gold: 0,
                    items: [],
                    monsterName,
                    message: error.message
                };
            }
        }
        
        /**
         * Loot dungeon monster using optimized fetch (Cloudflare-proof)
         * TODO: Verify body format when example is available
         * @param {string} dgmid - Dungeon monster ID
         * @param {string} instanceId - Instance ID
         * @param {string} userId - User ID
         * @param {string} monsterName - Monster name (optional)
         * @returns {Promise<Object>} Loot result
         */
        async function lootDungeonMonsterDirect(dgmid, instanceId, userId, monsterName = 'Unknown Monster') {
            try {
                logger.debug(`[Loot:Direct] Looting dungeon monster ${dgmid} (instance ${instanceId}, ${monsterName})...`);
                
                const referrer = `https://demonicscans.org/guild_dungeon_location.php?instance_id=${instanceId}`;
                const response = await http.lootDungeonMonsterDirect(dgmid, instanceId, userId, referrer);
                
                if (!response.success) {
                    return {
                        success: false,
                        exp: 0,
                        gold: 0,
                        items: [],
                        monsterName,
                        message: response.message || 'Failed to loot dungeon'
                    };
                }
                
                const data = response.data || {};
                const rewards = data.rewards || {};
                const exp = rewards.exp || 0;
                const gold = rewards.gold || 0;
                const damage = rewards.damage_dealt || 0;
                const items = data.items || [];
                
                logger.debug(`[Loot:Direct] Dungeon looted: ${monsterName} (+${exp} XP, +${gold} Gold, ${damage} DMG, ${items.length} items)`);
                
                return {
                    success: true,
                    exp,
                    gold,
                    damage,
                    items,
                    monsterName,
                    message: data.message || 'Looted successfully'
                };
            } catch (error) {
                logger.error(`[Loot:Direct] Error: ${error.message}`);
                return {
                    success: false,
                    exp: 0,
                    gold: 0,
                    items: [],
                    monsterName,
                    message: error.message
                };
            }
        }
        
        return {
            lootWaveMonster,
            lootDungeonMonster,
            lootMultiple,
            createSummary,
            updateSummary,
            aggregateByType,
            showDetailedModal,
            
            // Optimized methods (Cloudflare-proof)
            lootWaveMonsterDirect,
            lootDungeonMonsterDirect,
            
            // Public wrappers for checks
            checkLevelUp() {
                initialExpInfo = getPlayerExpInfo();
                return checkLevelUpInternal();
            },
            
            checkStaminaFull() {
                return checkStaminaFullInternal();
            },
            
            // üÜï Expor getPlayerExpInfo para uso externo (evitar duplica√ß√£o)
            getPlayerExpInfo() {
                return getPlayerExpInfo();
            },
            
            // Utility: reset initial XP (call before starting new loot session)
            resetLevelUpCheck() {
                initialExpInfo = getPlayerExpInfo();
                logger.debug('[Loot] Level up check reset');
            }
        };
    }

    // ==================== DATA EXTRACTOR SERVICE ====================
    // Centralized data extraction from stats/pets/inventory pages
    // Provides unified API for reading player data
    
    /**
     * Create data extractor service
     * Extracts player stats, pets, and equipment from DOM
     * 
     * @param {Object} context - Script context
     * @returns {Object} Data extractor service
     * 
     * @example
     * const extractor = context.dataExtractor;
     * 
     * // Extract all data
     * const data = await extractor.extractAll();
     * // { stats: {...}, pets: {...}, equipment: {...} }
     * 
     * // Extract specific data
     * const stats = await extractor.extractStats();
     * const pets = await extractor.extractPets();
     * const equipment = await extractor.extractEquipment();
     */
    function createDataExtractorService(context) {
        const { logger, http, storage } = context;
        const CACHE_TTL_MS = 3600000; // 1 hour
        
        // Cache keys
        const CACHE_KEYS = {
            stats: 'dataExtractor.stats',
            pets: 'dataExtractor.pets',
            equipment: 'dataExtractor.equipment'
        };
        
        /**
         * Check if cached data is still valid
         */
        function isCacheValid(key) {
            const cached = storage.get(key);
            if (!cached || !cached.timestamp) return false;
            return (Date.now() - cached.timestamp) < CACHE_TTL_MS;
        }
        
        /**
         * Extract base stats from stats.php
         * @returns {Promise<Object>} { base_attack, base_defense, max_stamina, current_stamina, level }
         */
        async function extractStats() {
            logger.debug('üîç Extracting player stats...');
            
            // Check cache first
            if (isCacheValid(CACHE_KEYS.stats)) {
                const cached = storage.get(CACHE_KEYS.stats);
                logger.debug('‚úÖ Using cached stats data');
                return cached.data;
            }
            
            try {
                // Fetch stats page HTML
                const response = await fetch('https://demonicscans.org/stats.php', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Extract base stats from stat cards
                const stats = {
                    base_attack: 0,
                    base_defense: 0,
                    max_stamina: 0,
                    current_stamina: 0,
                    level: 0,
                    unspent_points: 0
                };
                
                // Strategy 1: Find stat values in "Current Stats" section using regex
                const bodyText = doc.body.textContent;
                
                // Extract from "Current Stats" section - values appear directly after labels (no space)
                // Pattern: "ATTACK1110" or "ATTACK 1110" or "ATTACK\n1110"
                const attackMatch = bodyText.match(/ATTACK\s*(\d[\d,]*)/);
                const defenseMatch = bodyText.match(/DEFENSE\s*(\d[\d,]*)/);
                const staminaMatch = bodyText.match(/MAX STAMINA\s*(\d[\d,]*)/);
                
                if (attackMatch) {
                    stats.base_attack = parseInt(attackMatch[1].replace(/,/g, '')) || 0;
                }
                if (defenseMatch) {
                    stats.base_defense = parseInt(defenseMatch[1].replace(/,/g, '')) || 0;
                }
                if (staminaMatch) {
                    stats.max_stamina = parseInt(staminaMatch[1].replace(/,/g, '')) || 0;
                }
                
                // Strategy 2: If regex fails, use DOM traversal
                if (stats.base_attack === 0) {
                    const allElements = Array.from(doc.querySelectorAll('*'));
                    
                    // Find "Current Stats" section
                    const currentStatsHeading = allElements.find(el => 
                        el.textContent.includes('üìà Current Stats') || 
                        el.textContent.includes('Current Stats')
                    );
                    
                    if (currentStatsHeading) {
                        const statsSection = currentStatsHeading.closest('div') || currentStatsHeading.parentElement;
                        if (statsSection) {
                            // Extract ATTACK
                            const attackLabel = Array.from(statsSection.querySelectorAll('*')).find(el => 
                                el.textContent.trim() === 'ATTACK'
                            );
                            if (attackLabel && attackLabel.nextElementSibling) {
                                const value = attackLabel.nextElementSibling.textContent.trim().replace(/['"]/g, '');
                                stats.base_attack = parseInt(value.replace(/,/g, '')) || 0;
                            }
                            
                            // Extract DEFENSE
                            const defenseLabel = Array.from(statsSection.querySelectorAll('*')).find(el => 
                                el.textContent.trim() === 'DEFENSE'
                            );
                            if (defenseLabel && defenseLabel.nextElementSibling) {
                                const value = defenseLabel.nextElementSibling.textContent.trim().replace(/['"]/g, '');
                                stats.base_defense = parseInt(value.replace(/,/g, '')) || 0;
                            }
                            
                            // Extract MAX STAMINA
                            const staminaLabel = Array.from(statsSection.querySelectorAll('*')).find(el => 
                                el.textContent.trim() === 'MAX STAMINA'
                            );
                            if (staminaLabel && staminaLabel.nextElementSibling) {
                                const value = staminaLabel.nextElementSibling.textContent.trim().replace(/['"]/g, '');
                                stats.max_stamina = parseInt(value.replace(/,/g, '')) || 0;
                            }
                        }
                    }
                }
                
                // Extract current stamina from top bar
                const staminaText = bodyText.match(/üí™\s*(\d[\d,]*)\s*\/\s*(\d[\d,]*)/);
                if (staminaText) {
                    stats.current_stamina = parseInt(staminaText[1].replace(/,/g, '')) || 0;
                    // Also update max_stamina from top bar if not found
                    if (stats.max_stamina === 0) {
                        stats.max_stamina = parseInt(staminaText[2].replace(/,/g, '')) || 0;
                    }
                }
                
                // Extract level
                const levelText = bodyText.match(/LV\s*(\d+)/i);
                if (levelText) {
                    stats.level = parseInt(levelText[1]) || 0;
                }
                
                // Extract unspent points
                const unspentText = bodyText.match(/Unspent Points[\s\S]*?(\d+)/i);
                if (unspentText) {
                    stats.unspent_points = parseInt(unspentText[1]) || 0;
                }
                
                logger.info(`üìä Extracted stats: ATK ${stats.base_attack}, DEF ${stats.base_defense}, STAM ${stats.max_stamina}`);
                
                // Cache result
                storage.set(CACHE_KEYS.stats, {
                    data: stats,
                    timestamp: Date.now()
                });
                
                return stats;
            } catch (error) {
                logger.error('‚ùå Failed to extract stats', { error });
                return {
                    base_attack: 0,
                    base_defense: 0,
                    max_stamina: 0,
                    current_stamina: 0,
                    level: 0,
                    unspent_points: 0
                };
            }
        }
        
        /**
         * Parse effect text to extract all bonus types
         * @param {string} effectText - Raw effect text from pet card
         * @returns {Object} Parsed effects with numeric values
         */
        function parseEffects(effectText) {
            const effects = {
                // PvM Effects
                extra_damage_monsters: 0,      // % extra damage to monsters
                armor_penetration: 0,          // % armor penetration
                heal_on_damage: 0,             // % heal on damage received
                
                // Universal Effects
                stamina_save: 0,               // % chance to not consume stamina/tokens
                crit_rate: 0,                  // % critical rate increase
                crit_damage: 0,                // % critical damage increase
                stamina_cost_mult: 1.0,        // Multiplier for stamina cost (default 1.0)
                
                // PvP Effects
                atk_def_swap: 0,               // % ATK/DEF swap
                steal_stat: 0,                 // % steal opponent stat
                team_conversion: 0,            // % conversion between teams
                def_boost: 0,                  // % DEF boost (defender)
                
                // Metadata
                is_pve_only: false,
                is_pvp_only: false,
                is_universal: false
            };
            
            if (!effectText) return effects;
            
            const lower = effectText.toLowerCase();
            
            // Detect scope
            if (lower.includes('pve only') || lower.includes('pvm only')) {
                effects.is_pve_only = true;
            } else if (lower.includes('pvp only')) {
                effects.is_pvp_only = true;
            } else {
                effects.is_universal = true;
            }
            
            // Parse PvM effects
            const extraDmgMatch = effectText.match(/(\d+(?:\.\d+)?)\s*%\s*(?:Extra Damage To Monsters|extra damage to monsters)/i);
            if (extraDmgMatch) effects.extra_damage_monsters = parseFloat(extraDmgMatch[1]);
            
            const armorPenMatch = effectText.match(/Armor Penetration\s+by\s+(\d+(?:\.\d+)?)\s*%/i);
            if (armorPenMatch) effects.armor_penetration = parseFloat(armorPenMatch[1]);
            
            const healMatch = effectText.match(/Heals?\s+You\s+by\s+(\d+(?:\.\d+)?)\s*%/i);
            if (healMatch) effects.heal_on_damage = parseFloat(healMatch[1]);
            
            // Parse universal effects
            const staminaSaveMatch = effectText.match(/(\d+(?:\.\d+)?)\s*%\s*Your\s+attacks\s+won'?t\s+consume/i);
            if (staminaSaveMatch) effects.stamina_save = parseFloat(staminaSaveMatch[1]);
            
            const critRateMatch = effectText.match(/Critical\s+Rate\s+By\s+(\d+(?:\.\d+)?)\s*%/i);
            if (critRateMatch) effects.crit_rate = parseFloat(critRateMatch[1]);
            
            const critDmgMatch = effectText.match(/Critical\s+Damage\s+By\s+(\d+(?:\.\d+)?)\s*%/i);
            if (critDmgMatch) effects.crit_damage = parseFloat(critDmgMatch[1]);
            
            const staminaCostMatch = effectText.match(/stamina\s+cost\s+by\s+x(\d+(?:\.\d+)?)/i);
            if (staminaCostMatch) effects.stamina_cost_mult = parseFloat(staminaCostMatch[1]);
            
            // Parse PvP effects
            const swapMatch = effectText.match(/swap\s+(\d+(?:\.\d+)?)\s*%/i);
            if (swapMatch) effects.atk_def_swap = parseFloat(swapMatch[1]);
            
            const stealMatch = effectText.match(/steal\s+(\d+(?:\.\d+)?)\s*%/i);
            if (stealMatch) effects.steal_stat = parseFloat(stealMatch[1]);
            
            const conversionMatch = effectText.match(/increase.*?by\s+(\d+(?:\.\d+)?)\s*%\s+of/i);
            if (conversionMatch) effects.team_conversion = parseFloat(conversionMatch[1]);
            
            const defBoostMatch = effectText.match(/\+\s*(\d+(?:\.\d+)?)\s*%\s*DEF/i);
            if (defBoostMatch) effects.def_boost = parseFloat(defBoostMatch[1]);
            
            return effects;
        }
        
        /**
         * Extract pets from pets.php
         * @returns {Promise<Object>} { equipped_attack_team, total_attack_pets_atk, total_attack_pets_def, available_pets }
         */
        async function extractPets() {
            logger.debug('üîç Extracting pets data...');
            
            // Check cache first
            if (isCacheValid(CACHE_KEYS.pets)) {
                const cached = storage.get(CACHE_KEYS.pets);
                logger.debug('‚úÖ Using cached pets data');
                return cached.data;
            }
            
            try {
                // Fetch pets page HTML
                const response = await fetch('https://demonicscans.org/pets.php', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                const pets = {
                    equipped_attack_team: [],
                    total_attack_pets_atk: 0,
                    total_attack_pets_def: 0,
                    pvm_damage_bonus_percent: 0,  // Total PvM damage bonus from pets
                    available_pets: []
                };
                
                // Extract pet names from DOM (img alt attributes)
                const allPetImages = Array.from(doc.querySelectorAll('img[alt]')).filter(img => {
                    const text = img.parentElement?.parentElement?.textContent || '';
                    return text.includes('Lv.') && text.includes('ATK');
                });
                
                const bodyText = doc.body.textContent;
                
                // Find equipped pets section
                const equippedMatch = bodyText.match(/‚öîÔ∏è Equipped Pets ‚Äî Attack Team([\s\S]*?)(?:üêæ Pet Inventory|$)/);
                
                if (equippedMatch) {
                    const equippedSection = equippedMatch[1];
                    
                    // Split by pet cards (using stars as delimiter)
                    const petBlocks = equippedSection.split(/‚òÖ+/);
                    let petIndex = 0;
                    
                    for (const block of petBlocks) {
                        if (!block.trim()) continue;
                        
                        // Extract name from DOM img alt
                        let name = 'Unknown Pet';
                        if (petIndex < allPetImages.length) {
                            name = allPetImages[petIndex].alt;
                            petIndex++;
                        }
                        
                        // Extract stats: "üß™ Lv. 80 | üî™ 703 ATK | üõ°Ô∏è 703 DEF"
                        const statsMatch = block.match(/üß™\s*Lv\.\s*(\d+)\s*\|\s*üî™\s*(\d+)\s*ATK\s*\|\s*üõ°Ô∏è\s*(\d+)\s*DEF/);
                        if (!statsMatch) continue;
                        
                        const level = parseInt(statsMatch[1]) || 0;
                        const attack = parseInt(statsMatch[2]) || 0;
                        const defense = parseInt(statsMatch[3]) || 0;
                        
                        // Extract effects: "‚ö° 24.8% Extra Damage To Monsters"
                        const effectsMatch = block.match(/‚ö°\s*([^\n]+)/);
                        const effectText = effectsMatch ? effectsMatch[1].trim() : '';
                        
                        // Parse all effect types using comprehensive patterns
                        const effects = parseEffects(effectText);
                        
                        // Accumulate PvM damage bonus
                        if (effects.extra_damage_monsters > 0) {
                            pets.pvm_damage_bonus_percent += effects.extra_damage_monsters;
                        }
                        
                        pets.equipped_attack_team.push({
                            name,
                            level,
                            attack,
                            defense,
                            effect: effectText,
                            parsed_effects: effects
                        });
                        
                        pets.total_attack_pets_atk += attack;
                        pets.total_attack_pets_def += defense;
                    }
                }
                
                // Parse ALL available pets (including inventory)
                const inventoryMatch = bodyText.match(/üêæ Pet Inventory([\s\S]*?)(?:ü•ö Eggs|$)/);
                
                if (inventoryMatch) {
                    const inventorySection = inventoryMatch[1];
                    const petBlocks = inventorySection.split(/‚òÖ+/);
                    
                    // Continue from where equipped pets ended
                    let petIndex = pets.equipped_attack_team.length;
                    
                    for (const block of petBlocks) {
                        if (!block.trim()) continue;
                        
                        // Extract name from DOM img alt (skip already used equipped pets)
                        let name = 'Unknown Pet';
                        if (petIndex < allPetImages.length) {
                            name = allPetImages[petIndex].alt;
                            petIndex++;
                        }
                        
                        const statsMatch = block.match(/üß™\s*Lv\.\s*(\d+)\s*\|\s*üî™\s*(\d+)\s*ATK\s*\|\s*üõ°Ô∏è\s*(\d+)\s*DEF/);
                        if (!statsMatch) continue;
                        
                        const level = parseInt(statsMatch[1]) || 0;
                        const attack = parseInt(statsMatch[2]) || 0;
                        const defense = parseInt(statsMatch[3]) || 0;
                        
                        const effectsMatch = block.match(/‚ö°\s*([^\n]+)/);
                        const effectText = effectsMatch ? effectsMatch[1].trim() : '';
                        const effects = parseEffects(effectText);
                        
                        // Only add if not already in equipped list
                        const alreadyEquipped = pets.equipped_attack_team.some(p => p.name === name && p.level === level);
                        if (!alreadyEquipped) {
                            pets.available_pets.push({
                                name,
                                level,
                                attack,
                                defense,
                                effect: effectText,
                                parsed_effects: effects
                            });
                        }
                    }
                }
                
                logger.info(`üêæ Extracted pets: ${pets.equipped_attack_team.length} equipped, ${pets.available_pets.length} available (ATK ${pets.total_attack_pets_atk}, DEF ${pets.total_attack_pets_def})`);
                
                // Cache result
                storage.set(CACHE_KEYS.pets, {
                    data: pets,
                    timestamp: Date.now()
                });
                
                return pets;
            } catch (error) {
                logger.error('‚ùå Failed to extract pets', { error });
                return {
                    equipped_attack_team: [],
                    total_attack_pets_atk: 0,
                    total_attack_pets_def: 0,
                    available_pets: []
                };
            }
        }
        
        /**
         * Extract equipment from inventory.php
         * @returns {Promise<Object>} { equipped_attack_set, total_equipped_atk, total_equipped_def }
         */
        async function extractEquipment() {
            logger.debug('üîç Extracting equipment data...');
            
            // Check cache first
            if (isCacheValid(CACHE_KEYS.equipment)) {
                const cached = storage.get(CACHE_KEYS.equipment);
                logger.debug('‚úÖ Using cached equipment data');
                return cached.data;
            }
            
            try {
                // Fetch inventory page HTML
                const response = await fetch('https://demonicscans.org/inventory.php', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Get manual bonuses from config (auto-extraction not possible)
                const manualBonuses = context.config.get('equipmentBonuses');
                
                // Use defaults if config doesn't exist yet
                const defaultBonuses = {
                    extra_damage_monsters: 28,
                    armor_penetration: 0,
                    crit_rate: 0,
                    crit_damage: 0,
                    stamina_save: 0,
                    heal_on_damage: 0
                };
                
                const bonuses = manualBonuses || defaultBonuses;
                
                logger.debug(`üì¶ Equipment bonuses from config: Extra DMG ${bonuses.extra_damage_monsters}%`);
                
                const equipment = {
                    equipped_attack_set: {},
                    total_equipped_atk: 0,
                    total_equipped_def: 0,
                    equipment_effects: {
                        extra_damage_monsters: bonuses.extra_damage_monsters ?? defaultBonuses.extra_damage_monsters,
                        armor_penetration: bonuses.armor_penetration ?? defaultBonuses.armor_penetration,
                        crit_rate: bonuses.crit_rate ?? defaultBonuses.crit_rate,
                        crit_damage: bonuses.crit_damage ?? defaultBonuses.crit_damage,
                        stamina_save: bonuses.stamina_save ?? defaultBonuses.stamina_save,
                        heal_on_damage: bonuses.heal_on_damage ?? defaultBonuses.heal_on_damage
                    }
                };
                
                // Find equipped items section
                const bodyText = doc.body.textContent;
                const equippedMatch = bodyText.match(/üõ°Ô∏è Equipped Items ‚Äî Attack Set([\s\S]*?)(?:‚öîÔ∏è Equipment|$)/);
                
                if (equippedMatch) {
                    const equippedSection = equippedMatch[1];
                    
                    // Parse stats: "üî™ 180 ATK ¬∑ üõ°Ô∏è 0 DEF"
                    const statsRegex = /üî™\s*(\d+)\s*ATK\s*¬∑\s*üõ°Ô∏è\s*(\d+)\s*DEF/gi;
                    const matches = [...equippedSection.matchAll(statsRegex)];
                    
                    for (const match of matches) {
                        const attack = parseInt(match[1]) || 0;
                        const defense = parseInt(match[2]) || 0;
                        
                        equipment.total_equipped_atk += attack;
                        equipment.total_equipped_def += defense;
                    }
                }
                
                // Note: Equipment bonuses are configured manually in config.equipmentBonuses
                // Auto-extraction not available because bonuses are in dynamic modals (Info buttons)
                
                const equipEffects = equipment.equipment_effects;
                const totalBonus = equipEffects.extra_damage_monsters + equipEffects.armor_penetration + equipEffects.crit_rate + equipEffects.crit_damage;
                logger.info(`‚öîÔ∏è Extracted equipment: ATK ${equipment.total_equipped_atk}, DEF ${equipment.total_equipped_def}, Bonuses ${totalBonus.toFixed(1)}%`);
                
                // Cache result
                storage.set(CACHE_KEYS.equipment, {
                    data: equipment,
                    timestamp: Date.now()
                });
                
                return equipment;
            } catch (error) {
                logger.error('‚ùå Failed to extract equipment', { error });
                return {
                    equipped_attack_set: {},
                    total_equipped_atk: 0,
                    total_equipped_def: 0
                };
            }
        }
        
        /**
         * Extract all data (stats + pets + equipment)
         * @returns {Promise<Object>} { stats, pets, equipment }
         */
        async function extractAll() {
            logger.info('üîÑ Extracting all player data...');
            
            const [stats, pets, equipment] = await Promise.all([
                extractStats(),
                extractPets(),
                extractEquipment()
            ]);
            
            // Create combined list of all pets for build analysis
            const allAvailablePets = [
                ...(pets.equipped_attack_team || []),
                ...(pets.available_pets || [])
            ];
            
            return { 
                stats, 
                pets, 
                equipment,
                allAvailablePets
            };
        }
        
        /**
         * Clear all cached data
         */
        function clearCache() {
            storage.remove(CACHE_KEYS.stats);
            storage.remove(CACHE_KEYS.pets);
            storage.remove(CACHE_KEYS.equipment);
            logger.debug('üóëÔ∏è Data extractor cache cleared');
        }
        
        /**
         * Force refresh all data (clears cache and re-extracts)
         * @returns {Promise<Object>} Fresh data
         */
        async function forceRefresh() {
            logger.info('üîÑ Force refreshing all player data...');
            clearCache();
            return await extractAll();
        }
        
        /**
         * Analyze pet impact for different combat scenarios
         * @param {Array} pets - Array of equipped pets with parsed_effects
         * @returns {Object} Impact analysis with scores and recommendations
         */
        function analyzePetImpact(pets) {
            const analysis = {
                pvm: {
                    total_score: 0,
                    contributors: [],
                    damage_multiplier: 1.0,  // Final damage multiplier
                    breakdown: {}
                },
                pvp_attacker: {
                    total_score: 0,
                    contributors: [],
                    breakdown: {}
                },
                pvp_defender: {
                    total_score: 0,
                    contributors: [],
                    breakdown: {}
                },
                universal: {
                    total_score: 0,
                    contributors: [],
                    breakdown: {}
                }
            };
            
            if (!pets || pets.length === 0) return analysis;
            
            for (const pet of pets) {
                const effects = pet.parsed_effects;
                if (!effects) continue;
                
                // PvM Scoring
                if (effects.is_pve_only || effects.is_universal) {
                    let pvmScore = 0;
                    const breakdown = [];
                    
                    if (effects.extra_damage_monsters > 0) {
                        const score = effects.extra_damage_monsters * 3.0;
                        pvmScore += score;
                        breakdown.push(`${effects.extra_damage_monsters}% Extra Damage (√ó3.0) = ${score.toFixed(1)}`);
                        analysis.pvm.damage_multiplier += (effects.extra_damage_monsters / 100);
                    }
                    
                    if (effects.armor_penetration > 0) {
                        const score = effects.armor_penetration * 2.0;
                        pvmScore += score;
                        breakdown.push(`${effects.armor_penetration}% Armor Pen (√ó2.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.heal_on_damage > 0) {
                        const score = effects.heal_on_damage * 1.0;
                        pvmScore += score;
                        breakdown.push(`${effects.heal_on_damage}% Heal (√ó1.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.crit_rate > 0) {
                        const score = effects.crit_rate * 1.5;
                        pvmScore += score;
                        breakdown.push(`${effects.crit_rate}% Crit Rate (√ó1.5) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.crit_damage > 0) {
                        const score = effects.crit_damage * 1.2;
                        pvmScore += score;
                        breakdown.push(`${effects.crit_damage}% Crit Damage (√ó1.2) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.stamina_save > 0) {
                        const score = effects.stamina_save * 1.0;
                        pvmScore += score;
                        breakdown.push(`${effects.stamina_save}% Stamina Save (√ó1.0) = ${score.toFixed(1)}`);
                    }
                    
                    // Penalty for increased stamina cost
                    if (effects.stamina_cost_mult > 1.0) {
                        const penalty = (effects.stamina_cost_mult - 1.0) * 50;
                        pvmScore -= penalty;
                        breakdown.push(`√ó${effects.stamina_cost_mult} Stamina Cost (penalty) = -${penalty.toFixed(1)}`);
                    }
                    
                    if (pvmScore > 0) {
                        analysis.pvm.total_score += pvmScore;
                        analysis.pvm.contributors.push({
                            pet: pet.name,
                            score: pvmScore,
                            breakdown: breakdown.join(' | ')
                        });
                    }
                }
                
                // PvP Attacker Scoring
                if (effects.is_pvp_only || effects.is_universal) {
                    let atkScore = 0;
                    const breakdown = [];
                    
                    if (effects.steal_stat > 0) {
                        const score = effects.steal_stat * 3.0;
                        atkScore += score;
                        breakdown.push(`${effects.steal_stat}% Steal ATK (√ó3.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.team_conversion > 0) {
                        const score = effects.team_conversion * 2.5;
                        atkScore += score;
                        breakdown.push(`${effects.team_conversion}% Team Conversion (√ó2.5) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.atk_def_swap > 0) {
                        const score = effects.atk_def_swap * 2.0;
                        atkScore += score;
                        breakdown.push(`${effects.atk_def_swap}% ATK/DEF Swap (√ó2.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.crit_rate > 0) {
                        const score = effects.crit_rate * 1.5;
                        atkScore += score;
                        breakdown.push(`${effects.crit_rate}% Crit Rate (√ó1.5) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.crit_damage > 0) {
                        const score = effects.crit_damage * 1.2;
                        atkScore += score;
                        breakdown.push(`${effects.crit_damage}% Crit Damage (√ó1.2) = ${score.toFixed(1)}`);
                    }
                    
                    if (atkScore > 0) {
                        analysis.pvp_attacker.total_score += atkScore;
                        analysis.pvp_attacker.contributors.push({
                            pet: pet.name,
                            score: atkScore,
                            breakdown: breakdown.join(' | ')
                        });
                    }
                }
                
                // PvP Defender Scoring
                if (effects.is_pvp_only || effects.is_universal) {
                    let defScore = 0;
                    const breakdown = [];
                    
                    if (effects.steal_stat > 0) {
                        const score = effects.steal_stat * 3.0;
                        defScore += score;
                        breakdown.push(`${effects.steal_stat}% Steal DEF (√ó3.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.team_conversion > 0) {
                        const score = effects.team_conversion * 2.5;
                        defScore += score;
                        breakdown.push(`${effects.team_conversion}% Team Conversion (√ó2.5) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.def_boost > 0) {
                        const score = effects.def_boost * 2.0;
                        defScore += score;
                        breakdown.push(`${effects.def_boost}% DEF Boost (√ó2.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (effects.atk_def_swap > 0) {
                        const score = effects.atk_def_swap * 2.0;
                        defScore += score;
                        breakdown.push(`${effects.atk_def_swap}% ATK/DEF Swap (√ó2.0) = ${score.toFixed(1)}`);
                    }
                    
                    if (defScore > 0) {
                        analysis.pvp_defender.total_score += defScore;
                        analysis.pvp_defender.contributors.push({
                            pet: pet.name,
                            score: defScore,
                            breakdown: breakdown.join(' | ')
                        });
                    }
                }
                
                // Universal effects (apply to all scenarios)
                if (effects.stamina_save > 0 || effects.crit_rate > 0 || effects.crit_damage > 0) {
                    let uniScore = 0;
                    const breakdown = [];
                    
                    if (effects.stamina_save > 0) {
                        uniScore += effects.stamina_save * 1.0;
                        breakdown.push(`${effects.stamina_save}% Stamina Save`);
                    }
                    if (effects.crit_rate > 0) {
                        uniScore += effects.crit_rate * 1.5;
                        breakdown.push(`${effects.crit_rate}% Crit Rate`);
                    }
                    if (effects.crit_damage > 0) {
                        uniScore += effects.crit_damage * 1.2;
                        breakdown.push(`${effects.crit_damage}% Crit Damage`);
                    }
                    
                    if (uniScore > 0) {
                        analysis.universal.total_score += uniScore;
                        analysis.universal.contributors.push({
                            pet: pet.name,
                            score: uniScore,
                            breakdown: breakdown.join(' | ')
                        });
                    }
                }
            }
            
            // Sort contributors by score (descending)
            analysis.pvm.contributors.sort((a, b) => b.score - a.score);
            analysis.pvp_attacker.contributors.sort((a, b) => b.score - a.score);
            analysis.pvp_defender.contributors.sort((a, b) => b.score - a.score);
            analysis.universal.contributors.sort((a, b) => b.score - a.score);
            
            return analysis;
        }
        
        /**
         * Analyze all possible pet combinations to find optimal builds
         * @param {Object} data - Player data with stats, all pets, equipment
         * @param {number} monsterDefense - Target monster defense for PvM calculations
         * @returns {Object} Build recommendations for each scenario
         */
        function analyzeOptimalBuilds(data, monsterDefense = 0) {
            const { stats, equipment } = data;
            const allPets = data.allAvailablePets || [];
            
            if (!stats || !allPets || allPets.length === 0) {
                return {
                    pvm: { builds: [], note: 'No pets available' },
                    pvp_attacker: { builds: [], note: 'No pets available' },
                    pvp_defender: { builds: [], note: 'No pets available' }
                };
            }
            
            // Generate all combinations of 3 pets (C(n,3) where n = total pets)
            const combinations = [];
            const n = allPets.length;
            
            if (n < 3) {
                return {
                    pvm: { builds: [], note: 'Need at least 3 pets' },
                    pvp_attacker: { builds: [], note: 'Need at least 3 pets' },
                    pvp_defender: { builds: [], note: 'Need at least 3 pets' }
                };
            }
            
            // Generate all combinations of 3 pets
            for (let i = 0; i < n - 2; i++) {
                for (let j = i + 1; j < n - 1; j++) {
                    for (let k = j + 1; k < n; k++) {
                        combinations.push([allPets[i], allPets[j], allPets[k]]);
                    }
                }
            }
            
            logger.info(`üîç Analyzing ${combinations.length} pet combinations...`);
            
            // Evaluate each combination for PvM
            const pvmBuilds = combinations.map(pets => {
                const totalAtk = pets.reduce((sum, p) => sum + (p.attack || 0), 0);
                const totalDef = pets.reduce((sum, p) => sum + (p.defense || 0), 0);
                
                // Calculate damage bonus from pets
                let damageBonus = 0;
                let armorPen = 0;
                let critRate = 0;
                let critDamage = 0;
                let staminaSave = 0;
                let heal = 0;
                let staminaCostMult = 1.0;
                
                pets.forEach(pet => {
                    const eff = pet.parsed_effects || {};
                    damageBonus += eff.extra_damage_monsters || 0;
                    armorPen += eff.armor_penetration || 0;
                    critRate += eff.crit_rate || 0;
                    critDamage += eff.crit_damage || 0;
                    staminaSave += eff.stamina_save || 0;
                    heal += eff.heal_on_damage || 0;
                    if (eff.stamina_cost_mult > 1.0) staminaCostMult *= eff.stamina_cost_mult;
                });
                
                // Add equipment bonuses
                const equipEff = equipment.equipment_effects || {};
                damageBonus += equipEff.extra_damage_monsters || 0;
                armorPen += equipEff.armor_penetration || 0;
                critRate += equipEff.crit_rate || 0;
                critDamage += equipEff.crit_damage || 0;
                staminaSave += equipEff.stamina_save || 0;
                heal += equipEff.heal_on_damage || 0;
                
                // Calculate expected damage (using skill -1 = 10 stamina for comparison)
                const stamina_cost = 10;
                const base = 225;
                const equip_bonus = equipment.total_equipped_atk || 0;
                const user_atk_bonus = stats.base_attack || 0;
                const subtotal = (base + equip_bonus + totalAtk + user_atk_bonus) * stamina_cost;
                const baseDamage = subtotal * (1 + (damageBonus / 100));
                
                // Apply crit multiplier (simplified: if crit rate > 50%, assume 1.5x average boost)
                const critMultiplier = critRate > 50 ? 1 + ((critRate / 100) * (1 + critDamage / 100) * 0.5) : 1.0;
                const expectedDamage = baseDamage * critMultiplier;
                
                // Calculate score (weighted)
                const score = (
                    (damageBonus * 3.0) +
                    (armorPen * 2.0) +
                    (critRate * 1.5) +
                    (critDamage * 1.2) +
                    (staminaSave * 1.0) +
                    (heal * 1.0) +
                    (totalAtk / 10) // Stats contribution
                ) - ((staminaCostMult - 1.0) * 50);
                
                return {
                    pets: pets.map(p => p.name),
                    totalAtk,
                    totalDef,
                    damageBonus,
                    armorPen,
                    critRate,
                    critDamage,
                    staminaSave,
                    heal,
                    expectedDamage: Math.round(expectedDamage),
                    score: Math.round(score * 10) / 10,
                    equipmentBonus: {
                        damage: equipEff.extra_damage_monsters || 0,
                        armorPen: equipEff.armor_penetration || 0,
                        critRate: equipEff.crit_rate || 0,
                        critDamage: equipEff.crit_damage || 0
                    }
                };
            });
            
            // Evaluate for PvP Attacker
            const pvpAttackerBuilds = combinations.map(pets => {
                const totalAtk = pets.reduce((sum, p) => sum + (p.attack || 0), 0);
                const totalDef = pets.reduce((sum, p) => sum + (p.defense || 0), 0);
                
                let stealStat = 0;
                let teamConversion = 0;
                let atkDefSwap = 0;
                let critRate = 0;
                let critDamage = 0;
                
                pets.forEach(pet => {
                    const eff = pet.parsed_effects || {};
                    stealStat += eff.steal_stat || 0;
                    teamConversion += eff.team_conversion || 0;
                    atkDefSwap += eff.atk_def_swap || 0;
                    critRate += eff.crit_rate || 0;
                    critDamage += eff.crit_damage || 0;
                });
                
                const score = (
                    (stealStat * 3.0) +
                    (teamConversion * 2.5) +
                    (atkDefSwap * 2.0) +
                    (critRate * 1.5) +
                    (critDamage * 1.2) +
                    (totalAtk / 10)
                );
                
                return {
                    pets: pets.map(p => p.name),
                    totalAtk,
                    totalDef,
                    stealStat,
                    teamConversion,
                    atkDefSwap,
                    critRate,
                    critDamage,
                    score: Math.round(score * 10) / 10
                };
            });
            
            // Evaluate for PvP Defender
            const pvpDefenderBuilds = combinations.map(pets => {
                const totalAtk = pets.reduce((sum, p) => sum + (p.attack || 0), 0);
                const totalDef = pets.reduce((sum, p) => sum + (p.defense || 0), 0);
                
                let stealStat = 0;
                let teamConversion = 0;
                let defBoost = 0;
                let atkDefSwap = 0;
                
                pets.forEach(pet => {
                    const eff = pet.parsed_effects || {};
                    stealStat += eff.steal_stat || 0;
                    teamConversion += eff.team_conversion || 0;
                    defBoost += eff.def_boost || 0;
                    atkDefSwap += eff.atk_def_swap || 0;
                });
                
                const score = (
                    (stealStat * 3.0) +
                    (teamConversion * 2.5) +
                    (defBoost * 2.0) +
                    (atkDefSwap * 2.0) +
                    (totalDef / 10)
                );
                
                return {
                    pets: pets.map(p => p.name),
                    totalAtk,
                    totalDef,
                    stealStat,
                    teamConversion,
                    defBoost,
                    atkDefSwap,
                    score: Math.round(score * 10) / 10
                };
            });
            
            // Sort and return top 5 for each category
            pvmBuilds.sort((a, b) => b.expectedDamage - a.expectedDamage);
            pvpAttackerBuilds.sort((a, b) => b.score - a.score);
            pvpDefenderBuilds.sort((a, b) => b.score - a.score);
            
            return {
                pvm: {
                    builds: pvmBuilds.slice(0, 5),
                    total_combinations: combinations.length
                },
                pvp_attacker: {
                    builds: pvpAttackerBuilds.slice(0, 5),
                    total_combinations: combinations.length
                },
                pvp_defender: {
                    builds: pvpDefenderBuilds.slice(0, 5),
                    total_combinations: combinations.length
                }
            };
        }
        
        return {
            extractStats,
            extractPets,
            extractEquipment,
            extractAll,
            clearCache,
            forceRefresh,
            analyzePetImpact,
            analyzeOptimalBuilds
        };
    }
    
    // ==================== DAMAGE CALCULATOR SERVICE ====================
    // Centralized damage calculation for PvM and PvP
    // Implements verified game formulas
    
    /**
     * Create damage calculator service
     * Calculates damage/power based on game formulas
     * 
     * @param {Object} context - Script context
     * @returns {Object} Damage calculator service
     * 
     * @example
     * const calc = context.damageCalculator;
     * 
     * // Calculate PvM damage
     * const damage = calc.calculatePvMDamage({
     *   base_attack: 1110,
     *   equip_attack: 720,
     *   pet_attack: 1721,
     *   skill_id: -2,
     *   monster_defense: 50
     * });
     * // { damage: 2688250, breakdown: {...} }
     * 
     * // Calculate PvP power
     * const attackerPower = calc.calculatePvPAttacker({...});
     * const defenderPower = calc.calculatePvPDefender({...});
     */
    function createDamageCalculatorService(context) {
        const { logger } = context;
        
        // Skill stamina costs
        const SKILL_COSTS = {
            0: 1,      // Slash
            '-1': 10,  // Power Slash
            '-2': 50,  // Heroic Slash
            '-3': 100, // Ultimate Slash
            '-4': 200  // Legendary Slash
        };
        
        /**
         * Calculate PvM damage using verified formula
         * 
         * Formula:
         * PvM_Damage = (225 + equip_bonus + pet_bonus + user_atk_bonus) √ó stamina_cost √ó (1 + pet_effects_percent/100)
         * 
         * Where:
         * - equip_bonus = max(30, equip_atk - m_def/2) √ó 20
         * - pet_bonus = max(30, pet_atk - m_def/2) √ó 20
         * - user_atk_bonus = 1000 √ó max(30, user_atk - m_def)^0.25
         * - pet_effects_percent = sum of all "X% Extra Damage To Monsters" effects
         * 
         * @param {Object} params - Calculation parameters
         * @param {number} params.base_attack - Base attack stat
         * @param {number} params.equip_attack - Total equipment attack
         * @param {number} params.pet_attack - Total pet attack
         * @param {number} params.skill_id - Skill ID (0, -1, -2, -3, -4)
         * @param {number} params.monster_defense - Monster defense value
         * @param {number} [params.pet_damage_bonus_percent=0] - Total % damage bonus from pets
         * @param {number} [params.equip_damage_bonus_percent=0] - Total % damage bonus from equipment
         * @returns {Object} { damage, breakdown }
         */
        function calculatePvMDamage({ base_attack, equip_attack, pet_attack, skill_id, monster_defense, pet_damage_bonus_percent = 0, equip_damage_bonus_percent = 0 }) {
            const m_def = monster_defense || 0;
            const stamina_cost = SKILL_COSTS[String(skill_id)] || 1;
            
            // Calculate components
            const base = 225;
            
            const equip_component = Math.max(30, equip_attack - m_def / 2);
            const equip_bonus = equip_component * 20;
            
            const pet_component = Math.max(30, pet_attack - m_def / 2);
            const pet_bonus = pet_component * 20;
            
            const user_atk_component = Math.max(30, base_attack - m_def);
            const user_atk_bonus = 1000 * Math.pow(user_atk_component, 0.25);
            
            const skill_damage = 0; // No skill bonus in base formula
            
            const subtotal = base + equip_bonus + pet_bonus + skill_damage + user_atk_bonus;
            const damage_before_bonus = subtotal * stamina_cost;
            
            // Apply percentage bonuses from pets and equipment
            const total_bonus_percent = pet_damage_bonus_percent + equip_damage_bonus_percent;
            const bonus_multiplier = 1 + (total_bonus_percent / 100);
            const final_damage = Math.round(damage_before_bonus * bonus_multiplier);
            
            return {
                damage: final_damage,
                breakdown: {
                    base,
                    equip_contribution: Math.round(equip_bonus),
                    pet_contribution: Math.round(pet_bonus),
                    skill_damage,
                    user_attack_contribution: Math.round(user_atk_bonus),
                    subtotal: Math.round(subtotal),
                    stamina_multiplier: stamina_cost,
                    damage_before_bonus: Math.round(damage_before_bonus),
                    pet_bonus_percent: pet_damage_bonus_percent,
                    equip_bonus_percent: equip_damage_bonus_percent,
                    total_bonus_percent,
                    bonus_multiplier: bonus_multiplier.toFixed(2),
                    total: final_damage
                }
            };
        }
        
        /**
         * Calculate PvP Attacker power
         * 
         * Formula:
         * Power = atk_base + 0.7√ódef_base + 0.3√ópets_atk + 0.4√óequip_atk + 0.3√ópets_def + 0.2√óequip_def
         * 
         * @param {Object} params - Calculation parameters
         * @param {number} params.base_attack - Base attack stat
         * @param {number} params.base_defense - Base defense stat
         * @param {number} params.equip_attack - Total equipment attack
         * @param {number} params.equip_defense - Total equipment defense
         * @param {number} params.pet_attack - Total pet attack
         * @param {number} params.pet_defense - Total pet defense
         * @returns {Object} { power, breakdown }
         */
        function calculatePvPAttacker({ base_attack, base_defense, equip_attack, equip_defense, pet_attack, pet_defense }) {
            const power = 
                base_attack +
                (0.7 * base_defense) +
                (0.3 * pet_attack) +
                (0.4 * equip_attack) +
                (0.3 * pet_defense) +
                (0.2 * equip_defense);
            
            return {
                power: Math.round(power * 10) / 10, // Round to 1 decimal
                breakdown: {
                    base_attack: base_attack,
                    base_defense_contribution: Math.round(0.7 * base_defense * 10) / 10,
                    pet_attack_contribution: Math.round(0.3 * pet_attack * 10) / 10,
                    equip_attack_contribution: Math.round(0.4 * equip_attack * 10) / 10,
                    pet_defense_contribution: Math.round(0.3 * pet_defense * 10) / 10,
                    equip_defense_contribution: Math.round(0.2 * equip_defense * 10) / 10,
                    total: Math.round(power * 10) / 10
                }
            };
        }
        
        /**
         * Calculate PvP Defender power
         * 
         * Formula:
         * Power = def_base + 0.7√óatk_base + 0.3√ópets_atk + 0.2√óeq_atk + 0.3√ópets_def + 0.4√óeq_def
         * 
         * @param {Object} params - Calculation parameters
         * @param {number} params.base_attack - Base attack stat
         * @param {number} params.base_defense - Base defense stat
         * @param {number} params.equip_attack - Total equipment attack
         * @param {number} params.equip_defense - Total equipment defense
         * @param {number} params.pet_attack - Total pet attack
         * @param {number} params.pet_defense - Total pet defense
         * @returns {Object} { power, breakdown }
         */
        function calculatePvPDefender({ base_attack, base_defense, equip_attack, equip_defense, pet_attack, pet_defense }) {
            const power = 
                base_defense +
                (0.7 * base_attack) +
                (0.3 * pet_attack) +
                (0.2 * equip_attack) +
                (0.3 * pet_defense) +
                (0.4 * equip_defense);
            
            return {
                power: Math.round(power * 10) / 10, // Round to 1 decimal
                breakdown: {
                    base_defense: base_defense,
                    base_attack_contribution: Math.round(0.7 * base_attack * 10) / 10,
                    pet_attack_contribution: Math.round(0.3 * pet_attack * 10) / 10,
                    equip_attack_contribution: Math.round(0.2 * equip_attack * 10) / 10,
                    pet_defense_contribution: Math.round(0.3 * pet_defense * 10) / 10,
                    equip_defense_contribution: Math.round(0.4 * equip_defense * 10) / 10,
                    total: Math.round(power * 10) / 10
                }
            };
        }
        
        /**
         * Calculate damage/power with current player data
         * Automatically extracts data and calculates all values
         * 
         * @param {Object} dataExtractor - Data extractor service
         * @param {number} monster_defense - Monster defense (for PvM)
         * @param {number} skill_id - Skill ID (for PvM)
         * @returns {Promise<Object>} { pvm, pvp_attacker, pvp_defender }
         */
        async function calculateWithCurrentData(dataExtractor, monster_defense = 50, skill_id = -2) {
            logger.info('üßÆ Calculating damage with current player data...');
            
            const { stats, pets, equipment } = await dataExtractor.extractAll();
            
            // Get equipment bonuses (including manual config bonuses)
            const equipEffects = equipment.equipment_effects || {};
            const equipDamageBonus = equipEffects.extra_damage_monsters || 0;
            
            const pvm = calculatePvMDamage({
                base_attack: stats.base_attack,
                equip_attack: equipment.total_equipped_atk,
                pet_attack: pets.total_attack_pets_atk,
                skill_id,
                monster_defense,
                pet_damage_bonus_percent: pets.pvm_damage_bonus_percent || 0,
                equip_damage_bonus_percent: equipDamageBonus
            });
            
            const pvp_attacker = calculatePvPAttacker({
                base_attack: stats.base_attack,
                base_defense: stats.base_defense,
                equip_attack: equipment.total_equipped_atk,
                equip_defense: equipment.total_equipped_def,
                pet_attack: pets.total_attack_pets_atk,
                pet_defense: pets.total_attack_pets_def
            });
            
            const pvp_defender = calculatePvPDefender({
                base_attack: stats.base_attack,
                base_defense: stats.base_defense,
                equip_attack: equipment.total_equipped_atk,
                equip_defense: equipment.total_equipped_def,
                pet_attack: pets.total_attack_pets_atk,
                pet_defense: pets.total_attack_pets_def
            });
            
            logger.info(`‚úÖ PvM: ${formatNumber(pvm.damage)} | PvP ATK: ${pvp_attacker.power} | PvP DEF: ${pvp_defender.power}`);
            
            return {
                pvm,
                pvp_attacker,
                pvp_defender,
                player_data: { stats, pets, equipment }
            };
        }
        
        return {
            calculatePvMDamage,
            calculatePvPAttacker,
            calculatePvPDefender,
            calculateWithCurrentData
        };
    }

    function createUiRoot(config) {
        if (!config.core.shadowDom) {
            let container = document.getElementById('autods-root');
            if (!container) {
                container = document.createElement('div');
                container.id = 'autods-root';
                document.documentElement.appendChild(container);
            }
            return { root: container, shadow: container };
        }

        let host = document.getElementById('autods-root');
        if (!host) {
            host = document.createElement('div');
            host.id = 'autods-root';
            document.documentElement.appendChild(host);
        }
        let shadow = host.shadowRoot;
        if (!shadow) {
            shadow = host.attachShadow({ mode: 'open' });
            shadow.innerHTML = `<style>
                :host { all: initial; font-family: 'Segoe UI', system-ui, sans-serif; color: #e5e5e5; }
            </style>
            <div id="autods-app"></div>`;
        }
        return { root: host, shadow: shadow.getElementById('autods-app') };
    }

    /**
     * Create Wave View Navigation Service
     * Manages switching between alive/dead monsters views on wave pages
     * 
     * @param {Object} context - Script context (logger, etc.)
     * @returns {Object} View navigation service
     * @returns {function(): boolean} isDeadMonstersView - Check if in dead view
     * @returns {function(): Promise<boolean>} switchToDeadMonstersView - Switch to dead view
     * @returns {function(): Promise<boolean>} switchToAliveMonstersView - Switch to alive view
     * @returns {function(): Promise<boolean>} ensureAliveMonstersView - Ensure in alive view
     * 
     * @example
     * const viewNav = context.waveViewNavigation;
     * if (!viewNav.isDeadMonstersView()) {
     *   await viewNav.switchToDeadMonstersView();
     * }
     */
    function createWaveViewNavigationService(context) {
        const { logger } = context;
        
        return {
            /**
             * Verifica se est√° na view de dead monsters
             * @returns {boolean} - true se estiver na view de dead monsters
             */
            isDeadMonstersView() {
                const toggleBtn = document.querySelector('button[onclick*="toggleDead"], #toggleDeadBtn');
                if (toggleBtn) {
                    const text = toggleBtn.textContent || '';
                    return text.includes('Show Alive') || text.includes('üôà');
                }
                
                // Alternativa: verificar se URL tem dead=1 ou se bot√£o tem emoji espec√≠fico
                const buttons = document.querySelectorAll('button');
                for (const btn of buttons) {
                    const text = btn.textContent || '';
                    if (text.includes('Show Alive')) return true;
                    if (text.includes('Show unclaimed')) return false;
                }
                
                return false;
            },
            
            /**
             * Muda para view de dead monsters com verifica√ß√£o robusta
             * @returns {Promise<boolean>} - true se conseguiu mudar
             */
            async switchToDeadMonstersView() {
                if (this.isDeadMonstersView()) {
                    logger.debug('üíÄ J√° est√° na view de dead monsters');
                    return true;
                }
                
                // Procurar bot√£o "Show unclaimed monsters" (üëÅÔ∏è)
                const buttons = document.querySelectorAll('button');
                for (const btn of buttons) {
                    const text = btn.textContent || '';
                    if (text.includes('Show unclaimed') || (text.includes('üëÅÔ∏è') && text.includes('unclaimed'))) {
                        logger.info('üíÄ Mudando para unclaimed monsters view...');
                        
                        // Capturar estado ANTES do clique
                        const wasDeadView = this.isDeadMonstersView();
                        
                        // Clicar no bot√£o
                        btn.click();
                        
                        // Aguardar e verificar mudan√ßa com retries (delays aumentados)
                        const maxRetries = 5;
                        const retryDelays = [500, 800, 1200, 1500, 2000];
                        
                        for (let i = 0; i < maxRetries; i++) {
                            await sleep(retryDelays[i]);
                            
                            const isDeadNow = this.isDeadMonstersView();
                            
                            if (isDeadNow && !wasDeadView) {
                                logger.info(`‚úÖ [Dead View] Mudan√ßa confirmada ap√≥s ${retryDelays[i]}ms`);
                                
                                // Pausa adicional para garantir que os monster cards carreguem no DOM
                                logger.debug('üíÄ Aguardando carregamento dos monster cards...');
                                await sleep(800);
                                
                                return true;
                            }
                            
                            logger.debug(`üíÄ [Dead View] Tentativa ${i + 1}/${maxRetries}: isDeadView=${isDeadNow}`);
                        }
                        
                        // Se chegou aqui, pode ter mudado mas n√£o detectamos
                        const finalCheck = this.isDeadMonstersView();
                        if (finalCheck) {
                            logger.warn('‚ö†Ô∏è [Dead View] Mudan√ßa detectada ap√≥s retries (lento)');
                            
                            // Pausa adicional mesmo neste caso
                            await sleep(800);
                            
                            return true;
                        }
                        
                        logger.warn('‚ö†Ô∏è [Dead View] Bot√£o clicado mas mudan√ßa n√£o confirmada');
                        return false;
                    }
                }
                
                logger.warn('‚ö†Ô∏è Bot√£o de toggle para dead monsters n√£o encontrado');
                return false;
            },
            
            /**
             * Muda para view de alive monsters com verifica√ß√£o robusta
             * @returns {Promise<boolean>} - true se conseguiu mudar
             */
            async switchToAliveMonstersView() {
                if (!this.isDeadMonstersView()) {
                    logger.debug('‚úÖ J√° est√° na view de alive monsters');
                    return true;
                }
                
                // Procurar bot√£o "Show Alive monsters" (üôà)
                const buttons = document.querySelectorAll('button');
                for (const btn of buttons) {
                    const text = btn.textContent || '';
                    if (text.includes('Show Alive') || (text.includes('üôà') && text.includes('Alive'))) {
                        logger.info('‚úÖ Voltando para alive monsters view...');
                        
                        // Capturar estado ANTES do clique
                        const wasDeadView = this.isDeadMonstersView();
                        
                        // Clicar no bot√£o
                        btn.click();
                        
                        // Aguardar e verificar mudan√ßa com retries (delays aumentados)
                        const maxRetries = 5;
                        const retryDelays = [500, 800, 1200, 1500, 2000];
                        
                        for (let i = 0; i < maxRetries; i++) {
                            await sleep(retryDelays[i]);
                            
                            const isDeadNow = this.isDeadMonstersView();
                            
                            if (!isDeadNow && wasDeadView) {
                                logger.info(`‚úÖ [Alive View] Mudan√ßa confirmada ap√≥s ${retryDelays[i]}ms`);
                                
                                // Pausa adicional para garantir que os monster cards carreguem no DOM
                                logger.debug('‚úÖ Aguardando carregamento dos monster cards...');
                                await sleep(800);
                                
                                return true;
                            }
                            
                            logger.debug(`‚úÖ [Alive View] Tentativa ${i + 1}/${maxRetries}: isDeadView=${isDeadNow}`);
                        }
                        
                        // Se chegou aqui, pode ter mudado mas n√£o detectamos
                        const finalCheck = this.isDeadMonstersView();
                        if (!finalCheck) {
                            logger.warn('‚ö†Ô∏è [Alive View] Mudan√ßa detectada ap√≥s retries (lento)');
                            
                            // Pausa adicional mesmo neste caso
                            await sleep(800);
                            
                            return true;
                        }
                        
                        logger.warn('‚ö†Ô∏è [Alive View] Bot√£o clicado mas mudan√ßa n√£o confirmada');
                        return false;
                    }
                }
                
                logger.warn('‚ö†Ô∏è Bot√£o de toggle para alive monsters n√£o encontrado');
                return false;
            },
            
            /**
             * Garante que est√° na view de alive monsters
             * @returns {Promise<boolean>} - true se estiver ou conseguiu mudar
             */
            async ensureAliveMonstersView() {
                return this.switchToAliveMonstersView();
            }
        };
    }

    function createModuleRegistry(logger) {
        const modules = [];

        function register(module) {
            modules.push(module);
        }

        function initAll(context) {
            modules.forEach(module => {
                try {
                    module.init?.(context);
                } catch (error) {
                    logger.error(`Module ${module.id} failed to initialise`, error);
                }
            });
        }

        function activateFor(context) {
            modules.forEach(module => {
                try {
                    if (module.match?.(context)) {
                        module.activate?.(context);
                    }
                } catch (error) {
                    logger.error(`Module ${module.id} failed to activate`, error);
                }
            });
        }

        function getModule(id) {
            return modules.find(m => m.id === id);
        }

        return { register, initAll, activateFor, getModule, modules };
    }

    // --- Feature Module Skeletons --------------------------------------------------------

    const ultraFastWaveModule = {
        id: 'ultraFastWave',
        match: ({ location }) => /active_wave\.php/i.test(location.pathname),
        init() {
            this.state = {
                running: false,
                staminaWaiting: false,
                notifiedMaxBattles: false,
                lastTarget: null,
                lastWaveUrl: null,
                ultraFastStats: {
                    attackCount: 0,
                    damageDealt: 0,
                    potionsUsed: 0,
                    monstersCompleted: 0,
                    startTime: null
                }
            };
        },
        activate(context) {
            const cfgRoot = context.config.get();
            const cfgWave = cfgRoot.wave;
            
            if (!cfgRoot.core.enabled) {
                if (this.state) this.state.running = false;
                return;
            }
            
            if (!cfgWave || cfgWave.enabled === false) {
                if (this.state) this.state.running = false;
                return;
            }
            
            if (!this.state) this.init(context);
            if (this.state.running) return;
            
            this.state.running = true;
            context.logger.info('‚ö° Ultra Fast Wave - iniciando loop eterno');

            (async () => {
                try {
                    await this.runUltraFastLoop(context);
                } catch (error) {
                    context.logger.error('Falha no Ultra Fast Wave', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },
        
        /**
         * Ultra Fast Loop - joins and attacks directly from active_wave.php
         * Similar to Ultra Fast Dungeon but for wave battles
         */
        async runUltraFastLoop(context) {
            const { logger, dom } = context;
            
            this.state.ultraFastStats = {
                attackCount: 0,
                damageDealt: 0,
                potionsUsed: 0,
                monstersCompleted: 0,
                startTime: Date.now()
            };
            
            logger.info('‚ö° Ultra Fast Wave iniciado - Loop eterno ativado');
            
            // Debug: Log initial state
            const initialPathname = context.location?.pathname || window.location?.pathname || '';
            const isActivePage = /active_wave\.php/i.test(initialPathname);
            logger.debug(`[UltraFastLoop] Pathname: ${initialPathname}`);
            logger.debug(`[UltraFastLoop] isActivePage: ${isActivePage}`);
            
            if (!isActivePage) {
                logger.error(`‚ùå [UltraFastLoop] N√ÉO est√° em active_wave.php! Pathname: ${initialPathname}`);
                return;
            }
            
            let loopCount = 0;
            while (/active_wave\.php/i.test(context.location.pathname)) {
                loopCount++;
                if (loopCount === 1) {
                    logger.info(`‚úÖ [UltraFastLoop] Entrou no while loop - IN√çCIO`);
                }
                
                const cfg = context.config.get();
                logger.debug(`[UltraFastLoop] Itera√ß√£o ${loopCount}: core=${cfg.core?.enabled}, wave.enabled=${cfg.wave?.enabled}`);
                
                if (!cfg.core.enabled || cfg.wave?.enabled === false) {
                    logger.info(`‚ö° Ultra Fast Wave desativado via configura√ß√£o (itera√ß√£o ${loopCount}).`);
                    break;
                }
                
                // üéØ PRIORIDADE: Se Special Boss Farm estiver ativo E processando bosses, pausar Ultra Fast Wave
                if (cfg.specialBossFarm?.enabled) {
                    const specialBossModule = context.moduleRegistry.getModule('specialBossFarm');
                    if (specialBossModule?.state?.running && specialBossModule?.state?.activeBosses > 0) {
                        logger.info(`üëë Special Boss Farm processando ${specialBossModule.state.activeBosses} boss(es) - pausando Ultra Fast Wave...`);
                        await sleep(5000); // Aguardar 5s e verificar novamente
                        continue;
                    }
                }
                
                // 1. Check stamina
                const currentStamina = context.stamina.getCurrent();
                const skillId = cfg.wave.skillId ?? -2;
                const skillCost = context.combat.getSkillCost(skillId);
                
                if (currentStamina < skillCost) {
                    // Check if should use FSP
                    if ((cfg.wave.autoFSP || cfg.wave.lootDeadBeforeFSP) && currentStamina < (cfg.wave.minStaminaForFSP || 100)) {
                        logger.info(`‚è≥ Stamina insuficiente (${currentStamina}/${skillCost}). Tentando recuperar...`);
                        
                        // üÜï Verificar se j√° tentamos loot dead e devemos ir direto para FSP
                        const skipLootDead = sessionStorage.getItem('autods_skip_loot_dead_use_fsp');
                        
                        // üÜï ANTES de usar FSP, tentar lootar dead monsters (incluindo special bosses) para poss√≠vel level up
                        // lootDeadMonsters j√° gerencia TUDO: normal monsters + special bosses (100B+)
                        if (cfg.wave.lootDeadBeforeFSP !== false && !skipLootDead) {
                            logger.info('üíÄ [LOOT DEAD] Tentando lootar dead monsters (incluindo special bosses)...');
                            
                            // Chamar lootDeadMonsters diretamente do ultraFastLootModule
                            const lootModule = context.moduleRegistry?.getModule('ultraFastLoot');
                            if (!lootModule || typeof lootModule.lootDeadMonsters !== 'function') {
                                logger.error('‚ùå [LOOT DEAD] ultraFastLootModule ou lootDeadMonsters n√£o encontrado');
                                sessionStorage.setItem('autods_skip_loot_dead_use_fsp', 'true');
                            } else {
                                const lootResult = await lootModule.lootDeadMonsters(context);
                                
                                if (lootResult.levelUp) {
                                    // Level up detectado! Stamina recuperou
                                    const newStamina = context.stamina.getCurrent();
                                    logger.info(`üéâ [LOOT DEAD] Level up detectado! Nova stamina: ${newStamina}`);
                                    if (newStamina >= skillCost) {
                                        logger.info('üéâ Stamina recuperada ap√≥s loot! Continuando wave farm...');
                                        continue; // Continuar loop sem usar FSP
                                    }
                                }
                                
                                if (lootResult.count === 0) {
                                    logger.info('üíÄ [LOOT DEAD] Nenhum dead monster looteado. Tentando FSP...');
                                    sessionStorage.setItem('autods_skip_loot_dead_use_fsp', 'true');
                                } else {
                                    logger.info(`üíÄ [LOOT DEAD] ${lootResult.count} monster(s) looteado(s), mas stamina n√£o recuperou. Tentando FSP...`);
                                }
                            }
                        } else if (skipLootDead) {
                            logger.info('üíÄ [LOOT DEAD] Flag detectada - pulando loot dead, indo para FSP...');
                            // Limpar flag ap√≥s usar
                            sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                        }
                        
                        // Tentar usar FSP
                        logger.info(`üíä [FSP] autoFSP=${cfg.wave.autoFSP} - Verificando op√ß√£o FSP...`);
                        if (!cfg.wave.autoFSP) {
                            logger.info('üíä [FSP] autoFSP est√° DESATIVADO. N√£o usar√° FSP.');
                        } else {
                            logger.info('üíä [FSP] Usando Full Stamina Potion...');
                            const fspUsed = await context.inventory.useFullStaminaPotion();
                            if (fspUsed) {
                                logger.info('üíä [FSP] FSP usada com sucesso! Recarregando p√°gina...');
                                // Limpar flag ao usar FSP com sucesso (reset completo)
                                sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                                await sleep(500);
                                window.location.href = window.location.href;
                                return;
                            } else {
                                logger.info('üíä [FSP] Falha ao usar FSP ou sem FSP dispon√≠vel.');
                            }
                        }
                    }
                    
                    // üÜï Ap√≥s todo o processo de stamina recovery, limpar flag para pr√≥xima tentativa
                    // Isso permite tentar loot dead novamente ap√≥s aguardar regenera√ß√£o
                    logger.debug('üîÑ Limpando flag de loot para permitir nova tentativa ap√≥s regenera√ß√£o...');
                    sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                    
                    // Wait for stamina regen
                    logger.info(`‚è≥ Stamina baixa (${currentStamina}). Aguardando regenera√ß√£o...`);
                    await sleep(30000); // 30s wait
                    continue;
                }
                
                await this.switchToAliveMonstersView(context);
                // 2. Scan ALL eligible targets (not joined yet)
                const newTargets = this.scanUltraFastTargets(context, cfg);
                
                // 3. Count ongoing battles (already joined)
                const ongoingCount = this.countOngoingBattles(context);
                
                // 4. If no new targets but has ongoing battles, attack them
                if (newTargets.length === 0 && ongoingCount > 0) {
                    logger.info(`‚öîÔ∏è ${ongoingCount} batalhas em andamento - atacando...`);
                    await this.attackOngoingBattles(context, cfg);
                    
                    // Refresh to check for new targets
                    await sleep(5000);
                    window.location.href = window.location.href;
                    continue;
                }
                
                // 5. If no targets at all, wait and refresh
                if (newTargets.length === 0 && ongoingCount === 0) {
                    logger.debug('Nenhum alvo dispon√≠vel. Aguardando 15s...');
                    await sleep(15000);
                    window.location.href = window.location.href;
                    continue;
                }
                
                // 6. SAFE MODE CHECK: Don't join if already >10 continues active
                if (ongoingCount > 10) {
                    logger.warn(`‚ö†Ô∏è MUITAS BATALHAS ATIVAS (${ongoingCount} > 10)! Modo seguro: apenas atacando batalhas em andamento.`);
                    logger.info('üí° N√£o ser√° feito join em novos monstros para evitar sobrecarga do servidor.');
                    
                    // Attack ongoing battles only, then reload
                    const ongoingBattles = this.getOngoingBattles(context);
                    if (ongoingBattles.length > 0) {
                        await this.attackUltraFastBattles(context, ongoingBattles, cfg);
                    }
                    
                    // Wait and reload to check if some battles completed
                    await sleep(10000);
                    window.location.href = window.location.href;
                    continue;
                }
                
                // 7. JOIN ALL ELIGIBLE TARGETS AT ONCE (like Ultra Fast Farm does)
                // This bypasses the maxConcurrentBattles limit by joining before the server can enforce it
                logger.info(`üöÄ PRE-FLIGHT JOIN: Entrando em ${newTargets.length} batalha(s) SIMULTANEAMENTE...`);
                
                const joinedTargets = await this.joinUltraFastBattles(context, newTargets);
                
                logger.info(`üìä Pre-Flight Join: ${joinedTargets.length}/${newTargets.length} joins bem-sucedidos`);
                
                // 8. Attack ALL battles (newly joined + ongoing)
                if (joinedTargets.length > 0) {
                    await this.attackUltraFastBattles(context, joinedTargets, cfg);
                }
                
                // Also attack any ongoing battles that weren't in joinedTargets
                if (ongoingCount > 0) {
                    // Find ongoing battles that weren't in newTargets
                    const ongoingBattles = this.getOngoingBattles(context);
                    const newTargetIds = new Set(newTargets.map(t => t.monsterId));
                    const additionalOngoing = ongoingBattles.filter(t => !newTargetIds.has(t.monsterId));
                    
                    if (additionalOngoing.length > 0) {
                        logger.info(`‚öîÔ∏è Atacando ${additionalOngoing.length} batalha(s) adicionais em andamento...`);
                        await this.attackUltraFastBattles(context, additionalOngoing, cfg);
                    }
                }
                
                // 9. Refresh page to continue loop
                await sleep(2000);
                window.location.href = window.location.href;
            }
            
            // Log final stats
            const duration = (Date.now() - this.state.ultraFastStats.startTime) / 1000;
            logger.info(`‚ö° Ultra Fast Wave finalizado - Ataques: ${this.state.ultraFastStats.attackCount}, Dano: ${formatNumber(this.state.ultraFastStats.damageDealt)}, Tempo: ${duration.toFixed(1)}s`);
        },
        
        /**
         * Get list of ongoing battles (already joined)
         */
        getOngoingBattles(context) {
            const { dom } = context;
            const cards = dom.queryAll('.monster-card');
            const ongoing = [];
            
            for (const card of cards) {
                const button = card.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button');
                const buttonText = button?.textContent?.toLowerCase() || '';
                
                if (!buttonText.includes('continue')) continue;
                
                const link = card.querySelector('a[href*="battle.php"][href*="id="]');
                const battleUrl = link?.href;
                const monsterIdMatch = battleUrl?.match(/[?&]id=(\d+)/);
                const monsterId = monsterIdMatch ? monsterIdMatch[1] : null;
                
                if (!monsterId) continue;
                
                const nameNode = card.querySelector('h3, h4, .monster-name, .card-title');
                const name = nameNode ? nameNode.textContent.trim() : 'Unknown';
                
                ongoing.push({ name, monsterId, battleUrl });
            }
            
            return ongoing;
        },
        

        
        /**
         * Obt√©m contador de dead monsters (Unclaimed kills)
         * Mais robusto: tenta m√∫ltiplas formas de detec√ß√£o para conex√µes lentas
         */
        getUnclaimedKillsCount() {
            // M√©todo 1: Procurar por "üíÄ Unclaimed kills: X" ou "Unclaimed kills: X" no texto
            const pageText = document.body.textContent || '';
            let match = pageText.match(/Unclaimed kills:\s*(\d+)/i);
            if (match) {
                const count = parseInt(match[1], 10) || 0;
                if (count > 0) return count;
            }
            
            // M√©todo 2: Procurar por "X kills" (formato comum)
            match = pageText.match(/(\d+)\s+kills?/i);
            if (match) {
                const count = parseInt(match[1], 10) || 0;
                if (count > 0) return count;
            }
            
            // M√©todo 3: Contar monster cards com HP = 0 (dead)
            const monsterCards = document.querySelectorAll('.monster-card');
            let deadCount = 0;
            for (const card of monsterCards) {
                // Procurar por "0 / X" ou "0/X" pattern no card
                const cardText = card.textContent || '';
                if (/\b0\s*\/\s*\d+/.test(cardText)) {
                    deadCount++;
                }
                
                // Alternativa: verificar classe ou data attribute
                const hpElement = card.querySelector('.hp-value, [data-stat="hp"], .hp, [data-hp]');
                if (hpElement) {
                    const hpText = hpElement.textContent || '';
                    if (hpText.includes('0 /') || hpText.startsWith('0/') || hpText === '0') {
                        deadCount++;
                    }
                }
            }
            
            return Math.max(0, deadCount);
        },
        
        /**
         * Verifica se est√° na view de dead monsters
         * @deprecated Use context.waveViewNavigation.isDeadMonstersView() instead
         */
        isDeadMonstersView() {
            return context.waveViewNavigation?.isDeadMonstersView() ?? false;
        },
        
        /**
         * Muda para view de dead monsters
         * @deprecated Use context.waveViewNavigation.switchToDeadMonstersView() instead
         */
        async switchToDeadMonstersView(context) {
            return context.waveViewNavigation?.switchToDeadMonstersView() ?? false;
        },
        
        /**
         * Muda para view de alive monsters
         * @deprecated Use context.waveViewNavigation.switchToAliveMonstersView() instead
         */
        async switchToAliveMonstersView(context) {
            return context.waveViewNavigation?.switchToAliveMonstersView() ?? false;
        },
        
        /**
         * Garante que est√° na view de alive monsters
         * @deprecated Use context.waveViewNavigation.ensureAliveMonstersView() instead
         */
        async ensureAliveMonstersView(context) {
            return context.waveViewNavigation?.ensureAliveMonstersView() ?? false;
        },
        
        /**
         * Executa loot r√°pido nos dead monsters vis√≠veis
         * ‚ú® Delega para ultraFastLootModule para reutilizar toda a l√≥gica paralela
         * üÜï Agora com detec√ß√£o de level up para parar quando stamina recupera
         */
        async executeQuickDeadLoot(context) {
            // üÜï USAR FUN√á√ÉO CENTRALIZADA DO ultraFastLootModule
            const lootModule = context.moduleRegistry?.getModule('ultraFastLoot');
            if (!lootModule || typeof lootModule.lootDeadMonsters !== 'function') {
                context.logger.warn('‚ö†Ô∏è [WaveModule] ultraFastLootModule n√£o dispon√≠vel');
                return { looted: false, levelUp: false };
            }
            
            return await lootModule.lootDeadMonsters(context);
        },
        
        // üóëÔ∏è OLD IMPLEMENTATION - MANTIDA COMO BACKUP
        async executeQuickDeadLootOLD(context) {
            const { logger, numbers } = context;
            
            const BOSS_HP_THRESHOLD = 100_000_000_000;
            
            // üÜï CAPTURAR EXP INICIAL (antes de qualquer loot)
            const initialExpInfo = context.loot.getPlayerExpInfo();
            let simulatedCurrentExp = initialExpInfo?.currentExp || 0;
            
            if (initialExpInfo) {
                logger.info(`üíÄ [LOOT DEAD] Estado inicial: EXP=${numbers.format(initialExpInfo.currentExp)}/${numbers.format(initialExpInfo.maxExp)} (${initialExpInfo.percent.toFixed(2)}%)`);
            }
            
            // Encontrar dead monsters
            let cards = Array.from(document.querySelectorAll('.monster-card[data-dead="1"]'));
            
            // Se n√£o encontrou, procurar por HP = 0
            if (cards.length === 0) {
                cards = Array.from(document.querySelectorAll('.monster-card'));
                cards = cards.filter(card => {
                    const hpText = card.textContent || '';
                    return hpText.includes('0 /') || /HP[:\s]*0[^0-9]/.test(hpText);
                });
            }
            
            logger.info(`üíÄ [LOOT] Encontrados ${cards.length} monster cards para analisar`);
            
            // Coletar targets v√°lidos (filtrando bosses 100B+)
            const lootTargets = [];
            let bossesFiltered = 0;
            
            for (const card of cards) {
                let monsterId = card.getAttribute('data-monster-id');
                
                if (!monsterId) {
                    const link = card.querySelector('a[href*="battle.php"]');
                    if (link) {
                        const match = link.href.match(/[?&]id=(\d+)/);
                        monsterId = match ? match[1] : null;
                    }
                }
                
                if (!monsterId) continue;
                
                const nameElement = card.querySelector('h3, .monster-name, .card-title');
                const monsterName = nameElement ? nameElement.textContent.trim() : 'Unknown';
                
                // Extract HP and filter bosses
                const hpRow = Array.from(card.querySelectorAll('.stat-row')).find(row => row.querySelector('.stat-icon.hp'));
                const hpValueNode = hpRow?.querySelector('.stat-value');
                const hpText = hpValueNode?.textContent ?? '';
                const hpMatch = hpText.match(/(\d{1,3}(?:,\d{3})*|\d+)\s*\/\s*(\d{1,3}(?:,\d{3})*|\d+)/);
                const hp = hpMatch ? numberFromText(hpMatch[2]) : null;
                
                // Skip bosses (100B+ HP)
                if (hp && hp >= BOSS_HP_THRESHOLD) {
                    logger.warn(`üëë ${monsterName}: Ignorado (boss com ${formatNumber(hp)} HP)`);
                    bossesFiltered++;
                    continue;
                }
                
                lootTargets.push({
                    type: 'wave',
                    monsterId: monsterId,
                    name: monsterName
                });
            }
            
            if (lootTargets.length === 0) {
                logger.info(`üíÄ [LOOT] Nenhum dead monster para lootar (${bossesFiltered} bosses filtrados)`);
                return false;
            }
            
            logger.info(`üí∞ [LOOT] ${lootTargets.length} dead monsters para lootar (${bossesFiltered} bosses filtrados)`);
            
            // üÜï Lootar em BATCHES com verifica√ß√£o de level up AP√ìS cada batch
            const userId = context.userSession.getUserId();
            if (!userId) {
                logger.error('‚ùå [LOOT] User ID n√£o encontrado');
                return false;
            }
            
            const batchSize = context.config.get().ultraFastLoot?.maxParallelLoots || 10;
            let totalLooted = 0;
            
            // Processar em batches
            for (let i = 0; i < lootTargets.length; i += batchSize) {
                const batch = lootTargets.slice(i, i + batchSize);
                
                logger.debug(`üíÄ [LOOT] Batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(lootTargets.length / batchSize)}: ${batch.length} monsters`);
                
                // Lootar batch em PARALELO
                const promises = batch.map(target => 
                    context.http.lootMonster(target.monsterId, userId)
                        .then(result => ({ target, result }))
                        .catch(error => ({ target, result: { success: false, message: error.message } }))
                );
                
                const results = await Promise.all(promises);
                
                // üÜï ACUMULAR EXP DO BATCH
                let batchExpGained = 0;
                let batchSuccessCount = 0;
                
                for (const { target, result } of results) {
                    if (result.success) {
                        batchSuccessCount++;
                        const expGained = result.data?.rewards?.exp || 0;
                        batchExpGained += expGained;
                        logger.debug(`‚úÖ ${target.name}: +${numbers.format(expGained)} EXP`);
                    }
                }
                
                totalLooted += batchSuccessCount;
                logger.info(`üíÄ [LOOT] Batch completo: ${batchSuccessCount}/${batch.length} loots, +${numbers.format(batchExpGained)} EXP`);
                
                // üÜï VERIFICAR LEVEL UP AP√ìS BATCH (se temos info inicial)
                if (initialExpInfo && batchExpGained > 0) {
                    simulatedCurrentExp += batchExpGained;
                    
                    const leveledUp = simulatedCurrentExp >= initialExpInfo.maxExp;
                    
                    if (leveledUp) {
                        logger.info(`üéâ [LOOT DEAD] LEVEL UP DETECTADO! (EXP acumulado: ${numbers.format(simulatedCurrentExp)} >= ${numbers.format(initialExpInfo.maxExp)})`);
                        logger.info(`üéâ [LOOT DEAD] Stamina recuperada ap√≥s ${totalLooted} loot(s)! Parando...`);
                        context.notifications.success(`üéâ Level up! Stamina recuperada ap√≥s ${totalLooted} dead monster(s)`, 3000);
                        return true; // Retorna sucesso para que volte ao farming
                    }
                    
                    // Log progress
                    const expNeeded = initialExpInfo.maxExp - simulatedCurrentExp;
                    logger.debug(`üíÄ [LOOT] Progresso: ${numbers.format(simulatedCurrentExp)}/${numbers.format(initialExpInfo.maxExp)} (faltam ${numbers.format(expNeeded)} XP)`);
                }
                
                // Delay entre batches
                if (i + batchSize < lootTargets.length) {
                    await sleep(context.config.get().ultraFastLoot?.delayBetweenLoots || 100);
                }
            }
            
            logger.info(`üéâ [LOOT DEAD] CONCLU√çDO: ${totalLooted}/${lootTargets.length} loots bem-sucedidos`);
            return totalLooted > 0;
        },
        
        /**
         * DEPRECATED: Use context.loot.lootWaveMonster() instead
         * Kept for backward compatibility but redirects to unified service
         */
        performQuickLoot(context, target) {
            return context.loot.lootWaveMonster(target.monsterId, context.userSession.getUserId(), target.name || 'Unknown');
        },
        
        scanUltraFastTargets(context, cfg) {
            const { logger } = context;
            
            const monsterFilter = cfg.wave?.monsterFilter || {};
            const includeNames = Array.isArray(monsterFilter.includeNames) ? monsterFilter.includeNames.filter(Boolean) : [];
            const excludeNames = Array.isArray(monsterFilter.excludeNames) ? monsterFilter.excludeNames.filter(Boolean) : [];
            
            // Use Monster Scanner Service with include names (backward compat)
            const monsters = context.monsterScanner.scanWaveMonsters({
                monsterNames: includeNames.length > 0 ? includeNames : undefined,
                minHp: 0, // Ultra Fast doesn't filter by HP
                onlyNotJoined: true, // Ultra Fast only attacks new targets
                onlyAlive: true // Skip dead monsters
            });
            
            if (!monsters.length) {
                logger.debug('[UltraFastWave] No monsters found after filters');
                return [];
            }
            
            // Apply exclude filter to remaining monsters
            let filtered = monsters;
            if (excludeNames.length > 0) {
                filtered = monsters.filter(monster => {
                    const monsterNameLower = (monster.name || '').toLowerCase();
                    return !excludeNames.some(excludeName => 
                        monsterNameLower.includes(excludeName.toLowerCase())
                    );
                });
                if (filtered.length < monsters.length) {
                    logger.debug(`[UltraFastWave] Filtered out ${monsters.length - filtered.length} monsters by exclude names`);
                }
            }
            
            // Convert to Ultra Fast format
            const targets = filtered.map(monster => ({
                card: monster.card,
                name: monster.name,
                hp: monster.hp,
                monsterId: monster.monsterId,
                battleUrl: `battle.php?id=${monster.monsterId}`,
                button: monster.card?.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button')
            }));
            
            // Ultra Fast always uses lowest_hp priority
            targets.sort((a, b) => (a.hp || 0) - (b.hp || 0));
            
            return targets;
        },
        
        /**
         * Fetch current damage for a battle - reads from DOM card first (no HTTP needed)
         * Falls back to HTTP request if card not found
         * 
         * Strategy:
         * 1. üöÄ Try to read from monster card in current page (fast, no HTTP)
         * 2. üì° If not found, fetch from battle.php (slower, may be blocked by Cloudflare)
         */
        async fetchBattleDamage(context, monsterId) {
            const { logger, numbers, dom } = context;
            
            // 1Ô∏è‚É£ Try to read damage from monster card in current page (FASTEST - no HTTP)
            try {
                const card = dom.query(`[data-monster-id="${monsterId}"]`);
                if (card) {
                    // Get damage from data attribute: data-userdmg="5330150"
                    const damageAttr = card.getAttribute('data-userdmg');
                    if (damageAttr) {
                        const damage = parseInt(damageAttr, 10);
                        if (!isNaN(damage) && damage >= 0) {
                            logger.debug(`[FetchDamage] ${monsterId}: Lido do card - ${formatNumber(damage)}`);
                            return { success: true, damage, source: 'card' };
                        }
                    }
                    
                    // Fallback: try to read from "You: X,XXX,XXX" text
                    const damageText = card.querySelector('.party-chip')?.textContent || '';
                    const textMatch = damageText.match(/You:\s*([0-9,]+)/i);
                    if (textMatch) {
                        const damage = numbers.parse(textMatch[1]);
                        logger.debug(`[FetchDamage] ${monsterId}: Lido do texto - ${formatNumber(damage)}`);
                        return { success: true, damage, source: 'text' };
                    }
                }
            } catch (e) {
                // Silently continue to HTTP fallback
            }
            
            // 2Ô∏è‚É£ Card not found or no damage attribute - try HTTP fetch (slower, may be blocked)
            try {
                const url = `/battle.php?id=${monsterId}`;
                // Use current page URL as referer (includes event/wave params)
                const currentUrl = context.location?.href || window.location.href;
                const result = await context.http.get(url, {
                    headers: {
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                        'Referer': currentUrl
                    }
                });
                
                if (!result.success) {
                    logger.debug(`[FetchDamage] ${monsterId}: HTTP falhou`);
                    return { success: false, damage: 0 };
                }
                
                const html = result.data;
                
                // Valida√ß√£o: verificar se √© HTML v√°lido
                if (html.length < 500 || !html.includes('<body')) {
                    logger.debug(`[FetchDamage] ${monsterId}: Resposta inv√°lida (${html.length} bytes)`);
                    return { success: true, damage: 0, source: 'http-empty' };
                }
                
                // Try to find damage value in HTML (ordem de prioridade)
                const damageMatch = html.match(/id="yourDamageValue"[^>]*>([0-9,]+)<\/span>/i) 
                                  || html.match(/DMG:\s*<span[^>]*>([0-9,]+)<\/span>/i)
                                  || html.match(/Your Damage[^<]*<[^>]*>([0-9,]+)<\/span>/i)
                                  || html.match(/damage[^>]*>.*?([0-9,]+)/i);
                
                if (damageMatch) {
                    const damage = numbers.parse(damageMatch[1]);
                    logger.debug(`[FetchDamage] ${monsterId}: HTTP - ${formatNumber(damage)}`);
                    return { success: true, damage, source: 'http' };
                } else {
                    // Check if battle is invalid/ended
                    if (html.includes('Invalid') || html.includes('not found') || html.includes('ended') || html.includes('dead')) {
                        return { success: false, invalid: true, damage: 0 };
                    } else {
                        return { success: true, damage: 0, source: 'http-zero' };
                    }
                }
            } catch (error) {
                logger.debug(`[FetchDamage] Error for ${monsterId}:`, error);
                return { success: false, damage: 0 };
            }
        },
        
        /**
         * Fetch current damages for multiple battles in parallel
         */
        async fetchCurrentDamages(context, targets) {
            const { logger } = context;
            
            logger.info(`üìä Buscando dano atual de ${targets.length} batalha(s)...`);
            
            const startTime = Date.now();
            const results = await Promise.all(
                targets.map(async (target) => {
                    const result = await this.fetchBattleDamage(context, target.monsterId);
                    return { target, result };
                })
            );
            const duration = Date.now() - startTime;
            
            let skippedCount = 0;
            let zeroCount = 0;
            for (const { target, result } of results) {
                if (result.success) {
                    target.currentDamage = result.damage;
                    if (result.damage > 0) {
                        logger.debug(`  ${target.name}: ${formatNumber(result.damage)} dano existente`);
                    } else {
                        zeroCount++;
                    }
                } else if (result.invalid) {
                    target.invalid = true;
                    skippedCount++;
                }
            }
            
            // logger.info(`üìä Danos atuais obtidos em ${duration}ms (${skippedCount} inv√°lidos, ${zeroCount} com 0 dano)`);
        },
        
        countOngoingBattles(context) {
            const cards = context.dom.queryAll('.monster-card');
            let count = 0;
            
            for (const card of cards) {
                const button = card.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button');
                const buttonText = button?.textContent?.toLowerCase() || '';
                
                if (buttonText.includes('continue')) {
                    count++;
                }
            }
            
            return count;
        },
        
        async joinUltraFastBattles(context, targets) {
            const { logger } = context;
            const cfg = context.config.get();
            const userId = cfg.core?.userId;
            
            if (!userId) {
                logger.warn('‚ö†Ô∏è UserId n√£o configurado. N√£o √© poss√≠vel usar Ultra Fast Mode sem userId.');
                return [];
            }
            
            const joinedTargets = [];
            
            // Join all targets in parallel
            const joinPromises = targets.map(target => 
                context.http.joinBattle(target.monsterId, userId)
                    .then(result => ({ target, result }))
                    .catch(error => ({ target, result: { success: false, message: error.message } }))
            );
            
            const results = await Promise.all(joinPromises);
            
            for (const { target, result } of results) {
                if (result.success) {
                    joinedTargets.push(target);
                    logger.debug(`‚úÖ Joined: ${target.name} (ID: ${target.monsterId})`);
                } else if (result.cloudflareBlock) {
                    // Cloudflare blocked - still count as joined since battle exists
                    joinedTargets.push(target);
                    logger.debug(`‚ö†Ô∏è ${target.name}: Cloudflare block mas tentando atacar mesmo assim`);
                } else {
                    logger.debug(`‚ö†Ô∏è Join falhou: ${target.name} - ${result.message}`);
                }
            }
            
            return joinedTargets;
        },
        
        /**
         * Send attack using centralized combat service (Cloudflare-proof)
         */
        async sendWaveAttack(context, monsterId, skillId) {
            return context.combat.attackWaveMonsterDirect(monsterId, skillId);
        },
        
        async attackUltraFastBattles(context, targets, cfg) {
            const { logger } = context;
            const skillId = cfg.wave.skillId ?? -2;
            const parallelAttacks = cfg.wave.parallelAttacks || 10;
            const baseDamageTarget = cfg.wave.damageTarget || 3000000;
            const skillCosts = { '0': 1, '-1': 10, '-2': 50, '-3': 100, '-4': 200 };
            const skillCost = skillCosts[skillId.toString()] || 1;
            
            // 1. First fetch current damage for all targets
            await this.fetchCurrentDamages(context, targets);
            
            // 2. Filter out targets that already reached threshold or are invalid
            // Apply special boss logic: General/King/Empress/Bastion need 50M minimum
            const validTargets = targets.filter(t => {
                if (t.invalid) {
                    logger.debug(`‚è≠Ô∏è ${t.name}: Batalha inv√°lida, pulando`);
                    return false;
                }
                
                // Get effective damage target for this monster
                const effectiveDamageTarget = getEffectiveDamageTarget(t.name, baseDamageTarget);
                t.effectiveDamageTarget = effectiveDamageTarget;
                
                if (isSpecialBoss(t.name) && effectiveDamageTarget > baseDamageTarget) {
                    logger.info(`üëë ${t.name}: Boss especial detectado - alvo: ${formatNumber(effectiveDamageTarget)} (m√≠nimo 50M para loot)`);
                }
                
                if ((t.currentDamage || 0) >= effectiveDamageTarget) {
                    logger.info(`‚úÖ ${t.name}: J√° atingiu threshold (${formatNumber(t.currentDamage)}/${formatNumber(effectiveDamageTarget)})`);
                    this.state.ultraFastStats.monstersCompleted++;
                    return false;
                }
                return true;
            });
            
            if (validTargets.length === 0) {
                logger.info(`‚úÖ Todos os alvos j√° atingiram o threshold ou s√£o inv√°lidos`);
                return;
            }
            
            logger.info(`üöÄ PRE-FLIGHT ATTACK: ${validTargets.length} monstros precisam de ataque, alvo base ${formatNumber(baseDamageTarget)} dano`);
            
            // 3. Attack all targets in rounds until damage target reached
            const targetStates = validTargets.map(t => ({
                ...t,
                currentDamage: t.currentDamage || 0, // Preserve existing damage
                attackCount: 0,
                completed: false,
                dead: false
            }));
            
            let rounds = 0;
            const maxRounds = 100; // Safety limit
            let roundsWithoutProgress = 0;
            const maxRoundsWithoutProgress = 3; // Stop if 3 rounds without any success
            
            while (rounds < maxRounds) {
                rounds++;
                
                // Check stamina (recalculate each round to account for attacks)
                let currentStamina = context.stamina.getCurrent();
                if (currentStamina < skillCost) {
                    logger.info(`‚è≥ Stamina insuficiente (${currentStamina}/${skillCost}). Tentando recuperar...`);
                    
                    // üÜï Verificar se j√° tentamos loot dead e devemos ir direto para FSP
                    const skipLootDead = sessionStorage.getItem('autods_skip_loot_dead_use_fsp');
                    
                    // üÜï Tentar loot de dead monsters para poss√≠vel level up
                    if (cfg.wave.lootDeadBeforeFSP !== false && !skipLootDead) {
                        logger.info('üíÄ [LOOT DEAD] Tentando lootar dead monsters...');
                        
                        // Chamar lootDeadMonsters diretamente do ultraFastLootModule
                        const lootModule = context.moduleRegistry?.getModule('ultraFastLoot');
                        if (!lootModule || typeof lootModule.lootDeadMonsters !== 'function') {
                            logger.error('‚ùå [LOOT DEAD] ultraFastLootModule ou lootDeadMonsters n√£o encontrado');
                            sessionStorage.setItem('autods_skip_loot_dead_use_fsp', 'true');
                        } else {
                            const lootResult = await lootModule.lootDeadMonsters(context);
                            
                            if (lootResult.levelUp) {
                                // Level up detectado! Stamina recuperou
                                currentStamina = context.stamina.getCurrent();
                                logger.info(`üéâ [LOOT DEAD] Level up detectado! Nova stamina: ${currentStamina}`);
                                if (currentStamina >= skillCost) {
                                    logger.info(`üéâ Stamina recuperada (${currentStamina})! Continuando ataques...`);
                                    await this.ensureAliveMonstersView(context);
                                    continue; // Continuar loop de ataques
                                }
                            }
                            
                            if (lootResult.count === 0) {
                                logger.info('üíÄ [LOOT DEAD] Nenhum dead monster looteado. Tentando FSP...');
                                sessionStorage.setItem('autods_skip_loot_dead_use_fsp', 'true');
                            } else if (!lootResult.levelUp) {
                                logger.info(`üíÄ [LOOT DEAD] ${lootResult.count} monster(s) looteado(s), mas stamina n√£o recuperou. Tentando FSP...`);
                            }
                        }
                        // Se retornou false, a flag j√° foi setada dentro da fun√ß√£o
                    } else if (skipLootDead) {
                        logger.info('üíÄ [LOOT DEAD] Flag detectada - pulando loot dead, indo direto para FSP...');
                        sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                    }
                    
                    // Re-check stamina after loot dead attempt
                    currentStamina = context.stamina.getCurrent();
                    
                    // Tentar usar FSP se stamina ainda insuficiente
                    if (currentStamina < skillCost) {
                        logger.info(`üíä [FSP] autoFSP=${cfg.wave.autoFSP} - Verificando op√ß√£o FSP...`);
                        if (!cfg.wave.autoFSP) {
                            logger.info('üíä [FSP] autoFSP est√° DESATIVADO. N√£o usar√° FSP.');
                        } else {
                            logger.info('üíä [FSP] Usando Full Stamina Potion...');
                            const fspUsed = await context.inventory.useFullStaminaPotion();
                            if (fspUsed) {
                                logger.info('üíä [FSP] FSP usada com sucesso! Recarregando p√°gina...');
                                sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                                await sleep(500);
                                window.location.href = window.location.href;
                                return;
                            } else {
                                logger.info('üíä [FSP] Falha ao usar FSP ou sem FSP dispon√≠vel.');
                            }
                        }
                        
                        logger.info('‚è≥ Sem op√ß√µes de recupera√ß√£o. Parando ataques.');
                        break;
                    } else {
                        // Stamina recovered by loot dead
                        logger.info(`‚úÖ Stamina recuperada por loot dead (${currentStamina}). Continuando...`);
                        continue;
                    }
                }
                
                // Filter active targets (not completed, not dead)
                const activeTargets = targetStates.filter(t => !t.completed && !t.dead);
                
                if (activeTargets.length === 0) {
                    logger.info(`‚úÖ Todos os alvos completados ou mortos`);
                    break;
                }
                
                // Re-read stamina before calculating batch (stamina updates after attacks)
                currentStamina = context.stamina.getCurrent();
                
                // Calculate batch size based on stamina
                const possibleAttacks = Math.floor(currentStamina / skillCost);
                const batchSize = Math.min(possibleAttacks, parallelAttacks, activeTargets.length);
                
                if (batchSize <= 0) break;
                
                // Select targets for this batch (round-robin)
                const batchTargets = activeTargets.slice(0, batchSize);
                
                logger.debug(`‚öîÔ∏è Rodada ${rounds}: Atacando ${batchTargets.length} monstros em PARALELO...`);
                
                // Prepare attack promises
                const attackPromises = batchTargets.map(targetState => ({
                    targetState,
                    execute: () => this.sendWaveAttack(context, targetState.monsterId, skillId)
                }));
                
                // Execute all attacks simultaneously
                const startTime = Date.now();
                const results = await Promise.all(
                    attackPromises.map(async ({ targetState, execute }) => {
                        try {
                            const result = await execute();
                            return { targetState, result };
                        } catch (error) {
                            return { targetState, result: { success: false, error: error.message } };
                        }
                    })
                );
                const duration = Date.now() - startTime;
                
                // Process results
                let successCount = 0;
                let totalBatchDamage = 0;
                
                for (const { targetState, result } of results) {
                    if (result.success) {
                        const damageDealt = result.damageDealt || 0;
                        targetState.currentDamage += damageDealt;
                        targetState.attackCount++;
                        totalBatchDamage += damageDealt;
                        successCount++;
                        
                        this.state.ultraFastStats.attackCount++;
                        this.state.ultraFastStats.damageDealt += damageDealt;
                        
                        // Check if target reached (use individual effective target)
                        const targetDamage = targetState.effectiveDamageTarget || baseDamageTarget;
                        if (targetState.currentDamage >= targetDamage) {
                            targetState.completed = true;
                            const specialIcon = isSpecialBoss(targetState.name) ? 'üëë ' : '';
                            logger.info(`‚úÖ ${specialIcon}${targetState.name}: Alvo atingido! ${formatNumber(targetState.currentDamage)} dano em ${targetState.attackCount} ataques`);
                            this.state.ultraFastStats.monstersCompleted++;
                        }
                        
                        // Update stamina display
                        if (result.stamina !== undefined) {
                            const staminaEl = document.querySelector('#stamina_span');
                            if (staminaEl) staminaEl.textContent = result.stamina.toLocaleString();
                        }
                    } else if (result.dead) {
                        targetState.dead = true;
                        logger.info(`üíÄ ${targetState.name}: Monstro morto/inv√°lido`);
                        this.state.ultraFastStats.monstersCompleted++;
                    }
                }
                
                if (successCount > 0) {
                    logger.debug(`  ${successCount} hits, +${formatNumber(totalBatchDamage)} dano (${duration}ms)`);
                    roundsWithoutProgress = 0; // Reset counter on success
                } else {
                    roundsWithoutProgress++;
                    logger.warn(`‚ö†Ô∏è Rodada ${rounds}: Nenhum ataque bem-sucedido (${batchTargets.length} tentativas)`);
                    
                    // Check stamina again - might have been consumed without success
                    const currentStaminaCheck = context.stamina.getCurrent();
                    if (currentStaminaCheck < skillCost) {
                        logger.warn(`‚è≥ Stamina insuficiente ap√≥s rodada (${currentStaminaCheck}/${skillCost})`);
                        break;
                    }
                    
                    // Check if stuck in loop without progress
                    if (roundsWithoutProgress >= maxRoundsWithoutProgress) {
                        logger.warn(`‚ùå ${maxRoundsWithoutProgress} rodadas sem progresso. Parando ataques.`);
                        break;
                    }
                }
                
                // Small delay between rounds
                await sleep(cfg.wave.minDelayBetweenAttacks || 30);
            }
            
            // Summary
            for (const t of targetStates) {
                if (!t.completed && !t.dead && t.attackCount > 0) {
                    logger.info(`‚è∏Ô∏è ${t.name}: ${formatNumber(t.currentDamage)}/${formatNumber(t.effectiveDamageTarget || baseDamageTarget)} (${t.attackCount} ataques)`);
                }
            }
        },
        
        async attackOngoingBattles(context, cfg) {
            const { logger, dom } = context;
            const skillId = cfg.wave.skillId ?? -2;
            const parallelAttacks = cfg.wave.parallelAttacks || 10;
            const baseDamageTarget = cfg.wave.damageTarget || 3000000;
            const skillCosts = { '0': 1, '-1': 10, '-2': 50, '-3': 100, '-4': 200 };
            const skillCost = skillCosts[skillId.toString()] || 1;
            
            // Find ongoing battles
            const cards = dom.queryAll('.monster-card');
            const ongoingTargets = [];
            
            for (const card of cards) {
                const button = card.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button');
                const buttonText = button?.textContent?.toLowerCase() || '';
                
                if (!buttonText.includes('continue')) continue;
                
                // Get battle link
                const link = card.querySelector('a[href*="battle.php"][href*="id="]');
                const battleUrl = link?.href;
                const monsterIdMatch = battleUrl?.match(/[?&]id=(\d+)/);
                const monsterId = monsterIdMatch ? monsterIdMatch[1] : null;
                
                if (!monsterId) continue;
                
                // Extract monster name
                const nameNode = card.querySelector('h3, h4, .monster-name, .card-title');
                const name = nameNode ? nameNode.textContent.trim() : 'Unknown';
                
                ongoingTargets.push({ name, monsterId, battleUrl, currentDamage: 0 });
            }
            
            if (ongoingTargets.length === 0) {
                return;
            }
            
            // 1. Fetch current damage for all ongoing battles
            await this.fetchCurrentDamages(context, ongoingTargets);
            
            // 2. Filter out targets that already reached threshold
            // Apply special boss logic: General/King/Empress/Bastion need 50M minimum
            const validTargets = ongoingTargets.filter(t => {
                if (t.invalid) {
                    logger.debug(`‚è≠Ô∏è ${t.name}: Batalha inv√°lida, pulando`);
                    return false;
                }
                
                // Get effective damage target for this monster
                const effectiveDamageTarget = getEffectiveDamageTarget(t.name, baseDamageTarget);
                t.effectiveDamageTarget = effectiveDamageTarget;
                
                if (isSpecialBoss(t.name) && effectiveDamageTarget > baseDamageTarget) {
                    logger.info(`üëë ${t.name}: Boss especial detectado - alvo: ${formatNumber(effectiveDamageTarget)} (m√≠nimo 50M para loot)`);
                }
                
                if ((t.currentDamage || 0) >= effectiveDamageTarget) {
                    logger.info(`‚úÖ ${t.name}: J√° atingiu threshold (${formatNumber(t.currentDamage)}/${formatNumber(effectiveDamageTarget)})`);
                    this.state.ultraFastStats.monstersCompleted++;
                    return false;
                }
                return true;
            });
            
            if (validTargets.length === 0) {
                logger.info(`‚úÖ Todas as batalhas em andamento j√° atingiram o threshold`);
                return;
            }
            
            logger.info(`üöÄ PRE-FLIGHT: ${validTargets.length} batalha(s) precisam de ataque...`);
            
            // Use same strategy as attackUltraFastBattles but with ongoing targets
            const targetStates = validTargets.map(t => ({
                ...t,
                currentDamage: t.currentDamage || 0, // Preserve existing damage
                attackCount: 0,
                completed: false,
                dead: false,
                effectiveDamageTarget: t.effectiveDamageTarget || baseDamageTarget
            }));
            
            let rounds = 0;
            const maxRounds = 100;
            
            while (rounds < maxRounds) {
                rounds++;
                
                const currentStamina = context.stamina.getCurrent();
                if (currentStamina < skillCost) {
                    logger.info(`‚è≥ Stamina insuficiente (${currentStamina}/${skillCost}). Tentando recuperar...`);
                    
                    // üÜï Verificar se j√° tentamos loot dead e devemos ir direto para FSP
                    const skipLootDead = sessionStorage.getItem('autods_skip_loot_dead_use_fsp');
                    
                    // üÜï Tentar loot de dead monsters para poss√≠vel level up
                    if (cfg.wave.lootDeadBeforeFSP !== false && !skipLootDead) {
                        logger.info('üíÄ [LOOT DEAD] Tentando lootar dead monsters...');
                        
                        // Chamar lootDeadMonsters diretamente do ultraFastLootModule
                        const lootModule = context.moduleRegistry?.getModule('ultraFastLoot');
                        if (!lootModule || typeof lootModule.lootDeadMonsters !== 'function') {
                            logger.error('‚ùå [LOOT DEAD] ultraFastLootModule ou lootDeadMonsters n√£o encontrado');
                            sessionStorage.setItem('autods_skip_loot_dead_use_fsp', 'true');
                        } else {
                            const lootResult = await lootModule.lootDeadMonsters(context);
                            
                            if (lootResult.levelUp) {
                                // Level up detectado! Stamina recuperou
                                const newStamina = context.stamina.getCurrent();
                                logger.info(`üéâ [LOOT DEAD] Level up detectado! Nova stamina: ${newStamina}`);
                                if (newStamina >= skillCost) {
                                    logger.info(`üéâ Stamina recuperada (${newStamina})! Continuando ataques...`);
                                    await this.ensureAliveMonstersView(context);
                                    continue; // Continuar loop de ataques
                                }
                            }
                            
                            if (lootResult.count === 0) {
                                logger.info('üíÄ [LOOT DEAD] Nenhum dead monster looteado.');
                                sessionStorage.setItem('autods_skip_loot_dead_use_fsp', 'true');
                            } else if (!lootResult.levelUp) {
                                logger.info(`üíÄ [LOOT DEAD] ${lootResult.count} monster(s) looteado(s), mas stamina n√£o recuperou.`);
                            }
                        }
                        // Se retornou false, a flag j√° foi setada dentro da fun√ß√£o
                    } else if (skipLootDead) {
                        logger.info('üíÄ [LOOT DEAD] Flag detectada - pulando loot dead, indo direto para FSP...');
                        sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                    }
                    
                    // Tentar usar FSP se dispon√≠vel
                    logger.info(`üíä [FSP] autoFSP=${cfg.wave.autoFSP} - Verificando op√ß√£o FSP...`);
                    if (!cfg.wave.autoFSP) {
                        logger.info('üíä [FSP] autoFSP est√° DESATIVADO. N√£o usar√° FSP.');
                    } else {
                        logger.info('üíä [FSP] Usando Full Stamina Potion...');
                        const fspUsed = await context.inventory.useFullStaminaPotion();
                        if (fspUsed) {
                            logger.info('üíä [FSP] FSP usada com sucesso! Recarregando p√°gina...');
                            sessionStorage.removeItem('autods_skip_loot_dead_use_fsp');
                            await sleep(500);
                            window.location.href = window.location.href;
                            return;
                        } else {
                            logger.info('üíä [FSP] Falha ao usar FSP ou sem FSP dispon√≠vel.');
                        }
                    }
                    
                    logger.info('‚è≥ Sem op√ß√µes de recupera√ß√£o. Parando ataques.');
                    break;
                }
                
                const activeTargets = targetStates.filter(t => !t.completed && !t.dead);
                
                if (activeTargets.length === 0) {
                    logger.info(`‚úÖ Todos os alvos completados ou mortos`);
                    break;
                }
                
                const possibleAttacks = Math.floor(currentStamina / skillCost);
                const batchSize = Math.min(possibleAttacks, parallelAttacks, activeTargets.length);
                
                if (batchSize <= 0) break;
                
                const batchTargets = activeTargets.slice(0, batchSize);
                
                // Use GM_xmlhttpRequest via sendWaveAttack
                const attackPromises = batchTargets.map(targetState => ({
                    targetState,
                    execute: () => this.sendWaveAttack(context, targetState.monsterId, skillId)
                }));
                
                const startTime = Date.now();
                const results = await Promise.all(
                    attackPromises.map(async ({ targetState, execute }) => {
                        try {
                            const result = await execute();
                            return { targetState, result };
                        } catch (error) {
                            return { targetState, result: { success: false, error: error.message } };
                        }
                    })
                );
                const duration = Date.now() - startTime;
                
                let successCount = 0;
                let totalBatchDamage = 0;
                
                for (const { targetState, result } of results) {
                    if (result.success) {
                        const damageDealt = result.damageDealt || 0;
                        targetState.currentDamage += damageDealt;
                        targetState.attackCount++;
                        totalBatchDamage += damageDealt;
                        successCount++;
                        
                        this.state.ultraFastStats.attackCount++;
                        this.state.ultraFastStats.damageDealt += damageDealt;
                        
                        // Check if target reached (use individual effective target)
                        const targetDamage = targetState.effectiveDamageTarget || baseDamageTarget;
                        if (targetState.currentDamage >= targetDamage) {
                            targetState.completed = true;
                            const specialIcon = isSpecialBoss(targetState.name) ? 'üëë ' : '';
                            logger.info(`‚úÖ ${specialIcon}${targetState.name}: Alvo atingido! ${formatNumber(targetState.currentDamage)} dano`);
                            this.state.ultraFastStats.monstersCompleted++;
                        }
                        
                        if (result.stamina !== undefined) {
                            const staminaEl = document.querySelector('#stamina_span');
                            if (staminaEl) staminaEl.textContent = result.stamina.toLocaleString();
                        }
                    } else if (result.dead) {
                        targetState.dead = true;
                        logger.info(`üíÄ ${targetState.name}: Monstro morto/inv√°lido`);
                        this.state.ultraFastStats.monstersCompleted++;
                    }
                }
                
                if (successCount > 0) {
                    logger.debug(`  Rodada ${rounds}: ${successCount} hits, +${formatNumber(totalBatchDamage)} dano (${duration}ms)`);
                }
                
                await sleep(cfg.wave.minDelayBetweenAttacks || 30);
            }
            
            // Summary
            for (const t of targetStates) {
                if (!t.completed && !t.dead && t.attackCount > 0) {
                    logger.info(`‚è∏Ô∏è ${t.name}: ${formatNumber(t.currentDamage)}/${formatNumber(t.effectiveDamageTarget || baseDamageTarget)} (${t.attackCount} ataques)`);
                }
            }
        },
    };

    const waveUiModule = {
        id: 'waveUiEnhancements',
        match: ({ location }) => /active_wave\.php/i.test(location.pathname),
        init() {
            this.state = {
                continueBattlesExpanded: true,
                lootExpanded: true,
                filterSettings: {
                    nameFilter: '',
                    hideImg: false,
                    sortOrder: 'default'
                }
            };
        },
        activate(context) {
            if (!this.state) this.init(context);

            // Wait for DOM to be ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    this.initMonsterSorting(context);
                    this.initMonsterFilter(context);
                });
            } else {
                this.initMonsterSorting(context);
                this.initMonsterFilter(context);
            }
        },
        initMonsterFilter(context) {
            const monsterContainer = context.dom.query('.monster-container');
            if (!monsterContainer) return;

            // Load saved filter settings
            const savedSettings = context.storage.get('waveFilterSettings', this.state.filterSettings);
            this.state.filterSettings = { ...this.state.filterSettings, ...savedSettings };

            const filterContainer = document.createElement('div');
            filterContainer.style.cssText = `
                padding: 10px;
                background: rgba(30, 30, 46, 0.8);
                border-radius: 8px;
                margin-bottom: 15px;
                display: flex;
                gap: 10px;
                align-items: center;
                justify-content: center;
                flex-wrap: wrap;
                border: 1px solid rgba(70, 130, 220, 0.3);
            `;

            filterContainer.innerHTML = `
                <input type="text" id="monster-name-filter" placeholder="Filter by monster name..."
                    value="${this.state.filterSettings.nameFilter}"
                    style="padding: 8px 12px; background: rgba(20, 30, 50, 0.8); color: #e0e0e0;
                    border: 1px solid rgba(70, 130, 220, 0.4); border-radius: 6px; min-width: 200px;
                    font-size: 13px; transition: all 0.2s;">
                <select id="monster-sort-order"
                    style="padding: 8px 12px; background: rgba(20, 30, 50, 0.8); color: #e0e0e0;
                    border: 1px solid rgba(70, 130, 220, 0.4); border-radius: 6px; font-size: 13px;
                    cursor: pointer; transition: all 0.2s;">
                    <option value="default" ${this.state.filterSettings.sortOrder === 'default' ? 'selected' : ''}>Default Order</option>
                    <option value="hp-asc" ${this.state.filterSettings.sortOrder === 'hp-asc' ? 'selected' : ''}>HP: Low ‚Üí High</option>
                    <option value="hp-desc" ${this.state.filterSettings.sortOrder === 'hp-desc' ? 'selected' : ''}>HP: High ‚Üí Low</option>
                    <option value="name-asc" ${this.state.filterSettings.sortOrder === 'name-asc' ? 'selected' : ''}>Name: A ‚Üí Z</option>
                    <option value="name-desc" ${this.state.filterSettings.sortOrder === 'name-desc' ? 'selected' : ''}>Name: Z ‚Üí A</option>
                </select>
                <label style="display: flex; align-items: center; gap: 6px; color: #b8c5d6; cursor: pointer;">
                    <input type="checkbox" id="hide-img-monsters" ${this.state.filterSettings.hideImg ? 'checked' : ''}
                        style="cursor: pointer; width: 16px; height: 16px;">
                    <span style="font-size: 13px;">Hide images</span>
                </label>
                <button id="clear-filters"
                    style="padding: 8px 16px; background: linear-gradient(135deg, rgba(243, 139, 168, 0.6), rgba(203, 116, 139, 0.7));
                    color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;
                    transition: all 0.2s; box-shadow: 0 2px 8px rgba(0,0,0,0.2);">
                    Clear Filters
                </button>
            `;

            const contentArea = context.dom.query('.content-area') || monsterContainer.parentElement;
            if (contentArea) {
                contentArea.insertBefore(filterContainer, monsterContainer);
            }

            // Apply saved filters immediately
            if (this.state.filterSettings.nameFilter || this.state.filterSettings.hideImg) {
                setTimeout(() => this.applyMonsterFilters(context), 100);
            }
            
            // Apply saved sort order immediately
            if (this.state.filterSettings.sortOrder && this.state.filterSettings.sortOrder !== 'default') {
                setTimeout(() => this.applySortOrder(context), 150);
            }

            // Event listeners
            const nameInput = document.getElementById('monster-name-filter');
            const sortSelect = document.getElementById('monster-sort-order');
            const hideImgCheck = document.getElementById('hide-img-monsters');
            const clearBtn = document.getElementById('clear-filters');

            if (nameInput) {
                nameInput.addEventListener('input', () => {
                    this.state.filterSettings.nameFilter = nameInput.value;
                    context.storage.set('waveFilterSettings', this.state.filterSettings);
                    this.applyMonsterFilters(context);
                });
            }

            if (sortSelect) {
                sortSelect.addEventListener('change', () => {
                    this.state.filterSettings.sortOrder = sortSelect.value;
                    context.storage.set('waveFilterSettings', this.state.filterSettings);
                    this.applySortOrder(context);
                });
            }

            if (hideImgCheck) {
                hideImgCheck.addEventListener('change', () => {
                    this.state.filterSettings.hideImg = hideImgCheck.checked;
                    context.storage.set('waveFilterSettings', this.state.filterSettings);
                    this.applyMonsterFilters(context);
                });
            }

            if (clearBtn) {
                clearBtn.addEventListener('click', () => {
                    this.state.filterSettings = { nameFilter: '', hideImg: false, sortOrder: 'default' };
                    context.storage.set('waveFilterSettings', this.state.filterSettings);
                    if (nameInput) nameInput.value = '';
                    if (sortSelect) sortSelect.value = 'default';
                    if (hideImgCheck) hideImgCheck.checked = false;
                    this.applyMonsterFilters(context);
                    this.applySortOrder(context);
                    context.ui?.showToast?.(context, 'info', 'Filters Cleared', 'All filters have been reset');
                });
            }
        },
        applyMonsterFilters(context) {
            const nameFilter = this.state.filterSettings.nameFilter.toLowerCase();
            const hideImg = this.state.filterSettings.hideImg;
            const monsters = context.dom.queryAll('.monster-card');

            monsters.forEach(monster => {
                let shouldShow = true;

                // Name filter
                if (nameFilter) {
                    const nameNode = context.dom.query('h3, h4, .monster-name, .card-title', monster);
                    const monsterName = nameNode ? nameNode.textContent.toLowerCase() : '';
                    shouldShow = monsterName.includes(nameFilter);
                }

                // Image hiding
                if (hideImg) {
                    const img = context.dom.query('img', monster);
                    if (img) img.style.display = 'none';
                } else {
                    const img = context.dom.query('img', monster);
                    if (img) img.style.display = '';
                }

                monster.style.display = shouldShow ? '' : 'none';
            });
        },
        applySortOrder(context) {
            const sortOrder = this.state.filterSettings.sortOrder || 'default';
            if (sortOrder === 'default') return;

            // Ordena monstros dentro de cada se√ß√£o individualmente
            const sections = ['continue', 'loot', 'join'];
            
            sections.forEach(sectionType => {
                const sectionContent = context.dom.query(`[data-content="${sectionType}"]`);
                if (!sectionContent) return;

                // Busca o container interno dentro da se√ß√£o
                const sectionContainer = context.dom.query('.monster-container', sectionContent);
                if (!sectionContainer) return;

                const monsters = context.dom.queryAll('.monster-card', sectionContainer);
                if (monsters.length === 0) return;

                // Extract monster data for sorting
                const monsterData = monsters.map(card => {
                    const nameNode = context.dom.query('h3, h4, .monster-name, .card-title', card);
                    const name = nameNode ? nameNode.textContent.trim() : '';
                    
                    // Extract HP from progress bar or HP text
                    let currentHp = 0;
                    let maxHp = 0;
                    
                    // Try HP text first (e.g., "1,234,567 / 2,000,000 HP")
                    const hpText = card.querySelector('.hp-text, .monster-hp, .stat-value');
                    if (hpText) {
                        const hpMatch = hpText.textContent.match(/([0-9,]+)\s*\/\s*([0-9,]+)/);
                        if (hpMatch) {
                            currentHp = parseInt(hpMatch[1].replace(/,/g, ''), 10);
                            maxHp = parseInt(hpMatch[2].replace(/,/g, ''), 10);
                        }
                    }
                    
                    // Try progress bar width as fallback
                    if (currentHp === 0) {
                        const hpBar = card.querySelector('.progress-bar, .hp-bar, .hp-fill, [role="progressbar"]');
                        if (hpBar) {
                            const width = hpBar.style.width;
                            const percentMatch = width.match(/([0-9.]+)%/);
                            if (percentMatch) {
                                const percent = parseFloat(percentMatch[1]);
                                if (!isNaN(percent) && maxHp > 0) {
                                    currentHp = Math.round((percent / 100) * maxHp);
                                }
                            }
                        }
                    }

                    return { card, name, currentHp, maxHp };
                });

                // Sort based on order
                switch (sortOrder) {
                    case 'hp-asc':
                        monsterData.sort((a, b) => a.currentHp - b.currentHp);
                        break;
                    case 'hp-desc':
                        monsterData.sort((a, b) => b.currentHp - a.currentHp);
                        break;
                    case 'name-asc':
                        monsterData.sort((a, b) => a.name.localeCompare(b.name));
                        break;
                    case 'name-desc':
                        monsterData.sort((a, b) => b.name.localeCompare(a.name));
                        break;
                }

                // Re-append cards in sorted order to the section container
                monsterData.forEach(({ card }) => {
                    sectionContainer.appendChild(card);
                });
            });

            // context.logger.debug(`[WaveUI] Sorted monsters by ${sortOrder} within each section`);
        },
        initMonsterSorting(context) {
            const monsterContainer = context.dom.query('.monster-container');
            if (!monsterContainer) return;

            // Load saved expansion states
            const savedStates = context.storage.get('waveSectionStates', {
                continueBattlesExpanded: this.state.continueBattlesExpanded,
                lootExpanded: this.state.lootExpanded
            });
            this.state.continueBattlesExpanded = savedStates.continueBattlesExpanded;
            this.state.lootExpanded = savedStates.lootExpanded;

            const continueBattleSection = document.createElement('div');
            continueBattleSection.className = 'monster-section';
            continueBattleSection.innerHTML = `
                <div class="monster-section-header" data-section="continue">
                    <h3 style="color: #f38ba8; margin: 0; flex: 1;">
                        ‚öîÔ∏è Continue Battle 
                        <span class="section-count" data-count="continue" style="
                            background: rgba(243, 139, 168, 0.3);
                            padding: 2px 8px;
                            border-radius: 12px;
                            font-size: 12px;
                            margin-left: 8px;
                            border: 1px solid rgba(243, 139, 168, 0.5);
                        ">0</span>
                    </h3>
                    <button class="section-toggle-btn" data-toggle="continue">${this.state.continueBattlesExpanded ? '‚àí' : '+'}</button>
                </div>
                <div class="monster-section-content" data-content="continue" style="display: ${this.state.continueBattlesExpanded ? 'block' : 'none'};">
                    <div class="monster-container" style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px;"></div>
                </div>
            `;

            const lootSection = document.createElement('div');
            lootSection.className = 'monster-section';
            lootSection.innerHTML = `
                <div class="monster-section-header" data-section="loot">
                    <h3 style="color: #f9e2af; margin: 0; flex: 1;">
                        üí∞ Available Loot
                        <span class="section-count" data-count="loot" style="
                            background: rgba(249, 226, 175, 0.3);
                            padding: 2px 8px;
                            border-radius: 12px;
                            font-size: 12px;
                            margin-left: 8px;
                            border: 1px solid rgba(249, 226, 175, 0.5);
                        ">0</span>
                    </h3>
                    <button class="section-toggle-btn" data-toggle="loot">${this.state.lootExpanded ? '‚àí' : '+'}</button>
                </div>
                <div class="monster-section-content" data-content="loot" style="display: ${this.state.lootExpanded ? 'block' : 'none'};">
                    <div class="monster-container" style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px;"></div>
                </div>
            `;

            const joinBattleSection = document.createElement('div');
            joinBattleSection.className = 'monster-section';
            joinBattleSection.innerHTML = `
                <div class="monster-section-header">
                    <h3 style="color: #a6e3a1; margin: 0; flex: 1;">
                        ‚ö° Join a Battle
                        <span class="section-count" data-count="join" style="
                            background: rgba(166, 227, 161, 0.3);
                            padding: 2px 8px;
                            border-radius: 12px;
                            font-size: 12px;
                            margin-left: 8px;
                            border: 1px solid rgba(166, 227, 161, 0.5);
                        ">0</span>
                    </h3>
                </div>
                <div class="monster-section-content" data-content="join">
                    <div class="monster-container" style="display: flex; flex-wrap: wrap; gap: 15px;"></div>
                </div>
            `;

            // Categorize monsters based on button text
            const monsterCards = Array.from(context.dom.queryAll('.monster-card'));
            const continueCards = [];
            const lootCards = [];
            const joinCards = [];

            monsterCards.forEach(card => {
                // Try multiple selectors for buttons
                const button = card.querySelector('.join-btn, button.join-btn, .btn, button, a.btn');
                const buttonText = button ? button.textContent.toLowerCase().trim() : '';

                // Check button text to categorize (priority order: Continue > Loot > Join)
                if (buttonText.includes('continue')) {
                    continueCards.push(card);
                } else if (buttonText.includes('loot')) {
                    lootCards.push(card);
                } else if (buttonText.includes('join') || buttonText.includes('‚ö°') || buttonText === 'fight') {
                    joinCards.push(card);
                } else {
                    // If no clear indicator, check if monster is dead (data-dead="1" or HP is 0)
                    const isDead = card.getAttribute('data-dead') === '1' ||
                                   card.querySelector('.hp-fill[style*="width:0"]') ||
                                   card.querySelector('.hp-fill[style*="width: 0"]') ||
                                   card.querySelector('.monster-img.grayscale');

                    if (isDead) {
                        lootCards.push(card);
                    } else {
                        joinCards.push(card);
                    }
                }
            });

            // Sort join cards by HP (descending - highest HP first for easier targeting)
            joinCards.sort((a, b) => {
                const hpA = this.extractHP(a);
                const hpB = this.extractHP(b);
                return hpB - hpA;
            });

            // Clear and rebuild container
            monsterContainer.innerHTML = '';

            if (continueCards.length > 0) {
                const continueContent = continueBattleSection.querySelector('[data-content="continue"] .monster-container');
                continueCards.forEach(card => continueContent.appendChild(card));
                monsterContainer.appendChild(continueBattleSection);
                
                // Update counter
                const continueCount = continueBattleSection.querySelector('[data-count="continue"]');
                if (continueCount) continueCount.textContent = continueCards.length;
            }

            if (lootCards.length > 0) {
                const lootContent = lootSection.querySelector('[data-content="loot"] .monster-container');
                lootCards.forEach(card => lootContent.appendChild(card));
                monsterContainer.appendChild(lootSection);
                
                // Update counter
                const lootCount = lootSection.querySelector('[data-count="loot"]');
                if (lootCount) lootCount.textContent = lootCards.length;
            }

            if (joinCards.length > 0) {
                const joinContent = joinBattleSection.querySelector('.monster-section-content .monster-container');
                joinCards.forEach(card => joinContent.appendChild(card));
                monsterContainer.appendChild(joinBattleSection);
                
                // Update counter
                const joinCount = joinBattleSection.querySelector('[data-count="join"]');
                if (joinCount) joinCount.textContent = joinCards.length;
            }

            // Add toggle functionality
            const continueToggle = continueBattleSection.querySelector('[data-toggle="continue"]');
            const lootToggle = lootSection.querySelector('[data-toggle="loot"]');

            if (continueToggle) {
                continueToggle.addEventListener('click', () => {
                    this.state.continueBattlesExpanded = !this.state.continueBattlesExpanded;
                    const content = continueBattleSection.querySelector('[data-content="continue"]');
                    content.style.display = this.state.continueBattlesExpanded ? 'block' : 'none';
                    continueToggle.textContent = this.state.continueBattlesExpanded ? '‚àí' : '+';
                    context.storage.set('waveSectionStates', {
                        continueBattlesExpanded: this.state.continueBattlesExpanded,
                        lootExpanded: this.state.lootExpanded
                    });
                });
            }

            if (lootToggle) {
                lootToggle.addEventListener('click', () => {
                    this.state.lootExpanded = !this.state.lootExpanded;
                    const content = lootSection.querySelector('[data-content="loot"]');
                    content.style.display = this.state.lootExpanded ? 'block' : 'none';
                    lootToggle.textContent = this.state.lootExpanded ? '‚àí' : '+';
                    context.storage.set('waveSectionStates', {
                        continueBattlesExpanded: this.state.continueBattlesExpanded,
                        lootExpanded: this.state.lootExpanded
                    });
                });
            }

            // Log categorization results
            context.logger.info(`[WaveUI] Categorized monsters: Continue=${continueCards.length}, Loot=${lootCards.length}, Join=${joinCards.length}`);

            // Add styles
            this.addMonsterSectionStyles(context);
        },
        extractHP(card) {
            const hpNode = card.querySelector('[data-stat="hp"], .hp-text, .hp-value, .monster-hp, .hp-bar + div, .hp');
            const hpText = hpNode ? hpNode.textContent : '';
            return numberFromText(hpText) || 0;
        },
        addMonsterSectionStyles(context) {
            if (document.getElementById('autods-monster-section-styles')) return;

            const style = document.createElement('style');
            style.id = 'autods-monster-section-styles';
            style.textContent = `
                .monster-section {
                    margin-bottom: 20px;
                    background: rgba(30, 30, 46, 0.6);
                    border-radius: 10px;
                    overflow: hidden;
                    border: 1px solid rgba(70, 130, 220, 0.25);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                }
                
                /* Continue Battle section - Red/Pink theme */
                .monster-section [data-section="continue"] {
                    background: linear-gradient(135deg, rgba(243, 139, 168, 0.15), rgba(203, 116, 139, 0.2));
                    border-bottom: 2px solid rgba(243, 139, 168, 0.4);
                }
                
                /* Loot section - Yellow theme */
                .monster-section [data-section="loot"] {
                    background: linear-gradient(135deg, rgba(249, 226, 175, 0.15), rgba(229, 200, 144, 0.2));
                    border-bottom: 2px solid rgba(249, 226, 175, 0.4);
                }
                
                .monster-section-header {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    padding: 14px 18px;
                    background: linear-gradient(135deg, rgba(30, 50, 100, 0.4), rgba(20, 40, 80, 0.5));
                    cursor: pointer;
                    border-bottom: 1px solid rgba(70, 130, 220, 0.2);
                    transition: background 0.2s ease;
                }
                .monster-section-header:hover {
                    background: linear-gradient(135deg, rgba(40, 70, 130, 0.5), rgba(30, 50, 100, 0.6));
                }
                .monster-section-header h3 {
                    font-size: 16px;
                    font-weight: 700;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                    display: flex;
                    align-items: center;
                }
                .section-count {
                    animation: pulse 2s ease-in-out infinite;
                }
                @keyframes pulse {
                    0%, 100% { opacity: 1; }
                    50% { opacity: 0.7; }
                }
                .section-toggle-btn {
                    background: rgba(70, 130, 220, 0.3);
                    border: 1px solid rgba(100, 160, 255, 0.4);
                    color: #e0e0e0;
                    padding: 6px 12px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 18px;
                    font-weight: bold;
                    min-width: 36px;
                    transition: all 0.2s;
                    font-family: monospace;
                }
                .section-toggle-btn:hover {
                    background: rgba(70, 130, 220, 0.5);
                    border-color: rgba(100, 160, 255, 0.6);
                    transform: scale(1.1);
                }
                .monster-section-content {
                    padding: 16px 18px;
                    background: rgba(10, 18, 30, 0.3);
                }
            `;
            document.head.appendChild(style);
        }
    };

    /**
     * Special Boss Farm Module
     * Dedicated module for farming special bosses (General, King, Empress, Bastion)
     * Ensures 50M damage minimum for special loot drops
     * Uses GM_xmlhttpRequest for direct API calls (like Ultra Fast Mode)
     */
    const specialBossFarmModule = {
        id: 'specialBossFarm',
        match: ({ location }) => /active_wave\.php/i.test(location.pathname),
        
        init(context) {
            this.state = {
                running: false,
                activeBosses: 0, // üÜï Count of bosses currently being attacked (not just waiting)
                stats: {
                    bossesFound: 0,
                    bossesCompleted: 0,
                    totalAttacks: 0,
                    totalDamage: 0,
                    potionsUsed: 0,
                    startTime: null
                },
                lastCheckTime: null
            };
        },

        activate(context) {
            const cfg = context.config.get();
            if (!cfg.core.enabled || !cfg.specialBossFarm?.enabled) {
                if (this.state) this.state.running = false;
                return;
            }

            if (!this.state) this.init(context);
            if (this.state.running) return;

            this.state.running = true;
            this.state.stats.startTime = Date.now();
            
            context.logger.info('üëë Special Boss Farm ativado! (Ultra Fast Mode)');

            (async () => {
                try {
                    await this.runBossFarmLoop(context);
                } catch (error) {
                    context.logger.error('[SpecialBossFarm] Erro fatal:', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },

        async runBossFarmLoop(context) {
            const { logger } = context;
            
            logger.info('üëë Iniciando loop de farm de bosses especiais (Ultra Fast)...');

            while (/active_wave\.php/i.test(context.location.pathname)) {
                const cfg = context.config.get();
                
                if (!cfg.core.enabled || !cfg.specialBossFarm?.enabled) {
                    logger.info('üëë Special Boss Farm desativado via configura√ß√£o.');
                    break;
                }

                const bossCfg = cfg.specialBossFarm;
                
                // 1. Scan for special bosses
                const bosses = await this.scanSpecialBosses(context, bossCfg);
                
                if (bosses.length === 0) {
                    this.state.activeBosses = 0; // üÜï No bosses to attack
                    const waitTime = bossCfg.checkInterval || 300000; // 5 minutes default
                    logger.info(`üëë Nenhum boss especial dispon√≠vel. Aguardando ${Math.round(waitTime / 60000)} minuto(s)...`);
                    this.state.lastCheckTime = Date.now();
                    await sleep(waitTime);
                    logger.info('üëë Recarregando p√°gina para verificar novamente...');
                    window.location.href = window.location.href;
                    return;
                }

                logger.info(`üëë ${bosses.length} boss(es) especial(is) encontrado(s)!`);
                this.state.stats.bossesFound += bosses.length;
                this.state.activeBosses = bosses.length; // üÜï Mark bosses as being processed

                // 2. Join bosses via API (Ultra Fast Mode)
                const joinedBosses = await this.joinBossesViaApi(context, bosses, bossCfg);
                
                if (joinedBosses.length === 0) {
                    logger.warn('üëë Falha ao entrar nas batalhas. Aguardando 30s...');
                    await sleep(30000);
                    continue;
                }

                // 3. Attack until target damage reached (via GM_xmlhttpRequest)
                const attackResult = await this.attackBossesUltraFast(context, joinedBosses, bossCfg);
                
                this.state.activeBosses = 0; // üÜï Finished attacking bosses

                // 4. Decide next action based on result
                if (!attackResult.hadWork) {
                    // All bosses already completed - wait before checking again
                    const waitTime = bossCfg.checkInterval || 300000;
                    logger.info(`üëë Todos os bosses j√° completados. Aguardando ${Math.round(waitTime / 60000)} minuto(s)...`);
                    this.state.lastCheckTime = Date.now();
                    await sleep(waitTime);
                    logger.info('üëë Recarregando p√°gina para verificar novamente...');
                    window.location.href = window.location.href;
                    return;
                } else {
                    // Had work - reload quickly to check for more
                    logger.info('üëë Bosses processados. Recarregando para verificar novamente...');
                    await sleep(2000);
                    window.location.href = window.location.href;
                    return;
                }
            }
        },

        async scanSpecialBosses(context, cfg) {
            const { logger, dom } = context;
            const cards = dom.queryAll('.monster-card');
            
            if (!cards.length) {
                return [];
            }

            // Boss detection threshold: 100 billion (100B) HP
            const BOSS_HP_THRESHOLD = 100_000_000_000;
            const bosses = [];

            for (const card of cards) {
                // Extract monster name
                const nameNode = card.querySelector('h3, h4, .monster-name, .card-title');
                const monsterName = nameNode ? nameNode.textContent.trim() : '';

                // Extract HP - Find .stat-row with .stat-icon.hp child
                const hpRow = Array.from(card.querySelectorAll('.stat-row')).find(row => row.querySelector('.stat-icon.hp'));
                const hpValueNode = hpRow?.querySelector('.stat-value');
                const hpText = hpValueNode?.textContent ?? '';
                
                // Parse current HP and max HP from "current / max" format
                const hpMatch = hpText.match(/(\d{1,3}(?:,\d{3})*|\d+)\s*\/\s*(\d{1,3}(?:,\d{3})*|\d+)/);
                const currentHp = hpMatch ? numberFromText(hpMatch[1]) : null;  // hpMatch[1] is current HP
                const maxHp = hpMatch ? numberFromText(hpMatch[2]) : null;  // hpMatch[2] is max HP

                // üÜï BOSS DETECTION: Any mob with 100B+ max HP is considered a boss
                if (!maxHp || maxHp < BOSS_HP_THRESHOLD) {
                    continue;
                }

                // üÜï SKIP DEAD BOSSES: Ignore bosses with 0 HP (already dead/lootable)
                if (!currentHp || currentHp === 0) {
                    logger.debug(`üëë ${monsterName}: Ignorando boss morto (HP: 0)`);
                    continue;
                }

                // Get button to check status
                const button = card.querySelector('#join-battle, button.btn-join, .join-btn button, button.join-btn, .join-btn, button');
                const buttonText = button?.textContent?.toLowerCase() || '';
                
                // Get battle link - try multiple selectors
                let monsterId = null;
                
                // Try link with id parameter
                const link = card.querySelector('a[href*="battle.php"][href*="id="]');
                if (link) {
                    const monsterIdMatch = link.href.match(/[?&]id=(\d+)/);
                    monsterId = monsterIdMatch ? monsterIdMatch[1] : null;
                }
                
                // Fallback: try data attributes
                if (!monsterId) {
                    monsterId = card.dataset?.monsterId || card.dataset?.id || card.getAttribute('data-monster-id');
                }
                
                // Fallback: try button onclick
                if (!monsterId && button) {
                    const onclickMatch = button.getAttribute('onclick')?.match(/(\d+)/);
                    monsterId = onclickMatch ? onclickMatch[1] : null;
                }

                if (!monsterId) {
                    logger.warn(`üëë ${monsterName}: N√£o encontrou ID do monstro`);
                    continue;
                }

                const hasJoined = buttonText.includes('continue');
                const canJoin = buttonText.includes('join') || buttonText.includes('fight');

                bosses.push({
                    card,
                    name: monsterName,
                    monsterId,
                    hp: maxHp,
                    currentHp,
                    hasJoined,
                    canJoin,
                    button,
                    currentDamage: 0
                });

                logger.info(`üëë Boss detectado: ${monsterName} (HP: ${formatNumber(currentHp)}/${formatNumber(maxHp)}, ID: ${monsterId}, ${hasJoined ? 'JOINED' : 'NOT JOINED'})`);
            }

            return bosses;
        },

        async joinBossesViaApi(context, bosses, cfg) {
            const { logger } = context;
            const joinedBosses = [];
            
            // Get user ID
            const userId = context.userSession.ensureUserId(context);
            if (!userId) {
                logger.error('üëë User ID n√£o encontrado! N√£o √© poss√≠vel entrar nas batalhas via API.');
                return [];
            }

            logger.info(`üëë Entrando em ${bosses.length} boss(es) via API...`);

            // Join all bosses in parallel
            const joinPromises = bosses.map(async (boss) => {
                if (boss.hasJoined) {
                    logger.debug(`üëë ${boss.name}: J√° est√° na batalha`);
                    return { boss, success: true, alreadyJoined: true };
                }

                try {
                    const result = await context.http.joinBattle(boss.monsterId, userId);
                    return { boss, ...result };
                } catch (error) {
                    return { boss, success: false, error: error.message };
                }
            });

            const results = await Promise.all(joinPromises);

            for (const result of results) {
                if (result.success || result.alreadyJoined) {
                    logger.info(`‚úÖ ${result.boss.name}: ${result.alreadyJoined ? 'J√° estava na batalha' : 'Entrou via API!'}`);
                    result.boss.hasJoined = true;
                    joinedBosses.push(result.boss);
                } else {
                    logger.warn(`‚ùå ${result.boss.name}: Falha ao entrar - ${result.message || result.error || 'Erro desconhecido'}`);
                }
            }

            logger.info(`üëë Join Results: ${joinedBosses.length}/${bosses.length} bem-sucedidos`);
            return joinedBosses;
        },

        async attackBossesUltraFast(context, bosses, cfg) {
            const { logger } = context;
            const targetDamage = cfg.targetDamage || 50000000;
            const skillId = cfg.skillId ?? -2;
            const parallelAttacks = cfg.parallelAttacks || 5;
            const minDelayBetweenAttacks = cfg.minDelayBetweenAttacks || 30;
            const skillCosts = { '0': 1, '-1': 10, '-2': 50, '-3': 100, '-4': 200 };
            const skillCost = skillCosts[skillId.toString()] || 1;

            // 1. Fetch current damage for all bosses
            await this.fetchCurrentDamages(context, bosses);

            // 2. Filter out bosses that already reached target
            const validBosses = bosses.filter(boss => {
                if (boss.invalid) {
                    logger.warn(`üëë ${boss.name}: Batalha inv√°lida`);
                    return false;
                }
                if (boss.currentDamage >= targetDamage) {
                    logger.info(`‚úÖ ${boss.name}: J√° atingiu ${formatNumber(targetDamage)} dano (atual: ${formatNumber(boss.currentDamage)})`);
                    this.state.stats.bossesCompleted++;
                    return false;
                }
                logger.info(`üëë ${boss.name}: Precisa de ${formatNumber(targetDamage - boss.currentDamage)} dano (atual: ${formatNumber(boss.currentDamage)})`);
                return true;
            });

            if (validBosses.length === 0) {
                logger.info('‚úÖ Todos os bosses j√° atingiram o dano alvo!');
                return { hadWork: false, allCompleted: true };
            }

            logger.info(`üöÄ Atacando ${validBosses.length} boss(es) (Ultra Fast Mode) at√© ${formatNumber(targetDamage)} dano cada...`);

            // 3. Process each boss sequentially (to avoid overdamage)
            for (const boss of validBosses) {
                logger.info(`üëë Processando: ${boss.name} (dano atual: ${formatNumber(boss.currentDamage)})`);
                
                const bossState = {
                    ...boss,
                    currentDamage: boss.currentDamage || 0,
                    attackCount: 0,
                    completed: false,
                    potionsUsed: 0
                };
                
                // Attack loop for this boss (same logic as Ultra Fast Boss)
                while (bossState.currentDamage < targetDamage && !bossState.dead) {
                    // Check remaining damage
                    const remainingDamage = targetDamage - bossState.currentDamage;
                    
                    if (remainingDamage <= 0) {
                        bossState.completed = true;
                        logger.info(`‚úÖ üëë ${boss.name}: Alvo atingido! ${formatNumber(bossState.currentDamage)} dano`);
                        this.state.stats.bossesCompleted++;
                        break;
                    }
                    
                    // Check stamina (MESMO PADR√ÉO DO WAVEMODULE)
                    let currentStamina = context.stamina.getCurrent();
                    
                    if (currentStamina < skillCost) {
                        logger.info(`‚è≥ Stamina insuficiente (${currentStamina}/${skillCost}) - tratando...`);
                        
                        // PRIORIDADE 1: Tentar lootar dead monsters antes de FSP (se configurado)
                        if (cfg.lootDeadBeforeFSP !== false && currentStamina < (cfg.minStaminaForPotion || 100)) {
                            logger.info('üíÄ [SPECIAL BOSS] Tentando lootar dead monsters antes de usar FSP...');
                            
                            // üÜï USAR FUN√á√ÉO CENTRALIZADA DO ultraFastLootModule
                            const lootModule = context.moduleRegistry?.getModule('ultraFastLoot');
                            if (lootModule && typeof lootModule.lootDeadMonsters === 'function') {
                                const lootResult = await lootModule.lootDeadMonsters(context);
                                
                                if (lootResult.looted) {
                                    const newStamina = context.stamina.getCurrent();
                                    logger.info(`üíÄ [SPECIAL BOSS] Loot conclu√≠do! Nova stamina: ${newStamina}`);
                                    
                                    if (lootResult.levelUp || newStamina >= skillCost) {
                                        logger.info('üéâ [SPECIAL BOSS] Stamina recuperada via loot! Continuando farm...');
                                        continue;
                                    }
                                    logger.info(`üíÄ [SPECIAL BOSS] Stamina ainda baixa (${newStamina}). Tentando FSP...`);
                                }
                            } else {
                                logger.warn('‚ö†Ô∏è [SPECIAL BOSS] ultraFastLootModule n√£o dispon√≠vel para loot dead.');
                            }
                        }
                        
                        // PRIORIDADE 2: Try to use stamina potion if enabled and low
                        if (cfg.autoStaminaPotion && currentStamina < (cfg.minStaminaForPotion || 100)) {
                            logger.info('üíä [SPECIAL BOSS] Tentando usar Full Stamina Potion...');
                            
                            try {
                                const fspUsed = await context.inventory.useFullStaminaPotion();
                                
                                if (fspUsed) {
                                    logger.info('‚úÖ [SPECIAL BOSS] Full Stamina Potion usada com sucesso! Recarregando p√°gina...');
                                    bossState.potionsUsed++;
                                    this.state.stats.potionsUsed++;
                                    
                                    // Reload to sync stamina
                                    await sleep(1000);
                                    window.location.href = window.location.href;
                                    return { hadWork: true };
                                } else {
                                    logger.info('üíä [SPECIAL BOSS] Full Stamina Potion: Sem po√ß√µes dispon√≠veis ou erro');
                                }
                            } catch (error) {
                                logger.warn('üíä [SPECIAL BOSS] Erro ao tentar usar po√ß√£o:', error.message);
                            }
                        }
                        
                        // PRIORIDADE 3: If potion failed or disabled: wait for stamina regen (30s, same as wave module)
                        logger.info(`‚è≥ [SPECIAL BOSS] Aguardando regenera√ß√£o de stamina (30s)...`);
                        await sleep(30000);
                        currentStamina = context.stamina.getCurrent();
                        
                        if (currentStamina < skillCost) {
                            logger.warn(`‚ö†Ô∏è [SPECIAL BOSS] Stamina AINDA insuficiente (${currentStamina}/${skillCost}) ap√≥s aguardar. Pulando ${boss.name}.`);
                            break; // Skip this boss, try next in loop
                        }
                    }
                    
                    // Calculate how many attacks to send
                    const possibleAttacks = Math.floor(currentStamina / skillCost);
                    const attackCount = Math.min(possibleAttacks, parallelAttacks);
                    
                    if (attackCount <= 0) {
                        await sleep(100);
                        continue;
                    }
                    
                    // Execute parallel attacks (same as Ultra Fast Boss)
                    const results = await this.executeBossParallelAttacks(context, boss.monsterId, skillId, attackCount);
                    
                    // Update state
                    bossState.attackCount += results.successCount;
                    bossState.currentDamage += results.totalDamage;
                    this.state.stats.totalAttacks += results.successCount;
                    this.state.stats.totalDamage += results.totalDamage;
                    
                    // Update stamina display
                    if (results.lastStamina !== null) {
                        const staminaEl = document.querySelector('#stamina_span');
                        if (staminaEl) staminaEl.textContent = Math.max(0, results.lastStamina).toLocaleString();
                    }
                    
                    // Log progress every few attacks
                    if (bossState.attackCount % 10 === 0) {
                        const progress = ((bossState.currentDamage / targetDamage) * 100).toFixed(1);
                        logger.info(`üìä ${boss.name}: ${formatNumber(bossState.currentDamage)}/${formatNumber(targetDamage)} (${progress}%) - ${bossState.attackCount} ataques`);
                    }
                    
                    // Delay between attack batches
                    await sleep(minDelayBetweenAttacks);
                }
                
                // Boss completed
                if (bossState.completed) {
                    logger.info(`‚úÖ üëë ${boss.name}: Conclu√≠do com ${formatNumber(bossState.currentDamage)} dano em ${bossState.attackCount} ataques (${bossState.potionsUsed} po√ß√µes)`);
                }
            }

            // Final Summary
            logger.info('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            logger.info('üëë RESUMO DO SPECIAL BOSS FARM');
            logger.info(`üìà Total: ${this.state.stats.totalAttacks} ataques, ${formatNumber(this.state.stats.totalDamage)} dano, ${this.state.stats.potionsUsed} po√ß√µes`);
            logger.info(`‚úÖ Bosses completados: ${this.state.stats.bossesCompleted}`);
            logger.info('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            return { hadWork: true, allCompleted: true };
        },
        
        /**
         * Execute parallel attacks on a boss using context.combat service
         * TRATAMENTO DE STAMINA: Se algum ataque falhar por stamina insuficiente,
         * loga o erro para que o loop principal possa tratar
         * @param {string} monsterId - Monster ID
         * @param {number} skillId - Skill ID to use
         * @param {number} count - Number of parallel attacks
         * @returns {Promise<{totalDamage: number, successCount: number, lastStamina: number|null}>}
         */
        async executeBossParallelAttacks(context, monsterId, skillId, count) {
            const { logger } = context;
            const attackPromises = Array.from({ length: count }, () => 
                context.combat.attackWaveMonsterDirect(monsterId, skillId)
            );
            
            const results = await Promise.all(attackPromises);
            
            let totalDamage = 0, successCount = 0, lastStamina = null;
            for (const r of results) {
                if (r.success) {
                    totalDamage += r.damageDealt || 0;
                    successCount++;
                    if (r.stamina !== undefined) lastStamina = r.stamina;
                } else if (r.message && r.message.toLowerCase().includes('stamina')) {
                    // üÜï Stamina insuficiente - recarregar p√°gina
                    logger.warn(`‚ö†Ô∏è [BossAttack] Stamina insuficiente! Recarregando p√°gina...`);
                    await sleep(1000);
                    window.location.href = window.location.href;
                    return { totalDamage, successCount, lastStamina };
                }
            }
            
            return { totalDamage, successCount, lastStamina };
        },

        async fetchCurrentDamages(context, bosses) {
            const { logger } = context;
            logger.info(`üîç Verificando dano atual de ${bosses.length} boss(es)...`);

            // Use fetchBattleDamage from ultraFastWaveModule (better: tries card data first, then HTTP fallback)
            const ultraFastWaveModule = context.moduleRegistry.getModule('ultraFastWave');
            if (!ultraFastWaveModule) {
                logger.warn('‚ö†Ô∏è ultraFastWaveModule n√£o dispon√≠vel para fetchBattleDamage');
                return;
            }

            // Fetch damages in parallel using ultraFastWaveModule's optimized method
            const results = await Promise.all(
                bosses.map(boss => ultraFastWaveModule.fetchBattleDamage(context, boss.monsterId))
            );

            // Map results back to boss objects
            for (let i = 0; i < bosses.length; i++) {
                const boss = bosses[i];
                const result = results[i];
                
                if (result.success) {
                    boss.currentDamage = result.damage || 0;
                    logger.debug(`[FetchDamage] ${boss.name}: ${formatNumber(boss.currentDamage)} dano (fonte: ${result.source})`);
                } else {
                    boss.currentDamage = 0;
                    boss.fetchError = true;
                    
                    if (result.invalid) {
                        boss.invalid = true;
                        logger.warn(`[FetchDamage] ${boss.name}: Batalha inv√°lida`);
                    } else {
                        logger.debug(`[FetchDamage] ${boss.name}: Erro ao buscar dano`);
                    }
                }
            }
        }
    };

    // ============================================================================
    // ULTRA FAST ATTACK MODULE - Parallel batch operations for maximum speed
    // ============================================================================
    
    const ultraFastAttackModule = {
        id: 'ultraFastAttack',
        match: ({ location }) => /active_wave\.php/i.test(location.pathname),
        
        init(context) {
            this.state = {
                running: false,
                manualMode: true,  // üÜï Flag para indicar modo manual (via bot√£o)
                currentBatch: [],
                stats: {
                    totalBatches: 0,
                    totalMonsters: 0,
                    successfulJoins: 0,
                    failedJoins: 0,
                    totalAttacks: 0,
                    startTime: null
                }
            };
            // context.logger.debug('[UltraFastAttack] Module initialized');
        },

        activate(context) {
            const cfg = context.config.get();
            if (!cfg.core.enabled || !cfg.ultraFastAttack?.enabled) {
                if (this.state) this.state.running = false;
                return;
            }
            
            if (!this.state) this.init(context);
            
            // üÜï SEMPRE usar modo manual (s√≥ executa via bot√£o)
            // N√£o executar automaticamente mesmo quando ativado
            this.state.manualMode = true;
            context.logger.debug('[UltraFastAttack] Module activated, waiting for manual trigger via button');
        },

        triggerManualRun(context) {
            const { logger } = context;
            const cfg = context.config.get().ultraFastAttack;
            
            if (this.state.running) {
                logger.warn('[UltraFastAttack] J√° est√° rodando');
                return;
            }

            // CHECK SAFE MODE: Don't allow join if >10 continues already active
            const slotInfo = this.checkAvailableSlots(context, cfg.maxConcurrentBattles);
            if (slotInfo.continueCount > 10) {
                logger.warn(`‚ö†Ô∏è N√ÉO √â SEGURO! ${slotInfo.continueCount} batalhas simult√¢neas ativas (limite: 10)`);
                logger.warn('üí° Aguarde completar algumas batalhas antes de iniciar Ultra Fast Farm.');
                context.notifications?.notify?.(
                    `‚ö†Ô∏è Muitas batalhas ativas (${slotInfo.continueCount} > 10). Aguarde completar algumas.`,
                    'warning'
                );
                return;
            }

            this.state.running = true;
            this.state.stats.startTime = Date.now();
            
            logger.info('‚ö° Ultra Fast Farm iniciado manualmente!');
            
            (async () => {
                try {
                    await this.runBatchFarm(context);
                } catch (error) {
                    logger.error('[UltraFastAttack] Erro fatal:', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },

        async runBatchFarm(context) {
            const cfg = context.config.get().ultraFastAttack;
            const { logger } = context;

            logger.info(`üìä Configura√ß√£o: ${cfg.maxParallelBattles} batalhas paralelas, ${cfg.attacksPerMonster} ataques por mob`);

            // 0. Check available slots (count monsters with "Continue" button)
            const slotInfo = this.checkAvailableSlots(context, cfg.maxConcurrentBattles);
            const availableSlots = slotInfo.availableSlots;
            const continueCount = slotInfo.continueCount;
            
            // If more than 10 continues, only check damage on joined battles
            if (continueCount > 10) {
                logger.warn(`‚ö†Ô∏è MUITAS BATALHAS ATIVAS (${continueCount} > 10)! Modo seguro: apenas verificando dano dos monstros j√° joined.`);
                logger.info('üí° N√£o ser√° feito join em novos monstros para evitar sobrecarga do servidor.');
                
                // Check damage on already joined battles
                await this.checkAndAttackJoinedMonsters(context);
                return;
            }
            
            if (availableSlots === 0) {
                logger.warn('‚ö†Ô∏è Nenhum slot dispon√≠vel! Todas as batalhas j√° foram iniciadas.');
                logger.info('üí° Aguarde completar algumas batalhas antes de iniciar Ultra Fast Farm.');
                if (cfg.autoReturnToWave) {
                    await sleep(2000);
                    window.location.href = window.location.href;
                }
                return;
            }

            logger.info(`‚úÖ Slots dispon√≠veis: ${availableSlots}/${cfg.maxConcurrentBattles}`);

            // Ajustar maxParallelBattles baseado nos slots dispon√≠veis
            //const effectiveMaxBattles = Math.min(cfg.maxParallelBattles, availableSlots);
            const effectiveMaxBattles = cfg.maxParallelBattles
            
            // if (effectiveMaxBattles < cfg.maxParallelBattles) {
            //     logger.info(`‚öôÔ∏è Ajustando batalhas paralelas: ${cfg.maxParallelBattles} ‚Üí ${effectiveMaxBattles} (slots dispon√≠veis)`);
            // }

            // 1. Scan monsters from page
            const targets = await this.scanTargets(context);
            
            if (targets.length === 0) {
                logger.info('‚ùå Nenhum mob dispon√≠vel para farm ultra r√°pido');
                if (cfg.autoReturnToWave) {
                    await sleep(2000);
                    window.location.href = window.location.href;
                }
                return;
            }

            // 2. Group into batches (usando effectiveMaxBattles ao inv√©s de cfg.maxParallelBattles)
            const batches = [];
            for (let i = 0; i < targets.length; i += effectiveMaxBattles) {
                batches.push(targets.slice(i, i + effectiveMaxBattles));
            }

            logger.info(`üéØ ${targets.length} mobs encontrados ‚Üí ${batches.length} lotes paralelos (${effectiveMaxBattles} mobs/lote)`);

            // 3. Process each batch
            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                this.state.currentBatch = batch;
                this.state.stats.totalBatches++;

                logger.info(`‚ö° Lote ${batchIndex + 1}/${batches.length}: ${batch.length} mobs`);

                // Join all battles in parallel
                const joinResults = await this.joinBattlesParallel(context, batch);
                const successfulJoins = joinResults.filter(r => r.success);

                logger.info(`‚úÖ Entradas: ${successfulJoins.length}/${batch.length} bem-sucedidas`);

                if (successfulJoins.length === 0) {
                    logger.warn('‚ö†Ô∏è Nenhuma entrada bem-sucedida neste lote, pulando...');
                    continue;
                }

                // ‚è≥ CRITICAL: Aguardar servidor processar os joins antes de atacar
                // Sem esse delay, h√° race condition onde os attacks chegam antes dos joins serem processados
                const joinServerDelay = cfg.delayAfterJoin || 500; // Default 500ms
                logger.debug(`‚è≥ Aguardando ${joinServerDelay}ms para servidor processar joins...`);
                await sleep(joinServerDelay);

                // Attack all battles in parallel (N times each)
                for (let attackRound = 0; attackRound < cfg.attacksPerMonster; attackRound++) {
                    logger.info(`‚öîÔ∏è Rodada de ataque ${attackRound + 1}/${cfg.attacksPerMonster}`);
                    await this.attackBattlesParallel(context, successfulJoins, cfg.skillId);
                    
                    // Small delay between attack rounds
                    if (attackRound < cfg.attacksPerMonster - 1) {
                        await sleep(300);
                    }
                }

                // Leave all battles in parallel (optional - can skip if we reload page)
                // await this.leaveBattlesParallel(context, successfulJoins);

                // Delay between batches
                if (batchIndex < batches.length - 1) {
                    logger.info(`‚è≥ Aguardando ${cfg.delayBetweenBatches}ms antes do pr√≥ximo lote...`);
                    await sleep(cfg.delayBetweenBatches);
                }
            }

            // Summary
            const duration = Date.now() - this.state.stats.startTime;
            logger.info(`‚ú® Farm ultra r√°pido completo!`);
            logger.info(`üìä Stats: ${this.state.stats.totalMonsters} mobs, ${this.state.stats.totalAttacks} ataques em ${(duration/1000).toFixed(1)}s`);

            // üÜï Adicionar dura√ß√£o aos stats
            this.state.stats.duration = duration;

            // Emit completion event (always, for stats display)
            const autoLootCfg = context.config.get().ultraFastLoot;
            const triggerLoot = autoLootCfg?.enabled && autoLootCfg?.autoLootAfterFarm;
            
            context.events.emit('autods:ultraFastAttack:complete', { 
                stats: this.state.stats,
                triggerLoot: triggerLoot,
                endTime: Date.now()
            });

            // üÜï Mostrar modal com resultados
            this.showFarmResultsModal(context, this.state.stats);

            // üÜï Auto-loot OU aguardar usu√°rio fechar modal
            if (triggerLoot) {
                logger.info('üéÅ Auto-loot ser√° acionado ap√≥s fechar o modal...');
                // Loot module vai cuidar do reload
            } else {
                logger.info('‚úÖ Ultra Fast Farm conclu√≠do! Veja os resultados no modal.');
            }
        },

        /**
         * Check available battle slots by counting monsters with "Continue" button
         * @param {object} context - Script context
         * @param {number} maxConcurrentBattles - Max concurrent battles allowed
         * @returns {object} {continueCount, availableSlots, continueButtons}
         */
        checkAvailableSlots(context, maxConcurrentBattles) {
            const { logger, dom } = context;

            // Count monsters with "Continue" button (already joined)
            const continueButtons = dom.queryAll('.monster-card').filter(card => {
                const btn = card.querySelector('.btn-primary, .btn-success, .btn-warning');
                if (!btn) return false;
                const text = btn.textContent.trim().toLowerCase();
                return text.includes('continue') || text.includes('continuar');
            });

            const activeJoins = continueButtons.length;
            const availableSlots = Math.max(0, maxConcurrentBattles - activeJoins);

            logger.debug(`üîç Verifica√ß√£o de slots: ${activeJoins} batalhas ativas, ${availableSlots} slots dispon√≠veis`);

            return {
                continueCount: activeJoins,
                availableSlots: availableSlots,
                continueButtons: continueButtons
            };
        },

        async checkAndAttackJoinedMonsters(context) {
            const cfg = context.config.get().ultraFastAttack;
            const { logger, dom } = context;

            logger.info('üîç Verificando dano nos monstros j√° joined...');

            // Encontrar todos os cards com "Continue" button
            const joinedCards = dom.queryAll('.monster-card').filter(card => {
                const btn = card.querySelector('.btn-primary, .btn-success, .btn-warning');
                if (!btn) return false;
                const text = btn.textContent.trim().toLowerCase();
                return text.includes('continue') || text.includes('continuar');
            });

            if (joinedCards.length === 0) {
                logger.info('‚ùå Nenhum monstro com "Continue" encontrado');
                return;
            }

            logger.info(`üìä ${joinedCards.length} monstros j√° joined encontrados`);

            // Extrair dados dos monstros joined
            const targets = [];
            for (const card of joinedCards) {
                const monsterId = card.getAttribute('data-monster-id');
                if (!monsterId) continue;

                const nameNode = card.querySelector('h3, .monster-name');
                const monsterName = nameNode ? nameNode.textContent.trim() : 'Unknown';

                targets.push({
                    monsterId: monsterId,
                    name: monsterName,
                    currentHp: null  // Will be fetched if needed
                });
            }

            if (targets.length === 0) {
                logger.info('‚ùå Nenhum target v√°lido extra√≠do');
                return;
            }

            logger.info(`‚öîÔ∏è Atacando ${targets.length} monstros j√° joined com skill ${cfg.skillId}...`);

            // Agrupar em lotes e atacar
            for (let i = 0; i < targets.length; i += cfg.maxParallelBattles) {
                const batch = targets.slice(i, i + cfg.maxParallelBattles);

                await Promise.all(batch.map(async target => {
                    try {
                        const result = await this.performAttack(context, target.monsterId, cfg.skillId);
                        if (result.success) {
                            this.state.stats.totalAttacks++;
                            logger.debug(`‚úÖ Ataque em ${target.name}: sucesso`);
                        } else {
                            logger.debug(`‚ùå Ataque em ${target.name}: ${result.message}`);
                        }
                    } catch (error) {
                        logger.error(`‚ùå Erro ao atacar ${target.name}:`, error);
                    }
                }));

                // Delay entre lotes
                if (i + cfg.maxParallelBattles < targets.length) {
                    await sleep(cfg.delayBetweenBatches);
                }
            }

            logger.info(`‚úÖ Verifica√ß√£o e ataque conclu√≠do! ${this.state.stats.totalAttacks} ataques executados`);
        },

        async scanTargets(context) {
            const cfg = context.config.get().ultraFastAttack;
            const { logger } = context;

            // Parse monsterNames from CSV format (string) to array
            let monsterNamesList = [];
            if (cfg.monsterNames) {
                if (Array.isArray(cfg.monsterNames)) {
                    // Already an array
                    monsterNamesList = cfg.monsterNames.filter(Boolean);
                } else if (typeof cfg.monsterNames === 'string') {
                    // Parse CSV string: split by newlines or commas
                    monsterNamesList = cfg.monsterNames
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                }
            }

            // Use Monster Scanner Service
            const monsters = context.monsterScanner.scanWaveMonsters({
                monsterNames: monsterNamesList,
                minHp: cfg.minMobHp,
                onlyNotJoined: true // Only "Join" buttons, not "Continue"
            });

            logger.debug(`[UltraFastAttack] Encontrados ${monsters.length} monster cards ap√≥s filtros`);

            // Convert to Ultra Fast Farm format
            const targets = monsters.map(monster => ({
                monsterId: monster.monsterId,
                name: monster.name,
                currentHp: monster.hp,
                card: monster.card
            }));

            // Log filter results
            if (monsterNamesList && monsterNamesList.length > 0) {
                logger.debug(`[UltraFastAttack] Filtros ativos: ${monsterNamesList.join(', ')}`);
                logger.debug(`[UltraFastAttack] ${targets.length} mobs ap√≥s filtro de nome`);
            }

            // Sort by priority
            if (cfg.priorityMode === 'lowest_hp') {
                targets.sort((a, b) => a.currentHp - b.currentHp);
            } else if (cfg.priorityMode === 'highest_hp') {
                targets.sort((a, b) => b.currentHp - a.currentHp);
            } else if (cfg.priorityMode === 'random') {
                targets.sort(() => Math.random() - 0.5);
            }

            return targets;
        },

        async joinBattlesParallel(context, targets) {
            const { logger } = context;
            const userId = context.config.get().core?.userId;

            if (!userId) {
                logger.error('‚ùå User ID n√£o configurado! Configure core.userId primeiro.');
                return [];
            }

            if (targets.length === 0) {
                return [];
            }

            // üî• PRE-FLIGHT ATTACK: Preparar TODAS as requisi√ß√µes de join antes de enviar
            logger.info(`üöÄ PRE-FLIGHT JOIN: Preparando ${targets.length} requisi√ß√µes simult√¢neas...`);
            
            // Validar targets - remover qualquer um sem monsterId
            const validTargets = targets.filter(target => {
                if (!target.monsterId) {
                    logger.warn(`‚ö†Ô∏è Skipping target ${target.name || 'unknown'} - monsterId missing!`);
                    return false;
                }
                return true;
            });
            
            if (validTargets.length === 0) {
                logger.error('‚ùå Nenhum target v√°lido para join!');
                return [];
            }
            
            logger.info(`‚úÖ ${validTargets.length}/${targets.length} targets v√°lidos`);
            
            // BLOQUEIO DE NAVEGA√á√ÉO: Usar listener para prevenir navega√ß√£o acidental durante joins
            // N√£o conseguimos reatribuir location methods em navegadores modernos, ent√£o usamos um listener
            const navigationBlocker = {
                blocked: true,
                originalClickHandler: null
            };
            
            // Interceptar cliques (n√£o deixa navegar)
            const blockClickHandler = (e) => {
                if (navigationBlocker.blocked) {
                    // Se √© um link externo ou bot√£o, bloquear
                    if (e.target?.tagName === 'A' || e.target?.getAttribute?.('onclick')) {
                        logger.warn(`üîí Clique em link bloqueado durante join: ${e.target?.href || e.target?.textContent}`);
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            };
            
            // Interceptar navigation via popstate (bot√£o back)
            const blockPopState = (e) => {
                if (navigationBlocker.blocked) {
                    logger.warn(`üîí Navega√ß√£o do hist√≥rico bloqueada`);
                    e.preventDefault();
                }
            };
            
            // Adicionar listeners
            document.addEventListener('click', blockClickHandler, true);
            window.addEventListener('popstate', blockPopState);
            
            const cleanupNavigation = () => {
                navigationBlocker.blocked = false;
                document.removeEventListener('click', blockClickHandler, true);
                window.removeEventListener('popstate', blockPopState);
                logger.debug('üîì Bloqueio de navega√ß√£o removido');
            };
            
            // Criar array de fun√ß√µes que executam o join (n√£o executar ainda)
            const joinPromises = validTargets.map(target => ({
                target,
                execute: () => context.http.joinBattle(target.monsterId, userId)
            }));

            logger.info(`‚ö° Disparando ${joinPromises.length} joins SIMULTANEAMENTE...`);
            
            // Executar TODAS as requisi√ß√µes ao mesmo tempo (Pre-Flight)
            const startTime = Date.now();
            const results = await Promise.all(
                joinPromises.map(async ({ target, execute }) => {
                    try {
                        const result = await execute();
                        
                        if (result.success) {
                            this.state.stats.successfulJoins++;
                            this.state.stats.totalMonsters++;
                            logger.debug(`  ‚úÖ ${target.name}: Join bem-sucedido`);
                        } else {
                            this.state.stats.failedJoins++;
                            logger.debug(`  ‚ö†Ô∏è ${target.name}: Falha - ${result.message}`);
                        }

                        return {
                            ...target,
                            success: result.success,
                            message: result.message
                        };
                    } catch (error) {
                        this.state.stats.failedJoins++;
                        logger.error(`  ‚ùå Erro ao entrar em ${target.name}:`, error);
                        return {
                            ...target,
                            success: false,
                            message: error.message
                        };
                    }
                })
            );
            const duration = Date.now() - startTime;
            
            // DESBLOQUEAR NAVEGA√á√ÉO
            cleanupNavigation();

            // Contar sucessos/falhas
            const successCount = results.filter(r => r.success).length;
            const failCount = results.filter(r => !r.success).length;

            logger.info(`üìä Pre-Flight Join: ${successCount} sucessos, ${failCount} falhas (${duration}ms total)`);

            return results;
        },

        async attackBattlesParallel(context, targets, skillId) {
            const { logger } = context;

            logger.debug(`[UltraFastAttack] Atacando ${targets.length} batalhas com skill ${skillId}...`);

            // Create all attack promises
            const attackPromises = targets.map(async (target) => {
                try {
                    const result = await this.performAttack(context, target.monsterId, skillId);
                    
                    if (result.success) {
                        this.state.stats.totalAttacks++;
                        logger.debug(`‚öîÔ∏è Ataque em: ${target.name}`);
                    } else {
                        logger.debug(`‚ùå Falha no ataque: ${target.name}`);
                    }

                    return {
                        ...target,
                        attackSuccess: result.success
                    };
                } catch (error) {
                    logger.error(`‚ùå Erro ao atacar ${target.name}:`, error);
                    return {
                        ...target,
                        attackSuccess: false
                    };
                }
            });

            // Execute all in parallel
            const results = await Promise.all(attackPromises);
            return results;
        },

        async performAttack(context, monsterId, skillId) {
            // Use centralized combat service (Cloudflare-proof)
            return context.combat.attackWaveMonsterDirect(monsterId, skillId);
        },

        /**
         * Show farm results modal using floatingHelpers module
         * @param {object} context - Script context
         * @param {object} stats - Farm statistics
         */
        showFarmResultsModal(context, stats) {
            const { logger } = context;
            
            try {
                // Get floating helpers module
                const floatingHelpers = context.moduleRegistry?.getModule('floatingHelpers');
                
                if (!floatingHelpers || typeof floatingHelpers.openQuickLootModal !== 'function') {
                    logger.warn('[UltraFastAttack] Floating helpers module not available for modal display');
                    return;
                }

                // Convert stats to summary format (compatible with loot modal)
                const summary = {
                    drops: stats.totalMonsters || 0,
                    exp: 0, // Farm doesn't track EXP directly
                    gold: 0, // Farm doesn't track gold directly
                    items: new Map(), // No items from farm
                    monsters: new Map(),
                    messages: []
                };

                // Add farm-specific info to messages
                const durationSec = (stats.duration / 1000).toFixed(1);
                summary.messages.push(`‚ö° Ultra Fast Farm: ${stats.totalMonsters} mobs atacados em ${durationSec}s`);
                summary.messages.push(`‚öîÔ∏è ${stats.totalAttacks} ataques realizados em ${stats.totalBatches} lotes paralelos`);
                summary.messages.push(`‚úÖ ${stats.successfulJoins} entradas bem-sucedidas`);
                
                if (stats.failedJoins > 0) {
                    summary.messages.push(`‚ö†Ô∏è ${stats.failedJoins} entradas falharam`);
                }

                // Call modal with "Ultra Fast Farm" scope
                floatingHelpers.openQuickLootModal(context, summary, 'Ultra Fast Farm');
                
                logger.debug('[UltraFastAttack] Modal exibido com sucesso');
            } catch (error) {
                logger.error('[UltraFastAttack] Erro ao exibir modal:', error);
            }
        },

        cleanup() {
            if (this.state) {
                this.state.running = false;
            }
        }
    };

    // ============================================================================
    // ULTRA FAST LOOT MODULE - Parallel loot collection
    // ============================================================================
    const ultraFastLootModule = {
        id: 'ultraFastLoot',
        match: ({ location }) => {
            const path = location.pathname;
            return /active_wave\.php/i.test(path) || 
                   /wave\.php/i.test(path) ||
                   /guild_dungeon_location\.php/i.test(path);
        },
        
        init(context) {
            this.state = {
                running: false,
                stats: {
                    attempted: 0,
                    successful: 0,
                    failed: 0,
                    totalExp: 0,
                    totalGold: 0,
                    items: []
                }
            };
            // context.logger.debug('[UltraFastLoot] Module initialized');
        },

        activate(context) {
            const cfg = context.config.get();
            
            // Check if triggered by ultraFastAttack completion
            const autoTrigger = cfg.ultraFastLoot?.autoLootAfterFarm;
            
            // Manual trigger via UI or auto-trigger after farm
            if (!cfg.core.enabled || !cfg.ultraFastLoot?.enabled) {
                return;
            }

            // Listen for farm completion event
            if (autoTrigger) {
                context.events.on('autods:ultraFastAttack:complete', (data) => {
                    if (data.triggerLoot && !this.state.running) {
                        context.logger.info('[UltraFastLoot] Auto-triggered ap√≥s farm');
                        this.runLoot(context);
                    }
                });
            }
        },

        async runLoot(context) {
            if (this.state.running) {
                context.logger.warn('[UltraFastLoot] J√° est√° rodando');
                return;
            }

            const cfg = context.config.get().ultraFastLoot;
            const { logger, loot, numbers, notifications } = context;

            this.state.running = true;
            this.state.stats = {
                attempted: 0,
                successful: 0,
                failed: 0,
                totalExp: 0,
                totalGold: 0,
                items: []
            };

            try {
                logger.info('üéÅ Ultra Fast Loot iniciado!');

                // Mostrar filtros ativos
                const filtersConfig = cfg.filters || cfg.monsterFilter || {};
                let includeNames = [];
                let excludeNames = [];
                
                // Parse includeNames from both array and CSV string formats
                // Support both new format (includeNames) and legacy format (monsterNames)
                if (Array.isArray(filtersConfig.includeNames)) {
                    includeNames = filtersConfig.includeNames.filter(Boolean);
                } else if (Array.isArray(filtersConfig.monsterNames)) {
                    // Fallback: CSV data might come as array from UI
                    includeNames = filtersConfig.monsterNames.filter(Boolean);
                } else if (typeof filtersConfig.includeNames === 'string') {
                    const csv = String(filtersConfig.includeNames).trim();
                    if (csv) {
                        includeNames = csv.split(/[\n,]+/).map(s => s.trim()).filter(s => s.length > 0);
                    }
                } else if (typeof filtersConfig.monsterNames === 'string') {
                    const csv = String(filtersConfig.monsterNames).trim();
                    if (csv) {
                        includeNames = csv.split(/[\n,]+/).map(s => s.trim()).filter(s => s.length > 0);
                    }
                }
                
                // Parse excludeNames from both array and CSV string formats
                if (Array.isArray(filtersConfig.excludeNames)) {
                    excludeNames = filtersConfig.excludeNames.filter(Boolean);
                } else if (typeof filtersConfig.excludeNames === 'string') {
                    const csv = String(filtersConfig.excludeNames).trim();
                    if (csv) {
                        excludeNames = csv.split(/[\n,]+/).map(s => s.trim()).filter(s => s.length > 0);
                    }
                }
                
                const activeFilters = [];
                if (includeNames.length > 0) {
                    activeFilters.push(`Incluir: ${includeNames.join(', ')}`);
                }
                if (excludeNames.length > 0) {
                    activeFilters.push(`Excluir: ${excludeNames.join(', ')}`);
                }
                if (activeFilters.length > 0) {
                    logger.info(`üîç Filtros ativos: ${activeFilters.join(' | ')}`);
                }

                // Scan eligible monsters
                const targets = await this.scanLootTargets(context);
                
                if (targets.length === 0) {
                    logger.info('‚ùå Nenhum mob eleg√≠vel para loot');
                    this.state.running = false;
                    return;
                }

                logger.info(`üéØ ${targets.length} mobs para lootar`);
                if (includeNames.length > 0) {
                    logger.debug(`‚ÑπÔ∏è  Contagem AP√ìS filtro 'Incluir Nomes': ${targets.length} mobs eleg√≠veis`);
                    logger.debug(`üìã Filtros incluir: ${includeNames.join(', ')}`);
                }
                if (excludeNames.length > 0) {
                    logger.debug(`üìã Filtros excluir: ${excludeNames.join(', ')}`);
                }

                // Get user ID
                const userId = context.userSession.getUserId();
                if (!userId) {
                    logger.error('‚ùå User ID n√£o encontrado');
                    this.state.running = false;
                    return;
                }

                // üÜï ROBUSTO: Implementar loot manual com verifica√ß√£o de level up ap√≥s cada batch
                // Assim conseguimos parar imediatamente quando atingir o threshold
                this.state.stats.attempted = 0;
                this.state.stats.successful = 0;
                this.state.stats.failed = 0;
                this.state.stats.totalExp = 0;
                this.state.stats.totalGold = 0;
                
                const summary = {
                    drops: 0,
                    exp: 0,
                    gold: 0,
                    items: new Map(),
                    monsters: new Map(),
                    messages: []
                };
                
                // üÜï CAPTURAR EXP INICIAL (antes de qualquer loot) para simula√ß√£o
                const initialExpInfo = loot.getPlayerExpInfo();
                let simulatedCurrentExp = initialExpInfo?.currentExp || 0;
                
                if (initialExpInfo) {
                    logger.info(`üíÄ [UltraFastLoot] Estado inicial: EXP=${numbers.format(initialExpInfo.currentExp)}/${numbers.format(initialExpInfo.maxExp)} (${initialExpInfo.percent.toFixed(2)}%)`);
                }
                
                // Loot em lotes com verifica√ß√£o de level up robusta
                const batchSize = cfg.maxParallelLoots || 5;
                let levelUpDetected = false;
                let looted = 0;
                
                for (let i = 0; i < targets.length; i += batchSize) {
                    if (levelUpDetected) {
                        logger.warn(`‚èπÔ∏è  Level up detectado! Parando o loot autom√°tico`);
                        break;
                    }
                    
                    const batch = targets.slice(i, i + batchSize);
                    logger.debug(`üì¶ Processando batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(targets.length / batchSize)} (${batch.length} mobs)...`);
                    
                    // Capturar EXP antes do batch
                    const expBeforeBatch = summary.exp;
                    
                    // Fazer loot do batch
                    await this.lootBatchParallel(context, batch, summary);
                    looted += batch.length;
                    
                    // üÜï CALCULAR EXP GANHO NO BATCH
                    const batchExpGained = summary.exp - expBeforeBatch;
                    
                    // üÜï VERIFICAR LEVEL UP AP√ìS BATCH (simula√ß√£o matem√°tica)
                    if (initialExpInfo && batchExpGained > 0) {
                        simulatedCurrentExp += batchExpGained;
                        
                        const leveledUp = simulatedCurrentExp >= initialExpInfo.maxExp;
                        
                        if (leveledUp) {
                            logger.warn(`üéâ LEVEL UP DETECTADO! (EXP acumulado: ${numbers.format(simulatedCurrentExp)} >= ${numbers.format(initialExpInfo.maxExp)})`);
                            logger.warn(`üìä Batch ganhou ${numbers.format(batchExpGained)} EXP ‚Üí Total: ${numbers.format(simulatedCurrentExp)}`);
                            notifications.success(`üéâ Level up! Stamina recuperada ap√≥s ${looted} loot(s)`, 3000);
                            levelUpDetected = true;
                            break; // Parar imediatamente
                        }
                        
                        // Log progress
                        const expNeeded = initialExpInfo.maxExp - simulatedCurrentExp;
                        logger.debug(`üíÄ [UltraFastLoot] Progresso: ${numbers.format(simulatedCurrentExp)}/${numbers.format(initialExpInfo.maxExp)} (faltam ${numbers.format(expNeeded)} XP)`);
                    }
                    
                    // Mostrar progresso
                    logger.debug(`‚úÖ Batch completo - Total looted: ${looted}/${targets.length}, Batch EXP: +${numbers.format(batchExpGained)}`);
                    
                    // Pequena pausa entre batches (evitar rate limit)
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                // Update module stats (j√° foi atualizado durante lootBatchParallel)
                this.state.stats.totalExp = summary.exp;
                this.state.stats.totalGold = summary.gold;

                // Summary
                const skippedCount = targets.length - looted;
                logger.info(`‚ú® Loot conclu√≠do!`);
                logger.info(`üìä ${this.state.stats.successful}/${this.state.stats.attempted} loots bem-sucedidos`);
                if (skippedCount > 0) {
                    logger.info(`‚è≠Ô∏è  ${skippedCount} mobs n√£o looteados (parado no level up)`);
                }
                logger.info(`üí∞ ${numbers.format(summary.gold)} Gold, ${numbers.format(summary.exp)} EXP`);
                if (summary.items.size > 0) {
                    logger.info(`üéÅ ${summary.items.size} tipos de itens obtidos`);
                }

                // Show detailed modal using unified service
                const isGuildDungeon = /guild_dungeon_location\.php/i.test(context.location.pathname);
                const scopeLabel = isGuildDungeon ? 'Guild Dungeon Loot' : 'Wave Loot';
                loot.showDetailedModal(summary, scopeLabel);

                // Emit completion event for stats display
                context.events.emit('autods:ultraFastLoot:complete', {
                    stats: {
                        ...this.state.stats,
                        summary: summary
                    }
                });

                logger.info('‚úÖ Ultra Fast Loot conclu√≠do! Veja os resultados no modal e painel lateral.');

            } catch (error) {
                logger.error('[UltraFastLoot] Erro:', error);
            } finally {
                this.state.running = false;
            }
        },

        /**
         * üÜï FUN√á√ÉO P√öBLICA: Lootar dead monsters com detec√ß√£o de level up
         * Pode ser chamada por qualquer m√≥dulo (ultraFastWave, specialBossFarm, etc)
         * 
         * Caracter√≠sticas:
         * - üÜï Faz switch de view automaticamente se estiver em p√°gina de wave
         * - üÜï Detecta e filtra special bosses (100B+ HP) - loota UM POR UM
         * - Processa monsters normais em batches de 10
         * - Detec√ß√£o matem√°tica de level up (simulatedCurrentExp)
         * - Para quando detecta level up
         * - üÜï Volta para alive view automaticamente se estiver em wave page
         */
        async lootDeadMonsters(context) {
            const { logger, loot, numbers, notifications } = context;
            
            // üÜï DETECTAR SE EST√Å EM P√ÅGINA DE WAVE (para fazer switch de view)
            const isWavePage = /active_wave\.php|wave\.php/i.test(context.location.pathname);
            
            // üÜï MUDAR PARA DEAD VIEW SE ESTIVER EM WAVE PAGE
            if (isWavePage) {
                logger.debug('üíÄ [LootDeadMonsters] Mudando para dead monsters view...');
                await context.waveViewNavigation.switchToDeadMonstersView();
                await sleep(500); // Wait for view to load
            }
            
            // Scan dead monsters
            const cards = context.dom.queryAll('.monster-card');
            const deadMonsters = [];
            
            // üÜï BOSS DETECTION THRESHOLD: 100B (same as specialBossFarm)
            const BOSS_HP_THRESHOLD = 100_000_000_000;
            
            for (const card of cards) {
                const nameNode = card.querySelector('h3, h4, .monster-name');
                const monsterName = nameNode?.textContent?.trim() || 'Unknown';
                
                const button = card.querySelector('button');
                const buttonText = button?.textContent?.toLowerCase() || '';
                
                if (buttonText.includes('loot') || buttonText.includes('claim')) {
                    const link = card.querySelector('a[href*="battle.php"]');
                    const idMatch = link?.href?.match(/id=(\d+)/);
                    const monsterId = idMatch?.[1];
                    
                    if (monsterId) {
                        // üÜï EXTRAIR HP PARA DETECTAR SPECIAL BOSSES
                        const hpRow = Array.from(card.querySelectorAll('.stat-row')).find(row => row.querySelector('.stat-icon.hp'));
                        const hpValueNode = hpRow?.querySelector('.stat-value');
                        const hpText = hpValueNode?.textContent ?? '';
                        
                        // Parse HP - format: "0 / 100,000,000"
                        const hpMatch = hpText.match(/(\d{1,3}(?:,\d{3})*|\d+)\s*\/\s*(\d{1,3}(?:,\d{3})*|\d+)/);
                        const maxHp = hpMatch ? numberFromText(hpMatch[2]) : 0;
                        
                        // üÜï MARCAR SE √â SPECIAL BOSS (100B+)
                        const isSpecialBoss = maxHp >= BOSS_HP_THRESHOLD;
                        
                        deadMonsters.push({ 
                            monsterId, 
                            name: monsterName, 
                            card, 
                            maxHp,
                            isSpecialBoss 
                        });
                    }
                }
            }
            
            if (deadMonsters.length === 0) {
                logger.info('üíÄ [LootDeadMonsters] Nenhum dead monster eleg√≠vel');
                
                // üÜï VOLTAR PARA ALIVE VIEW SE ESTIVER EM WAVE PAGE
                if (isWavePage) {
                    await context.waveViewNavigation.switchToAliveMonstersView();
                }
                
                return { looted: false, levelUp: false, summary: null, count: 0 };
            }
            
            // üÜï SEPARAR SPECIAL BOSSES de monsters normais
            const specialBosses = deadMonsters.filter(m => m.isSpecialBoss);
            const normalMonsters = deadMonsters.filter(m => !m.isSpecialBoss);
            
            logger.info(`üíÄ [LootDeadMonsters] Total: ${deadMonsters.length} (${specialBosses.length} bosses 100B+, ${normalMonsters.length} normais)`);
            
            // üÜï VERIFICAR SE LOOT DE SPECIAL BOSS EST√Å HABILITADO
            const lootSpecialBossConfigCheck = context.config.get().ultraFastLoot?.lootSpecialBossBeforeFSP ?? true;
            if (specialBosses.length > 0 && !lootSpecialBossConfigCheck) {
                logger.info(`üëë [LootDeadMonsters] ${specialBosses.length} special boss(es) N√ÉO ser√£o looteados (lootSpecialBossBeforeFSP = false)`);
            }
            
            // üÜï CAPTURAR EXP INICIAL
            const initialExpInfo = loot.getPlayerExpInfo();
            let simulatedCurrentExp = initialExpInfo?.currentExp || 0;
            
            if (initialExpInfo) {
                logger.info(`üíÄ [LootDeadMonsters] EXP inicial: ${numbers.format(initialExpInfo.currentExp)}/${numbers.format(initialExpInfo.maxExp)} (${initialExpInfo.percent.toFixed(2)}%)`);
            }
            
            // Get user ID
            const userId = context.userSession.getUserId();
            if (!userId) {
                logger.error('üíÄ [LootDeadMonsters] User ID n√£o encontrado');
                
                // üÜï VOLTAR PARA ALIVE VIEW SE ESTIVER EM WAVE PAGE
                if (isWavePage) {
                    await context.waveViewNavigation.switchToAliveMonstersView();
                }
                
                return { looted: false, levelUp: false, summary: null, count: 0 };
            }
            
            const summary = loot.createSummary();
            let totalLooted = 0;
            let levelUpDetected = false;
            
            
            // üÜï PRIORIDADE 1: LOOTAR MONSTERS NORMAIS EM BATCHES (se n√£o teve level up ainda)
            if (!levelUpDetected && normalMonsters.length > 0) {
                logger.info(`üíÄ [LootDeadMonsters] Looteando ${normalMonsters.length} monster(s) normal(is) em batches...`);
                
                const batchSize = 10;
                for (let i = 0; i < normalMonsters.length; i += batchSize) {
                    if (levelUpDetected) {
                        logger.warn(`‚èπÔ∏è [LootDeadMonsters] Level up detectado! Parando loot`);
                        break;
                    }
                    
                    const batch = normalMonsters.slice(i, i + batchSize);
                    const expBeforeBatch = summary.exp;
                    
                    // Loot batch in parallel
                    const promises = batch.map(m => loot.lootWaveMonster(m.monsterId, userId));
                    const results = await Promise.all(promises);
                    
                    // Update summary
                    let batchSuccessCount = 0;
                    for (const result of results) {
                        if (result.success) {
                            loot.updateSummary(summary, result);
                            totalLooted++;
                            batchSuccessCount++;
                        }
                    }
                    
                    // üÜï VERIFICAR LEVEL UP ap√≥s batch
                    const batchExpGained = summary.exp - expBeforeBatch;
                    
                    if (batchSuccessCount > 0) {
                        logger.info(`üíÄ Batch ${Math.floor(i / batchSize) + 1}: ${batchSuccessCount}/${batch.length} loots, +${numbers.format(batchExpGained)} EXP`);
                    }
                    
                    if (initialExpInfo && batchExpGained > 0) {
                        simulatedCurrentExp += batchExpGained;
                        
                        const leveledUp = simulatedCurrentExp >= initialExpInfo.maxExp;
                        
                        if (leveledUp) {
                            logger.warn(`üéâ [LootDeadMonsters] LEVEL UP DETECTADO! (EXP: ${numbers.format(simulatedCurrentExp)} >= ${numbers.format(initialExpInfo.maxExp)})`);
                            notifications.success(`üéâ Level up! Stamina recuperada ap√≥s ${totalLooted} loot(s)`, 3000);
                            levelUpDetected = true;
                            break;
                        }
                        
                        logger.debug(`üíÄ [LootDeadMonsters] Progresso: ${numbers.format(simulatedCurrentExp)}/${numbers.format(initialExpInfo.maxExp)} (faltam ${numbers.format(initialExpInfo.maxExp - simulatedCurrentExp)} XP)`);
                    }
                    
                    await sleep(100); // Small delay between batches
                }
            }

            // üÜï PRIORIDADE 2: LOOTAR SPECIAL BOSSES UM POR UM (n√£o em batch)
            // üÜï SOMENTE SE A OP√á√ÉO lootSpecialBossBeforeFSP ESTIVER HABILITADA
            const lootSpecialBossConfig = context.config.get().ultraFastLoot?.lootSpecialBossBeforeFSP ?? true;
            
            if (specialBosses.length > 0 && lootSpecialBossConfig) {
                logger.info(`üëë [LootDeadMonsters] Looteando ${specialBosses.length} special boss(es) UM POR UM...`);
                
                for (const boss of specialBosses) {
                    if (levelUpDetected) {
                        logger.warn(`‚èπÔ∏è [LootDeadMonsters] Level up detectado! Parando loot de bosses`);
                        break;
                    }
                    
                    const expBeforeLoot = summary.exp;
                    
                    // Loot boss (ONE AT A TIME)
                    const result = await loot.lootWaveMonster(boss.monsterId, userId);
                    
                    if (result.success) {
                        loot.updateSummary(summary, result);
                        totalLooted++;
                        
                        logger.info(`üëë ‚úÖ ${boss.name} (${numbers.format(boss.maxHp)} HP): +${numbers.format(result.exp)} EXP, +${numbers.format(result.gold)} Gold`);
                        
                        // üÜï VERIFICAR LEVEL UP ap√≥s cada boss
                        const bossExpGained = summary.exp - expBeforeLoot;
                        
                        if (initialExpInfo && bossExpGained > 0) {
                            simulatedCurrentExp += bossExpGained;
                            
                            const leveledUp = simulatedCurrentExp >= initialExpInfo.maxExp;
                            
                            if (leveledUp) {
                                logger.warn(`üéâ [LootDeadMonsters] LEVEL UP DETECTADO ap√≥s loot de boss! (EXP: ${numbers.format(simulatedCurrentExp)} >= ${numbers.format(initialExpInfo.maxExp)})`);
                                notifications.success(`üéâ Level up! Stamina recuperada ap√≥s loot de ${boss.name}`, 3000);
                                levelUpDetected = true;
                                break;
                            }
                        }
                        
                        // Delay ap√≥s cada boss (evitar spam)
                        await sleep(200);
                    } else {
                        logger.warn(`üëë ‚ùå ${boss.name}: Falha no loot - ${result.message}`);
                    }
                }
            }
            
            logger.info(`‚úÖ [LootDeadMonsters] Loot conclu√≠do: ${totalLooted}/${deadMonsters.length} monsters, ${numbers.format(summary.exp)} EXP, ${numbers.format(summary.gold)} Gold`);
            
            // üÜï VOLTAR PARA ALIVE VIEW SE ESTIVER EM WAVE PAGE
            if (isWavePage) {
                logger.debug('‚úÖ [LootDeadMonsters] Voltando para alive monsters view...');
                await context.waveViewNavigation.switchToAliveMonstersView();
            }
            
            return {
                looted: totalLooted > 0,
                levelUp: levelUpDetected,
                summary: summary,
                count: totalLooted
            };
        },
        
        async scanLootTargets(context) {
            const cfg = context.config.get().ultraFastLoot;
            const isGuildDungeon = /guild_dungeon_location\.php/i.test(context.location.pathname);
            const filters = cfg.filters || cfg.monsterFilter || {};
            
            // Boss detection threshold: 1 billion (1B) HP - bosses won't be auto-looted
            const BOSS_HP_THRESHOLD = 1_000_000_000;
            
            // Parse includeNames - support both array and CSV string format
            let includeNames = [];
            if (Array.isArray(filters.includeNames)) {
                includeNames = filters.includeNames.filter(Boolean);
            } else if (Array.isArray(filters.monsterNames)) {
                // Fallback: CSV data might come as array from UI
                includeNames = filters.monsterNames.filter(Boolean);
            } else if (typeof filters.includeNames === 'string') {
                // Fallback: parse CSV string from old format
                const csv = String(filters.includeNames).trim();
                if (csv) {
                    includeNames = csv
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                }
            } else if (typeof filters.monsterNames === 'string') {
                // Legacy fallback
                const csv = String(filters.monsterNames).trim();
                if (csv) {
                    includeNames = csv
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                }
            }
            
            // Parse excludeNames - support both array and CSV string format
            let excludeNames = [];
            if (Array.isArray(filters.excludeNames)) {
                excludeNames = filters.excludeNames.filter(Boolean);
            } else if (typeof filters.excludeNames === 'string') {
                // Parse CSV string
                const csv = String(filters.excludeNames).trim();
                if (csv) {
                    excludeNames = csv
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                }
            }

            let targets = [];

            if (isGuildDungeon) {
                // Guild dungeon: scan directly from monster cards (not dependent on injected buttons)
                const monsterCards = Array.from(document.querySelectorAll('.mon.dead'));
                
                context.logger.debug(`[UltraFastLoot] Found ${monsterCards.length} dead monsters in guild dungeon`);
                
                for (const card of monsterCards) {
                    // Check if has "not looted" pill
                    const notLootedPill = Array.from(card.querySelectorAll('.pill')).find(pill =>
                        /not looted/i.test(pill.textContent)
                    );

                    if (!notLootedPill) continue; // Skip if already looted

                    // Find the View button (support both dungeon_battle.php and battle.php with dgmid)
                    const viewButton = card.querySelector('a.btn[href*="battle.php"][href*="dgmid"], a.btn[href*="dungeon_battle.php"]');
                    if (!viewButton) continue;

                    // Extract dgmid and instance_id from View button href
                    const href = viewButton.getAttribute('href');
                    const dgmidMatch = href.match(/dgmid=(\d+)/);
                    const instanceMatch = href.match(/instance_id=(\d+)/);

                    if (!dgmidMatch || !instanceMatch) continue;

                    // Extract monster name and HP
                    const nameElement = card.querySelector('h3, .monster-name, [class*="name"]');
                    const monsterName = nameElement ? nameElement.textContent.trim() : '';
                    
                    // Extract HP from .stat-row with .stat-icon.hp -> .stat-value (format: "current / max")
                    const hpRow = Array.from(card.querySelectorAll('.stat-row')).find(row => row.querySelector('.stat-icon.hp'));
                    const hpValueNode = hpRow?.querySelector('.stat-value');
                    const hpText = hpValueNode?.textContent ?? '';
                    // Extract max HP (after the /) - format is "0 / 100,000,000"
                    const hpMatch = hpText.match(/(\d{1,3}(?:,\d{3})*|\d+)\s*\/\s*(\d{1,3}(?:,\d{3})*|\d+)/);
                    const hp = hpMatch ? numberFromText(hpMatch[2]) : 0; // hpMatch[2] is max HP
                    
                    // üëë Skip bosses (100B+ HP) - they must be looted manually
                    if (hp && hp >= BOSS_HP_THRESHOLD) {
                        context.logger.debug(`‚Ü©Ô∏è  Pulando boss ${monsterName} (HP: ${formatNumber(hp)}) - deve ser looteado manualmente`);
                        continue;
                    }

                    // Apply name filters - include check
                    if (includeNames.length > 0) {
                        if (!includeNames.some(name => monsterName.toLowerCase().includes(name.toLowerCase()))) {
                            continue; // Skip if not in whitelist
                        }
                    }
                    // Apply name filters - exclude check
                    if (excludeNames.length > 0) {
                        if (excludeNames.some(name => monsterName.toLowerCase().includes(name.toLowerCase()))) {
                            continue; // Skip if in blacklist
                        }
                    }

                    targets.push({
                        type: 'dungeon',
                        dgmid: dgmidMatch[1],
                        instanceId: instanceMatch[1],
                        name: monsterName
                    });
                }
                
                context.logger.debug(`[UltraFastLoot] Extracted ${targets.length} lootable guild monsters (after filters)`);
            } else {
                // Regular wave: only dead monsters
                let cards = [];
                
                if (cfg.onlyEligible) {
                    cards = Array.from(document.querySelectorAll('.monster-card[data-eligible="1"][data-dead="1"]'));
                } else {
                    cards = Array.from(document.querySelectorAll('.monster-card[data-dead="1"]'));
                }
                
                for (const card of cards) {
                    const monsterId = card.getAttribute('data-monster-id');
                    if (!monsterId) continue;

                    // Extract monster name and HP
                    const nameElement = card.querySelector('h3, .monster-name');
                    const monsterName = nameElement ? nameElement.textContent.trim() : '';
                    
                    // Extract HP from .stat-row with .stat-icon.hp -> .stat-value (format: "current / max")
                    const hpRow = Array.from(card.querySelectorAll('.stat-row')).find(row => row.querySelector('.stat-icon.hp'));
                    const hpValueNode = hpRow?.querySelector('.stat-value');
                    const hpText = hpValueNode?.textContent ?? '';
                    // Extract max HP (after the /) - format is "0 / 100,000,000"
                    const hpMatch = hpText.match(/(\d{1,3}(?:,\d{3})*|\d+)\s*\/\s*(\d{1,3}(?:,\d{3})*|\d+)/);
                    const hp = hpMatch ? numberFromText(hpMatch[2]) : 0; // hpMatch[2] is max HP
                    
                    // üëë Skip bosses (100B+ HP) - they must be looted manually
                    if (hp && hp >= BOSS_HP_THRESHOLD) {
                        context.logger.debug(`‚Ü©Ô∏è  Pulando boss ${monsterName} (HP: ${formatNumber(hp)}) - deve ser looteado manualmente`);
                        continue;
                    }

                    // Apply name filters - include check
                    if (includeNames.length > 0) {
                        if (!includeNames.some(name => monsterName.toLowerCase().includes(name.toLowerCase()))) {
                            continue; // Skip if not in whitelist
                        }
                    }
                    // Apply name filters - exclude check
                    if (excludeNames.length > 0) {
                        if (excludeNames.some(name => monsterName.toLowerCase().includes(name.toLowerCase()))) {
                            continue; // Skip if in blacklist
                        }
                    }

                    targets.push({
                        type: 'wave',
                        monsterId: monsterId,
                        name: monsterName
                    });
                }
                
                context.logger.debug(`[UltraFastLoot] Extracted ${targets.length} lootable wave monsters (after filters)`);
            }

            return targets;
        },

        async lootBatchParallel(context, batch, summary) {
            const { logger } = context;

            const lootPromises = batch.map(async (target) => {
                this.state.stats.attempted++;
                
                try {
                    const result = await this.performLoot(context, target);
                    
                    if (result.success) {
                        this.state.stats.successful++;
                        
                        // üÜï Acumular em summary (compat√≠vel com loot tradicional)
                        const exp = result.exp || 0;
                        const gold = result.gold || 0;
                        
                        summary.exp += exp;
                        summary.gold += gold;
                        summary.drops++;
                        
                        // üÜï Processar itens
                        if (result.items && result.items.length > 0) {
                            result.items.forEach(item => {
                                // üÜï Debug: Log estrutura do item
                                context.logger.debug('[UltraFastLoot] Processing item:', item);
                                
                                // API retorna campos em MAI√öSCULAS: ITEM_ID, NAME, RARITY, QUANTITY
                                const itemName = item.NAME || item.name || 'Unknown Item';
                                const itemRarity = (item.RARITY || item.rarity || 'COMMON').toLowerCase();
                                const itemQty = item.QUANTITY || item.quantity || 1;
                                
                                context.logger.debug('[UltraFastLoot] Parsed item:', { itemName, itemRarity, itemQty });
                                
                                const itemKey = `${itemName}|${itemRarity}`;
                                const existing = summary.items.get(itemKey);
                                
                                if (existing) {
                                    existing.quantity += itemQty;
                                } else {
                                    summary.items.set(itemKey, {
                                        displayName: itemName,
                                        rarity: itemRarity,
                                        quantity: itemQty
                                    });
                                }
                            });
                        }
                        
                        // üÜï Armazenar info do monstro
                        if (result.monsterName) {
                            const monsterKey = result.monsterName.toLowerCase();
                            const existing = summary.monsters.get(monsterKey);
                            
                            if (existing) {
                                existing.exp += exp;
                                existing.gold += gold;
                                existing.count++;
                            } else {
                                summary.monsters.set(monsterKey, {
                                    name: result.monsterName,
                                    exp: exp,
                                    gold: gold,
                                    count: 1
                                });
                            }
                        }
                        
                        logger.debug(`‚úÖ Loot: ${target.type} ${target.monsterId || target.dgmid} - ${exp} XP, ${gold} Gold`);
                    } else {
                        this.state.stats.failed++;
                        logger.debug(`‚ùå Falha loot: ${result.message}`);
                    }

                    return result;
                } catch (error) {
                    this.state.stats.failed++;
                    logger.error('‚ùå Erro no loot:', error);
                    return { success: false, message: error.message };
                }
            });

            const results = await Promise.all(lootPromises);
            return results;
        },

        async performLoot(context, target) {
            const isDungeon = target.type === 'dungeon';
            const url = isDungeon ? 
                'https://demonicscans.org/dungeon_loot.php' : 
                'https://demonicscans.org/loot.php';
            
            const body = isDungeon ?
                `dgmid=${target.dgmid}&instance_id=${target.instanceId}` :
                `monster_id=${target.monsterId}`;

            // Use centralized loot service (Cloudflare-proof)
            const userId = context.userSession.getUserId();
            if (!userId) {
                return { success: false, message: 'User ID not found' };
            }
            
            if (isDungeon) {
                return context.loot.lootDungeonMonsterDirect(target.dgmid, target.instanceId, userId, target.name || 'Unknown');
            } else {
                return context.loot.lootWaveMonsterDirect(target.monsterId, userId, target.name || 'Unknown');
            }
        },

        createLootSummary() {
            return {
                drops: 0,
                exp: 0,
                gold: 0,
                items: new Map(),
                monsters: new Map(),
                messages: []
            };
        },

        getPlayerExpInfo(context) {
            // Selectors para encontrar o XP do jogador
            const expSelectors = [
                '[data-player-exp]',
                '.player-exp',
                '#player_exp',
                '.exp-bar .exp-text',
                '[class*="exp"]'
            ];

            for (const selector of expSelectors) {
                const expElement = document.querySelector(selector);
                if (!expElement) continue;

                const expText = expElement.textContent.trim();
                const match = expText.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                
                if (match) {
                    const currentExp = numberFromText(match[1]);
                    const maxExp = numberFromText(match[2]);
                    
                    if (currentExp !== null && maxExp !== null && maxExp > 0) {
                        const percent = (currentExp / maxExp) * 100;
                        return {
                            currentExp,
                            maxExp,
                            percent
                        };
                    }
                }
            }

            return null;
        },

        showLootResultsModal(context, summary) {
            context.logger.info('üîç [showLootResultsModal] Iniciando...');
            
            // Usar a fun√ß√£o do floatingHelpersModule se dispon√≠vel
            const floatingHelpers = context.moduleRegistry?.getModule('floatingHelpers');
            
            context.logger.info(`üîç [showLootResultsModal] floatingHelpers encontrado: ${!!floatingHelpers}`);
            
            if (floatingHelpers && typeof floatingHelpers.openQuickLootModal === 'function') {
                const isGuildDungeon = /guild_dungeon_location\.php/i.test(context.location.pathname);
                const scopeLabel = isGuildDungeon ? 'Guild' : 'Wave';
                
                context.logger.info(`üîç [showLootResultsModal] Chamando openQuickLootModal (scope: ${scopeLabel})`);
                
                try {
                    floatingHelpers.openQuickLootModal(context, summary, scopeLabel);
                    context.logger.info('‚úÖ [showLootResultsModal] Modal aberto com sucesso!');
                } catch (error) {
                    context.logger.error('‚ùå [showLootResultsModal] Erro ao abrir modal:', error);
                }
            } else {
                // Fallback: mostrar log simples
                context.logger.warn('[UltraFastLoot] Modal n√£o dispon√≠vel, resultados no console');
                context.logger.info(`üìä Total: ${formatNumber(summary.exp)} EXP, ${formatNumber(summary.gold)} Gold`);
                
                if (summary.items.size > 0) {
                    context.logger.info(`üéÅ Itens (${summary.items.size} tipos):`);
                    summary.items.forEach((item, key) => {
                        context.logger.info(`  - ${item.quantity}x ${item.name} (${item.rarity})`);
                    });
                }
            }
        },

        cleanup() {
            this.state.running = false;
        }
    };

    // ============================================================================
    // ULTRA FAST STAMINA FARM MODULE - Parallel chapter reactions
    // ============================================================================
    const ultraFastStaminaModule = {
        id: 'ultraFastStamina',
        match: ({ location }) => {
            // Match manga/title pages where we can get chapter lists
            const path = location.pathname;
            return /\/manga\/|\/title\//i.test(path) && !/\/chapter\//i.test(path);
        },
        
        init(context) {
            this.state = {
                running: false,
                isLoggingIn: false,  // Lock para evitar m√∫ltiplos logins paralelos
                loginPromise: null,  // Promise que aguarda o login completar
                stats: {
                    attempted: 0,
                    successful: 0,
                    failed: 0,
                    alreadyReacted: 0,
                    totalReactions: 0,
                    startTime: null,
                    duration: 0
                }
            };
            // context.logger.debug('[UltraFastStamina] Module initialized');
        },

        activate(context) {
            const cfg = context.config.get();
            if (!cfg.core.enabled || !cfg.ultraFastStamina?.enabled) {
                if (this.state) this.state.running = false;
                return;
            }
            
            if (!this.state) this.init(context);
            
            // Don't auto-run, wait for manual trigger via UI
            context.logger.debug('[UltraFastStamina] Module activated, waiting for manual trigger');
        },

        async runStaminaFarm(context) {
            const { logger } = context;
            
            if (this.state.running) {
                logger.warn('[UltraFastStamina] Already running');
                return;
            }

            this.state.running = true;
            this.state.stats = {
                attempted: 0,
                successful: 0,
                failed: 0,
                alreadyReacted: 0,
                totalReactions: 0,
                startTime: Date.now(),
                duration: 0
            };

            logger.info('‚ö° Ultra Fast Stamina iniciado!');

            try {
                // 1. Get user UID from cookie
                const userUID = this.getUserUID(context);
                logger.info(`üë§ UserUID: ${userUID}`);

                // 2. Scan chapters from current page
                const chapters = await this.scanChapters(context);
                
                if (chapters.length === 0) {
                    logger.warn('‚ùå Nenhum cap√≠tulo encontrado na p√°gina');
                    return;
                }

                logger.info(`üìö ${chapters.length} cap√≠tulos encontrados`);

                // 3. Filter out already reacted chapters
                const unreactedChapters = chapters.filter(ch => {
                    const cookieName = `reacted_chap_${ch.id}`;
                    const hasReacted = this.getCookie(cookieName);
                    if (hasReacted) {
                        this.state.stats.alreadyReacted++;
                        return false;
                    }
                    return true;
                });

                logger.info(`‚ú® ${unreactedChapters.length} cap√≠tulos sem rea√ß√£o`);
                
                if (unreactedChapters.length === 0) {
                    logger.info('‚úÖ Todos os cap√≠tulos j√° foram reagidos!');
                    this.showResults(context);
                    return;
                }

                // 4. Group into batches
                const cfg = context.config.get().ultraFastStamina;
                const batchSize = cfg?.batchSize || 10;
                const batches = [];
                
                for (let i = 0; i < unreactedChapters.length; i += batchSize) {
                    batches.push(unreactedChapters.slice(i, i + batchSize));
                }

                logger.info(`üì¶ ${batches.length} lotes de ${batchSize} rea√ß√µes`);

                // 5. Process batches
                for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                    const batch = batches[batchIndex];
                    logger.info(`‚ö° Lote ${batchIndex + 1}/${batches.length}: ${batch.length} cap√≠tulos`);

                    await this.reactBatchParallel(context, batch, userUID);

                    // Delay between batches
                    if (batchIndex < batches.length - 1) {
                        const delay = cfg?.delayBetweenBatches || 1000;
                        logger.info(`‚è≥ Aguardando ${delay}ms antes do pr√≥ximo lote...`);
                        await sleep(delay);
                    }
                }

                // 6. Show results
                this.state.stats.duration = Date.now() - this.state.stats.startTime;
                this.showResults(context);

            } catch (error) {
                logger.error('[UltraFastStamina] Erro fatal:', error);
            } finally {
                this.state.running = false;
            }
        },

        async scanChapters(context) {
            const { logger } = context;
            const chapters = [];

            // Look for chapter links with class "chplinks"
            // Format: <a class="chplinks" href="/chaptered.php?manga=11952&chapter=145">
            const chapterLinks = document.querySelectorAll('.chplinks');
            
            logger.debug(`[UltraFastStamina] Found ${chapterLinks.length} chapter links`);

            const seenIds = new Set();

            chapterLinks.forEach(link => {
                const href = link.getAttribute('href');
                if (!href) return;

                // Extract chapter ID from URL query parameter
                // Example: /chaptered.php?manga=11952&chapter=145
                let chapterId = null;

                // 1. Try to extract from "chapter=" query parameter
                const urlParams = new URLSearchParams(href.split('?')[1] || '');
                chapterId = urlParams.get('chapter');

                // 2. If not found, try data-chapter-id attribute
                if (!chapterId) {
                    chapterId = link.getAttribute('data-chapter-id');
                }

                // 3. Try parent element data attributes
                if (!chapterId) {
                    const parent = link.closest('[data-chapter-id]');
                    if (parent) {
                        chapterId = parent.getAttribute('data-chapter-id');
                    }
                }

                // 4. Try onclick attribute (e.g., onclick="reactToChapter(12345)")
                if (!chapterId) {
                    const onclick = link.getAttribute('onclick');
                    if (onclick) {
                        const match = onclick.match(/\d+/);
                        if (match) chapterId = match[0];
                    }
                }

                if (chapterId && !seenIds.has(chapterId)) {
                    seenIds.add(chapterId);
                    chapters.push({
                        id: chapterId,
                        url: href,
                        title: link.textContent.trim()
                    });
                }
            });

            logger.debug(`[UltraFastStamina] Extracted ${chapters.length} unique chapter IDs`);

            return chapters;
        },

        async reactBatchParallel(context, batch, userUID) {
            const { logger } = context;
            const cfg = context.config.get().ultraFastStamina;
            const reactionType = cfg?.reactionType || '1'; // Default: üëç

            const promises = batch.map(async (chapter) => {
                this.state.stats.attempted++;

                try {
                    const result = await this.sendReaction(context, chapter.id, reactionType, userUID);
                    
                    if (result.success) {
                        this.state.stats.successful++;
                        this.state.stats.totalReactions++;
                        logger.debug(`‚úÖ Rea√ß√£o enviada: ${chapter.title} (${chapter.id})`);
                        
                        // Set cookie to mark as reacted
                        this.setCookie(`reacted_chap_${chapter.id}`, reactionType, 365);
                    } else {
                        this.state.stats.failed++;
                        logger.debug(`‚ùå Falha: ${chapter.title} - ${result.message}`);
                    }

                    return result;
                } catch (error) {
                    this.state.stats.failed++;
                    logger.error(`‚ùå Erro: ${chapter.title}`, error);
                    return { success: false, message: error.message };
                }
            });

            await Promise.all(promises);
        },

        isLoggedOut(responseText) {
            // Check if response contains login page indicators
            return responseText && (
                responseText.includes('Sign in to your account') ||
                responseText.includes('signin.php') ||
                responseText.includes('login-container') ||
                responseText.includes('Register</a>')
            );
        },

        async autoSignin(context) {
            const { logger } = context;
            
            // Se j√° est√° logando, aguarda o resultado
            if (this.state.isLoggingIn) {
                logger.debug('‚è≥ Aguardando login em andamento...');
                if (this.state.loginPromise) {
                    return await this.state.loginPromise;
                }
            }

            // Seta flag de login em andamento
            this.state.isLoggingIn = true;

            // Cria Promise para que outros aguardem
            this.state.loginPromise = (async () => {
                try {
                    // Get credentials from config or storage
                    const cfg = context.config.get();
                    const credentials = cfg?.credentials;
                    
                    if (!credentials?.email || !credentials?.password) {
                        logger.warn('‚ùå Credenciais n√£o configuradas. Configure email e senha em ‚öôÔ∏è Interface > üîê Credenciais de Login');
                        return false;
                    }

                    logger.info('üîÑ Fazendo login autom√°tico (uma √∫nica vez)...');
                    
                    const body = `email=${encodeURIComponent(credentials.email)}&password=${encodeURIComponent(credentials.password)}&submit=Sign+In`;
                    
                    const result = await context.http.fetchDirect('/signin.php', {
                        method: 'POST',
                        body: body,
                        referrer: 'https://demonicscans.org/',
                        parseJson: false
                    });

                    // Check if login was successful
                    // "You are already signed in" = sucesso (j√° estava logado ou login completou)
                    // "Sign in to your account" = falha
                    const responseText = result.data || '';
                    const isAlreadySignedIn = responseText.includes('You are already signed in') || 
                                             responseText.includes('you will be redirected');
                    const isLoginPage = this.isLoggedOut(result.data);

                    if (isLoginPage && !isAlreadySignedIn) {
                        logger.error('‚ùå Falha no login - credenciais incorretas?');
                        return false;
                    }

                    logger.info('‚úÖ Login bem-sucedido!');
                    await sleep(1000); // Wait for session to stabilize
                    return true;
                } catch (error) {
                    logger.error('‚ùå Erro ao fazer login:', error);
                    return false;
                } finally {
                    // Limpa flag e promise
                    this.state.isLoggingIn = false;
                    this.state.loginPromise = null;
                }
            })();

            return await this.state.loginPromise;
        },

        async sendReaction(context, chapterId, reactionType, userUID) {
            // Build form-encoded body (application/x-www-form-urlencoded)
            const body = `chapterid=${encodeURIComponent(chapterId)}&reaction=${encodeURIComponent(reactionType)}&useruid=${encodeURIComponent(userUID)}`;

            // Use http.fetchDirect (Cloudflare-proof)
            try {
                const result = await context.http.fetchDirect('/postreaction.php', {
                    method: 'POST',
                    body: body,
                    referrer: window.location.href,
                    parseJson: false // Response is plain text: 'added' or 'updated'
                });
                
                // Check if we got logged out (received login page)
                if (this.isLoggedOut(result.data)) {
                    // Se n√£o est√° logando, inicia o login (com lock)
                    if (!this.state.isLoggingIn) {
                        context.logger.warn('‚ö†Ô∏è Sess√£o expirada, iniciando login √∫nico...');
                    } else {
                        context.logger.debug('‚è≥ Sess√£o expirada, aguardando login em andamento...');
                    }
                    
                    const loginSuccess = await this.autoSignin(context);
                    if (!loginSuccess) {
                        return {
                            success: false,
                            message: 'Sess√£o expirada e falha no login autom√°tico',
                            statusCode: 401
                        };
                    }

                    // Retry the reaction after login
                    context.logger.debug('üîÑ Tentando rea√ß√£o novamente ap√≥s login...');
                    return this.sendReaction(context, chapterId, reactionType, userUID);
                }
                
                // fetchDirect with parseJson:false returns { success: bool, data: text }
                // Response is 'added' or 'updated' (plain text)
                return {
                    success: result.success,
                    message: result.data || result.error,
                    statusCode: result.status || 200
                };
            } catch (error) {
                return { success: false, message: error.message || 'Network error' };
            }
        },

        getUserUID(context) {
            // Try to get from cookie
            let uid = this.getCookie('useruid');
            
            if (!uid) {
                // Generate new UID
                uid = 'uid-' + Math.random().toString(36).substr(2, 16) + Date.now();
                this.setCookie('useruid', uid, 365);
                context.logger.info(`[UltraFastStamina] Generated new UserUID: ${uid}`);
            }

            return uid;
        },

        getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return null;
        },

        setCookie(name, value, days) {
            const expires = new Date();
            expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
            document.cookie = `${name}=${value}; expires=${expires.toUTCString()}; path=/`;
        },

        showResults(context) {
            const { logger } = context;
            const stats = this.state.stats;

            logger.info('‚ú® Ultra Fast Stamina conclu√≠do!');
            logger.info(`üìä Stats: ${stats.successful}/${stats.attempted} rea√ß√µes enviadas`);
            logger.info(`‚è±Ô∏è Dura√ß√£o: ${(stats.duration / 1000).toFixed(1)}s`);

            // Get floating helpers module
            const floatingHelpers = context.moduleRegistry?.getModule('floatingHelpers');
            
            if (!floatingHelpers || typeof floatingHelpers.openQuickLootModal !== 'function') {
                logger.warn('[UltraFastStamina] Modal not available');
                return;
            }

            // Create summary in modal-compatible format
            const summary = {
                drops: stats.totalReactions,
                exp: 0,
                gold: 0,
                items: new Map(),
                monsters: new Map(),
                messages: []
            };

            const durationSec = (stats.duration / 1000).toFixed(1);
            summary.messages.push(`‚ö° Ultra Fast Stamina: ${stats.successful} rea√ß√µes enviadas em ${durationSec}s`);
            summary.messages.push(`‚úÖ ${stats.successful} sucessos, ‚ùå ${stats.failed} falhas`);
            summary.messages.push(`üîÑ ${stats.alreadyReacted} cap√≠tulos j√° reagidos (pulados)`);

            // Call modal
            floatingHelpers.openQuickLootModal(context, summary, 'Ultra Fast Stamina');
        },

        cleanup() {
            if (this.state) {
                this.state.running = false;
            }
        }
    };

    // ============================================================================
    // ULTRA FAST DUNGEON ATTACK MODULE - Parallel dungeon attack
    // ============================================================================
    const ultraFastDungeonModule = {
        id: 'ultraFastDungeon',
        match: ({ location }) => /guild_dungeon_location\.php/i.test(location.pathname),
        
        init(context) {
            this.state = {
                running: false,
                stats: {
                    totalBatches: 0,
                    totalMonsters: 0,
                    successfulJoins: 0,
                    failedJoins: 0,
                    totalAttacks: 0,
                    monstersCompleted: 0,
                    startTime: null
                }
            };
            // context.logger.debug('[UltraFastDungeon] Module initialized');
        },

        activate(context) {
            const cfg = context.config.get();
            if (!cfg.core.enabled || !cfg.ultraFastDungeon?.enabled) {
                if (this.state) this.state.running = false;
                return;
            }
            
            if (!this.state) this.init(context);
            
            // Manual mode only (via button)
            context.logger.debug('[UltraFastDungeon] Module activated, waiting for manual trigger');
        },

        triggerManualRun(context) {
            const { logger } = context;
            
            if (this.state.running) {
                logger.warn('[UltraFastDungeon] J√° est√° rodando');
                return;
            }

            this.state.running = true;
            this.state.stats.startTime = Date.now();
            
            logger.info('‚ö° Ultra Fast Dungeon iniciado manualmente!');
            
            (async () => {
                try {
                    await this.runDungeonFarm(context);
                } catch (error) {
                    logger.error('[UltraFastDungeon] Erro fatal:', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },

        async runDungeonFarm(context) {
            const cfg = context.config.get().ultraFastDungeon;
            const { logger } = context;

            logger.info(`üìä Config: ${cfg.maxParallelBattles} paralelos, ${cfg.attacksPerMonster} ataques/mob, Smart Damage: ${cfg.useSmartDamage ? 'ON' : 'OFF'}`);

            // 1. Scan dungeon monsters
            const targets = await this.scanDungeonTargets(context);
            
            if (targets.length === 0) {
                logger.info('‚ùå Nenhum mob dispon√≠vel para farm ultra r√°pido');
                this.showResults(context);
                return;
            }

            // 2. Group into batches
            const batches = [];
            for (let i = 0; i < targets.length; i += cfg.maxParallelBattles) {
                batches.push(targets.slice(i, i + cfg.maxParallelBattles));
            }

            logger.info(`üéØ ${targets.length} mobs encontrados ‚Üí ${batches.length} lotes (${cfg.maxParallelBattles} mobs/lote)`);

            // 3. Process each batch
            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                this.state.stats.totalBatches++;

                logger.info(`‚ö° Lote ${batchIndex + 1}/${batches.length}: ${batch.length} mobs`);

                // Join battles if not joined yet
                const joinedTargets = await this.ensureBattlesJoined(context, batch);

                if (joinedTargets.length === 0) {
                    logger.warn('‚ö†Ô∏è Nenhuma entrada bem-sucedida neste lote');
                    continue;
                }

                // Attack all battles respecting damage thresholds
                await this.attackWithSmartDamage(context, joinedTargets);

                // Delay between batches
                if (batchIndex < batches.length - 1) {
                    logger.info(`‚è≥ Aguardando ${cfg.delayBetweenBatches}ms antes do pr√≥ximo lote...`);
                    await sleep(cfg.delayBetweenBatches);
                }
            }

            // Summary
            const duration = Date.now() - this.state.stats.startTime;
            logger.info(`‚úÖ Ultra Fast Dungeon conclu√≠do em ${(duration / 1000).toFixed(1)}s`);
            logger.info(`üìä ${this.state.stats.totalAttacks} ataques, ${this.state.stats.monstersCompleted} mobs completados`);

            this.showResults(context);
        },

        async scanDungeonTargets(context) {
            const cfg = context.config.get().ultraFastDungeon;
            const { logger } = context;

            // Extract filter names from CSV format (ultraFastDungeon.monsterNames)
            // Support both old and new formats for backward compatibility
            let includeNames = [];
            let excludeNames = [];
            
            // Try new structure first (monsterFilter.includeNames/excludeNames)
            const monsterFilter = cfg.monsterFilter || {};
            if (Array.isArray(monsterFilter.includeNames)) {
                includeNames = monsterFilter.includeNames.filter(Boolean);
            }
            if (Array.isArray(monsterFilter.excludeNames)) {
                excludeNames = monsterFilter.excludeNames.filter(Boolean);
            }
            
            // Fallback to old CSV format (monsterNames from textarea)
            if (includeNames.length === 0 && cfg.monsterNames) {
                const csv = String(cfg.monsterNames).trim();
                if (csv) {
                    // Parse CSV: split by newlines or commas, trim whitespace
                    includeNames = csv
                        .split(/[\n,]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                }
            }
            
            // Parse monster filters - suporta formato "nome" ou "nome:dano"
            const rawMonsterNames = includeNames.length > 0 ? includeNames : [];
            const monsterFilters = rawMonsterNames.map(entry => {
                const str = String(entry).trim();
                const colonIndex = str.lastIndexOf(':');
                
                if (colonIndex > 0) {
                    const namePart = str.substring(0, colonIndex).trim();
                    const damagePart = str.substring(colonIndex + 1).trim();
                    const customDamage = context.numbers.parse(damagePart);
                    
                    if (namePart && customDamage && customDamage > 0) {
                        return { name: namePart, customDamage };
                    }
                }
                
                // Formato simples (s√≥ nome)
                return { name: str, customDamage: null };
            }).filter(f => f.name.length > 0);
            
            // Log active filters
            if (includeNames.length > 0) {
                logger.info(`[UltraFastDungeon] ‚úì Incluindo APENAS: ${includeNames.join(', ')}`);
            }
            if (excludeNames.length > 0) {
                logger.info(`[UltraFastDungeon] ‚úó Excluindo: ${excludeNames.join(', ')}`);
            }
            logger.debug(`[UltraFastDungeon] Monster filters:`, monsterFilters.map(f => f.customDamage ? `${f.name}:${f.customDamage}` : f.name));

            // Use Monster Scanner Service
            const scanFilters = {
                minHp: cfg.minMobHp
            };
            
            // Only apply joined filters if explicitly enabled/disabled
            if (cfg.checkJoined && !cfg.checkNotJoined) {
                // Only joined monsters
                logger.debug('[UltraFastDungeon] Filter: Only JOINED monsters');
            } else if (cfg.checkNotJoined && !cfg.checkJoined) {
                // Only not joined monsters
                scanFilters.onlyNotJoined = true;
                logger.debug('[UltraFastDungeon] Filter: Only NOT JOINED monsters');
            } else {
                // Both (no filter)
                logger.debug('[UltraFastDungeon] Filter: BOTH joined and not joined monsters');
            }

            // Extract just the names for scanner
            if (monsterFilters.length > 0) {
                scanFilters.monsterNames = monsterFilters.map(f => f.name);
                logger.debug(`[UltraFastDungeon] Name filters: ${scanFilters.monsterNames.join(', ')}`);
            } else {
                logger.debug('[UltraFastDungeon] Name filters: ALL monsters');
            }

            let monsters = context.monsterScanner.scanDungeonMonsters(scanFilters);
            logger.info(`[UltraFastDungeon] Scanner found ${monsters.length} dungeon monsters`);

            // Apply exclude filter as secondary filter
            if (excludeNames.length > 0) {
                const beforeCount = monsters.length;
                monsters = monsters.filter(monster => {
                    const monsterNameLower = (monster.name || '').toLowerCase();
                    return !excludeNames.some(excludeName => 
                        monsterNameLower.includes(excludeName.toLowerCase())
                    );
                });
                logger.info(`[UltraFastDungeon] Ap√≥s filtro de exclus√£o: ${beforeCount} ‚Üí ${monsters.length} monstros`);
            }

            // Convert to Ultra Fast Dungeon format + add customDamageLimit
            const targets = monsters.map(monster => {
                const matchedFilter = monsterFilters.find(filter => 
                    monster.name.toLowerCase().includes(filter.name.toLowerCase())
                );

                return {
                    dgmid: monster.dgmid,
                    instanceId: monster.instanceId,
                    name: monster.name,
                    currentHp: monster.hp,
                    maxHp: monster.maxHp,
                    currentDamage: 0, // Will be fetched if joined
                    hasJoined: monster.hasJoined,
                    card: monster.card,
                    customDamageLimit: matchedFilter?.customDamage || null
                };
            });

            // Fetch current damage for joined battles
            if (targets.length > 0) {
                await this.fetchCurrentDamages(context, targets);
            }

            // Filter by threshold AFTER fetching damages
            const cfg2 = context.config.get().ultraFastDungeon;
            const filteredTargets = targets.filter(target => {
                const isMagus = /magus/i.test(target.name);
                const isSpecial = isSpecialBoss(target.name);
                
                // Priority: customDamageLimit > special boss (50M) > magus threshold > default threshold
                let damageThreshold;
                if (target.customDamageLimit) {
                    damageThreshold = target.customDamageLimit;
                    logger.debug(`[UltraFastDungeon] ${target.name}: Usando limite customizado: ${formatNumber(damageThreshold)}`);
                } else if (isSpecial) {
                    damageThreshold = Math.max(50000000, cfg2.damageThresholds.default); // 50M minimum for special bosses
                    logger.info(`[UltraFastDungeon] üëë ${target.name}: Boss especial - alvo: ${formatNumber(damageThreshold)} (m√≠nimo 50M para loot)`);
                } else {
                    damageThreshold = isMagus ? cfg2.damageThresholds.magus : cfg2.damageThresholds.default;
                }
                
                const safeThreshold = Math.floor(damageThreshold * cfg2.safetyMargin);
                
                // Calculate 20% of total HP limit (required for full EXP on kill)
                const expLimit = Math.floor(target.maxHp * 0.20);
                
                // Use the most restrictive limit
                let effectiveLimit = safeThreshold;
                if (cfg2.respectExpLimit && expLimit < safeThreshold) {
                    effectiveLimit = expLimit;
                    logger.debug(`[UltraFastDungeon] ${target.name}: Limite de EXP (20% HP) aplicado: ${formatNumber(expLimit)} < ${formatNumber(safeThreshold)}`);
                }

                target.isMagus = isMagus;
                target.maxDamage = effectiveLimit;
                target.remainingDamage = effectiveLimit - target.currentDamage;

                // Skip if already at or above threshold
                if (target.currentDamage >= effectiveLimit) {
                    logger.debug(`[UltraFastDungeon] ${target.name}: Dano ${formatNumber(target.currentDamage)} >= ${formatNumber(effectiveLimit)} (threshold) - ignorado`);
                    return false;
                }

                logger.debug(`[UltraFastDungeon] ‚úì ${target.name}: HP ${formatNumber(target.currentHp)}, Dano ${formatNumber(target.currentDamage)}/${formatNumber(effectiveLimit)} (faltam ${formatNumber(target.remainingDamage)})`);
                return true;
            });

            // Sort by priority
            this.sortTargets(filteredTargets, cfg2.priorityMode);

            return filteredTargets;
        },

        async fetchCurrentDamages(context, targets) {
            const { logger } = context;
            const joinedTargets = targets.filter(t => t.hasJoined);
            
            if (joinedTargets.length === 0) return;

            logger.info(`üîç Verificando dano atual de ${joinedTargets.length} batalhas j√° iniciadas...`);

            // Fetch damages in parallel (max 5 at a time to avoid overwhelming)
            const batchSize = 5;
            for (let i = 0; i < joinedTargets.length; i += batchSize) {
                const batch = joinedTargets.slice(i, i + batchSize);
                await Promise.all(batch.map(target => this.fetchBattleDamage(context, target)));
                await sleep(200); // Small delay between batches
            }
        },

        async fetchBattleDamage(context, target) {
            const { logger } = context;

            try {
                const url = `https://demonicscans.org/battle.php?dgmid=${target.dgmid}&instance_id=${target.instanceId}`;
                const response = await fetch(url, { credentials: 'include' });
                
                if (!response.ok) {
                    logger.warn(`[Damage Fetch] HTTP ${response.status} para ${target.name}`);
                    return;
                }

                const html = await response.text();
                
                // Parse damage from HTML: DMG: <span id="yourDamageValue">5,291,020</span>
                const damageMatch = html.match(/DMG:\s*<span[^>]*>([0-9,]+)<\/span>/i);
                if (damageMatch) {
                    target.currentDamage = numberFromText(damageMatch[1]);
                    logger.debug(`[Damage Fetch] ${target.name}: ${formatNumber(target.currentDamage)} dano`);
                } else {
                    // Try alternative patterns
                    const altMatch = html.match(/yourDamageValue[^>]*>([0-9,]+)</i);
                    if (altMatch) {
                        target.currentDamage = numberFromText(altMatch[1]);
                        logger.debug(`[Damage Fetch] ${target.name}: ${formatNumber(target.currentDamage)} dano (alt)`);
                    }
                }
            } catch (error) {
                logger.warn(`[Damage Fetch] Erro ao buscar dano de ${target.name}:`, error.message);
            }
        },

        sortTargets(targets, mode) {
            switch (mode) {
                case 'lowest_damage':
                    targets.sort((a, b) => a.currentDamage - b.currentDamage);
                    break;
                case 'highest_damage':
                    targets.sort((a, b) => b.currentDamage - a.currentDamage);
                    break;
                case 'lowest_hp':
                    targets.sort((a, b) => a.currentHp - b.currentHp);
                    break;
                case 'highest_hp':
                    targets.sort((a, b) => b.currentHp - a.currentHp);
                    break;
            }
        },

        async ensureBattlesJoined(context, targets) {
            const { logger } = context;
            const joinedTargets = [];

            // Separar alvos que j√° est√£o joined dos que precisam join
            const alreadyJoined = targets.filter(t => t.hasJoined);
            const needJoin = targets.filter(t => !t.hasJoined);

            // Adicionar os que j√° est√£o joined
            alreadyJoined.forEach(target => {
                joinedTargets.push(target);
                logger.debug(`[UltraFastDungeon] ${target.name}: J√° est√° joined`);
            });

            if (needJoin.length === 0) {
                return joinedTargets;
            }

            // üî• PRE-FLIGHT ATTACK: Preparar TODAS as requisi√ß√µes de join antes de enviar
            logger.info(`üöÄ PRE-FLIGHT JOIN: Preparando ${needJoin.length} requisi√ß√µes simult√¢neas...`);
            
            // Criar array de promises para joins simult√¢neos
            const joinPromises = needJoin.map(target => {
                // Retornar uma fun√ß√£o que cria a promise (n√£o a promise diretamente)
                return {
                    target,
                    execute: () => context.http.joinDungeonBattle(target.dgmid, target.instanceId)
                };
            });

            logger.info(`‚ö° Disparando ${joinPromises.length} joins SIMULTANEAMENTE...`);
            
            // Executar TODAS as requisi√ß√µes ao mesmo tempo (Pre-Flight)
            const startTime = Date.now();
            const results = await Promise.all(
                joinPromises.map(async ({ target, execute }) => {
                    try {
                        const result = await execute();
                        return { target, result, success: true };
                    } catch (error) {
                        logger.error(`Erro ao entrar em ${target.name}: ${error.message}`);
                        return { target, result: { success: false, message: error.message }, success: false };
                    }
                })
            );
            const duration = Date.now() - startTime;

            logger.info(`‚úÖ Pre-Flight conclu√≠do em ${duration}ms`);

            // Processar resultados
            let successCount = 0;
            let failCount = 0;

            results.forEach(({ target, result }) => {
                if (result.success || result.cloudflareBlock) {
                    joinedTargets.push(target);
                    this.state.stats.successfulJoins++;
                    this.state.stats.totalMonsters++;
                    successCount++;
                    logger.debug(`  ‚úÖ ${target.name}: Join bem-sucedido`);
                } else {
                    logger.warn(`  ‚ö†Ô∏è ${target.name}: Falha - ${result.message}`);
                    this.state.stats.failedJoins++;
                    failCount++;
                }
            });

            logger.info(`üìä Pre-Flight Join: ${successCount} sucessos, ${failCount} falhas (${duration}ms total)`);

            return joinedTargets;
        },

        async attackWithSmartDamage(context, targets) {
            const cfg = context.config.get().ultraFastDungeon;
            const battleCfg = context.config.get().battle;
            const { logger } = context;

            if (targets.length === 0) {
                logger.warn('‚ö†Ô∏è Nenhum alvo para atacar');
                return;
            }

            // Inicializar estado de cada alvo
            const targetStates = targets.map(target => ({
                ...target,
                attackCount: 0,
                totalDamageDealt: 0,
                currentDamage: target.currentDamage,
                completed: false,
                skillId: battleCfg.attackSkillId || 0
            }));

            logger.info(`üöÄ PRE-FLIGHT ATTACK: ${targets.length} monstros, ${cfg.attacksPerMonster} ataques cada`);

            // Executar rodadas de ataque paralelo
            for (let round = 0; round < cfg.attacksPerMonster; round++) {
                // Verificar stamina antes de cada rodada
                const currentStamina = context.stamina.getCurrent();
                if (currentStamina === 0) {
                    logger.warn(`‚ö†Ô∏è Stamina em 0! Parando ataques.`);
                    logger.info(`üí° Aguarde a Stamina regenerar ou use uma po√ß√£o de Stamina.`);
                    this.state.running = false;
                    return;
                }

                // Filtrar alvos que ainda precisam de ataque
                const activeTargets = targetStates.filter(t => !t.completed && t.attackCount < cfg.attacksPerMonster);
                
                if (activeTargets.length === 0) {
                    logger.info(`‚úÖ Todos os alvos atingiram threshold ou completaram ataques`);
                    break;
                }

                logger.info(`‚öîÔ∏è Rodada ${round + 1}/${cfg.attacksPerMonster}: Atacando ${activeTargets.length} monstros em PARALELO...`);

                // Preparar ataques para todos os alvos ativos (Pre-Flight)
                const attackPromises = activeTargets.map(targetState => {
                    // Recalcular skill se usando smart damage
                    if (cfg.useSmartDamage) {
                        // Ultra Fast Dungeon usa smartDamage de battle.smartDamage, mas s√≥ precisa de useSmartDamage=true
                        // Se smartDamage n√£o estiver configurado, usar skills padr√£o
                        const skills = battleCfg.smartDamage?.skills || {
                            slash: { skillId: 0, damageLimit: 0, name: 'Slash' },
                            powerSlash: { skillId: -1, damageLimit: 320000, name: 'Power Slash' },
                            heroicSlash: { skillId: -2, damageLimit: 1600000, name: 'Heroic Slash' },
                            ultimateSlash: { skillId: -3, damageLimit: 3400000, name: 'Ultimate Slash' },
                            legendarySlash: { skillId: -4, damageLimit: 6800000, name: 'Legendary Slash' }
                        };
                        
                        const smartSkill = selectSmartSkill(targetState.currentDamage, targetState.maxDamage, skills);
                        if (smartSkill) {
                            targetState.skillId = smartSkill.skillId;
                            logger.debug(`  üß† ${targetState.name}: Smart damage selecionou ${smartSkill.name} (skillId: ${smartSkill.skillId}, limite: ${formatNumber(smartSkill.damageLimit)})`);
                        }
                    }

                    return {
                        targetState,
                        execute: () => this.sendAttack(context, targetState.dgmid, targetState.instanceId, targetState.skillId)
                    };
                });

                // Disparar TODOS os ataques simultaneamente
                const startTime = Date.now();
                const results = await Promise.all(
                    attackPromises.map(async ({ targetState, execute }) => {
                        try {
                            const attackResult = await execute();
                            return { targetState, attackResult, error: null };
                        } catch (error) {
                            return { targetState, attackResult: null, error };
                        }
                    })
                );
                const duration = Date.now() - startTime;

                // Processar resultados
                let successCount = 0;
                let thresholdCount = 0;

                for (const { targetState, attackResult, error } of results) {
                    if (error) {
                        logger.error(`  ‚ùå ${targetState.name}: Erro - ${error.message}`);
                        continue;
                    }

                    if (attackResult?.success) {
                        // Extract damage from the correct field (combat service returns it at top level)
                        const damageDealt = attackResult.damageDealt || attackResult.data?.damageDealt || 0;
                        const monsterHp = attackResult.data?.hp?.value || 0;
                        
                        targetState.attackCount++;
                        targetState.totalDamageDealt += damageDealt;
                        targetState.currentDamage += damageDealt;
                        this.state.stats.totalAttacks++;
                        successCount++;
                        
                        logger.debug(`  ‚úì ${targetState.name}: +${formatNumber(damageDealt)} dano (Total: ${formatNumber(targetState.currentDamage)}/${formatNumber(targetState.maxDamage)})`);
                        
                        // Verificar threshold
                        if (targetState.currentDamage >= targetState.maxDamage) {
                            targetState.completed = true;
                            thresholdCount++;
                            logger.info(`  üéØ ${targetState.name}: Threshold atingido! (${formatNumber(targetState.currentDamage)}/${formatNumber(targetState.maxDamage)})`);
                        }
                    } else {
                        logger.warn(`  ‚ö†Ô∏è ${targetState.name}: Ataque falhou`);
                        targetState.attackCount++; // Contar mesmo falhando para evitar loop infinito
                    }
                }

                logger.info(`üìä Rodada ${round + 1}: ${successCount} ataques OK, ${thresholdCount} thresholds (${duration}ms)`);

                // Pequeno delay entre rodadas (n√£o entre ataques individuais)
                if (round < cfg.attacksPerMonster - 1) {
                    await sleep(200);
                }
            }

            // Resumo final
            for (const targetState of targetStates) {
                logger.info(`‚úÖ ${targetState.name}: ${targetState.attackCount} ataques, ${formatNumber(targetState.totalDamageDealt)} dano total`);
                this.state.stats.monstersCompleted++;
            }
        },

        async sendAttack(context, dgmid, instanceId, skillId) {
            const { logger } = context;
            
            // Use centralized combat service (Cloudflare-proof)
            return context.combat.attackDungeonMonsterDirect(dgmid, instanceId, skillId);
        },

        estimateDamage(skillId) {
            // Rough damage estimates based on skill ID
            // These are very rough estimates - actual damage varies
            switch (skillId) {
                case 0: return 50000;      // Slash
                case -1: return 200000;    // Power Slash
                case -2: return 800000;    // Heroic Slash
                case -3: return 2000000;   // Ultimate Slash
                case -4: return 4000000;   // Legendary Slash
                default: return 50000;
            }
        },

        showResults(context) {
            const { logger } = context;
            const stats = this.state.stats;
            const duration = Date.now() - stats.startTime;

            logger.info('‚ú® Ultra Fast Dungeon conclu√≠do!');
            logger.info(`üìä Stats: ${stats.totalAttacks} ataques, ${stats.monstersCompleted} mobs`);
            logger.info(`‚è±Ô∏è Dura√ß√£o: ${(duration / 1000).toFixed(1)}s`);

            // Get floating helpers module
            const floatingHelpers = context.moduleRegistry?.getModule('floatingHelpers');
            
            if (!floatingHelpers || typeof floatingHelpers.openQuickLootModal !== 'function') {
                logger.warn('[UltraFastDungeon] Modal not available');
                return;
            }

            // Create summary
            const summary = {
                drops: 0,
                exp: 0,
                gold: 0,
                items: new Map(),
                monsters: new Map(),
                messages: []
            };

            const durationSec = (duration / 1000).toFixed(1);
            summary.messages.push(`‚ö° Ultra Fast Dungeon: ${stats.monstersCompleted} mobs em ${durationSec}s`);
            summary.messages.push(`‚öîÔ∏è ${stats.totalAttacks} ataques enviados`);
            summary.messages.push(`‚úÖ ${stats.successfulJoins} joins, ‚ùå ${stats.failedJoins} falhas`);

            floatingHelpers.openQuickLootModal(context, summary, 'Ultra Fast Dungeon');
        },

        cleanup() {
            if (this.state) {
                this.state.running = false;
            }
        }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üöÄ PVP MODULE - Ultra Fast PvP automation via API direct attacks
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const pvpModule = {
        id: 'pvpAutomation',
        match: ({ location }) => {
            const path = location.pathname.toLowerCase();
            return path.includes('pvp.php') || path.includes('pvp_battle');
        },
        
        init(context) {
            this.state = {
                active: false,
                isRunning: false,  // Flag to prevent duplicate activation
                battlesCompleted: 0,
                battlesWon: 0,
                battlesLost: 0,
                attacksSent: 0,
                sessionStartTime: null,
                currentBattleStartTime: null,
                running: true,  // Changed to true so the loop can execute
                rotationPatternIndex: 0,  // Which skill group in the pattern
                rotationAttackCount: 0  // Count of attacks in current skill group
            };
            
            // Listen for config changes to re-activate the module if enabled
            if (context.events && typeof context.events.on === 'function') {
                context.events.on('autods:config:updated', () => {
                    const cfg = context.config.get().pvp;
                    if (cfg?.enabled && this.match({ location: context.location })) {
                        // Re-activate the module when config changes to enabled
                        context.logger.info('[PvP] Config changed - re-activating module');
                        this.activate(context);
                    }
                });
            }
        },
        
        activate(context) {
            try {
                if (!this.state) {
                    this.init(context);
                }
                
                // Prevent duplicate activation
                if (this.state.isRunning) {
                    return;
                }
                
                const cfgRoot = context.config.get();
                const cfg = cfgRoot.pvp;
                const path = context.location.pathname.toLowerCase();
                
                // Log FIRST - so user always sees the module is being activated
                context.logger.debug(`[PvP] Module activated on ${path}`);
                context.logger.debug(`[PvP] Config state - core.enabled=${cfgRoot.core?.enabled}, pvp.enabled=${cfg?.enabled}`);
                
                // Check if core automation is enabled
                if (!cfgRoot.core.enabled) {
                    context.logger.debug('[PvP] Core automation disabled globally');
                    return;
                }
                
                // Check if PvP automation is enabled
                if (!cfg?.enabled) {
                    context.logger.debug('[PvP] PvP automation disabled - enable in UI');
                    return;
                }
                
                // Mark as running
                this.state.isRunning = true;
                
                // All conditions met - start automation
                if (path.includes('pvp_battle')) {
                    this.handleUltraFastBattle(context).catch(error => {
                        context.logger.error('Ultra Fast PvP battle error:', error);
                        this.state.isRunning = false;
                    });
                } else if (path.includes('pvp.php')) {
                    context.logger.info('[UltraFastPvP] Starting matchmaking loop');
                    this.runAutoMatchmakingLoop(context).catch(error => {
                        context.logger.error('Ultra Fast PvP matchmaking error:', error);
                        this.state.isRunning = false;
                    });
                }
            } catch (error) {
                context.logger.error('Ultra Fast PvP FATAL ERROR:', error);
                this.state.isRunning = false;
            }
        },
        
        cleanup() {
            this.state.running = false;
            this.state.active = false;
        },
        
        /**
         * Main automated matchmaking loop (runs when on pvp.php)
         * Continuously tries to find battles until tokens run out
         */
        async runAutoMatchmakingLoop(context) {
            const { logger } = context;
            const cfg = context.config.get().pvp;
            
            if (!cfg?.enabled) {
                logger.info('[PvP] automation desativado, abortando');
                return;
            }
            
            // Initialize session start time
            if (!this.state.sessionStartTime) {
                this.state.sessionStartTime = Date.now();
            }
            
            let attemptCount = 0;
            const maxAttempts = 100;  // Safety limit
            
            logger.info('üèüÔ∏è Ultra Fast PvP: Starting auto matchmaking loop...');
            
            while (this.state.running && attemptCount < maxAttempts) {
                attemptCount++;
                logger.debug(`[UltraFastPvP] Tentativa ${attemptCount}/${maxAttempts}`);
                
                // Check if Ultra Fast Mode is still enabled
                const freshCfg = context.config.get().pvp;
                if (!freshCfg?.enabled) {
                    logger.info('‚è∏Ô∏è PvP disabled via config');
                    break;
                }
                
                // Check tokens from page
                const tokens = this.getPvpTokens();
                if (!tokens) {
                    logger.warn('‚ö†Ô∏è Could not read PvP tokens from page');
                    await sleep(1000);
                    continue;
                }
                
                logger.debug(`‚öîÔ∏è PvP Tokens: ${tokens.current}/${tokens.max}`);
                
                // Check if we have tokens
                if (tokens.current < 1) {
                    logger.warn('‚ö†Ô∏è No tokens available');
                    logger.info('‚è≥ Aguardando 1 hora para regenerar tokens...');
                    
                    // Wait 1 hour
                    await sleep(3600000);
                    
                    // Reload the page
                    logger.info('üîÑ Recarregando p√°gina...');
                    window.location.href = window.location.href;
                    return;
                }
                
                // Start matchmaking via API
                logger.info('üéØ Starting matchmaking...');
                const matchResult = await context.http.startPvpMatchmaking();
                logger.debug(`[UltraFastPvP] Matchmaking result: ${matchResult.success ? '‚úÖ' : '‚ùå'} - ${matchResult.error || matchResult.message}`);
                
                if (!matchResult.success) {
                    logger.warn(`‚ùå Matchmaking failed: ${matchResult.error || matchResult.message}`);
                    await sleep(2000);
                    continue;
                }
                
                logger.info('‚úÖ Matchmaking successful, waiting for battle page to load...');
                
                // Wait for battle page to load (indicated by URL change)
                await sleep(1500);
                
                // Check if we're now on the battle page
                let currentPath = window.location.pathname.toLowerCase();
                if (currentPath.includes('pvp_battle')) {
                    logger.info('‚ú® Battle page loaded, starting battle automation...');
                    await this.handleUltraFastBattle(context);
                    
                    // After battle ends, we should be back on lobby
                    // Repeat the loop for the next battle
                    await sleep(1000);
                } else {
                    logger.warn('‚ö†Ô∏è Matchmaking found, but page did not change. Looking for Start Matching button...');
                    
                    // Try to find and click the Start Matching button
                    let battleBtn = document.getElementById('btnStartTop');
                    
                    // Fallback: Look for button with "Start Matching" text
                    if (!battleBtn) {
                        const buttons = Array.from(document.querySelectorAll('button'));
                        battleBtn = buttons.find(btn => btn.textContent.includes('Start Matching'));
                    }
                    
                    if (battleBtn) {
                        battleBtn.click();
                        await sleep(2000);  // Wait longer for battle page to load
                        currentPath = window.location.pathname.toLowerCase();
                        if (currentPath.includes('pvp_battle')) {
                            logger.info('‚ú® Battle page loaded after button click, starting battle automation...');
                            await this.handleUltraFastBattle(context);
                            await sleep(1000);
                        } else {
                            logger.warn('‚ö†Ô∏è Still not on battle page after button click');
                            await sleep(2000);
                        }
                    } else {
                        logger.warn('‚ö†Ô∏è Could not find Start Matching button on page');
                        await sleep(2000);
                    }
                }
            }
            
            logger.info('üèÅ Auto matchmaking loop ended');
            this.state.isRunning = false;  // Reset the running flag
        },
        
        /**
         * Get the next skill ID based on smart rotation pattern or fallback to configured skill
         */
        getNextSkill(ultraCfg) {
            if (!ultraCfg.useSmartRotation) {
                return ultraCfg.skillId ?? 0;
            }
            
            const pattern = ultraCfg.smartRotationPattern || [];
            if (pattern.length === 0) {
                return ultraCfg.skillId ?? 0;
            }
            
            const currentGroup = pattern[this.state.rotationPatternIndex];
            const skill = currentGroup.skill;
            
            // Increment counters for next call
            this.state.rotationAttackCount++;
            
            if (this.state.rotationAttackCount >= currentGroup.count) {
                // Move to next skill group
                this.state.rotationPatternIndex = (this.state.rotationPatternIndex + 1) % pattern.length;
                this.state.rotationAttackCount = 0;
            }
            
            return skill;
        },
        
        /**
         * Handle Ultra Fast Battle - Attack as fast as possible
         */
        async handleUltraFastBattle(context) {
            const { logger } = context;
            const cfg = context.config.get().pvp;
            const ultraCfg = cfg.ultraFastConfig || {};
            
            this.state.running = true;
            this.state.currentBattleStartTime = Date.now();
            
            // Reset rotation counters at start of battle
            this.state.rotationPatternIndex = 0;
            this.state.rotationAttackCount = 0;
            
            const minDelay = ultraCfg.minDelayBetweenAttacks ?? 100;
            
            const rotationMode = ultraCfg.useSmartRotation ? ' [Smart Rotation]' : '';
            logger.info(`‚öîÔ∏è Ultra Fast PvP Battle Started!${rotationMode}`);
            
            let attackCount = 0;
            let consecutiveErrors = 0;
            const maxConsecutiveErrors = 5;
            
            // Main attack loop - attack until battle ends
            while (this.state.running) {
                // Check if we're still on battle page
                const currentPath = window.location.pathname.toLowerCase();
                if (!currentPath.includes('pvp_battle')) {
                    logger.info('üîÑ No longer on battle page, battle ended');
                    break;
                }
                
                // Check DOM for battle end
                if (this.isBattleEnded()) {
                    logger.info('üèÅ Battle ended (detected via DOM)');
                    break;
                }
                
                // Get skill for this attack (either from rotation or config)
                const attackSkill = this.getNextSkill(ultraCfg);
                
                // Send attack via API
                const result = await context.http.attackPvpDirect(attackSkill);
                attackCount++;
                this.state.attacksSent++;
                
                if (result.success && result.data) {
                    consecutiveErrors = 0;
                    const data = result.data;
                    
                    // Log damage dealt/taken
                    if (data.your_damage || data.enemy_damage) {
                        logger.debug(`‚öîÔ∏è Hit #${attackCount}: You dealt ${data.your_damage} dmg, took ${data.enemy_damage} dmg`);
                    }
                    
                    // Check if battle ended from response
                    if (data.ended === 1) {
                        logger.info(`üèÅ Battle ended (response indicated) after ${attackCount} attacks`);
                        // Check who won
                        const myHp = data.my_hp;
                        const enemyHp = data.enemy_hp;
                        if (myHp > 0 && enemyHp <= 0) {
                            this.state.battlesWon++;
                            logger.info('üèÜ Victory!');
                        } else if (myHp <= 0) {
                            this.state.battlesLost++;
                            logger.info('üíÄ Defeat!');
                        }
                        break;
                    }
                    
                    // Check HP to detect death
                    if (data.my_hp !== undefined && data.my_hp <= 0) {
                        logger.info('üíÄ You died - battle lost');
                        this.state.battlesLost++;
                        break;
                    }
                    if (data.enemy_hp !== undefined && data.enemy_hp <= 0) {
                        logger.info('üèÜ Enemy defeated - battle won!');
                        this.state.battlesWon++;
                        break;
                    }
                    
                    // Check remaining tokens
                    if (data.attacker_tokens !== undefined) {
                        logger.debug(`üìä Your tokens: ${data.attacker_tokens}`);
                    }
                } else {
                    consecutiveErrors++;
                    logger.warn(`‚ö†Ô∏è Attack error (${consecutiveErrors}/${maxConsecutiveErrors}): ${result.message || result.error}`);
                    
                    if (consecutiveErrors >= maxConsecutiveErrors) {
                        logger.warn('‚ùå Too many consecutive errors, checking if battle ended via DOM...');
                        await sleep(500);
                        
                        if (this.isBattleEnded()) {
                            logger.info('üèÅ Battle ended (confirmed via DOM)');
                            break;
                        }
                        
                        // Reset error count and continue
                        consecutiveErrors = 0;
                    }
                }
                
                // Minimal delay between attacks
                if (minDelay > 0) {
                    await sleep(minDelay);
                }
            }
            
            // Battle finished
            this.state.battlesCompleted++;
            this.state.running = false;
            
            const battleDuration = Date.now() - this.state.currentBattleStartTime;
            logger.info(`‚úÖ Battle #${this.state.battlesCompleted} completed in ${(battleDuration / 1000).toFixed(1)}s (${attackCount} attacks)`);
            
            // Show stats every 5 battles
            if (this.state.battlesCompleted % 5 === 0) {
                this.showStats(context);
            }
            
            // Wait for page to redirect back to lobby
            logger.info('‚è≥ Waiting for return to lobby...');
            await sleep(2000);
            
            // Try to click the return link if modal is showing
            const returnLink = document.querySelector('a[href*="pvp.php" i]');
            if (returnLink) {
                logger.info('‚Ü©Ô∏è Clicking return to lobby link...');
                returnLink.click();
                await sleep(1000);
            }
            
            // Note: isRunning will be reset by runAutoMatchmakingLoop when it continues
        },
        
        /**
         * Check PvP tokens from page
         */
        getPvpTokens() {
            // Look for token display in the info box: "‚öîÔ∏è 30 /30"
            const tokenElements = Array.from(document.querySelectorAll('*')).filter(el => {
                return el.textContent.match(/‚öîÔ∏è\s*(\d+)\s*\/\s*(\d+)/);
            });
            
            for (const el of tokenElements) {
                const match = el.textContent.match(/‚öîÔ∏è\s*(\d+)\s*\/\s*(\d+)/);
                if (match) {
                    return { 
                        current: parseInt(match[1], 10), 
                        max: parseInt(match[2], 10) 
                    };
                }
            }
            
            // Fallback: search for generic number pattern
            const allText = document.body.innerText;
            const lobbyMatch = allText.match(/PvP Tokens[^]*?(\d+)\s*\/\s*(\d+)/i);
            if (lobbyMatch) {
                return { 
                    current: parseInt(lobbyMatch[1], 10), 
                    max: parseInt(lobbyMatch[2], 10) 
                };
            }
            
            return null;
        },
        
        /**
         * Check if battle ended via DOM
         */
        isBattleEnded() {
            const endModal = document.querySelector('#endModal');
            if (endModal) {
                const style = window.getComputedStyle(endModal);
                if (style.display !== 'none') {
                    return true;
                }
            }
            
            // Check for result text indicators
            const bodyText = document.body.innerText || '';
            if (bodyText.includes('Victory') || bodyText.includes('Defeat')) {
                return true;
            }
            
            return false;
        },
        
        /**
         * Show session statistics
         */
        showStats(context) {
            const { logger } = context;
            const duration = this.state.sessionStartTime ? 
                (Date.now() - this.state.sessionStartTime) / 1000 : 0;
            
            const winRate = this.state.battlesCompleted > 0 ?
                ((this.state.battlesWon / this.state.battlesCompleted) * 100).toFixed(1) : 0;
            
            logger.info(`üìä Ultra Fast PvP Stats:
  ‚îú‚îÄ Battles: ${this.state.battlesCompleted} (${this.state.battlesWon}W/${this.state.battlesLost}L) - ${winRate}% win rate
  ‚îú‚îÄ Total Attacks: ${this.state.attacksSent}
  ‚îî‚îÄ Session Duration: ${(duration / 60).toFixed(1)} minutes`);
            
            // Show notification
            context.notifications.info(`üèüÔ∏è PvP: ${this.state.battlesCompleted} battles (${winRate}% win)`);
        }
    };

    const attackUnlockerModule = {
        id: 'attackUnlocker',
        match: ({ location }) => {
            const path = location.pathname;
            // Active on any battle page (battle.php, pvp_battle.php, dungeon pages, etc)
            return /battle/i.test(path) || /dungeon/i.test(path) || /boss/i.test(path);
        },
        init(context) {
            this.state = {
                injected: false,
                intervalId: null
            };
            context.logger.debug('attackUnlocker module initialised');
        },
        activate(context) {
            // Check if feature is enabled
            const cfg = context.config.get();
            if (cfg.core?.unlockAttackButtons === false) {
                context.logger.debug('Attack unlocker desabilitado via configura√ß√£o');
                this.cleanup();
                return;
            }

            if (this.state.injected) return;

            // context.logger.info('üîì Ativando desbloqueio permanente de bot√µes de ataque...');

            // Strategy 1: Neutralize the lockAttackButtons function
            this.injectGlobalBypass(context);

            // Strategy 2: Continuously unlock buttons via interval
            this.startButtonUnlocker(context);

            // Strategy 3: Intercept clicks to force unlock just-in-time
            this.interceptClicks(context);

            this.state.injected = true;
            context.logger.info('‚úÖ Desbloqueio de ataques ativo! Voc√™ pode atacar sem delay de 1s.');
        },
        cleanup() {
            if (this.state.intervalId) {
                clearInterval(this.state.intervalId);
                this.state.intervalId = null;
            }
            this.state.injected = false;
        },
        injectGlobalBypass(context) {
            try {
                const script = document.createElement('script');
                script.textContent = `
                    (function() {
                        // Backup original function if needed for debugging
                        window._originalLockAttackButtons = window.lockAttackButtons;

                        // Override lockAttackButtons with no-op
                        // window.lockAttackButtons = function(lock) {
                        //     // Do nothing - attacks remain unlocked
                        // };

                        // Also intercept any setTimeout/setInterval that might re-enable locks
                        const originalSetTimeout = window.setTimeout;
                        window.setTimeout = function(fn, delay, ...args) {
                            // If it's trying to unlock buttons after 1000ms, do it immediately
                            if (delay === 1000 && typeof fn === 'function') {
                                const fnStr = fn.toString();
                                if (fnStr.includes('disabled') || fnStr.includes('lockAttack')) {
                                    // delay = 0; // Execute immediately
                                    delay = 0; // Execute immediately
                                }
                            }
                            return originalSetTimeout.call(window, fn, delay, ...args);
                        };

                    })();
                `;
                document.documentElement.appendChild(script);
                script.remove();

                context.logger.info('‚úÖ Bypass global de lockAttackButtons injetado');
            } catch (error) {
                context.logger.warn('Falha ao injetar bypass global', error);
            }
        },
        startButtonUnlocker(context) {
            // Clear any existing interval
            if (this.state.intervalId) {
                clearInterval(this.state.intervalId);
            }

            // Continuously unlock all attack buttons every 50ms
            this.state.intervalId = setInterval(() => {
                const buttons = document.querySelectorAll('.attack-btn[disabled], button.attack-btn[disabled], button[data-skill-id][disabled]');
                if (buttons.length > 0) {
                    buttons.forEach(btn => {
                        btn.removeAttribute('disabled');
                        btn.disabled = false;
                        btn.classList.remove('disabled', 'btn-disabled', 'attack-disabled');
                    });
                    // Only log when we actually unlock something
                    // context.logger.debug(`üîì Desbloqueados ${buttons.length} bot√µes de ataque`);
                }
            }, 50); // Check every 50ms for fast response

            // Cleanup on page unload
            window.addEventListener('beforeunload', () => {
                if (this.state.intervalId) {
                    clearInterval(this.state.intervalId);
                }
            }, { once: true });

            context.logger.info('‚úÖ Intervalo de desbloqueio autom√°tico iniciado (50ms)');
        },
        interceptClicks(context) {
            // Add click listener to all attack buttons (current and future)
            document.addEventListener('click', (event) => {
                const target = event.target;

                // Check if it's an attack button
                if (target &&
                    (target.classList.contains('attack-btn') ||
                     target.dataset?.skillId !== undefined ||
                     target.getAttribute?.('data-skill-id') !== null)) {

                    // Force unlock just before click processes
                    target.removeAttribute('disabled');
                    target.disabled = false;
                    target.classList.remove('disabled', 'btn-disabled', 'attack-disabled');

                    // context.logger.debug('üîì Bot√£o de ataque desbloqueado via interceptor de clique');
                }
            }, true); // Use capture phase to intercept before other handlers

            context.logger.info('‚úÖ Interceptor de cliques instalado');
        }
    };

    /**
     * Module to inject "Join Now" and "Fight Now" buttons
     * Always active on wave and dungeon pages
     */
    const directJoinButtonsModule = {
        id: 'directJoinButtons',
        match: ({ location }) => {
            const path = location.pathname;
            return /active_wave\.php/i.test(path) || /guild_dungeon_location\.php/i.test(path);
        },
        init() {
            this.state = {
                buttonsInjected: false
            };
        },
        activate(context) {
            if (!this.state) this.init();
            
            // Always inject buttons, regardless of automation being enabled
            this.injectButtons(context);
        },
        injectButtons(context) {
            const { logger, dom, location } = context;
            
            // Wait for DOM to be fully loaded
            setTimeout(() => {
                const isWavePage = /active_wave\.php/i.test(location.pathname);
                const isDungeonPage = /guild_dungeon_location\.php/i.test(location.pathname);
                
                // Updated selectors: include .mon and .wave-monster
                const cards = dom.queryAll('.monster-card, .dungeon-monster-card, .mon, .wave-monster');
                
                if (!cards.length) {
                    // logger.debug('[DirectJoinButtons] No monster cards found on page');
                    return;
                }

                // logger.debug(`[DirectJoinButtons] Found ${cards.length} monster cards`);
                let buttonsAdded = 0;

                cards.forEach((card, index) => {
                    // Find the Join/Fight button - try multiple selectors
                    let actionButton = card.querySelector('button.join-btn');
                    
                    if (!actionButton) {
                        actionButton = card.querySelector('button.fight-btn');
                    }
                    
                    if (!actionButton) {
                        actionButton = card.querySelector('button.btn-join');
                    }
                    
                    if (!actionButton) {
                        actionButton = card.querySelector('#join-battle');
                    }
                    
                    // NEW: Try to find <a> with "Fight" or "Join" text
                    if (!actionButton) {
                        const links = card.querySelectorAll('a.btn');
                        for (const link of links) {
                            if (/join|fight/i.test(link.textContent || '')) {
                                actionButton = link;
                                break;
                            }
                        }
                    }
                    
                    if (!actionButton) {
                        // Fallback: find any button with "join" or "fight" text
                        const buttons = card.querySelectorAll('button');
                        for (const btn of buttons) {
                            if (/join|fight/i.test(btn.textContent || '')) {
                                actionButton = btn;
                                break;
                            }
                        }
                    }
                    
                    if (!actionButton) {
                        // logger.debug(`[DirectJoinButtons] Card ${index}: No action button found`);
                        return;
                    }
                    
                    // Only add to "Join"/"Fight" buttons, not "Continue" buttons
                    const buttonText = actionButton.textContent || '';
                    if (/continue/i.test(buttonText)) {
                        // logger.debug(`[DirectJoinButtons] Card ${index}: Skipping "Continue" button`);
                        return;
                    }
                    
                    // Extract monster ID from link or button
                    let monsterId = null;
                    let instanceId = null; // For guild dungeons
                    
                    // Try to get from nearby link first (dungeon_battle.php or battle.php)
                    const battleLink = card.querySelector('a[href*="battle.php?"], a[href*="battle.php&"], a[href*="dungeon_battle.php?"], a[href*="dungeon_battle.php&"]');
                    if (battleLink) {
                        const href = battleLink.getAttribute('href') || '';
                        // For dungeon: extract dgmid instead of id
                        const dgmidMatch = href.match(/[?&]dgmid=(\d+)/);
                        if (dgmidMatch) {
                            monsterId = dgmidMatch[1];
                            // Also extract instance_id for guild dungeons
                            const instanceMatch = href.match(/[?&]instance_id=(\d+)/);
                            if (instanceMatch) {
                                instanceId = instanceMatch[1];
                            }
                        } else {
                            const monsterIdMatch = href.match(/[?&]id=(\d+)/);
                            if (monsterIdMatch) {
                                monsterId = monsterIdMatch[1];
                            }
                        }
                    }
                    
                    // Try to get from button's href if it's an <a> tag
                    if (!monsterId && actionButton.tagName === 'A') {
                        const href = actionButton.getAttribute('href') || '';
                        const dgmidMatch = href.match(/[?&]dgmid=(\d+)/);
                        if (dgmidMatch) {
                            monsterId = dgmidMatch[1];
                        } else {
                            const monsterIdMatch = href.match(/[?&]id=(\d+)/);
                            if (monsterIdMatch) {
                                monsterId = monsterIdMatch[1];
                            }
                        }
                    }
                    
                    // Try to get from button's parent anchor
                    if (!monsterId && actionButton.parentElement?.tagName === 'A') {
                        const href = actionButton.parentElement.href;
                        const dgmidMatch = href?.match(/[?&]dgmid=(\d+)/);
                        if (dgmidMatch) {
                            monsterId = dgmidMatch[1];
                        } else {
                            const monsterIdMatch = href?.match(/[?&]id=(\d+)/);
                            if (monsterIdMatch) {
                                monsterId = monsterIdMatch[1];
                            }
                        }
                    }
                    
                    // Try to get from button onclick
                    if (!monsterId) {
                        const onclick = actionButton.getAttribute('onclick') || '';
                        const onclickMatch = onclick.match(/id[=:](\d+)/i);
                        if (onclickMatch) {
                            monsterId = onclickMatch[1];
                        }
                    }
                    
                    if (!monsterId) {
                        logger.debug(`[DirectJoinButtons] Card ${index}: No monster ID found`);
                        return;
                    }
                    
                    // Determine button label based on page type
                    const buttonLabel = isWavePage ? 'Join Now' : 'Fight Now';
                    
                    // Add direct join button (pass instanceId for guild dungeons)
                    // logger.debug(`[DirectJoinButtons] Card ${index}: Adding "${buttonLabel}" for monster ${monsterId}${instanceId ? ` (instance ${instanceId})` : ''}`);
                    addDirectJoinButton(actionButton, monsterId, buttonLabel, context, instanceId);
                    buttonsAdded++;
                });

                logger.info(`[DirectJoinButtons] ‚úÖ Added ${buttonsAdded} direct join buttons to ${cards.length} cards`);
                this.state.buttonsInjected = true;
            }, 1000); // Wait 1 second for DOM to stabilize
        },
        cleanup() {
            this.state.buttonsInjected = false;
        }
    };

    /**
     * Collections Organizer Module
     * Automatically reorganizes the collections page to show claimed collections at the end
     */
    const collectionsOrganizerModule = {
        id: 'collectionsOrganizer',
        match: ({ location }) => /collections\.php/i.test(location.pathname),
        
        init(context) {
            // context.logger.debug('[CollectionsOrganizer] Module initialized');
        },
        
        activate(context) {
            context.logger.info('[CollectionsOrganizer] Activating on collections page');
            
            // Wait for page to load, then reorganize
            const reorganize = () => {
                try {
                    this.reorganizeCollections(context);
                } catch (error) {
                    context.logger.error('[CollectionsOrganizer] Failed to reorganize:', { error });
                }
            };
            
            // Try immediately
            if (document.readyState === 'complete') {
                reorganize();
            } else {
                window.addEventListener('load', reorganize);
            }
            
            // Also observe DOM changes in case content loads dynamically
            const observer = new MutationObserver(() => {
                const grid = document.querySelector('.grid');
                if (grid && grid.children.length > 0) {
                    observer.disconnect();
                    reorganize();
                }
            });
            
            observer.observe(document.body, { childList: true, subtree: true });
            
            // Store for cleanup
            this.observer = observer;
        },
        
        reorganizeCollections(context) {
            const grid = context.dom.query('.grid');
            
            if (!grid) {
                context.logger.warn('[CollectionsOrganizer] Grid container not found');
                return;
            }
            
            const cards = context.dom.queryAll('.card', grid);
            
            if (cards.length === 0) {
                context.logger.warn('[CollectionsOrganizer] No collection cards found');
                return;
            }
            
            context.logger.debug(`[CollectionsOrganizer] Found ${cards.length} collection cards`);
            
            // Extract completion percentage from each card
            const cardsWithData = cards.map(card => {
                const button = context.dom.query('button', card);
                const isClaimed = button && button.textContent.includes('Claimed');
                
                // Find percentage text (e.g., "35%", "100%")
                let percentage = 0;
                const percentText = card.textContent.match(/(\d+)%/);
                if (percentText) {
                    percentage = parseInt(percentText[1], 10);
                }
                
                // Get title for logging
                const titleEl = context.dom.query('.title', card);
                const title = titleEl ? titleEl.textContent.trim() : 'Unknown';
                
                return {
                    card,
                    isClaimed,
                    percentage,
                    title
                };
            });
            
            // Separate claimed and unclaimed collections
            const claimed = cardsWithData.filter(item => item.isClaimed);
            const unclaimed = cardsWithData.filter(item => !item.isClaimed);
            
            // Sort unclaimed by percentage (highest to lowest)
            unclaimed.sort((a, b) => b.percentage - a.percentage);
            
            // Sort claimed by percentage (highest to lowest) - optional, but keeps consistency
            claimed.sort((a, b) => b.percentage - a.percentage);
            
            context.logger.info(`[CollectionsOrganizer] Found ${claimed.length} claimed and ${unclaimed.length} unclaimed collections`);
            
            if (unclaimed.length > 0) {
                context.logger.debug('[CollectionsOrganizer] Unclaimed sorted by %:', 
                    unclaimed.map(item => `${item.title}: ${item.percentage}%`).join(', '));
            }
            
            // Add visual indicator to claimed collections
            claimed.forEach(item => {
                const card = item.card;
                if (!card.classList.contains('autods-claimed')) {
                    card.classList.add('autods-claimed');
                    card.style.opacity = '0.7';
                    card.style.order = '999';
                }
            });
            
            // Reorder: unclaimed first (sorted by %), then claimed (sorted by %)
            const fragment = document.createDocumentFragment();
            
            // Add unclaimed collections first (highest % first)
            unclaimed.forEach(item => {
                fragment.appendChild(item.card);
            });
            
            // Add claimed collections at the end (highest % first)
            claimed.forEach(item => {
                fragment.appendChild(item.card);
            });
            
            // Clear grid and append reorganized cards
            grid.innerHTML = '';
            grid.appendChild(fragment);
            
            context.logger.info('[CollectionsOrganizer] ‚úì Collections reorganized by completion %');
            
            // Show notification
            context.notifications.success(`üìö Collections organized: sorted by completion (${claimed.length} claimed at bottom)`);
            
            // Add custom styles for better visual separation
            this.injectStyles(context);
        },
        
        injectStyles(context) {
            if (document.getElementById('autods-collections-styles')) {
                return; // Already injected
            }
            
            const style = document.createElement('style');
            style.id = 'autods-collections-styles';
            style.textContent = `
                /* Collections Organizer Styles */
                .autods-claimed {
                    position: relative;
                }
                
                .autods-claimed::before {
                    content: '‚úì CLAIMED';
                    position: absolute;
                    top: 8px;
                    right: 8px;
                    background: linear-gradient(135deg, rgba(166, 227, 161, 0.9), rgba(148, 226, 213, 0.9));
                    color: #1e1e2e;
                    padding: 4px 12px;
                    border-radius: 12px;
                    font-size: 10px;
                    font-weight: 700;
                    letter-spacing: 0.5px;
                    z-index: 10;
                    box-shadow: 0 2px 8px rgba(166, 227, 161, 0.4);
                    text-transform: uppercase;
                }
                
                .autods-claimed {
                    opacity: 0.7 !important;
                    transition: opacity 0.3s ease, transform 0.3s ease;
                }
                
                .autods-claimed:hover {
                    opacity: 1 !important;
                    transform: translateY(-2px);
                }
                
                /* Add separator before claimed section */
                .grid .autods-claimed:first-of-type {
                    margin-top: 32px;
                    padding-top: 32px;
                    border-top: 2px dashed rgba(137, 180, 250, 0.3);
                }
                
                /* Add label before first claimed item */
                .grid .autods-claimed:first-of-type::after {
                    content: 'Claimed Collections';
                    position: absolute;
                    top: -28px;
                    left: 0;
                    font-size: 14px;
                    font-weight: 600;
                    color: rgba(166, 227, 161, 0.9);
                    text-transform: uppercase;
                    letter-spacing: 1px;
                }
            `;
            
            document.head.appendChild(style);
            context.logger.debug('[CollectionsOrganizer] Styles injected');
        },
        
        cleanup() {
            if (this.observer) {
                this.observer.disconnect();
            }
            
            // Remove custom styles
            const styleEl = document.getElementById('autods-collections-styles');
            if (styleEl) {
                styleEl.remove();
            }
            
            // Remove custom classes
            document.querySelectorAll('.autods-claimed').forEach(el => {
                el.classList.remove('autods-claimed');
                el.style.opacity = '';
                el.style.order = '';
            });
        }
    };

    const imageBlockModule = {
        id: 'imageBlocker',
        match: () => true,
        init(context) {
            context.logger.debug('imageBlocker module initialised');
            if (context.config.get().imageBlocker.enabled) {
                this.enable(context);
            }
            // Remove background pattern from wave pages
            this.removeWaveBackground(context);
            // Hide gate-info divs on all pages
            this.hideGateInfo(context);
        },
        activate(context) {
            const enabled = context.config.get().imageBlocker.enabled;
            if (!enabled) {
                this.disable(context);
                return;
            }
            if (!this.shouldBlockCurrentPath(context)) {
                this.disable(context);
                context.logger.debug('Image blocking bypassed on guild route.');
                return;
            }
            this.enable(context);
            // Remove background pattern from wave pages
            this.removeWaveBackground(context);
            // Hide gate-info divs on all pages
            this.hideGateInfo(context);
        },
        enable(context) {
            if (this.styleEl) return;
            if (!this.shouldBlockCurrentPath(context)) return;
            context.logger.info('Enabling image blocking');
            const style = document.createElement('style');
            style.id = 'autods-image-blocker';
            style.textContent = 'img { display: none !important; }';
            (document.head || document.documentElement).appendChild(style);
            this.styleEl = style;
        },
        disable(context) {
            if (!this.styleEl) return;
            context.logger.info('Disabling image blocking');
            this.styleEl.remove();
            this.styleEl = null;
        },
        removeWaveBackground(context) {
            const pathname = context.location?.pathname || window.location?.pathname || '';
            
            // Only apply to active_wave.php
            // if (!/active_wave\.php/i.test(pathname)) return;
            
            // Check if style already exists
            if (document.getElementById('autods-wave-bg-remover')) return;
            
            context.logger.info('Removing wave page background pattern');
            
            const style = document.createElement('style');
            style.id = 'autods-wave-bg-remover';
            style.textContent = `
                body {
                    background-image: none !important;
                    background-color: rgb(28, 29, 33) !important;
                }
            `;
            (document.head || document.documentElement).appendChild(style);
        },
        hideGateInfo(context) {
            // Check if style already exists
            if (document.getElementById('autods-gate-info-hider')) return;
            
            context.logger.info('Hiding gate-info divs');
            
            const style = document.createElement('style');
            style.id = 'autods-gate-info-hider';
            style.textContent = `
                div.gate-info {
                    display: none !important;
                }
            `;
            (document.head || document.documentElement).appendChild(style);
        },
        shouldBlockCurrentPath(context) {
            const pathname = context.location?.pathname || window.location?.pathname || '';
            // Bloquear imagens em todas as p√°ginas exceto guild e dungeon_info
            if (/^\/guild/i.test(pathname)) return false;
            if (/dungeon_info\.php/i.test(pathname)) return false;
            return true;
        }
    };

    const dungeonLootHelperModule = {
        id: 'dungeonLootHelper',
        match: ({ location }) => {
            const path = location.pathname;
            return /guild_dungeon_location\.php/i.test(path);
        },
        init(context) {
            this.state = {
                injected: false
            };
            context.logger.debug('dungeonLootHelper module initialised');
        },
        activate(context) {
            if (this.state.injected) return;

            context.logger.info('üéÅ Adicionando bot√µes de loot r√°pido nas dungeon locations...');

            // Add custom styles for loot buttons
            this.injectStyles();

            // Wait for monsters to load
            setTimeout(() => {
                this.injectLootButtons(context);
                this.state.injected = true;
                
                // Add "Loot All" button after individual buttons are injected
                setTimeout(() => {
                    addGuildDungeonLootAllButton();
                }, 500);
            }, 500);
        },
        injectStyles() {
            if (document.getElementById('autods-loot-btn-styles')) return;

            const style = document.createElement('style');
            style.id = 'autods-loot-btn-styles';
            style.textContent = `
                .autods-loot-btn {
                    background: linear-gradient(135deg, #10b981, #059669) !important;
                    border: 2px solid #34d399 !important;
                    color: white !important;
                    padding: 6px 12px !important;
                    font-weight: 600 !important;
                    transition: all 0.2s ease !important;
                    cursor: pointer !important;
                    box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3) !important;
                }
                .autods-loot-btn:hover:not(:disabled) {
                    background: linear-gradient(135deg, #059669, #047857) !important;
                    border-color: #10b981 !important;
                    transform: translateY(-2px) !important;
                    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.5) !important;
                }
                .autods-loot-btn:active:not(:disabled) {
                    transform: translateY(0) !important;
                    box-shadow: 0 1px 4px rgba(16, 185, 129, 0.3) !important;
                }
                .autods-loot-btn:disabled {
                    opacity: 0.6 !important;
                    cursor: not-allowed !important;
                }
            `;
            document.head.appendChild(style);
        },
        injectLootButtons(context) {
            // Find all monster cards with "not looted" status
            const monsterCards = document.querySelectorAll('.mon.dead');

            let injectedCount = 0;

            monsterCards.forEach(card => {
                // Check if has "not looted" pill
                const notLootedPill = Array.from(card.querySelectorAll('.pill')).find(pill =>
                    /not looted/i.test(pill.textContent)
                );

                if (!notLootedPill) return; // Skip if already looted or not eligible

                // Find the View button (support both dungeon_battle.php and battle.php with dgmid)
                const viewButton = card.querySelector('a.btn[href*="battle.php"][href*="dgmid"], a.btn[href*="dungeon_battle.php"]');
                if (!viewButton) return;

                // Extract dgmid and instance_id from View button href
                const href = viewButton.getAttribute('href');
                const dgmidMatch = href.match(/dgmid=(\d+)/);
                const instanceMatch = href.match(/instance_id=(\d+)/);

                if (!dgmidMatch || !instanceMatch) return;

                const dgmid = dgmidMatch[1];
                const instanceId = instanceMatch[1];

                // Check if loot button already exists
                if (card.querySelector('.autods-loot-btn')) return;

                // Extract monster name from card
                const monsterNameEl = card.querySelector('strong, .h, [style*="font-weight:700"]');
                const monsterName = monsterNameEl?.textContent?.trim() || `Monster ${dgmid}`;
                
                // Create loot button
                const lootBtn = document.createElement('button');
                lootBtn.className = 'btn autods-loot-btn';
                lootBtn.style.marginLeft = '8px';
                lootBtn.innerHTML = 'üéÅ Loot';
                lootBtn.dataset.dgmid = dgmid;
                lootBtn.dataset.instanceId = instanceId;
                lootBtn.dataset.monsterName = monsterName;

                // Add click handler
                lootBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    await this.handleLootClick(context, lootBtn, dgmid, instanceId, monsterName, notLootedPill);
                });

                // Insert button next to View button
                viewButton.parentElement.appendChild(lootBtn);
                injectedCount++;
            });

            if (injectedCount > 0) {
                context.logger.info(`‚úÖ ${injectedCount} bot√µes de loot adicionados`);
            } else {
                context.logger.debug('Nenhum monstro eleg√≠vel para loot encontrado');
            }
        },
        async handleLootClick(context, button, dgmid, instanceId, monsterName, notLootedPill) {
            const originalText = button.innerHTML;
            const originalDisabled = button.disabled;

            try {
                button.disabled = true;
                button.innerHTML = '‚è≥ Lootando...';

                context.logger.debug(`Claiming loot for monster ${dgmid} (${monsterName})`);

                // Use unified loot service
                const result = await context.loot.lootDungeonMonster(dgmid, instanceId, context.userSession.getUserId(), monsterName);

                if (!result.success) {
                    const msg = result.message || 'Failed to loot';
                    this.showNotification(msg, 'error');
                    
                    if (/cloudflare/i.test(msg)) {
                        context.notifications.error('‚ùå Bloqueio Cloudflare: O loot autom√°tico foi bloqueado. Por favor, fa√ßa o loot manualmente.', 10000);
                        context.notifications.error('‚ùå Bloqueio Cloudflare: Fa√ßa o loot manualmente clicando no bot√£o "Loot" do monstro.', 10000);
                    }
                    
                    button.disabled = originalDisabled;
                    button.innerHTML = originalText;
                    return;
                }

                // Success!
                this.showNotification(`Loot claimed! +${result.exp} XP, +${result.gold} Gold`, 'success');
                context.logger.info(`‚úÖ Loot claimed for ${monsterName}: +${result.exp} XP, +${result.gold} Gold, ${result.items.length} items`);

                // Update UI: change pill from "not looted" to "looted"
                notLootedPill.className = 'pill';
                notLootedPill.textContent = 'looted';
                notLootedPill.removeAttribute('title');

                // Remove the loot button
                button.remove();

                // Show custom loot popup with rewards
                this.showLootPopup({
                    status: 'success',
                    message: result.message,
                    rewards: {
                        exp: result.exp,
                        gold: result.gold,
                        damage_dealt: result.damage || 0
                    },
                    items: result.items
                });
            } catch (error) {
                context.logger.error('Error claiming loot', error);
                this.showNotification(error?.message || 'Server error', 'error');
                button.disabled = originalDisabled;
                button.innerHTML = originalText;
            }
        },
        showLootPopup(data) {
            const rewards = data.rewards || {};
            const exp = rewards.exp || 0;
            const gold = rewards.gold || 0;
            const items = Array.isArray(data.items) ? data.items : [];

            // Create popup container
            const popup = document.createElement('div');
            popup.className = 'autods-loot-popup';
            popup.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0.8);
                background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                border: 2px solid #10b981;
                border-radius: 16px;
                padding: 24px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 40px rgba(16, 185, 129, 0.3);
                z-index: 999999;
                min-width: 320px;
                max-width: 500px;
                opacity: 0;
                animation: lootPopupIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            `;

            // Build popup content
            let html = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 48px; margin-bottom: 8px;">üéÅ</div>
                    <h3 style="margin: 0; color: #10b981; font-size: 20px; font-weight: 700;">Loot Collected!</h3>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 20px;">
                    <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 12px; text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 4px;">‚≠ê</div>
                        <div style="font-size: 18px; font-weight: 700; color: #60a5fa;">${context.numbers.format(exp)}</div>
                        <div style="font-size: 11px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">EXP</div>
                    </div>
                    <div style="background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px; padding: 12px; text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 4px;">üí∞</div>
                        <div style="font-size: 18px; font-weight: 700; color: #fbbf24;">${context.numbers.format(gold)}</div>
                        <div style="font-size: 11px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px;">Gold</div>
                    </div>
                </div>
            `;

            if (items.length > 0) {
                html += `
                    <div style="margin-top: 16px;">
                        <div style="font-size: 12px; font-weight: 600; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.8px; margin-bottom: 12px; text-align: center;">
                            üì¶ Items (${items.length})
                        </div>
                        <div style="display: grid; gap: 8px; max-height: 200px; overflow-y: auto;">
                `;

                items.forEach(item => {
                    const itemName = item.NAME || 'Unknown Item';
                    const tier = item.TIER ? String(item.TIER).toLowerCase() : 'common';
                    const tierColors = {
                        legendary: '#f59e0b',
                        epic: '#a855f7',
                        rare: '#3b82f6',
                        uncommon: '#10b981',
                        common: '#6b7280'
                    };
                    const tierColor = tierColors[tier] || tierColors.common;

                    html += `
                        <div style="background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-left: 3px solid ${tierColor}; border-radius: 6px; padding: 8px 12px; display: flex; align-items: center; gap: 10px;">
                            <div style="font-size: 20px;">üìú</div>
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-size: 13px; font-weight: 600; color: #e2e8f0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${this.escapeHtml(itemName)}</div>
                                ${item.TIER ? `<div style="font-size: 10px; color: ${tierColor}; text-transform: uppercase; font-weight: 600; letter-spacing: 0.5px;">${this.escapeHtml(item.TIER)}</div>` : ''}
                            </div>
                            ${item.DROP_RATIO != null ? `<div style="font-size: 10px; color: #94a3b8; white-space: nowrap;">${item.DROP_RATIO}%</div>` : ''}
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            } else {
                html += `
                    <div style="text-align: center; padding: 16px; color: #64748b; font-size: 13px;">
                        No items dropped this time
                    </div>
                `;
            }

            html += `
                <div style="margin-top: 20px; text-align: center;">
                    <button class="autods-loot-popup-close" style="
                        background: linear-gradient(135deg, #10b981, #059669);
                        border: none;
                        color: white;
                        padding: 10px 24px;
                        border-radius: 8px;
                        font-weight: 600;
                        cursor: pointer;
                        font-size: 13px;
                        transition: all 0.2s ease;
                        box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
                    ">
                        ‚ú® Awesome!
                    </button>
                </div>
            `;

            popup.innerHTML = html;

            // Add animation styles
            if (!document.getElementById('autods-loot-popup-styles')) {
                const style = document.createElement('style');
                style.id = 'autods-loot-popup-styles';
                style.textContent = `
                    @keyframes lootPopupIn {
                        to {
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1);
                        }
                    }
                    @keyframes lootPopupOut {
                        to {
                            opacity: 0;
                            transform: translate(-50%, -50%) scale(0.8);
                        }
                    }
                    .autods-loot-popup-close:hover {
                        background: linear-gradient(135deg, #059669, #047857) !important;
                        transform: translateY(-2px);
                        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.5) !important;
                    }
                    .autods-loot-popup-close:active {
                        transform: translateY(0);
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(popup);

            // Close button handler
            const closeBtn = popup.querySelector('.autods-loot-popup-close');
            const closePopup = () => {
                popup.style.animation = 'lootPopupOut 0.2s ease-out forwards';
                setTimeout(() => popup.remove(), 200);
            };

            closeBtn.addEventListener('click', closePopup);

            // Auto-close after 5 seconds if no items, 8 seconds if has items
            const autoCloseDelay = items.length > 0 ? 8000 : 5000;
            setTimeout(closePopup, autoCloseDelay);

            // Close on Escape key
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closePopup();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        },
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },
        showNotification(message, type = 'info') {
            // Try to use page's showNotification if available
            if (typeof window.showNotification === 'function') {
                window.showNotification(message, type);
            } else {
                // Fallback to console
                console.log(`[Dungeon Loot] ${type.toUpperCase()}: ${message}`);
            }
        },
        formatNumber(value) {
            try {
                return new Intl.NumberFormat().format(Number(value) || 0);
            } catch {
                return value;
            }
        }
    };

    const floatingHelpersModule = {
        id: 'floatingHelpers',
        match: () => true,
        init(context) {
            this.state = {
                container: null,
                expPotionTimer: null,
                expPotionEndTime: null,
                inventoryData: null,
                damageCalculatorVisible: false
            };
            this.POTION_STORAGE_KEY = 'autods_exp_potion_timer';
        },
        activate(context) {
            const cfg = context.config.get();
            console.log('[FloatingHelpers] Activate called. Config:', cfg.floatingHelpers);

            if (!cfg.floatingHelpers || !cfg.floatingHelpers.enabled) {
                console.log('[FloatingHelpers] Module disabled in config');
                return;
            }

            console.log('[FloatingHelpers] Creating container...');
            this.createFloatingContainer(context, cfg);
            this.restoreExpPotionTimer(context);
            
            // Register event listeners for Ultra Fast stats
            context.events.on('autods:ultraFastAttack:complete', (data) => {
                console.log('[FloatingHelpers] Ultra Fast Attack complete event received:', data);
                if (data.stats) {
                    this.updateUltraFastStats(context, { ...data.stats, endTime: Date.now() }, 'attack');
                }
            });

            context.events.on('autods:ultraFastLoot:complete', (data) => {
                console.log('[FloatingHelpers] Ultra Fast Loot complete event received:', data);
                if (data.stats) {
                    this.updateUltraFastStats(context, data.stats, 'loot');
                }
            });
            
            // üÜï Listen for config changes to update loot button appearance
            context.events.on('config:change', () => {
                const newCfg = context.config.get();
                if (newCfg.floatingHelpers?.enabled && this.state.container) {
                    // Recreate loot box if Ultra Fast Loot toggle changed
                    this.recreateLootBox(context);
                    
                    // üÜï Recreate farm box if Ultra Fast Farm toggle changed
                    this.recreateFarmBox(context);
                }
            });
            
            // üÜï Listen for autods:config:updated to handle panel config changes
            context.events.on('autods:config:updated', () => {
                const newCfg = context.config.get();
                if (newCfg.floatingHelpers?.enabled && this.state.container) {
                    // Recreate farm box when enabled/disabled from panel
                    this.recreateFarmBox(context);
                }
            });
            
            console.log('[FloatingHelpers] Activation complete');
        },
        createFloatingContainer(context, cfg) {
            console.log('[FloatingHelpers] createFloatingContainer called');
            const existing = document.getElementById('autods-floating-helpers');
            if (existing) {
                console.log('[FloatingHelpers] Removing existing container');
                existing.remove();
            }

            const container = document.createElement('div');
            container.id = 'autods-floating-helpers';
            container.setAttribute('data-position', cfg.floatingHelpers.position);
            container.setAttribute('data-minimized', '0'); // Estado inicial: expandido

            // Base inline styles (position handled by CSS based on data-position)
            container.style.cssText = `
                top: ${cfg.floatingHelpers.topOffset};
            `;

            console.log('[FloatingHelpers] Container created with position:', cfg.floatingHelpers.position);

            // Adicionar bot√£o de toggle minimizar/maximizar (mobile only)
            const toggleBtn = document.createElement('button');
            toggleBtn.id = 'autods-floating-helpers-toggle';
            toggleBtn.textContent = '‚ñ≤ Minimizar';
            toggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isMinimized = container.getAttribute('data-minimized') === '1';
                container.setAttribute('data-minimized', isMinimized ? '0' : '1');
                toggleBtn.textContent = isMinimized ? '‚ñ≤ Minimizar' : '‚ñº Expandir';
                console.log('[FloatingHelpers] Toggle:', isMinimized ? 'Expandido' : 'Minimizado');
            });
            container.appendChild(toggleBtn);

            // Adicionar bot√£o de loot r√°pido
            if (cfg.floatingHelpers.loot.enabled && cfg.floatingHelpers.loot.showFloating) {
                console.log('[FloatingHelpers] Adding loot box');
                container.appendChild(this.createLootBox(context, cfg));
            }

            // Adicionar bot√£o de Ultra Fast Stamina (sempre vis√≠vel)
            console.log('[FloatingHelpers] Adding stamina box (always visible)');
            container.appendChild(this.createStaminaBox(context, cfg));

            // Adicionar bot√£o de Ultra Fast Attack
            if (cfg.ultraFastAttack?.enabled) {
                console.log('[FloatingHelpers] Adding attack box');
                container.appendChild(this.createFarmBox(context, cfg));
            }

            // Adicionar 4 bot√µes principais de abas (Farm, Dungeon, PvP, Boss)
            console.log('[FloatingHelpers] Adding main tab buttons');
            container.appendChild(this.createMainTabButtons(context, cfg));

            console.log('[FloatingHelpers] Appending container to body. Children:', container.children.length);
            document.body.appendChild(container);
            this.state.container = container;

            console.log('[FloatingHelpers] Container appended. Element in DOM:', !!document.getElementById('autods-floating-helpers'));

            // Handle window resize para mostrar/esconder toggle
            const handleResize = () => {
                if (window.innerWidth <= 480) {
                    toggleBtn.style.display = 'block';
                } else {
                    toggleBtn.style.display = 'none';
                    // Em desktop, sempre expandir
                    container.setAttribute('data-minimized', '0');
                }
            };
            window.addEventListener('resize', handleResize);

            // Integrar bot√£o nativo de battle drawer (üß™)
            this.integrateBattleDrawerButton(context);

            // Adicionar bot√£o de Damage Calculator (ap√≥s items)
            console.log('[FloatingHelpers] Adding damage calculator button');
            this.state.container.appendChild(this.createDamageCalculatorButton(context, cfg));

            // Ocultar popup nativo se configurado
            if (cfg.floatingHelpers.hideNativePopup) {
                this.hideNativeBattleConsumables(context);
            }

            // Removido: updateAllPotionCounts (fetch bloqueado pelo site)
        },
        createPotionBox(context, type, label, cfg) {
            const box = document.createElement('div');
            box.className = `potion-box potion-${type}`;
            box.style.cssText = `
                background: rgba(30, 30, 46, 0.95);
                border: 2px solid rgba(137, 180, 250, 0.5);
                border-radius: 8px;
                padding: 8px;
                min-width: 60px;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
            `;

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: 24px; line-height: 1;';
            icon.textContent = type === 'small' ? 'üß™' : '‚öóÔ∏è';

            const count = document.createElement('div');
            count.className = `potion-count-${type}`;
            count.style.cssText = 'font-size: 11px; color: #a6e3a1; font-weight: bold;';
            count.textContent = '0';

            box.appendChild(icon);
            box.appendChild(count);

            // Full Stamina e Small Stamina agora abrem o BattleDrawer
            const openDrawerBtn = document.createElement('button');
            openDrawerBtn.textContent = type === 'full' ? 'Use' : 'Open';
            openDrawerBtn.style.cssText = `
                background: #89b4fa;
                color: #1e1e2e;
                border: none;
                padding: 3px 8px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
                font-weight: bold;
                margin-top: 2px;
            `;
            openDrawerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.openBattleDrawer(context);
            });
            box.appendChild(openDrawerBtn);

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'translateX(-4px)';
                box.style.boxShadow = '0 4px 12px rgba(137, 180, 250, 0.4)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'translateX(0)';
                box.style.boxShadow = 'none';
            });

            return box;
        },
        createExpPotionBox(context, cfg) {
            const box = document.createElement('div');
            box.className = 'potion-box potion-exp';
            box.style.cssText = `
                background: rgba(30, 30, 46, 0.95);
                border: 2px solid rgba(249, 226, 175, 0.5);
                border-radius: 8px;
                padding: 8px;
                min-width: 60px;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
            `;

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: 24px; line-height: 1;';
            icon.textContent = '‚ú®';

            const count = document.createElement('div');
            count.className = 'potion-count-exp';
            count.style.cssText = 'font-size: 11px; color: #f9e2af; font-weight: bold;';
            count.textContent = '0';

            const timerDisplay = document.createElement('div');
            timerDisplay.className = 'exp-potion-timer';
            timerDisplay.style.cssText = 'font-size: 10px; color: #f9e2af; display: none;';
            timerDisplay.textContent = '00:00';

            const useBtn = document.createElement('button');
            useBtn.textContent = 'Use';
            useBtn.style.cssText = `
                background: #f9e2af;
                color: #1e1e2e;
                border: none;
                padding: 3px 8px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
                font-weight: bold;
                margin-top: 2px;
            `;
            useBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.useExpPotion(context);
            });

            box.appendChild(icon);
            box.appendChild(count);
            box.appendChild(timerDisplay);
            box.appendChild(useBtn);

            return box;
        },
        createLootBox(context, cfg) {
            const box = document.createElement('div');
            box.className = 'loot-box autods-floating-loot-btn';  // üÜï Adicionada classe para sele√ß√£o
            
            // Verificar se Ultra Fast Loot est√° ativo
            const ultraFastEnabled = context.config.get().ultraFastLoot?.enabled;
            
            box.style.cssText = `
                background: ${ultraFastEnabled ? 'linear-gradient(135deg, #fab387 0%, #f38ba8 100%)' : 'rgba(50, 50, 70, 0.8)'};
                border: 2px solid ${ultraFastEnabled ? '#fab387' : 'rgba(100, 100, 100, 0.5)'};
                border-radius: 6px;
                padding: 8px 12px;
                color: ${ultraFastEnabled ? '#000' : '#aaa'};
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                min-height: 36px;
                position: relative;
            `;

            // Badge de Ultra Fast (se ativo)
            if (ultraFastEnabled) {
                const badge = document.createElement('div');
                badge.style.cssText = `
                    position: absolute;
                    top: -4px;
                    right: -4px;
                    background: linear-gradient(135deg, #fab387 0%, #f38ba8 100%);
                    color: #1e1e2e;
                    font-size: 10px;
                    font-weight: bold;
                    padding: 2px 4px;
                    border-radius: 4px;
                    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                    z-index: 1;
                `;
                badge.textContent = '‚ö°';
                badge.title = 'Ultra Fast Loot Ativo';
                box.appendChild(badge);
            }

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: clamp(18px, 5vw, 24px); line-height: 1;';
            icon.textContent = 'üí∞';
            icon.className = 'loot-icon';  // üÜï Classe para o √≠cone

            const label = document.createElement('div');
            label.style.cssText = `font-size: clamp(10px, 2vw, 12px); color: inherit; font-weight: bold;`;
            label.textContent = ultraFastEnabled ? 'Fast' : 'Loot';
            label.className = 'loot-label';  // üÜï Classe para o label

            box.appendChild(icon);
            box.appendChild(label);

            box.addEventListener('click', () => {
                this.performQuickLoot(context);
            });

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = ultraFastEnabled 
                    ? '0 4px 12px rgba(250, 179, 135, 0.4)' 
                    : '0 4px 12px rgba(137, 180, 250, 0.3)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
            });

            return box;
        },

        createStaminaBox(context, cfg) {
            const box = document.createElement('div');
            box.className = 'stamina-box autods-floating-stamina-btn';
            
            const ultraFastEnabled = context.config.get().ultraFastStamina?.enabled;
            
            box.style.cssText = `
                background: ${ultraFastEnabled ? 'linear-gradient(135deg, #89dceb 0%, #74c7ec 100%)' : 'rgba(50, 50, 70, 0.8)'};
                border: 2px solid ${ultraFastEnabled ? '#89dceb' : 'rgba(100, 100, 100, 0.5)'};
                border-radius: 6px;
                padding: 8px 12px;
                color: ${ultraFastEnabled ? '#000' : '#aaa'};
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                min-height: 36px;
                position: relative;
            `;

            // Badge de Ultra Fast
            const badge = document.createElement('div');
            badge.style.cssText = `
                position: absolute;
                top: -4px;
                right: -4px;
                background: linear-gradient(135deg, #89dceb 0%, #74c7ec 100%);
                color: #1e1e2e;
                font-size: 10px;
                font-weight: bold;
                padding: 2px 4px;
                border-radius: 4px;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                z-index: 1;
            `;
            badge.textContent = '‚ö°';
            badge.title = 'Ultra Fast Stamina';
            box.appendChild(badge);

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: clamp(18px, 5vw, 24px); line-height: 1;';
            icon.textContent = '‚ö°';
            icon.className = 'stamina-icon';

            const label = document.createElement('div');
            label.style.cssText = 'font-size: clamp(10px, 2vw, 12px); color: inherit; font-weight: bold;';
            label.textContent = 'Stamina';
            label.className = 'stamina-label';

            box.appendChild(icon);
            box.appendChild(label);

            box.addEventListener('click', async () => {
                context.logger.info('‚ö° Iniciando Ultra Fast Stamina...');
                
                // Get module
                const ultraStaminaModule = context.moduleRegistry?.getModule('ultraFastStamina');
                if (!ultraStaminaModule) {
                    context.logger.error('Ultra Fast Stamina module n√£o encontrado');
                    context.notifications.error('Ultra Fast Stamina module n√£o encontrado!');
                    return;
                }

                // Run
                try {
                    await ultraStaminaModule.runStaminaFarm(context);
                } catch (error) {
                    context.logger.error('Erro ao executar Ultra Fast Stamina:', error);
                    context.notifications.error('Erro ao executar Ultra Fast Stamina!');
                }
            });

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = ultraFastEnabled 
                    ? '0 4px 12px rgba(137, 220, 235, 0.4)' 
                    : '0 4px 12px rgba(137, 180, 250, 0.3)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
            });

            return box;
        },

        createFarmBox(context, cfg) {
            const box = document.createElement('div');
            box.className = 'farm-box autods-floating-farm-btn';
            
            const ultraFastEnabled = context.config.get().ultraFastAttack?.enabled;
            
            box.style.cssText = `
                background: ${ultraFastEnabled ? 'linear-gradient(135deg, #89b4fa 0%, #a6e3a1 100%)' : 'rgba(50, 50, 70, 0.8)'};
                border: 2px solid ${ultraFastEnabled ? '#89b4fa' : 'rgba(100, 100, 100, 0.5)'};
                border-radius: 6px;
                padding: 8px 12px;
                color: ${ultraFastEnabled ? '#000' : '#aaa'};
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                min-height: 36px;
                position: relative;
            `;

            // Badge de Ultra Fast (se ativo)
            if (ultraFastEnabled) {
                const badge = document.createElement('div');
                badge.style.cssText = `
                    position: absolute;
                    top: -4px;
                    right: -4px;
                    background: linear-gradient(135deg, #89b4fa 0%, #74c7ec 100%);
                    color: #1e1e2e;
                    font-size: 10px;
                    font-weight: bold;
                    padding: 2px 4px;
                    border-radius: 4px;
                    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                    z-index: 1;
                `;
                badge.textContent = '‚ö°';
                badge.title = 'Ultra Fast Farm Ativo';
                box.appendChild(badge);
            }

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: clamp(18px, 5vw, 24px); line-height: 1;';
            icon.textContent = '‚öîÔ∏è';
            icon.className = 'farm-icon';

            const label = document.createElement('div');
            label.style.cssText = `font-size: clamp(10px, 2vw, 12px); color: inherit; font-weight: bold;`;
            label.textContent = 'Attack';
            label.className = 'farm-label';

            box.appendChild(icon);
            box.appendChild(label);

            box.addEventListener('click', () => {
                const pathname = window.location?.pathname || '';
                // Apenas executar em active_wave.php
                if (!/active_wave\.php/i.test(pathname)) {
                    context.logger.warn('[FloatingHelpers] Farm box s√≥ funciona em active_wave.php');
                    context.notifications.warn('Farm: acesse uma p√°gina de wave!');
                    return;
                }
                
                // Executar ultraFastAttackModule para um batch √∫nico de opera√ß√µes
                context.logger.info('[FloatingHelpers] üöÄ Iniciando Ultra Fast Attack (batch √∫nico)...');
                
                // Ativar ultraFastAttack config se necess√°rio
                const cfg = context.config.get();
                if (!cfg.ultraFastAttack?.enabled) {
                    context.config.update({
                        ultraFastAttack: { enabled: true }
                    });
                }
                
                // Chamar triggerManualRun do ultraFastAttackModule
                const ultraFastAttackModule = context.moduleRegistry?.getModule('ultraFastAttack');
                if (ultraFastAttackModule && typeof ultraFastAttackModule.triggerManualRun === 'function') {
                    context.logger.info('[FloatingHelpers] ‚úÖ Disparando ultraFastAttackModule.triggerManualRun()');
                    ultraFastAttackModule.triggerManualRun(context);
                } else {
                    context.logger.error('[FloatingHelpers] ‚ùå Ultra Fast Farm module n√£o encontrado ou n√£o tem triggerManualRun!');
                    context.notifications.error('Farm box: m√≥dulo n√£o encontrado!');
                }
            });

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = ultraFastEnabled 
                    ? '0 4px 12px rgba(137, 180, 250, 0.4)' 
                    : '0 4px 12px rgba(137, 180, 250, 0.3)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
            });

            return box;
        },
        
        recreateLootBox(context) {
            const cfg = context.config.get();
            
            // Find existing loot box using context.dom
            const existingLootBox = context.dom.query('.autods-floating-loot-btn', this.state.container);
            if (!existingLootBox) return;
            
            // Create new loot box with updated appearance
            const newLootBox = this.createLootBox(context, cfg);
            
            // Replace in DOM
            existingLootBox.replaceWith(newLootBox);
            
            console.log('[FloatingHelpers] Loot box recreated with Ultra Fast status update');
        },

        createDamageCalculatorButton(context, cfg) {
            const box = document.createElement('div');
            box.className = 'damage-calculator-box';
            
            const calcVisible = this.state.damageCalculatorVisible || false;
            
            box.style.cssText = `
                background: ${calcVisible ? 'linear-gradient(135deg, #cba6f7 0%, #89b4fa 100%)' : 'rgba(50, 50, 70, 0.8)'};
                border: 2px solid ${calcVisible ? '#cba6f7' : 'rgba(100, 100, 100, 0.5)'};
                border-radius: 6px;
                padding: 8px 12px;
                color: ${calcVisible ? '#000' : '#aaa'};
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                min-height: 36px;
                position: relative;
            `;

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: clamp(16px, 5vw, 16px); line-height: 1;';
            icon.textContent = 'üßÆ';

            const label = document.createElement('div');
            label.style.cssText = 'font-size: clamp(10px, 2vw, 12px); color: inherit; font-weight: bold;';
            label.textContent = 'Calc';

            box.appendChild(icon);
            box.appendChild(label);

            box.addEventListener('click', () => {
                this.toggleDamageCalculator(context);
            });

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = calcVisible 
                    ? '0 4px 12px rgba(203, 166, 247, 0.4)' 
                    : '0 4px 12px rgba(137, 180, 250, 0.3)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
            });

            return box;
        },

        createMainTabButtons(context, cfg) {
            const container = document.createElement('div');
            container.id = 'autods-main-tab-buttons';
            container.style.cssText = `
                display: flex;
                flex-direction: column;
                gap: 6px;
                margin-top: 8px;
                padding-top: 8px;
                border-top: 1px solid rgba(100, 100, 100, 0.3);
                width: 100%;
            `;

            // 4 bot√µes principais: Farm, Dungeon, PvP, Boss
            const buttons = [
                { id: 'dungeon', label: 'Dungeon', emoji: 'üè∞', config: 'ultraFastDungeon.enabled' },
                { id: 'farm', label: 'Farm', emoji: '‚öîÔ∏è', config: 'wave.enabled' },
                { id: 'pvp', label: 'PvP', emoji: 'üèÜ', config: 'pvp.enabled' },
                { id: 'boss', label: 'Boss', emoji: 'üëë', config: 'specialBossFarm.enabled' }
            ];

            buttons.forEach(btn => {
                const button = document.createElement('button');
                button.id = `autods-main-btn-${btn.id}`;
                button.dataset.action = `toggle-${btn.id}`;
                button.title = `Toggle ${btn.label} mode`;
                
                // Get current state
                const cfg = context.config.get();
                const parts = btn.config.split('.');
                let enabled = cfg;
                for (const part of parts) {
                    enabled = enabled?.[part];
                }

                button.style.cssText = `
                    background: ${enabled ? 'linear-gradient(135deg, #89b4fa 0%, #a6e3a1 100%)' : 'rgba(50, 50, 70, 0.8)'};
                    border: 2px solid ${enabled ? '#89b4fa' : 'rgba(100, 100, 100, 0.5)'};
                    border-radius: 6px;
                    padding: 8px 12px;
                    color: ${enabled ? '#000' : '#aaa'};
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.2s;
                    font-size: clamp(11px, 2vw, 12px);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 4px;
                    min-height: 36px;
                    width: 100%;
                `;

                button.innerHTML = `<span style="font-size: 16px;">${btn.emoji}</span> ${btn.label}${btn.id === 'dungeon' ? ' ‚ö°' : ''}`;

                button.addEventListener('click', async () => {
                    // Comportamento especial para Dungeon: executa em vez de toggle
                    if (btn.id === 'dungeon') {
                        context.logger.info('üè∞ Executando Ultra Fast Dungeon...');
                        const dungeonModule = context.moduleRegistry?.getModule('ultraFastDungeon');
                        if (!dungeonModule) {
                            context.logger.error('Ultra Fast Dungeon module n√£o encontrado');
                            context.notifications.error('Dungeon: m√≥dulo n√£o encontrado!');
                            return;
                        }
                        try {
                            if (typeof dungeonModule.triggerManualRun === 'function') {
                                await dungeonModule.triggerManualRun(context);
                            } else {
                                context.logger.error('Dungeon: m√©todo triggerManualRun n√£o existe');
                                context.notifications.error('Dungeon n√£o est√° configurado corretamente!');
                            }
                        } catch (error) {
                            context.logger.error('Erro ao executar Dungeon:', error);
                            context.notifications.error('Erro ao executar Dungeon!');
                        }
                        return;
                    }
                    
                    // Comportamento especial para Farm: toggle ativa/desativa
                    if (btn.id === 'farm') {
                        const pathname = window.location?.pathname || '';
                        // Apenas executar em active_wave.php
                        if (!/active_wave\.php/i.test(pathname)) {
                            context.logger.warn('[FloatingHelpers] Farm s√≥ funciona em active_wave.php');
                            context.notifications.warn('Farm: acesse uma p√°gina de wave!');
                            return;
                        }
                        
                        const cfg = context.config.get();
                        const waveEnabled = cfg.wave?.enabled || false;
                        const newValue = !waveEnabled;  // Toggle
                        
                        if (newValue) {
                            // ATIVAR Farm
                            context.logger.info('[FloatingHelpers] üöÄ Iniciando Ultra Fast Farm (loop cont√≠nuo)...');
                            
                            // Atualizar config: ativar core, wave.enabled
                            context.config.update({
                                core: { enabled: true },
                                wave: {
                                    enabled: true
                                }
                            });
                            
                            // Reset e ativar o m√≥dulo
                            setTimeout(() => {
                                const ultraFastWaveModule = context.moduleRegistry?.getModule('ultraFastWave');
                                if (ultraFastWaveModule) {
                                    // Reset state
                                    if (ultraFastWaveModule.state) {
                                        ultraFastWaveModule.state.running = false;
                                    }
                                    
                                    // Activate
                                    if (typeof ultraFastWaveModule.activate === 'function') {
                                        ultraFastWaveModule.activate(context);
                                        context.logger.info('[FloatingHelpers] ‚úÖ Ultra Fast Farm iniciado!');
                                    }
                                }
                            }, 20);
                        } else {
                            // DESATIVAR Farm
                            context.logger.info('[FloatingHelpers] ‚èπÔ∏è Parando Ultra Fast Farm...');
                            context.config.update({
                                wave: {
                                    enabled: false
                                }
                            });
                            context.logger.info('[FloatingHelpers] ‚úÖ Ultra Fast Farm parado!');
                        }
                        
                        // Update button appearance
                        button.style.background = newValue ? 'linear-gradient(135deg, #89b4fa 0%, #a6e3a1 100%)' : 'rgba(50, 50, 70, 0.8)';
                        button.style.borderColor = newValue ? '#89b4fa' : 'rgba(100, 100, 100, 0.5)';
                        button.style.color = newValue ? '#000' : '#aaa';
                        
                        return;
                    }
                    
                    // Comportamento padr√£o para PvP, Boss: toggle flag
                    const cfg = context.config.get();
                    const parts = btn.config.split('.');
                    let obj = cfg;
                    for (let i = 0; i < parts.length - 1; i++) {
                        obj = obj[parts[i]];
                    }
                    const lastPart = parts[parts.length - 1];
                    const newValue = !obj[lastPart];

                    // Update config
                    const patch = createPatchFromPath(btn.config, newValue);
                    context.config.update(patch);

                    // Update button appearance
                    button.style.background = newValue ? 'linear-gradient(135deg, #89b4fa 0%, #a6e3a1 100%)' : 'rgba(50, 50, 70, 0.8)';
                    button.style.borderColor = newValue ? '#89b4fa' : 'rgba(100, 100, 100, 0.5)';
                    button.style.color = newValue ? '#000' : '#aaa';

                    context.logger.info(`[FloatingHelpers] ${btn.label} mode ${newValue ? 'enabled' : 'disabled'}`);
                });

                button.addEventListener('mouseenter', () => {
                    button.style.transform = 'scale(1.05)';
                    button.style.boxShadow = '0 4px 12px rgba(137, 180, 250, 0.3)';
                });
                button.addEventListener('mouseleave', () => {
                    button.style.transform = 'scale(1)';
                    button.style.boxShadow = 'none';
                });

                container.appendChild(button);
            });

            return container;
        },

        toggleDamageCalculator(context) {
            this.state.damageCalculatorVisible = !this.state.damageCalculatorVisible;
            
            const damageCalcModule = context.moduleRegistry?.getModule('damageCalculator');
            if (!damageCalcModule) {
                context.logger.warn('[FloatingHelpers] Damage Calculator module not found');
                return;
            }

            if (this.state.damageCalculatorVisible) {
                damageCalcModule.show(context);
            } else {
                damageCalcModule.hide(context);
            }
        },

        recreateFarmBox(context) {
            const cfg = context.config.get();
            
            // Se Attack n√£o est√° habilitado, remover o bot√£o
            if (!cfg.ultraFastAttack?.enabled) {
                const existingFarmBox = this.state.container?.querySelector('.autods-floating-farm-btn');
                if (existingFarmBox) {
                    existingFarmBox.remove();
                    console.log('[FloatingHelpers] Attack box removed (disabled)');
                }
                return;
            }
            
            // Se Attack est√° habilitado mas bot√£o n√£o existe, criar
            const existingFarmBox = this.state.container?.querySelector('.autods-floating-farm-btn');
            if (!existingFarmBox) {
                // Inserir ap√≥s o bot√£o de stamina (se existir) ou ao final
                const staminaBox = this.state.container?.querySelector('.autods-floating-stamina-btn');
                const newFarmBox = this.createFarmBox(context, cfg);
                
                if (staminaBox) {
                    staminaBox.insertAdjacentElement('afterend', newFarmBox);
                } else {
                    this.state.container?.appendChild(newFarmBox);
                }
                
                console.log('[FloatingHelpers] Farm box created (enabled)');
                return;
            }
            
            // Se j√° existe, apenas atualizar apar√™ncia
            const newFarmBox = this.createFarmBox(context, cfg);
            existingFarmBox.replaceWith(newFarmBox);
            
            console.log('[FloatingHelpers] Farm box recreated with Ultra Fast status update');
        },
        
        integrateBattleDrawerButton(context) {
            // Procurar o bot√£o nativo de battle drawer
            const nativeButton = document.getElementById('openBattleDrawerBtn');
            if (!nativeButton) {
                context.logger.debug('[FloatingHelpers] Bot√£o nativo #openBattleDrawerBtn n√£o encontrado');
                return;
            }

            // Esconder o bot√£o da sua posi√ß√£o original
            nativeButton.style.display = 'none';

            // Criar uma c√≥pia estilizada para o floating helpers
            const box = document.createElement('div');
            box.className = 'battle-drawer-box';
            box.style.cssText = `
                background: linear-gradient(135deg, #f9e2af 0%, #fab387 100%);
                border: 2px solid #f9e2af;
                border-radius: 6px;
                padding: 8px 12px;
                color: #000;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                font-size: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                min-height: 36px;
            `;

            const icon = document.createElement('div');
            icon.style.cssText = 'font-size: clamp(16px, 5vw, 16px); line-height: 1;';
            icon.textContent = 'üß™';

            const label = document.createElement('div');
            label.style.cssText = 'font-size: clamp(10px, 2vw, 12px); color: inherit; font-weight: bold;';
            label.textContent = 'Items';

            box.appendChild(icon);
            box.appendChild(label);

            // Ao clicar no box, clicar no bot√£o nativo
            box.addEventListener('click', () => {
                nativeButton.click();
                const closeAction = document.querySelector('[data-action="close-panel"]');
                if (closeAction) {
                    closeAction.click();
                } else {
                    context.logger.debug('[FloatingHelpers] Fechar painel n√£o encontrado ap√≥s abrir drawer');
                }
            });

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'scale(1.05)';
                box.style.boxShadow = '0 4px 12px rgba(249, 226, 175, 0.4)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'scale(1)';
                box.style.boxShadow = 'none';
            });

            // Adicionar o box ao container
            const container = this.state.container;
            if (container) {
                container.appendChild(box);
                context.logger.debug('[FloatingHelpers] Bot√£o de Battle Drawer integrado');
            }
        },
        openBattleDrawer(context) {
            // Abrir o Battle Drawer nativo da p√°gina adicionando a classe 'drawer-open' ao body
            context.logger.info('[FloatingHelpers] Abrindo Battle Drawer');

            const body = context.document.body;
            if (body) {
                body.classList.add('drawer-open');

                // Verificar se o drawer existe
                const drawer = context.document.getElementById('battleDrawer');
                if (drawer) {
                    context.logger.debug('[FloatingHelpers] Battle Drawer aberto com sucesso');
                } else {
                    context.logger.warn('[FloatingHelpers] Battle Drawer (#battleDrawer) n√£o encontrado na p√°gina');

                    // Tentar usar o bot√£o nativo como fallback
                    const openBtn = context.document.getElementById('openBattleDrawerBtn');
                    if (openBtn) {
                        context.logger.debug('[FloatingHelpers] Clicando no bot√£o nativo de abrir drawer');
                        openBtn.click();
                    }
                }
            }
        },
        createUltraFastStatsBox(context) {
            const box = document.createElement('div');
            box.className = 'ultra-fast-stats-box';
            box.id = 'autods-ultra-stats';
            box.style.cssText = `
                background: rgba(30, 30, 46, 0.95);
                border: 2px solid rgba(203, 166, 247, 0.5);
                border-radius: 8px;
                padding: 10px;
                min-width: 120px;
                cursor: pointer;
                transition: all 0.2s;
                display: none;
                flex-direction: column;
                gap: 6px;
            `;

            const header = document.createElement('div');
            header.style.cssText = 'display: flex; align-items: center; gap: 6px; font-size: 12px; color: #cba6f7; font-weight: bold;';
            
            const icon = document.createElement('span');
            icon.textContent = '‚ö°';
            icon.style.cssText = 'font-size: 18px;';
            
            const title = document.createElement('span');
            title.textContent = 'Ultra Fast';
            
            header.appendChild(icon);
            header.appendChild(title);

            const statsContainer = document.createElement('div');
            statsContainer.className = 'ultra-stats-content';
            statsContainer.style.cssText = 'font-size: 10px; color: #cdd6f4; line-height: 1.4;';

            const closeBtn = document.createElement('button');
            closeBtn.textContent = '‚úï';
            closeBtn.style.cssText = `
                background: rgba(203, 166, 247, 0.2);
                color: #cba6f7;
                border: none;
                padding: 2px 6px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
                margin-top: 4px;
                align-self: flex-end;
            `;
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                box.style.display = 'none';
            });

            box.appendChild(header);
            box.appendChild(statsContainer);
            box.appendChild(closeBtn);

            box.addEventListener('mouseenter', () => {
                box.style.transform = 'translateX(-4px)';
                box.style.boxShadow = '0 4px 12px rgba(203, 166, 247, 0.4)';
            });
            box.addEventListener('mouseleave', () => {
                box.style.transform = 'translateX(0)';
                box.style.boxShadow = 'none';
            });

            return box;
        },
        updateUltraFastStats(context, stats, type) {
            console.log('[FloatingHelpers] updateUltraFastStats called:', { type, stats });
            
            let box = document.getElementById('autods-ultra-stats');
            
            if (!box) {
                const container = this.state.container;
                if (!container) {
                    console.warn('[FloatingHelpers] Container not found for stats box');
                    return;
                }
                
                console.log('[FloatingHelpers] Creating new stats box');
                box = this.createUltraFastStatsBox(context);
                container.appendChild(box);
            }

            const statsContent = box.querySelector('.ultra-stats-content');
            if (!statsContent) {
                console.warn('[FloatingHelpers] Stats content not found');
                return;
            }

            let html = '';
            
            if (type === 'farm') {
                const duration = stats.duration ? (stats.duration / 1000).toFixed(1) : 
                               (stats.endTime ? ((stats.endTime - stats.startTime) / 1000).toFixed(1) : 0);
                html = `
                    <div style="margin-bottom: 4px; color: #a6e3a1; font-weight: bold;">üåæ Farm Complete!</div>
                    <div>‚è±Ô∏è ${duration}s</div>
                    <div>üì¶ ${stats.totalBatches || 0} lotes</div>
                    <div>üëπ ${stats.totalMonsters || 0} mobs</div>
                    <div style="color: #a6e3a1;">‚úÖ ${stats.successfulJoins || 0} entradas</div>
                    ${(stats.failedJoins || 0) > 0 ? `<div style="color: #f38ba8;">‚ùå ${stats.failedJoins} falhas</div>` : ''}
                    <div>‚öîÔ∏è ${stats.totalAttacks || 0} ataques</div>
                `;
            } else if (type === 'loot') {
                // üÜï Usar dados do summary se dispon√≠vel
                const summary = stats.summary;
                const exp = summary ? summary.exp : (stats.totalExp || 0);
                const gold = summary ? summary.gold : (stats.totalGold || 0);
                const itemCount = summary ? summary.items.size : (stats.items?.length || 0);
                
                html = `
                    <div style="margin-bottom: 4px; color: #f9e2af; font-weight: bold;">üí∞ Loot Complete!</div>
                    <div>üì¶ ${stats.attempted || 0} mobs</div>
                    <div style="color: #a6e3a1;">‚úÖ ${stats.successful || 0} loots</div>
                    ${(stats.failed || 0) > 0 ? `<div style="color: #f38ba8;">‚ùå ${stats.failed} falhas</div>` : ''}
                    <div>‚ú® ${formatNumber(exp)} EXP</div>
                    <div>üí∞ ${formatNumber(gold)} Gold</div>
                    ${itemCount > 0 ? `<div>üéÅ ${itemCount} ${summary ? 'tipos' : 'itens'}</div>` : ''}
                `;
            }

            console.log('[FloatingHelpers] Setting stats HTML:', html);
            statsContent.innerHTML = html;
            box.style.display = 'flex';
            
            console.log('[FloatingHelpers] Stats box visibility:', box.style.display, 'in DOM:', document.body.contains(box));

            // Auto-hide ap√≥s 30 segundos
            setTimeout(() => {
                if (box && box.style.display !== 'none') {
                    box.style.display = 'none';
                }
            }, 30000);
        },
        hideNativeBattleConsumables(context) {
            // Procurar o popup nativo de Battle Consumables
            const nativePopup = context.document.querySelector('[data-battle-consumables], .battle-consumables-popup, #battleConsumables');
            
            if (nativePopup) {
                nativePopup.style.display = 'none';
                context.logger.debug('[FloatingHelpers] Popup nativo de Battle Consumables ocultado');
            } else {
                // Tentar encontrar pelo conte√∫do (complementary role com "Battle Consumables")
                const complementaries = context.document.querySelectorAll('complementary, [role="complementary"]');
                for (const elem of complementaries) {
                    const heading = elem.querySelector('generic, div, h1, h2, h3, h4, h5, h6');
                    if (heading && heading.textContent.includes('Battle Consumables')) {
                        elem.style.display = 'none';
                        context.logger.debug('[FloatingHelpers] Popup nativo encontrado e ocultado via texto');
                        break;
                    }
                }
            }
        },
        // REMOVIDO: usePotions() - fetch bloqueado pelo site (HTTP 403)
        // REMOVIDO: useExpPotion() - fetch bloqueado pelo site (HTTP 403)
        // REMOVIDO: fetchInventoryData() - fetch bloqueado pelo site (HTTP 403)
        // REMOVIDO: updateAllPotionCounts() - fetch bloqueado pelo site (HTTP 403)
        // REMOVIDO: startExpPotionTimer() - depende de fun√ß√µes removidas
        // REMOVIDO: updateExpPotionTimer() - depende de fun√ß√µes removidas
        // REMOVIDO: stopExpPotionTimer() - depende de fun√ß√µes removidas
        // REMOVIDO: restoreExpPotionTimer() - depende de fun√ß√µes removidas
        async useExpPotion(context) {
            // Verificar se temos dados do invent√°rio
            if (!this.state.inventoryData || !this.state.inventoryData.exp) {
                context.logger.warn('Dados do invent√°rio n√£o dispon√≠veis. Atualizando...');
                await this.updateAllPotionCounts(context);
            }

            const itemData = this.state.inventoryData.exp;
            if (!itemData || !itemData.invId) {
                context.logger.error('Exp Potion S n√£o encontrada no invent√°rio');
                context.notifications.error('Exp Potion S not found in inventory');
                return;
            }

            if (itemData.quantity < 1) {
                context.logger.warn('Exp Potion S indispon√≠vel');
                context.notifications.error('No Exp Potions available');
                return;
            }

            try {
                context.logger.info('Usando EXP Potion...');

                // Preparar dados para envio (igual ao jogo)
                const params = new URLSearchParams();
                params.set('inv_id', itemData.invId.toString());

                // Usar HTTP service com Cloudflare bypass
                const result = await context.http.usePotionDirect(itemData.invId.toString(), window.location.href);

                if (!result.success) {
                    throw new Error(`Falha na requisi√ß√£o: ${result.message || 'Unknown error'}`);
                }
                const lower = result.message.trim().toLowerCase();

                if (lower.includes('success')) {
                    context.logger.info('‚úÖ EXP Potion usado com sucesso!');

                    // Notificar sucesso
                    context.notifications.success('Used Exp Potion S!');

                    // Iniciar timer de 1 hora
                    this.startExpPotionTimer(context);

                    // Atualizar contador local (sem fetch)
                    const newQuantity = itemData.quantity - 1;
                    this.state.inventoryData.exp.quantity = newQuantity;

                    const countElement = document.querySelector('.potion-count-exp');
                    if (countElement) {
                        countElement.textContent = newQuantity.toString();
                    }

                    // Emitir evento
                    context.events.emit('autods:potion:use', {
                        type: 'exp',
                        name: 'EXP Potion',
                        remaining: newQuantity,
                        timestamp: Date.now()
                    });

                    // Recarregar p√°gina para sincronizar (igual ao jogo)
                    setTimeout(() => {
                        location.href = location.href;
                    }, 500);
                } else {
                    throw new Error(responseText.slice(0, 200) || 'Failed to use item.');
                }
            } catch (error) {
                context.logger.error(`Erro ao usar EXP Potion: ${error.message}`);
                context.notifications.error(error.message || 'Server error.');
            }
        },
        startExpPotionTimer(context) {
            this.state.expPotionEndTime = Date.now() + (60 * 60 * 1000); // 1 hora
            context.storage.set(this.POTION_STORAGE_KEY, this.state.expPotionEndTime.toString());

            if (this.state.expPotionTimer) {
                clearInterval(this.state.expPotionTimer);
            }

            this.state.expPotionTimer = setInterval(() => {
                this.updateExpPotionTimer(context);
            }, 1000);

            this.updateExpPotionTimer(context);
        },
        updateExpPotionTimer(context) {
            if (!this.state.expPotionEndTime) return;

            const remaining = this.state.expPotionEndTime - Date.now();
            if (remaining <= 0) {
                this.stopExpPotionTimer(context);
                return;
            }

            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            const timerElement = document.querySelector('.exp-potion-timer');
            if (timerElement) {
                timerElement.textContent = display;
                timerElement.style.display = 'block';
            }
        },
        stopExpPotionTimer(context) {
            if (this.state.expPotionTimer) {
                clearInterval(this.state.expPotionTimer);
                this.state.expPotionTimer = null;
            }
            this.state.expPotionEndTime = null;
            context.storage.remove(this.POTION_STORAGE_KEY);

            const timerElement = document.querySelector('.exp-potion-timer');
            if (timerElement) {
                timerElement.style.display = 'none';
            }
        },
        restoreExpPotionTimer(context) {
            const stored = context.storage.get(this.POTION_STORAGE_KEY);
            if (!stored) return;

            const endTime = parseInt(stored, 10);
            if (endTime > Date.now()) {
                this.state.expPotionEndTime = endTime;
                this.state.expPotionTimer = setInterval(() => {
                    this.updateExpPotionTimer(context);
                }, 1000);
                this.updateExpPotionTimer(context);
            } else {
                context.storage.remove(this.POTION_STORAGE_KEY);
            }
        },
        // REMOVED: fetchInventoryData() - use context.inventory.fetchInventoryData() instead
        async updateAllPotionCounts(context) {
            console.log('[FloatingHelpers] Updating potion counts...');
            const inventory = await context.inventory.fetchInventoryData();

            console.log('[FloatingHelpers] Inventory data:', inventory);

            // Armazenar inv_ids no estado para uso posterior
            if (!this.state.inventoryData) {
                this.state.inventoryData = {};
            }
            this.state.inventoryData = inventory;

            // Atualizar elementos do DOM
            ['small', 'full', 'exp'].forEach(type => {
                const element = document.querySelector(`.potion-count-${type}`);
                if (element) {
                    element.textContent = inventory[type].quantity.toString();
                    console.log(`[FloatingHelpers] Updated ${type} count to ${inventory[type].quantity}`);
                }
            });
        },
        getPlayerExpInfo() {
            // Tentar encontrar a barra de XP na p√°gina
            // Formato esperado: "175,842 / 810,100" ou similar
            const expSelectors = [
                '.gtb-exp-top span:last-child',      // Top toolbar
                '.side-exp-top span:last-child',     // Sidebar
                '[class*="exp"] span:contains("/")', // Gen√©rico
                '.exp-text',
                '#exp_text'
            ];

            for (const selector of expSelectors) {
                const expElement = document.querySelector(selector);
                if (!expElement) continue;

                const expText = expElement.textContent.trim();
                const match = expText.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                
                if (match) {
                    const currentExp = numberFromText(match[1]);
                    const maxExp = numberFromText(match[2]);
                    
                    if (currentExp !== null && maxExp !== null && maxExp > 0) {
                        const percent = (currentExp / maxExp) * 100;
                        return {
                            currentExp,
                            maxExp,
                            percent
                        };
                    }
                }
            }

            // Se n√£o encontrou pela estrutura, tentar via regex no body
            const bodyText = document.body?.textContent || '';
            const expMatch = bodyText.match(/EXP[:\s]*([\d,]+)\s*\/\s*([\d,]+)/i);
            
            if (expMatch) {
                const currentExp = context.numbers.parse(expMatch[1]);
                const maxExp = context.numbers.parse(expMatch[2]);
                
                if (currentExp !== null && maxExp !== null && maxExp > 0) {
                    const percent = (currentExp / maxExp) * 100;
                    return {
                        currentExp,
                        maxExp,
                        percent
                    };
                }
            }

            return null;
        },
        async performQuickLoot(context) {
            context.logger.info('Executando loot r√°pido...');

            // Verificar se estamos em p√°gina de dungeon/wave ou guild dungeon
            const isWavePage = window.location.pathname.includes('active_wave.php') ||
                              window.location.pathname.includes('wave.php');
            const isGuildDungeon = window.location.pathname.includes('guild_dungeon_location.php');

            if (!isWavePage && !isGuildDungeon) {
                context.logger.warn('Loot r√°pido dispon√≠vel apenas em p√°ginas de dungeon');
                return;
            }

            const cfg = context.config.get();
            
            // üÜï VERIFICAR SE ULTRA FAST LOOT EST√Å ATIVO
            const ultraFastEnabled = cfg.ultraFastLoot?.enabled;
            
            if (ultraFastEnabled) {
                context.logger.info('‚ö° Ultra Fast Loot est√° ativo! Usando modo paralelo...');
                
                // Obter refer√™ncia ao m√≥dulo ultraFastLoot usando o m√©todo getModule
                const ultraFastLootModule = context.moduleRegistry?.getModule('ultraFastLoot');
                
                if (ultraFastLootModule && typeof ultraFastLootModule.runLoot === 'function') {
                    // Executar Ultra Fast Loot
                    await ultraFastLootModule.runLoot(context);
                    return; // Sair - Ultra Fast Loot j√° cuidou de tudo
                } else {
                    context.logger.warn('‚ö†Ô∏è Ultra Fast Loot module n√£o encontrado, usando loot tradicional...');
                }
            }
            
            // FALLBACK: Loot tradicional (c√≥digo original)
            let userId = cfg.core?.userId;

            if (!userId) {
                context.logger.warn('User ID n√£o configurado. Tentando detectar...');
                context.userSession.ensureUserId(context);
                userId = context.config.get().core?.userId;
            }

            if (!userId) {
                context.logger.error('‚ùå User ID n√£o detectado. Fa√ßa login e tente novamente.');
                context.notifications.error('User ID not found. Please login.');
                return;
            }

            // üÜï Verificar XP do jogador antes de iniciar loot
            const playerExpInfo = this.getPlayerExpInfo();
            if (playerExpInfo) {
                const expToLevelUp = playerExpInfo.maxExp - playerExpInfo.currentExp;
                context.logger.info(`üìä XP atual: ${formatNumber(playerExpInfo.currentExp)} / ${formatNumber(playerExpInfo.maxExp)} (${playerExpInfo.percent.toFixed(1)}%)`);
                context.logger.info(`üìä Falta ${formatNumber(expToLevelUp)} XP para subir de n√≠vel`);
            }

            // Para guild dungeons, buscar bot√µes espec√≠ficos
            if (isGuildDungeon) {
                const guildLootButtons = Array.from(document.querySelectorAll('.autods-loot-btn'));

                if (guildLootButtons.length === 0) {
                    context.logger.info('Nenhum monstro eleg√≠vel para loot no guild dungeon');
                    return;
                }

                // üÜï Feedback visual inicial
                context.logger.info(`üéÅ Feedback: Iniciando loot de ${guildLootButtons.length} monstros...`);
                
                // Usar toast do sistema
                if (context.ui?.showToast) {
                    context.ui.showToast(context, 'info', 'Loot All', `Iniciando loot de ${guildLootButtons.length} monstros...`);
                } else {
                    context.notifications.info(`üéÅ Iniciando loot de ${guildLootButtons.length} monstros...`);
                }
                
                // Atualizar bot√£o do floating helper se existir
                const lootHelperBtn = document.querySelector('.autods-floating-loot-btn');
                const lootIcon = lootHelperBtn?.querySelector('.loot-icon');
                const lootLabel = lootHelperBtn?.querySelector('.loot-label');
                
                context.logger.debug(`[LootAll] Bot√£o encontrado: ${!!lootHelperBtn}, Icon: ${!!lootIcon}, Label: ${!!lootLabel}`);
                
                if (lootHelperBtn && lootIcon && lootLabel) {
                    lootIcon.textContent = '‚è≥';
                    lootLabel.textContent = `0/${guildLootButtons.length}`;
                    lootHelperBtn.disabled = true;
                    lootHelperBtn.style.opacity = '0.6';
                    lootHelperBtn.style.cursor = 'wait';
                    
                    // Guardar refer√™ncias para restaura√ß√£o
                    this.state.lootAllButton = lootHelperBtn;
                    this.state.lootAllIcon = lootIcon;
                    this.state.lootAllLabel = lootLabel;
                }

                // Use unified loot service
                const targets = [];
                
                for (const button of guildLootButtons) {
                    const dgmid = button.getAttribute('data-dgmid');
                    const instanceId = button.getAttribute('data-instance-id') || button.dataset.instanceId;
                    
                    if (!dgmid || !instanceId) continue;
                    
                    const card = button.closest?.('.mon, .monster-card, .card, .monster-row, .list-group-item') || null;
                    const storedName = button.getAttribute('data-monster-name') || button.dataset?.monsterName;
                    const monsterName = this.extractMonsterName(card, storedName || `Mob ${dgmid}`);
                    
                    targets.push({
                        type: 'dungeon',
                        dgmid: dgmid,
                        instanceId: instanceId,
                        name: monsterName
                    });
                }
                
                const summary = await context.loot.lootMultiple(targets, userId, {
                    batchSize: 1, // One at a time for UI feedback
                    checkLevelUp: true,
                    checkStamina: false
                });

                try {
                    context.logger.info(`‚úÖ Loot de guild dungeon conclu√≠do: ${summary.drops}/${guildLootButtons.length} loots bem-sucedidos`);
                    
                    // Show which monsters were looted
                    const monsterNames = Array.from(summary.monsters.values()).map(m => m.name).join(' | ');
                    context.logger.info(`‚úÖ [Dungeon] Mobs: ${monsterNames}`);
                    
                    const failed = guildLootButtons.length - summary.drops;
                    // Mostrar notifica√ß√£o de erro se todas as tentativas falharam
                    if (failed > 0 && summary.drops === 0) {
                        const errorMsg = `‚ùå Falha no Loot de Dungeon: Todas as ${failed} tentativas foram bloqueadas pelo Cloudflare. Use o bot√£o individual de loot em cada monstro.`;
                        context.notifications.error(errorMsg);
                        showErrorNotification(errorMsg, 10000, context.logger);
                        context.logger.error(errorMsg);
                    } else if (failed > 0) {
                        const warningMsg = `‚ö†Ô∏è Loot de Dungeon parcialmente conclu√≠do: ${summary.drops} sucessos, ${failed} bloqueados pelo Cloudflare.`;
                        context.notifications.warn(warningMsg);
                        context.logger.warn(warningMsg);
                    }

                    context.events.emit('autods:loot:quick', {
                        method: 'guild_dungeon',
                        total: guildLootButtons.length,
                        success: summary.drops,
                        failed: failed,
                        timestamp: Date.now()
                    });
                } catch (error) {
                    context.logger.error(`Erro no loot r√°pido de guild dungeon: ${error.message}`);
                } finally {
                    // üÜï Restaurar bot√£o do floating helper
                    if (this.state.lootAllButton) {
                        this.state.lootAllButton.textContent = this.state.lootAllOriginalText || 'üí∞ Loot All';
                        this.state.lootAllButton.disabled = false;
                        this.state.lootAllButton.style.opacity = '1';
                        delete this.state.lootAllButton;
                        delete this.state.lootAllOriginalText;
                    }
                    
                    if (summary.drops > 0) {
                        context.loot.showDetailedModal(summary, 'Dungeon Quick Loot');
                    }
                }

                return;
            }

            // Para wave pages: buscar monstros eleg√≠veis para loot
            const monsterCards = Array.from(document.querySelectorAll('.monster-card'));
            const eligibleMonsters = [];

            for (const card of monsterCards) {
                // Buscar link/bot√£o de loot
                const lootLink = card.querySelector('a[href*="battle.php"][href*="id="]');
                if (!lootLink) continue;

                const lootButton = card.querySelector('button, a');
                const buttonText = lootButton?.textContent || '';

                // Verificar se o bot√£o √© "Loot" (n√£o "Join" ou "Continue")
                if (!/loot/i.test(buttonText)) continue;

                // Extrair monster ID
                const monsterIdMatch = lootLink.href.match(/[?&]id=(\d+)/);
                if (!monsterIdMatch) continue;

                const monsterId = monsterIdMatch[1];
                const monsterName = this.extractMonsterName(card, lootButton?.getAttribute('data-monster-name') || lootButton?.dataset?.monsterName || `Mob ${monsterId}`);
                eligibleMonsters.push({ monsterId, card, button: lootButton, monsterName });
            }

            if (eligibleMonsters.length === 0) {
                context.logger.info('Nenhum monstro eleg√≠vel para loot na wave');
                return;
            }

            // üÜï Feedback visual inicial para wave
            context.notifications.info(`üéÅ Iniciando loot de ${eligibleMonsters.length} monstros...`);
            
            // Atualizar bot√£o do floating helper se existir
            const lootHelperBtn = document.querySelector('.autods-floating-loot-btn');
            const lootIcon = lootHelperBtn?.querySelector('.loot-icon');
            const lootLabel = lootHelperBtn?.querySelector('.loot-label');
            
            if (lootHelperBtn && lootIcon && lootLabel) {
                lootIcon.textContent = '‚è≥';
                lootLabel.textContent = `0/${eligibleMonsters.length}`;
                lootHelperBtn.disabled = true;
                lootHelperBtn.style.opacity = '0.6';
                lootHelperBtn.style.cursor = 'wait';
                
                // Armazenar refer√™ncias para restaura√ß√£o
                this.state.lootAllIcon = lootIcon;
                this.state.lootAllLabel = lootLabel;
                this.state.lootAllButton = lootHelperBtn;
            }

            // Use unified loot service
            const targets = eligibleMonsters.map(m => ({
                monsterId: m.monsterId,
                type: 'wave',
                name: m.monsterName
            }));
            
            const summary = await context.loot.lootMultiple(targets, userId, {
                batchSize: 1, // One at a time for UI feedback
                checkLevelUp: true,
                checkStamina: false // Don't check stamina for quick loot
            });

            try {
                context.logger.info(`‚úÖ Loot de wave conclu√≠do: ${summary.drops}/${eligibleMonsters.length} loots bem-sucedidos`);
                
                // Show which monsters were looted
                const monsterNames = Array.from(summary.monsters.values()).map(m => m.name).join(' | ');
                context.logger.info(`‚úÖ [Wave] Mobs: ${monsterNames}`);
                
                const failed = eligibleMonsters.length - summary.drops;
                
                // Mostrar notifica√ß√£o de erro se todas as tentativas falharam
                if (failed > 0 && summary.drops === 0) {
                    const errorMsg = `‚ùå Falha no Loot: Todas as ${failed} tentativas foram bloqueadas pelo Cloudflare. Use o bot√£o individual de loot em cada monstro.`;
                    
                    context.notifications.error(errorMsg);
                    showErrorNotification(errorMsg, 10000, context.logger);
                    context.logger.error(errorMsg);
                } else if (failed > 0) {
                    const warningMsg = `‚ö†Ô∏è Loot parcialmente conclu√≠do: ${summary.drops} sucessos, ${failed} bloqueados pelo Cloudflare.`;
                    context.notifications.warn(warningMsg);
                    context.logger.warn(warningMsg);
                }

                context.events.emit('autods:loot:quick', {
                    method: 'wave',
                    total: eligibleMonsters.length,
                    success: summary.drops,
                    failed: failed,
                    timestamp: Date.now()
                });

                // Recarregar para atualizar status
            } catch (error) {
                context.logger.error(`Erro no loot r√°pido de wave: ${error.message}`);
            } finally {
                // üÜï Restaurar bot√£o do floating helper
                if (this.state.lootAllButton && this.state.lootAllIcon && this.state.lootAllLabel) {
                    this.state.lootAllIcon.textContent = 'üí∞';
                    this.state.lootAllLabel.textContent = 'Loot';
                    this.state.lootAllButton.disabled = false;
                    this.state.lootAllButton.style.opacity = '1';
                    this.state.lootAllButton.style.cursor = 'pointer';
                }
                
                // Limpar refer√™ncias
                this.state.lootAllIcon = null;
                this.state.lootAllLabel = null;
                this.state.lootAllButton = null;
                
                if (summary.drops > 0) {
                    context.loot.showDetailedModal(summary, 'Wave Quick Loot');
                }
            }
        },
        createLootSummary() {
            return {
                drops: 0,
                exp: 0,
                gold: 0,
                items: new Map(),
                monsters: new Map(),
                messages: []
            };
        },
        getFirstNonNull(obj, keys) {
            if (!obj || !keys || !keys.length) {
                return undefined;
            }

            for (const key of keys) {
                if (key == null) {
                    continue;
                }

                const variants = new Set([
                    key,
                    String(key).toLowerCase(),
                    String(key).toUpperCase(),
                    String(key).replace(/[_-](\w)/g, (_, c) => (c ? c.toUpperCase() : '')),
                    String(key).replace(/[_-](\w)/g, (_, c) => (c ? c.toUpperCase() : '')).replace(/^(.)/, (match) => match.toUpperCase()),
                    String(key).replace(/[_-](\w)/g, (_, c) => (c ? c.toUpperCase() : '')).replace(/^(.)/, (match) => match.toLowerCase())
                ]);

                for (const variant of variants) {
                    if (Object.prototype.hasOwnProperty.call(obj, variant) && obj[variant] != null) {
                        return obj[variant];
                    }
                }
            }

            return undefined;
        },
        createItemKey(name, rarity) {
            const base = String(name || '').trim().toLowerCase();
            const rarityKey = String(rarity || '').trim().toLowerCase();
            return rarityKey ? `${base}|${rarityKey}` : base;
        },
        createMonsterKey(name, id) {
            const base = String(name || '').trim().toLowerCase();
            const identifier = id ? String(id).trim().toLowerCase() : '';
            if (base) {
                return base;
            }
            return identifier || '';
        },
        normalizeRarity(item) {
            const raw = this.getFirstNonNull(item, ['rarity', 'rarityName', 'rarity_name', 'rarity-level', 'grade', 'quality', 'tier']);
            if (!raw) {
                return '';
            }
            return String(raw).trim();
        },
        normalizeDescription(item) {
            const raw = this.getFirstNonNull(item, ['description', 'desc', 'details', 'info', 'note', 'tooltip']);
            if (!raw) {
                return '';
            }
            return String(raw).trim();
        },
        getRarityStyling(rarity) {
            if (!rarity) {
                return {
                    background: 'rgba(148,163,184,0.18)',
                    border: 'rgba(148,163,184,0.35)',
                    color: '#e2e8f0'
                };
            }

            const value = String(rarity).trim().toLowerCase();
            switch (value) {
                case 'common':
                case 'comum':
                    return { background: 'rgba(148,163,184,0.18)', border: 'rgba(148,163,184,0.35)', color: '#e2e8f0' };
                case 'uncommon':
                case 'incomum':
                    return { background: 'rgba(74,222,128,0.18)', border: 'rgba(74,222,128,0.35)', color: '#bbf7d0' };
                case 'rare':
                case 'raro':
                    return { background: 'rgba(59,130,246,0.18)', border: 'rgba(59,130,246,0.35)', color: '#93c5fd' };
                case 'epic':
                case '√©pico':
                    return { background: 'rgba(168,85,247,0.18)', border: 'rgba(168,85,247,0.35)', color: '#d8b4fe' };
                case 'legendary':
                case 'lend√°rio':
                    return { background: 'rgba(249,115,22,0.18)', border: 'rgba(249,115,22,0.35)', color: '#fdba74' };
                case 'mythic':
                case 'mythical':
                case 'm√≠tico':
                    return { background: 'rgba(236,72,153,0.18)', border: 'rgba(236,72,153,0.35)', color: '#f9a8d4' };
                case 'unique':
                case 'exotic':
                case 'ex√≥tico':
                    return { background: 'rgba(14,165,233,0.2)', border: 'rgba(14,165,233,0.4)', color: '#7dd3fc' };
                default:
                    return { background: 'rgba(148,163,184,0.18)', border: 'rgba(148,163,184,0.35)', color: '#e2e8f0' };
            }
        },
        formatRatio(value) {
            if (!Number.isFinite(value) || value === 0) {
                return null;
            }

            const absolute = Math.abs(value);
            let fractionDigits = 2;

            if (absolute < 1) {
                fractionDigits = absolute < 0.01 ? 5 : 3;
            }

            const formatted = value.toFixed(fractionDigits);
            return formatted.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
        },
        extractMonsterName(card, fallbackName) {
            if (!card) {
                return fallbackName || '';
            }

            const direct = card.getAttribute?.('data-monster-name');
            if (direct && direct.trim()) {
                return direct.trim();
            }

            const selectors = [
                '[data-name]',
                '.monster-name',
                '.monster-title',
                '.monster-card-title',
                '.card-title',
                '.name',
                'h1',
                'h2',
                'h3',
                'h4',
                '.title'
            ];

            for (const selector of selectors) {
                const element = card.querySelector?.(selector);
                if (element && element.textContent) {
                    const text = element.textContent.trim();
                    if (text) {
                        return text.replace(/\s+/g, ' ');
                    }
                }
            }

            if (fallbackName) {
                return fallbackName;
            }

            return '';
        },
        escapeHtml(value) {
            return String(value ?? '').replace(/[&<>"']/g, (char) => {
                switch (char) {
                    case '&': return '&amp;';
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '"': return '&quot;';
                    case "'": return '&#39;';
                    default: return char;
                }
            });
        },
        sanitizeHtml(doc, html) {
            if (!html) {
                return null;
            }
            const wrapper = doc.createElement('span');
            wrapper.innerHTML = String(html);
            wrapper.querySelectorAll('script, style').forEach(el => el.remove());
            wrapper.querySelectorAll('*').forEach(el => {
                Array.from(el.attributes).forEach(attr => {
                    if (/^on/i.test(attr.name)) {
                        el.removeAttribute(attr.name);
                    }
                });
            });
            return wrapper;
        },
        /**
         * @deprecated LEGACY METHOD - Not used anymore. All loot operations now use context.loot service.
         * Kept for backward compatibility only.
         */
        recordLootResult(summary, result, metadata = {}) {
            if (!summary || !result) {
                return;
            }

            summary.drops += 1;

            const rewards = result.rewards || {};
            const expValue = Number(rewards.exp ?? rewards.xp ?? rewards.experience ?? 0);
            if (Number.isFinite(expValue) && expValue > 0) {
                summary.exp += expValue;
            }

            const goldValue = Number(rewards.gold ?? rewards.coins ?? rewards.money ?? 0);
            if (Number.isFinite(goldValue) && goldValue > 0) {
                summary.gold += goldValue;
            }

            const rawRewards = result.rawRewards || rewards || {};
            const perDamage = rawRewards?.per_damage ?? rawRewards?.perDamage ?? rawRewards?.perDamageStats ?? {};
            const expPerHp = Number(this.getFirstNonNull(perDamage, ['exp_per_hp', 'expPerHp', 'exp_per_HP', 'exp-per-hp']));
            const goldPerHp = Number(this.getFirstNonNull(perDamage, ['gold_per_hp', 'goldPerHp', 'gold_per_HP', 'gold-per-hp']));
            const damageDealt = Number(this.getFirstNonNull(rawRewards, ['damage_dealt', 'damageDealt', 'damage', 'total_damage', 'totalDamage']));

            const resolvedName = this.extractMonsterName(metadata.card, metadata.monsterName) || metadata.monsterName || (metadata.monsterId ? `Mob ${metadata.monsterId}` : 'Mob');
            const monsterKey = this.createMonsterKey(resolvedName, metadata.monsterId || resolvedName);
            let monsterEntry = summary.monsters.get(monsterKey);
            if (!monsterEntry) {
                monsterEntry = {
                    name: resolvedName,
                    id: metadata.monsterId ?? null,
                    scope: metadata.scope || null,
                    count: 0,
                    exp: 0,
                    gold: 0,
                    damage: 0,
                    expPerHp: null,
                    goldPerHp: null
                };
            }

            monsterEntry.count += 1;
            if (Number.isFinite(expValue) && expValue > 0) {
                monsterEntry.exp += expValue;
            }
            if (Number.isFinite(goldValue) && goldValue > 0) {
                monsterEntry.gold += goldValue;
            }
            if (Number.isFinite(damageDealt) && damageDealt > 0) {
                monsterEntry.damage += damageDealt;
            }
            if (Number.isFinite(expPerHp) && expPerHp > 0) {
                monsterEntry.expPerHp = expPerHp;
            }
            if (Number.isFinite(goldPerHp) && goldPerHp > 0) {
                monsterEntry.goldPerHp = goldPerHp;
            }

            summary.monsters.set(monsterKey, monsterEntry);

            if (Array.isArray(result.items)) {
                result.items.forEach(item => {
                    if (!item) {
                        return;
                    }

                    const rawName = this.getFirstNonNull(item, ['name', 'title', 'item_name', 'label', 'id']);
                    const baseName = (rawName ? String(rawName) : 'Item').trim() || 'Item';
                    const rarity = this.normalizeRarity(item);
                    const description = this.normalizeDescription(item);
                    const emojiRaw = this.getFirstNonNull(item, ['emoji', 'icon_emoji', 'symbol']);
                    const emoji = emojiRaw ? String(emojiRaw).trim() : '';
                    const displayName = emoji ? `${emoji} ${baseName}` : baseName;
                    const qtyValue = this.getFirstNonNull(item, ['quantity', 'qty', 'amount', 'count', 'stack']);
                    const qtyRaw = Number(qtyValue ?? 1);
                    const quantity = Number.isFinite(qtyRaw) && qtyRaw > 0 ? qtyRaw : 1;
                    const iconRaw = this.getFirstNonNull(item, ['icon', 'icon_url', 'iconUrl', 'image', 'image_url', 'imageUrl', 'img', 'IMAGE_URL', 'thumbnail']);
                    const icon = iconRaw ? String(iconRaw) : '';

                    const key = this.createItemKey(baseName, rarity);
                    const existing = summary.items.get(key);
                    if (existing) {
                        existing.quantity += quantity;
                        if (!existing.description && description) {
                            existing.description = description;
                        }
                        if (!existing.icon && icon) {
                            existing.icon = icon;
                        }
                    } else {
                        summary.items.set(key, {
                            name: baseName,
                            displayName,
                            rarity,
                            description,
                            icon,
                            quantity
                        });
                    }
                });
            }

            if (result.message) {
                const message = String(result.message).trim();
                if (message) {
                    summary.messages.push(message);
                }
            }

            if (result.note) {
                const note = String(result.note).trim();
                if (note) {
                    summary.messages.push(note);
                }
            }
        },
        formatLootItems(summary) {
            if (!summary || !summary.items || summary.items.size === 0) {
                return '';
            }

            const entries = [];
            summary.items.forEach(item => {
                if (!item) {
                    return;
                }

                        const raritySuffix = item.rarity ? ` - ${item.rarity}` : '';
                entries.push(`${formatNumber(item.quantity)}x ${item.displayName}${raritySuffix}`);
            });

            return entries.join(', ');
        },
        formatMonsterSummary(summary) {
            if (!summary || !summary.monsters || summary.monsters.size === 0) {
                return '';
            }

            const entries = [];
            summary.monsters.forEach(monster => {
                if (!monster) {
                    return;
                }

                const name = monster.name || monster.id || 'Mob';
                const parts = [];

                if (Number.isFinite(monster.exp) && monster.exp > 0) {
                    parts.push(`${formatNumber(monster.exp)} XP`);
                }

                if (Number.isFinite(monster.gold) && monster.gold > 0) {
                    parts.push(`${formatNumber(monster.gold)} Gold`);
                }

                const ratioParts = [];
                if (Number.isFinite(monster.expPerHp) && monster.expPerHp > 0) {
                    const expRatio = this.formatRatio(monster.expPerHp);
                    if (expRatio) {
                        ratioParts.push(`EXP/HP ${expRatio}`);
                    }
                }

                if (Number.isFinite(monster.goldPerHp) && monster.goldPerHp > 0) {
                    const goldRatio = this.formatRatio(monster.goldPerHp);
                    if (goldRatio) {
                        ratioParts.push(`Gold/HP ${goldRatio}`);
                    }
                }

                const ratioText = ratioParts.length ? ` (${ratioParts.join(' ‚Ä¢ ')})` : '';
                const metrics = parts.length ? parts.join(' ‚Ä¢ ') : null;
                entries.push(metrics ? `${name}: ${metrics}${ratioText}` : `${name}${ratioText}`);
            });

            return entries.length ? `Mobs: ${entries.join(' | ')}` : '';
        },
        /**
         * @deprecated LEGACY METHOD - Not used anymore. Use context.loot.showDetailedModal() instead.
         * Kept for backward compatibility only.
         */
        showLootSummary(context, summary, scopeLabel) {
            if (!summary || summary.drops === 0) {
                return;
            }

            const parts = [];

            if (summary.exp > 0) {
                parts.push(`${formatNumber(summary.exp)} EXP`);
            }

            if (summary.gold > 0) {
                parts.push(`${formatNumber(summary.gold)} Gold`);
            }

            const itemsText = this.formatLootItems(summary);
            if (itemsText) {
                parts.push(itemsText);
            }

            const monstersText = this.formatMonsterSummary(summary);
            if (monstersText) {
                parts.push(monstersText);
            }

            const fallbackMessage = summary.messages.length ? summary.messages[summary.messages.length - 1] : 'Loot conclu√≠do.';
            const message = parts.length ? parts.join(' ‚Ä¢ ') : fallbackMessage.replace(/<[^>]+>/g, '');
            const prefix = scopeLabel ? `[${scopeLabel}] ` : '';
            const fullMessage = `${prefix}${message}`;

            context.notifications.success(fullMessage);

            context.logger.info(`[QuickLoot] ${fullMessage}`);

            this.openQuickLootModal(context, summary, scopeLabel);
        },
        openQuickLootModal(context, summary, scopeLabel) {
            try {
                const doc = context.document || document;
                const host = doc.body;
                if (!host) {
                    return;
                }

                const existing = doc.getElementById('autods-quickloot-modal');
                if (existing) {
                    existing.remove();
                }

                const overlay = doc.createElement('div');
                overlay.id = 'autods-quickloot-modal';
                overlay.style.cssText = `
                    position: fixed;
                    inset: 0;
                    background: rgba(8, 15, 28, 0.65);
                    backdrop-filter: blur(4px);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 2147483646;
                    animation: autods-quickloot-fade-in 0.18s ease-out;
                `;

                const card = doc.createElement('div');
                card.style.cssText = `
                    background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
                    border: 1px solid rgba(148, 163, 184, 0.35);
                    border-radius: 16px;
                    padding: 20px;
                    min-width: 320px;
                    max-width: 520px;
                    width: min(520px, calc(100vw - 40px));
                    max-height: 82vh;
                    overflow-y: auto;
                    color: #e2e8f0;
                    box-shadow: 0 20px 60px rgba(8, 15, 28, 0.55);
                    display: flex;
                    flex-direction: column;
                    gap: 12px;
                    font-family: 'Segoe UI', system-ui, sans-serif;
                `;

                const title = doc.createElement('div');
                title.style.cssText = 'display:flex;justify-content:space-between;align-items:center;gap:12px;';
                const heading = doc.createElement('h3');
                heading.textContent = scopeLabel ? `${scopeLabel} Quick Loot` : 'Quick Loot';
                heading.style.cssText = 'margin:0;font-size:16px;font-weight:700;color:#93c5fd;';

                const closeBtn = doc.createElement('button');
                closeBtn.textContent = '√ó';
                closeBtn.title = 'Fechar resumo';
                closeBtn.style.cssText = `
                    background: rgba(148, 163, 184, 0.1);
                    border: 1px solid rgba(148, 163, 184, 0.4);
                    border-radius: 8px;
                    color: #e2e8f0;
                    width: 28px;
                    height: 28px;
                    font-size: 16px;
                    line-height: 1;
                    cursor: pointer;
                `;

                const totals = doc.createElement('div');
                totals.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;font-size:13px;';

                if (summary.exp > 0) {
                    const expChip = doc.createElement('span');
                    expChip.textContent = `${formatNumber(summary.exp)} EXP`;
                    expChip.style.cssText = 'padding:6px 10px;background:rgba(59,130,246,0.18);border:1px solid rgba(59,130,246,0.35);border-radius:10px;color:#93c5fd;font-weight:600;';
                    totals.appendChild(expChip);
                }

                const hasGold = summary.gold > 0;
                if (hasGold) {
                    const goldChip = doc.createElement('span');
                    goldChip.textContent = `${formatNumber(summary.gold)} Gold`;
                    goldChip.style.cssText = 'padding:6px 10px;background:rgba(250,204,21,0.18);border:1px solid rgba(250,204,21,0.35);border-radius:10px;color:#facc15;font-weight:600;';
                    totals.appendChild(goldChip);
                }

                if (summary.drops > 0) {
                    const countChip = doc.createElement('span');
                    countChip.textContent = `${summary.drops} loot${summary.drops === 1 ? '' : 's'}`;
                    countChip.style.cssText = 'padding:6px 10px;background:rgba(148,163,184,0.15);border:1px solid rgba(148,163,184,0.35);border-radius:10px;color:#cbd5f5;font-weight:600;';
                    totals.appendChild(countChip);
                }

                const closeModal = () => overlay.remove();
                closeBtn.addEventListener('click', closeModal);
                overlay.addEventListener('click', (event) => {
                    if (event.target === overlay) {
                        closeModal();
                    }
                });

                title.appendChild(heading);
                title.appendChild(closeBtn);
                card.appendChild(title);
                if (totals.childNodes.length) {
                    card.appendChild(totals);
                }

                if (summary.monsters && summary.monsters.size > 0) {
                    const monsterBlock = doc.createElement('div');
                    monsterBlock.style.cssText = 'font-size:13px;line-height:1.5;background:rgba(17,24,39,0.85);border:1px solid rgba(59,130,246,0.22);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:8px;';

                    const monsterHeading = doc.createElement('div');
                    monsterHeading.textContent = 'Mobs Lootados';
                    monsterHeading.style.cssText = 'font-size:13px;font-weight:700;color:#93c5fd;text-transform:uppercase;letter-spacing:0.04em;';
                    monsterBlock.appendChild(monsterHeading);

                    const monsterList = doc.createElement('div');
                    monsterList.style.cssText = 'display:flex;flex-direction:column;gap:8px;';

                    summary.monsters.forEach(monster => {
                        if (!monster) {
                            return;
                        }

                        const row = doc.createElement('div');
                        row.style.cssText = 'display:flex;flex-direction:column;gap:6px;background:rgba(15,23,42,0.65);border-radius:12px;padding:12px;border:1px solid rgba(148,163,184,0.18);';

                        const header = doc.createElement('div');
                        header.style.cssText = 'display:flex;flex-wrap:wrap;align-items:center;gap:8px;font-weight:600;color:#f8fafc;';

                        const nameSpan = doc.createElement('span');
                        const monsterName = monster.name || monster.id || 'Mob';
                        nameSpan.textContent = monster.count > 1 ? `${monsterName} √ó${monster.count}` : monsterName;
                        header.appendChild(nameSpan);

                        const ratioChips = [];
                        if (Number.isFinite(monster.expPerHp) && monster.expPerHp > 0) {
                            const chip = doc.createElement('span');
                            chip.textContent = `EXP/HP ${this.formatRatio(monster.expPerHp)}`;
                            chip.style.cssText = 'margin-left:auto;padding:4px 8px;background:rgba(59,130,246,0.18);border:1px solid rgba(59,130,246,0.35);border-radius:999px;font-size:11px;color:#93c5fd;font-weight:600;';
                            ratioChips.push(chip);
                        }

                        if (Number.isFinite(monster.goldPerHp) && monster.goldPerHp > 0) {
                            const chip = doc.createElement('span');
                            chip.textContent = `Gold/HP ${this.formatRatio(monster.goldPerHp)}`;
                            chip.style.cssText = 'padding:4px 8px;background:rgba(250,204,21,0.18);border:1px solid rgba(250,204,21,0.35);border-radius:999px;font-size:11px;color:#facc15;font-weight:600;';
                            ratioChips.push(chip);
                        }

                        if (ratioChips.length) {
                            ratioChips.forEach(chip => header.appendChild(chip));
                        }

                        row.appendChild(header);

                        const metrics = doc.createElement('div');
                        metrics.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;font-size:12px;';

                        if (Number.isFinite(monster.exp) && monster.exp > 0) {
                            const expChip = doc.createElement('span');
                            expChip.textContent = `${formatNumber(monster.exp)} EXP`;
                            expChip.style.cssText = 'padding:6px 10px;background:rgba(59,130,246,0.15);border:1px solid rgba(59,130,246,0.3);border-radius:10px;color:#bfdbfe;font-weight:600;';
                            metrics.appendChild(expChip);
                        }

                        if (Number.isFinite(monster.gold) && monster.gold > 0) {
                            const goldChip = doc.createElement('span');
                            goldChip.textContent = `${formatNumber(monster.gold)} Gold`;
                            goldChip.style.cssText = 'padding:6px 10px;background:rgba(250,204,21,0.12);border:1px solid rgba(250,204,21,0.28);border-radius:10px;color:#fde68a;font-weight:600;';
                            metrics.appendChild(goldChip);
                        }

                        if (Number.isFinite(monster.damage) && monster.damage > 0) {
                            const damageChip = doc.createElement('span');
                            damageChip.textContent = `${formatNumber(monster.damage)} Dano`;
                            damageChip.style.cssText = 'padding:6px 10px;background:rgba(248,113,113,0.12);border:1px solid rgba(248,113,113,0.28);border-radius:10px;color:#fecaca;font-weight:600;';
                            metrics.appendChild(damageChip);
                        }

                        if (metrics.childNodes.length) {
                            row.appendChild(metrics);
                        }

                        monsterList.appendChild(row);
                    });

                    monsterBlock.appendChild(monsterList);
                    card.appendChild(monsterBlock);
                }

                if (summary.items && summary.items.size > 0) {
                    const itemsContainer = doc.createElement('div');
                    itemsContainer.style.cssText = 'display:flex;flex-direction:column;gap:10px;background:rgba(30,41,59,0.8);border:1px solid rgba(148,163,184,0.25);border-radius:12px;padding:12px;';

                    const itemsHeading = doc.createElement('div');
                    itemsHeading.textContent = 'Itens Obtidos';
                    itemsHeading.style.cssText = 'font-size:13px;font-weight:700;color:#bae6fd;text-transform:uppercase;letter-spacing:0.04em;';
                    itemsContainer.appendChild(itemsHeading);

                    const list = doc.createElement('ul');
                    list.style.cssText = 'margin:0;padding-left:18px;display:flex;flex-direction:column;gap:6px;font-size:12px;color:#e2e8f0;';
                    summary.items.forEach(item => {
                        if (!item) {
                            return;
                        }

                        const li = doc.createElement('li');
                        li.style.cssText = 'display:flex;flex-direction:column;gap:2px;background:rgba(15,23,42,0.65);border-radius:10px;padding:10px;border:1px solid rgba(148,163,184,0.18);';

                        const header = doc.createElement('div');
                        header.style.cssText = 'display:flex;align-items:center;gap:8px;font-weight:600;color:#f8fafc;';

                        if (item.icon) {
                            const iconImg = doc.createElement('img');
                            iconImg.src = item.icon;
                            iconImg.alt = item.displayName;
                            iconImg.style.cssText = 'width:20px;height:20px;border-radius:4px;object-fit:cover;border:1px solid rgba(148,163,184,0.25);';
                            header.appendChild(iconImg);
                        }

                        const titleSpan = doc.createElement('span');
                        titleSpan.textContent = `${formatNumber(item.quantity)}√ó ${item.displayName}`;
                        header.appendChild(titleSpan);

                        if (item.rarity) {
                            const rarityBadge = doc.createElement('span');
                            rarityBadge.textContent = item.rarity.toUpperCase();
                            const rarityStyle = this.getRarityStyling(item.rarity);
                            rarityBadge.style.cssText = `margin-left:auto;padding:4px 8px;border-radius:999px;font-size:11px;font-weight:600;` +
                                `background:${rarityStyle.background};border:1px solid ${rarityStyle.border};color:${rarityStyle.color};`;
                            header.appendChild(rarityBadge);
                        }

                        li.appendChild(header);

                        if (item.description) {
                            const descriptionBlock = doc.createElement('div');
                            descriptionBlock.style.cssText = 'font-size:11px;line-height:1.4;color:#cbd5f5;opacity:0.9;';
                            const sanitized = this.sanitizeHtml(doc, item.description);
                            if (sanitized) {
                                descriptionBlock.appendChild(sanitized);
                            } else {
                                descriptionBlock.textContent = item.description;
                            }
                            li.appendChild(descriptionBlock);
                        }

                        list.appendChild(li);
                    });

                    itemsContainer.appendChild(list);
                    card.appendChild(itemsContainer);
                }

                if (summary.messages.length) {
                    const lastMessage = summary.messages[summary.messages.length - 1];
                    const messageBlock = doc.createElement('div');
                    messageBlock.style.cssText = 'font-size:12px;color:#cbd5f5;opacity:0.85;';
                    const sanitized = this.sanitizeHtml(doc, lastMessage);
                    if (sanitized) {
                        messageBlock.appendChild(sanitized);
                    } else {
                        messageBlock.textContent = lastMessage;
                    }
                    card.appendChild(messageBlock);
                }

                overlay.appendChild(card);
                host.appendChild(overlay);

                // Inject simple animation style once
                if (!doc.getElementById('autods-quickloot-modal-style')) {
                    const style = doc.createElement('style');
                    style.id = 'autods-quickloot-modal-style';
                    style.textContent = `
                        @keyframes autods-quickloot-fade-in {
                            from { opacity: 0; transform: scale(0.96); }
                            to { opacity: 1; transform: scale(1); }
                        }
                    `;
                    doc.head?.appendChild(style);
                }
            } catch (error) {
                context.logger.error(`Erro ao renderizar quick loot modal: ${error.message}`);
            }
        },
        cleanup() {
            // Limpar observers
            if (this.state.observers && Array.isArray(this.state.observers)) {
                this.state.observers.forEach(observer => {
                    try {
                        observer.disconnect();
                    } catch (error) {
                        console.warn('[FloatingHelpers] Erro ao desconectar observer:', error);
                    }
                });
                this.state.observers = [];
            }

            // Limpar timer de EXP potion
            if (this.state.expPotionTimer) {
                clearInterval(this.state.expPotionTimer);
                this.state.expPotionTimer = null;
            }

            // Remover container
            if (this.state.container) {
                this.state.container.remove();
                this.state.container = null;
            }
        }
    };

    const uiShellModule = {
        id: 'uiShell',
        match: () => true,
        init(context) {
            // Armazenar context para uso em addLog
            this._context = context;

            if (!this.state) {
                this.state = {
                    log: [],
                    logViewExpanded: false, // Controla se mostra todos os logs ou apenas 8
                    wave: { lastJoin: null },
                    battle: { lastResult: null },
                    farm: { lastPause: null },
                    farmProgress: { chapters: 0 },
                    pvp: { inBattle: false, lastResult: null },
                    toasts: []
                };
            }

            ensureLayoutStyles(context.document);
            ensureFloatingHelpersStyles(context.document);
            setPanelOffset(context.document, PANEL_WIDTH_PX);

            const { shadow } = context.ui;
            if (!shadow.querySelector('#autods-ui-style')) {
                const style = document.createElement('style');
                style.id = 'autods-ui-style';
                style.textContent = `
                    /* ========================================
                       AUTODS MODERN UI - Design System
                       Catppuccin-inspired Dark Theme
                       ======================================== */
                    
                    :host {
                        all: initial;
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
                        
                        /* Base Colors */
                        --bg-base: #11111b;
                        --bg-surface: #181825;
                        --bg-overlay: #1e1e2e;
                        --bg-mantle: #292945;
                        
                        /* Accent Colors */
                        --accent-primary: #89b4fa;
                        --accent-secondary: #cba6f7;
                        --accent-tertiary: #f5c2e7;
                        
                        /* Semantic Colors */
                        --success: #a6e3a1;
                        --warning: #f9e2af;
                        --error: #f38ba8;
                        --info: #89dceb;
                        
                        /* Text Colors */
                        --text-primary: #cdd6f4;
                        --text-secondary: #bac2de;
                        --text-muted: #7f849c;
                        
                        /* Borders & Dividers */
                        --border-subtle: rgba(137, 180, 250, 0.1);
                        --border-normal: rgba(137, 180, 250, 0.2);
                        --border-strong: rgba(137, 180, 250, 0.3);
                        
                        /* Shadows */
                        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
                        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
                        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
                        --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.6);
                        
                        /* Spacing Scale */
                        --space-1: 0.25rem;
                        --space-2: 0.5rem;
                        --space-3: 0.75rem;
                        --space-4: 1rem;
                        --space-5: 1.25rem;
                        --space-6: 1.5rem;
                        --space-8: 2rem;
                        
                        /* Border Radius */
                        --radius-sm: 0.25rem;
                        --radius-md: 0.5rem;
                        --radius-lg: 0.75rem;
                        --radius-xl: 1rem;
                        --radius-full: 9999px;
                        
                        /* Typography */
                        --text-xs: 0.55rem;
                        --text-sm: 0.675rem;
                        --text-base: 0.7rem;
                        --text-lg: 0.8rem;
                        --text-xl: 0.9rem;
                        
                        --leading-tight: 1.25;
                        --leading-normal: 1.5;
                        --leading-relaxed: 1.75;
                        
                        --weight-normal: 400;
                        --weight-medium: 500;
                        --weight-semibold: 600;
                        --weight-bold: 700;
                    }

                    #autods-shell {
                        position: fixed;
                        top: 0;
                        right: 0;
                        z-index: 99999999999;
                        background: linear-gradient(135deg, var(--bg-surface) 0%, var(--bg-base) 100%);
                        border: 1px solid var(--border-normal);
                        border-radius: var(--radius-xl) 0 0 var(--radius-xl);
                        color: var(--text-primary);
                        min-width: 280px;
                        width: var(--autods-panel-width, 380px);
                        max-width: 540px;
                        height: 100vh;
                        box-shadow: var(--shadow-xl);
                        font-size: var(--text-sm);
                        line-height: var(--leading-normal);
                        backdrop-filter: blur(12px);
                        overflow: hidden auto;
                        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s ease;
                    }
                    
                    #autods-shell[data-mobile-collapsed="1"] {
                        opacity: 0;
                        pointer-events: none;
                    }
                    
                    #autods-shell[data-mobile-collapsed="0"] {
                        opacity: 1;
                        pointer-events: auto;
                    }
                    
                    .autods-layout {
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-4);
                        min-height: 100%;
                    }
                    
                    .autods-panel {
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-4);
                        padding: var(--space-4);
                    }
                    /* Header Modernizado */
                    .autods-header {
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-2);
                        padding-bottom: var(--space-3);
                        border-bottom: 1px solid var(--border-subtle);
                    }
                    
                    .autods-header-main {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        gap: var(--space-3);
                    }
                    
                    .autods-header-title {
                        display: flex;
                        align-items: baseline;
                        gap: var(--space-3);
                        flex: 1;
                        min-width: 0;
                    }
                    
                    .autods-header-main strong {
                        font-size: var(--text-lg);
                        font-weight: var(--weight-bold);
                        letter-spacing: 0.02em;
                        color: var(--accent-primary);
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                        background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
                        -webkit-background-clip: text;
                        -webkit-text-fill-color: transparent;
                        background-clip: text;
                    }
                    
                    .autods-chip {
                        display: inline-flex;
                        align-items: center;
                        gap: var(--space-1);
                        padding: var(--space-1) var(--space-3);
                        border-radius: var(--radius-full);
                        font-size: var(--text-xs);
                        background: linear-gradient(135deg, rgba(137, 180, 250, 0.2) 0%, rgba(203, 166, 247, 0.2) 100%);
                        color: var(--accent-primary);
                        border: 1px solid var(--border-normal);
                        font-weight: var(--weight-semibold);
                        flex-shrink: 0;
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-panel-close {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 2.5rem;
                        height: 2.5rem;
                        background: var(--bg-overlay);
                        border: 1px solid var(--border-normal);
                        border-radius: var(--radius-md);
                        color: var(--text-secondary);
                        font-size: var(--text-xl);
                        line-height: 1;
                        cursor: pointer;
                        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                        flex-shrink: 0;
                        padding: 0;
                    }
                    
                    .autods-panel-close:hover {
                        background: linear-gradient(135deg, rgba(243, 139, 168, 0.3), rgba(235, 160, 172, 0.3));
                        border-color: var(--error);
                        color: var(--error);
                        transform: scale(1.05);
                        box-shadow: var(--shadow-md);
                    }
                    
                    .autods-panel-close:active {
                        transform: scale(0.95);
                    }
                    
                    .autods-route {
                        font-size: var(--text-xs);
                        color: var(--text-muted);
                        font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
                        word-break: break-all;
                        padding: var(--space-2) var(--space-3);
                        background: var(--bg-overlay);
                        border-radius: var(--radius-md);
                        border: 1px solid var(--border-subtle);
                    }
                    .autods-section { display: flex; flex-direction: column; gap: 6px; }
                    .autods-section-header { display: flex; align-items: center; gap: 8px; justify-content: space-between; padding: 0 2px; flex-wrap: nowrap; }
                    .autods-section-header h4 { flex: 1; margin: 0; font-size: 11px; font-weight: 700; letter-spacing: 0.45px; text-transform: uppercase; color: rgba(140, 190, 255, 0.9); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; min-width: 0; }
                    .autods-section-actions { display: inline-flex; align-items: center; gap: 4px; flex-shrink: 0; flex-wrap: nowrap; }
                    .autods-section-actions button { background: none; border: 1px solid rgba(70, 130, 220, 0.3); color: rgba(200, 220, 255, 0.9); font-size: 9px; padding: 3px 6px; border-radius: 6px; cursor: pointer; transition: background 0.2s ease, border 0.2s ease; white-space: nowrap; }
                    .autods-section-actions button:hover { background: rgba(70, 130, 220, 0.25); border-color: rgba(70, 130, 220, 0.5); }
                    @media (max-width: 480px) {
                        .autods-section-actions button { font-size: 8px; padding: 2px 5px; }
                    }
                    .autods-section-collapse { background: none; border: 1px solid rgba(70, 130, 220, 0.4); color: rgba(200, 220, 255, 0.9); border-radius: 50%; width: 20px; height: 20px; font-size: 11px; line-height: 1; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.2s ease, transform 0.2s ease; flex-shrink: 0; }
                    .autods-section-collapse:hover { background: rgba(70, 130, 220, 0.3); }
                    .autods-section[data-collapsed="1"] .autods-section-collapse { transform: rotate(-90deg); }
                    .autods-section-body { display: flex; flex-direction: column; gap: 8px; }
                    .autods-config-body { display: grid; gap: 10px; }
                    @media (min-width: 520px) {
                        .autods-config-body { grid-template-columns: minmax(270px, 1fr) 200px; align-items: start; }
                    }
                    .autods-config-forms { display: flex; flex-direction: column; gap: 10px; }
                    .autods-config-group { background: rgba(10, 20, 35, 0.7); border: 1px solid rgba(70, 130, 220, 0.25); border-radius: 10px; padding: 10px 12px; display: flex; flex-direction: column; gap: 8px; }
                    .autods-config-group h5 { margin: 0; font-size: 11px; text-transform: uppercase; letter-spacing: 0.45px; color: rgba(140, 190, 255, 0.9); }
                    .autods-config-field { display: flex; flex-direction: column; gap: 4px; font-size: 11px; }
                    .autods-config-field label { font-weight: 600; color: rgba(200, 220, 255, 0.9); display: flex; justify-content: space-between; gap: 8px; }
                    .autods-config-field small { color: rgba(180, 200, 235, 0.6); font-size: 10px; font-weight: 400; }
                    .autods-config-field input,
                    .autods-config-field select,
                    .autods-config-field textarea { width: 100%; background: rgba(20, 40, 70, 0.4); border: 1px solid rgba(70, 130, 220, 0.3); border-radius: 8px; color: #e8f0ff; padding: 6px 8px; font-size: 11px; font-family: inherit; resize: vertical; min-height: 30px; }
                    .autods-config-field textarea { min-height: 48px; }
                    .autods-config-field input:focus,
                    .autods-config-field select:focus,
                    .autods-config-field textarea:focus { outline: none; border-color: rgba(70, 130, 220, 0.6); box-shadow: 0 0 0 1px rgba(70, 130, 220, 0.4); }
                    .autods-config-field input.invalid,
                    .autods-config-field select.invalid,
                    .autods-config-field textarea.invalid { border-color: #ff6b6b; box-shadow: 0 0 0 1px rgba(255,107,107,0.35); }
                    .autods-section[data-collapsed="1"] .autods-section-body { display: none; }
                    .autods-toggle-list { display: flex; flex-direction: column; gap: 6px; }
                    .autods-toggle { display: flex; align-items: center; justify-content: space-between; gap: 6px; padding: 6px 8px; background: rgba(255,255,255,0.05); border-radius: 9px; transition: background 0.2s ease; }
                    .autods-toggle:hover { background: rgba(255,255,255,0.08); }
                    .autods-toggle span.label { font-weight: 600; color: #f1f5f4; font-size: 11px; }
                    .autods-toggle input[type="checkbox"] { width: 34px; height: 16px; accent-color: #4a9eff; cursor: pointer; }
                    .autods-log { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 5px; max-height: 120px; overflow-y: auto; }
                    .autods-log li { display: flex; align-items: baseline; gap: 6px; padding: 5px 7px; border-radius: 8px; background: rgba(20, 40, 70, 0.4); font-size: 11px; border-left: 3px solid transparent; }
                    .autods-log li .time { font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size: 10px; color: rgba(120, 180, 255, 0.8); }
                    .autods-log li .message { flex: 1; color: #e8f0ff; }
                    .autods-log li[data-level="warn"] { border-left-color: #f7b733; }
                    .autods-log li[data-level="error"] { border-left-color: #ff6b6b; }
                    .autods-log li[data-level="success"] { border-left-color: #4a9eff; }
                    .autods-log li[data-level="info"] { border-left-color: rgba(70, 130, 220, 0.7); }
                    .autods-log li.empty { justify-content: center; color: rgba(229,229,229,0.55); border-left-color: transparent; }
                    .autods-metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px; }
                    .autods-metric-card { background: rgba(20, 40, 80, 0.4); border-radius: 9px; padding: 8px 10px; display: flex; flex-direction: column; gap: 3px; border: 1px solid rgba(70, 130, 220, 0.25); }
                    .autods-metric-card strong { font-size: 19px; font-weight: 700; color: #b8d8ff; letter-spacing: 0.8px; }
                    .autods-metric-card span.label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.55px; color: rgba(140, 190, 255, 0.75); }
                    .autods-metric-card span.sub { font-size: 10px; color: rgba(120, 170, 235, 0.6); }
                    .autods-toast-container { position: fixed; inset: auto 16px 16px auto; display: flex; flex-direction: column; gap: 8px; pointer-events: none; }
                    .autods-toast { display: flex; gap: 8px; align-items: flex-start; background: rgba(10, 20, 35, 0.95); border: 1px solid rgba(70, 130, 220, 0.4); border-radius: 9px; padding: 8px 10px; box-shadow: 0 10px 20px rgba(0,0,0,0.35); pointer-events: auto; animation: fade-in 0.2s ease forwards; font-size: 11px; }
                    .autods-toast .body { display: flex; flex-direction: column; gap: 2px; }
                    .autods-toast .title { font-weight: 600; color: #a8d0ff; font-size: 11px; }
                    .autods-toast .message { font-size: 11px; color: rgba(200, 220, 255, 0.9); }
                    .autods-toast .time { font-size: 10px; color: rgba(140, 180, 235, 0.7); }
                    .autods-toast[data-level="warn"] { border-color: #f7b733; }
                    .autods-toast[data-level="error"] { border-color: #ff6b6b; }
                    .autods-toast[data-level="success"] { border-color: #4a9eff; }
                    .autods-toast[data-level="info"] { border-color: rgba(70, 130, 220, 0.6); }
                    @keyframes fade-in { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }

                    /* Mobile-First Responsive Design */
                    @media (max-width: 768px) {
                        #autods-shell { width: 85vw !important; max-width: 400px; border-radius: 0 12px 12px 0; font-size: 11px; }
                        .autods-panel { padding: 12px; gap: 10px; }
                        .autods-header-main strong { font-size: 12px; }
                        .autods-chip { font-size: 9px; padding: 1px 6px; }
                        .autods-section-header h4 { font-size: 10px; }
                        .autods-section-actions button { font-size: 8px; padding: 2px 5px; }
                        .autods-config-field { font-size: 10px; }
                        .autods-config-field input,
                        .autods-config-field select,
                        .autods-config-field textarea { font-size: 10px; padding: 5px 7px; min-height: 28px; }
                        .autods-config-field textarea { min-height: 42px; }
                        .autods-metrics-grid { grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)); gap: 6px; }
                        .autods-metric-card { padding: 6px 8px; }
                        .autods-metric-card strong { font-size: 16px; }
                        .autods-log { max-height: 100px; font-size: 10px; }
                        .autods-log li { font-size: 10px; padding: 4px 6px; }
                        .autods-toggle span.label { font-size: 10px; }
                        .autods-toast { font-size: 10px; padding: 7px 9px; }
                    }

                    @media (max-width: 480px) {
                        #autods-shell { width: 100vw !important; max-width: 100vw; border-radius: 0; height: 100vh; border: none; border-right: 1px solid rgba(70, 130, 220, 0.35); }
                        #autods-shell[data-mobile-collapsed="1"] { opacity: 0; pointer-events: none; }
                        .autods-panel { padding: 10px; gap: 8px; }
                        .autods-header-main { flex-direction: row !important; align-items: center !important; gap: 6px; }
                        .autods-header-title { flex-direction: row; align-items: center; gap: 6px; }
                        .autods-header-main strong { font-size: 11px; }
                        .autods-chip { font-size: 8px; padding: 1px 5px; }
                        .autods-panel-close { width: 32px; height: 32px; font-size: 18px; }
                        .autods-route { font-size: 10px; }
                        .autods-section { gap: 4px; }
                        .autods-section-header { gap: 6px; padding: 0; }
                        .autods-section-header h4 { font-size: 9px; letter-spacing: 0.3px; }
                        .autods-section-actions { gap: 3px; }
                        .autods-section-actions button { font-size: 7px; padding: 2px 4px; border-radius: 5px; }
                        .autods-section-collapse { width: 18px; height: 18px; font-size: 10px; }
                        .autods-section-body { gap: 6px; }
                        .autods-config-group { padding: 8px 10px; gap: 6px; border-radius: 8px; }
                        .autods-config-group h5 { font-size: 10px; }
                        .autods-config-field { gap: 3px; font-size: 9px; }
                        .autods-config-field label { gap: 6px; }
                        .autods-config-field small { font-size: 9px; }
                        .autods-config-field input,
                        .autods-config-field select,
                        .autods-config-field textarea { font-size: 9px; padding: 5px 6px; min-height: 26px; border-radius: 6px; }
                        .autods-config-field textarea { min-height: 38px; }
                        .autods-toggle { padding: 5px 6px; border-radius: 7px; }
                        .autods-toggle span.label { font-size: 9px; }
                        .autods-toggle input[type="checkbox"] { width: 30px; height: 14px; }
                        .autods-metrics-grid { grid-template-columns: repeat(2, 1fr); gap: 5px; }
                        .autods-metric-card { padding: 6px 7px; gap: 2px; border-radius: 7px; }
                        .autods-metric-card strong { font-size: 15px; letter-spacing: 0.5px; }
                        .autods-metric-card span.label { font-size: 9px; letter-spacing: 0.4px; }
                        .autods-metric-card span.sub { font-size: 9px; }
                        .autods-log { max-height: 90px; gap: 4px; }
                        .autods-log li { padding: 4px 5px; gap: 5px; font-size: 9px; border-radius: 6px; }
                        .autods-log li .time { font-size: 9px; }
                        .autods-toast-container { inset: auto 8px 8px auto; gap: 6px; max-width: calc(100vw - 16px); }
                        .autods-toast { font-size: 9px; padding: 6px 7px; gap: 6px; border-radius: 7px; max-width: 100%; }
                        .autods-toast .title { font-size: 10px; }
                        .autods-toast .message { font-size: 9px; line-height: 1.3; }
                        .autods-toast .time { font-size: 9px; }
                    }

                    @media (max-width: 360px) {
                        .autods-panel { padding: 8px; gap: 6px; }
                        .autods-header-main strong { font-size: 10px; }
                        .autods-chip { font-size: 7px; }
                        .autods-section-header h4 { font-size: 8px; }
                        .autods-section-actions button { font-size: 6px; padding: 2px 3px; }
                        .autods-config-field input,
                        .autods-config-field select,
                        .autods-config-field textarea { font-size: 8px; padding: 4px 5px; }
                        .autods-metric-card strong { font-size: 13px; }
                        .autods-metrics-grid { grid-template-columns: 1fr 1fr; }
                    }

                    /* Tab System Modernizado */
                    .autods-tabs-main {
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-1);
                        padding: var(--space-2) var(--space-3);
                        background: var(--bg-overlay);
                        border-bottom: 2px solid var(--border-normal);
                        overflow-x: auto;
                        scroll-behavior: smooth;
                        -webkit-overflow-scrolling: touch;
                        flex-wrap: nowrap;
                    }

                    .autods-tabs-main .autods-tab {
                        flex: 0 1 auto;
                        padding: var(--space-2) var(--space-3);
                        white-space: nowrap;
                        min-width: 75px;
                        font-size: 12px;
                    }

                    .autods-tabs-content {
                        padding: var(--space-4);
                        background: var(--bg-base);
                    }

                    .autods-tab-content {
                        display: none;
                        animation: fadeIn 0.2s ease-in-out;
                    }

                    .autods-tab-content[style*="display: block"] {
                        display: block;
                    }

                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }

                    /* Mobile Responsiveness for Tab System */
                    @media (max-width: 768px) {
                        .autods-tabs-main {
                            gap: var(--space-1);
                            padding: var(--space-2) var(--space-3);
                            overflow-x: auto;
                        }

                        .autods-tabs-main .autods-tab {
                            padding: var(--space-2) var(--space-3);
                            min-width: 70px;
                            font-size: 12px;
                        }

                        .autods-tabs-content {
                            padding: var(--space-3);
                        }

                        #autods-main-tab-buttons {
                            flex-wrap: wrap;
                            gap: var(--space-1);
                        }

                        #autods-main-tab-buttons button {
                            min-width: 70px;
                            padding: 8px 12px;
                            font-size: 12px;
                        }
                    }

                    @media (max-width: 480px) {
                        .autods-tabs-main {
                            gap: 4px;
                            padding: 8px 10px;
                            border-bottom: 1px solid var(--border-normal);
                        }

                        .autods-tabs-main .autods-tab {
                            padding: 8px 10px;
                            min-width: 60px;
                            font-size: 11px;
                            flex: 0 1 auto;
                            border-radius: 6px;
                        }

                        .autods-tabs-main .autods-tab.active {
                            min-height: 36px;
                        }

                        .autods-tabs-content {
                            padding: var(--space-2);
                        }

                        .autods-tab-content {
                            padding: 8px 0;
                        }

                        .autods-config-field {
                            gap: 4px;
                        }

                        .autods-config-field input,
                        .autods-config-field select,
                        .autods-config-field textarea {
                            font-size: 13px;
                            min-height: 40px;
                        }

                        #autods-main-tab-buttons {
                            position: fixed;
                            bottom: 8px;
                            right: 8px;
                            flex-direction: column;
                            gap: 6px;
                            z-index: 9999;
                        }

                        #autods-main-tab-buttons button {
                            min-width: 48px;
                            min-height: 48px;
                            padding: 10px;
                            font-size: 20px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        }
                    }

                    @media (max-width: 360px) {
                        .autods-tabs-main {
                            gap: 2px;
                            padding: 6px 8px;
                        }

                        .autods-tabs-main .autods-tab {
                            padding: 6px 8px;
                            min-width: 50px;
                            font-size: 10px;
                        }

                        .autods-tabs-content {
                            padding: 8px;
                        }

                        #autods-main-tab-buttons button {
                            min-width: 44px;
                            min-height: 44px;
                            padding: 8px;
                        }

                        .autods-config-field input,
                        .autods-config-field select,
                        .autods-config-field textarea {
                            font-size: 12px;
                            min-height: 38px;
                        }
                    }

                    /* Config Dropdowns Modernizados */
                    .autods-config-groups {
                        padding: var(--space-3);
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-3);
                    }
                    
                    .autods-config-dropdown {
                        background: var(--bg-surface);
                        border-radius: var(--radius-lg);
                        border: 1px solid var(--border-subtle);
                        overflow: hidden;
                        transition: all 0.3s ease;
                    }
                    
                    .autods-config-dropdown:hover {
                        border-color: var(--border-normal);
                        box-shadow: var(--shadow-md);
                    }
                    
                    .autods-dropdown-header {
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        width: 100%;
                        padding: var(--space-4);
                        background: linear-gradient(180deg, var(--bg-mantle) 0%, transparent 100%);
                        border: none;
                        color: var(--text-primary);
                        cursor: pointer;
                        transition: all 0.2s ease;
                        font-size: var(--text-base);
                        font-weight: var(--weight-semibold);
                        font-family: inherit;
                        gap: var(--space-3);
                    }
                    
                    .autods-dropdown-header:hover {
                        background: linear-gradient(180deg, rgba(137, 180, 250, 0.1) 0%, transparent 100%);
                    }
                    
                    .dropdown-icon {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 1.25rem;
                        height: 1.25rem;
                        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        font-size: var(--text-sm);
                        color: var(--accent-primary);
                    }
                    
                    .autods-dropdown-header.active .dropdown-icon {
                        transform: rotate(90deg);
                    }
                    
                    .dropdown-title {
                        flex: 1;
                        text-align: left;
                        display: flex;
                        align-items: center;
                        gap: var(--space-2);
                    }
                    
                    .dropdown-status {
                        font-size: var(--text-xs);
                        padding: var(--space-1) var(--space-3);
                        border-radius: var(--radius-full);
                        font-weight: var(--weight-semibold);
                        display: inline-flex;
                        align-items: center;
                        gap: var(--space-1);
                    }
                    
                    .dropdown-status[data-active="true"] {
                        background: linear-gradient(135deg, rgba(166, 227, 161, 0.3), rgba(148, 226, 213, 0.3));
                        color: var(--success);
                        border: 1px solid rgba(166, 227, 161, 0.4);
                    }
                    
                    .dropdown-status[data-active="false"] {
                        background: rgba(127, 132, 156, 0.2);
                        color: var(--text-muted);
                        border: 1px solid var(--border-subtle);
                    }
                    
                    .autods-dropdown-content {
                        padding: var(--space-4);
                        border-top: 1px solid var(--border-subtle);
                        animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    }
                    
                    @keyframes slideDown {
                        from {
                            opacity: 0;
                            max-height: 0;
                            padding-top: 0;
                            padding-bottom: 0;
                        }
                        to {
                            opacity: 1;
                            max-height: 2000px;
                            padding-top: var(--space-4);
                            padding-bottom: var(--space-4);
                        }
                    }

                    /* Tabs Modernizadas */
                    .autods-tabs {
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-1);
                        margin-bottom: var(--space-4);
                        padding: var(--space-1);
                        background: var(--bg-overlay);
                        border-radius: var(--radius-lg);
                        border: 1px solid var(--border-subtle);
                        position: relative;
                    }
                    
                    .autods-tab {
                        flex: 1;
                        padding: var(--space-3) var(--space-4);
                        background: transparent;
                        border: none;
                        border-radius: var(--radius-md);
                        color: var(--text-muted);
                        cursor: pointer;
                        font-size: var(--text-sm);
                        font-weight: var(--weight-medium);
                        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        text-align: center;
                        font-family: inherit;
                        position: relative;
                        z-index: 1;
                    }
                    
                    .autods-tab:hover {
                        color: var(--text-secondary);
                        background: rgba(137, 180, 250, 0.05);
                    }
                    
                    .autods-tab.active {
                        background: linear-gradient(135deg, rgba(137, 180, 250, 0.2), rgba(203, 166, 247, 0.2));
                        color: var(--accent-primary);
                        font-weight: var(--weight-semibold);
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-tab.active::after {
                        content: '';
                        position: absolute;
                        bottom: -4px;
                        left: 50%;
                        transform: translateX(-50%);
                        width: 60%;
                        height: 3px;
                        background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
                        border-radius: var(--radius-full);
                    }
                    
                    .autods-tab-content {
                        display: none;
                        animation: fadeIn 0.3s ease-out;
                    }
                    
                    .autods-tab-content.active {
                        display: block;
                    }
                    
                    @keyframes fadeIn {
                        from {
                            opacity: 0;
                            transform: translateY(8px);
                        }
                        to {
                            opacity: 1;
                            transform: translateY(0);
                        }
                    }

                    /* Form Fields Modernizados */
                    .autods-field-row {
                        display: flex;
                        gap: var(--space-3);
                        margin-bottom: var(--space-3);
                        flex-wrap: wrap;
                    }
                    
                    .autods-field {
                        flex: 1;
                        display: flex;
                        flex-direction: column;
                        gap: var(--space-2);
                        min-width: 120px;
                    }
                    
                    .autods-field-small {
                        flex: 0 0 100px;
                    }
                    
                    .autods-field > span {
                        font-size: var(--text-xs);
                        font-weight: var(--weight-medium);
                        color: var(--text-secondary);
                        text-transform: uppercase;
                        letter-spacing: 0.05em;
                    }
                    
                    .autods-field input,
                    .autods-field select,
                    .autods-field textarea {
                        padding: var(--space-3) var(--space-4);
                        background: var(--bg-overlay);
                        border: 2px solid var(--border-normal);
                        border-radius: var(--radius-lg);
                        color: var(--text-primary);
                        font-size: var(--text-sm);
                        font-family: inherit;
                        resize: vertical;
                        transition: all 0.2s ease;
                    }
                    
                    .autods-field input::placeholder,
                    .autods-field textarea::placeholder {
                        color: var(--text-muted);
                    }
                    
                    .autods-field input:hover,
                    .autods-field select:hover,
                    .autods-field textarea:hover {
                        border-color: var(--border-strong);
                    }
                    
                    .autods-field input:focus,
                    .autods-field select:focus,
                    .autods-field textarea:focus {
                        outline: none;
                        border-color: var(--accent-primary);
                        box-shadow: 0 0 0 3px rgba(137, 180, 250, 0.1);
                        background: var(--bg-base);
                    }
                    
                    .autods-field output {
                        display: block;
                        text-align: center;
                        margin-top: var(--space-1);
                        font-size: var(--text-sm);
                        font-weight: var(--weight-semibold);
                        color: var(--success);
                        padding: var(--space-1) var(--space-2);
                        background: rgba(166, 227, 161, 0.1);
                        border-radius: var(--radius-md);
                    }
                    
                    .autods-field small {
                        font-size: var(--text-xs);
                        color: var(--text-muted);
                        font-style: italic;
                        margin-top: var(--space-1);
                        line-height: var(--leading-relaxed);
                    }

                    /* Checkboxes Modernizados */
                    .autods-checkbox {
                        display: flex;
                        align-items: center;
                        gap: var(--space-3);
                        padding: var(--space-3) var(--space-4);
                        background: var(--bg-overlay);
                        border: 1px solid var(--border-subtle);
                        border-radius: var(--radius-lg);
                        cursor: pointer;
                        font-size: var(--text-sm);
                        margin: var(--space-2) 0;
                        transition: all 0.2s ease;
                    }
                    
                    .autods-checkbox:hover {
                        background: rgba(137, 180, 250, 0.1);
                        border-color: var(--border-normal);
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-checkbox input {
                        width: 1.25rem;
                        height: 1.25rem;
                        cursor: pointer;
                        accent-color: var(--accent-primary);
                        position: relative;
                    }
                    
                    .autods-checkbox input:checked {
                        filter: drop-shadow(0 0 4px rgba(137, 180, 250, 0.5));
                    }
                    
                    .autods-checkbox:has(input:checked) {
                        background: linear-gradient(135deg, rgba(137, 180, 250, 0.15), rgba(203, 166, 247, 0.15));
                        border-color: var(--accent-primary);
                    }

                    /* Subsections Modernizadas */
                    .autods-subsection {
                        margin: var(--space-4) 0;
                        padding: var(--space-4);
                        background: var(--bg-overlay);
                        border-radius: var(--radius-lg);
                        border: 1px solid var(--border-subtle);
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-subsection h5 {
                        margin: 0 0 var(--space-3) 0;
                        font-size: var(--text-sm);
                        font-weight: var(--weight-semibold);
                        text-transform: uppercase;
                        letter-spacing: 0.05em;
                        color: var(--accent-primary);
                        display: flex;
                        align-items: center;
                        gap: var(--space-2);
                    }
                    
                    .autods-subsection h5::before {
                        content: '';
                        width: 3px;
                        height: 1rem;
                        background: linear-gradient(180deg, var(--accent-primary), var(--accent-secondary));
                        border-radius: var(--radius-full);
                    }
                    
                    .autods-subsection-title {
                        margin: var(--space-5) 0 var(--space-3) 0;
                        font-size: var(--text-sm);
                        font-weight: var(--weight-bold);
                        letter-spacing: 0.05em;
                        text-transform: uppercase;
                        color: var(--accent-secondary);
                        border-bottom: 2px solid var(--border-normal);
                        padding-bottom: var(--space-2);
                        display: flex;
                        align-items: center;
                        gap: var(--space-2);
                    }

                    /* Warning Message Modernizada */
                    .autods-warning {
                        margin: var(--space-3) 0;
                        padding: var(--space-4);
                        background: linear-gradient(135deg, rgba(249, 226, 175, 0.15), rgba(251, 191, 36, 0.1));
                        border: 1px solid var(--warning);
                        border-left: 4px solid var(--warning);
                        border-radius: var(--radius-lg);
                        font-size: var(--text-sm);
                        line-height: var(--leading-relaxed);
                        color: var(--warning);
                        display: flex;
                        gap: var(--space-3);
                        align-items: flex-start;
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-warning::before {
                        content: '‚ö†Ô∏è';
                        font-size: var(--text-lg);
                        flex-shrink: 0;
                    }
                    
                    /* Info Message Modernizada */
                    .autods-info {
                        margin: var(--space-3) 0;
                        padding: var(--space-4);
                        background: linear-gradient(135deg, rgba(137, 220, 235, 0.15), rgba(137, 180, 250, 0.1));
                        border: 1px solid var(--info);
                        border-left: 4px solid var(--info);
                        border-radius: var(--radius-lg);
                        font-size: var(--text-sm);
                        line-height: var(--leading-relaxed);
                        color: var(--info);
                        display: flex;
                        gap: var(--space-3);
                        align-items: flex-start);
                        box-shadow: var(--shadow-sm);
                    }
                    
                    .autods-info::before {
                        content: '‚ÑπÔ∏è';
                        font-size: var(--text-lg);
                        flex-shrink: 0;
                    }
                    
                    /* Button System Modernizado */
                    .autods-btn {
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        gap: var(--space-2);
                        padding: var(--space-3) var(--space-5);
                        border-radius: var(--radius-lg);
                        border: 2px solid var(--border-normal);
                        background: linear-gradient(135deg, rgba(137, 180, 250, 0.2), rgba(203, 166, 247, 0.2));
                        color: var(--accent-primary);
                        font-size: var(--text-sm);
                        font-weight: var(--weight-medium);
                        cursor: pointer;
                        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                        font-family: inherit;
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .autods-btn::before {
                        content: '';
                        position: absolute;
                        inset: 0;
                        background: linear-gradient(135deg, transparent, rgba(137, 180, 250, 0.2));
                        opacity: 0;
                        transition: opacity 0.3s ease;
                    }
                    
                    .autods-btn:hover {
                        border-color: var(--accent-primary);
                        box-shadow: 0 0 0 3px rgba(137, 180, 250, 0.1), var(--shadow-md);
                        transform: translateY(-2px);
                    }
                    
                    .autods-btn:hover::before {
                        opacity: 1;
                    }
                    
                    .autods-btn:active {
                        transform: translateY(0) scale(0.98);
                    }
                    
                    .autods-btn-success {
                        background: linear-gradient(135deg, rgba(166, 227, 161, 0.3), rgba(148, 226, 213, 0.3));
                        border-color: var(--success);
                        color: var(--success);
                    }
                    
                    .autods-btn-success:hover {
                        border-color: var(--success);
                        box-shadow: 0 0 0 3px rgba(166, 227, 161, 0.1), var(--shadow-md);
                    }
                    
                    .autods-btn-danger {
                        background: linear-gradient(135deg, rgba(243, 139, 168, 0.3), rgba(235, 160, 172, 0.3));
                        border-color: var(--error);
                        color: var(--error);
                    }
                    
                    .autods-btn-danger:hover {
                        border-color: var(--error);
                        box-shadow: 0 0 0 3px rgba(243, 139, 168, 0.1), var(--shadow-md);
                    }

                    /* Skill Grid */
                    .autods-skill-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 8px; padding: 8px; background: rgba(20, 20, 30, 0.4); border-radius: 4px; }
                    .autods-skill { display: flex; flex-direction: column; gap: 2px; }
                    .autods-skill span { font-size: 9px; color: #89b4fa; }
                    .autods-skill input { padding: 4px; font-size: 11px; background: rgba(30, 30, 46, 0.6); border: 1px solid rgba(137, 180, 250, 0.3); border-radius: 4px; color: #e0e0e0; font-family: inherit; }



                    /* Events Mini */
                    .autods-events-mini { margin-top: auto; padding-top: 8px; border-top: 1px solid rgba(70, 130, 220, 0.3); }
                    .autods-events-header { display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: rgba(30, 30, 46, 0.6); border-radius: 6px 6px 0 0; font-size: 11px; font-weight: 600; }
                    .autods-events-header button { background: none; border: none; color: rgba(200, 220, 255, 0.9); font-size: 14px; cursor: pointer; padding: 0; transition: transform 0.2s; }
                    .autods-events-header button:hover { transform: scale(1.1); }
                    .autods-events-list { max-height: 100px; overflow-y: auto; padding: 4px; background: rgba(20, 20, 30, 0.4); border-radius: 0 0 6px 6px; }
                    .autods-events-list .autods-log { margin: 0; padding: 0; max-height: none; }

                    /* Responsive Design Modernizado */
                    
                    /* Tablet (768px - 1024px) */
                    @media (max-width: 1024px) {
                        #autods-shell {
                            width: 400px;
                        }
                    }
                    
                    /* Mobile Large (481px - 768px) */
                    @media (max-width: 768px) {
                        :host {
                            --space-4: 0.875rem;
                            --space-6: 1.25rem;
                        }
                        
                        #autods-shell {
                            width: 90vw;
                            max-width: 420px;
                            font-size: calc(var(--text-sm) * 0.95);
                        }
                        
                        .autods-header-main strong {
                            font-size: var(--text-base);
                        }
                        
                        .autods-tab {
                            font-size: var(--text-sm);
                            padding: var(--space-3);
                        }
                        
                        .autods-tab {
                            font-size: var(--text-xs);
                            padding: var(--space-2) var(--space-3);
                        }
                        
                        .autods-field input,
                        .autods-field select,
                        .autods-field textarea {
                            font-size: var(--text-xs);
                            padding: var(--space-2) var(--space-3);
                        }
                        
                        .autods-checkbox {
                            font-size: var(--text-xs);
                            padding: var(--space-2) var(--space-3);
                        }
                        
                        .autods-btn {
                            padding: var(--space-2) var(--space-4);
                            font-size: var(--text-xs);
                        }
                    }

                    /* Mobile (320px - 480px) */
                    @media (max-width: 480px) {
                        :host {
                            --space-4: 0.75rem;
                            --space-6: 1rem;
                            --text-base: 0.9375rem;
                        }
                        
                        #autods-shell {
                            width: 100vw !important;
                            max-width: 100vw;
                            border-radius: 0;
                            border-right: 1px solid var(--border-normal);
                        }
                        
                        .autods-panel {
                            padding: var(--space-3);
                        }
                        
                        .autods-header-main strong {
                            font-size: var(--text-sm);
                        }
                        
                        .autods-chip {
                            font-size: 0.65rem;
                            padding: 0 var(--space-2);
                        }
                        
                        .autods-dropdown-header {
                            font-size: var(--text-xs);
                            padding: var(--space-2);
                        }
                        
                        .autods-tab {
                            font-size: 0.7rem;
                            padding: var(--space-1) var(--space-2);
                        }
                        
                        .autods-field-row {
                            flex-direction: column;
                        }
                        
                        .autods-field input,
                        .autods-field select,
                        .autods-field textarea {
                            font-size: 0.8rem;
                            padding: var(--space-2);
                        }
                        
                        .autods-checkbox {
                            font-size: 0.8rem;
                            padding: var(--space-2);
                        }
                        
                        .autods-skill-grid {
                            grid-template-columns: 1fr;
                        }
                        
                        .autods-btn {
                            width: 100%;
                            padding: var(--space-3);
                        }
                    }
                    
                    /* Mobile Extra Small (< 360px) */
                    @media (max-width: 360px) {
                        .autods-dropdown-header {
                            font-size: 0.7rem;
                        }
                    }
                `;
                shadow.appendChild(style);
            }

            if (!shadow.querySelector('#autods-toast-root')) {
                const toastHost = document.createElement('div');
                toastHost.id = 'autods-toast-root';
                shadow.appendChild(toastHost);
                this.createToastContainer(toastHost, context);
            } else if (!this.toastContainer) {
                this.createToastContainer(shadow.querySelector('#autods-toast-root'), context);
            }

            let container = shadow.querySelector('#autods-shell');
            if (!container) {
                container = context.dom.create('div', { id: 'autods-shell' });
                container.innerHTML = this.template(context);
                shadow.appendChild(container);
            }

            // Create mobile toggle button in document (not shadow DOM) so it's always visible
            this.ensureMobileToggle(context, container);
            // Create desktop toggle button (visible when panel is collapsed)
            this.ensureDesktopToggle(context, container);

            // Show desktop toggle button if panel is minimized
            if (this.desktopToggleButton && container.getAttribute('data-mobile-collapsed') === '1') {
                this.desktopToggleButton.classList.add('visible');
            }

            this.cacheElements(container);
            this.bind(context);
            this.render(context);
            
            // Render Profile Manager in the Profiles tab
            setTimeout(() => {
                const pmContainer = container.querySelector('#autods-profile-manager-container');
                if (pmContainer && context.profileManager) {
                    try {
                        context.profileManager.renderUI(pmContainer);
                        context.logger.debug('Profile Manager UI renderizado com sucesso');
                    } catch (e) {
                        context.logger.warn('Erro ao renderizar Profile Manager UI', e);
                    }
                }
            }, 100);
            
            // Restore dropdown states after DOM is fully ready
            requestAnimationFrame(() => {
                this.restoreDropdownStates(context);
            });
            
            // Check for Ultra Fast Boss auto-resume after potion reload
            setTimeout(() => {
                this.checkAndResumeUltraFastBoss(context);
            }, 1500);
        },
        template(context) {
            const uiConfig = context.config.get().ui || {};
            const panelStates = uiConfig.panelStates || {};
            const cfg = context.config.get();
            return `
                <div class="autods-layout">
                    <div class="autods-panel">
                        <div class="autods-header">
                            <div class="autods-header-main">
                                <div class="autods-header-title">
                                    <strong>AutoDS</strong>
                                    <span class="autods-chip">v<span data-meta="version"></span></span>
                                </div>
                                <button type="button" class="autods-panel-close" data-action="close-panel" aria-label="Minimizar" title="Minimizar (Ctrl+Shift+P)">‚úï</button>
                            </div>
                            <div class="autods-route"><code data-meta="route"></code></div>
                        </div>

                        <!-- Tab Navigation -->
                        <div class="autods-tabs-main">
                            <button class="autods-tab" data-tab="profiles">üìÅ Perfis</button>
                            <button class="autods-tab active" data-tab="quick">üéØ R√°pido</button>
                            <button class="autods-tab" data-tab="ultrafastfarm">‚öîÔ∏è Ultra Fast Farm</button>
                            <button class="autods-tab" data-tab="specialboss">üëë Special Boss</button>
                            <button class="autods-tab" data-tab="ultrafastattack">‚ö° Ultra Fast Attack</button>
                            <button class="autods-tab" data-tab="ultrafastloot">üéÅ Ultra Fast Loot</button>
                            <button class="autods-tab" data-tab="boss">üêâ Boss</button>
                            <button class="autods-tab" data-tab="dungeon">üè∞ Dungeon</button>
                            <button class="autods-tab" data-tab="battle">üó°Ô∏è Battle</button>
                            <button class="autods-tab" data-tab="pvp">üèÜ PvP</button>
                            <button class="autods-tab" data-tab="interface">‚öôÔ∏è Interface</button>
                        </div>

                        <!-- Tab Contents -->
                        <div class="autods-tabs-content">
                            <!-- Tab: R√°pido -->
                            <div class="autods-tab-content active" data-tab-content="quick">
                                <div class="autods-status-panel">
                                    <h3>üìä Status Geral</h3>
                                    <div class="autods-status-grid">
                                        <div class="autods-status-item">
                                            <label class="autods-checkbox">
                                                <input type="checkbox" data-config="core.enabled" data-label="Core" data-toast="0" />
                                                <span>üîå Core Habilitado</span>
                                            </label>
                                        </div>
                                        <div class="autods-status-item">
                                            <label class="autods-checkbox">
                                                <input type="checkbox" data-config="wave.enabled" data-label="Ultra Fast Wave" data-toast="0" />
                                                <span>‚ö° Ultra Fast Farm</span>
                                            </label>
                                        </div>
                                        <div class="autods-status-item">
                                            <label class="autods-checkbox">
                                                <input type="checkbox" data-config="ultraFastDungeon.enabled" data-label="Ultra Fast Dungeon" data-toast="0" />
                                                <span>üè∞ Ultra Fast Dungeon</span>
                                            </label>
                                        </div>
                                        <div class="autods-status-item">
                                            <label class="autods-checkbox">
                                                <input type="checkbox" data-config="pvp.enabled" data-label="PvP" data-toast="0" />
                                                <span>üèÜ PvP</span>
                                            </label>
                                        </div>
                                        <div class="autods-status-item">
                                            <label class="autods-checkbox">
                                                <input type="checkbox" data-config="specialBossFarm.enabled" data-label="Special Boss Farm" data-toast="0" />
                                                <span>üëë Special Boss Farm</span>
                                            </label>
                                        </div>
                                        <div class="autods-status-item">
                                            <label class="autods-checkbox">
                                                <input type="checkbox" data-config="merchantAutoBuy.enabled" data-label="Merchant Auto-Buy" data-toast="1" />
                                                <span>üõí Merchant Auto-Buy</span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Tab: Ultra Fast Farm -->
                            <div class="autods-tab-content" data-tab-content="ultrafastfarm">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">‚öîÔ∏è Ultra Fast Farm</h4>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="wave.enabled" data-label="Ultra Fast Wave" data-toast="0" />
                                    <span>‚ö° Ativar Ultra Fast Mode</span>
                                </label>
                                
                                <h6 style="margin-top:10px;margin-bottom:6px;font-size:11px;color:#aaa;">üéØ Filtro de Monstros</h6>
                                <label class="autods-field">
                                    <span>Include (Whitelist)</span>
                                    <textarea data-config="wave.monsterFilter.includeNames" data-config-format="csv" data-label="Incluir Monstros" placeholder="If empty, attack all. One name per line. Ex:
Orc Warrior
Troll Brawler" rows="2"></textarea>
                                </label>
                                <label class="autods-field">
                                    <span>Exclude (Blacklist)</span>
                                    <textarea data-config="wave.monsterFilter.excludeNames" data-config-format="csv" data-label="Excluir Monstros" placeholder="Monsters to ignore. One name per line. Ex:
Mini Boss
Event Monster" rows="2"></textarea>
                                </label>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Skill</span>
                                        <select data-config="wave.skillId" data-config-format="int" data-label="Ultra Fast Skill">
                                            <option value="0">Slash (1)</option>
                                            <option value="-1">Power (10)</option>
                                            <option value="-2">Heroic (50)</option>
                                            <option value="-3">Ultimate (100)</option>
                                            <option value="-4">Legendary (200)</option>
                                        </select>
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Dano Alvo</span>
                                        <input type="number" data-config="wave.damageTarget" data-config-format="int" data-label="Dano Alvo" min="100000" step="100000" />
                                    </label>
                                </div>
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Ataques //</span>
                                        <input type="number" data-config="wave.parallelAttacks" data-config-format="int" data-label="Ataques Paralelos" min="1" max="20" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="wave.minDelayBetweenAttacks" data-config-format="int" data-label="Delay" min="10" step="10" />
                                    </label>
                                </div>
                                
                                <h6 style="margin-top:10px;margin-bottom:6px;font-size:11px;color:#aaa;">üíä Auto Full Stamina Potion</h6>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="wave.autoFSP" data-label="Auto FSP" data-toast="0" />
                                    <span>üíä Auto FSP quando stamina baixa</span>
                                </label>
                                <label class="autods-field autods-field-small">
                                    <span>Stamina M√≠n para FSP</span>
                                    <input type="number" data-config="wave.minStaminaForFSP" data-config-format="int" data-label="Stamina M√≠n FSP" min="0" step="10" />
                                </label>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="wave.lootDeadBeforeFSP" data-label="Loot Dead antes FSP" data-toast="0" />
                                    <span>üíÄ Lootar Dead Monsters antes de usar FSP</span>
                                </label>
                                <p class="autods-info" style="font-size:10px;margin-top:4px;">Tenta lootar dead monsters para recuperar stamina via level up antes de gastar FSP.</p>
                            </div>

                            <!-- Tab: Special Boss Farm -->
                            <div class="autods-tab-content" data-tab-content="specialboss">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">üëë Special Boss Farm</h4>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="specialBossFarm.enabled" data-label="Special Boss Farm" data-toast="0" />
                                    <span>üëë Farm Bosses Especiais (General/King/Empress/Bastion)</span>
                                </label>
                                <p class="autods-info" style="font-size:11px;">M√≥dulo dedicado para garantir 50M de dano em bosses raros com loot especial.</p>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Dano Alvo</span>
                                        <input type="number" data-config="specialBossFarm.targetDamage" data-config-format="int" data-label="Dano Alvo Boss" value="50000000" min="1000000" step="1000000" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Skill</span>
                                        <select data-config="specialBossFarm.skillId" data-config-format="int" data-label="Boss Skill">
                                            <option value="0">Slash (1)</option>
                                            <option value="-1">Power (10)</option>
                                            <option value="-2">Heroic (50)</option>
                                            <option value="-3">Ultimate (100)</option>
                                            <option value="-4">Legendary (200)</option>
                                        </select>
                                    </label>
                                </div>
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Ataques //</span>
                                        <input type="number" data-config="specialBossFarm.parallelAttacks" data-config-format="int" data-label="Parallel" min="1" max="10" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="specialBossFarm.minDelayBetweenAttacks" data-config-format="int" data-label="Delay" min="10" step="10" />
                                    </label>
                                </div>
                                
                                <h6 style="margin-top:10px;margin-bottom:6px;font-size:11px;color:#aaa;">üíä Auto Stamina Potion</h6>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="specialBossFarm.autoStaminaPotion" data-label="Auto Potion" data-toast="0" />
                                    <span>üíä Usar po√ß√£o automaticamente quando necess√°rio</span>
                                </label>
                                <label class="autods-field autods-field-small">
                                    <span>Stamina M√≠n</span>
                                    <input type="number" data-config="specialBossFarm.minStaminaForPotion" data-config-format="int" data-label="Min Stamina" min="0" step="10" />
                                </label>
                                
                                <h6 style="margin-top:10px;margin-bottom:6px;font-size:11px;color:#aaa;">üíÄ Configura√ß√£o de Loot</h6>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="specialBossFarm.lootDeadBeforeFSP" data-label="Loot Dead antes FSP Boss" data-toast="0" />
                                    <span>üíÄ Lootar Dead Monsters antes de usar FSP</span>
                                </label>
                                <p class="autods-info" style="font-size:10px;margin-top:4px;">Durante farm de bosses, tenta lootar dead monsters para recuperar stamina via level up antes de gastar FSP.</p>
                                
                                <h6 style="margin-top:10px;margin-bottom:6px;font-size:11px;color:#aaa;">‚è±Ô∏è Tempo de Espera</h6>
                                <label class="autods-field">
                                    <span>Intervalo sem Boss (min)</span>
                                    <input type="number" data-config="specialBossFarm.checkInterval" data-config-format="int" data-label="Check Interval" min="60000" step="60000" value="300000" />
                                </label>
                                <p class="autods-info" style="font-size:10px;margin-top:4px;">Tempo de espera se n√£o encontrar bosses antes de recarregar (padr√£o: 5 minutos).</p>
                            </div>

                            <!-- Tab: Ultra Fast Attack -->
                            <div class="autods-tab-content" data-tab-content="ultrafastattack">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">‚ö° Ultra Fast Attack</h4>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastAttack.enabled" data-label="Ultra Fast Attack" data-toast="0" />
                                    <span>‚ö° Ativar Ultra Fast Attack (via bot√£o Farm)</span>
                                </label>
                                <p class="autods-info" style="font-size:11px;">Opera√ß√µes de ataque em lote paralelo via bot√£o flutuante Farm. Modo manual.</p>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Max Paralelos</span>
                                        <input type="number" data-config="ultraFastAttack.maxParallelBattles" data-config-format="int" data-label="Max Paralelos" min="1" max="20" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Max Concurrent</span>
                                        <input type="number" data-config="ultraFastAttack.maxConcurrentBattles" data-config-format="int" data-label="Max Concurrent" min="1" max="10" />
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Ataques/Mob</span>
                                        <input type="number" data-config="ultraFastAttack.attacksPerMonster" data-config-format="int" data-label="Ataques" min="1" max="10" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Skill</span>
                                        <select data-config="ultraFastAttack.skillId" data-config-format="int" data-label="Skill">
                                            <option value="0">Slash (1)</option>
                                            <option value="-1">Power (10)</option>
                                            <option value="-2">Heroic (50)</option>
                                            <option value="-3">Ultimate (100)</option>
                                            <option value="-4">Legendary (200)</option>
                                        </select>
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="ultraFastAttack.delayBetweenBatches" data-config-format="int" data-label="Delay" min="100" step="100" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Prioridade</span>
                                        <select data-config="ultraFastAttack.priorityMode" data-label="Prioridade">
                                            <option value="lowest_hp">‚Üì HP</option>
                                            <option value="highest_hp">‚Üë HP</option>
                                            <option value="random">üé≤ Aleat√≥rio</option>
                                        </select>
                                    </label>
                                </div>
                                
                                <label class="autods-field">
                                    <span>Nomes de Monstros</span>
                                    <textarea data-config="ultraFastAttack.monsterNames" data-config-format="csv" data-label="Monstros Attack" placeholder="Deixar vazio para todos. Um por linha. Ex:
Orc Warrior
Troll Brawler" rows="2"></textarea>
                                </label>
                                <p class="autods-info" style="font-size:10px;margin-top:4px;">Deixe vazio para atacar todos os monstros dispon√≠veis.</p>
                            </div>

                            <!-- Tab: Ultra Fast Loot -->
                            <div class="autods-tab-content" data-tab-content="ultrafastloot">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">üéÅ Ultra Fast Loot</h4>
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastLoot.enabled" data-label="Ultra Fast Loot" data-toast="0" />
                                    <span>üéÅ Ativar Ultra Fast Loot (via bot√£o Loot)</span>
                                </label>
                                <p class="autods-info" style="font-size:11px;">Loot autom√°tico em paralelo. Trabalha melhor ap√≥s Ultra Fast Attack.</p>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Max Paralelos</span>
                                        <input type="number" data-config="ultraFastLoot.maxParallelLoots" data-config-format="int" data-label="Max Paralelos Loot" min="1" max="20" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="ultraFastLoot.delayBetweenLoots" data-config-format="int" data-label="Delay Loot" min="50" step="50" />
                                    </label>
                                </div>
                                
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastLoot.autoLootAfterFarm" data-label="Auto Loot" data-toast="0" />
                                    <span>‚ö° Auto-loot ap√≥s Ultra Fast Attack completar</span>
                                </label>
                                <p class="autods-info" style="font-size:10px; margin-top: 4px;">Se ativado, iniciar√° automaticamente o loot ap√≥s farm terminar.</p>
                                
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastLoot.lootSpecialBossBeforeFSP" data-label="Loot Special Boss" data-toast="0" />
                                    <span>üëë Lootar Special Bosses (100B+ HP)</span>
                                </label>
                                <p class="autods-info" style="font-size:10px; margin-top: 4px;">Se ativado, loota special bosses UM POR UM para recuperar stamina via level up.</p>
                                
                                <label class="autods-field">
                                    <span>Incluir Nomes</span>
                                    <textarea data-config="ultraFastLoot.filters.monsterNames" data-config-format="csv" data-label="Incluir Loot" placeholder="Deixar vazio para todos os mobs. Um por linha. Ex:
Orc Warrior
Troll Brawler" rows="2"></textarea>
                                </label>
                                <p class="autods-info" style="font-size:10px; margin-top: 4px;">Whitelist: apenas estes mobs ser√£o looteados.</p>
                                
                                <label class="autods-field">
                                    <span>Excluir Nomes</span>
                                    <textarea data-config="ultraFastLoot.filters.excludeNames" data-config-format="csv" data-label="Excluir Loot" placeholder="Deixar vazio para nenhuma exclus√£o. Um por linha. Ex:
Minion
Scout" rows="2"></textarea>
                                </label>
                                <p class="autods-info" style="font-size:10px; margin-top: 4px;">Blacklist: estes mobs ser√£o ignorados.</p>
                                
                            </div>

                            <!-- Tab: Ultra Fast Boss -->
                            <div class="autods-tab-content" data-tab-content="boss">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">üêâ Ultra Fast Boss</h4>
                                <p class="autods-info" style="font-size:11px; margin-bottom: 12px;">‚ö†Ô∏è Navegue para battle.php ou dungeon_battle.php antes de usar. Clique em Start para iniciar.</p>
                                
                                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                    <button type="button" class="autods-btn autods-btn-primary" data-action="boss-start" style="flex: 1; background: linear-gradient(135deg, #4a2a6a 0%, #2a4a6a 100%); border: 1px solid #8af; color: #8af; padding: 8px 12px; border-radius: 4px; cursor: pointer;">‚ñ∂Ô∏è Start</button>
                                    <button type="button" class="autods-btn autods-btn-secondary" data-action="boss-stop" style="flex: 1; background: linear-gradient(135deg, #6a2a2a 0%, #4a3a2a 100%); border: 1px solid #f88; color: #f88; padding: 8px 12px; border-radius: 4px; cursor: pointer;">‚èπÔ∏è Stop</button>
                                    <button type="button" class="autods-btn autods-btn-secondary" data-action="boss-reset" style="flex: 1; background: linear-gradient(135deg, #3a4a2a 0%, #2a4a3a 100%); border: 1px solid #8f8; color: #8f8; padding: 8px 12px; border-radius: 4px; cursor: pointer;">üîÑ Reset</button>
                                </div>
                                
                                <div id="autods-boss-status" style="background: rgba(74, 42, 106, 0.3); padding: 8px; border-radius: 4px; border-left: 3px solid #8af; margin-bottom: 12px; display: none;">
                                    <div style="font-size: 12px; color: #8af; line-height: 1.5;">
                                        <div><strong>Dano:</strong> <span id="autods-boss-damage">0</span></div>
                                        <div><strong>Ataques:</strong> <span id="autods-boss-attacks">0</span></div>
                                        <div><strong>DPS:</strong> <span id="autods-boss-dps">0</span></div>
                                        <div><strong>Po√ß√µes:</strong> <span id="autods-boss-potions">0</span></div>
                                    </div>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Alvo Dano</span>
                                        <input type="number" data-config="ultraFastBoss.targetDamage" data-config-format="int" data-label="Target Damage" min="1000000" step="1000000" value="1000000000" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Skill</span>
                                        <select data-config="ultraFastBoss.skillId" data-config-format="int" data-label="Boss Skill">
                                            <option value="0">Slash (1)</option>
                                            <option value="-1">Power (10)</option>
                                            <option value="-2">Heroic (50)</option>
                                            <option value="-3">Ultimate (100)</option>
                                            <option value="-4">Legendary (200)</option>
                                        </select>
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field autods-field-small">
                                        <span>Ataques //</span>
                                        <input type="number" data-config="ultraFastBoss.parallelAttacks" data-config-format="int" data-label="Parallel" min="1" max="20" value="10" />
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="ultraFastBoss.minDelayBetweenAttacks" data-config-format="int" data-label="Delay" min="10" step="10" value="30" />
                                    </label>
                                </div>
                                
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastBoss.autoPotion" data-label="Auto Potion" data-toast="0" />
                                    <span>üíä Usar Full Stamina Potion automaticamente</span>
                                </label>
                                <p class="autods-info" style="font-size:10px; margin-top: 8px;">Usar Full Stamina Potion (FSP) automaticamente quando stamina acabar.</p>
                            </div>
                            <div class="autods-tab-content" data-tab-content="dungeon">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">‚ö° Ultra Fast Dungeon</h4>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field">
                                        <span>Monstros</span>
                                        <textarea data-config="ultraFastDungeon.monsterNames" data-config-format="csv" data-label="Monstros Dungeon Ultra Fast" placeholder="Um nome por linha. Ex:
Ancient Dragon
Magus" rows="2"></textarea>
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field">
                                        <span>Prioridade</span>
                                        <select data-config="ultraFastDungeon.priorityMode" data-label="Prioridade">
                                            <option value="lowest_damage">‚Üì Dano</option>
                                            <option value="highest_damage">‚Üë Dano</option>
                                            <option value="lowest_hp">‚Üì HP</option>
                                            <option value="highest_hp">‚Üë HP</option>
                                        </select>
                                    </label>
                                    <label class="autods-field">
                                        <span>HP M√≠n</span>
                                        <input type="number" data-config="ultraFastDungeon.minMobHp" data-config-format="int" data-label="HP M√≠n" min="0" step="100000" />
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field">
                                        <span>Ataques por Monstro</span>
                                        <input type="number" data-config="ultraFastDungeon.attacksPerMonster" data-config-format="int" data-label="Ataques" min="1" max="10" />
                                    </label>
                                    <label class="autods-field">
                                        <span>Ataques //</span>
                                        <input type="number" data-config="ultraFastDungeon.maxParallelBattles" data-config-format="int" data-label="Paralelos" min="1" max="20" />
                                    </label>
                                </div>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field">
                                        <span>Delay (ms)</span>
                                        <input type="number" data-config="ultraFastDungeon.delayBetweenBatches" data-config-format="int" data-label="Delay" min="100" step="100" />
                                    </label>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>üß† Smart Damage</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="ultraFastDungeon.useSmartDamage" data-label="Smart Damage" data-toast="0" />
                                        <span>üß† Usar Smart Damage para respeitar limites</span>
                                    </label>
                                    
                                    <div class="autods-field-row">
                                        <label class="autods-field autods-field-small">
                                            <span>Dano Default</span>
                                            <input type="number" data-config="ultraFastDungeon.damageThresholds.default" data-config-format="int" data-label="Default" />
                                        </label>
                                        <label class="autods-field autods-field-small">
                                            <span>Dano Magus</span>
                                            <input type="number" data-config="ultraFastDungeon.damageThresholds.magus" data-config-format="int" data-label="Magus" />
                                        </label>
                                    </div>
                                    
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="ultraFastDungeon.respectExpLimit" data-label="Respect Exp Limit" data-toast="0" />
                                        <span>Nunca exceder 20% HP para full EXP</span>
                                    </label>
                                </div>
                                
                                <div class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastDungeon.checkJoined" data-label="Check Joined" data-toast="0" />
                                    <span>Verificar monstros que j√° entrei</span>
                                </div>
                                <div class="autods-checkbox">
                                    <input type="checkbox" data-config="ultraFastDungeon.checkNotJoined" data-label="Check Not Joined" data-toast="0" />
                                    <span>Verificar monstros que n√£o entrei</span>
                                </div>
                                
                                <p class="autods-info" style="font-size: 11px; margin-top: 12px;">
                                    üí° Stamina m√≠nima compartilhada com Wave.
                                </p>
                            </div>

                            <!-- Tab: Battle -->
                            <div class="autods-tab-content" data-tab-content="battle">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">üó°Ô∏è Battle Config</h4>
                                
                                <div class="autods-subsection">
                                    <h5>üß† Smart Damage</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="battle.smartDamage.enabled" data-label="Smart Damage" data-toast="0" />
                                        <span>Ativar Smart Damage Autom√°tico</span>
                                    </label>
                                    
                                    <div class="autods-skill-grid" style="margin-top: 12px;">
                                        <label class="autods-skill">
                                            <span>Power Slash</span>
                                            <input type="number" data-config="battle.smartDamage.skills.powerSlash.damageLimit" data-config-format="int" data-label="Power Limit" />
                                        </label>
                                        <label class="autods-skill">
                                            <span>Heroic Slash</span>
                                            <input type="number" data-config="battle.smartDamage.skills.heroicSlash.damageLimit" data-config-format="int" data-label="Heroic Limit" />
                                        </label>
                                        <label class="autods-skill">
                                            <span>Ultimate Slash</span>
                                            <input type="number" data-config="battle.smartDamage.skills.ultimateSlash.damageLimit" data-config-format="int" data-label="Ultimate Limit" />
                                        </label>
                                        <label class="autods-skill">
                                            <span>Legendary Slash</span>
                                            <input type="number" data-config="battle.smartDamage.skills.legendarySlash.damageLimit" data-config-format="int" data-label="Legendary Limit" />
                                        </label>
                                    </div>
                                    <p class="autods-info" style="font-size: 10px; margin-top: 8px;">
                                        Smart Damage seleciona skill autom√°tico conforme o dano atual se aproxima dos limites.
                                    </p>
                                </div>
                                
                                <label class="autods-checkbox">
                                    <input type="checkbox" data-config="battle.randomizeDelays" data-label="Randomize Delays" data-toast="0" />
                                    <span>Randomizar delays (anti-bot detection)</span>
                                </label>
                            </div>

                            <!-- Tab: PvP -->
                            <div class="autods-tab-content" data-tab-content="pvp">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">üèÜ PvP (Ultra Fast Mode)</h4>
                                <p class="autods-info" style="font-size:11px; margin-bottom: 12px;">Automa√ß√£o completa de PvP com ataques via API direto.</p>
                                
                                <label class="autods-checkbox" style="background: linear-gradient(135deg, #2a1a3a 0%, #1a2a3a 100%); padding: 8px; border-radius: 6px; border: 1px solid #8af; margin-bottom: 12px;">
                                    <input type="checkbox" data-config="pvp.enabled" data-label="PvP" data-toast="0" />
                                    <span>‚ö° Ativar PvP Automation</span>
                                </label>
                                
                                <div class="autods-field-row">
                                    <label class="autods-field">
                                        <span>Modo</span>
                                        <select data-config="pvp.autoMode" data-label="Modo PvP">
                                            <option value="all">Todas as batalhas</option>
                                            <option value="limited">Limitado</option>
                                        </select>
                                    </label>
                                    <label class="autods-field">
                                        <span>Limite</span>
                                        <input type="number" data-config="pvp.limitedBattles" data-config-format="int" data-label="Limite" min="1" />
                                    </label>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>‚ö° Configura√ß√µes de Combate</h5>
                                    <div class="autods-field-row">
                                        <label class="autods-field">
                                            <span>Skill</span>
                                            <select data-config="pvp.ultraFastConfig.skillId" data-config-format="int" data-label="Skill PvP">
                                                <option value="0">Slash (1 token)</option>
                                                <option value="-1">Power Slash (5 tokens, 10x)</option>
                                            </select>
                                        </label>
                                        <label class="autods-field">
                                            <span>Delay Min (ms)</span>
                                            <input type="number" data-config="pvp.ultraFastConfig.minDelayBetweenAttacks" data-config-format="int" data-label="Delay Min" min="0" max="1000" step="10" />
                                        </label>
                                    </div>
                                    
                                    <label class="autods-checkbox" style="margin-top: 12px; background: linear-gradient(135deg, #1a3a2a 0%, #2a1a3a 100%); padding: 8px; border-radius: 6px; border: 1px solid #8fa;">
                                        <input type="checkbox" data-config="pvp.ultraFastConfig.useSmartRotation" data-label="Smart Rotation" data-toast="0" />
                                        <span>üîÑ Smart Skill Rotation</span>
                                    </label>
                                    
                                    <div id="smartRotationConfig" style="margin-top: 10px; padding: 10px; background: rgba(26, 58, 42, 0.3); border-radius: 6px; border: 1px solid #4a8;">
                                        <div style="font-size: 12px; color: #aaf; margin-bottom: 8px; line-height: 1.4;">
                                            <strong>Configurar Rota√ß√£o:</strong> Skill ID | Qtd
                                        </div>
                                        
                                        <div id="rotationItems" style="max-height: 300px; overflow-y: auto;">
                                            <!-- Items de rota√ß√£o ser√£o inseridos aqui dinamicamente -->
                                        </div>
                                        
                                        <button id="addRotationItem" style="
                                            width: 100%;
                                            margin-top: 8px;
                                            padding: 6px 12px;
                                            background: linear-gradient(135deg, #2a4a2a 0%, #1a3a2a 100%);
                                            border: 1px solid #6a8;
                                            color: #aef;
                                            border-radius: 4px;
                                            cursor: pointer;
                                            font-size: 12px;
                                            font-weight: bold;
                                        ">‚ûï Adicionar Skill</button>
                                    </div>
                                    
                                    <label class="autods-field">
                                        <span>Max Batalhas/Sess√£o</span>
                                        <input type="number" data-config="pvp.ultraFastConfig.maxConsecutiveBattles" data-config-format="int" data-label="Max Batalhas" min="0" />
                                    </label>
                                    <label class="autods-checkbox" style="margin-top: 8px;">
                                        <input type="checkbox" data-config="pvp.ultraFastConfig.autoContinueBattles" data-label="Auto Continue" data-toast="0" />
                                        <span>Auto-iniciar pr√≥xima batalha</span>
                                    </label>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="pvp.ultraFastConfig.autoReturnToLobby" data-label="Auto Return" data-toast="0" />
                                        <span>Auto-retornar ao lobby</span>
                                    </label>
                                </div>
                                
                                <label class="autods-checkbox" style="margin-top: 12px;">
                                    <input type="checkbox" data-config="pvp.autoSurrender" data-label="Auto Surrender" data-toast="0" />
                                    <span>Auto Surrender (HP < 10%)</span>
                                </label>
                                <label class="autods-field autods-field-small">
                                    <span>Limite Surrender (%)</span>
                                    <input type="number" data-config="pvp.autoSurrenderThreshold" data-config-format="int" data-label="Threshold" min="1" max="100" />
                                </label>
                            </div>

                            <!-- Tab: Interface -->
                            <div class="autods-tab-content" data-tab-content="interface">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">‚öôÔ∏è Interface & Config</h4>
                                
                                <div class="autods-subsection">
                                    <h5>üìä Log Floater</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="ui.logFloater.enabled" data-label="Log Floater" data-toast="0" />
                                        <span>Exibir Log Flutuante</span>
                                    </label>
                                    <label class="autods-field">
                                        <span>Posi√ß√£o</span>
                                        <select data-config="ui.logFloater.position" data-label="Log Position">
                                            <option value="bottom-right">Inferior Direita</option>
                                            <option value="bottom-left">Inferior Esquerda</option>
                                            <option value="top-right">Superior Direita</option>
                                            <option value="top-left">Superior Esquerda</option>
                                        </select>
                                    </label>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>üîî Toast Notifications</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="ui.toasts.enabled" data-label="Toasts" data-toast="0" />
                                        <span>Ativar notifica√ß√µes tipo toast</span>
                                    </label>
                                    <label class="autods-field">
                                        <span>Posi√ß√£o</span>
                                        <select data-config="ui.toasts.position" data-label="Toast Position">
                                            <option value="bottom-right">Inferior Direita</option>
                                            <option value="bottom-left">Inferior Esquerda</option>
                                            <option value="top-right">Superior Direita</option>
                                            <option value="top-left">Superior Esquerda</option>
                                        </select>
                                    </label>
                                    <label class="autods-field autods-field-small">
                                        <span>Dura√ß√£o (ms)</span>
                                        <input type="number" data-config="ui.toasts.durationMs" data-config-format="int" data-label="Duration" min="1000" step="500" />
                                    </label>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>üéÄ Floating Helpers</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="floatingHelpers.enabled" data-label="Floating Helpers" data-toast="0" />
                                        <span>Exibir bot√µes flutuantes</span>
                                    </label>
                                    <label class="autods-field">
                                        <span>Posi√ß√£o</span>
                                        <select data-config="floatingHelpers.position" data-label="Helpers Position">
                                            <option value="right">Direita</option>
                                            <option value="left">Esquerda</option>
                                        </select>
                                    </label>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="floatingHelpers.loot.enabled" data-label="Loot" data-toast="0" />
                                        <span>Bot√µes de loot</span>
                                    </label>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>ÔøΩÔ∏è Bloqueador de Imagens</h5>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="imageBlocker.enabled" data-label="Image Blocker" data-toast="0" />
                                        <span>Bloquear imagens (melhora performance)</span>
                                    </label>
                                    <p class="autods-info" style="font-size: 11px; color: #aaa; margin-top: 8px;">
                                        Carrega a p√°gina mais r√°pido bloqueando todas as imagens. Recarregue a p√°gina para ativar.
                                    </p>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>ÔøΩüîê Credenciais de Login</h5>
                                    <p class="autods-info" style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                                        Salve suas credenciais para re-login autom√°tico (opcional).
                                    </p>
                                    <label class="autods-field">
                                        <span>Email/Usu√°rio</span>
                                        <input type="email" data-config="credentials.email" data-label="Email" placeholder="seu@email.com" />
                                    </label>
                                    <label class="autods-field">
                                        <span>Senha</span>
                                        <input type="password" data-config="credentials.password" data-label="Senha" placeholder="‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè" />
                                    </label>
                                    <p class="autods-info" style="font-size: 10px; color: #f88; margin-top: 8px;">
                                        ‚ö†Ô∏è As credenciais s√£o salvas localmente. Nunca compartilhe seu config com outras pessoas.
                                    </p>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>üîß Sistema</h5>
                                    <label class="autods-field">
                                        <span>N√≠vel de Log</span>
                                        <select data-config="core.logLevel" data-label="Log Level">
                                            <option value="debug">Debug</option>
                                            <option value="info">Info</option>
                                            <option value="warn">Aviso</option>
                                            <option value="error">Erro</option>
                                        </select>
                                    </label>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="core.shadowDom" data-label="Shadow DOM" data-toast="0" />
                                        <span>Usar Shadow DOM (isolamento de estilos)</span>
                                    </label>
                                    <label class="autods-checkbox">
                                        <input type="checkbox" data-config="core.unlockAttackButtons" data-label="Unlock Attack Buttons" data-toast="0" />
                                        <span>Sempre desbloquear bot√µes de ataque</span>
                                    </label>
                                </div>
                                
                                <div class="autods-subsection">
                                    <h5>üõí Merchant</h5>
                                    <button id="autods-reset-merchant-schedule" class="autods-button-action" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 13px; transition: all 0.2s;">
                                        üîÑ Resetar Agendamento do Merchant
                                    </button>
                                    <p class="autods-info" style="font-size: 11px; color: #aaa; margin-top: 8px;">
                                        Limpa os timestamps e for√ßa uma nova verifica√ß√£o na pr√≥xima hora.
                                    </p>
                                </div>
                            </div>

                            <!-- Tab: Profiles -->
                            <div class="autods-tab-content" data-tab-content="profiles">
                                <h4 style="margin-bottom: 16px; color: var(--accent-primary);">üìÅ Gerenciador de Perfis</h4>
                                <p class="autods-info" style="font-size: 12px; margin-bottom: 16px;">
                                    Salve e carregue diferentes configura√ß√µes de automa√ß√£o.
                                </p>
                                <div id="autods-profile-manager-container" style="margin-top: 8px;">
                                    <!-- Profile Manager ser√° renderizado aqui -->
                                </div>
                            </div>

                        </div> <!-- fim autods-tabs-content -->
                            
                        </div> <!-- fim autods-tabs-main -->
                            
                    </div>
                </div>
            `;
        },
        cacheElements(container) {
            this.elements = {
                container,
                layout: container.querySelector('.autods-layout'),
                toggles: Array.from(container.querySelectorAll('[data-config]')),
                route: container.querySelector('[data-meta="route"]'),
                version: container.querySelector('[data-meta="version"]'),
                sections: {
                    configs: container.querySelector('[data-section="configs"]'),
                    automation: container.querySelector('[data-section="automation"]'),
                    events: container.querySelector('[data-section="events"]')
                },
                sectionBodies: {
                    configs: container.querySelector('[data-section-body="configs"]'),
                    automation: container.querySelector('[data-section-body="automation"]'),
                    events: container.querySelector('[data-section-body="events"]')
                },
                sectionToggles: {
                    configs: container.querySelector('[data-section-toggle="configs"]'),
                    automation: container.querySelector('[data-section-toggle="automation"]'),
                    events: container.querySelector('[data-section-toggle="events"]')
                },
                log: container.querySelector('#autods-status-log'),
                toolbar: this.toolbar || null,
                toolbarLinks: this.toolbarLinks || null
            };
        },
        bind(context) {
            if (this.bound) return;
            this.bound = true;

            console.log('[UIShell] bind() called - setting up event listeners');
            console.log('[UIShell] container:', this.elements.container);

            this.elements.container.addEventListener('change', event => {
                const target = event.target;
                if (!(target instanceof HTMLInputElement || target instanceof HTMLSelectElement || target instanceof HTMLTextAreaElement)) return;
                if (!target.dataset.config) return;
                this.onConfigInputChange(context, target);
            });

            // Handle range input live updates
            this.elements.container.addEventListener('input', event => {
                const target = event.target;
                if (target instanceof HTMLInputElement && target.type === 'range') {
                    // Find associated output element
                    const outputId = target.id ? `${target.id}-output` : null;
                    const output = outputId ? this.elements.container.querySelector(`#${outputId}`) : target.nextElementSibling;
                    
                    if (output && output.tagName === 'OUTPUT') {
                        const format = target.dataset.configFormat || '';
                        const precision = parseInt(target.dataset.configPrecision || '0', 10);
                        let displayValue = target.value;
                        
                        if (format === 'percent') {
                            displayValue = `${displayValue}%`;
                        } else if (precision > 0) {
                            displayValue = parseFloat(target.value).toFixed(precision);
                        }
                        
                        output.textContent = displayValue;
                    }
                }
            });

            this.elements.container.addEventListener('click', event => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) return;
                console.log('[UIShell] Click event:', target.tagName, target.className, target.dataset.action);
                
                // Debug: Log boss button clicks specifically
                if (target.dataset.action?.includes('boss') || target.closest('[data-action*="boss"]')) {
                    console.log('[UIShell] üêâ Boss button detected! Action:', target.dataset.action);
                    console.log('[UIShell] Target element:', target);
                    console.log('[UIShell] Closest selector match:', target.closest('[data-action]'));
                }

                // Handle main tabs (R√°pido, Farm, Dungeon, Battle, PvP, Interface)
                const mainTab = target.closest('.autods-tabs-main .autods-tab');
                if (mainTab) {
                    event.preventDefault();
                    const tabName = mainTab.dataset.tab;
                    
                    // Update active tab button
                    this.elements.container.querySelectorAll('.autods-tabs-main .autods-tab').forEach(t => {
                        t.classList.toggle('active', t === mainTab);
                    });
                    
                    // Update active tab content
                    this.elements.container.querySelectorAll('.autods-tab-content').forEach(c => {
                        c.style.display = c.dataset.tabContent === tabName ? 'block' : 'none';
                    });
                    
                    // Save state
                    const cfg = context.config.get();
                    const patch = createPatchFromPath('ui.activeTab', tabName);
                    context.config.update(patch);
                    return;
                }

                // Handle dropdown toggles
                const toggleBtn = target.closest('[data-toggle]');
                if (toggleBtn) {
                    event.preventDefault();
                    const groupId = toggleBtn.dataset.toggle;
                    const content = this.elements.container.querySelector(`[data-content="${groupId}"]`);
                    if (content) {
                        const isOpen = content.style.display !== 'none';
                        
                        // Toggle state
                        content.style.display = isOpen ? 'none' : 'block';
                        toggleBtn.classList.toggle('active', !isOpen);
                        
                        // Save state in config
                        const currentConfig = context.config.get();
                        const currentStates = currentConfig.ui?.dropdownStates || {};
                        currentStates[groupId] = !isOpen;
                        const patch = createPatchFromPath('ui.dropdownStates', currentStates);
                        context.config.update(patch);
                        
                        // context.logger.debug(`[UI] Dropdown "${groupId}" ${!isOpen ? 'aberto' : 'fechado'}, estado salvo`);
                    }
                    return;
                }
                
                // Handle tabs
                const tab = target.closest('.autods-tab');
                if (tab) {
                    event.preventDefault();
                    const tabName = tab.dataset.tab;
                    const parent = tab.closest('.autods-dropdown-content');
                    if (parent) {
                        // Update active tab
                        parent.querySelectorAll('.autods-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        
                        // Update content
                        parent.querySelectorAll('.autods-tab-content').forEach(c => c.classList.remove('active'));
                        const targetContent = parent.querySelector(`[data-tab-content="${tabName}"]`);
                        if (targetContent) {
                            targetContent.classList.add('active');
                        }
                    }
                    return;
                }

                // Close panel button
                if (target.matches('[data-action="close-panel"]') || target.closest('[data-action="close-panel"]')) {
                    event.preventDefault();
                    const shell = this.elements.container; // container IS the #autods-shell
                    if (shell) {
                        const isCollapsed = shell.getAttribute('data-mobile-collapsed') === '1';

                        if (isCollapsed) {
                            // Reabrir painel
                            shell.setAttribute('data-mobile-collapsed', '0');
                            document.body.classList.add('autods-layout-ready');
                            document.body.classList.add('autods-shell-open');
                            if (window.innerWidth <= 480) {
                                document.body.classList.add('autods-panel-visible');
                            }
                            // Update mobile toggle button if it exists
                            if (this.mobileToggleButton) {
                                this.mobileToggleButton.textContent = '‚úï';
                                this.mobileToggleButton.setAttribute('aria-label', 'Fechar painel');
                            }
                            // Hide desktop toggle button
                            if (this.desktopToggleButton) {
                                this.desktopToggleButton.classList.remove('visible');
                            }
                        } else {
                            // Minimizar painel
                            shell.setAttribute('data-mobile-collapsed', '1');
                            document.body.classList.remove('autods-layout-ready');
                            document.body.classList.remove('autods-shell-open');
                            if (window.innerWidth <= 480) {
                                document.body.classList.remove('autods-panel-visible');
                            }
                            // Update mobile toggle button if it exists
                            if (this.mobileToggleButton) {
                                this.mobileToggleButton.textContent = '‚ò∞';
                                this.mobileToggleButton.setAttribute('aria-label', 'Abrir painel');
                            }
                            // Show desktop toggle button (only on desktop)
                            if (this.desktopToggleButton && window.innerWidth > 480) {
                                this.desktopToggleButton.classList.add('visible');
                            }
                            this.showToast(context, 'info', 'Painel minimizado', 'Pressione Ctrl+Shift+P ou clique no bot√£o flutuante para reabrir.');
                        }
                    }
                    return;
                }

                const sectionToggle = target.closest('[data-section-toggle]');
                if (sectionToggle) {
                    event.preventDefault();
                    const sectionId = sectionToggle.getAttribute('data-section-toggle');
                    this.toggleSection(context, sectionId);
                    return;
                }

                if (target.matches('[data-action="toggle-log-view"]') || target.closest('[data-action="toggle-log-view"]')) {
                    event.preventDefault();
                    this.state.logViewExpanded = !this.state.logViewExpanded;
                    const btn = target.matches('[data-action="toggle-log-view"]') ? target : target.closest('[data-action="toggle-log-view"]');
                    btn.textContent = this.state.logViewExpanded ? 'üîº' : 'üëÅÔ∏è';
                    btn.title = this.state.logViewExpanded ? 'Mostrar menos' : 'Mostrar todos';
                    this.render(context);
                }

                // Smart Rotation: Add rotation item
                if (target.id === 'addRotationItem' || target.closest('#addRotationItem')) {
                    event.preventDefault();
                    const cfg = context.config.get();
                    const pattern = cfg.pvp?.ultraFastConfig?.smartRotationPattern || [];
                    
                    // Add new item
                    const newItem = { skill: 0, count: 1 };
                    pattern.push(newItem);
                    
                    // Save to config
                    const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', pattern);
                    context.config.update(patch);
                    
                    // Re-render the rotation items
                    this.renderSmartRotationItems(context);
                    return;
                }

                // Smart Rotation: Remove rotation item
                const removeBtn = target.closest('[data-rotation-remove]');
                if (removeBtn) {
                    event.preventDefault();
                    const index = parseInt(removeBtn.dataset.rotationRemove, 10);
                    const cfg = context.config.get();
                    const pattern = cfg.pvp?.ultraFastConfig?.smartRotationPattern || [];
                    
                    pattern.splice(index, 1);
                    if (pattern.length === 0) {
                        pattern.push({ skill: 0, count: 1 });
                    }
                    
                    const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', pattern);
                    context.config.update(patch);
                    
                    this.renderSmartRotationItems(context);
                    return;
                }

                // Smart Rotation: Change skill or count
                const rotationSelect = target.closest('[data-rotation-skill]');
                if (rotationSelect && target.dataset.rotationSkill) {
                    event.preventDefault();
                    const index = parseInt(target.dataset.rotationSkill, 10);
                    const cfg = context.config.get();
                    const pattern = cfg.pvp?.ultraFastConfig?.smartRotationPattern || [];
                    
                    if (pattern[index]) {
                        pattern[index].skill = parseInt(target.value, 10);
                        const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', pattern);
                        context.config.update(patch);
                    }
                    return;
                }

                const rotationCount = target.closest('[data-rotation-count]');
                if (rotationCount && target.dataset.rotationCount) {
                    event.preventDefault();
                    const index = parseInt(target.dataset.rotationCount, 10);
                    const cfg = context.config.get();
                    const pattern = cfg.pvp?.ultraFastConfig?.smartRotationPattern || [];
                    
                    if (pattern[index]) {
                        pattern[index].count = parseInt(target.value, 10) || 1;
                        const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', pattern);
                        context.config.update(patch);
                    }
                    return;
                }

                // Ultra Fast Boss controls
                if (target.matches('[data-action="boss-start"]') || target.closest('[data-action="boss-start"]')) {
                    event.preventDefault();
                    console.log('[UI] ‚úÖ Boss START button handler triggered!');
                    context.logger.info('[UI] üêâ Iniciando Ultra Fast Boss...');
                    this.startUltraFastBoss(context);
                    return;
                }

                if (target.matches('[data-action="boss-stop"]') || target.closest('[data-action="boss-stop"]')) {
                    event.preventDefault();
                    console.log('[UI] ‚úÖ Boss STOP button handler triggered!');
                    context.logger.info('[UI] üõë Parando Ultra Fast Boss...');
                    this.stopUltraFastBoss(context);
                    return;
                }

                if (target.matches('[data-action="boss-reset"]') || target.closest('[data-action="boss-reset"]')) {
                    event.preventDefault();
                    console.log('[UI] ‚úÖ Boss RESET button handler triggered!');
                    context.logger.info('[UI] üîÑ Resetando Ultra Fast Boss...');
                    this.resetUltraFastBoss(context);
                    return;
                }
                
                // Merchant Schedule Reset
                if (target.id === 'autods-reset-merchant-schedule' || target.closest('#autods-reset-merchant-schedule')) {
                    event.preventDefault();
                    context.logger.info('[UI] üîÑ Resetando agendamento do Merchant...');
                    
                    // Clear timestamps
                    context.storage.remove('merchant.lastWeeklyPurchase');
                    context.storage.remove('merchant.nextRetryTime');
                    
                    context.logger.info('‚úÖ Agendamento do Merchant resetado!');
                    context.logger.info('‚è∞ Nova verifica√ß√£o ser√° feita na pr√≥xima hora');
                    context.notifications?.success('Merchant: Agendamento resetado! Pr√≥xima verifica√ß√£o em 1h');
                    
                    return;
                }
            });

            const render = () => this.render(context);
            const addLog = (level, message, timestamp) => this.addLog(level, message, timestamp);

            this.handlers = {
                configUpdated: render,
                farmDisabled: evt => {
                    const reason = evt?.detail?.reason || 'motivo desconhecido';
                    this.state.farm.lastPause = { reason, timestamp: Date.now() };
                    addLog('warn', `Farming pausado: ${reason}`);
                    this.showToast(context, 'warn', 'Farming pausado', reason);
                },
                waveJoin: evt => {
                    const detail = evt?.detail || {};
                    this.state.wave.lastJoin = {
                        monster: detail.monster,
                        hp: detail.hp,
                        timestamp: detail.timestamp || Date.now()
                    };
                    const monster = detail.monster || 'alvo desconhecido';
                    addLog('info', `Wave ingressou em ${monster}`, detail.timestamp);
                    this.showToast(context, 'info', 'Wave', `Entrando em ${monster}.`);
                },
                battleComplete: evt => {
                    const detail = evt?.detail || {};
                    this.state.battle.lastResult = {
                        damage: detail.damage,
                        reason: detail.reason,
                        targetDamage: detail.targetDamage,
                        timestamp: detail.timestamp || Date.now()
                    };
                    const reasonLabel = detail.reason === 'targetDamage' ? 'meta atingida' : 'inimigo derrotado';
                    addLog('success', `Batalha conclu√≠da (${reasonLabel})`, detail.timestamp);
                    this.showToast(context, 'success', 'Batalha PvE', `Conclu√≠da: ${reasonLabel}.`);
                },
                battleBlocked: () => {
                    addLog('warn', 'Limite de batalhas alcan√ßado (5 simult√¢neas).', Date.now());
                    this.showToast(context, 'warn', 'Batalhas bloqueadas', 'Limite de 5 batalhas atingido.');
                },
                battleJoin: evt => {
                    addLog('info', 'Entrando em batalha PvE.', evt?.detail?.timestamp || Date.now());
                },
                pvpStart: evt => {
                    this.state.pvp.inBattle = true;
                    addLog('info', 'PvP: batalha iniciada.', evt?.detail?.timestamp || Date.now());
                    this.showToast(context, 'info', 'PvP', 'Batalha iniciada.');
                },
                pvpEnd: evt => {
                    this.state.pvp.inBattle = false;
                    this.state.pvp.lastResult = { timestamp: evt?.detail?.timestamp || Date.now(), reason: 'completed' };
                    addLog('success', 'PvP: batalha conclu√≠da.', evt?.detail?.timestamp || Date.now());
                    this.showToast(context, 'success', 'PvP', 'Batalha conclu√≠da.');
                },
                pvpSurrender: evt => {
                    this.state.pvp.inBattle = false;
                    this.state.pvp.lastResult = { timestamp: evt?.detail?.timestamp || Date.now(), reason: 'surrender' };
                    addLog('warn', 'PvP: rendi√ß√£o autom√°tica executada.', evt?.detail?.timestamp || Date.now());
                    this.showToast(context, 'warn', 'PvP', 'Rendi√ß√£o autom√°tica executada.');
                },
                ready: evt => {
                    addLog('success', `Automa√ß√£o pronta (v${evt?.detail?.version || SCRIPT_VERSION}).`, Date.now());
                    this.showToast(context, 'success', 'AutoDS', 'Automa√ß√£o inicializada.');
                },
                farmChapter: evt => {
                    const detail = evt?.detail || {};
                    this.state.farmProgress.chapters += 1;
                    const origin = context.location?.origin || 'https://demonicscans.org';
                    const href = detail.href ? new URL(detail.href, origin).pathname : null;
                    addLog('info', 'Cap√≠tulo farm conclu√≠do.', detail.timestamp || Date.now());
                    this.showToast(context, 'info', 'Farming', href ? `Avan√ßando para ${href}.` : 'Cap√≠tulo conclu√≠do.');
                },
                farmLimitReached: evt => {
                    const detail = evt?.detail || {};
                    const reason = detail.reason === 'farm-energy-full' ? 'Energia de farming cheia (1000/1000)' : 'Limite atingido';
                    addLog('warn', `Farming parou: ${reason}`, detail.timestamp || Date.now());
                    this.showToast(context, 'warn', 'Farming', reason);
                },
                waveMaxBattles: evt => {
                    const detail = evt?.detail || {};
                    const count = detail.continueCount || 5;
                    const limit = detail.limit || 5;
                    const interval = Math.round((detail.reloadInterval || 30000) / 1000);
                    addLog('warn', `Batalhas simult√¢neas no limite (${count}/${limit}). Reload em ${interval}s.`, detail.timestamp);
                    this.showToast(context, 'warn', 'Wave', `Limite de batalhas (${count}/${limit}). Aguardando...`);
                },
                waveReloading: evt => {
                    addLog('info', 'Recarregando p√°gina para verificar batalhas dispon√≠veis...', evt?.detail?.timestamp || Date.now());
                }
            };

            context.events.on('autods:config:updated', this.handlers.configUpdated);
            context.events.on('autods:farm:disabled', this.handlers.farmDisabled);
            context.events.on('autods:farm:limit-reached', this.handlers.farmLimitReached);
            context.events.on('autods:wave:join', this.handlers.waveJoin);
            context.events.on('autods:battle:complete', this.handlers.battleComplete);
            context.events.on('autods:battle:blocked', this.handlers.battleBlocked);
            context.events.on('autods:battle:join', this.handlers.battleJoin);
            context.events.on('autods:pvp:battleStart', this.handlers.pvpStart);
            context.events.on('autods:pvp:battleEnd', this.handlers.pvpEnd);
            context.events.on('autods:pvp:surrender', this.handlers.pvpSurrender);
            context.events.on('autods:farm:chapter', this.handlers.farmChapter);
            context.events.on('autods:ready', this.handlers.ready);
        },
        addLog(level, message, timestamp = Date.now()) {
            if (!this.state) return;
            this.state.log.unshift({ level, message, timestamp });

            // Manter at√© MAX_PERSISTENT_LOGS no storage, mas apenas 8 vis√≠veis por padr√£o
            if (this.state.log.length > MAX_PERSISTENT_LOGS) {
                this.state.log = this.state.log.slice(0, MAX_PERSISTENT_LOGS);
            }

            // Auto-render ap√≥s adicionar log para garantir que eventos apare√ßam imediatamente
            if (this._context) {
                this.render(this._context);
            }
        },
        updateStatusIndicators(context) {
            const cfg = context.config.get();
            
            // Wave status
            const waveStatus = this.elements.container.querySelector('[data-status="wave-unified"]');
            if (waveStatus) {
                const active = cfg.wave?.enabled || cfg.dungeonWave?.enabled;
                waveStatus.textContent = active ? '‚úÖ' : '‚≠ï';
                waveStatus.style.background = active ? 'rgba(166, 227, 161, 0.2)' : 'rgba(100, 100, 100, 0.2)';
                waveStatus.style.color = active ? '#a6e3a1' : '#808080';
            }
            
            // Battle status
            const battleStatus = this.elements.container.querySelector('[data-status="battle"]');
            if (battleStatus) {
                const active = cfg.battle?.enabled || cfg.autoBoss?.enabled;
                battleStatus.textContent = active ? '‚úÖ' : '‚≠ï';
                battleStatus.style.background = active ? 'rgba(166, 227, 161, 0.2)' : 'rgba(100, 100, 100, 0.2)';
                battleStatus.style.color = active ? '#a6e3a1' : '#808080';
            }
            
            // PvP status
            const pvpStatus = this.elements.container.querySelector('[data-status="pvp"]');
            if (pvpStatus) {
                const active = cfg.pvp?.enabled;
                pvpStatus.textContent = active ? '‚úÖ' : '‚≠ï';
                pvpStatus.style.background = active ? 'rgba(166, 227, 161, 0.2)' : 'rgba(100, 100, 100, 0.2)';
                pvpStatus.style.color = active ? '#a6e3a1' : '#808080';
            }
            
            // Others status
            const othersStatus = this.elements.container.querySelector('[data-status="others"]');
            if (othersStatus) {
                const active = cfg.farm?.enabled || cfg.floatingHelpers?.enabled || cfg.imageBlock?.enabled;
                othersStatus.textContent = active ? '‚úÖ' : '‚≠ï';
                othersStatus.style.background = active ? 'rgba(166, 227, 161, 0.2)' : 'rgba(100, 100, 100, 0.2)';
                othersStatus.style.color = active ? '#a6e3a1' : '#808080';
            }
        },
        restoreDropdownStates(context) {
            const states = context.config.get().ui?.dropdownStates || {};
            const activeTab = context.config.get().ui?.activeTab || 'quick';
            
            // Restaurar tab principal (R√°pido, Farm, etc)
            const mainTabButtons = this.elements.container.querySelectorAll('.autods-tabs-main .autods-tab');
            mainTabButtons.forEach(btn => {
                if (btn.dataset.tab === activeTab) {
                    btn.classList.add('active');
                    // Show corresponding content
                    this.elements.container.querySelectorAll('.autods-tab-content').forEach(content => {
                        content.style.display = content.dataset.tabContent === activeTab ? 'block' : 'none';
                    });
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Restaurar dropdowns antigos (backward compatibility)
            Object.keys(states).forEach(groupId => {
                const isOpen = states[groupId];
                const toggleBtn = this.elements.container.querySelector(`[data-toggle="${groupId}"]`);
                const content = this.elements.container.querySelector(`[data-content="${groupId}"]`);
                
                if (toggleBtn && content) {
                    content.style.display = isOpen ? 'block' : 'none';
                    toggleBtn.classList.toggle('active', isOpen);
                }
            });
        },
        render(context) {
            if (!this.elements) return;
            const config = context.config.get();
            if (this.elements.route) {
                this.elements.route.textContent = context.location.pathname;
            }
            if (this.elements.version) {
                this.elements.version.textContent = context.version;
            }

            this.syncConfigInputs(config);

            this.applySectionStates(config);
            this.renderConfigs(context, config);
            this.renderToasts(context, config);
            
            // Render smart rotation items if they exist
            this.renderSmartRotationItems(context);
            
            // Update status indicators and restore dropdown states
            this.updateStatusIndicators(context);
            this.restoreDropdownStates(context);

            if (this.elements.log) {
                const list = this.elements.log;
                list.innerHTML = '';
                if (!this.state.log.length) {
                    const empty = document.createElement('li');
                    empty.classList.add('empty');
                    empty.textContent = 'Sem eventos recentes.';
                    list.appendChild(empty);
                } else {
                    const formatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    // Mostrar apenas 8 mais recentes por padr√£o, ou todos se expandido
                    const displayLimit = this.state.logViewExpanded ? this.state.log.length : 8;
                    const logsToShow = this.state.log.slice(0, displayLimit);

                    logsToShow.forEach(entry => {
                        const li = document.createElement('li');
                        li.dataset.level = entry.level;
                        const time = document.createElement('span');
                        time.className = 'time';
                        time.textContent = formatter.format(new Date(entry.timestamp));
                        const message = document.createElement('span');
                        message.className = 'message';
                        message.textContent = entry.message;
                        li.append(time, message);
                        list.appendChild(li);
                    });

                    // Mostrar indicador se h√° mais logs dispon√≠veis
                    if (!this.state.logViewExpanded && this.state.log.length > 8) {
                        const more = document.createElement('li');
                        more.classList.add('empty');
                        more.style.cssText = 'color: rgba(140, 190, 255, 0.8); font-style: italic; cursor: pointer;';
                        more.textContent = `+ ${this.state.log.length - 8} eventos anteriores (clique no üëÅÔ∏è para ver todos)`;
                        more.title = 'Clique no bot√£o üëÅÔ∏è no cabe√ßalho para ver todos os eventos';
                        list.appendChild(more);
                    }
                }
            }
        },
        getConfigValue(config, path) {
            if (!path) return undefined;
            const keys = path.split('.');
            let current = config;
            for (const key of keys) {
                if (current == null) return undefined;
                current = current[key];
            }
            return current;
        },
        toInputDisplayValue(element, value) {
            if (element instanceof HTMLInputElement && element.type === 'checkbox') {
                return Boolean(value);
            }
            const format = element.dataset.configFormat
                || (element instanceof HTMLSelectElement ? 'string'
                : (element instanceof HTMLInputElement && element.type === 'number' ? 'int' : 'string'));

            if (value === undefined || value === null) {
                if (format === 'csv') return '';
                return '';
            }

            const precision = parseInt(element.dataset.configPrecision || '0', 10);

            switch (format) {
                case 'percent': {
                    const scaled = Number(value) * 100;
                    if (!Number.isFinite(scaled)) return '';
                    return scaled.toFixed(Math.max(0, precision));
                }
                case 'minutes': {
                    const minutes = Number(value) / 60000;
                    if (!Number.isFinite(minutes)) return '';
                    return minutes.toFixed(Math.max(0, precision));
                }
                case 'csv':
                    if (Array.isArray(value)) {
                        return value.join('\n');
                    }
                    if (typeof value === 'string') return value;
                    return '';
                case 'float': {
                    const num = Number(value);
                    if (!Number.isFinite(num)) return '';
                    return num.toFixed(Math.max(0, precision || 2));
                }
                case 'string':
                    return String(value ?? '');
                case 'int':
                default: {
                    const num = Number(value);
                    if (!Number.isFinite(num)) return '';
                    return String(Math.round(num));
                }
            }
        },
        syncConfigInputs(config) {
            if (!this.elements?.toggles) return;
            this.elements.toggles.forEach(element => {
                const path = element.dataset.config;
                if (!path) return;
                const value = this.getConfigValue(config, path);
                if (element instanceof HTMLInputElement) {
                    if (element.type === 'checkbox') {
                        element.checked = Boolean(value);
                    } else {
                        const displayValue = this.toInputDisplayValue(element, value);
                        if (displayValue !== undefined) {
                            element.value = displayValue;
                        }
                    }
                } else if (element instanceof HTMLSelectElement || element instanceof HTMLTextAreaElement) {
                    const displayValue = this.toInputDisplayValue(element, value);
                    if (displayValue !== undefined) {
                        element.value = displayValue;
                    }
                }
            });
        },
        parseConfigInput(element) {
            if (element instanceof HTMLInputElement && element.type === 'checkbox') {
                return { value: element.checked };
            }

            const format = element.dataset.configFormat
                || (element instanceof HTMLSelectElement ? 'string'
                : (element instanceof HTMLInputElement && element.type === 'number' ? 'int' : 'string'));
            const raw = element.value?.trim?.() ?? '';
            const normalised = raw.replace(/,/g, '.');

            const ensureBounds = (numericValue) => {
                if (!(element instanceof HTMLInputElement) || element.type !== 'number') return numericValue;
                let value = numericValue;
                if (element.min !== '') {
                    const min = Number(element.min);
                    if (Number.isFinite(min)) {
                        value = Math.max(value, min);
                    }
                }
                if (element.max !== '') {
                    const max = Number(element.max);
                    if (Number.isFinite(max)) {
                        value = Math.min(value, max);
                    }
                }
                return value;
            };

            switch (format) {
                case 'percent': {
                    if (!raw && element.dataset.allowEmpty === '1') {
                        return { value: null };
                    }
                    const parsed = Number(normalised);
                    if (!Number.isFinite(parsed)) {
                        return { error: 'Valor percentual inv√°lido.' };
                    }
                    const bounded = Math.max(0, Math.min(100, parsed));
                    return { value: bounded / 100 };
                }
                case 'minutes': {
                    if (!raw && element.dataset.allowEmpty === '1') {
                        return { value: null };
                    }
                    const parsed = Number(normalised);
                    if (!Number.isFinite(parsed)) {
                        return { error: 'Valor em minutos inv√°lido.' };
                    }
                    let fixed = Math.max(0, parsed);
                    if (element instanceof HTMLInputElement) {
                        if (element.min !== '') {
                            const min = Number(element.min);
                            if (Number.isFinite(min)) {
                                fixed = Math.max(fixed, min);
                            }
                        }
                        if (element.max !== '') {
                            const max = Number(element.max);
                            if (Number.isFinite(max)) {
                                fixed = Math.min(fixed, max);
                            }
                        }
                    }
                    return { value: fixed * 60000 };
                }
                case 'csv': {
                    if (!raw) return { value: [] };
                    const entries = raw
                        .split(/[\n,]+/)
                        .map(name => name.trim())
                        .filter(name => name.length > 0);
                    return { value: entries };
                }
                case 'float': {
                    const parsed = Number(normalised);
                    if (!Number.isFinite(parsed)) {
                        return { error: 'Valor num√©rico inv√°lido.' };
                    }
                    return { value: ensureBounds(parsed) };
                }
                case 'int': {
                    if (!raw && element.dataset.allowEmpty === '1') {
                        return { value: null };
                    }
                    const parsed = Number.parseInt(normalised, 10);
                    if (!Number.isFinite(parsed)) {
                        return { error: 'Valor inteiro inv√°lido.' };
                    }
                    return { value: ensureBounds(parsed) };
                }
                case 'string':
                default:
                    return { value: raw };
            }
        },
        describeInputValue(element, value) {
            if (element instanceof HTMLInputElement && element.type === 'checkbox') {
                return value ? 'ativado' : 'desativado';
            }

            const format = element.dataset.configFormat
                || (element instanceof HTMLSelectElement ? 'string'
                : (element instanceof HTMLInputElement && element.type === 'number' ? 'int' : 'string'));
            const precision = parseInt(element.dataset.configPrecision || '0', 10);

            switch (format) {
                case 'percent': {
                    if (value == null) return '';
                    return `${(Number(value) * 100).toFixed(Math.max(0, precision))}%`;
                }
                case 'minutes': {
                    if (value == null) return '';
                    const minutes = Number(value) / 60000;
                    if (!Number.isFinite(minutes)) return '';
                    return `${minutes.toFixed(Math.max(0, precision))} min`;
                }
                case 'csv': {
                    if (!value || !value.length) return 'lista vazia';
                    if (Array.isArray(value)) return value.join(', ');
                    return String(value);
                }
                case 'int':
                case 'float':
                    if (value == null) return '';
                    return String(value);
                case 'string':
                default:
                    return value ? String(value) : '';
            }
        },
        updateConfigValue(context, path, value, logMessage) {
            if (!path) return;
            const currentConfig = context.config.get();
            const patch = createPatchFromPath(path, value);
            const preview = deepMerge(currentConfig, patch);
            this.syncConfigInputs(preview);
            context.config.update(patch);
            if (logMessage) {
                this.addLog('info', logMessage, Date.now());
                // render() n√£o √© mais necess√°rio aqui, addLog() j√° renderiza automaticamente
            }
            context.moduleRegistry?.activateFor(context);
        },
        onConfigInputChange(context, element) {
            const path = element.dataset.config;
            if (!path) return;
            const { value, error } = this.parseConfigInput(element);
            if (error) {
                element.classList.add('invalid');
                this.showToast(context, 'error', 'Configura√ß√µes', error);
                this.syncConfigInputs(context.config.get());
                if (typeof element.focus === 'function') {
                    element.focus();
                    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
                        element.select?.();
                    }
                }
                return;
            }

            if (element.classList.contains('invalid')) {
                element.classList.remove('invalid');
            }

            const label = element.dataset.label || path;
            const description = this.describeInputValue(element, value);
            const isToggle = element instanceof HTMLInputElement && element.type === 'checkbox';
            const message = isToggle
                ? `${label} ${description}`
                : `${label} atualizado${description ? ` (${description})` : ''}`;

            this.updateConfigValue(context, path, value, message);

            if (element.dataset.toast !== '0') {
                this.showToast(context, 'success', 'Configura√ß√µes', message);
            }
        },
        toggleSection(context, sectionId) {
            if (!sectionId) return;
            const currentConfig = context.config.get();
            const nextState = !Boolean(currentConfig.ui?.panelStates?.[sectionId]);
            const patch = createPatchFromPath(`ui.panelStates.${sectionId}`, nextState);
            const preview = deepMerge(currentConfig, patch);
            this.applySectionStates(preview);
            context.config.update(patch);
        },
        createToastContainer(host, context) {
            if (!host) return;
            if (this.toastTimers && this.toastTimers.size) {
                this.toastTimers.forEach(timer => context.window?.clearTimeout?.(timer));
                this.toastTimers.clear();
            }
            host.innerHTML = '';
            const container = document.createElement('div');
            container.className = 'autods-toast-container';
            host.appendChild(container);
            this.toastRoot = host;
            this.toastContainer = container;
            this.toastTimers = new Map();
            this.updateToastPosition(context);
        },
        updateToastPosition(context, config) {
            const container = this.toastContainer;
            if (!container) return;
            const effectiveConfig = config || context.config.get();
            const position = effectiveConfig.ui?.toasts?.position || 'bottom-right';
            container.style.top = '';
            container.style.bottom = '';
            container.style.left = '';
            container.style.right = '';
            switch (position) {
                case 'top-left':
                    container.style.top = '16px';
                    container.style.left = '16px';
                    break;
                case 'top-right':
                    container.style.top = '16px';
                    container.style.right = '16px';
                    break;
                case 'bottom-left':
                    container.style.bottom = '16px';
                    container.style.left = '16px';
                    break;
                case 'bottom-right':
                default:
                    container.style.bottom = '16px';
                    container.style.right = '16px';
                    break;
            }
        },
        removeToast(context, toastId) {
            if (!this.state?.toasts) return;
            const index = this.state.toasts.findIndex(toast => toast.id === toastId);
            if (index >= 0) {
                this.state.toasts.splice(index, 1);
            }
            if (this.toastTimers && this.toastTimers.has(toastId)) {
                const timer = this.toastTimers.get(toastId);
                context.window?.clearTimeout?.(timer);
                this.toastTimers.delete(toastId);
            }
            this.renderToasts(context);
        },
        showToast(context, level = 'info', title = '', message = '', options = {}) {
            const config = context.config.get();
            if (!config.ui?.toasts?.enabled) return;
            if (!this.toastContainer) {
                this.createToastContainer(context.ui.shadow.querySelector('#autods-toast-root'), context);
            }
            const now = Date.now();
            const duration = Math.max(0, options.durationMs ?? config.ui?.toasts?.durationMs ?? 4500);
            const toast = {
                id: `toast-${now}-${Math.random().toString(16).slice(2)}`,
                level,
                title,
                message,
                createdAt: now,
                expiresAt: duration ? now + duration : null
            };
            this.state.toasts = [toast, ...(this.state.toasts || [])].slice(0, 6);
            this.renderToasts(context, config);

            if (duration && context.window?.setTimeout) {
                this.toastTimers = this.toastTimers || new Map();
                const timerId = context.window.setTimeout(() => {
                    this.removeToast(context, toast.id);
                }, duration + 10);
                this.toastTimers.set(toast.id, timerId);
            }
        },
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ULTRA FAST BOSS METHODS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        ultraFastBossState: {
            running: false,
            battleId: null,
            targetDamage: 0,
            skillId: -2,
            autoPotion: true,
            startTime: null,
            attackCount: 0,
            totalDamageDealt: 0,
            currentDamage: 0,
            potionsUsed: 0,
            currentStamina: 0,
            fullPotionInvId: null,
            fullPotionCount: 0
        },
        
        ultraFastBossConfig: {
            attackEndpoint: 'https://demonicscans.org/damage.php',
            potionEndpoint: 'https://demonicscans.org/use_item.php',
            skillCosts: { '0': 1, '-1': 10, '-2': 50, '-3': 100, '-4': 200 },
            skillNames: { '0': 'Slash', '-1': 'Power Slash', '-2': 'Heroic Slash', '-3': 'Ultimate Slash', '-4': 'Legendary Slash' }
        },
        
        /**
         * Render smart rotation items dynamically
         */
        renderSmartRotationItems(context) {
            const container = this.elements?.container;
            if (!container) return;
            
            const cfg = context.config.get();
            const pattern = cfg.pvp?.ultraFastConfig?.smartRotationPattern || [];
            const rotationItemsContainer = container.querySelector('#rotationItems');
            
            if (!rotationItemsContainer) return;
            
            // Clear existing items
            rotationItemsContainer.innerHTML = '';
            
            // Render each item
            pattern.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.style.cssText = `
                    display: grid;
                    grid-template-columns: 1fr 1fr auto;
                    gap: 6px;
                    margin-bottom: 8px;
                    padding: 8px;
                    background: rgba(26, 42, 58, 0.3);
                    border: 1px solid #4a8;
                    border-radius: 4px;
                    align-items: center;
                `;
                
                // Skill input (text input for custom skill numbers)
                const skillInput = document.createElement('input');
                skillInput.type = 'text';
                skillInput.style.cssText = `
                    padding: 4px;
                    background: rgba(26, 42, 58, 0.8);
                    color: #aef;
                    border: 1px solid #4a8;
                    border-radius: 3px;
                    font-size: 11px;
                    width: 100%;
                `;
                skillInput.placeholder = 'ID do Skill';
                skillInput.value = item.skill;
                skillInput.dataset.rotationSkill = index;
                skillInput.addEventListener('blur', () => {
                    const value = parseInt(skillInput.value, 10);
                    if (!isNaN(value)) {
                        const newPattern = [...pattern];
                        newPattern[index].skill = value;
                        const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', newPattern);
                        context.config.update(patch);
                    }
                });
                
                // Count input
                const countInput = document.createElement('input');
                countInput.type = 'text';
                countInput.style.cssText = `
                    padding: 4px;
                    background: rgba(26, 42, 58, 0.8);
                    color: #aef;
                    border: 1px solid #4a8;
                    border-radius: 3px;
                    font-size: 11px;
                    width: 100%;
                `;
                countInput.placeholder = 'Qtd';
                countInput.value = item.count;
                countInput.dataset.rotationCount = index;
                countInput.addEventListener('blur', () => {
                    const value = parseInt(countInput.value, 10);
                    if (!isNaN(value) && value > 0) {
                        const newPattern = [...pattern];
                        newPattern[index].count = value;
                        const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', newPattern);
                        context.config.update(patch);
                    }
                });
                
                // Remove button
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'üóëÔ∏è';
                removeBtn.style.cssText = `
                    padding: 4px 8px;
                    background: rgba(139, 42, 42, 0.5);
                    border: 1px solid #a44;
                    color: #faa;
                    border-radius: 3px;
                    cursor: pointer;
                    font-size: 12px;
                    min-width: 36px;
                `;
                removeBtn.dataset.rotationRemove = index;
                removeBtn.addEventListener('click', () => {
                    const newPattern = pattern.filter((_, i) => i !== index);
                    if (newPattern.length === 0) {
                        newPattern.push({ skill: 0, count: 1 });
                    }
                    const patch = createPatchFromPath('pvp.ultraFastConfig.smartRotationPattern', newPattern);
                    context.config.update(patch);
                    this.renderSmartRotationItems(context);
                });
                
                itemEl.appendChild(skillInput);
                itemEl.appendChild(countInput);
                itemEl.appendChild(removeBtn);
                rotationItemsContainer.appendChild(itemEl);
            });
        },
        
        startUltraFastBoss(context) {
            if (this.ultraFastBossState.running) {
                this.showToast(context, 'warn', 'Ultra Fast Boss', 'J√° est√° em execu√ß√£o!');
                return;
            }
            
            // Check if on battle page (battle.php or dungeon_battle.php)
            const url = new URL(window.location.href);
            const pathname = window.location.pathname;
            const isBattlePage = /battle\.php$/i.test(pathname) || /dungeon_battle\.php$/i.test(pathname);
            
            // Get battle ID from various possible params
            let battleId = url.searchParams.get('id') || url.searchParams.get('dgmid') || url.searchParams.get('monster_id');
            const instanceId = url.searchParams.get('instance_id');
            
            // Detect battle type
            const isDungeon = /dungeon_battle\.php/i.test(pathname) || url.searchParams.has('dgmid') || url.searchParams.has('instance_id');
            
            if (!battleId || !isBattlePage) {
                this.showToast(context, 'error', 'Ultra Fast Boss', 'Navegue at√© battle.php ou dungeon_battle.php primeiro!');
                return;
            }
            
            // Check if boss ID changed - reset counters if so
            const previousBossId = this.ultraFastBossState.battleId;
            if (previousBossId && previousBossId !== battleId) {
                this.addLog('info', `üîÑ Boss ID mudou (${previousBossId} ‚Üí ${battleId}), resetando contadores...`);
            }
            
            // Get config
            const cfg = context.config.get().ultraFastBoss || {};
            
            // Initialize state (reset counters if boss changed)
            const keepCounters = previousBossId === battleId;
            this.ultraFastBossState = {
                running: true,
                battleId: battleId,
                instanceId: instanceId,
                isDungeon: isDungeon,
                targetDamage: cfg.targetDamage || 1000000000,
                skillId: cfg.skillId ?? -2,
                autoPotion: cfg.autoPotion !== false,
                parallelAttacks: cfg.parallelAttacks || 10,
                minDelay: cfg.minDelayBetweenAttacks || 30,
                startTime: keepCounters ? (this.ultraFastBossState.startTime || Date.now()) : Date.now(),
                attackCount: keepCounters ? (this.ultraFastBossState.attackCount || 0) : 0,
                totalDamageDealt: keepCounters ? (this.ultraFastBossState.totalDamageDealt || 0) : 0,
                currentDamage: context.numbers.parse(document.querySelector('#yourDamageValue')?.textContent) || 0,
                potionsUsed: keepCounters ? (this.ultraFastBossState.potionsUsed || 0) : 0,
                healsUsed: keepCounters ? (this.ultraFastBossState.healsUsed || 0) : 0,
                currentStamina: 0,
                fullPotionInvId: null,
                fullPotionCount: 0
            };
            
            const battleType = isDungeon ? 'üè∞ Dungeon Boss' : 'üêâ Boss';
            this.showToast(context, 'success', 'Ultra Fast Boss', `${battleType} iniciando! Alvo: ${context.numbers.formatCompact(this.ultraFastBossState.targetDamage)}`);
            this.addLog('info', `${battleType} iniciado - Alvo: ${context.numbers.formatCompact(this.ultraFastBossState.targetDamage)}, ID: ${battleId}${instanceId ? ', Instance: ' + instanceId : ''}`);
            
            // Update UI
            this.updateBossStatusUI(context);
            
            // Start the main loop
            this.runUltraFastBossLoop(context);
        },
        
        stopUltraFastBoss(context) {
            if (!this.ultraFastBossState.running) {
                this.showToast(context, 'warn', 'Ultra Fast Boss', 'N√£o est√° em execu√ß√£o!');
                return;
            }
            
            this.ultraFastBossState.running = false;
            
            const elapsed = ((Date.now() - this.ultraFastBossState.startTime) / 1000).toFixed(1);
            const dps = this.ultraFastBossState.totalDamageDealt / (elapsed || 1);
            
            this.showToast(context, 'info', 'Ultra Fast Boss', `Parado! Dano: ${context.numbers.formatCompact(this.ultraFastBossState.currentDamage)}, DPS: ${context.numbers.formatCompact(dps)}/s`);
            this.addLog('warn', `üõë Ultra Fast Boss parado - Dano: ${context.numbers.formatCompact(this.ultraFastBossState.currentDamage)}, Ataques: ${this.ultraFastBossState.attackCount}, Po√ß√µes: ${this.ultraFastBossState.potionsUsed}`);
            
            this.updateBossStatusUI(context);
        },
        
        resetUltraFastBoss(context) {
            // Stop if running
            if (this.ultraFastBossState.running) {
                this.ultraFastBossState.running = false;
            }
            
            // Clear sessionStorage
            sessionStorage.removeItem('UltraFastBoss_Progress');
            
            // Reset state completely
            this.ultraFastBossState = {
                running: false,
                battleId: null,
                instanceId: null,
                isDungeon: false,
                targetDamage: 0,
                skillId: -2,
                autoPotion: true,
                parallelAttacks: 10,
                minDelay: 30,
                startTime: null,
                attackCount: 0,
                totalDamageDealt: 0,
                currentDamage: 0,
                potionsUsed: 0,
                healsUsed: 0,
                currentStamina: 0,
                fullPotionInvId: null,
                fullPotionCount: 0
            };
            
            // Update UI to show reset state
            const { shadow } = context.ui;
            const statusDiv = shadow.querySelector('#autods-boss-status');
            if (statusDiv) statusDiv.style.display = 'none';
            
            this.showToast(context, 'success', 'Ultra Fast Boss', 'Contadores resetados!');
            this.addLog('info', 'üîÑ Ultra Fast Boss - Contadores resetados');
        },
        
        async runUltraFastBossLoop(context) {
            const state = this.ultraFastBossState;
            const cfg = this.ultraFastBossConfig;
            
            // Get initial data
            state.currentStamina = context.numbers.parse(document.querySelector('#stamina_span')?.textContent) || 0;
            const potionBtn = document.querySelector('button.potion-use-btn[data-item="35"]');
            if (potionBtn) {
                state.fullPotionInvId = potionBtn.dataset.inv;
                state.fullPotionCount = parseInt(potionBtn.dataset.max || '0', 10);
            }
            
            const skillCost = cfg.skillCosts[state.skillId.toString()] || 1;
            
            while (state.running) {
                // Check player HP - if dead, need heal potion
                const playerHP = this.getPlayerHP(context);
                if (playerHP.current <= 0) {
                    this.addLog('warn', 'üíÄ HP zerado! Tentando usar Heal Potion...');
                    const healResult = await this.useHealPotion(context);
                    
                    if (healResult.success) {
                        state.healsUsed++;
                        
                        // Page will likely reload after heal - save progress
                        const progress = {
                            battleId: state.battleId,
                            instanceId: state.instanceId,
                            isDungeon: state.isDungeon,
                            targetDamage: state.targetDamage,
                            skillId: state.skillId,
                            autoPotion: state.autoPotion,
                            parallelAttacks: state.parallelAttacks,
                            minDelay: state.minDelay,
                            currentDamage: state.currentDamage,
                            totalDamageDealt: state.totalDamageDealt,
                            attackCount: state.attackCount,
                            potionsUsed: state.potionsUsed,
                            healsUsed: state.healsUsed,
                            startTime: state.startTime,
                            autoResume: true
                        };
                        sessionStorage.setItem('UltraFastBoss_Progress', JSON.stringify(progress));
                        
                        // Wait for server to process, then reload
                        await sleep(500);
                        window.location.href = window.location.href;
                        return;
                    } else {
                        this.showToast(context, 'error', 'Ultra Fast Boss', 'HP zerado e sem Heal Potions!');
                        this.addLog('error', '‚ùå N√£o foi poss√≠vel usar Heal Potion - parando');
                        state.running = false;
                        break;
                    }
                }
                
                // Check target reached
                if (state.currentDamage >= state.targetDamage) {
                    this.showToast(context, 'success', 'üéâ Ultra Fast Boss', `META ATINGIDA! ${context.numbers.formatCompact(state.currentDamage)}`);
                    this.addLog('success', `üéâ Ultra Fast Boss - META ATINGIDA: ${context.numbers.formatCompact(state.currentDamage)}`);
                    state.running = false;
                    break;
                }
                
                // Check stamina
                if (state.currentStamina < skillCost) {
                    if (!state.autoPotion) {
                        this.showToast(context, 'warn', 'Ultra Fast Boss', 'Stamina esgotada! Sem po√ß√µes configuradas.');
                        state.running = false;
                        break;
                    }
                    
                    // Use potion and reload
                    this.addLog('info', 'üíä Usando Full Stamina Potion...');
                    const potionResult = await this.useBossPotion(context);
                    
                    if (potionResult.success) {
                        state.potionsUsed++;
                        
                        // Save progress and reload
                        const progress = {
                            battleId: state.battleId,
                            instanceId: state.instanceId,
                            isDungeon: state.isDungeon,
                            targetDamage: state.targetDamage,
                            skillId: state.skillId,
                            autoPotion: state.autoPotion,
                            parallelAttacks: state.parallelAttacks,
                            minDelay: state.minDelay,
                            currentDamage: state.currentDamage,
                            totalDamageDealt: state.totalDamageDealt,
                            attackCount: state.attackCount,
                            potionsUsed: state.potionsUsed,
                            healsUsed: state.healsUsed,
                            startTime: state.startTime,
                            autoResume: true
                        };
                        sessionStorage.setItem('UltraFastBoss_Progress', JSON.stringify(progress));
                        
                        this.addLog('info', 'üîÑ Recarregando p√°gina para sincronizar stamina...');
                        window.location.href = window.location.href;
                        return;
                    } else {
                        this.showToast(context, 'error', 'Ultra Fast Boss', 'Falha ao usar po√ß√£o!');
                        state.running = false;
                        break;
                    }
                }
                
                // Calculate attacks
                const possibleAttacks = Math.floor(state.currentStamina / skillCost);
                const attackCount = Math.min(possibleAttacks, state.parallelAttacks);
                
                if (attackCount <= 0) {
                    await sleep(100);
                    continue;
                }
                
                // Execute parallel attacks (pass isDungeon and instanceId for proper endpoint)
                const results = await this.executeBossParallelAttacks(context, state.battleId, state.skillId, attackCount, state.isDungeon, state.instanceId);
                
                state.attackCount += results.successCount;
                state.totalDamageDealt += results.totalDamage;
                state.currentDamage += results.totalDamage;
                state.currentStamina = results.lastStamina !== null ? results.lastStamina : Math.max(0, state.currentStamina - (attackCount * skillCost));
                
                // Update DOM display
                const damageEl = document.querySelector('#yourDamageValue');
                if (damageEl) damageEl.textContent = state.currentDamage.toLocaleString();
                const staminaEl = document.querySelector('#stamina_span');
                if (staminaEl) staminaEl.textContent = Math.max(0, state.currentStamina).toLocaleString();
                
                // Update UI
                this.updateBossStatusUI(context);
                
                await sleep(state.minDelay);
            }
            
            // Final stats
            const elapsed = ((Date.now() - state.startTime) / 1000).toFixed(1);
            const dps = state.totalDamageDealt / (elapsed || 1);
            this.addLog('success', `‚úÖ Ultra Fast Boss finalizado - Dano: ${context.numbers.formatCompact(state.currentDamage)}, DPS: ${context.numbers.formatCompact(dps)}/s, Tempo: ${elapsed}s`);
            
            this.updateBossStatusUI(context);
        },
        
        async executeBossParallelAttacks(context, battleId, skillId, count, isDungeon = false, instanceId = null) {
            // Use centralized combat service for both wave and dungeon attacks
            const attackPromises = Array.from({ length: count }, async () => {
                try {
                    if (isDungeon && instanceId) {
                        return await context.combat.attackDungeonMonsterDirect(battleId, instanceId, skillId);
                    } else {
                        return await context.combat.attackWaveMonsterDirect(battleId, skillId);
                    }
                } catch (error) {
                    return { success: false };
                }
            });
            
            const results = await Promise.all(attackPromises);
            
            let totalDamage = 0, successCount = 0, lastStamina = null;
            for (const r of results) {
                if (r.success) {
                    totalDamage += r.damageDealt || 0;
                    successCount++;
                    if (r.stamina !== undefined) lastStamina = r.stamina;
                }
            }
            
            return { totalDamage, successCount, lastStamina };
        },
        
        async useBossPotion(context) {
            // Use centralized inventory service for Full Stamina Potion
            try {
                const result = await context.inventory.useFullStaminaPotion();
                return { success: result };
            } catch (error) {
                return { success: false };
            }
        },
        
        /**
         * Get current player HP from DOM
         * @returns {{ current: number, max: number }} Player HP
         */
        getPlayerHP(context) {
            // Try #pHpText first: "üíö 27,000 / 44,500 HP"
            const hpText = document.querySelector('#pHpText');
            if (hpText) {
                const text = hpText.textContent || '';
                const match = text.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                if (match) {
                    return {
                        current: context.numbers.parse(match[1]),
                        max: context.numbers.parse(match[2])
                    };
                }
            }
            
            // Fallback to .card-sub: "27,000 / 44,500"
            const cardSub = document.querySelector('.battle-card.player-card .card-sub, .player-card .card-sub');
            if (cardSub) {
                const text = cardSub.textContent || '';
                const match = text.match(/([\d,]+)\s*\/\s*([\d,]+)/);
                if (match) {
                    return {
                        current: context.numbers.parse(match[1]),
                        max: context.numbers.parse(match[2])
                    };
                }
            }
            
            // Fallback: #pHpFill width percentage
            const hpFill = document.querySelector('#pHpFill');
            if (hpFill) {
                const widthStr = hpFill.style.width || '0%';
                const pct = parseFloat(widthStr) || 0;
                // Without max, assume 100% means alive
                return { current: pct > 0 ? 1 : 0, max: 100 };
            }
            
            return { current: 0, max: 0 };
        },
        
        /**
         * Use Heal Potion to restore player HP
         * @returns {Promise<{ success: boolean }>}
         */
        async useHealPotion(context) {
            this.addLog('info', 'üíö Usando Heal Potion...');
            
            // Use centralized inventory service for Heal Potion
            try {
                const result = await context.inventory.useHealPotion();
                if (result) {
                    this.addLog('success', '‚úÖ Heal Potion usada com sucesso!');
                    // Wait for HP to update
                    await sleep(1000);
                    return { success: true };
                } else {
                    this.addLog('warn', '‚ö†Ô∏è Sem Heal Potions dispon√≠veis!');
                    return { success: false };
                }
            } catch (error) {
                this.addLog('error', `‚ùå Erro ao usar heal: ${error.message}`);
                return { success: false };
            }
        },
        
        updateBossStatusUI(context) {
            const state = this.ultraFastBossState;
            const { shadow } = context.ui;
            const { numbers } = context;
            
            const statusDiv = shadow.querySelector('#autods-boss-status');
            if (statusDiv) statusDiv.style.display = 'block';
            
            const runningEl = shadow.querySelector('#autods-boss-running');
            if (runningEl) runningEl.textContent = state.running ? 'üü¢ Executando' : 'üî¥ Parado';
            
            const bossIdEl = shadow.querySelector('#autods-boss-id');
            if (bossIdEl) {
                const typeIcon = state.isDungeon ? 'üè∞' : 'üêâ';
                const idText = state.battleId ? `${typeIcon} ${state.battleId}${state.instanceId ? ' (inst:' + state.instanceId + ')' : ''}` : '-';
                bossIdEl.textContent = idText;
            }
            
            const damageEl = shadow.querySelector('#autods-boss-damage');
            if (damageEl) damageEl.textContent = numbers.formatCompact(state.currentDamage);
            
            const targetEl = shadow.querySelector('#autods-boss-target');
            if (targetEl) targetEl.textContent = numbers.formatCompact(state.targetDamage);
            
            const progressEl = shadow.querySelector('#autods-boss-progress');
            if (progressEl) {
                const pct = state.targetDamage > 0 ? ((state.currentDamage / state.targetDamage) * 100).toFixed(1) : 0;
                progressEl.textContent = `${pct}%`;
            }
            
            const attacksEl = shadow.querySelector('#autods-boss-attacks');
            if (attacksEl) attacksEl.textContent = state.attackCount.toLocaleString();
            
            const potionsEl = shadow.querySelector('#autods-boss-potions');
            if (potionsEl) potionsEl.textContent = state.potionsUsed.toString();
            
            const healsEl = shadow.querySelector('#autods-boss-heals');
            if (healsEl) healsEl.textContent = (state.healsUsed || 0).toString();
        },
        
        checkAndResumeUltraFastBoss(context) {
            const saved = sessionStorage.getItem('UltraFastBoss_Progress');
            if (!saved) return;
            
            try {
                const progress = JSON.parse(saved);
                if (progress.autoResume) {
                    sessionStorage.removeItem('UltraFastBoss_Progress');
                    
                    const battleType = progress.isDungeon ? 'üè∞ Dungeon Boss' : 'üêâ Boss';
                    this.addLog('info', `üîÑ Resumindo ${battleType} ap√≥s reload...`);
                    
                    this.ultraFastBossState = {
                        running: true,
                        battleId: progress.battleId,
                        instanceId: progress.instanceId || null,
                        isDungeon: progress.isDungeon || false,
                        targetDamage: progress.targetDamage,
                        skillId: progress.skillId,
                        autoPotion: progress.autoPotion,
                        parallelAttacks: progress.parallelAttacks || 10,
                        minDelay: progress.minDelay || 30,
                        startTime: progress.startTime,
                        attackCount: progress.attackCount,
                        totalDamageDealt: progress.totalDamageDealt,
                        currentDamage: progress.currentDamage,
                        potionsUsed: progress.potionsUsed,
                        healsUsed: progress.healsUsed || 0,
                        currentStamina: 0,
                        fullPotionInvId: null,
                        fullPotionCount: 0
                    };
                    
                    this.showToast(context, 'info', 'Ultra Fast Boss', 'Resumindo ap√≥s po√ß√£o...');
                    this.updateBossStatusUI(context);
                    this.runUltraFastBossLoop(context);
                }
            } catch (e) {
                sessionStorage.removeItem('UltraFastBoss_Progress');
            }
        },
        
        pruneExpiredToasts() {
            if (!this.state?.toasts?.length) return false;
            const now = Date.now();
            const beforeLength = this.state.toasts.length;
            this.state.toasts = this.state.toasts.filter(toast => toast.expiresAt == null || toast.expiresAt > now);
            return beforeLength !== this.state.toasts.length;
        },
        renderToasts(context, config) {
            const container = this.toastContainer;
            const effectiveConfig = config || context.config.get();
            if (!container || !effectiveConfig.ui) return;

            const enabled = Boolean(effectiveConfig.ui.toasts?.enabled);
            this.updateToastPosition(context, effectiveConfig);

            if (!enabled) {
                container.innerHTML = '';
                container.style.display = 'none';
                return;
            }

            container.style.display = '';
            this.pruneExpiredToasts();

            container.innerHTML = '';
            if (!this.state.toasts.length) {
                return;
            }

            this.state.toasts.forEach(toast => {
                const el = document.createElement('div');
                el.className = 'autods-toast';
                el.dataset.level = toast.level || 'info';

                const body = document.createElement('div');
                body.className = 'body';
                const titleEl = document.createElement('div');
                titleEl.className = 'title';
                titleEl.textContent = toast.title || 'AutoDS';
                const messageEl = document.createElement('div');
                messageEl.className = 'message';
                messageEl.textContent = toast.message || '';
                const timeEl = document.createElement('div');
                timeEl.className = 'time';
                const formatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                timeEl.textContent = formatter.format(new Date(toast.createdAt));

                body.appendChild(titleEl);
                body.appendChild(messageEl);
                body.appendChild(timeEl);
                el.appendChild(body);

                if (toast.expiresAt != null) {
                    el.addEventListener('click', () => this.removeToast(context, toast.id));
                }

                container.appendChild(el);
            });
        },
        // REMOVIDO: Modal de Configura√ß√µes Avan√ßadas (substitu√≠do por configura√ß√µes inline no painel)
        applySectionStates(config) {
            if (!this.elements) return;
            const states = config.ui?.panelStates || {};
            const ids = ['stats', 'configs', 'automation', 'status', 'events'];
            ids.forEach(id => {
                const section = this.elements.sections?.[id];
                const body = this.elements.sectionBodies?.[id];
                const toggle = this.elements.sectionToggles?.[id];
                const collapsed = Boolean(states[id]);
                if (section) {
                    section.setAttribute('data-collapsed', collapsed ? '1' : '0');
                }
                if (body) {
                    body.hidden = collapsed;
                }
                if (toggle) {
                    toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
                    toggle.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
                }
            });
        },
        ensureMobileToggle(context, panelContainer) {
            const doc = context.document;
            if (!doc) return;

            // Check if toggle button already exists
            let toggleButton = doc.getElementById('autods-mobile-toggle-btn');
            if (toggleButton) {
                this.mobileToggleButton = toggleButton;
                return;
            }

            // Create the toggle button in the main document (not shadow DOM)
            toggleButton = doc.createElement('button');
            toggleButton.id = 'autods-mobile-toggle-btn';
            toggleButton.type = 'button';
            toggleButton.className = 'autods-mobile-toggle';
            toggleButton.setAttribute('aria-label', 'Toggle painel');
            toggleButton.textContent = '‚ò∞';

            // Add styles to main document if not already present
            if (!doc.getElementById('autods-mobile-toggle-style')) {
                const style = doc.createElement('style');
                style.id = 'autods-mobile-toggle-style';
                style.textContent = `
                    .autods-mobile-toggle {
                        display: none;
                        position: fixed;
                        bottom: 90px;
                        left: 10px;
                        z-index: 10000;
                        width: 44px;
                        height: 44px;
                        background: rgba(20, 40, 70, 0.95);
                        border: 2px solid rgba(70, 130, 220, 0.5);
                        border-radius: 12px;
                        color: #a8d0ff;
                        font-size: 20px;
                        cursor: pointer;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                        backdrop-filter: blur(10px);
                        align-items: center;
                        justify-content: center;
                        transition: all 0.2s ease;
                    }
                    .autods-mobile-toggle:hover {
                        background: rgba(30, 60, 100, 0.95);
                        border-color: rgba(100, 160, 255, 0.7);
                        transform: scale(1.05);
                    }
                    .autods-mobile-toggle:active {
                        transform: scale(0.95);
                    }
                    @media (max-width: 480px) {
                        .autods-mobile-toggle {
                            display: flex !important;
                        }
                    }
                `;
                doc.head.appendChild(style);
            }

            // Add click handler
            toggleButton.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();

                const shell = panelContainer;
                if (!shell) return;

                const isCollapsed = shell.getAttribute('data-mobile-collapsed') === '1';
                shell.setAttribute('data-mobile-collapsed', isCollapsed ? '0' : '1');
                toggleButton.textContent = isCollapsed ? '‚úï' : '‚ò∞';
                toggleButton.setAttribute('aria-label', isCollapsed ? 'Fechar painel' : 'Toggle painel');

                // Toggle body class for mobile overflow control
                if (window.innerWidth <= 480) {
                    doc.body.classList.toggle('autods-panel-visible', isCollapsed);
                }
            });

            // Insert button into document body
            const placeButton = () => {
                if (doc.body && !toggleButton.parentElement) {
                    doc.body.appendChild(toggleButton);
                    return true;
                }
                return false;
            };

            const placed = placeButton();
            if (!placed) {
                doc.addEventListener('DOMContentLoaded', () => {
                    placeButton();
                }, { once: true });
            }

            // Auto-collapse panel by default (desktop and mobile)
            // With external floating buttons, panel starts minimized
            panelContainer.setAttribute('data-mobile-collapsed', '1');
            doc.body.classList.remove('autods-panel-visible');

            // Handle window resize
            window.addEventListener('resize', () => {
                if (window.innerWidth > 480) {
                    panelContainer.setAttribute('data-mobile-collapsed', '0');
                    doc.body.classList.remove('autods-panel-visible');
                    doc.body.classList.add('autods-shell-open');
                    toggleButton.textContent = '‚ò∞';
                }
            });

            // Close panel when clicking outside on mobile
            doc.addEventListener('click', (event) => {
                if (window.innerWidth <= 480) {
                    const target = event.target;
                    const isInsidePanel = panelContainer.contains(target) || context.ui.root.contains(target);
                    const isToggleButton = toggleButton.contains(target);

                    if (!isInsidePanel && !isToggleButton && panelContainer.getAttribute('data-mobile-collapsed') === '0') {
                        panelContainer.setAttribute('data-mobile-collapsed', '1');
                        toggleButton.textContent = '‚ò∞';
                        doc.body.classList.remove('autods-panel-visible');
                        doc.body.classList.remove('autods-shell-open');
                    }
                }
            });

            // Add keyboard shortcut Ctrl+Shift+P to toggle panel
            doc.addEventListener('keydown', (event) => {
                if (event.ctrlKey && event.shiftKey && event.key === 'P') {
                    event.preventDefault();
                    const isCollapsed = panelContainer.getAttribute('data-mobile-collapsed') === '1';
                    panelContainer.setAttribute('data-mobile-collapsed', isCollapsed ? '0' : '1');
                    toggleButton.textContent = isCollapsed ? '‚úï' : '‚ò∞';
                    toggleButton.setAttribute('aria-label', isCollapsed ? 'Fechar painel' : 'Toggle painel');

                    if (window.innerWidth <= 480) {
                        doc.body.classList.toggle('autods-panel-visible', isCollapsed);
                    }
                    // Add/remove shell-open class
                    doc.body.classList.toggle('autods-shell-open', isCollapsed);
                }
            });

            this.mobileToggleButton = toggleButton;
        },
        ensureDesktopToggle(context, panelContainer) {
            const doc = context.document;
            if (!doc) return;

            // Check if toggle button already exists
            let toggleButton = doc.getElementById('autods-panel-toggle-btn');
            if (toggleButton) {
                this.desktopToggleButton = toggleButton;
                return;
            }

            // Create the toggle button in the main document (not shadow DOM)
            toggleButton = doc.createElement('button');
            toggleButton.id = 'autods-panel-toggle-btn';
            toggleButton.type = 'button';
            toggleButton.setAttribute('aria-label', 'Abrir painel');
            toggleButton.setAttribute('title', 'Abrir painel (Ctrl+Shift+P)');
            toggleButton.innerHTML = '‚öôÔ∏è';

            // Add click handler
            toggleButton.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();

                const shell = panelContainer;
                if (!shell) return;

                const isCollapsed = shell.getAttribute('data-mobile-collapsed') === '1';
                
                if (isCollapsed) {
                    // Reabrir painel
                    shell.setAttribute('data-mobile-collapsed', '0');
                    doc.body.classList.add('autods-layout-ready');
                    doc.body.classList.add('autods-shell-open');
                    toggleButton.setAttribute('aria-label', 'Fechar painel');
                    toggleButton.setAttribute('title', 'Fechar painel (Ctrl+Shift+P)');
                    toggleButton.classList.remove('visible');
                } else {
                    // Fechar painel
                    shell.setAttribute('data-mobile-collapsed', '1');
                    doc.body.classList.remove('autods-layout-ready');
                    doc.body.classList.remove('autods-shell-open');
                    toggleButton.setAttribute('aria-label', 'Abrir painel');
                    toggleButton.setAttribute('title', 'Abrir painel (Ctrl+Shift+P)');
                    toggleButton.classList.add('visible');
                }
            });

            // üÜï Function to try inserting into floating helpers
            const tryInsertIntoFloatingHelpers = () => {
                const floatingHelpers = doc.getElementById('autods-floating-helpers');
                if (floatingHelpers && !toggleButton.parentElement) {
                    floatingHelpers.insertBefore(toggleButton, floatingHelpers.firstChild);
                    console.log('[DesktopToggle] Button inserted into autods-floating-helpers');
                    return true;
                }
                return false;
            };

            // Try immediately
            if (!tryInsertIntoFloatingHelpers()) {
                // If floating helpers not ready yet, try again with retry logic
                let retries = 0;
                const retryInterval = setInterval(() => {
                    if (tryInsertIntoFloatingHelpers()) {
                        clearInterval(retryInterval);
                    }
                    retries++;
                    if (retries > 20) { // 2 seconds (20 * 100ms)
                        clearInterval(retryInterval);
                        // Fallback: Insert into body
                        if (doc.body && !toggleButton.parentElement) {
                            doc.body.appendChild(toggleButton);
                            console.log('[DesktopToggle] Button inserted into body (floating helpers not found)');
                        }
                    }
                }, 100);
            }

            this.desktopToggleButton = toggleButton;
        },
        renderConfigs(context, config) {
            if (!this.elements) return;
            this.syncConfigInputs(config);
        }
    };

    // Guild Dungeon Loot All Button
    function addGuildDungeonLootAllButton() {
        // Verificar se estamos em p√°gina de guild dungeon
        if (!window.location.pathname.includes('guild_dungeon_location.php')) {
            return;
        }

        // Verificar se j√° existe o bot√£o
        if (document.getElementById('autods-guild-loot-all')) {
            return;
        }

        // Buscar o elemento "üëæ Monsters in this location"
        const monsterHeaders = Array.from(document.querySelectorAll('.h')).filter(h =>
            h.textContent.includes('üëæ Monsters in this location')
        );

        if (monsterHeaders.length === 0) {
            return;
        }

        const monsterHeader = monsterHeaders[0];

        // Contar quantos bot√µes .autods-loot-btn existem
        const lootButtons = document.querySelectorAll('.autods-loot-btn');
        if (lootButtons.length === 0) {
            return;
        }

        // Criar bot√£o Loot All
        const lootAllBtn = document.createElement('button');
        lootAllBtn.id = 'autods-guild-loot-all';
        lootAllBtn.className = 'btn';
        lootAllBtn.style.cssText = `
            margin-left: 12px;
            background: linear-gradient(135deg, #a6e3a1 0%, #74c7ec 100%);
            color: #1e1e2e;
            border: none;
            font-weight: bold;
            padding: 6px 12px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(166, 227, 161, 0.3);
        `;
        lootAllBtn.innerHTML = `üí∞ Loot All (${lootButtons.length})`;
        lootAllBtn.title = 'Fazer loot de todos os monstros eleg√≠veis nesta localiza√ß√£o';

        // Hover effects
        lootAllBtn.addEventListener('mouseenter', () => {
            lootAllBtn.style.transform = 'translateY(-2px)';
            lootAllBtn.style.boxShadow = '0 4px 12px rgba(166, 227, 161, 0.5)';
        });
        lootAllBtn.addEventListener('mouseleave', () => {
            lootAllBtn.style.transform = 'translateY(0)';
            lootAllBtn.style.boxShadow = '0 2px 6px rgba(166, 227, 161, 0.3)';
        });

        // Click handler
        lootAllBtn.addEventListener('click', async () => {
            const originalText = lootAllBtn.innerHTML;
            lootAllBtn.disabled = true;
            lootAllBtn.innerHTML = '‚è≥ Looting...';
            lootAllBtn.style.opacity = '0.6';

            try {
                const buttons = Array.from(document.querySelectorAll('.autods-loot-btn'));
                let success = 0;
                let failed = 0;

                for (let i = 0; i < buttons.length; i++) {
                    const btn = buttons[i];

                    try {
                        // Simular clique no bot√£o
                        btn.click();

                        // Aguardar resposta
                        await new Promise(resolve => setTimeout(resolve, 500));

                        success++;
                        lootAllBtn.innerHTML = `‚è≥ ${i + 1}/${buttons.length}...`;
                    } catch (error) {
                        failed++;
                        console.error('Erro ao fazer loot:', error);
                    }

                    // Delay entre loots
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                // Resultado final
                lootAllBtn.innerHTML = `‚úÖ ${success} looted!`;
                lootAllBtn.style.background = 'linear-gradient(135deg, #a6e3a1 0%, #94e2d5 100%)';

                setTimeout(() => {
                    lootAllBtn.innerHTML = originalText;
                    lootAllBtn.disabled = false;
                    lootAllBtn.style.opacity = '1';
                    lootAllBtn.style.background = 'linear-gradient(135deg, #a6e3a1 0%, #74c7ec 100%)';
                }, 2000);

            } catch (error) {
                console.error('Erro no loot all:', error);
                lootAllBtn.innerHTML = '‚ùå Error';
                lootAllBtn.style.background = 'linear-gradient(135deg, #f38ba8 0%, #eba0ac 100%)';

                setTimeout(() => {
                    lootAllBtn.innerHTML = originalText;
                    lootAllBtn.disabled = false;
                    lootAllBtn.style.opacity = '1';
                    lootAllBtn.style.background = 'linear-gradient(135deg, #a6e3a1 0%, #74c7ec 100%)';
                }, 2000);
            }
        });

        // Inserir o bot√£o ap√≥s o header
        monsterHeader.appendChild(lootAllBtn);
    }

    // Dungeon Pills Functions
    function addDungeonPills() {
        // Verificar se estamos em p√°gina de dungeon
        if (!window.location.pathname.includes('active_wave.php') &&
            !window.location.pathname.includes('wave.php')) {
            return;
        }

        const cfg = JSON.parse(localStorage.getItem('autods.v1:config') || '{}');
        if (!cfg.dungeonWave) return;

        const showDamagePills = cfg.dungeonWave.showDamagePills !== false; // default true
        const showExpPills = cfg.dungeonWave.showExpPills !== false; // default true

        if (!showDamagePills && !showExpPills) return;

        // Buscar todos os monster cards
        const monsterCards = document.querySelectorAll('.monster-card');
        if (!monsterCards.length) return;

        monsterCards.forEach(card => {
            // Evitar duplica√ß√£o
            if (card.querySelector('.dungeon-pills')) return;

            // Extrair HP atual e m√°ximo
            const hpNode = card.querySelector('[data-stat="hp"], .hp-text, .hp-value, .monster-hp, .hp-bar + div, .hp');
            if (!hpNode) return;

            const hpText = hpNode.getAttribute?.('data-current-hp') ?? hpNode.textContent ?? '';

            // Parse HP (formato: "‚ù§Ô∏è 123,456 / 1,234,567 HP" ou "123456 / 1234567")
            const hpMatch = hpText.match(/([\d,]+)\s*\/\s*([\d,]+)/);
            if (!hpMatch) return;

            const currentHP = parseInt(hpMatch[1].replace(/,/g, '')) || 0;
            const maxHP = parseInt(hpMatch[2].replace(/,/g, '')) || 0;

            if (maxHP === 0) return;

            // Calcular damage e exp esperados
            const expectedDamage = calculateExpectedDungeonDamage(currentHP, maxHP);
            const expectedExp = calculateExpectedExp(currentHP, maxHP);

            // Criar container de pills
            const pillsContainer = document.createElement('div');
            pillsContainer.className = 'dungeon-pills';
            pillsContainer.style.cssText = `
                display: flex;
                gap: 6px;
                justify-content: center;
                margin: 8px 0 4px;
                flex-wrap: wrap;
            `;

            // Adicionar pill de damage
            if (showDamagePills && expectedDamage > 0) {
                const damagePill = document.createElement('div');
                damagePill.className = 'pill-item pill-damage';
                damagePill.style.cssText = `
                    background: linear-gradient(135deg, #f38ba8 0%, #f5c2e7 100%);
                    color: #1e1e2e;
                    padding: 4px 10px;
                    border-radius: 12px;
                    font-size: 11px;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    box-shadow: 0 2px 6px rgba(243, 139, 168, 0.3);
                    transition: transform 0.2s, box-shadow 0.2s;
                    cursor: help;
                `;
                damagePill.title = `Dano estimado: ${formatNumber(expectedDamage)} (15-25% do HP atual)`;
                damagePill.innerHTML = `<span>‚öîÔ∏è</span><span>~${formatNumber(expectedDamage)}</span>`;

                // Hover effect
                damagePill.addEventListener('mouseenter', () => {
                    damagePill.style.transform = 'translateY(-2px) scale(1.05)';
                    damagePill.style.boxShadow = '0 4px 12px rgba(243, 139, 168, 0.5)';
                });
                damagePill.addEventListener('mouseleave', () => {
                    damagePill.style.transform = 'translateY(0) scale(1)';
                    damagePill.style.boxShadow = '0 2px 6px rgba(243, 139, 168, 0.3)';
                });

                pillsContainer.appendChild(damagePill);
            }

            // Adicionar pill de exp
            if (showExpPills && expectedExp > 0) {
                const expPill = document.createElement('div');
                expPill.className = 'pill-item pill-exp';
                expPill.style.cssText = `
                    background: linear-gradient(135deg, #89dceb 0%, #74c7ec 100%);
                    color: #1e1e2e;
                    padding: 4px 10px;
                    border-radius: 12px;
                    font-size: 11px;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    box-shadow: 0 2px 6px rgba(137, 220, 235, 0.3);
                    transition: transform 0.2s, box-shadow 0.2s;
                    cursor: help;
                `;
                expPill.title = `EXP estimado: ${formatNumber(expectedExp)} (base 10% do HP + b√¥nus de ratio)`;
                expPill.innerHTML = `<span>‚ú®</span><span>~${formatNumber(expectedExp)}</span>`;

                // Hover effect
                expPill.addEventListener('mouseenter', () => {
                    expPill.style.transform = 'translateY(-2px) scale(1.05)';
                    expPill.style.boxShadow = '0 4px 12px rgba(137, 220, 235, 0.5)';
                });
                expPill.addEventListener('mouseleave', () => {
                    expPill.style.transform = 'translateY(0) scale(1)';
                    expPill.style.boxShadow = '0 2px 6px rgba(137, 220, 235, 0.3)';
                });

                pillsContainer.appendChild(expPill);
            }

            // Inserir pills no card (ap√≥s HP bar)
            const hpBar = card.querySelector('.hp-bar');
            if (hpBar && hpBar.nextSibling) {
                hpBar.parentNode.insertBefore(pillsContainer, hpBar.nextSibling.nextSibling);
            } else {
                // Fallback: adicionar antes dos bot√µes
                const button = card.querySelector('button, .join-btn, a');
                if (button) {
                    button.parentNode.insertBefore(pillsContainer, button);
                } else {
                    card.appendChild(pillsContainer);
                }
            }
        });
    }

    // Smart Damage Calculation Functions
    function addSmartDamageDisplay() {
        if (!window.location.pathname.includes('stats.php')) return;

        const attackElement = document.getElementById('v-attack');
        if (!attackElement) return;

        const attackValue = parseInt(attackElement.textContent.replace(/,/g, '')) || 0;

        // Encontrar o card de stats (segundo card no grid)
        const statCards = document.querySelectorAll('.grid .card');
        if (statCards.length < 2) return;

        const statCard = statCards[1]; // Segundo card (Current Stats)

        // Verificar se j√° adicionamos (evitar duplicatas)
        if (statCard.querySelector('.autods-damage-calc')) return;

        // Adicionar separador
        const separator = document.createElement('hr');
        separator.style.cssText = 'border:0;border-top:1px solid #333;margin:10px 0';
        statCard.appendChild(separator);

        // Pegar valores de defesa da config ou usar padr√£o
        const cfg = JSON.parse(localStorage.getItem('autods.v1:config') || '{}');
        const defenseValues = cfg.smartDamageCalc?.defenseValues || [0, 25, 50];

        // Adicionar rows de damage calculation
        const tempNumbers = createNumberFormattingService();
        defenseValues.forEach(def => {
            const damage = tempNumbers.calculateDamageVsDefense(attackValue, def);

            const row = document.createElement('div');
            row.className = 'row autods-damage-calc';
            row.style.cssText = 'color: #f38ba8; cursor: help;';
            row.title = `Calculated damage against monsters with ${def} DEF\nFormula: DMG = 1000 √ó (ATK - DEF)^0.25`;

            const label = document.createElement('span');
            label.textContent = `ATK DMG vs ${def} DEF`;

            const value = document.createElement('span');
            value.textContent = formatNumber(damage);
            value.style.fontWeight = 'bold';

            row.appendChild(label);
            row.appendChild(value);
            statCard.appendChild(row);
        });
    }

    // ========================================
    // AUTO BOSS MODULE
    // ========================================
    const autoBossModule = {
        id: 'autoBoss',
        match: ({ location }) => /battle\.php/i.test(location.pathname) && !/pvp.*battle/i.test(location.pathname),
        init(context) {
            this.state = {
                running: false,
                totalDamage: 0,
                attackCount: 0,
                potionsUsed: 0,
                startTime: null
            };
        },
        activate(context) {
            const cfg = context.config.get();
            if (!cfg.core.enabled || !cfg.autoBoss || !cfg.autoBoss.enabled) {
                if (this.state) {
                    this.state.running = false;
                }
                return;
            }

            // Don't run if regular battle automation is enabled to avoid conflicts
            if (cfg.battle?.enabled) {
                context.logger.warn('‚ö†Ô∏è AutoBoss: M√≥dulo battle regular est√° ativado. Desative-o para usar AutoBoss.');
                return;
            }

            if (!this.state) this.init(context);
            if (this.state.running) return;

            this.state.running = true;
            this.state.startTime = Date.now();

            // Override window.confirm globally for AutoBoss to auto-accept potion usage
            if (!window._autoBossConfirmOverridden) {
                this.state.originalConfirm = window.confirm;
                window.confirm = (message) => {
                    context.logger.debug(`‚úÖ AutoBoss: Auto-aceitando confirm: "${message}"`);
                    return true; // Always accept
                };
                window._autoBossConfirmOverridden = true;
                context.logger.debug('üîß AutoBoss: window.confirm() override ativado');
            }

            (async () => {
                try {
                    await this.runAutoBoss(context);
                } catch (error) {
                    context.logger.error('‚ùå Falha no AutoBoss', error);
                } finally {
                    this.state.running = false;
                }
            })();
        },
        getSkillStaminaCost(button) {
            if (!button) return 0;

            const dataStamina = button.dataset?.staminaCost || button.getAttribute('data-stamina-cost');
            if (dataStamina) {
                const cost = parseInt(dataStamina, 10);
                if (!isNaN(cost)) return cost;
            }

            const buttonText = button.dataset?.skillName || button.getAttribute('data-skill-name') || button.textContent || '';
            const match = buttonText.match(/\((\d+)\s*STAMINA\)/i);
            if (match) {
                const cost = parseInt(match[1], 10);
                if (!isNaN(cost)) return cost;
            }

            return 0;
        },
        getAllAttackButtons(dom) {
            const buttons = dom.queryAll('.attack-btn, button[data-skill-id], button.skill-button');
            return buttons.filter(btn => !btn.disabled && !btn.classList.contains('is-loading'));
        },
        selectBestAttackButton(context, buttons, currentStamina) {
            if (!buttons || buttons.length === 0) {
                context.logger.debug('‚ùå AutoBoss: Nenhum bot√£o dispon√≠vel para sele√ß√£o');
                return null;
            }

            // If stamina is 0 or negative, don't try to attack
            if (currentStamina <= 0) {
                context.logger.debug('‚ùå AutoBoss: Stamina = 0, nenhum ataque poss√≠vel');
                return null;
            }

            let bestButton = null;
            let highestCost = -1;

            for (const button of buttons) {
                const cost = this.getSkillStaminaCost(button);

                // Only consider buttons that we can afford
                if (cost <= currentStamina && cost > highestCost) {
                    highestCost = cost;
                    bestButton = button;
                }
            }

            if (bestButton) {
                const skillName = bestButton.dataset?.skillName || bestButton.getAttribute('data-skill-name') || 'Unknown';
                context.logger.debug(`üéØ AutoBoss: Selecionado ${skillName} (custo: ${highestCost} stamina, dispon√≠vel: ${currentStamina})`);
            } else {
                context.logger.debug(`‚ùå AutoBoss: Nenhum ataque dispon√≠vel com stamina ${currentStamina}`);
            }

            return bestButton;
        },
        getCurrentDamage(dom) {
            const damageElement = dom.query('#totalDamage, .total-damage, [data-total-damage]');
            if (!damageElement) return 0;

            const text = damageElement.textContent || damageElement.dataset?.totalDamage || '0';
            return numberFromText(text) || 0;
        },
        getMonsterHp(dom) {
            const hpElement = dom.query('.hp-text, .monster-hp-text, [data-monster-hp]');
            if (!hpElement) return null;

            const text = hpElement.textContent || '';
            const parts = text.split('/');
            if (parts.length >= 1) {
                return numberFromText(parts[0]);
            }

            return null;
        },
        canAttackNow() {
            try {
                const cookieStr = document.cookie;
                const match = cookieStr.match(/last_attack=(\d+)/);
                if (!match) return { ok: true, waitMs: 0 };

                const lastAttack = parseInt(match[1], 10);
                const now = Date.now();
                const elapsed = now - lastAttack;
                const cooldown = 1000;

                if (elapsed < cooldown) {
                    return { ok: false, waitMs: cooldown - elapsed };
                }

                return { ok: true, waitMs: 0 };
            } catch (error) {
                return { ok: true, waitMs: 0 };
            }
        },
        setLastAttackTime() {
            const now = Date.now();
            document.cookie = `last_attack=${now}; path=/; max-age=86400`;
            return now;
        },
        async runAutoBoss(context) {
            const { logger, dom } = context;
            const cfg = context.config.get();

            const damageTarget = cfg.autoBoss?.damageTarget || 1000000000;
            const delayBase = cfg.autoBoss?.delayBaseMs || 1000;
            const variation = cfg.autoBoss?.delayVariation || 0.3;
            const randomize = cfg.autoBoss?.randomizeDelays ?? true;

            logger.info(`ü§ñ AutoBoss iniciado! Meta de dano: ${formatNumber(damageTarget)}`);

            // Check if we need to join the battle first
            const joinButton = dom.query('#join-battle, button.btn-join, button.join-battle');
            if (joinButton && !joinButton.disabled) {
                logger.info('üö™ AutoBoss: Entrando na batalha...');
                joinButton.click();
                await sleep(2000);
                // After joining, the page will reload, and the module will restart
                return;
            }

            while (true) {
                const currentCfg = context.config.get();
                if (!currentCfg.core.enabled || !currentCfg.autoBoss?.enabled) {
                    logger.info('‚èπÔ∏è AutoBoss: Desativado via configura√ß√£o.');
                    break;
                }

                // Check if monster is dead
                const monsterHp = this.getMonsterHp(dom);
                if (monsterHp !== null && monsterHp <= 0) {
                    logger.info('üíÄ AutoBoss: Monstro derrotado!');
                    logger.info(`üìä Estat√≠sticas: ${this.state.attackCount} ataques, ${this.state.potionsUsed} po√ß√µes usadas`);
                    break;
                }

                // Check if damage target reached
                const currentDamage = this.getCurrentDamage(dom);
                if (currentDamage >= damageTarget) {
                    logger.info(`‚úÖ AutoBoss: Meta de dano atingida! ${formatNumber(currentDamage)} / ${formatNumber(damageTarget)}`);
                    logger.info(`üìä Estat√≠sticas: ${this.state.attackCount} ataques, ${this.state.potionsUsed} po√ß√µes usadas`);
                    break;
                }

                // Get current stamina
                const currentStamina = context.stamina.getCurrent();
                logger.debug(`‚ö° AutoBoss: Stamina atual: ${currentStamina}`);

                // Get all available attack buttons
                const attackButtons = this.getAllAttackButtons(dom);

                if (attackButtons.length === 0) {
                    logger.warn('‚ö†Ô∏è AutoBoss: Nenhum bot√£o de ataque dispon√≠vel.');
                    await sleep(1000);
                    continue;
                }

                // Select best attack based on current stamina
                const bestButton = this.selectBestAttackButton(context, attackButtons, currentStamina);

                if (!bestButton) {
                    // No attack available with current stamina - need to use potion
                    logger.warn(`‚ö†Ô∏è AutoBoss: Stamina insuficiente (${currentStamina}). Tentando usar Full Stamina Potion...`);

                    // IMPORTANT: Stop trying to attack before using potion
                    await sleep(500); // Give time for any pending attacks to complete

                    const potionUsed = await context.inventory.useFullStaminaPotion();

                    if (!potionUsed) {
                        logger.error('‚ùå AutoBoss: N√£o foi poss√≠vel usar po√ß√£o. Encerrando.');
                        logger.info(`üìä Dano total: ${formatNumber(currentDamage)} / ${formatNumber(damageTarget)}`);
                        logger.info(`üìä Estat√≠sticas: ${this.state.attackCount} ataques, ${this.state.potionsUsed} po√ß√µes usadas`);
                        break;
                    }

                    // After using potion, page should reload and module will restart
                    // If we're still here, something went wrong
                    logger.warn('‚ö†Ô∏è AutoBoss: Esperando reload ap√≥s usar po√ß√£o...');
                    await sleep(3000);

                    // Try to continue if page didn't reload
                    continue;
                }

                // Double-check stamina before attacking (to prevent HTTP 400 errors)
                const skillCost = this.getSkillStaminaCost(bestButton);
                const reCheckStamina = context.stamina.getCurrent();

                if (reCheckStamina < skillCost) {
                    logger.warn(`‚ö†Ô∏è AutoBoss: Stamina mudou! Agora: ${reCheckStamina}, necess√°rio: ${skillCost}. Pulando ataque.`);
                    await sleep(500);
                    continue; // Go back to top of loop to try use potion
                }

                // Check cooldown
                const cooldownCheck = this.canAttackNow();
                if (!cooldownCheck.ok) {
                    const waitSecs = Math.ceil(cooldownCheck.waitMs / 1000);
                    logger.debug(`‚è≥ AutoBoss: Aguardando cooldown... ${waitSecs}s`);
                    await sleep(cooldownCheck.waitMs);
                }

                // Final check: is button still enabled?
                if (bestButton.disabled || bestButton.classList.contains('is-loading')) {
                    logger.debug('‚ö†Ô∏è AutoBoss: Bot√£o ficou desabilitado. Aguardando...');
                    await sleep(500);
                    continue;
                }

                // Attack!
                bestButton.click();
                this.setLastAttackTime();
                this.state.attackCount++;

                const skillName = bestButton.dataset?.skillName || bestButton.getAttribute('data-skill-name') || 'Ataque';
                logger.debug(`‚öîÔ∏è AutoBoss: ${skillName} executado! (Total: ${this.state.attackCount} ataques, Stamina restante: ~${reCheckStamina - skillCost})`);

                // Wait before next attack
                await sleepRandom(delayBase, variation, randomize);
            }

            logger.info('üèÅ AutoBoss: Sess√£o finalizada.');
        },
        cleanup() {
            if (this.state) {
                this.state.running = false;

                // Restore original window.confirm if we overrode it
                if (window._autoBossConfirmOverridden && this.state.originalConfirm) {
                    window.confirm = this.state.originalConfirm;
                    window._autoBossConfirmOverridden = false;
                    console.log('[AutoDS] window.confirm() restaurado');
                }
            }
        }
    };

    // ==================== DAMAGE CALCULATOR MODULE ====================
    // UI widget for damage calculation and build optimization
    // Active on: stats.php, pets.php, inventory.php
    
    const damageCalculatorModule = {
        id: 'damageCalculator',
        match: ({ location }) => /\/(stats|pets|inventory)\.php/i.test(location.pathname),
        
        init(context) {
            context.logger.debug('Damage Calculator module initialized');
            this.state = {
                widget: null,
                currentTab: 'stats',
                monsterDefense: 50,
                skillId: -2,
                lastUpdate: null,
                isVisible: false
            };
        },
        
        activate(context) {
            if (!this.state) this.init(context);
            
            const cfg = context.config.get();
            if (!cfg.core.enabled) return;
            
            context.logger.info('üßÆ Damage Calculator widget ready (inicialmente oculto)...');
            
            // Create widget but keep it hidden initially
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    this.createWidget(context);
                    this.hide(context); // Hide on creation
                }, { once: true });
            } else {
                this.createWidget(context);
                this.hide(context); // Hide on creation
            }
        },
        
        show(context) {
            if (!this.state.widget) {
                // If widget doesn't exist, create it
                this.createWidget(context);
            }
            if (this.state.widget) {
                this.state.widget.style.display = 'block';
                this.state.isVisible = true;
                context.logger.info('üßÆ Damage Calculator mostrado');
            }
        },
        
        hide(context) {
            if (this.state.widget) {
                this.state.widget.style.display = 'none';
                this.state.isVisible = false;
                context.logger.info('üßÆ Damage Calculator ocultado');
            }
        },
        
        createWidget(context) {
            const { logger, dataExtractor, damageCalculator } = context;
            
            // Check if widget already exists
            if (document.getElementById('autods-damage-calculator')) {
                logger.debug('Damage Calculator widget already exists');
                return;
            }
            
            // Create floating widget container
            const widget = document.createElement('div');
            widget.id = 'autods-damage-calculator';
            widget.style.cssText = `
                position: fixed;
                top: 120px;
                left: 20px;
                width: 360px;
                background: linear-gradient(135deg, rgba(20, 30, 50, 0.95), rgba(30, 40, 60, 0.95));
                border: 2px solid rgba(70, 130, 220, 0.6);
                border-radius: 12px;
                padding: 0;
                z-index: 2147483645;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
                backdrop-filter: blur(10px);
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                color: #e0e0e0;
                overflow: hidden;
                transition: all 0.3s ease;
                display: none;
            `;
            
            // Save widget reference
            this.state.widget = widget;
            
            // Create widget header
            const header = document.createElement('div');
            header.style.cssText = `
                background: linear-gradient(135deg, rgba(70, 130, 220, 0.3), rgba(90, 150, 240, 0.2));
                padding: 12px 16px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-bottom: 1px solid rgba(70, 130, 220, 0.4);
                cursor: move;
            `;
            header.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 18px;">üßÆ</span>
                    <span style="font-weight: 600; font-size: 14px;">Damage Calculator</span>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button id="autods-calc-refresh" style="
                        background: rgba(70, 180, 70, 0.3);
                        border: 1px solid rgba(70, 180, 70, 0.5);
                        color: #90ee90;
                        padding: 4px 10px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 11px;
                        transition: all 0.2s;
                    " title="Refresh data">üîÑ Refresh</button>
                    <button id="autods-calc-minimize" style="
                        background: rgba(70, 130, 220, 0.3);
                        border: 1px solid rgba(70, 130, 220, 0.5);
                        color: #b8c5d6;
                        padding: 4px 10px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 11px;
                        transition: all 0.2s;
                    ">‚àí</button>
                </div>
            `;
            
            // Create tabs
            const tabs = document.createElement('div');
            tabs.style.cssText = `
                display: flex;
                background: rgba(15, 20, 35, 0.6);
                border-bottom: 1px solid rgba(70, 130, 220, 0.3);
            `;
            
            const tabItems = [
                { id: 'stats', label: 'üìä Stats', title: 'Player Stats' },
                { id: 'pvm', label: '‚öîÔ∏è PvM', title: 'PvM Damage' },
                { id: 'pvp', label: 'üõ°Ô∏è PvP', title: 'PvP Power' },
                { id: 'builds', label: 'üèÜ Builds', title: 'Best Pet Builds' }
            ];
            
            tabItems.forEach(tab => {
                const btn = document.createElement('button');
                btn.id = `autods-calc-tab-${tab.id}`;
                btn.className = 'autods-calc-tab';
                btn.textContent = tab.label;
                btn.title = tab.title;
                btn.style.cssText = `
                    flex: 1;
                    padding: 10px;
                    background: transparent;
                    border: none;
                    color: #b8c5d6;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: 500;
                    transition: all 0.2s;
                    border-bottom: 2px solid transparent;
                `;
                
                btn.addEventListener('click', () => {
                    this.switchTab(context, tab.id);
                });
                
                tabs.appendChild(btn);
            });
            
            // Create content area
            const content = document.createElement('div');
            content.id = 'autods-calc-content';
            content.style.cssText = `
                padding: 16px;
                max-height: 500px;
                overflow-y: auto;
                font-size: 13px;
            `;
            
            // Create loading state
            content.innerHTML = `
                <div style="text-align: center; padding: 40px 20px; color: #b8c5d6;">
                    <div style="font-size: 32px; margin-bottom: 12px;">‚è≥</div>
                    <div>Loading player data...</div>
                </div>
            `;
            
            // Assemble widget
            widget.appendChild(header);
            widget.appendChild(tabs);
            widget.appendChild(content);
            document.body.appendChild(widget);
            
            this.state.widget = widget;
            
            // Make draggable
            this.makeDraggable(header, widget);
            
            // Setup event listeners
            this.setupEventListeners(context);
            
            // Load initial data
            this.loadData(context);
            
            logger.info('‚úÖ Damage Calculator widget created');
        },
        
        setupEventListeners(context) {
            // Refresh button
            const refreshBtn = document.getElementById('autods-calc-refresh');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', async () => {
                    refreshBtn.textContent = '‚è≥';
                    refreshBtn.disabled = true;
                    await context.dataExtractor.forceRefresh();
                    await this.loadData(context);
                    refreshBtn.textContent = 'üîÑ Refresh';
                    refreshBtn.disabled = false;
                });
            }
            
            // Minimize button
            const minimizeBtn = document.getElementById('autods-calc-minimize');
            const content = document.getElementById('autods-calc-content');
            if (minimizeBtn && content) {
                minimizeBtn.addEventListener('click', () => {
                    if (content.style.display === 'none') {
                        content.style.display = 'block';
                        minimizeBtn.textContent = '‚àí';
                    } else {
                        content.style.display = 'none';
                        minimizeBtn.textContent = '+';
                    }
                });
            }
        },
        
        async loadData(context) {
            const { logger, dataExtractor, damageCalculator } = context;
            
            try {
                logger.debug('Loading player data for calculator...');
                
                // Extract all data
                const data = await dataExtractor.extractAll();
                this.state.playerData = data;
                this.state.lastUpdate = new Date();
                
                // Calculate damage/power
                const calc = await damageCalculator.calculateWithCurrentData(
                    dataExtractor,
                    this.state.monsterDefense,
                    this.state.skillId
                );
                this.state.calculations = calc;
                
                // Update UI
                this.switchTab(context, this.state.currentTab);
                
            } catch (error) {
                logger.error('Failed to load calculator data', { error });
                const content = document.getElementById('autods-calc-content');
                if (content) {
                    content.innerHTML = `
                        <div style="text-align: center; padding: 40px 20px; color: #ff6b6b;">
                            <div style="font-size: 32px; margin-bottom: 12px;">‚ùå</div>
                            <div>Failed to load data</div>
                            <div style="font-size: 11px; margin-top: 8px; opacity: 0.7;">${error.message}</div>
                        </div>
                    `;
                }
            }
        },
        
        switchTab(context, tabId) {
            this.state.currentTab = tabId;
            
            // Update tab buttons
            document.querySelectorAll('.autods-calc-tab').forEach(btn => {
                const isActive = btn.id === `autods-calc-tab-${tabId}`;
                btn.style.color = isActive ? '#fff' : '#b8c5d6';
                btn.style.background = isActive ? 'rgba(70, 130, 220, 0.3)' : 'transparent';
                btn.style.borderBottomColor = isActive ? 'rgba(70, 130, 220, 0.8)' : 'transparent';
                btn.style.fontWeight = isActive ? '600' : '500';
            });
            
            // Update content
            const content = document.getElementById('autods-calc-content');
            if (!content) return;
            
            switch (tabId) {
                case 'stats':
                    content.innerHTML = this.renderStatsTab(context);
                    break;
                case 'pvm':
                    content.innerHTML = this.renderPvMTab(context);
                    this.setupPvMListeners(context);
                    break;
                case 'pvp':
                    content.innerHTML = this.renderPvPTab(context);
                    break;
                case 'builds':
                    content.innerHTML = this.renderBuildsTab(context);
                    break;
            }
        },
        
        renderStatsTab(context) {
            if (!this.state.playerData) {
                return '<div style="text-align: center; padding: 20px; color: #b8c5d6;">No data available</div>';
            }
            
            const { stats, pets, equipment } = this.state.playerData;
            const lastUpdate = this.state.lastUpdate ? this.state.lastUpdate.toLocaleTimeString() : 'Never';
            
            // Analyze pet impact
            const analysis = context.dataExtractor.analyzePetImpact(pets.equipped_attack_team || []);
            
            return `
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div style="text-align: center; font-size: 11px; color: #888; margin-bottom: 8px;">
                        Last updated: ${lastUpdate}
                    </div>
                    
                    <div style="background: rgba(20, 30, 50, 0.5); padding: 12px; border-radius: 8px; border: 1px solid rgba(70, 130, 220, 0.3);">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #90caf9;">üìä Base Stats</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
                            <div>Level:</div><div style="text-align: right; font-weight: 600;">${stats.level}</div>
                            <div>Attack:</div><div style="text-align: right; font-weight: 600; color: #ff6b6b;">${stats.base_attack}</div>
                            <div>Defense:</div><div style="text-align: right; font-weight: 600; color: #4dabf7;">${stats.base_defense}</div>
                            <div>Max Stamina:</div><div style="text-align: right; font-weight: 600; color: #69db7c;">${stats.max_stamina}</div>
                            <div>Current Stamina:</div><div style="text-align: right; font-weight: 600;">${stats.current_stamina}</div>
                            <div>Unspent Points:</div><div style="text-align: right; font-weight: 600; color: #ffd43b;">${stats.unspent_points}</div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(20, 30, 50, 0.5); padding: 12px; border-radius: 8px; border: 1px solid rgba(70, 130, 220, 0.3);">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #a78bfa;">üêæ Pets (Attack Team)</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px; margin-bottom: 12px;">
                            <div>Equipped:</div><div style="text-align: right; font-weight: 600;">${pets.equipped_attack_team.length}</div>
                            <div>Total Attack:</div><div style="text-align: right; font-weight: 600; color: #ff6b6b;">${pets.total_attack_pets_atk}</div>
                            <div>Total Defense:</div><div style="text-align: right; font-weight: 600; color: #4dabf7;">${pets.total_attack_pets_def}</div>
                            ${pets.pvm_damage_bonus_percent > 0 ? `
                                <div style="grid-column: 1 / -1; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);">
                                    <div style="color: #69db7c; font-weight: 600;">‚ö° PvM Bonus: +${pets.pvm_damage_bonus_percent.toFixed(1)}%</div>
                                </div>
                            ` : ''}
                        </div>
                        ${pets.equipped_attack_team.length > 0 ? `
                            <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; margin-top: 4px;">
                                <div style="font-size: 11px; color: #888; margin-bottom: 6px;">Individual Pets:</div>
                                ${pets.equipped_attack_team.map(pet => `
                                    <div style="background: rgba(15, 20, 35, 0.5); padding: 6px 8px; border-radius: 4px; margin-bottom: 4px; font-size: 11px;">
                                        <div style="font-weight: 600; color: #e0e0e0; margin-bottom: 2px;">${pet.name}</div>
                                        <div style="color: #b8c5d6;">
                                            <span style="color: #ff6b6b;">üî™ ${pet.attack}</span> ¬∑ 
                                            <span style="color: #4dabf7;">üõ°Ô∏è ${pet.defense}</span> ¬∑ 
                                            <span style="color: #a78bfa;">üß™ Lv.${pet.level}</span>
                                        </div>
                                        ${pet.effect ? `
                                            <div style="color: ${pet.pvm_damage_bonus > 0 ? '#69db7c' : '#888'}; font-size: 10px; margin-top: 2px;">
                                                ‚ö° ${pet.effect}
                                            </div>
                                        ` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                    
                    <div style="background: rgba(20, 30, 50, 0.5); padding: 12px; border-radius: 8px; border: 1px solid rgba(70, 130, 220, 0.3);">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #ffd43b;">‚öîÔ∏è Equipment (Attack Set)</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
                            <div>Total Attack:</div><div style="text-align: right; font-weight: 600; color: #ff6b6b;">${equipment.total_equipped_atk}</div>
                            <div>Total Defense:</div><div style="text-align: right; font-weight: 600; color: #4dabf7;">${equipment.total_equipped_def}</div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(20, 30, 50, 0.5); padding: 12px; border-radius: 8px; border: 1px solid rgba(70, 130, 220, 0.3);">
                        <div style="font-weight: 600; margin-bottom: 12px; color: #f06292;">üìä Pet Impact Analysis</div>
                        
                        ${analysis.pvm.total_score > 0 ? `
                            <div style="margin-bottom: 12px; padding: 10px; background: rgba(105, 219, 124, 0.1); border: 1px solid rgba(105, 219, 124, 0.3); border-radius: 6px;">
                                <div style="font-weight: 600; color: #69db7c; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>‚öîÔ∏è PvM</span>
                                    <span style="font-size: 14px;">${analysis.pvm.total_score.toFixed(1)} pts</span>
                                </div>
                                ${analysis.pvm.contributors.map(c => `
                                    <div style="font-size: 10px; color: #b8c5d6; margin-top: 4px; padding: 4px 6px; background: rgba(15, 20, 35, 0.5); border-radius: 3px;">
                                        <div style="font-weight: 600; color: #e0e0e0;">${c.pet} (${c.score.toFixed(1)} pts)</div>
                                        <div style="color: #888; margin-top: 2px;">${c.breakdown}</div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        ${analysis.pvp_attacker.total_score > 0 ? `
                            <div style="margin-bottom: 12px; padding: 10px; background: rgba(255, 107, 107, 0.1); border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 6px;">
                                <div style="font-weight: 600; color: #ff6b6b; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>‚ö° PvP Attacker</span>
                                    <span style="font-size: 14px;">${analysis.pvp_attacker.total_score.toFixed(1)} pts</span>
                                </div>
                                ${analysis.pvp_attacker.contributors.map(c => `
                                    <div style="font-size: 10px; color: #b8c5d6; margin-top: 4px; padding: 4px 6px; background: rgba(15, 20, 35, 0.5); border-radius: 3px;">
                                        <div style="font-weight: 600; color: #e0e0e0;">${c.pet} (${c.score.toFixed(1)} pts)</div>
                                        <div style="color: #888; margin-top: 2px;">${c.breakdown}</div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        ${analysis.pvp_defender.total_score > 0 ? `
                            <div style="margin-bottom: 12px; padding: 10px; background: rgba(77, 171, 247, 0.1); border: 1px solid rgba(77, 171, 247, 0.3); border-radius: 6px;">
                                <div style="font-weight: 600; color: #4dabf7; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>üõ°Ô∏è PvP Defender</span>
                                    <span style="font-size: 14px;">${analysis.pvp_defender.total_score.toFixed(1)} pts</span>
                                </div>
                                ${analysis.pvp_defender.contributors.map(c => `
                                    <div style="font-size: 10px; color: #b8c5d6; margin-top: 4px; padding: 4px 6px; background: rgba(15, 20, 35, 0.5); border-radius: 3px;">
                                        <div style="font-weight: 600; color: #e0e0e0;">${c.pet} (${c.score.toFixed(1)} pts)</div>
                                        <div style="color: #888; margin-top: 2px;">${c.breakdown}</div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        ${analysis.universal.total_score > 0 ? `
                            <div style="padding: 10px; background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.3); border-radius: 6px;">
                                <div style="font-weight: 600; color: #a78bfa; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>üåü Universal</span>
                                    <span style="font-size: 14px;">${analysis.universal.total_score.toFixed(1)} pts</span>
                                </div>
                                ${analysis.universal.contributors.map(c => `
                                    <div style="font-size: 10px; color: #b8c5d6; margin-top: 4px; padding: 4px 6px; background: rgba(15, 20, 35, 0.5); border-radius: 3px;">
                                        <div style="font-weight: 600; color: #e0e0e0;">${c.pet} (${c.score.toFixed(1)} pts)</div>
                                        <div style="color: #888; margin-top: 2px;">${c.breakdown}</div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        ${analysis.pvm.total_score === 0 && analysis.pvp_attacker.total_score === 0 && 
                          analysis.pvp_defender.total_score === 0 && analysis.universal.total_score === 0 ? `
                            <div style="text-align: center; padding: 16px; color: #888; font-size: 11px;">
                                No pets equipped or no effects detected
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        },
        
        renderPvMTab(context) {
            if (!this.state.calculations) {
                return '<div style="text-align: center; padding: 20px; color: #b8c5d6;">No calculations available</div>';
            }
            
            const { pvm } = this.state.calculations;
            const skills = [
                { id: 0, name: 'Slash', cost: 1 },
                { id: -1, name: 'Power Slash', cost: 10 },
                { id: -2, name: 'Heroic Slash', cost: 50 },
                { id: -3, name: 'Ultimate Slash', cost: 100 },
                { id: -4, name: 'Legendary Slash', cost: 200 }
            ];
            
            return `
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div style="background: rgba(20, 30, 50, 0.5); padding: 12px; border-radius: 8px; border: 1px solid rgba(70, 130, 220, 0.3);">
                        <div style="font-weight: 600; margin-bottom: 12px; color: #90caf9;">‚öôÔ∏è Settings</div>
                        
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #b8c5d6;">Monster Defense</label>
                            <input type="number" id="autods-calc-monster-def" value="${this.state.monsterDefense}" 
                                min="0" max="1000" step="1"
                                style="width: 100%; padding: 8px; background: rgba(15, 20, 35, 0.8); color: #e0e0e0; 
                                border: 1px solid rgba(70, 130, 220, 0.4); border-radius: 6px; font-size: 13px;">
                        </div>
                        
                        <div>
                            <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #b8c5d6;">Skill</label>
                            <select id="autods-calc-skill" 
                                style="width: 100%; padding: 8px; background: rgba(15, 20, 35, 0.8); color: #e0e0e0; 
                                border: 1px solid rgba(70, 130, 220, 0.4); border-radius: 6px; font-size: 13px; cursor: pointer;">
                                ${skills.map(s => `
                                    <option value="${s.id}" ${s.id === this.state.skillId ? 'selected' : ''}>
                                        ${s.name} (${s.cost} stamina)
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                        
                        <button id="autods-calc-recalculate" style="
                            width: 100%;
                            margin-top: 12px;
                            padding: 10px;
                            background: linear-gradient(135deg, rgba(70, 130, 220, 0.4), rgba(90, 150, 240, 0.3));
                            border: 1px solid rgba(70, 130, 220, 0.6);
                            color: #fff;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 13px;
                            font-weight: 600;
                            transition: all 0.2s;
                        ">üîÑ Recalculate</button>
                    </div>
                    
                    <div style="background: rgba(70, 180, 70, 0.1); padding: 16px; border-radius: 8px; border: 2px solid rgba(70, 180, 70, 0.4);">
                        <div style="font-weight: 600; margin-bottom: 12px; color: #69db7c; text-align: center; font-size: 14px;">
                            üí• Expected Damage
                        </div>
                        <div style="text-align: center; font-size: 28px; font-weight: 700; color: #fff; margin-bottom: 16px;">
                            ${context.numbers.format(pvm.damage)}
                        </div>
                        <div style="font-size: 11px; color: #b8c5d6; border-top: 1px solid rgba(70, 180, 70, 0.3); padding-top: 12px;">
                            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 6px;">
                                <div>Base:</div><div style="text-align: right;">${context.numbers.format(pvm.breakdown.base)}</div>
                                <div>Equipment:</div><div style="text-align: right;">${context.numbers.format(pvm.breakdown.equip_contribution)}</div>
                                <div>Pets:</div><div style="text-align: right;">${context.numbers.format(pvm.breakdown.pet_contribution)}</div>
                                <div>User Attack:</div><div style="text-align: right;">${context.numbers.format(pvm.breakdown.user_attack_contribution)}</div>
                                <div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 4px; font-weight: 600;">Subtotal:</div>
                                <div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 4px; text-align: right; font-weight: 600;">${context.numbers.format(pvm.breakdown.subtotal)}</div>
                                <div style="color: #ffd43b;">√ó Stamina:</div><div style="text-align: right; color: #ffd43b;">√ó${pvm.breakdown.stamina_multiplier}</div>
                                ${pvm.breakdown.total_bonus_percent > 0 ? `
                                    <div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 4px; color: #69db7c;">Before Bonus:</div>
                                    <div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 4px; text-align: right; color: #69db7c;">${context.numbers.format(pvm.breakdown.damage_before_bonus)}</div>
                                    ${pvm.breakdown.pet_bonus_percent > 0 ? `
                                        <div style="color: #a78bfa;">Pet Bonus:</div><div style="text-align: right; color: #a78bfa;">+${pvm.breakdown.pet_bonus_percent.toFixed(1)}%</div>
                                    ` : ''}
                                    ${pvm.breakdown.equip_bonus_percent > 0 ? `
                                        <div style="color: #ffd43b;">Equip Bonus:</div><div style="text-align: right; color: #ffd43b;">+${pvm.breakdown.equip_bonus_percent.toFixed(1)}%</div>
                                    ` : ''}
                                    <div style="color: #69db7c; font-weight: 600;">Total Bonus:</div>
                                    <div style="text-align: right; color: #69db7c; font-weight: 600;">√ó${pvm.breakdown.bonus_multiplier}</div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        },
        
        renderPvPTab(context) {
            if (!this.state.calculations) {
                return '<div style="text-align: center; padding: 20px; color: #b8c5d6;">No calculations available</div>';
            }
            
            const { pvp_attacker, pvp_defender } = this.state.calculations;
            
            return `
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <div style="background: rgba(220, 70, 70, 0.1); padding: 16px; border-radius: 8px; border: 2px solid rgba(220, 70, 70, 0.4);">
                        <div style="font-weight: 600; margin-bottom: 12px; color: #ff6b6b; text-align: center; font-size: 14px;">
                            ‚öîÔ∏è Attacker Power
                        </div>
                        <div style="text-align: center; font-size: 28px; font-weight: 700; color: #fff; margin-bottom: 16px;">
                            ${pvp_attacker.power.toFixed(1)}
                        </div>
                        <div style="font-size: 11px; color: #b8c5d6; border-top: 1px solid rgba(220, 70, 70, 0.3); padding-top: 12px;">
                            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 6px;">
                                <div>Base Attack:</div><div style="text-align: right;">${pvp_attacker.breakdown.base_attack}</div>
                                <div>Base Defense (√ó0.7):</div><div style="text-align: right;">${pvp_attacker.breakdown.base_defense_contribution.toFixed(1)}</div>
                                <div>Pet Attack (√ó0.3):</div><div style="text-align: right;">${pvp_attacker.breakdown.pet_attack_contribution.toFixed(1)}</div>
                                <div>Equipment ATK (√ó0.4):</div><div style="text-align: right;">${pvp_attacker.breakdown.equip_attack_contribution.toFixed(1)}</div>
                                <div>Pet Defense (√ó0.3):</div><div style="text-align: right;">${pvp_attacker.breakdown.pet_defense_contribution.toFixed(1)}</div>
                                <div>Equipment DEF (√ó0.2):</div><div style="text-align: right;">${pvp_attacker.breakdown.equip_defense_contribution.toFixed(1)}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(70, 130, 220, 0.1); padding: 16px; border-radius: 8px; border: 2px solid rgba(70, 130, 220, 0.4);">
                        <div style="font-weight: 600; margin-bottom: 12px; color: #4dabf7; text-align: center; font-size: 14px;">
                            üõ°Ô∏è Defender Power
                        </div>
                        <div style="text-align: center; font-size: 28px; font-weight: 700; color: #fff; margin-bottom: 16px;">
                            ${pvp_defender.power.toFixed(1)}
                        </div>
                        <div style="font-size: 11px; color: #b8c5d6; border-top: 1px solid rgba(70, 130, 220, 0.3); padding-top: 12px;">
                            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 6px;">
                                <div>Base Defense:</div><div style="text-align: right;">${pvp_defender.breakdown.base_defense}</div>
                                <div>Base Attack (√ó0.7):</div><div style="text-align: right;">${pvp_defender.breakdown.base_attack_contribution.toFixed(1)}</div>
                                <div>Pet Attack (√ó0.3):</div><div style="text-align: right;">${pvp_defender.breakdown.pet_attack_contribution.toFixed(1)}</div>
                                <div>Equipment ATK (√ó0.2):</div><div style="text-align: right;">${pvp_defender.breakdown.equip_attack_contribution.toFixed(1)}</div>
                                <div>Pet Defense (√ó0.3):</div><div style="text-align: right;">${pvp_defender.breakdown.pet_defense_contribution.toFixed(1)}</div>
                                <div>Equipment DEF (√ó0.4):</div><div style="text-align: right;">${pvp_defender.breakdown.equip_defense_contribution.toFixed(1)}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: rgba(255, 215, 0, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); font-size: 11px; color: #b8c5d6;">
                        <div style="margin-bottom: 6px; color: #ffd43b; font-weight: 600;">üí° PvP Formula Info:</div>
                        <div>Attacker: ATK + 0.7√óDEF + 0.3√óPetATK + 0.4√óEqATK + 0.3√óPetDEF + 0.2√óEqDEF</div>
                        <div>Defender: DEF + 0.7√óATK + 0.3√óPetATK + 0.2√óEqATK + 0.3√óPetDEF + 0.4√óEqDEF</div>
                    </div>
                </div>
            `;
        },
        
        renderBuildsTab(context) {
            if (!this.state.playerData) {
                return '<div style="text-align: center; padding: 20px; color: #b8c5d6;">No data available. Click Refresh to analyze builds.</div>';
            }
            
            const { allAvailablePets } = this.state.playerData;
            
            if (!allAvailablePets || allAvailablePets.length < 3) {
                return '<div style="text-align: center; padding: 20px; color: #b8c5d6;">Need at least 3 pets to analyze builds</div>';
            }
            
            // Analyze optimal builds
            const builds = context.dataExtractor.analyzeOptimalBuilds(this.state.playerData, this.state.monsterDefense);
            
            return `
                <div style="display: flex; flex-direction: column; gap: 12px; max-height: 480px; overflow-y: auto;">
                    <div style="text-align: center; font-size: 11px; color: #888; padding: 8px; background: rgba(255,215,0,0.05); border-radius: 6px; margin-bottom: 4px;">
                        Analyzed ${builds.pvm.total_combinations || 0} combinations from ${allAvailablePets.length} pets
                    </div>
                    
                    ${builds.pvm.builds.length > 0 ? `
                        <div style="background: rgba(105, 219, 124, 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(105, 219, 124, 0.3);">
                            <div style="font-weight: 600; color: #69db7c; margin-bottom: 10px; font-size: 13px;">üèÜ Best PvM Builds</div>
                            ${builds.pvm.builds.map((build, idx) => `
                                <div style="margin-bottom: 10px; padding: 10px; background: rgba(15, 20, 35, 0.6); border-radius: 6px; border-left: 3px solid ${idx === 0 ? '#ffd43b' : 'rgba(105, 219, 124, 0.3)'};">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                        <span style="font-weight: 600; color: ${idx === 0 ? '#ffd43b' : '#e0e0e0'}; font-size: 11px;">
                                            ${idx === 0 ? 'üëë #1' : `#${idx + 1}`}
                                        </span>
                                        <span style="font-size: 12px; font-weight: 600; color: #69db7c;">
                                            ${context.numbers.format(build.expectedDamage)} dmg
                                        </span>
                                    </div>
                                    <div style="font-size: 10px; color: #b8c5d6; margin-bottom: 4px;">
                                        ${build.pets.join(' ¬∑ ')}
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; font-size: 9px; color: #888; margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <div>ATK: ${build.totalAtk}</div>
                                        <div>DEF: ${build.totalDef}</div>
                                        ${build.damageBonus > 0 ? `<div style="color: #69db7c;">+${build.damageBonus.toFixed(1)}% DMG</div>` : ''}
                                        ${build.critRate > 0 ? `<div style="color: #ffa94d;">+${build.critRate.toFixed(1)}% Crit</div>` : ''}
                                        ${build.armorPen > 0 ? `<div style="color: #ff6b6b;">+${build.armorPen.toFixed(1)}% Pen</div>` : ''}
                                        ${build.staminaSave > 0 ? `<div style="color: #90caf9;">+${build.staminaSave.toFixed(1)}% Save</div>` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${builds.pvp_attacker.builds.length > 0 ? `
                        <div style="background: rgba(255, 107, 107, 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 107, 107, 0.3);">
                            <div style="font-weight: 600; color: #ff6b6b; margin-bottom: 10px; font-size: 13px;">‚öîÔ∏è Best PvP Attacker Builds</div>
                            ${builds.pvp_attacker.builds.slice(0, 3).map((build, idx) => `
                                <div style="margin-bottom: 10px; padding: 10px; background: rgba(15, 20, 35, 0.6); border-radius: 6px; border-left: 3px solid ${idx === 0 ? '#ffd43b' : 'rgba(255, 107, 107, 0.3)'};">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                        <span style="font-weight: 600; color: ${idx === 0 ? '#ffd43b' : '#e0e0e0'}; font-size: 11px;">
                                            ${idx === 0 ? 'üëë #1' : `#${idx + 1}`}
                                        </span>
                                        <span style="font-size: 12px; font-weight: 600; color: #ff6b6b;">
                                            ${build.score.toFixed(1)} pts
                                        </span>
                                    </div>
                                    <div style="font-size: 10px; color: #b8c5d6; margin-bottom: 4px;">
                                        ${build.pets.join(' ¬∑ ')}
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; font-size: 9px; color: #888; margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <div>ATK: ${build.totalAtk}</div>
                                        <div>DEF: ${build.totalDef}</div>
                                        ${build.stealStat > 0 ? `<div style="color: #ff6b6b;">Steal ${build.stealStat.toFixed(1)}%</div>` : ''}
                                        ${build.teamConversion > 0 ? `<div style="color: #a78bfa;">Conv ${build.teamConversion.toFixed(1)}%</div>` : ''}
                                        ${build.atkDefSwap > 0 ? `<div style="color: #ffd43b;">Swap ${build.atkDefSwap.toFixed(1)}%</div>` : ''}
                                        ${build.critRate > 0 ? `<div style="color: #ffa94d;">Crit ${build.critRate.toFixed(1)}%</div>` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${builds.pvp_defender.builds.length > 0 ? `
                        <div style="background: rgba(77, 171, 247, 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(77, 171, 247, 0.3);">
                            <div style="font-weight: 600; color: #4dabf7; margin-bottom: 10px; font-size: 13px;">üõ°Ô∏è Best PvP Defender Builds</div>
                            ${builds.pvp_defender.builds.slice(0, 3).map((build, idx) => `
                                <div style="margin-bottom: 10px; padding: 10px; background: rgba(15, 20, 35, 0.6); border-radius: 6px; border-left: 3px solid ${idx === 0 ? '#ffd43b' : 'rgba(77, 171, 247, 0.3)'};">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                        <span style="font-weight: 600; color: ${idx === 0 ? '#ffd43b' : '#e0e0e0'}; font-size: 11px;">
                                            ${idx === 0 ? 'üëë #1' : `#${idx + 1}`}
                                        </span>
                                        <span style="font-size: 12px; font-weight: 600; color: #4dabf7;">
                                            ${build.score.toFixed(1)} pts
                                        </span>
                                    </div>
                                    <div style="font-size: 10px; color: #b8c5d6; margin-bottom: 4px;">
                                        ${build.pets.join(' ¬∑ ')}
                                    </div>
                                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; font-size: 9px; color: #888; margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.1);">
                                        <div>ATK: ${build.totalAtk}</div>
                                        <div>DEF: ${build.totalDef}</div>
                                        ${build.stealStat > 0 ? `<div style="color: #4dabf7;">Steal ${build.stealStat.toFixed(1)}%</div>` : ''}
                                        ${build.teamConversion > 0 ? `<div style="color: #a78bfa;">Conv ${build.teamConversion.toFixed(1)}%</div>` : ''}
                                        ${build.defBoost > 0 ? `<div style="color: #69db7c;">+${build.defBoost.toFixed(1)}% DEF</div>` : ''}
                                        ${build.atkDefSwap > 0 ? `<div style="color: #ffd43b;">Swap ${build.atkDefSwap.toFixed(1)}%</div>` : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        },
        
        setupPvMListeners(context) {
            const recalcBtn = document.getElementById('autods-calc-recalculate');
            const monsterDefInput = document.getElementById('autods-calc-monster-def');
            const skillSelect = document.getElementById('autods-calc-skill');
            
            if (!recalcBtn || !monsterDefInput || !skillSelect) return;
            
            recalcBtn.addEventListener('click', async () => {
                this.state.monsterDefense = parseInt(monsterDefInput.value) || 50;
                this.state.skillId = parseInt(skillSelect.value) || -2;
                
                recalcBtn.textContent = '‚è≥ Calculating...';
                recalcBtn.disabled = true;
                
                const calc = await context.damageCalculator.calculateWithCurrentData(
                    context.dataExtractor,
                    this.state.monsterDefense,
                    this.state.skillId
                );
                this.state.calculations = calc;
                
                this.switchTab(context, 'pvm');
                
                recalcBtn.textContent = 'üîÑ Recalculate';
                recalcBtn.disabled = false;
            });
        },
        
        makeDraggable(header, widget) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                const rect = widget.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
                header.style.cursor = 'grabbing';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                widget.style.left = (initialX + dx) + 'px';
                widget.style.top = (initialY + dy) + 'px';
                widget.style.right = 'auto';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
                header.style.cursor = 'move';
            });
        },
        
        cleanup() {
            if (this.state?.widget) {
                this.state.widget.remove();
            }
        }
    };

    // Profile Manager Service (Phase 4)
    function createProfileManager(context) {
        const STORAGE_KEY = 'autods.profiles';
        let uiContainer = null;  // Armazenar refer√™ncia do container renderizado
        
        /**
         * Filter config keys to exclude system-level configs
         * @param {string} key - Config key (e.g., 'wave.enabled', 'ui.theme')
         * @returns {boolean} - True if should be included in profile
         */
        function shouldIncludeConfigKey(key) {
            if (!key) return false;
            if (key.startsWith('ui.')) return false;
            if (key.startsWith('core.')) return false;
            if (key.startsWith('credentials.')) return false;
            return true;
        }
        
        /**
         * Extract saveable config from context.config.get()
         * @returns {Object} - Filtered config object
         */
        function extractSaveableConfig() {
            const fullConfig = context.config.get();
            const saveableConfig = {};
            
            // Iterate through all top-level config keys
            Object.keys(fullConfig).forEach(topKey => {
                if (shouldIncludeConfigKey(topKey)) {
                    saveableConfig[topKey] = JSON.parse(JSON.stringify(fullConfig[topKey]));
                }
            });
            
            return saveableConfig;
        }
        
        /**
         * Apply loaded config to context.config and trigger UI update
         * @param {Object} profileConfig - Config object to apply
         */
        function applyLoadedConfig(profileConfig) {
            // Deep merge into current config
            const currentConfig = context.config.get();
            
            Object.keys(profileConfig).forEach(topKey => {
                if (shouldIncludeConfigKey(topKey)) {
                    currentConfig[topKey] = JSON.parse(JSON.stringify(profileConfig[topKey]));
                }
            });
            
            // Save merged config using save() method
            context.config.save(currentConfig);
            
            // Note: config.save() already emits 'autods:config:updated' event
            // UI will update automatically via existing event listeners
        }
        
        function loadProfilesData() {
            try {
                const data = GM_getValue(STORAGE_KEY, '{}');
                return JSON.parse(data);
            } catch (e) {
                context.logger.error('Erro ao carregar perfis', e);
                return {};
            }
        }
        
        function saveProfilesData(profiles) {
            try {
                GM_setValue(STORAGE_KEY, JSON.stringify(profiles));
            } catch (e) {
                context.logger.error('Erro ao salvar perfis', e);
            }
        }
        
        function loadProfilesInSelect(container = uiContainer) {
            // Procurar o select dentro do container que foi passado (ou usar o armazenado)
            if (!container) {
                context.logger.warn('Container n√£o encontrado para loadProfilesInSelect');
                return;
            }
            
            const select = container.querySelector('#autods-profile-select');
            if (!select) {
                context.logger.warn('Select de perfis n√£o encontrado no container');
                return;
            }
            
            const profiles = loadProfilesData();
            select.innerHTML = '<option value="">-- Selecione um perfil --</option>';
            
            Object.keys(profiles).sort().forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        }
        
        function triggerInputChange(input) {
            const event = new Event('change', { bubbles: true });
            input.dispatchEvent(event);
        }
        
        return {
            saveProfile(profileName) {
                if (!profileName || profileName.length > 100) {
                    return { success: false, error: 'Nome inv√°lido (m√°x 100 caracteres)' };
                }
                
                try {
                    const profiles = loadProfilesData();
                    const configData = extractSaveableConfig();
                    
                    profiles[profileName] = {
                        timestamp: Date.now(),
                        data: configData,
                        version: context.version
                    };
                    
                    saveProfilesData(profiles);
                    loadProfilesInSelect();
                    
                    const configKeys = Object.keys(configData);
                    context.logger.info(`üíæ Perfil '${profileName}' salvo com sucesso (${configKeys.length} m√≥dulos)`);
                    context.notifications?.success(`Perfil '${profileName}' salvo! (${configKeys.length} m√≥dulos)`);
                    
                    return {
                        success: true,
                        profileName,
                        itemsCount: configKeys.length
                    };
                } catch (e) {
                    context.logger.error('Erro ao salvar perfil', e);
                    return { success: false, error: e.message };
                }
            },
            
            loadProfile(profileName) {
                try {
                    const profiles = loadProfilesData();
                    const profile = profiles[profileName];
                    
                    if (!profile) {
                        context.logger.warn(`Perfil '${profileName}' n√£o encontrado`);
                        return { success: false, error: 'Perfil n√£o encontrado' };
                    }
                    
                    // Apply config data
                    applyLoadedConfig(profile.data);
                    
                    // Force update of floating helpers to reflect new config
                    const floatingHelpersModule = context.moduleRegistry.getModule('floatingHelpers');
                    if (floatingHelpersModule && floatingHelpersModule.state?.container) {
                        const cfg = context.config.get();
                        context.logger.debug('üîÑ Atualizando Floating Helpers ap√≥s carregar perfil');
                        
                        // Recreate entire container to reflect all changes
                        floatingHelpersModule.createFloatingContainer(context, cfg);
                    }
                    
                    const configKeys = Object.keys(profile.data);
                    context.logger.info(`üìÇ Perfil '${profileName}' carregado com sucesso (${configKeys.length} m√≥dulos)`);
                    context.notifications?.success(`Perfil '${profileName}' carregado! (${configKeys.length} m√≥dulos)`);
                    
                    return {
                        success: true,
                        profileName,
                        applied: configKeys.length,
                        errors: 0
                    };
                } catch (e) {
                    context.logger.error('Erro ao carregar perfil', e);
                    return { success: false, error: e.message };
                }
            },
            
            deleteProfile(profileName) {
                const profiles = loadProfilesData();
                delete profiles[profileName];
                saveProfilesData(profiles);
                loadProfilesInSelect();
                
                context.logger.info(`üóëÔ∏è Perfil '${profileName}' deletado`);
                context.notifications?.success(`Perfil '${profileName}' deletado!`);
                
                return { success: true, profileName };
            },
            
            listProfiles() {
                const profiles = loadProfilesData();
                return Object.keys(profiles).sort().map(name => ({
                    name,
                    timestamp: profiles[name].timestamp,
                    version: profiles[name].version || 'unknown',
                    modulesCount: Object.keys(profiles[name].data || {}).length
                }));
            },
            
            hasProfile(profileName) {
                const profiles = loadProfilesData();
                return profileName in profiles;
            },
            
            exportProfile(profileName) {
                const profiles = loadProfilesData();
                return profiles[profileName] || null;
            },
            
            importProfile(profileName, data) {
                const profiles = loadProfilesData();
                profiles[profileName] = data;
                saveProfilesData(profiles);
                loadProfilesInSelect();
                return { success: true };
            },
            
            clearAllProfiles() {
                GM_setValue(STORAGE_KEY, '{}');
                loadProfilesInSelect();
                return { success: true, message: 'Todos os perfis deletados' };
            },
            
            renderUI(container) {
                if (!container) {
                    context.logger.warn('Container para Profile Manager n√£o encontrado');
                    return;
                }
                
                // Armazenar refer√™ncia do container para uso posterior
                uiContainer = container;
                
                const html = `
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <div style="display: flex; gap: 4px;">
                            <input id="autods-profile-name" type="text" placeholder="Nome do novo perfil..." 
                                   style="flex: 1; padding: 6px 8px; background: #1a1a2e; color: #aaa; border: 1px solid #333; border-radius: 4px; font-size: 12px;" />
                            <button id="autods-profile-save" style="padding: 6px 12px; background: #2a6a2a; border: 1px solid #4a8; color: #8f8; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 12px;">üíæ Salvar</button>
                        </div>
                        
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <select id="autods-profile-select" style="flex: 1; padding: 6px 8px; background: #1a1a2e; color: #aaa; border: 1px solid #333; border-radius: 4px; font-size: 12px;">
                                <option value="">-- Selecione um perfil --</option>
                            </select>
                        </div>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <button id="autods-profile-load" style="padding: 6px 12px; background: #2a4a6a; border: 1px solid #4a9eff; color: #8af; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 12px;">üìÇ Carregar</button>
                            <button id="autods-profile-delete" style="padding: 6px 12px; background: #6a2a2a; border: 1px solid #f88; color: #f88; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 12px;">üóëÔ∏è Delete</button>
                        </div>
                        
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <button id="autods-profile-export" style="flex: 1; padding: 6px 12px; background: #4a2a6a; border: 1px solid #a8f; color: #d8f; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 12px;">üì§ Exportar</button>
                            <button id="autods-profile-import" style="flex: 1; padding: 6px 12px; background: #2a4a4a; border: 1px solid #4fa; color: #8fa; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 12px;">üì• Importar</button>
                        </div>
                        
                        <input id="autods-profile-import-file" type="file" accept=".json" style="display: none;" />
                    </div>
                `;
                
                container.innerHTML = html;
                
                // Usar setTimeout para garantir que o DOM foi renderizado
                setTimeout(() => {
                    const nameInput = container.querySelector('#autods-profile-name');
                    const saveBtn = container.querySelector('#autods-profile-save');
                    const select = container.querySelector('#autods-profile-select');
                    const loadBtn = container.querySelector('#autods-profile-load');
                    const deleteBtn = container.querySelector('#autods-profile-delete');
                    const exportBtn = container.querySelector('#autods-profile-export');
                    const importBtn = container.querySelector('#autods-profile-import');
                    const importFile = container.querySelector('#autods-profile-import-file');
                    
                    context.logger.debug('Profile Manager inputs found:', {
                        nameInput: !!nameInput,
                        saveBtn: !!saveBtn,
                        select: !!select,
                        loadBtn: !!loadBtn,
                        deleteBtn: !!deleteBtn,
                        exportBtn: !!exportBtn,
                        importBtn: !!importBtn
                    });
                    
                    loadProfilesInSelect();
                    
                    saveBtn?.addEventListener('click', () => {
                        const name = nameInput.value.trim();
                        if (name) {
                            this.saveProfile(name);
                            nameInput.value = '';
                        }
                    });
                    
                    loadBtn?.addEventListener('click', () => {
                        const name = select.value;
                        if (name) {
                            this.loadProfile(name);
                        }
                    });
                    
                    deleteBtn?.addEventListener('click', () => {
                        const name = select.value;
                        if (name && confirm(`Confirmar exclus√£o de '${name}'?`)) {
                            this.deleteProfile(name);
                        }
                    });
                    
                    // Export profile to JSON file
                    exportBtn?.addEventListener('click', () => {
                        const name = select.value;
                        if (!name) {
                            context.notifications?.warn('Selecione um perfil para exportar');
                            return;
                        }
                        
                        const profileData = this.exportProfile(name);
                        if (!profileData) {
                            context.notifications?.error('Perfil n√£o encontrado');
                            return;
                        }
                        
                        // Create JSON blob and download
                        const json = JSON.stringify(profileData, null, 2);
                        const blob = new Blob([json], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `autods-profile-${name}-${Date.now()}.json`;
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        context.logger.info(`üì§ Perfil '${name}' exportado para JSON`);
                        context.notifications?.success(`Perfil '${name}' exportado!`);
                    });
                    
                    // Import profile from JSON file
                    importBtn?.addEventListener('click', () => {
                        importFile?.click();
                    });
                    
                    importFile?.addEventListener('change', (e) => {
                        const file = e.target.files?.[0];
                        if (!file) return;
                        
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const profileData = JSON.parse(event.target.result);
                                
                                // Validate profile structure
                                if (!profileData.data || !profileData.timestamp) {
                                    context.notifications?.error('Arquivo de perfil inv√°lido');
                                    return;
                                }
                                
                                // Ask for new profile name
                                const newName = prompt('Nome para o perfil importado:', file.name.replace(/\.json$/, '').replace(/^autods-profile-/, ''));
                                if (!newName) return;
                                
                                // Import profile
                                this.importProfile(newName, profileData);
                                
                                // Update UI
                                loadProfilesInSelect();
                                select.value = newName;
                                
                                context.logger.info(`üì• Perfil '${newName}' importado de JSON`);
                                context.notifications?.success(`Perfil '${newName}' importado com sucesso!`);
                            } catch (err) {
                                context.logger.error('Erro ao importar perfil:', err);
                                context.notifications?.error(`Erro ao importar: ${err.message}`);
                            }
                        };
                        reader.readAsText(file);
                        
                        // Reset input to allow re-importing the same file
                        e.target.value = '';
                    });
                }, 50);
            }
        };
    }

    function bootstrap() {
        const storage = createStorage({ namespace: STORAGE_NAMESPACE });
        const events = createEventBus();
        const config = createConfig(storage, events);
        const cfg = config.get();
        const logger = createLogger(cfg.core.logLevel || 'info', cfg.ui?.logFloater || {});
        const dom = createDomService(logger);
        const scheduler = createScheduler(logger);
        const ui = createUiRoot(cfg);
        const moduleRegistry = createModuleRegistry(logger);

        // Create temporary context for service initialization
        const tempContext = { logger, config };
        
        // Initialize Phase 1 services (Completed 11/12/2025)
        const stamina = createStaminaReader();
        const inventory = createInventoryService(tempContext);
        
        // Initialize merchant service (requires http service, so we'll do it after http)
        
        // Initialize Phase 2 services (Completed 11/12/2025)
        const http = createHttpService(tempContext);
        const notifications = createNotificationService(tempContext);
        
        // Initialize combat service AFTER http (needs http.attackWaveMonsterDirect etc.)
        const combat = createCombatService({ ...tempContext, http });
        
        // Initialize Wave View Navigation Service BEFORE context (needed in context object)
        const waveViewNavigation = createWaveViewNavigationService({ logger });
        
        // NOTE: Phase 2 services are available but not yet fully integrated
        // Old functions like joinBattleDirectly() still use GM_xmlhttpRequest directly
        // Future Phase 3 will migrate all modules to use context.http and context.notifications
        // Example usage:
        //   const result = await context.http.joinBattle(monsterId, userId);
        //   context.notifications.success('Battle joined!');
        //   context.notifications.staminaLow(current, required);

        const context = {
            version: SCRIPT_VERSION,
            storage,
            config,
            logger,
            dom,
            scheduler,
            events,
            ui,
            location: window.location,
            document,
            window,
            moduleRegistry,
            waveViewNavigation,
            // Phase 1 centralized services
            stamina,
            inventory,
            combat,
            // Phase 2 centralized services
            http,
            notifications,
            // Phase 3 utilities
        };
        
        // Create merchant service after context (needs numbers service)
        // Numbers service will be added below
        let merchantService = null;
        
        // Initialize Phase 3 Services (Battle stats, monster scanning, user session, number formatting)
        context.battleStats = createBattleStatsService(context);
        context.monsterScanner = createMonsterScannerService(context);
        context.userSession = createUserSessionService(context);
        context.numbers = createNumberFormattingService();
        
        // Initialize merchant service now that numbers service is available
        merchantService = createMerchantService(context);
        context.merchant = merchantService;
        
        // Schedule merchant checks if enabled
        if (cfg.merchantAutoBuy?.enabled) {
            logger.info('üõí Merchant Auto-Buy enabled');
            
            // Run initial check immediately
            (async () => {
                try {
                    // Show status on first load
                    const lastPurchase = storage.get('merchant.lastWeeklyPurchase', 0);
                    const nextRetry = storage.get('merchant.nextRetryTime', 0);
                    
                    if (lastPurchase === 0) {
                        logger.info('üõí First time setup - no previous purchase recorded');
                        logger.info('üí° Merchant will check for purchases on next scheduled run');
                    } else {
                        const now = Date.now();
                        const weekInMs = 7 * 24 * 60 * 60 * 1000;
                        const nextPurchase = lastPurchase + weekInMs;
                        const timeLeft = nextPurchase - now;
                        
                        if (timeLeft > 0) {
                            const daysLeft = Math.floor(timeLeft / (24 * 60 * 60 * 1000));
                            const hoursLeft = Math.floor((timeLeft % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                            logger.info(`‚è∞ Next merchant purchase in: ${daysLeft}d ${hoursLeft}h`);
                        } else {
                            logger.info('‚úÖ Merchant purchase is available now!');
                        }
                    }
                    
                    // Check if retry is pending
                    if (nextRetry > 0) {
                        const now = Date.now();
                        const retryTimeLeft = nextRetry - now;
                        if (retryTimeLeft > 0) {
                            const minutesLeft = Math.ceil(retryTimeLeft / (60 * 1000));
                            logger.info(`üîÑ Retry scheduled in ${minutesLeft} minutes (insufficient gold)`);
                        }
                    }
                    
                    // Check if it's time for weekly purchase
                    if (merchantService.shouldPerformWeeklyPurchase()) {
                        logger.info('üõí Time for weekly merchant purchases!');
                        await merchantService.performWeeklyPurchases();
                    }
                    
                    // Check if we should retry after insufficient gold
                    if (merchantService.shouldRetryAfterInsufficientGold()) {
                        logger.info('üõí Retrying merchant purchases after insufficient gold');
                        await merchantService.performWeeklyPurchases();
                    }
                    
                    // Show renewal notification if close
                    merchantService.checkWeeklyRenewal();
                } catch (error) {
                    logger.error('Error in initial merchant check:', error);
                }
            })();
            
            // Check weekly renewal every hour
            scheduler.repeat(async () => {
                merchantService.checkWeeklyRenewal();
                
                // Check if it's time for weekly purchase
                if (merchantService.shouldPerformWeeklyPurchase()) {
                    logger.info('üõí Time for weekly merchant purchases!');
                    await merchantService.performWeeklyPurchases();
                }
                
                // Check if we should retry after insufficient gold
                if (merchantService.shouldRetryAfterInsufficientGold()) {
                    logger.info('üõí Retrying merchant purchases after insufficient gold');
                    await merchantService.performWeeklyPurchases();
                }
            }, cfg.merchantAutoBuy.checkInterval);
        }
        
        // Initialize Unified Loot Service (Phase 4 - Unified loot management)
        context.loot = createLootService(context);
        
        // Initialize Damage Calculator services (Phase 1 - Data extraction & calculations)
        context.dataExtractor = createDataExtractorService(context);
        context.damageCalculator = createDamageCalculatorService(context);
        
        // Initialize Profile Manager (Phase 4)
        context.profileManager = createProfileManager(context);
        
        // Expose services globally for console testing
        // Use unsafeWindow to ensure it's accessible in browser console
        const globalWindow = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;
        globalWindow.autoDSServices = {
            dataExtractor: context.dataExtractor,
            damageCalculator: context.damageCalculator,
            merchant: context.merchant,  // Expose merchant for testing
            context: context,  // Expose full context for debugging
            version: SCRIPT_VERSION
        };
        logger.info('‚úÖ Services exposed globally: window.autoDSServices (version ' + SCRIPT_VERSION + ')');

        moduleRegistry.register(uiShellModule);
        moduleRegistry.register(floatingHelpersModule);  // Floating helpers for potions and loot
        moduleRegistry.register(damageCalculatorModule);  // Damage calculator widget (stats/pets/inventory pages)
        moduleRegistry.register(attackUnlockerModule);  // Always active on battle pages
        moduleRegistry.register(directJoinButtonsModule);  // "Join Now" / "Fight Now" buttons (always visible)
        moduleRegistry.register(dungeonLootHelperModule);  // Loot buttons on dungeon locations
        moduleRegistry.register(collectionsOrganizerModule);  // Organize collections page (claimed at bottom)
        moduleRegistry.register(imageBlockModule);
        moduleRegistry.register(pvpModule);  // PvP - Ultra Fast automation via API direct attacks
        moduleRegistry.register(waveUiModule);  // Wave UI enhancements (independent of automation)
        moduleRegistry.register(ultraFastAttackModule);  // Ultra Fast Attack - parallel batch operations
        moduleRegistry.register(ultraFastLootModule);  // Ultra Fast Loot - parallel loot collection
        moduleRegistry.register(ultraFastStaminaModule);  // Ultra Fast Stamina - parallel chapter reactions
        moduleRegistry.register(ultraFastDungeonModule);  // Ultra Fast Dungeon - smart damage dungeon farming
        moduleRegistry.register(specialBossFarmModule);  // Special Boss Farm - dedicated farm for General/King/Empress/Bastion
        moduleRegistry.register(ultraFastWaveModule);
        moduleRegistry.register(autoBossModule);  // AutoBoss - high-damage boss farming

        moduleRegistry.initAll(context);
        context.modulesCount = 18;  // Updated count after removing duplicate PvP module
        
        // Auto-detect user ID from cookie and start monitoring (Phase 3 service)
        context.userSession.ensureUserId();
        context.userSession.startAutoDetect(10000); // Check every 10 seconds
        
        moduleRegistry.activateFor(context);

        // REMOVIDO: Quest Widget (fetch bloqueado pelo site)

        // Inicializar Smart Damage Calculation na p√°gina de stats
        if (window.location.pathname.includes('stats.php')) {
            scheduler.addTimeout(() => {
                addSmartDamageDisplay();
            }, 500, 'Smart Damage Display Init');
        }

        // Inicializar Dungeon Pills nas p√°ginas de wave
        if (window.location.pathname.includes('active_wave.php') || window.location.pathname.includes('wave.php')) {
            scheduler.addTimeout(() => {
                addDungeonPills();
            }, 800, 'Dungeon Pills Init');
        }

        // Inicializar Guild Dungeon Loot All Button
        if (window.location.pathname.includes('guild_dungeon_location.php')) {
            scheduler.addTimeout(() => {
                addGuildDungeonLootAllButton();
            }, 800, 'Guild Dungeon Loot All Init');
        }

        window.addEventListener('beforeunload', () => {
            scheduler.disposeAll();
        });
        
        // Listen for log floater config changes
        events.on('config:change', () => {
            const newCfg = config.get();
            const floaterEnabled = newCfg.ui?.logFloater?.enabled !== false;
            toggleLogFloaterVisibility(floaterEnabled);
        });

        // logger.info('AutoDS Unified Automator bootstrapped', { version: SCRIPT_VERSION });
        // logger.info('üí° User ID detection: getUserIdFromCookie() always checks "demon" cookie');
        events.emit('autods:ready', { version: SCRIPT_VERSION });
    }

    try {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
            bootstrap();
        }
    } catch (error) {
        console.error('[AutoDS] Fatal bootstrap error', error);
    }

})();