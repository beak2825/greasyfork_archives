// ==UserScript==
// @name         jpnkn-browser
// @namespace    jpnkn-browser-extension
// @version      0.1.0
// @author       nijifun
// @description  bbs.jpnkn.comの非公式クライアントです。主に作者がにじさんじなかよし掲示板を快適に使うために開発しています。インストールした後各掲示板のトップに行くとサイドバーに「Stream Client」メニューが表示されるのでそれをクリックすると利用できます。
// @match        https://bbs.jpnkn.com/*
// @downloadURL https://update.greasyfork.org/scripts/470226/jpnkn-browser.user.js
// @updateURL https://update.greasyfork.org/scripts/470226/jpnkn-browser.meta.js
// ==/UserScript==

(o=>{const e=document.createElement("style");e.dataset.source="vite-plugin-monkey",e.textContent=o,document.head.append(e)})(" img{max-width:100%;height:auto}._App_134ae_1{height:100vh;display:flex;flex-direction:column}._main_134ae_7{overflow-y:scroll;flex-grow:1}._messageHeader_134ae_12{display:flex;flex-direction:row;justify-content:space-between;align-items:center;padding:5px 10px;background-color:#f2f2f2;border-bottom:1px solid #ddd}._headerNo_134ae_22{color:#929292;margin-right:4px}._headerUsername_134ae_27{color:#333;font-weight:700}._headerTrip_134ae_32{color:#666}._headerTimestamp_134ae_36{color:#999;font-size:.9em}._headerID_134ae_41{color:#999;font-size:.9em;text-align:right}._replyList_134ae_47{border-left:2px solid #888;margin-left:20px}._nestedReplyList_134ae_52{border-left:2px solid #888;margin-left:6px}._reply_134ae_47{display:flex;flex-direction:column;align-items:flex-start;justify-content:space-between;background-color:#f9f9f9;border-radius:5px;padding:5px 5px 5px 10px}._replyNo_134ae_68{color:#595959;font-size:.8em;line-height:1;padding:0;margin:0}._replyBody_134ae_76{flex-grow:1;margin-left:6px;word-break:break-all}._replyBody_134ae_76 img{max-width:120px;max-height:120px;object-fit:cover;margin:4px}._replyBody_134ae_76 img+br:has(+img){display:none}._Body_134ae_93{padding:6px;color:#333;word-break:break-all}@media (max-width: 680px){._headerTimestamp_134ae_36,._headerID_134ae_41{display:none}}._scrollToBottomButton_134ae_106{position:fixed;right:20px;bottom:70px;z-index:100;background:#008CBA;color:#fff;border:none;text-align:center;text-decoration:none;display:inline-block;font-size:24px;border-radius:50%;cursor:pointer;line-height:1;padding:4px 6px}._form_134ae_124{display:flex;justify-content:space-between;padding:10px;background-color:#fff;border-top:1px solid #ddd;flex-shrink:0}._form_134ae_124 textarea{flex-grow:1;margin-right:10px;padding:5px;border:1px solid #ddd;border-radius:4px;height:40px;resize:none}._form_134ae_124 input[type=text]{flex-grow:1;margin-right:10px;padding:5px;border:1px solid #ddd;border-radius:4px;height:40px}._form_134ae_124 button{padding:5px 10px;border:none;background-color:#007bff;color:#fff;border-radius:4px;cursor:pointer;transition:background-color .3s ease}._form_134ae_124 button[disabled]{background-color:#ccc;cursor:not-allowed} ");

(function () {
  'use strict';

  const equalFn = (a, b) => a === b;
  const $PROXY = Symbol("solid-proxy");
  const $TRACK = Symbol("solid-track");
  const signalOptions = {
    equals: equalFn
  };
  let runEffects = runQueue;
  const STALE = 1;
  const PENDING = 2;
  const UNOWNED = {
    owned: null,
    cleanups: null,
    context: null,
    owner: null
  };
  var Owner = null;
  let Transition = null;
  let Listener = null;
  let Updates = null;
  let Effects = null;
  let ExecCount = 0;
  function createRoot(fn, detachedOwner) {
    const listener = Listener, owner = Owner, unowned = fn.length === 0, root = unowned ? UNOWNED : {
      owned: null,
      cleanups: null,
      context: null,
      owner: detachedOwner === void 0 ? owner : detachedOwner
    }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
    Owner = root;
    Listener = null;
    try {
      return runUpdates(updateFn, true);
    } finally {
      Listener = listener;
      Owner = owner;
    }
  }
  function createSignal(value, options) {
    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
    const s = {
      value,
      observers: null,
      observerSlots: null,
      comparator: options.equals || void 0
    };
    const setter = (value2) => {
      if (typeof value2 === "function") {
        value2 = value2(s.value);
      }
      return writeSignal(s, value2);
    };
    return [readSignal.bind(s), setter];
  }
  function createRenderEffect(fn, value, options) {
    const c = createComputation(fn, value, false, STALE);
    updateComputation(c);
  }
  function createEffect(fn, value, options) {
    runEffects = runUserEffects;
    const c = createComputation(fn, value, false, STALE);
    if (!options || !options.render)
      c.user = true;
    Effects ? Effects.push(c) : updateComputation(c);
  }
  function createReaction(onInvalidate, options) {
    let fn;
    const c = createComputation(() => {
      fn ? fn() : untrack(onInvalidate);
      fn = void 0;
    }, void 0, false, 0);
    c.user = true;
    return (tracking) => {
      fn = tracking;
      updateComputation(c);
    };
  }
  function createMemo(fn, value, options) {
    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
    const c = createComputation(fn, value, true, 0);
    c.observers = null;
    c.observerSlots = null;
    c.comparator = options.equals || void 0;
    updateComputation(c);
    return readSignal.bind(c);
  }
  function untrack(fn) {
    if (Listener === null)
      return fn();
    const listener = Listener;
    Listener = null;
    try {
      return fn();
    } finally {
      Listener = listener;
    }
  }
  function onMount(fn) {
    createEffect(() => untrack(fn));
  }
  function onCleanup(fn) {
    if (Owner === null)
      ;
    else if (Owner.cleanups === null)
      Owner.cleanups = [fn];
    else
      Owner.cleanups.push(fn);
    return fn;
  }
  function readSignal() {
    if (this.sources && this.state) {
      if (this.state === STALE)
        updateComputation(this);
      else {
        const updates = Updates;
        Updates = null;
        runUpdates(() => lookUpstream(this), false);
        Updates = updates;
      }
    }
    if (Listener) {
      const sSlot = this.observers ? this.observers.length : 0;
      if (!Listener.sources) {
        Listener.sources = [this];
        Listener.sourceSlots = [sSlot];
      } else {
        Listener.sources.push(this);
        Listener.sourceSlots.push(sSlot);
      }
      if (!this.observers) {
        this.observers = [Listener];
        this.observerSlots = [Listener.sources.length - 1];
      } else {
        this.observers.push(Listener);
        this.observerSlots.push(Listener.sources.length - 1);
      }
    }
    return this.value;
  }
  function writeSignal(node, value, isComp) {
    let current = node.value;
    if (!node.comparator || !node.comparator(current, value)) {
      node.value = value;
      if (node.observers && node.observers.length) {
        runUpdates(() => {
          for (let i = 0; i < node.observers.length; i += 1) {
            const o = node.observers[i];
            const TransitionRunning = Transition && Transition.running;
            if (TransitionRunning && Transition.disposed.has(o))
              ;
            if (TransitionRunning ? !o.tState : !o.state) {
              if (o.pure)
                Updates.push(o);
              else
                Effects.push(o);
              if (o.observers)
                markDownstream(o);
            }
            if (!TransitionRunning)
              o.state = STALE;
          }
          if (Updates.length > 1e6) {
            Updates = [];
            if (false)
              ;
            throw new Error();
          }
        }, false);
      }
    }
    return value;
  }
  function updateComputation(node) {
    if (!node.fn)
      return;
    cleanNode(node);
    const owner = Owner, listener = Listener, time = ExecCount;
    Listener = Owner = node;
    runComputation(node, node.value, time);
    Listener = listener;
    Owner = owner;
  }
  function runComputation(node, value, time) {
    let nextValue;
    try {
      nextValue = node.fn(value);
    } catch (err) {
      if (node.pure) {
        {
          node.state = STALE;
          node.owned && node.owned.forEach(cleanNode);
          node.owned = null;
        }
      }
      node.updatedAt = time + 1;
      return handleError(err);
    }
    if (!node.updatedAt || node.updatedAt <= time) {
      if (node.updatedAt != null && "observers" in node) {
        writeSignal(node, nextValue);
      } else
        node.value = nextValue;
      node.updatedAt = time;
    }
  }
  function createComputation(fn, init, pure, state = STALE, options) {
    const c = {
      fn,
      state,
      updatedAt: null,
      owned: null,
      sources: null,
      sourceSlots: null,
      cleanups: null,
      value: init,
      owner: Owner,
      context: null,
      pure
    };
    if (Owner === null)
      ;
    else if (Owner !== UNOWNED) {
      {
        if (!Owner.owned)
          Owner.owned = [c];
        else
          Owner.owned.push(c);
      }
    }
    return c;
  }
  function runTop(node) {
    if (node.state === 0)
      return;
    if (node.state === PENDING)
      return lookUpstream(node);
    if (node.suspense && untrack(node.suspense.inFallback))
      return node.suspense.effects.push(node);
    const ancestors = [node];
    while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
      if (node.state)
        ancestors.push(node);
    }
    for (let i = ancestors.length - 1; i >= 0; i--) {
      node = ancestors[i];
      if (node.state === STALE) {
        updateComputation(node);
      } else if (node.state === PENDING) {
        const updates = Updates;
        Updates = null;
        runUpdates(() => lookUpstream(node, ancestors[0]), false);
        Updates = updates;
      }
    }
  }
  function runUpdates(fn, init) {
    if (Updates)
      return fn();
    let wait = false;
    if (!init)
      Updates = [];
    if (Effects)
      wait = true;
    else
      Effects = [];
    ExecCount++;
    try {
      const res = fn();
      completeUpdates(wait);
      return res;
    } catch (err) {
      if (!wait)
        Effects = null;
      Updates = null;
      handleError(err);
    }
  }
  function completeUpdates(wait) {
    if (Updates) {
      runQueue(Updates);
      Updates = null;
    }
    if (wait)
      return;
    const e = Effects;
    Effects = null;
    if (e.length)
      runUpdates(() => runEffects(e), false);
  }
  function runQueue(queue) {
    for (let i = 0; i < queue.length; i++)
      runTop(queue[i]);
  }
  function runUserEffects(queue) {
    let i, userLength = 0;
    for (i = 0; i < queue.length; i++) {
      const e = queue[i];
      if (!e.user)
        runTop(e);
      else
        queue[userLength++] = e;
    }
    for (i = 0; i < userLength; i++)
      runTop(queue[i]);
  }
  function lookUpstream(node, ignore) {
    node.state = 0;
    for (let i = 0; i < node.sources.length; i += 1) {
      const source = node.sources[i];
      if (source.sources) {
        const state = source.state;
        if (state === STALE) {
          if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))
            runTop(source);
        } else if (state === PENDING)
          lookUpstream(source, ignore);
      }
    }
  }
  function markDownstream(node) {
    for (let i = 0; i < node.observers.length; i += 1) {
      const o = node.observers[i];
      if (!o.state) {
        o.state = PENDING;
        if (o.pure)
          Updates.push(o);
        else
          Effects.push(o);
        o.observers && markDownstream(o);
      }
    }
  }
  function cleanNode(node) {
    let i;
    if (node.sources) {
      while (node.sources.length) {
        const source = node.sources.pop(), index2 = node.sourceSlots.pop(), obs = source.observers;
        if (obs && obs.length) {
          const n = obs.pop(), s = source.observerSlots.pop();
          if (index2 < obs.length) {
            n.sourceSlots[s] = index2;
            obs[index2] = n;
            source.observerSlots[index2] = s;
          }
        }
      }
    }
    if (node.owned) {
      for (i = node.owned.length - 1; i >= 0; i--)
        cleanNode(node.owned[i]);
      node.owned = null;
    }
    if (node.cleanups) {
      for (i = node.cleanups.length - 1; i >= 0; i--)
        node.cleanups[i]();
      node.cleanups = null;
    }
    node.state = 0;
    node.context = null;
  }
  function castError(err) {
    if (err instanceof Error)
      return err;
    return new Error(typeof err === "string" ? err : "Unknown error", {
      cause: err
    });
  }
  function handleError(err, owner = Owner) {
    const error = castError(err);
    throw error;
  }
  const FALLBACK = Symbol("fallback");
  function dispose(d) {
    for (let i = 0; i < d.length; i++)
      d[i]();
  }
  function mapArray(list, mapFn, options = {}) {
    let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
    onCleanup(() => dispose(disposers));
    return () => {
      let newItems = list() || [], i, j;
      newItems[$TRACK];
      return untrack(() => {
        let newLen = newItems.length, newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
        if (newLen === 0) {
          if (len !== 0) {
            dispose(disposers);
            disposers = [];
            items = [];
            mapped = [];
            len = 0;
            indexes && (indexes = []);
          }
          if (options.fallback) {
            items = [FALLBACK];
            mapped[0] = createRoot((disposer) => {
              disposers[0] = disposer;
              return options.fallback();
            });
            len = 1;
          }
        } else if (len === 0) {
          mapped = new Array(newLen);
          for (j = 0; j < newLen; j++) {
            items[j] = newItems[j];
            mapped[j] = createRoot(mapper);
          }
          len = newLen;
        } else {
          temp = new Array(newLen);
          tempdisposers = new Array(newLen);
          indexes && (tempIndexes = new Array(newLen));
          for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++)
            ;
          for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
            temp[newEnd] = mapped[end];
            tempdisposers[newEnd] = disposers[end];
            indexes && (tempIndexes[newEnd] = indexes[end]);
          }
          newIndices = /* @__PURE__ */ new Map();
          newIndicesNext = new Array(newEnd + 1);
          for (j = newEnd; j >= start; j--) {
            item = newItems[j];
            i = newIndices.get(item);
            newIndicesNext[j] = i === void 0 ? -1 : i;
            newIndices.set(item, j);
          }
          for (i = start; i <= end; i++) {
            item = items[i];
            j = newIndices.get(item);
            if (j !== void 0 && j !== -1) {
              temp[j] = mapped[i];
              tempdisposers[j] = disposers[i];
              indexes && (tempIndexes[j] = indexes[i]);
              j = newIndicesNext[j];
              newIndices.set(item, j);
            } else
              disposers[i]();
          }
          for (j = start; j < newLen; j++) {
            if (j in temp) {
              mapped[j] = temp[j];
              disposers[j] = tempdisposers[j];
              if (indexes) {
                indexes[j] = tempIndexes[j];
                indexes[j](j);
              }
            } else
              mapped[j] = createRoot(mapper);
          }
          mapped = mapped.slice(0, len = newLen);
          items = newItems.slice(0);
        }
        return mapped;
      });
      function mapper(disposer) {
        disposers[j] = disposer;
        if (indexes) {
          const [s, set] = createSignal(j);
          indexes[j] = set;
          return mapFn(newItems[j], s);
        }
        return mapFn(newItems[j]);
      }
    };
  }
  function createComponent(Comp, props) {
    return untrack(() => Comp(props || {}));
  }
  function trueFn() {
    return true;
  }
  const propTraps = {
    get(_, property, receiver) {
      if (property === $PROXY)
        return receiver;
      return _.get(property);
    },
    has(_, property) {
      if (property === $PROXY)
        return true;
      return _.has(property);
    },
    set: trueFn,
    deleteProperty: trueFn,
    getOwnPropertyDescriptor(_, property) {
      return {
        configurable: true,
        enumerable: true,
        get() {
          return _.get(property);
        },
        set: trueFn,
        deleteProperty: trueFn
      };
    },
    ownKeys(_) {
      return _.keys();
    }
  };
  function resolveSource(s) {
    return !(s = typeof s === "function" ? s() : s) ? {} : s;
  }
  function resolveSources() {
    for (let i = 0, length = this.length; i < length; ++i) {
      const v = this[i]();
      if (v !== void 0)
        return v;
    }
  }
  function mergeProps(...sources) {
    let proxy = false;
    for (let i = 0; i < sources.length; i++) {
      const s = sources[i];
      proxy = proxy || !!s && $PROXY in s;
      sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
    }
    if (proxy) {
      return new Proxy({
        get(property) {
          for (let i = sources.length - 1; i >= 0; i--) {
            const v = resolveSource(sources[i])[property];
            if (v !== void 0)
              return v;
          }
        },
        has(property) {
          for (let i = sources.length - 1; i >= 0; i--) {
            if (property in resolveSource(sources[i]))
              return true;
          }
          return false;
        },
        keys() {
          const keys = [];
          for (let i = 0; i < sources.length; i++)
            keys.push(...Object.keys(resolveSource(sources[i])));
          return [...new Set(keys)];
        }
      }, propTraps);
    }
    const target = {};
    const sourcesMap = {};
    const defined = /* @__PURE__ */ new Set();
    for (let i = sources.length - 1; i >= 0; i--) {
      const source = sources[i];
      if (!source)
        continue;
      const sourceKeys = Object.getOwnPropertyNames(source);
      for (let i2 = 0, length = sourceKeys.length; i2 < length; i2++) {
        const key = sourceKeys[i2];
        if (key === "__proto__" || key === "constructor")
          continue;
        const desc = Object.getOwnPropertyDescriptor(source, key);
        if (!defined.has(key)) {
          if (desc.get) {
            defined.add(key);
            Object.defineProperty(target, key, {
              enumerable: true,
              configurable: true,
              get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
            });
          } else {
            if (desc.value !== void 0)
              defined.add(key);
            target[key] = desc.value;
          }
        } else {
          const sources2 = sourcesMap[key];
          if (sources2) {
            if (desc.get) {
              sources2.push(desc.get.bind(source));
            } else if (desc.value !== void 0) {
              sources2.push(() => desc.value);
            }
          } else if (target[key] === void 0)
            target[key] = desc.value;
        }
      }
    }
    return target;
  }
  function splitProps(props, ...keys) {
    if ($PROXY in props) {
      const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
      const res = keys.map((k) => {
        return new Proxy({
          get(property) {
            return k.includes(property) ? props[property] : void 0;
          },
          has(property) {
            return k.includes(property) && property in props;
          },
          keys() {
            return k.filter((property) => property in props);
          }
        }, propTraps);
      });
      res.push(new Proxy({
        get(property) {
          return blocked.has(property) ? void 0 : props[property];
        },
        has(property) {
          return blocked.has(property) ? false : property in props;
        },
        keys() {
          return Object.keys(props).filter((k) => !blocked.has(k));
        }
      }, propTraps));
      return res;
    }
    const otherObject = {};
    const objects = keys.map(() => ({}));
    for (const propName of Object.getOwnPropertyNames(props)) {
      const desc = Object.getOwnPropertyDescriptor(props, propName);
      const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
      let blocked = false;
      let objectIndex = 0;
      for (const k of keys) {
        if (k.includes(propName)) {
          blocked = true;
          isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
        }
        ++objectIndex;
      }
      if (!blocked) {
        isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
      }
    }
    return [...objects, otherObject];
  }
  const narrowedError = (name2) => `Stale read from <${name2}>.`;
  function For(props) {
    const fallback = "fallback" in props && {
      fallback: () => props.fallback
    };
    return createMemo(mapArray(() => props.each, props.children, fallback || void 0));
  }
  function Show(props) {
    const keyed = props.keyed;
    const condition = createMemo(() => props.when, void 0, {
      equals: (a, b) => keyed ? a === b : !a === !b
    });
    return createMemo(() => {
      const c = condition();
      if (c) {
        const child = props.children;
        const fn = typeof child === "function" && child.length > 0;
        return fn ? untrack(() => child(keyed ? c : () => {
          if (!untrack(condition))
            throw narrowedError("Show");
          return props.when;
        })) : child;
      }
      return props.fallback;
    }, void 0, void 0);
  }
  const booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"];
  const Properties = /* @__PURE__ */ new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans]);
  const ChildProperties = /* @__PURE__ */ new Set(["innerHTML", "textContent", "innerText", "children"]);
  const Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
    className: "class",
    htmlFor: "for"
  });
  const PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
    class: "className",
    formnovalidate: {
      $: "formNoValidate",
      BUTTON: 1,
      INPUT: 1
    },
    ismap: {
      $: "isMap",
      IMG: 1
    },
    nomodule: {
      $: "noModule",
      SCRIPT: 1
    },
    playsinline: {
      $: "playsInline",
      VIDEO: 1
    },
    readonly: {
      $: "readOnly",
      INPUT: 1,
      TEXTAREA: 1
    }
  });
  function getPropAlias(prop, tagName) {
    const a = PropAliases[prop];
    return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
  }
  const DelegatedEvents = /* @__PURE__ */ new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]);
  const SVGNamespace = {
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace"
  };
  function reconcileArrays(parentNode, a, b) {
    let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
    while (aStart < aEnd || bStart < bEnd) {
      if (a[aStart] === b[bStart]) {
        aStart++;
        bStart++;
        continue;
      }
      while (a[aEnd - 1] === b[bEnd - 1]) {
        aEnd--;
        bEnd--;
      }
      if (aEnd === aStart) {
        const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
        while (bStart < bEnd)
          parentNode.insertBefore(b[bStart++], node);
      } else if (bEnd === bStart) {
        while (aStart < aEnd) {
          if (!map || !map.has(a[aStart]))
            a[aStart].remove();
          aStart++;
        }
      } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
        const node = a[--aEnd].nextSibling;
        parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
        parentNode.insertBefore(b[--bEnd], node);
        a[aEnd] = b[bEnd];
      } else {
        if (!map) {
          map = /* @__PURE__ */ new Map();
          let i = bStart;
          while (i < bEnd)
            map.set(b[i], i++);
        }
        const index2 = map.get(a[aStart]);
        if (index2 != null) {
          if (bStart < index2 && index2 < bEnd) {
            let i = aStart, sequence = 1, t;
            while (++i < aEnd && i < bEnd) {
              if ((t = map.get(a[i])) == null || t !== index2 + sequence)
                break;
              sequence++;
            }
            if (sequence > index2 - bStart) {
              const node = a[aStart];
              while (bStart < index2)
                parentNode.insertBefore(b[bStart++], node);
            } else
              parentNode.replaceChild(b[bStart++], a[aStart++]);
          } else
            aStart++;
        } else
          a[aStart++].remove();
      }
    }
  }
  const $$EVENTS = "_$DX_DELEGATE";
  function render(code, element, init, options = {}) {
    let disposer;
    createRoot((dispose2) => {
      disposer = dispose2;
      element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);
    }, options.owner);
    return () => {
      disposer();
      element.textContent = "";
    };
  }
  function template(html, isCE, isSVG) {
    let node;
    const create = () => {
      const t = document.createElement("template");
      t.innerHTML = html;
      return isSVG ? t.content.firstChild.firstChild : t.content.firstChild;
    };
    const fn = isCE ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
    fn.cloneNode = fn;
    return fn;
  }
  function delegateEvents(eventNames, document2 = window.document) {
    const e = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
    for (let i = 0, l = eventNames.length; i < l; i++) {
      const name2 = eventNames[i];
      if (!e.has(name2)) {
        e.add(name2);
        document2.addEventListener(name2, eventHandler);
      }
    }
  }
  function setAttribute(node, name2, value) {
    if (value == null)
      node.removeAttribute(name2);
    else
      node.setAttribute(name2, value);
  }
  function setAttributeNS(node, namespace, name2, value) {
    if (value == null)
      node.removeAttributeNS(namespace, name2);
    else
      node.setAttributeNS(namespace, name2, value);
  }
  function className(node, value) {
    if (value == null)
      node.removeAttribute("class");
    else
      node.className = value;
  }
  function addEventListener(node, name2, handler, delegate) {
    if (delegate) {
      if (Array.isArray(handler)) {
        node[`$$${name2}`] = handler[0];
        node[`$$${name2}Data`] = handler[1];
      } else
        node[`$$${name2}`] = handler;
    } else if (Array.isArray(handler)) {
      const handlerFn = handler[0];
      node.addEventListener(name2, handler[0] = (e) => handlerFn.call(node, handler[1], e));
    } else
      node.addEventListener(name2, handler);
  }
  function classList(node, value, prev = {}) {
    const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);
    let i, len;
    for (i = 0, len = prevKeys.length; i < len; i++) {
      const key = prevKeys[i];
      if (!key || key === "undefined" || value[key])
        continue;
      toggleClassKey(node, key, false);
      delete prev[key];
    }
    for (i = 0, len = classKeys.length; i < len; i++) {
      const key = classKeys[i], classValue = !!value[key];
      if (!key || key === "undefined" || prev[key] === classValue || !classValue)
        continue;
      toggleClassKey(node, key, true);
      prev[key] = classValue;
    }
    return prev;
  }
  function style(node, value, prev) {
    if (!value)
      return prev ? setAttribute(node, "style") : value;
    const nodeStyle = node.style;
    if (typeof value === "string")
      return nodeStyle.cssText = value;
    typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
    prev || (prev = {});
    value || (value = {});
    let v, s;
    for (s in prev) {
      value[s] == null && nodeStyle.removeProperty(s);
      delete prev[s];
    }
    for (s in value) {
      v = value[s];
      if (v !== prev[s]) {
        nodeStyle.setProperty(s, v);
        prev[s] = v;
      }
    }
    return prev;
  }
  function spread(node, props = {}, isSVG, skipChildren) {
    const prevProps = {};
    if (!skipChildren) {
      createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
    }
    createRenderEffect(() => props.ref && props.ref(node));
    createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));
    return prevProps;
  }
  function use(fn, element, arg) {
    return untrack(() => fn(element, arg));
  }
  function insert(parent, accessor, marker, initial) {
    if (marker !== void 0 && !initial)
      initial = [];
    if (typeof accessor !== "function")
      return insertExpression(parent, accessor, initial, marker);
    createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
  }
  function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
    props || (props = {});
    for (const prop in prevProps) {
      if (!(prop in props)) {
        if (prop === "children")
          continue;
        prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);
      }
    }
    for (const prop in props) {
      if (prop === "children") {
        if (!skipChildren)
          insertExpression(node, props.children);
        continue;
      }
      const value = props[prop];
      prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);
    }
  }
  function toPropertyName(name2) {
    return name2.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
  }
  function toggleClassKey(node, key, value) {
    const classNames = key.trim().split(/\s+/);
    for (let i = 0, nameLen = classNames.length; i < nameLen; i++)
      node.classList.toggle(classNames[i], value);
  }
  function assignProp(node, prop, value, prev, isSVG, skipRef) {
    let isCE, isProp, isChildProp, propAlias, forceProp;
    if (prop === "style")
      return style(node, value, prev);
    if (prop === "classList")
      return classList(node, value, prev);
    if (value === prev)
      return prev;
    if (prop === "ref") {
      if (!skipRef)
        value(node);
    } else if (prop.slice(0, 3) === "on:") {
      const e = prop.slice(3);
      prev && node.removeEventListener(e, prev);
      value && node.addEventListener(e, value);
    } else if (prop.slice(0, 10) === "oncapture:") {
      const e = prop.slice(10);
      prev && node.removeEventListener(e, prev, true);
      value && node.addEventListener(e, value, true);
    } else if (prop.slice(0, 2) === "on") {
      const name2 = prop.slice(2).toLowerCase();
      const delegate = DelegatedEvents.has(name2);
      if (!delegate && prev) {
        const h = Array.isArray(prev) ? prev[0] : prev;
        node.removeEventListener(name2, h);
      }
      if (delegate || value) {
        addEventListener(node, name2, value, delegate);
        delegate && delegateEvents([name2]);
      }
    } else if (prop.slice(0, 5) === "attr:") {
      setAttribute(node, prop.slice(5), value);
    } else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-"))) {
      if (forceProp) {
        prop = prop.slice(5);
        isProp = true;
      }
      if (prop === "class" || prop === "className")
        className(node, value);
      else if (isCE && !isProp && !isChildProp)
        node[toPropertyName(prop)] = value;
      else
        node[propAlias || prop] = value;
    } else {
      const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
      if (ns)
        setAttributeNS(node, ns, prop, value);
      else
        setAttribute(node, Aliases[prop] || prop, value);
    }
    return value;
  }
  function eventHandler(e) {
    const key = `$$${e.type}`;
    let node = e.composedPath && e.composedPath()[0] || e.target;
    if (e.target !== node) {
      Object.defineProperty(e, "target", {
        configurable: true,
        value: node
      });
    }
    Object.defineProperty(e, "currentTarget", {
      configurable: true,
      get() {
        return node || document;
      }
    });
    while (node) {
      const handler = node[key];
      if (handler && !node.disabled) {
        const data = node[`${key}Data`];
        data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
        if (e.cancelBubble)
          return;
      }
      node = node._$host || node.parentNode || node.host;
    }
  }
  function insertExpression(parent, value, current, marker, unwrapArray) {
    while (typeof current === "function")
      current = current();
    if (value === current)
      return current;
    const t = typeof value, multi = marker !== void 0;
    parent = multi && current[0] && current[0].parentNode || parent;
    if (t === "string" || t === "number") {
      if (t === "number")
        value = value.toString();
      if (multi) {
        let node = current[0];
        if (node && node.nodeType === 3) {
          node.data = value;
        } else
          node = document.createTextNode(value);
        current = cleanChildren(parent, current, marker, node);
      } else {
        if (current !== "" && typeof current === "string") {
          current = parent.firstChild.data = value;
        } else
          current = parent.textContent = value;
      }
    } else if (value == null || t === "boolean") {
      current = cleanChildren(parent, current, marker);
    } else if (t === "function") {
      createRenderEffect(() => {
        let v = value();
        while (typeof v === "function")
          v = v();
        current = insertExpression(parent, v, current, marker);
      });
      return () => current;
    } else if (Array.isArray(value)) {
      const array = [];
      const currentArray = current && Array.isArray(current);
      if (normalizeIncomingArray(array, value, current, unwrapArray)) {
        createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
        return () => current;
      }
      if (array.length === 0) {
        current = cleanChildren(parent, current, marker);
        if (multi)
          return current;
      } else if (currentArray) {
        if (current.length === 0) {
          appendNodes(parent, array, marker);
        } else
          reconcileArrays(parent, current, array);
      } else {
        current && cleanChildren(parent);
        appendNodes(parent, array);
      }
      current = array;
    } else if (value.nodeType) {
      if (Array.isArray(current)) {
        if (multi)
          return current = cleanChildren(parent, current, marker, value);
        cleanChildren(parent, current, null, value);
      } else if (current == null || current === "" || !parent.firstChild) {
        parent.appendChild(value);
      } else
        parent.replaceChild(value, parent.firstChild);
      current = value;
    } else
      console.warn(`Unrecognized value. Skipped inserting`, value);
    return current;
  }
  function normalizeIncomingArray(normalized, array, current, unwrap) {
    let dynamic = false;
    for (let i = 0, len = array.length; i < len; i++) {
      let item = array[i], prev = current && current[i], t;
      if (item == null || item === true || item === false)
        ;
      else if ((t = typeof item) === "object" && item.nodeType) {
        normalized.push(item);
      } else if (Array.isArray(item)) {
        dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
      } else if (t === "function") {
        if (unwrap) {
          while (typeof item === "function")
            item = item();
          dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
        } else {
          normalized.push(item);
          dynamic = true;
        }
      } else {
        const value = String(item);
        if (prev && prev.nodeType === 3 && prev.data === value)
          normalized.push(prev);
        else
          normalized.push(document.createTextNode(value));
      }
    }
    return dynamic;
  }
  function appendNodes(parent, array, marker = null) {
    for (let i = 0, len = array.length; i < len; i++)
      parent.insertBefore(array[i], marker);
  }
  function cleanChildren(parent, current, marker, replacement) {
    if (marker === void 0)
      return parent.textContent = "";
    const node = replacement || document.createTextNode("");
    if (current.length) {
      let inserted = false;
      for (let i = current.length - 1; i >= 0; i--) {
        const el = current[i];
        if (node !== el) {
          const isParent = el.parentNode === parent;
          if (!inserted && !i)
            isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
          else
            isParent && el.remove();
        } else
          inserted = true;
      }
    } else
      parent.insertBefore(node, marker);
    return [node];
  }
  const isServer = false;
  const App$1 = "_App_134ae_1";
  const main$1 = "_main_134ae_7";
  const messageHeader = "_messageHeader_134ae_12";
  const headerNo = "_headerNo_134ae_22";
  const headerUsername = "_headerUsername_134ae_27";
  const headerTrip = "_headerTrip_134ae_32";
  const headerTimestamp = "_headerTimestamp_134ae_36";
  const headerID = "_headerID_134ae_41";
  const replyList = "_replyList_134ae_47";
  const nestedReplyList = "_nestedReplyList_134ae_52";
  const reply = "_reply_134ae_47";
  const replyNo = "_replyNo_134ae_68";
  const replyBody = "_replyBody_134ae_76";
  const Body = "_Body_134ae_93";
  const scrollToBottomButton = "_scrollToBottomButton_134ae_106";
  const form = "_form_134ae_124";
  const styles = {
    App: App$1,
    main: main$1,
    messageHeader,
    headerNo,
    headerUsername,
    headerTrip,
    headerTimestamp,
    headerID,
    replyList,
    nestedReplyList,
    reply,
    replyNo,
    replyBody,
    Body,
    scrollToBottomButton,
    form
  };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var mqtt$1 = { exports: {} };
  (function(module, exports) {
    (function(f) {
      {
        module.exports = f();
      }
    })(function() {
      return function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof commonjsRequire && commonjsRequire;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof commonjsRequire && commonjsRequire, i = 0; i < t.length; i++)
            o(t[i]);
          return o;
        }
        return r;
      }()({ 1: [function(require2, module2, exports2) {
        (function(process, global2) {
          (function() {
            const EventEmitter = require2("events").EventEmitter;
            const Store = require2("./store");
            const TopicAliasRecv = require2("./topic-alias-recv");
            const TopicAliasSend = require2("./topic-alias-send");
            const mqttPacket = require2("mqtt-packet");
            const DefaultMessageIdProvider = require2("./default-message-id-provider");
            const Writable = require2("readable-stream").Writable;
            const inherits = require2("inherits");
            const reInterval = require2("reinterval");
            const clone = require2("rfdc/default");
            const validations = require2("./validations");
            const xtend = require2("xtend");
            const debug = require2("debug")("mqttjs:client");
            const nextTick = process ? process.nextTick : function(callback) {
              setTimeout(callback, 0);
            };
            const setImmediate = global2.setImmediate || function(callback) {
              nextTick(callback);
            };
            const defaultConnectOptions = {
              keepalive: 60,
              reschedulePings: true,
              protocolId: "MQTT",
              protocolVersion: 4,
              reconnectPeriod: 1e3,
              connectTimeout: 30 * 1e3,
              clean: true,
              resubscribe: true
            };
            const socketErrors = [
              "ECONNREFUSED",
              "EADDRINUSE",
              "ECONNRESET",
              "ENOTFOUND",
              "ETIMEDOUT"
            ];
            const errors = {
              0: "",
              1: "Unacceptable protocol version",
              2: "Identifier rejected",
              3: "Server unavailable",
              4: "Bad username or password",
              5: "Not authorized",
              16: "No matching subscribers",
              17: "No subscription existed",
              128: "Unspecified error",
              129: "Malformed Packet",
              130: "Protocol Error",
              131: "Implementation specific error",
              132: "Unsupported Protocol Version",
              133: "Client Identifier not valid",
              134: "Bad User Name or Password",
              135: "Not authorized",
              136: "Server unavailable",
              137: "Server busy",
              138: "Banned",
              139: "Server shutting down",
              140: "Bad authentication method",
              141: "Keep Alive timeout",
              142: "Session taken over",
              143: "Topic Filter invalid",
              144: "Topic Name invalid",
              145: "Packet identifier in use",
              146: "Packet Identifier not found",
              147: "Receive Maximum exceeded",
              148: "Topic Alias invalid",
              149: "Packet too large",
              150: "Message rate too high",
              151: "Quota exceeded",
              152: "Administrative action",
              153: "Payload format invalid",
              154: "Retain not supported",
              155: "QoS not supported",
              156: "Use another server",
              157: "Server moved",
              158: "Shared Subscriptions not supported",
              159: "Connection rate exceeded",
              160: "Maximum connect time",
              161: "Subscription Identifiers not supported",
              162: "Wildcard Subscriptions not supported"
            };
            function defaultId() {
              return "mqttjs_" + Math.random().toString(16).substr(2, 8);
            }
            function applyTopicAlias(client, packet) {
              if (client.options.protocolVersion === 5) {
                if (packet.cmd === "publish") {
                  let alias;
                  if (packet.properties) {
                    alias = packet.properties.topicAlias;
                  }
                  const topic = packet.topic.toString();
                  if (client.topicAliasSend) {
                    if (alias) {
                      if (topic.length !== 0) {
                        debug("applyTopicAlias :: register topic: %s - alias: %d", topic, alias);
                        if (!client.topicAliasSend.put(topic, alias)) {
                          debug("applyTopicAlias :: error out of range. topic: %s - alias: %d", topic, alias);
                          return new Error("Sending Topic Alias out of range");
                        }
                      }
                    } else {
                      if (topic.length !== 0) {
                        if (client.options.autoAssignTopicAlias) {
                          alias = client.topicAliasSend.getAliasByTopic(topic);
                          if (alias) {
                            packet.topic = "";
                            packet.properties = { ...packet.properties, topicAlias: alias };
                            debug("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", topic, alias);
                          } else {
                            alias = client.topicAliasSend.getLruAlias();
                            client.topicAliasSend.put(topic, alias);
                            packet.properties = { ...packet.properties, topicAlias: alias };
                            debug("applyTopicAlias :: auto assign topic: %s - alias: %d", topic, alias);
                          }
                        } else if (client.options.autoUseTopicAlias) {
                          alias = client.topicAliasSend.getAliasByTopic(topic);
                          if (alias) {
                            packet.topic = "";
                            packet.properties = { ...packet.properties, topicAlias: alias };
                            debug("applyTopicAlias :: auto use topic: %s - alias: %d", topic, alias);
                          }
                        }
                      }
                    }
                  } else if (alias) {
                    debug("applyTopicAlias :: error out of range. topic: %s - alias: %d", topic, alias);
                    return new Error("Sending Topic Alias out of range");
                  }
                }
              }
            }
            function removeTopicAliasAndRecoverTopicName(client, packet) {
              let alias;
              if (packet.properties) {
                alias = packet.properties.topicAlias;
              }
              let topic = packet.topic.toString();
              if (topic.length === 0) {
                if (typeof alias === "undefined") {
                  return new Error("Unregistered Topic Alias");
                } else {
                  topic = client.topicAliasSend.getTopicByAlias(alias);
                  if (typeof topic === "undefined") {
                    return new Error("Unregistered Topic Alias");
                  } else {
                    packet.topic = topic;
                  }
                }
              }
              if (alias) {
                delete packet.properties.topicAlias;
              }
            }
            function sendPacket(client, packet, cb) {
              debug("sendPacket :: packet: %O", packet);
              debug("sendPacket :: emitting `packetsend`");
              client.emit("packetsend", packet);
              debug("sendPacket :: writing to stream");
              const result = mqttPacket.writeToStream(packet, client.stream, client.options);
              debug("sendPacket :: writeToStream result %s", result);
              if (!result && cb && cb !== nop) {
                debug("sendPacket :: handle events on `drain` once through callback.");
                client.stream.once("drain", cb);
              } else if (cb) {
                debug("sendPacket :: invoking cb");
                cb();
              }
            }
            function flush(queue) {
              if (queue) {
                debug("flush: queue exists? %b", !!queue);
                Object.keys(queue).forEach(function(messageId) {
                  if (typeof queue[messageId].cb === "function") {
                    queue[messageId].cb(new Error("Connection closed"));
                    delete queue[messageId];
                  }
                });
              }
            }
            function flushVolatile(queue) {
              if (queue) {
                debug("flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function");
                Object.keys(queue).forEach(function(messageId) {
                  if (queue[messageId].volatile && typeof queue[messageId].cb === "function") {
                    queue[messageId].cb(new Error("Connection closed"));
                    delete queue[messageId];
                  }
                });
              }
            }
            function storeAndSend(client, packet, cb, cbStorePut) {
              debug("storeAndSend :: store packet with cmd %s to outgoingStore", packet.cmd);
              let storePacket = packet;
              let err;
              if (storePacket.cmd === "publish") {
                storePacket = clone(packet);
                err = removeTopicAliasAndRecoverTopicName(client, storePacket);
                if (err) {
                  return cb && cb(err);
                }
              }
              client.outgoingStore.put(storePacket, function storedPacket(err2) {
                if (err2) {
                  return cb && cb(err2);
                }
                cbStorePut();
                sendPacket(client, packet, cb);
              });
            }
            function nop(error) {
              debug("nop ::", error);
            }
            function MqttClient(streamBuilder, options) {
              let k;
              const that = this;
              if (!(this instanceof MqttClient)) {
                return new MqttClient(streamBuilder, options);
              }
              this.options = options || {};
              for (k in defaultConnectOptions) {
                if (typeof this.options[k] === "undefined") {
                  this.options[k] = defaultConnectOptions[k];
                } else {
                  this.options[k] = options[k];
                }
              }
              debug("MqttClient :: options.protocol", options.protocol);
              debug("MqttClient :: options.protocolVersion", options.protocolVersion);
              debug("MqttClient :: options.username", options.username);
              debug("MqttClient :: options.keepalive", options.keepalive);
              debug("MqttClient :: options.reconnectPeriod", options.reconnectPeriod);
              debug("MqttClient :: options.rejectUnauthorized", options.rejectUnauthorized);
              debug("MqttClient :: options.properties.topicAliasMaximum", options.properties ? options.properties.topicAliasMaximum : void 0);
              this.options.clientId = typeof options.clientId === "string" ? options.clientId : defaultId();
              debug("MqttClient :: clientId", this.options.clientId);
              this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function() {
                arguments[3](0);
              };
              this.streamBuilder = streamBuilder;
              this.messageIdProvider = typeof this.options.messageIdProvider === "undefined" ? new DefaultMessageIdProvider() : this.options.messageIdProvider;
              this.outgoingStore = options.outgoingStore || new Store();
              this.incomingStore = options.incomingStore || new Store();
              this.queueQoSZero = options.queueQoSZero === void 0 ? true : options.queueQoSZero;
              this._resubscribeTopics = {};
              this.messageIdToTopic = {};
              this.pingTimer = null;
              this.connected = false;
              this.disconnecting = false;
              this.queue = [];
              this.connackTimer = null;
              this.reconnectTimer = null;
              this._storeProcessing = false;
              this._packetIdsDuringStoreProcessing = {};
              this._storeProcessingQueue = [];
              this.outgoing = {};
              this._firstConnection = true;
              if (options.properties && options.properties.topicAliasMaximum > 0) {
                if (options.properties.topicAliasMaximum > 65535) {
                  debug("MqttClient :: options.properties.topicAliasMaximum is out of range");
                } else {
                  this.topicAliasRecv = new TopicAliasRecv(options.properties.topicAliasMaximum);
                }
              }
              this.on("connect", function() {
                const queue = this.queue;
                function deliver() {
                  const entry = queue.shift();
                  debug("deliver :: entry %o", entry);
                  let packet = null;
                  if (!entry) {
                    that._resubscribe();
                    return;
                  }
                  packet = entry.packet;
                  debug("deliver :: call _sendPacket for %o", packet);
                  let send = true;
                  if (packet.messageId && packet.messageId !== 0) {
                    if (!that.messageIdProvider.register(packet.messageId)) {
                      send = false;
                    }
                  }
                  if (send) {
                    that._sendPacket(
                      packet,
                      function(err) {
                        if (entry.cb) {
                          entry.cb(err);
                        }
                        deliver();
                      }
                    );
                  } else {
                    debug("messageId: %d has already used. The message is skipped and removed.", packet.messageId);
                    deliver();
                  }
                }
                debug("connect :: sending queued packets");
                deliver();
              });
              this.on("close", function() {
                debug("close :: connected set to `false`");
                this.connected = false;
                debug("close :: clearing connackTimer");
                clearTimeout(this.connackTimer);
                debug("close :: clearing ping timer");
                if (that.pingTimer !== null) {
                  that.pingTimer.clear();
                  that.pingTimer = null;
                }
                if (this.topicAliasRecv) {
                  this.topicAliasRecv.clear();
                }
                debug("close :: calling _setupReconnect");
                this._setupReconnect();
              });
              EventEmitter.call(this);
              debug("MqttClient :: setting up stream");
              this._setupStream();
            }
            inherits(MqttClient, EventEmitter);
            MqttClient.prototype._setupStream = function() {
              const that = this;
              const writable = new Writable();
              const parser = mqttPacket.parser(this.options);
              let completeParse = null;
              const packets = [];
              debug("_setupStream :: calling method to clear reconnect");
              this._clearReconnect();
              debug("_setupStream :: using streamBuilder provided to client to create stream");
              this.stream = this.streamBuilder(this);
              parser.on("packet", function(packet) {
                debug("parser :: on packet push to packets array.");
                packets.push(packet);
              });
              function nextTickWork() {
                if (packets.length) {
                  nextTick(work);
                } else {
                  const done = completeParse;
                  completeParse = null;
                  done();
                }
              }
              function work() {
                debug("work :: getting next packet in queue");
                const packet = packets.shift();
                if (packet) {
                  debug("work :: packet pulled from queue");
                  that._handlePacket(packet, nextTickWork);
                } else {
                  debug("work :: no packets in queue");
                  const done = completeParse;
                  completeParse = null;
                  debug("work :: done flag is %s", !!done);
                  if (done)
                    done();
                }
              }
              writable._write = function(buf, enc, done) {
                completeParse = done;
                debug("writable stream :: parsing buffer");
                parser.parse(buf);
                work();
              };
              function streamErrorHandler(error) {
                debug("streamErrorHandler :: error", error.message);
                if (socketErrors.includes(error.code)) {
                  debug("streamErrorHandler :: emitting error");
                  that.emit("error", error);
                } else {
                  nop(error);
                }
              }
              debug("_setupStream :: pipe stream to writable stream");
              this.stream.pipe(writable);
              this.stream.on("error", streamErrorHandler);
              this.stream.on("close", function() {
                debug("(%s)stream :: on close", that.options.clientId);
                flushVolatile(that.outgoing);
                debug("stream: emit close to MqttClient");
                that.emit("close");
              });
              debug("_setupStream: sending packet `connect`");
              const connectPacket = Object.create(this.options);
              connectPacket.cmd = "connect";
              if (this.topicAliasRecv) {
                if (!connectPacket.properties) {
                  connectPacket.properties = {};
                }
                if (this.topicAliasRecv) {
                  connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max;
                }
              }
              sendPacket(this, connectPacket);
              parser.on("error", this.emit.bind(this, "error"));
              if (this.options.properties) {
                if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {
                  that.end(() => this.emit(
                    "error",
                    new Error("Packet has no Authentication Method")
                  ));
                  return this;
                }
                if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === "object") {
                  const authPacket = xtend({ cmd: "auth", reasonCode: 0 }, this.options.authPacket);
                  sendPacket(this, authPacket);
                }
              }
              this.stream.setMaxListeners(1e3);
              clearTimeout(this.connackTimer);
              this.connackTimer = setTimeout(function() {
                debug("!!connectTimeout hit!! Calling _cleanUp with force `true`");
                that._cleanUp(true);
              }, this.options.connectTimeout);
            };
            MqttClient.prototype._handlePacket = function(packet, done) {
              const options = this.options;
              if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {
                this.emit("error", new Error("exceeding packets size " + packet.cmd));
                this.end({ reasonCode: 149, properties: { reasonString: "Maximum packet size was exceeded" } });
                return this;
              }
              debug("_handlePacket :: emitting packetreceive");
              this.emit("packetreceive", packet);
              switch (packet.cmd) {
                case "publish":
                  this._handlePublish(packet, done);
                  break;
                case "puback":
                case "pubrec":
                case "pubcomp":
                case "suback":
                case "unsuback":
                  this._handleAck(packet);
                  done();
                  break;
                case "pubrel":
                  this._handlePubrel(packet, done);
                  break;
                case "connack":
                  this._handleConnack(packet);
                  done();
                  break;
                case "auth":
                  this._handleAuth(packet);
                  done();
                  break;
                case "pingresp":
                  this._handlePingresp(packet);
                  done();
                  break;
                case "disconnect":
                  this._handleDisconnect(packet);
                  done();
                  break;
              }
            };
            MqttClient.prototype._checkDisconnecting = function(callback) {
              if (this.disconnecting) {
                if (callback && callback !== nop) {
                  callback(new Error("client disconnecting"));
                } else {
                  this.emit("error", new Error("client disconnecting"));
                }
              }
              return this.disconnecting;
            };
            MqttClient.prototype.publish = function(topic, message, opts, callback) {
              debug("publish :: message `%s` to topic `%s`", message, topic);
              const options = this.options;
              if (typeof opts === "function") {
                callback = opts;
                opts = null;
              }
              const defaultOpts = { qos: 0, retain: false, dup: false };
              opts = xtend(defaultOpts, opts);
              if (this._checkDisconnecting(callback)) {
                return this;
              }
              const that = this;
              const publishProc = function() {
                let messageId = 0;
                if (opts.qos === 1 || opts.qos === 2) {
                  messageId = that._nextId();
                  if (messageId === null) {
                    debug("No messageId left");
                    return false;
                  }
                }
                const packet = {
                  cmd: "publish",
                  topic,
                  payload: message,
                  qos: opts.qos,
                  retain: opts.retain,
                  messageId,
                  dup: opts.dup
                };
                if (options.protocolVersion === 5) {
                  packet.properties = opts.properties;
                }
                debug("publish :: qos", opts.qos);
                switch (opts.qos) {
                  case 1:
                  case 2:
                    that.outgoing[packet.messageId] = {
                      volatile: false,
                      cb: callback || nop
                    };
                    debug("MqttClient:publish: packet cmd: %s", packet.cmd);
                    that._sendPacket(packet, void 0, opts.cbStorePut);
                    break;
                  default:
                    debug("MqttClient:publish: packet cmd: %s", packet.cmd);
                    that._sendPacket(packet, callback, opts.cbStorePut);
                    break;
                }
                return true;
              };
              if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {
                this._storeProcessingQueue.push(
                  {
                    invoke: publishProc,
                    cbStorePut: opts.cbStorePut,
                    callback
                  }
                );
              }
              return this;
            };
            MqttClient.prototype.subscribe = function() {
              const that = this;
              const args = new Array(arguments.length);
              for (let i = 0; i < arguments.length; i++) {
                args[i] = arguments[i];
              }
              const subs = [];
              let obj = args.shift();
              const resubscribe = obj.resubscribe;
              let callback = args.pop() || nop;
              let opts = args.pop();
              const version2 = this.options.protocolVersion;
              delete obj.resubscribe;
              if (typeof obj === "string") {
                obj = [obj];
              }
              if (typeof callback !== "function") {
                opts = callback;
                callback = nop;
              }
              const invalidTopic = validations.validateTopics(obj);
              if (invalidTopic !== null) {
                setImmediate(callback, new Error("Invalid topic " + invalidTopic));
                return this;
              }
              if (this._checkDisconnecting(callback)) {
                debug("subscribe: discconecting true");
                return this;
              }
              const defaultOpts = {
                qos: 0
              };
              if (version2 === 5) {
                defaultOpts.nl = false;
                defaultOpts.rap = false;
                defaultOpts.rh = 0;
              }
              opts = xtend(defaultOpts, opts);
              if (Array.isArray(obj)) {
                obj.forEach(function(topic) {
                  debug("subscribe: array topic %s", topic);
                  if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {
                    const currentOpts = {
                      topic,
                      qos: opts.qos
                    };
                    if (version2 === 5) {
                      currentOpts.nl = opts.nl;
                      currentOpts.rap = opts.rap;
                      currentOpts.rh = opts.rh;
                      currentOpts.properties = opts.properties;
                    }
                    debug("subscribe: pushing topic `%s` and qos `%s` to subs list", currentOpts.topic, currentOpts.qos);
                    subs.push(currentOpts);
                  }
                });
              } else {
                Object.keys(obj).forEach(function(k) {
                  debug("subscribe: object topic %s", k);
                  if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {
                    const currentOpts = {
                      topic: k,
                      qos: obj[k].qos
                    };
                    if (version2 === 5) {
                      currentOpts.nl = obj[k].nl;
                      currentOpts.rap = obj[k].rap;
                      currentOpts.rh = obj[k].rh;
                      currentOpts.properties = opts.properties;
                    }
                    debug("subscribe: pushing `%s` to subs list", currentOpts);
                    subs.push(currentOpts);
                  }
                });
              }
              if (!subs.length) {
                callback(null, []);
                return this;
              }
              const subscribeProc = function() {
                const messageId = that._nextId();
                if (messageId === null) {
                  debug("No messageId left");
                  return false;
                }
                const packet = {
                  cmd: "subscribe",
                  subscriptions: subs,
                  qos: 1,
                  retain: false,
                  dup: false,
                  messageId
                };
                if (opts.properties) {
                  packet.properties = opts.properties;
                }
                if (that.options.resubscribe) {
                  debug("subscribe :: resubscribe true");
                  const topics = [];
                  subs.forEach(function(sub) {
                    if (that.options.reconnectPeriod > 0) {
                      const topic = { qos: sub.qos };
                      if (version2 === 5) {
                        topic.nl = sub.nl || false;
                        topic.rap = sub.rap || false;
                        topic.rh = sub.rh || 0;
                        topic.properties = sub.properties;
                      }
                      that._resubscribeTopics[sub.topic] = topic;
                      topics.push(sub.topic);
                    }
                  });
                  that.messageIdToTopic[packet.messageId] = topics;
                }
                that.outgoing[packet.messageId] = {
                  volatile: true,
                  cb: function(err, packet2) {
                    if (!err) {
                      const granted = packet2.granted;
                      for (let i = 0; i < granted.length; i += 1) {
                        subs[i].qos = granted[i];
                      }
                    }
                    callback(err, subs);
                  }
                };
                debug("subscribe :: call _sendPacket");
                that._sendPacket(packet);
                return true;
              };
              if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {
                this._storeProcessingQueue.push(
                  {
                    invoke: subscribeProc,
                    callback
                  }
                );
              }
              return this;
            };
            MqttClient.prototype.unsubscribe = function() {
              const that = this;
              const args = new Array(arguments.length);
              for (let i = 0; i < arguments.length; i++) {
                args[i] = arguments[i];
              }
              let topic = args.shift();
              let callback = args.pop() || nop;
              let opts = args.pop();
              if (typeof topic === "string") {
                topic = [topic];
              }
              if (typeof callback !== "function") {
                opts = callback;
                callback = nop;
              }
              const invalidTopic = validations.validateTopics(topic);
              if (invalidTopic !== null) {
                setImmediate(callback, new Error("Invalid topic " + invalidTopic));
                return this;
              }
              if (that._checkDisconnecting(callback)) {
                return this;
              }
              const unsubscribeProc = function() {
                const messageId = that._nextId();
                if (messageId === null) {
                  debug("No messageId left");
                  return false;
                }
                const packet = {
                  cmd: "unsubscribe",
                  qos: 1,
                  messageId
                };
                if (typeof topic === "string") {
                  packet.unsubscriptions = [topic];
                } else if (Array.isArray(topic)) {
                  packet.unsubscriptions = topic;
                }
                if (that.options.resubscribe) {
                  packet.unsubscriptions.forEach(function(topic2) {
                    delete that._resubscribeTopics[topic2];
                  });
                }
                if (typeof opts === "object" && opts.properties) {
                  packet.properties = opts.properties;
                }
                that.outgoing[packet.messageId] = {
                  volatile: true,
                  cb: callback
                };
                debug("unsubscribe: call _sendPacket");
                that._sendPacket(packet);
                return true;
              };
              if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {
                this._storeProcessingQueue.push(
                  {
                    invoke: unsubscribeProc,
                    callback
                  }
                );
              }
              return this;
            };
            MqttClient.prototype.end = function(force, opts, cb) {
              const that = this;
              debug("end :: (%s)", this.options.clientId);
              if (force == null || typeof force !== "boolean") {
                cb = opts || nop;
                opts = force;
                force = false;
                if (typeof opts !== "object") {
                  cb = opts;
                  opts = null;
                  if (typeof cb !== "function") {
                    cb = nop;
                  }
                }
              }
              if (typeof opts !== "object") {
                cb = opts;
                opts = null;
              }
              debug("end :: cb? %s", !!cb);
              cb = cb || nop;
              function closeStores() {
                debug("end :: closeStores: closing incoming and outgoing stores");
                that.disconnected = true;
                that.incomingStore.close(function(e1) {
                  that.outgoingStore.close(function(e2) {
                    debug("end :: closeStores: emitting end");
                    that.emit("end");
                    if (cb) {
                      const err = e1 || e2;
                      debug("end :: closeStores: invoking callback with args");
                      cb(err);
                    }
                  });
                });
                if (that._deferredReconnect) {
                  that._deferredReconnect();
                }
              }
              function finish() {
                debug("end :: (%s) :: finish :: calling _cleanUp with force %s", that.options.clientId, force);
                that._cleanUp(force, () => {
                  debug("end :: finish :: calling process.nextTick on closeStores");
                  nextTick(closeStores.bind(that));
                }, opts);
              }
              if (this.disconnecting) {
                cb();
                return this;
              }
              this._clearReconnect();
              this.disconnecting = true;
              if (!force && Object.keys(this.outgoing).length > 0) {
                debug("end :: (%s) :: calling finish in 10ms once outgoing is empty", that.options.clientId);
                this.once("outgoingEmpty", setTimeout.bind(null, finish, 10));
              } else {
                debug("end :: (%s) :: immediately calling finish", that.options.clientId);
                finish();
              }
              return this;
            };
            MqttClient.prototype.removeOutgoingMessage = function(messageId) {
              const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;
              delete this.outgoing[messageId];
              this.outgoingStore.del({ messageId }, function() {
                cb(new Error("Message removed"));
              });
              return this;
            };
            MqttClient.prototype.reconnect = function(opts) {
              debug("client reconnect");
              const that = this;
              const f = function() {
                if (opts) {
                  that.options.incomingStore = opts.incomingStore;
                  that.options.outgoingStore = opts.outgoingStore;
                } else {
                  that.options.incomingStore = null;
                  that.options.outgoingStore = null;
                }
                that.incomingStore = that.options.incomingStore || new Store();
                that.outgoingStore = that.options.outgoingStore || new Store();
                that.disconnecting = false;
                that.disconnected = false;
                that._deferredReconnect = null;
                that._reconnect();
              };
              if (this.disconnecting && !this.disconnected) {
                this._deferredReconnect = f;
              } else {
                f();
              }
              return this;
            };
            MqttClient.prototype._reconnect = function() {
              debug("_reconnect: emitting reconnect to client");
              this.emit("reconnect");
              if (this.connected) {
                this.end(() => {
                  this._setupStream();
                });
                debug("client already connected. disconnecting first.");
              } else {
                debug("_reconnect: calling _setupStream");
                this._setupStream();
              }
            };
            MqttClient.prototype._setupReconnect = function() {
              const that = this;
              if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {
                if (!this.reconnecting) {
                  debug("_setupReconnect :: emit `offline` state");
                  this.emit("offline");
                  debug("_setupReconnect :: set `reconnecting` to `true`");
                  this.reconnecting = true;
                }
                debug("_setupReconnect :: setting reconnectTimer for %d ms", that.options.reconnectPeriod);
                that.reconnectTimer = setInterval(function() {
                  debug("reconnectTimer :: reconnect triggered!");
                  that._reconnect();
                }, that.options.reconnectPeriod);
              } else {
                debug("_setupReconnect :: doing nothing...");
              }
            };
            MqttClient.prototype._clearReconnect = function() {
              debug("_clearReconnect : clearing reconnect timer");
              if (this.reconnectTimer) {
                clearInterval(this.reconnectTimer);
                this.reconnectTimer = null;
              }
            };
            MqttClient.prototype._cleanUp = function(forced, done) {
              const opts = arguments[2];
              if (done) {
                debug("_cleanUp :: done callback provided for on stream close");
                this.stream.on("close", done);
              }
              debug("_cleanUp :: forced? %s", forced);
              if (forced) {
                if (this.options.reconnectPeriod === 0 && this.options.clean) {
                  flush(this.outgoing);
                }
                debug("_cleanUp :: (%s) :: destroying stream", this.options.clientId);
                this.stream.destroy();
              } else {
                const packet = xtend({ cmd: "disconnect" }, opts);
                debug("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId);
                this._sendPacket(
                  packet,
                  setImmediate.bind(
                    null,
                    this.stream.end.bind(this.stream)
                  )
                );
              }
              if (!this.disconnecting) {
                debug("_cleanUp :: client not disconnecting. Clearing and resetting reconnect.");
                this._clearReconnect();
                this._setupReconnect();
              }
              if (this.pingTimer !== null) {
                debug("_cleanUp :: clearing pingTimer");
                this.pingTimer.clear();
                this.pingTimer = null;
              }
              if (done && !this.connected) {
                debug("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId);
                this.stream.removeListener("close", done);
                done();
              }
            };
            MqttClient.prototype._sendPacket = function(packet, cb, cbStorePut) {
              debug("_sendPacket :: (%s) ::  start", this.options.clientId);
              cbStorePut = cbStorePut || nop;
              cb = cb || nop;
              const err = applyTopicAlias(this, packet);
              if (err) {
                cb(err);
                return;
              }
              if (!this.connected) {
                if (packet.cmd === "auth") {
                  this._shiftPingInterval();
                  sendPacket(this, packet, cb);
                  return;
                }
                debug("_sendPacket :: client not connected. Storing packet offline.");
                this._storePacket(packet, cb, cbStorePut);
                return;
              }
              this._shiftPingInterval();
              switch (packet.cmd) {
                case "publish":
                  break;
                case "pubrel":
                  storeAndSend(this, packet, cb, cbStorePut);
                  return;
                default:
                  sendPacket(this, packet, cb);
                  return;
              }
              switch (packet.qos) {
                case 2:
                case 1:
                  storeAndSend(this, packet, cb, cbStorePut);
                  break;
                case 0:
                default:
                  sendPacket(this, packet, cb);
                  break;
              }
              debug("_sendPacket :: (%s) ::  end", this.options.clientId);
            };
            MqttClient.prototype._storePacket = function(packet, cb, cbStorePut) {
              debug("_storePacket :: packet: %o", packet);
              debug("_storePacket :: cb? %s", !!cb);
              cbStorePut = cbStorePut || nop;
              let storePacket = packet;
              if (storePacket.cmd === "publish") {
                storePacket = clone(packet);
                const err = removeTopicAliasAndRecoverTopicName(this, storePacket);
                if (err) {
                  return cb && cb(err);
                }
              }
              if ((storePacket.qos || 0) === 0 && this.queueQoSZero || storePacket.cmd !== "publish") {
                this.queue.push({ packet: storePacket, cb });
              } else if (storePacket.qos > 0) {
                cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null;
                this.outgoingStore.put(storePacket, function(err) {
                  if (err) {
                    return cb && cb(err);
                  }
                  cbStorePut();
                });
              } else if (cb) {
                cb(new Error("No connection to broker"));
              }
            };
            MqttClient.prototype._setupPingTimer = function() {
              debug("_setupPingTimer :: keepalive %d (seconds)", this.options.keepalive);
              const that = this;
              if (!this.pingTimer && this.options.keepalive) {
                this.pingResp = true;
                this.pingTimer = reInterval(function() {
                  that._checkPing();
                }, this.options.keepalive * 1e3);
              }
            };
            MqttClient.prototype._shiftPingInterval = function() {
              if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {
                this.pingTimer.reschedule(this.options.keepalive * 1e3);
              }
            };
            MqttClient.prototype._checkPing = function() {
              debug("_checkPing :: checking ping...");
              if (this.pingResp) {
                debug("_checkPing :: ping response received. Clearing flag and sending `pingreq`");
                this.pingResp = false;
                this._sendPacket({ cmd: "pingreq" });
              } else {
                debug("_checkPing :: calling _cleanUp with force true");
                this._cleanUp(true);
              }
            };
            MqttClient.prototype._handlePingresp = function() {
              this.pingResp = true;
            };
            MqttClient.prototype._handleConnack = function(packet) {
              debug("_handleConnack");
              const options = this.options;
              const version2 = options.protocolVersion;
              const rc = version2 === 5 ? packet.reasonCode : packet.returnCode;
              clearTimeout(this.connackTimer);
              delete this.topicAliasSend;
              if (packet.properties) {
                if (packet.properties.topicAliasMaximum) {
                  if (packet.properties.topicAliasMaximum > 65535) {
                    this.emit("error", new Error("topicAliasMaximum from broker is out of range"));
                    return;
                  }
                  if (packet.properties.topicAliasMaximum > 0) {
                    this.topicAliasSend = new TopicAliasSend(packet.properties.topicAliasMaximum);
                  }
                }
                if (packet.properties.serverKeepAlive && options.keepalive) {
                  options.keepalive = packet.properties.serverKeepAlive;
                  this._shiftPingInterval();
                }
                if (packet.properties.maximumPacketSize) {
                  if (!options.properties) {
                    options.properties = {};
                  }
                  options.properties.maximumPacketSize = packet.properties.maximumPacketSize;
                }
              }
              if (rc === 0) {
                this.reconnecting = false;
                this._onConnect(packet);
              } else if (rc > 0) {
                const err = new Error("Connection refused: " + errors[rc]);
                err.code = rc;
                this.emit("error", err);
              }
            };
            MqttClient.prototype._handleAuth = function(packet) {
              const options = this.options;
              const version2 = options.protocolVersion;
              const rc = version2 === 5 ? packet.reasonCode : packet.returnCode;
              if (version2 !== 5) {
                const err = new Error("Protocol error: Auth packets are only supported in MQTT 5. Your version:" + version2);
                err.code = rc;
                this.emit("error", err);
                return;
              }
              const that = this;
              this.handleAuth(packet, function(err, packet2) {
                if (err) {
                  that.emit("error", err);
                  return;
                }
                if (rc === 24) {
                  that.reconnecting = false;
                  that._sendPacket(packet2);
                } else {
                  const error = new Error("Connection refused: " + errors[rc]);
                  err.code = rc;
                  that.emit("error", error);
                }
              });
            };
            MqttClient.prototype.handleAuth = function(packet, callback) {
              callback();
            };
            MqttClient.prototype._handlePublish = function(packet, done) {
              debug("_handlePublish: packet %o", packet);
              done = typeof done !== "undefined" ? done : nop;
              let topic = packet.topic.toString();
              const message = packet.payload;
              const qos = packet.qos;
              const messageId = packet.messageId;
              const that = this;
              const options = this.options;
              const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];
              if (this.options.protocolVersion === 5) {
                let alias;
                if (packet.properties) {
                  alias = packet.properties.topicAlias;
                }
                if (typeof alias !== "undefined") {
                  if (topic.length === 0) {
                    if (alias > 0 && alias <= 65535) {
                      const gotTopic = this.topicAliasRecv.getTopicByAlias(alias);
                      if (gotTopic) {
                        topic = gotTopic;
                        debug("_handlePublish :: topic complemented by alias. topic: %s - alias: %d", topic, alias);
                      } else {
                        debug("_handlePublish :: unregistered topic alias. alias: %d", alias);
                        this.emit("error", new Error("Received unregistered Topic Alias"));
                        return;
                      }
                    } else {
                      debug("_handlePublish :: topic alias out of range. alias: %d", alias);
                      this.emit("error", new Error("Received Topic Alias is out of range"));
                      return;
                    }
                  } else {
                    if (this.topicAliasRecv.put(topic, alias)) {
                      debug("_handlePublish :: registered topic: %s - alias: %d", topic, alias);
                    } else {
                      debug("_handlePublish :: topic alias out of range. alias: %d", alias);
                      this.emit("error", new Error("Received Topic Alias is out of range"));
                      return;
                    }
                  }
                }
              }
              debug("_handlePublish: qos %d", qos);
              switch (qos) {
                case 2: {
                  options.customHandleAcks(topic, message, packet, function(error, code) {
                    if (!(error instanceof Error)) {
                      code = error;
                      error = null;
                    }
                    if (error) {
                      return that.emit("error", error);
                    }
                    if (validReasonCodes.indexOf(code) === -1) {
                      return that.emit("error", new Error("Wrong reason code for pubrec"));
                    }
                    if (code) {
                      that._sendPacket({ cmd: "pubrec", messageId, reasonCode: code }, done);
                    } else {
                      that.incomingStore.put(packet, function() {
                        that._sendPacket({ cmd: "pubrec", messageId }, done);
                      });
                    }
                  });
                  break;
                }
                case 1: {
                  options.customHandleAcks(topic, message, packet, function(error, code) {
                    if (!(error instanceof Error)) {
                      code = error;
                      error = null;
                    }
                    if (error) {
                      return that.emit("error", error);
                    }
                    if (validReasonCodes.indexOf(code) === -1) {
                      return that.emit("error", new Error("Wrong reason code for puback"));
                    }
                    if (!code) {
                      that.emit("message", topic, message, packet);
                    }
                    that.handleMessage(packet, function(err) {
                      if (err) {
                        return done && done(err);
                      }
                      that._sendPacket({ cmd: "puback", messageId, reasonCode: code }, done);
                    });
                  });
                  break;
                }
                case 0:
                  this.emit("message", topic, message, packet);
                  this.handleMessage(packet, done);
                  break;
                default:
                  debug("_handlePublish: unknown QoS. Doing nothing.");
                  break;
              }
            };
            MqttClient.prototype.handleMessage = function(packet, callback) {
              callback();
            };
            MqttClient.prototype._handleAck = function(packet) {
              const messageId = packet.messageId;
              const type = packet.cmd;
              let response = null;
              const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;
              const that = this;
              let err;
              if (!cb) {
                debug("_handleAck :: Server sent an ack in error. Ignoring.");
                return;
              }
              debug("_handleAck :: packet type", type);
              switch (type) {
                case "pubcomp":
                case "puback": {
                  const pubackRC = packet.reasonCode;
                  if (pubackRC && pubackRC > 0 && pubackRC !== 16) {
                    err = new Error("Publish error: " + errors[pubackRC]);
                    err.code = pubackRC;
                    cb(err, packet);
                  }
                  delete this.outgoing[messageId];
                  this.outgoingStore.del(packet, cb);
                  this.messageIdProvider.deallocate(messageId);
                  this._invokeStoreProcessingQueue();
                  break;
                }
                case "pubrec": {
                  response = {
                    cmd: "pubrel",
                    qos: 2,
                    messageId
                  };
                  const pubrecRC = packet.reasonCode;
                  if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {
                    err = new Error("Publish error: " + errors[pubrecRC]);
                    err.code = pubrecRC;
                    cb(err, packet);
                  } else {
                    this._sendPacket(response);
                  }
                  break;
                }
                case "suback": {
                  delete this.outgoing[messageId];
                  this.messageIdProvider.deallocate(messageId);
                  for (let grantedI = 0; grantedI < packet.granted.length; grantedI++) {
                    if ((packet.granted[grantedI] & 128) !== 0) {
                      const topics = this.messageIdToTopic[messageId];
                      if (topics) {
                        topics.forEach(function(topic) {
                          delete that._resubscribeTopics[topic];
                        });
                      }
                    }
                  }
                  this._invokeStoreProcessingQueue();
                  cb(null, packet);
                  break;
                }
                case "unsuback": {
                  delete this.outgoing[messageId];
                  this.messageIdProvider.deallocate(messageId);
                  this._invokeStoreProcessingQueue();
                  cb(null);
                  break;
                }
                default:
                  that.emit("error", new Error("unrecognized packet type"));
              }
              if (this.disconnecting && Object.keys(this.outgoing).length === 0) {
                this.emit("outgoingEmpty");
              }
            };
            MqttClient.prototype._handlePubrel = function(packet, callback) {
              debug("handling pubrel packet");
              callback = typeof callback !== "undefined" ? callback : nop;
              const messageId = packet.messageId;
              const that = this;
              const comp = { cmd: "pubcomp", messageId };
              that.incomingStore.get(packet, function(err, pub) {
                if (!err) {
                  that.emit("message", pub.topic, pub.payload, pub);
                  that.handleMessage(pub, function(err2) {
                    if (err2) {
                      return callback(err2);
                    }
                    that.incomingStore.del(pub, nop);
                    that._sendPacket(comp, callback);
                  });
                } else {
                  that._sendPacket(comp, callback);
                }
              });
            };
            MqttClient.prototype._handleDisconnect = function(packet) {
              this.emit("disconnect", packet);
            };
            MqttClient.prototype._nextId = function() {
              return this.messageIdProvider.allocate();
            };
            MqttClient.prototype.getLastMessageId = function() {
              return this.messageIdProvider.getLastAllocated();
            };
            MqttClient.prototype._resubscribe = function() {
              debug("_resubscribe");
              const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);
              if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent) && _resubscribeTopicsKeys.length > 0) {
                if (this.options.resubscribe) {
                  if (this.options.protocolVersion === 5) {
                    debug("_resubscribe: protocolVersion 5");
                    for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {
                      const resubscribeTopic = {};
                      resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];
                      resubscribeTopic.resubscribe = true;
                      this.subscribe(resubscribeTopic, { properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties });
                    }
                  } else {
                    this._resubscribeTopics.resubscribe = true;
                    this.subscribe(this._resubscribeTopics);
                  }
                } else {
                  this._resubscribeTopics = {};
                }
              }
              this._firstConnection = false;
            };
            MqttClient.prototype._onConnect = function(packet) {
              if (this.disconnected) {
                this.emit("connect", packet);
                return;
              }
              const that = this;
              this.connackPacket = packet;
              this.messageIdProvider.clear();
              this._setupPingTimer();
              this.connected = true;
              function startStreamProcess() {
                let outStore = that.outgoingStore.createStream();
                function clearStoreProcessing() {
                  that._storeProcessing = false;
                  that._packetIdsDuringStoreProcessing = {};
                }
                that.once("close", remove);
                outStore.on("error", function(err) {
                  clearStoreProcessing();
                  that._flushStoreProcessingQueue();
                  that.removeListener("close", remove);
                  that.emit("error", err);
                });
                function remove() {
                  outStore.destroy();
                  outStore = null;
                  that._flushStoreProcessingQueue();
                  clearStoreProcessing();
                }
                function storeDeliver() {
                  if (!outStore) {
                    return;
                  }
                  that._storeProcessing = true;
                  const packet2 = outStore.read(1);
                  let cb;
                  if (!packet2) {
                    outStore.once("readable", storeDeliver);
                    return;
                  }
                  if (that._packetIdsDuringStoreProcessing[packet2.messageId]) {
                    storeDeliver();
                    return;
                  }
                  if (!that.disconnecting && !that.reconnectTimer) {
                    cb = that.outgoing[packet2.messageId] ? that.outgoing[packet2.messageId].cb : null;
                    that.outgoing[packet2.messageId] = {
                      volatile: false,
                      cb: function(err, status) {
                        if (cb) {
                          cb(err, status);
                        }
                        storeDeliver();
                      }
                    };
                    that._packetIdsDuringStoreProcessing[packet2.messageId] = true;
                    if (that.messageIdProvider.register(packet2.messageId)) {
                      that._sendPacket(packet2);
                    } else {
                      debug("messageId: %d has already used.", packet2.messageId);
                    }
                  } else if (outStore.destroy) {
                    outStore.destroy();
                  }
                }
                outStore.on("end", function() {
                  let allProcessed = true;
                  for (const id in that._packetIdsDuringStoreProcessing) {
                    if (!that._packetIdsDuringStoreProcessing[id]) {
                      allProcessed = false;
                      break;
                    }
                  }
                  if (allProcessed) {
                    clearStoreProcessing();
                    that.removeListener("close", remove);
                    that._invokeAllStoreProcessingQueue();
                    that.emit("connect", packet);
                  } else {
                    startStreamProcess();
                  }
                });
                storeDeliver();
              }
              startStreamProcess();
            };
            MqttClient.prototype._invokeStoreProcessingQueue = function() {
              if (this._storeProcessingQueue.length > 0) {
                const f = this._storeProcessingQueue[0];
                if (f && f.invoke()) {
                  this._storeProcessingQueue.shift();
                  return true;
                }
              }
              return false;
            };
            MqttClient.prototype._invokeAllStoreProcessingQueue = function() {
              while (this._invokeStoreProcessingQueue()) {
              }
            };
            MqttClient.prototype._flushStoreProcessingQueue = function() {
              for (const f of this._storeProcessingQueue) {
                if (f.cbStorePut)
                  f.cbStorePut(new Error("Connection closed"));
                if (f.callback)
                  f.callback(new Error("Connection closed"));
              }
              this._storeProcessingQueue.splice(0);
            };
            module2.exports = MqttClient;
          }).call(this);
        }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./default-message-id-provider": 7, "./store": 9, "./topic-alias-recv": 10, "./topic-alias-send": 11, "./validations": 13, "_process": 93, "debug": 21, "events": 40, "inherits": 42, "mqtt-packet": 66, "readable-stream": 116, "reinterval": 122, "rfdc/default": 123, "xtend": 133 }], 2: [function(require2, module2, exports2) {
        const { Buffer } = require2("buffer");
        const Transform = require2("readable-stream").Transform;
        const duplexify = require2("duplexify");
        let my;
        let proxy;
        let stream;
        let isInitialized = false;
        function buildProxy() {
          const proxy2 = new Transform();
          proxy2._write = function(chunk, encoding2, next) {
            my.sendSocketMessage({
              data: chunk.buffer,
              success: function() {
                next();
              },
              fail: function() {
                next(new Error());
              }
            });
          };
          proxy2._flush = function socketEnd(done) {
            my.closeSocket({
              success: function() {
                done();
              }
            });
          };
          return proxy2;
        }
        function setDefaultOpts(opts) {
          if (!opts.hostname) {
            opts.hostname = "localhost";
          }
          if (!opts.path) {
            opts.path = "/";
          }
          if (!opts.wsOptions) {
            opts.wsOptions = {};
          }
        }
        function buildUrl(opts, client) {
          const protocol = opts.protocol === "alis" ? "wss" : "ws";
          let url = protocol + "://" + opts.hostname + opts.path;
          if (opts.port && opts.port !== 80 && opts.port !== 443) {
            url = protocol + "://" + opts.hostname + ":" + opts.port + opts.path;
          }
          if (typeof opts.transformWsUrl === "function") {
            url = opts.transformWsUrl(url, opts, client);
          }
          return url;
        }
        function bindEventHandler() {
          if (isInitialized)
            return;
          isInitialized = true;
          my.onSocketOpen(function() {
            stream.setReadable(proxy);
            stream.setWritable(proxy);
            stream.emit("connect");
          });
          my.onSocketMessage(function(res) {
            if (typeof res.data === "string") {
              const buffer = Buffer.from(res.data, "base64");
              proxy.push(buffer);
            } else {
              const reader = new FileReader();
              reader.addEventListener("load", function() {
                let data = reader.result;
                if (data instanceof ArrayBuffer)
                  data = Buffer.from(data);
                else
                  data = Buffer.from(data, "utf8");
                proxy.push(data);
              });
              reader.readAsArrayBuffer(res.data);
            }
          });
          my.onSocketClose(function() {
            stream.end();
            stream.destroy();
          });
          my.onSocketError(function(res) {
            stream.destroy(res);
          });
        }
        function buildStream(client, opts) {
          opts.hostname = opts.hostname || opts.host;
          if (!opts.hostname) {
            throw new Error("Could not determine host. Specify host manually.");
          }
          const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
          setDefaultOpts(opts);
          const url = buildUrl(opts, client);
          my = opts.my;
          my.connectSocket({
            url,
            protocols: websocketSubProtocol
          });
          proxy = buildProxy();
          stream = duplexify.obj();
          bindEventHandler();
          return stream;
        }
        module2.exports = buildStream;
      }, { "buffer": 20, "duplexify": 23, "readable-stream": 116 }], 3: [function(require2, module2, exports2) {
        const net = require2("net");
        const debug = require2("debug")("mqttjs:tcp");
        function streamBuilder(client, opts) {
          opts.port = opts.port || 1883;
          opts.hostname = opts.hostname || opts.host || "localhost";
          const port = opts.port;
          const host = opts.hostname;
          debug("port %d and host %s", port, host);
          return net.createConnection(port, host);
        }
        module2.exports = streamBuilder;
      }, { "debug": 21, "net": 17 }], 4: [function(require2, module2, exports2) {
        const tls = require2("tls");
        const net = require2("net");
        const debug = require2("debug")("mqttjs:tls");
        function buildBuilder(mqttClient, opts) {
          opts.port = opts.port || 8883;
          opts.host = opts.hostname || opts.host || "localhost";
          if (net.isIP(opts.host) === 0) {
            opts.servername = opts.host;
          }
          opts.rejectUnauthorized = opts.rejectUnauthorized !== false;
          delete opts.path;
          debug("port %d host %s rejectUnauthorized %b", opts.port, opts.host, opts.rejectUnauthorized);
          const connection = tls.connect(opts);
          connection.on("secureConnect", function() {
            if (opts.rejectUnauthorized && !connection.authorized) {
              connection.emit("error", new Error("TLS not authorized"));
            } else {
              connection.removeListener("error", handleTLSerrors);
            }
          });
          function handleTLSerrors(err) {
            if (opts.rejectUnauthorized) {
              mqttClient.emit("error", err);
            }
            connection.end();
          }
          connection.on("error", handleTLSerrors);
          return connection;
        }
        module2.exports = buildBuilder;
      }, { "debug": 21, "net": 17, "tls": 17 }], 5: [function(require2, module2, exports2) {
        const { Buffer } = require2("buffer");
        const WS = require2("ws");
        const debug = require2("debug")("mqttjs:ws");
        const duplexify = require2("duplexify");
        const Transform = require2("readable-stream").Transform;
        const IS_BROWSER = require2("../is-browser").IS_BROWSER;
        const WSS_OPTIONS = [
          "rejectUnauthorized",
          "ca",
          "cert",
          "key",
          "pfx",
          "passphrase"
        ];
        function buildUrl(opts, client) {
          let url = opts.protocol + "://" + opts.hostname + ":" + opts.port + opts.path;
          if (typeof opts.transformWsUrl === "function") {
            url = opts.transformWsUrl(url, opts, client);
          }
          return url;
        }
        function setDefaultOpts(opts) {
          const options = opts;
          if (!opts.hostname) {
            options.hostname = "localhost";
          }
          if (!opts.port) {
            if (opts.protocol === "wss") {
              options.port = 443;
            } else {
              options.port = 80;
            }
          }
          if (!opts.path) {
            options.path = "/";
          }
          if (!opts.wsOptions) {
            options.wsOptions = {};
          }
          if (!IS_BROWSER && opts.protocol === "wss") {
            WSS_OPTIONS.forEach(function(prop) {
              if (Object.prototype.hasOwnProperty.call(opts, prop) && !Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)) {
                options.wsOptions[prop] = opts[prop];
              }
            });
          }
          return options;
        }
        function setDefaultBrowserOpts(opts) {
          const options = setDefaultOpts(opts);
          if (!options.hostname) {
            options.hostname = options.host;
          }
          if (!options.hostname) {
            if (typeof document === "undefined") {
              throw new Error("Could not determine host. Specify host manually.");
            }
            const parsed = new URL(document.URL);
            options.hostname = parsed.hostname;
            if (!options.port) {
              options.port = parsed.port;
            }
          }
          if (options.objectMode === void 0) {
            options.objectMode = !(options.binary === true || options.binary === void 0);
          }
          return options;
        }
        function createWebSocket(client, url, opts) {
          debug("createWebSocket");
          debug("protocol: " + opts.protocolId + " " + opts.protocolVersion);
          const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
          debug("creating new Websocket for url: " + url + " and protocol: " + websocketSubProtocol);
          const socket = new WS(url, [websocketSubProtocol], opts.wsOptions);
          return socket;
        }
        function createBrowserWebSocket(client, opts) {
          const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
          const url = buildUrl(opts, client);
          const socket = new WebSocket(url, [websocketSubProtocol]);
          socket.binaryType = "arraybuffer";
          return socket;
        }
        function streamBuilder(client, opts) {
          debug("streamBuilder");
          const options = setDefaultOpts(opts);
          const url = buildUrl(options, client);
          const socket = createWebSocket(client, url, options);
          const webSocketStream = WS.createWebSocketStream(socket, options.wsOptions);
          webSocketStream.url = url;
          socket.on("close", () => {
            webSocketStream.destroy();
          });
          return webSocketStream;
        }
        function browserStreamBuilder(client, opts) {
          debug("browserStreamBuilder");
          let stream;
          const options = setDefaultBrowserOpts(opts);
          const bufferSize = options.browserBufferSize || 1024 * 512;
          const bufferTimeout = opts.browserBufferTimeout || 1e3;
          const coerceToBuffer = !opts.objectMode;
          const socket = createBrowserWebSocket(client, opts);
          const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser);
          if (!opts.objectMode) {
            proxy._writev = writev;
          }
          proxy.on("close", () => {
            socket.close();
          });
          const eventListenerSupport = typeof socket.addEventListener !== "undefined";
          if (socket.readyState === socket.OPEN) {
            stream = proxy;
          } else {
            stream = stream = duplexify(void 0, void 0, opts);
            if (!opts.objectMode) {
              stream._writev = writev;
            }
            if (eventListenerSupport) {
              socket.addEventListener("open", onopen);
            } else {
              socket.onopen = onopen;
            }
          }
          stream.socket = socket;
          if (eventListenerSupport) {
            socket.addEventListener("close", onclose);
            socket.addEventListener("error", onerror);
            socket.addEventListener("message", onmessage);
          } else {
            socket.onclose = onclose;
            socket.onerror = onerror;
            socket.onmessage = onmessage;
          }
          function buildProxy(options2, socketWrite, socketEnd) {
            const proxy2 = new Transform({
              objectModeMode: options2.objectMode
            });
            proxy2._write = socketWrite;
            proxy2._flush = socketEnd;
            return proxy2;
          }
          function onopen() {
            stream.setReadable(proxy);
            stream.setWritable(proxy);
            stream.emit("connect");
          }
          function onclose() {
            stream.end();
            stream.destroy();
          }
          function onerror(err) {
            stream.destroy(err);
          }
          function onmessage(event) {
            let data = event.data;
            if (data instanceof ArrayBuffer)
              data = Buffer.from(data);
            else
              data = Buffer.from(data, "utf8");
            proxy.push(data);
          }
          function writev(chunks, cb) {
            const buffers = new Array(chunks.length);
            for (let i = 0; i < chunks.length; i++) {
              if (typeof chunks[i].chunk === "string") {
                buffers[i] = Buffer.from(chunks[i], "utf8");
              } else {
                buffers[i] = chunks[i].chunk;
              }
            }
            this._write(Buffer.concat(buffers), "binary", cb);
          }
          function socketWriteBrowser(chunk, enc, next) {
            if (socket.bufferedAmount > bufferSize) {
              setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);
            }
            if (coerceToBuffer && typeof chunk === "string") {
              chunk = Buffer.from(chunk, "utf8");
            }
            try {
              socket.send(chunk);
            } catch (err) {
              return next(err);
            }
            next();
          }
          function socketEndBrowser(done) {
            socket.close();
            done();
          }
          return stream;
        }
        if (IS_BROWSER) {
          module2.exports = browserStreamBuilder;
        } else {
          module2.exports = streamBuilder;
        }
      }, { "../is-browser": 8, "buffer": 20, "debug": 21, "duplexify": 23, "readable-stream": 116, "ws": 132 }], 6: [function(require2, module2, exports2) {
        const { Buffer } = require2("buffer");
        const Transform = require2("readable-stream").Transform;
        const duplexify = require2("duplexify");
        let socketTask, proxy, stream;
        function buildProxy() {
          const proxy2 = new Transform();
          proxy2._write = function(chunk, encoding2, next) {
            socketTask.send({
              data: chunk.buffer,
              success: function() {
                next();
              },
              fail: function(errMsg) {
                next(new Error(errMsg));
              }
            });
          };
          proxy2._flush = function socketEnd(done) {
            socketTask.close({
              success: function() {
                done();
              }
            });
          };
          return proxy2;
        }
        function setDefaultOpts(opts) {
          if (!opts.hostname) {
            opts.hostname = "localhost";
          }
          if (!opts.path) {
            opts.path = "/";
          }
          if (!opts.wsOptions) {
            opts.wsOptions = {};
          }
        }
        function buildUrl(opts, client) {
          const protocol = opts.protocol === "wxs" ? "wss" : "ws";
          let url = protocol + "://" + opts.hostname + opts.path;
          if (opts.port && opts.port !== 80 && opts.port !== 443) {
            url = protocol + "://" + opts.hostname + ":" + opts.port + opts.path;
          }
          if (typeof opts.transformWsUrl === "function") {
            url = opts.transformWsUrl(url, opts, client);
          }
          return url;
        }
        function bindEventHandler() {
          socketTask.onOpen(function() {
            stream.setReadable(proxy);
            stream.setWritable(proxy);
            stream.emit("connect");
          });
          socketTask.onMessage(function(res) {
            let data = res.data;
            if (data instanceof ArrayBuffer)
              data = Buffer.from(data);
            else
              data = Buffer.from(data, "utf8");
            proxy.push(data);
          });
          socketTask.onClose(function() {
            stream.end();
            stream.destroy();
          });
          socketTask.onError(function(res) {
            stream.destroy(new Error(res.errMsg));
          });
        }
        function buildStream(client, opts) {
          opts.hostname = opts.hostname || opts.host;
          if (!opts.hostname) {
            throw new Error("Could not determine host. Specify host manually.");
          }
          const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
          setDefaultOpts(opts);
          const url = buildUrl(opts, client);
          socketTask = wx.connectSocket({
            url,
            protocols: [websocketSubProtocol]
          });
          proxy = buildProxy();
          stream = duplexify.obj();
          stream._destroy = function(err, cb) {
            socketTask.close({
              success: function() {
                cb && cb(err);
              }
            });
          };
          const destroyRef = stream.destroy;
          stream.destroy = function() {
            stream.destroy = destroyRef;
            const self2 = this;
            setTimeout(function() {
              socketTask.close({
                fail: function() {
                  self2._destroy(new Error());
                }
              });
            }, 0);
          }.bind(stream);
          bindEventHandler();
          return stream;
        }
        module2.exports = buildStream;
      }, { "buffer": 20, "duplexify": 23, "readable-stream": 116 }], 7: [function(require2, module2, exports2) {
        function DefaultMessageIdProvider() {
          if (!(this instanceof DefaultMessageIdProvider)) {
            return new DefaultMessageIdProvider();
          }
          this.nextId = Math.max(1, Math.floor(Math.random() * 65535));
        }
        DefaultMessageIdProvider.prototype.allocate = function() {
          const id = this.nextId++;
          if (this.nextId === 65536) {
            this.nextId = 1;
          }
          return id;
        };
        DefaultMessageIdProvider.prototype.getLastAllocated = function() {
          return this.nextId === 1 ? 65535 : this.nextId - 1;
        };
        DefaultMessageIdProvider.prototype.register = function(messageId) {
          return true;
        };
        DefaultMessageIdProvider.prototype.deallocate = function(messageId) {
        };
        DefaultMessageIdProvider.prototype.clear = function() {
        };
        module2.exports = DefaultMessageIdProvider;
      }, {}], 8: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            const legacyIsBrowser = typeof process !== "undefined" && process.title === "browser" || // eslint-disable-next-line camelcase
            typeof __webpack_require__ === "function";
            const isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
            module2.exports = {
              IS_BROWSER: isBrowser || legacyIsBrowser
            };
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 93 }], 9: [function(require2, module2, exports2) {
        const xtend = require2("xtend");
        const Readable = require2("readable-stream").Readable;
        const streamsOpts = { objectMode: true };
        const defaultStoreOptions = {
          clean: true
        };
        function Store(options) {
          if (!(this instanceof Store)) {
            return new Store(options);
          }
          this.options = options || {};
          this.options = xtend(defaultStoreOptions, options);
          this._inflights = /* @__PURE__ */ new Map();
        }
        Store.prototype.put = function(packet, cb) {
          this._inflights.set(packet.messageId, packet);
          if (cb) {
            cb();
          }
          return this;
        };
        Store.prototype.createStream = function() {
          const stream = new Readable(streamsOpts);
          const values = [];
          let destroyed = false;
          let i = 0;
          this._inflights.forEach(function(value, key) {
            values.push(value);
          });
          stream._read = function() {
            if (!destroyed && i < values.length) {
              this.push(values[i++]);
            } else {
              this.push(null);
            }
          };
          stream.destroy = function() {
            if (destroyed) {
              return;
            }
            const self2 = this;
            destroyed = true;
            setTimeout(function() {
              self2.emit("close");
            }, 0);
          };
          return stream;
        };
        Store.prototype.del = function(packet, cb) {
          packet = this._inflights.get(packet.messageId);
          if (packet) {
            this._inflights.delete(packet.messageId);
            cb(null, packet);
          } else if (cb) {
            cb(new Error("missing packet"));
          }
          return this;
        };
        Store.prototype.get = function(packet, cb) {
          packet = this._inflights.get(packet.messageId);
          if (packet) {
            cb(null, packet);
          } else if (cb) {
            cb(new Error("missing packet"));
          }
          return this;
        };
        Store.prototype.close = function(cb) {
          if (this.options.clean) {
            this._inflights = null;
          }
          if (cb) {
            cb();
          }
        };
        module2.exports = Store;
      }, { "readable-stream": 116, "xtend": 133 }], 10: [function(require2, module2, exports2) {
        function TopicAliasRecv(max) {
          if (!(this instanceof TopicAliasRecv)) {
            return new TopicAliasRecv(max);
          }
          this.aliasToTopic = {};
          this.max = max;
        }
        TopicAliasRecv.prototype.put = function(topic, alias) {
          if (alias === 0 || alias > this.max) {
            return false;
          }
          this.aliasToTopic[alias] = topic;
          this.length = Object.keys(this.aliasToTopic).length;
          return true;
        };
        TopicAliasRecv.prototype.getTopicByAlias = function(alias) {
          return this.aliasToTopic[alias];
        };
        TopicAliasRecv.prototype.clear = function() {
          this.aliasToTopic = {};
        };
        module2.exports = TopicAliasRecv;
      }, {}], 11: [function(require2, module2, exports2) {
        const LruMap = require2("lru-cache");
        const NumberAllocator = require2("number-allocator").NumberAllocator;
        function TopicAliasSend(max) {
          if (!(this instanceof TopicAliasSend)) {
            return new TopicAliasSend(max);
          }
          if (max > 0) {
            this.aliasToTopic = new LruMap({ max });
            this.topicToAlias = {};
            this.numberAllocator = new NumberAllocator(1, max);
            this.max = max;
            this.length = 0;
          }
        }
        TopicAliasSend.prototype.put = function(topic, alias) {
          if (alias === 0 || alias > this.max) {
            return false;
          }
          const entry = this.aliasToTopic.get(alias);
          if (entry) {
            delete this.topicToAlias[entry];
          }
          this.aliasToTopic.set(alias, topic);
          this.topicToAlias[topic] = alias;
          this.numberAllocator.use(alias);
          this.length = this.aliasToTopic.length;
          return true;
        };
        TopicAliasSend.prototype.getTopicByAlias = function(alias) {
          return this.aliasToTopic.get(alias);
        };
        TopicAliasSend.prototype.getAliasByTopic = function(topic) {
          const alias = this.topicToAlias[topic];
          if (typeof alias !== "undefined") {
            this.aliasToTopic.get(alias);
          }
          return alias;
        };
        TopicAliasSend.prototype.clear = function() {
          this.aliasToTopic.reset();
          this.topicToAlias = {};
          this.numberAllocator.clear();
          this.length = 0;
        };
        TopicAliasSend.prototype.getLruAlias = function() {
          const alias = this.numberAllocator.firstVacant();
          if (alias)
            return alias;
          return this.aliasToTopic.keys()[this.aliasToTopic.length - 1];
        };
        module2.exports = TopicAliasSend;
      }, { "lru-cache": 63, "number-allocator": 89 }], 12: [function(require2, module2, exports2) {
        const NumberAllocator = require2("number-allocator").NumberAllocator;
        function UniqueMessageIdProvider() {
          if (!(this instanceof UniqueMessageIdProvider)) {
            return new UniqueMessageIdProvider();
          }
          this.numberAllocator = new NumberAllocator(1, 65535);
        }
        UniqueMessageIdProvider.prototype.allocate = function() {
          this.lastId = this.numberAllocator.alloc();
          return this.lastId;
        };
        UniqueMessageIdProvider.prototype.getLastAllocated = function() {
          return this.lastId;
        };
        UniqueMessageIdProvider.prototype.register = function(messageId) {
          return this.numberAllocator.use(messageId);
        };
        UniqueMessageIdProvider.prototype.deallocate = function(messageId) {
          this.numberAllocator.free(messageId);
        };
        UniqueMessageIdProvider.prototype.clear = function() {
          this.numberAllocator.clear();
        };
        module2.exports = UniqueMessageIdProvider;
      }, { "number-allocator": 89 }], 13: [function(require2, module2, exports2) {
        function validateTopic(topic) {
          const parts = topic.split("/");
          for (let i = 0; i < parts.length; i++) {
            if (parts[i] === "+") {
              continue;
            }
            if (parts[i] === "#") {
              return i === parts.length - 1;
            }
            if (parts[i].indexOf("+") !== -1 || parts[i].indexOf("#") !== -1) {
              return false;
            }
          }
          return true;
        }
        function validateTopics(topics) {
          if (topics.length === 0) {
            return "empty_topic_list";
          }
          for (let i = 0; i < topics.length; i++) {
            if (!validateTopic(topics[i])) {
              return topics[i];
            }
          }
          return null;
        }
        module2.exports = {
          validateTopics
        };
      }, {}], 14: [function(require2, module2, exports2) {
        const MqttClient = require2("../client");
        const Store = require2("../store");
        const DefaultMessageIdProvider = require2("../default-message-id-provider");
        const UniqueMessageIdProvider = require2("../unique-message-id-provider");
        const IS_BROWSER = require2("../is-browser").IS_BROWSER;
        const url = require2("url");
        const xtend = require2("xtend");
        const debug = require2("debug")("mqttjs");
        const protocols = {};
        if (!IS_BROWSER) {
          protocols.mqtt = require2("./tcp");
          protocols.tcp = require2("./tcp");
          protocols.ssl = require2("./tls");
          protocols.tls = require2("./tls");
          protocols.mqtts = require2("./tls");
        } else {
          protocols.wx = require2("./wx");
          protocols.wxs = require2("./wx");
          protocols.ali = require2("./ali");
          protocols.alis = require2("./ali");
        }
        protocols.ws = require2("./ws");
        protocols.wss = require2("./ws");
        function parseAuthOptions(opts) {
          let matches;
          if (opts.auth) {
            matches = opts.auth.match(/^(.+):(.+)$/);
            if (matches) {
              opts.username = matches[1];
              opts.password = matches[2];
            } else {
              opts.username = opts.auth;
            }
          }
        }
        function connect(brokerUrl, opts) {
          debug("connecting to an MQTT broker...");
          if (typeof brokerUrl === "object" && !opts) {
            opts = brokerUrl;
            brokerUrl = null;
          }
          opts = opts || {};
          if (brokerUrl) {
            const parsed = url.parse(brokerUrl, true);
            if (parsed.port != null) {
              parsed.port = Number(parsed.port);
            }
            opts = xtend(parsed, opts);
            if (opts.protocol === null) {
              throw new Error("Missing protocol");
            }
            opts.protocol = opts.protocol.replace(/:$/, "");
          }
          parseAuthOptions(opts);
          if (opts.query && typeof opts.query.clientId === "string") {
            opts.clientId = opts.query.clientId;
          }
          if (opts.cert && opts.key) {
            if (opts.protocol) {
              if (["mqtts", "wss", "wxs", "alis"].indexOf(opts.protocol) === -1) {
                switch (opts.protocol) {
                  case "mqtt":
                    opts.protocol = "mqtts";
                    break;
                  case "ws":
                    opts.protocol = "wss";
                    break;
                  case "wx":
                    opts.protocol = "wxs";
                    break;
                  case "ali":
                    opts.protocol = "alis";
                    break;
                  default:
                    throw new Error('Unknown protocol for secure connection: "' + opts.protocol + '"!');
                }
              }
            } else {
              throw new Error("Missing secure protocol key");
            }
          }
          if (!protocols[opts.protocol]) {
            const isSecure = ["mqtts", "wss"].indexOf(opts.protocol) !== -1;
            opts.protocol = [
              "mqtt",
              "mqtts",
              "ws",
              "wss",
              "wx",
              "wxs",
              "ali",
              "alis"
            ].filter(function(key, index2) {
              if (isSecure && index2 % 2 === 0) {
                return false;
              }
              return typeof protocols[key] === "function";
            })[0];
          }
          if (opts.clean === false && !opts.clientId) {
            throw new Error("Missing clientId for unclean clients");
          }
          if (opts.protocol) {
            opts.defaultProtocol = opts.protocol;
          }
          function wrapper(client2) {
            if (opts.servers) {
              if (!client2._reconnectCount || client2._reconnectCount === opts.servers.length) {
                client2._reconnectCount = 0;
              }
              opts.host = opts.servers[client2._reconnectCount].host;
              opts.port = opts.servers[client2._reconnectCount].port;
              opts.protocol = !opts.servers[client2._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client2._reconnectCount].protocol;
              opts.hostname = opts.host;
              client2._reconnectCount++;
            }
            debug("calling streambuilder for", opts.protocol);
            return protocols[opts.protocol](client2, opts);
          }
          const client = new MqttClient(wrapper, opts);
          client.on("error", function() {
          });
          return client;
        }
        module2.exports = connect;
        module2.exports.connect = connect;
        module2.exports.MqttClient = MqttClient;
        module2.exports.Store = Store;
        module2.exports.DefaultMessageIdProvider = DefaultMessageIdProvider;
        module2.exports.UniqueMessageIdProvider = UniqueMessageIdProvider;
      }, { "../client": 1, "../default-message-id-provider": 7, "../is-browser": 8, "../store": 9, "../unique-message-id-provider": 12, "./ali": 2, "./tcp": 3, "./tls": 4, "./ws": 5, "./wx": 6, "debug": 21, "url": 128, "xtend": 133 }], 15: [function(require2, module2, exports2) {
        const { AbortController, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
          /* otherwise */
          void 0
        );
        module2.exports = AbortController;
        module2.exports.AbortSignal = AbortSignal;
        module2.exports.default = AbortController;
      }, {}], 16: [function(require2, module2, exports2) {
        exports2.byteLength = byteLength;
        exports2.toByteArray = toByteArray;
        exports2.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
          var len2 = b64.length;
          if (len2 % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          var validLen = b64.indexOf("=");
          if (validLen === -1)
            validLen = len2;
          var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
          return [validLen, placeHoldersLen];
        }
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
          var curByte = 0;
          var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
          var i2;
          for (i2 = 0; i2 < len2; i2 += 4) {
            tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
            arr[curByte++] = tmp >> 16 & 255;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 2) {
            tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 1) {
            tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i2 = start; i2 < end; i2 += 3) {
            tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }
        function fromByteArray(uint8) {
          var tmp;
          var len2 = uint8.length;
          var extraBytes = len2 % 3;
          var parts = [];
          var maxChunkLength = 16383;
          for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
            parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
          }
          if (extraBytes === 1) {
            tmp = uint8[len2 - 1];
            parts.push(
              lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
            );
          } else if (extraBytes === 2) {
            tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
            parts.push(
              lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
            );
          }
          return parts.join("");
        }
      }, {}], 17: [function(require2, module2, exports2) {
      }, {}], 18: [function(require2, module2, exports2) {
        var buffer = require2("buffer");
        var Buffer = buffer.Buffer;
        function copyProps(src2, dst) {
          for (var key in src2) {
            dst[key] = src2[key];
          }
        }
        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
          module2.exports = buffer;
        } else {
          copyProps(buffer, exports2);
          exports2.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length);
        }
        copyProps(Buffer, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding2) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer(size);
          if (fill !== void 0) {
            if (typeof encoding2 === "string") {
              buf.fill(fill, encoding2);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      }, { "buffer": 20 }], 19: [function(require2, module2, exports2) {
        var Buffer = require2("safe-buffer").Buffer;
        var isEncoding = Buffer.isEncoding || function(encoding2) {
          encoding2 = "" + encoding2;
          switch (encoding2 && encoding2.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function _normalizeEncoding(enc) {
          if (!enc)
            return "utf8";
          var retried;
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return enc;
              default:
                if (retried)
                  return;
                enc = ("" + enc).toLowerCase();
                retried = true;
            }
          }
        }
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc);
          if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
            throw new Error("Unknown encoding: " + enc);
          return nenc || enc;
        }
        exports2.StringDecoder = StringDecoder;
        function StringDecoder(encoding2) {
          this.encoding = normalizeEncoding(encoding2);
          var nb;
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text;
              this.end = utf16End;
              nb = 4;
              break;
            case "utf8":
              this.fillLast = utf8FillLast;
              nb = 4;
              break;
            case "base64":
              this.text = base64Text;
              this.end = base64End;
              nb = 3;
              break;
            default:
              this.write = simpleWrite;
              this.end = simpleEnd;
              return;
          }
          this.lastNeed = 0;
          this.lastTotal = 0;
          this.lastChar = Buffer.allocUnsafe(nb);
        }
        StringDecoder.prototype.write = function(buf) {
          if (buf.length === 0)
            return "";
          var r;
          var i;
          if (this.lastNeed) {
            r = this.fillLast(buf);
            if (r === void 0)
              return "";
            i = this.lastNeed;
            this.lastNeed = 0;
          } else {
            i = 0;
          }
          if (i < buf.length)
            return r ? r + this.text(buf, i) : this.text(buf, i);
          return r || "";
        };
        StringDecoder.prototype.end = utf8End;
        StringDecoder.prototype.text = utf8Text;
        StringDecoder.prototype.fillLast = function(buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
          this.lastNeed -= buf.length;
        };
        function utf8CheckByte(byte) {
          if (byte <= 127)
            return 0;
          else if (byte >> 5 === 6)
            return 2;
          else if (byte >> 4 === 14)
            return 3;
          else if (byte >> 3 === 30)
            return 4;
          return byte >> 6 === 2 ? -1 : -2;
        }
        function utf8CheckIncomplete(self2, buf, i) {
          var j = buf.length - 1;
          if (j < i)
            return 0;
          var nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 1;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 2;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2)
                nb = 0;
              else
                self2.lastNeed = nb - 3;
            }
            return nb;
          }
          return 0;
        }
        function utf8CheckExtraBytes(self2, buf, p) {
          if ((buf[0] & 192) !== 128) {
            self2.lastNeed = 0;
            return "�";
          }
          if (self2.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 192) !== 128) {
              self2.lastNeed = 1;
              return "�";
            }
            if (self2.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 192) !== 128) {
                self2.lastNeed = 2;
                return "�";
              }
            }
          }
        }
        function utf8FillLast(buf) {
          var p = this.lastTotal - this.lastNeed;
          var r = utf8CheckExtraBytes(this, buf);
          if (r !== void 0)
            return r;
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, p, 0, buf.length);
          this.lastNeed -= buf.length;
        }
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i);
          if (!this.lastNeed)
            return buf.toString("utf8", i);
          this.lastTotal = total;
          var end = buf.length - (total - this.lastNeed);
          buf.copy(this.lastChar, 0, end);
          return buf.toString("utf8", i, end);
        }
        function utf8End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r + "�";
          return r;
        }
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i);
            if (r) {
              var c = r.charCodeAt(r.length - 1);
              if (c >= 55296 && c <= 56319) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
              }
            }
            return r;
          }
          this.lastNeed = 1;
          this.lastTotal = 2;
          this.lastChar[0] = buf[buf.length - 1];
          return buf.toString("utf16le", i, buf.length - 1);
        }
        function utf16End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r + this.lastChar.toString("utf16le", 0, end);
          }
          return r;
        }
        function base64Text(buf, i) {
          var n = (buf.length - i) % 3;
          if (n === 0)
            return buf.toString("base64", i);
          this.lastNeed = 3 - n;
          this.lastTotal = 3;
          if (n === 1) {
            this.lastChar[0] = buf[buf.length - 1];
          } else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
          }
          return buf.toString("base64", i, buf.length - n);
        }
        function base64End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
          return r;
        }
        function simpleWrite(buf) {
          return buf.toString(this.encoding);
        }
        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : "";
        }
      }, { "safe-buffer": 18 }], 20: [function(require2, module2, exports2) {
        (function(Buffer) {
          (function() {
            var base64 = require2("base64-js");
            var ieee754 = require2("ieee754");
            exports2.Buffer = Buffer2;
            exports2.SlowBuffer = SlowBuffer;
            exports2.INSPECT_MAX_BYTES = 50;
            var K_MAX_LENGTH = 2147483647;
            exports2.kMaxLength = K_MAX_LENGTH;
            Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
              console.error(
                "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
              );
            }
            function typedArraySupport() {
              try {
                var arr = new Uint8Array(1);
                arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } };
                return arr.foo() === 42;
              } catch (e) {
                return false;
              }
            }
            Object.defineProperty(Buffer2.prototype, "parent", {
              enumerable: true,
              get: function() {
                if (!Buffer2.isBuffer(this))
                  return void 0;
                return this.buffer;
              }
            });
            Object.defineProperty(Buffer2.prototype, "offset", {
              enumerable: true,
              get: function() {
                if (!Buffer2.isBuffer(this))
                  return void 0;
                return this.byteOffset;
              }
            });
            function createBuffer(length) {
              if (length > K_MAX_LENGTH) {
                throw new RangeError('The value "' + length + '" is invalid for option "size"');
              }
              var buf = new Uint8Array(length);
              buf.__proto__ = Buffer2.prototype;
              return buf;
            }
            function Buffer2(arg, encodingOrOffset, length) {
              if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                  throw new TypeError(
                    'The "string" argument must be of type string. Received type number'
                  );
                }
                return allocUnsafe(arg);
              }
              return from(arg, encodingOrOffset, length);
            }
            if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer2[Symbol.species] === Buffer2) {
              Object.defineProperty(Buffer2, Symbol.species, {
                value: null,
                configurable: true,
                enumerable: false,
                writable: false
              });
            }
            Buffer2.poolSize = 8192;
            function from(value, encodingOrOffset, length) {
              if (typeof value === "string") {
                return fromString(value, encodingOrOffset);
              }
              if (ArrayBuffer.isView(value)) {
                return fromArrayLike(value);
              }
              if (value == null) {
                throw TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
                );
              }
              if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                return fromArrayBuffer(value, encodingOrOffset, length);
              }
              if (typeof value === "number") {
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number'
                );
              }
              var valueOf = value.valueOf && value.valueOf();
              if (valueOf != null && valueOf !== value) {
                return Buffer2.from(valueOf, encodingOrOffset, length);
              }
              var b = fromObject(value);
              if (b)
                return b;
              if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                return Buffer2.from(
                  value[Symbol.toPrimitive]("string"),
                  encodingOrOffset,
                  length
                );
              }
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
              );
            }
            Buffer2.from = function(value, encodingOrOffset, length) {
              return from(value, encodingOrOffset, length);
            };
            Buffer2.prototype.__proto__ = Uint8Array.prototype;
            Buffer2.__proto__ = Uint8Array;
            function assertSize(size) {
              if (typeof size !== "number") {
                throw new TypeError('"size" argument must be of type number');
              } else if (size < 0) {
                throw new RangeError('The value "' + size + '" is invalid for option "size"');
              }
            }
            function alloc(size, fill, encoding2) {
              assertSize(size);
              if (size <= 0) {
                return createBuffer(size);
              }
              if (fill !== void 0) {
                return typeof encoding2 === "string" ? createBuffer(size).fill(fill, encoding2) : createBuffer(size).fill(fill);
              }
              return createBuffer(size);
            }
            Buffer2.alloc = function(size, fill, encoding2) {
              return alloc(size, fill, encoding2);
            };
            function allocUnsafe(size) {
              assertSize(size);
              return createBuffer(size < 0 ? 0 : checked(size) | 0);
            }
            Buffer2.allocUnsafe = function(size) {
              return allocUnsafe(size);
            };
            Buffer2.allocUnsafeSlow = function(size) {
              return allocUnsafe(size);
            };
            function fromString(string, encoding2) {
              if (typeof encoding2 !== "string" || encoding2 === "") {
                encoding2 = "utf8";
              }
              if (!Buffer2.isEncoding(encoding2)) {
                throw new TypeError("Unknown encoding: " + encoding2);
              }
              var length = byteLength(string, encoding2) | 0;
              var buf = createBuffer(length);
              var actual = buf.write(string, encoding2);
              if (actual !== length) {
                buf = buf.slice(0, actual);
              }
              return buf;
            }
            function fromArrayLike(array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              var buf = createBuffer(length);
              for (var i = 0; i < length; i += 1) {
                buf[i] = array[i] & 255;
              }
              return buf;
            }
            function fromArrayBuffer(array, byteOffset, length) {
              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('"offset" is outside of buffer bounds');
              }
              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('"length" is outside of buffer bounds');
              }
              var buf;
              if (byteOffset === void 0 && length === void 0) {
                buf = new Uint8Array(array);
              } else if (length === void 0) {
                buf = new Uint8Array(array, byteOffset);
              } else {
                buf = new Uint8Array(array, byteOffset, length);
              }
              buf.__proto__ = Buffer2.prototype;
              return buf;
            }
            function fromObject(obj) {
              if (Buffer2.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                var buf = createBuffer(len);
                if (buf.length === 0) {
                  return buf;
                }
                obj.copy(buf, 0, 0, len);
                return buf;
              }
              if (obj.length !== void 0) {
                if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                  return createBuffer(0);
                }
                return fromArrayLike(obj);
              }
              if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                return fromArrayLike(obj.data);
              }
            }
            function checked(length) {
              if (length >= K_MAX_LENGTH) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
              }
              return length | 0;
            }
            function SlowBuffer(length) {
              if (+length != length) {
                length = 0;
              }
              return Buffer2.alloc(+length);
            }
            Buffer2.isBuffer = function isBuffer(b) {
              return b != null && b._isBuffer === true && b !== Buffer2.prototype;
            };
            Buffer2.compare = function compare(a, b) {
              if (isInstance(a, Uint8Array))
                a = Buffer2.from(a, a.offset, a.byteLength);
              if (isInstance(b, Uint8Array))
                b = Buffer2.from(b, b.offset, b.byteLength);
              if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
                throw new TypeError(
                  'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                );
              }
              if (a === b)
                return 0;
              var x = a.length;
              var y = b.length;
              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break;
                }
              }
              if (x < y)
                return -1;
              if (y < x)
                return 1;
              return 0;
            };
            Buffer2.isEncoding = function isEncoding(encoding2) {
              switch (String(encoding2).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            };
            Buffer2.concat = function concat(list, length) {
              if (!Array.isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              if (list.length === 0) {
                return Buffer2.alloc(0);
              }
              var i;
              if (length === void 0) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }
              var buffer = Buffer2.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (isInstance(buf, Uint8Array)) {
                  buf = Buffer2.from(buf);
                }
                if (!Buffer2.isBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer;
            };
            function byteLength(string, encoding2) {
              if (Buffer2.isBuffer(string)) {
                return string.length;
              }
              if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                return string.byteLength;
              }
              if (typeof string !== "string") {
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
                );
              }
              var len = string.length;
              var mustMatch = arguments.length > 2 && arguments[2] === true;
              if (!mustMatch && len === 0)
                return 0;
              var loweredCase = false;
              for (; ; ) {
                switch (encoding2) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;
                  case "utf8":
                  case "utf-8":
                    return utf8ToBytes(string).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;
                  case "hex":
                    return len >>> 1;
                  case "base64":
                    return base64ToBytes(string).length;
                  default:
                    if (loweredCase) {
                      return mustMatch ? -1 : utf8ToBytes(string).length;
                    }
                    encoding2 = ("" + encoding2).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer2.byteLength = byteLength;
            function slowToString(encoding2, start, end) {
              var loweredCase = false;
              if (start === void 0 || start < 0) {
                start = 0;
              }
              if (start > this.length) {
                return "";
              }
              if (end === void 0 || end > this.length) {
                end = this.length;
              }
              if (end <= 0) {
                return "";
              }
              end >>>= 0;
              start >>>= 0;
              if (end <= start) {
                return "";
              }
              if (!encoding2)
                encoding2 = "utf8";
              while (true) {
                switch (encoding2) {
                  case "hex":
                    return hexSlice(this, start, end);
                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);
                  case "ascii":
                    return asciiSlice(this, start, end);
                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);
                  case "base64":
                    return base64Slice(this, start, end);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding2);
                    encoding2 = (encoding2 + "").toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer2.prototype._isBuffer = true;
            function swap(b, n, m) {
              var i = b[n];
              b[n] = b[m];
              b[m] = i;
            }
            Buffer2.prototype.swap16 = function swap16() {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              }
              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this;
            };
            Buffer2.prototype.swap32 = function swap32() {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              }
              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this;
            };
            Buffer2.prototype.swap64 = function swap64() {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              }
              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this;
            };
            Buffer2.prototype.toString = function toString() {
              var length = this.length;
              if (length === 0)
                return "";
              if (arguments.length === 0)
                return utf8Slice(this, 0, length);
              return slowToString.apply(this, arguments);
            };
            Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
            Buffer2.prototype.equals = function equals(b) {
              if (!Buffer2.isBuffer(b))
                throw new TypeError("Argument must be a Buffer");
              if (this === b)
                return true;
              return Buffer2.compare(this, b) === 0;
            };
            Buffer2.prototype.inspect = function inspect() {
              var str = "";
              var max = exports2.INSPECT_MAX_BYTES;
              str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
              if (this.length > max)
                str += " ... ";
              return "<Buffer " + str + ">";
            };
            Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
              if (isInstance(target, Uint8Array)) {
                target = Buffer2.from(target, target.offset, target.byteLength);
              }
              if (!Buffer2.isBuffer(target)) {
                throw new TypeError(
                  'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
                );
              }
              if (start === void 0) {
                start = 0;
              }
              if (end === void 0) {
                end = target ? target.length : 0;
              }
              if (thisStart === void 0) {
                thisStart = 0;
              }
              if (thisEnd === void 0) {
                thisEnd = this.length;
              }
              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError("out of range index");
              }
              if (thisStart >= thisEnd && start >= end) {
                return 0;
              }
              if (thisStart >= thisEnd) {
                return -1;
              }
              if (start >= end) {
                return 1;
              }
              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;
              if (this === target)
                return 0;
              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);
              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);
              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break;
                }
              }
              if (x < y)
                return -1;
              if (y < x)
                return 1;
              return 0;
            };
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding2, dir) {
              if (buffer.length === 0)
                return -1;
              if (typeof byteOffset === "string") {
                encoding2 = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 2147483647) {
                byteOffset = 2147483647;
              } else if (byteOffset < -2147483648) {
                byteOffset = -2147483648;
              }
              byteOffset = +byteOffset;
              if (numberIsNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer.length - 1;
              }
              if (byteOffset < 0)
                byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir)
                  return -1;
                else
                  byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir)
                  byteOffset = 0;
                else
                  return -1;
              }
              if (typeof val === "string") {
                val = Buffer2.from(val, encoding2);
              }
              if (Buffer2.isBuffer(val)) {
                if (val.length === 0) {
                  return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding2, dir);
              } else if (typeof val === "number") {
                val = val & 255;
                if (typeof Uint8Array.prototype.indexOf === "function") {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                  }
                }
                return arrayIndexOf(buffer, [val], byteOffset, encoding2, dir);
              }
              throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;
              if (encoding2 !== void 0) {
                encoding2 = String(encoding2).toLowerCase();
                if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
                  if (arr.length < 2 || val.length < 2) {
                    return -1;
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }
              function read(buf, i2) {
                if (indexSize === 1) {
                  return buf[i2];
                } else {
                  return buf.readUInt16BE(i2 * indexSize);
                }
              }
              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1)
                      foundIndex = i;
                    if (i - foundIndex + 1 === valLength)
                      return foundIndex * indexSize;
                  } else {
                    if (foundIndex !== -1)
                      i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength)
                  byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read(arr, i + j) !== read(val, j)) {
                      found = false;
                      break;
                    }
                  }
                  if (found)
                    return i;
                }
              }
              return -1;
            }
            Buffer2.prototype.includes = function includes(val, byteOffset, encoding2) {
              return this.indexOf(val, byteOffset, encoding2) !== -1;
            };
            Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
            };
            Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
            };
            function hexWrite(buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }
              var strLen = string.length;
              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (numberIsNaN(parsed))
                  return i;
                buf[offset + i] = parsed;
              }
              return i;
            }
            function utf8Write(buf, string, offset, length) {
              return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
            }
            function asciiWrite(buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length);
            }
            function latin1Write(buf, string, offset, length) {
              return asciiWrite(buf, string, offset, length);
            }
            function base64Write(buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length);
            }
            function ucs2Write(buf, string, offset, length) {
              return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
            }
            Buffer2.prototype.write = function write(string, offset, length, encoding2) {
              if (offset === void 0) {
                encoding2 = "utf8";
                length = this.length;
                offset = 0;
              } else if (length === void 0 && typeof offset === "string") {
                encoding2 = offset;
                length = this.length;
                offset = 0;
              } else if (isFinite(offset)) {
                offset = offset >>> 0;
                if (isFinite(length)) {
                  length = length >>> 0;
                  if (encoding2 === void 0)
                    encoding2 = "utf8";
                } else {
                  encoding2 = length;
                  length = void 0;
                }
              } else {
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              }
              var remaining = this.length - offset;
              if (length === void 0 || length > remaining)
                length = remaining;
              if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                throw new RangeError("Attempt to write outside buffer bounds");
              }
              if (!encoding2)
                encoding2 = "utf8";
              var loweredCase = false;
              for (; ; ) {
                switch (encoding2) {
                  case "hex":
                    return hexWrite(this, string, offset, length);
                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset, length);
                  case "ascii":
                    return asciiWrite(this, string, offset, length);
                  case "latin1":
                  case "binary":
                    return latin1Write(this, string, offset, length);
                  case "base64":
                    return base64Write(this, string, offset, length);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset, length);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding2);
                    encoding2 = ("" + encoding2).toLowerCase();
                    loweredCase = true;
                }
              }
            };
            Buffer2.prototype.toJSON = function toJSON() {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
              };
            };
            function base64Slice(buf, start, end) {
              if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
              } else {
                return base64.fromByteArray(buf.slice(start, end));
              }
            }
            function utf8Slice(buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];
              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;
                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 128) {
                        codePoint = firstByte;
                      }
                      break;
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }
                if (codePoint === null) {
                  codePoint = 65533;
                  bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                  codePoint -= 65536;
                  res.push(codePoint >>> 10 & 1023 | 55296);
                  codePoint = 56320 | codePoint & 1023;
                }
                res.push(codePoint);
                i += bytesPerSequence;
              }
              return decodeCodePointsArray(res);
            }
            var MAX_ARGUMENTS_LENGTH = 4096;
            function decodeCodePointsArray(codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
              }
              var res = "";
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                );
              }
              return res;
            }
            function asciiSlice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 127);
              }
              return ret;
            }
            function latin1Slice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret;
            }
            function hexSlice(buf, start, end) {
              var len = buf.length;
              if (!start || start < 0)
                start = 0;
              if (!end || end < 0 || end > len)
                end = len;
              var out = "";
              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }
              return out;
            }
            function utf16leSlice(buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = "";
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res;
            }
            Buffer2.prototype.slice = function slice(start, end) {
              var len = this.length;
              start = ~~start;
              end = end === void 0 ? len : ~~end;
              if (start < 0) {
                start += len;
                if (start < 0)
                  start = 0;
              } else if (start > len) {
                start = len;
              }
              if (end < 0) {
                end += len;
                if (end < 0)
                  end = 0;
              } else if (end > len) {
                end = len;
              }
              if (end < start)
                end = start;
              var newBuf = this.subarray(start, end);
              newBuf.__proto__ = Buffer2.prototype;
              return newBuf;
            };
            function checkOffset(offset, ext, length) {
              if (offset % 1 !== 0 || offset < 0)
                throw new RangeError("offset is not uint");
              if (offset + ext > length)
                throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength2 && (mul *= 256)) {
                val += this[offset + i] * mul;
              }
              return val;
            };
            Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                checkOffset(offset, byteLength2, this.length);
              }
              var val = this[offset + --byteLength2];
              var mul = 1;
              while (byteLength2 > 0 && (mul *= 256)) {
                val += this[offset + --byteLength2] * mul;
              }
              return val;
            };
            Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 1, this.length);
              return this[offset];
            };
            Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              return this[offset] | this[offset + 1] << 8;
            };
            Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              return this[offset] << 8 | this[offset + 1];
            };
            Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
            };
            Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
            };
            Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength2 && (mul *= 256)) {
                val += this[offset + i] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert)
                checkOffset(offset, byteLength2, this.length);
              var i = byteLength2;
              var mul = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul *= 256)) {
                val += this[offset + --i] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength2);
              return val;
            };
            Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 1, this.length);
              if (!(this[offset] & 128))
                return this[offset];
              return (255 - this[offset] + 1) * -1;
            };
            Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              var val = this[offset] | this[offset + 1] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | this[offset] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
            };
            Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
            };
            Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, true, 23, 4);
            };
            Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, false, 23, 4);
            };
            Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, true, 52, 8);
            };
            Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
              offset = offset >>> 0;
              if (!noAssert)
                checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, false, 52, 8);
            };
            function checkInt(buf, value, offset, ext, max, min) {
              if (!Buffer2.isBuffer(buf))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (value > max || value < min)
                throw new RangeError('"value" argument is out of bounds');
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
            }
            Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
              }
              var mul = 1;
              var i = 0;
              this[offset] = value & 255;
              while (++i < byteLength2 && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              byteLength2 = byteLength2 >>> 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
              }
              var i = byteLength2 - 1;
              var mul = 1;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 1, 255, 0);
              this[offset] = value & 255;
              return offset + 1;
            };
            Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 65535, 0);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };
            Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 65535, 0);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
              return offset + 2;
            };
            Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 4294967295, 0);
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 255;
              return offset + 4;
            };
            Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 4294967295, 0);
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
              return offset + 4;
            };
            Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
              }
              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 255;
              while (++i < byteLength2 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
              }
              var i = byteLength2 - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
              }
              return offset + byteLength2;
            };
            Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 1, 127, -128);
              if (value < 0)
                value = 255 + value + 1;
              this[offset] = value & 255;
              return offset + 1;
            };
            Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 32767, -32768);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              return offset + 2;
            };
            Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 2, 32767, -32768);
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
              return offset + 2;
            };
            Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
              return offset + 4;
            };
            Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              if (value < 0)
                value = 4294967295 + value + 1;
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
              return offset + 4;
            };
            function checkIEEE754(buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length)
                throw new RangeError("Index out of range");
              if (offset < 0)
                throw new RangeError("Index out of range");
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 4);
              }
              ieee754.write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4;
            }
            Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
              return writeFloat(this, value, offset, true, noAssert);
            };
            Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
              return writeFloat(this, value, offset, false, noAssert);
            };
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
              value = +value;
              offset = offset >>> 0;
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 8);
              }
              ieee754.write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8;
            }
            Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
              return writeDouble(this, value, offset, true, noAssert);
            };
            Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
              return writeDouble(this, value, offset, false, noAssert);
            };
            Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
              if (!Buffer2.isBuffer(target))
                throw new TypeError("argument should be a Buffer");
              if (!start)
                start = 0;
              if (!end && end !== 0)
                end = this.length;
              if (targetStart >= target.length)
                targetStart = target.length;
              if (!targetStart)
                targetStart = 0;
              if (end > 0 && end < start)
                end = start;
              if (end === start)
                return 0;
              if (target.length === 0 || this.length === 0)
                return 0;
              if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
              }
              if (start < 0 || start >= this.length)
                throw new RangeError("Index out of range");
              if (end < 0)
                throw new RangeError("sourceEnd out of bounds");
              if (end > this.length)
                end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }
              var len = end - start;
              if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                this.copyWithin(targetStart, start, end);
              } else if (this === target && start < targetStart && targetStart < end) {
                for (var i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, end),
                  targetStart
                );
              }
              return len;
            };
            Buffer2.prototype.fill = function fill(val, start, end, encoding2) {
              if (typeof val === "string") {
                if (typeof start === "string") {
                  encoding2 = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === "string") {
                  encoding2 = end;
                  end = this.length;
                }
                if (encoding2 !== void 0 && typeof encoding2 !== "string") {
                  throw new TypeError("encoding must be a string");
                }
                if (typeof encoding2 === "string" && !Buffer2.isEncoding(encoding2)) {
                  throw new TypeError("Unknown encoding: " + encoding2);
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (encoding2 === "utf8" && code < 128 || encoding2 === "latin1") {
                    val = code;
                  }
                }
              } else if (typeof val === "number") {
                val = val & 255;
              }
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
              }
              if (end <= start) {
                return this;
              }
              start = start >>> 0;
              end = end === void 0 ? this.length : end >>> 0;
              if (!val)
                val = 0;
              var i;
              if (typeof val === "number") {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding2);
                var len = bytes.length;
                if (len === 0) {
                  throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                }
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }
              return this;
            };
            var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
            function base64clean(str) {
              str = str.split("=")[0];
              str = str.trim().replace(INVALID_BASE64_RE, "");
              if (str.length < 2)
                return "";
              while (str.length % 4 !== 0) {
                str = str + "=";
              }
              return str;
            }
            function toHex(n) {
              if (n < 16)
                return "0" + n.toString(16);
              return n.toString(16);
            }
            function utf8ToBytes(string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];
              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);
                if (codePoint > 55295 && codePoint < 57344) {
                  if (!leadSurrogate) {
                    if (codePoint > 56319) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    } else if (i + 1 === length) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    }
                    leadSurrogate = codePoint;
                    continue;
                  }
                  if (codePoint < 56320) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    leadSurrogate = codePoint;
                    continue;
                  }
                  codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                } else if (leadSurrogate) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = null;
                if (codePoint < 128) {
                  if ((units -= 1) < 0)
                    break;
                  bytes.push(codePoint);
                } else if (codePoint < 2048) {
                  if ((units -= 2) < 0)
                    break;
                  bytes.push(
                    codePoint >> 6 | 192,
                    codePoint & 63 | 128
                  );
                } else if (codePoint < 65536) {
                  if ((units -= 3) < 0)
                    break;
                  bytes.push(
                    codePoint >> 12 | 224,
                    codePoint >> 6 & 63 | 128,
                    codePoint & 63 | 128
                  );
                } else if (codePoint < 1114112) {
                  if ((units -= 4) < 0)
                    break;
                  bytes.push(
                    codePoint >> 18 | 240,
                    codePoint >> 12 & 63 | 128,
                    codePoint >> 6 & 63 | 128,
                    codePoint & 63 | 128
                  );
                } else {
                  throw new Error("Invalid code point");
                }
              }
              return bytes;
            }
            function asciiToBytes(str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                byteArray.push(str.charCodeAt(i) & 255);
              }
              return byteArray;
            }
            function utf16leToBytes(str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0)
                  break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }
              return byteArray;
            }
            function base64ToBytes(str) {
              return base64.toByteArray(base64clean(str));
            }
            function blitBuffer(src2, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src2.length)
                  break;
                dst[i + offset] = src2[i];
              }
              return i;
            }
            function isInstance(obj, type) {
              return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
            }
            function numberIsNaN(obj) {
              return obj !== obj;
            }
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "base64-js": 16, "buffer": 20, "ieee754": 41 }], 21: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            exports2.formatArgs = formatArgs;
            exports2.save = save;
            exports2.load = load;
            exports2.useColors = useColors;
            exports2.storage = localstorage();
            exports2.destroy = (() => {
              let warned = false;
              return () => {
                if (!warned) {
                  warned = true;
                  console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
                }
              };
            })();
            exports2.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33"
            ];
            function useColors() {
              if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
                return true;
              }
              if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                return false;
              }
              return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
              typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
              // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
              typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
              typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
            }
            function formatArgs(args) {
              args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
              if (!this.useColors) {
                return;
              }
              const c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");
              let index2 = 0;
              let lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, (match) => {
                if (match === "%%") {
                  return;
                }
                index2++;
                if (match === "%c") {
                  lastC = index2;
                }
              });
              args.splice(lastC, 0, c);
            }
            exports2.log = console.debug || console.log || (() => {
            });
            function save(namespaces) {
              try {
                if (namespaces) {
                  exports2.storage.setItem("debug", namespaces);
                } else {
                  exports2.storage.removeItem("debug");
                }
              } catch (error) {
              }
            }
            function load() {
              let r;
              try {
                r = exports2.storage.getItem("debug");
              } catch (error) {
              }
              if (!r && typeof process !== "undefined" && "env" in process) {
                r = {}.DEBUG;
              }
              return r;
            }
            function localstorage() {
              try {
                return localStorage;
              } catch (error) {
              }
            }
            module2.exports = require2("./common")(exports2);
            const { formatters } = module2.exports;
            formatters.j = function(v) {
              try {
                return JSON.stringify(v);
              } catch (error) {
                return "[UnexpectedJSONParseError]: " + error.message;
              }
            };
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./common": 22, "_process": 93 }], 22: [function(require2, module2, exports2) {
        function setup(env) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = require2("ms");
          createDebug.destroy = destroy;
          Object.keys(env).forEach((key) => {
            createDebug[key] = env[key];
          });
          createDebug.names = [];
          createDebug.skips = [];
          createDebug.formatters = {};
          function selectColor(namespace) {
            let hash = 0;
            for (let i = 0; i < namespace.length; i++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }
          createDebug.selectColor = selectColor;
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;
            function debug(...args) {
              if (!debug.enabled) {
                return;
              }
              const self2 = debug;
              const curr = Number(/* @__PURE__ */ new Date());
              const ms = curr - (prevTime || curr);
              self2.diff = ms;
              self2.prev = prevTime;
              self2.curr = curr;
              prevTime = curr;
              args[0] = createDebug.coerce(args[0]);
              if (typeof args[0] !== "string") {
                args.unshift("%O");
              }
              let index2 = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                if (match === "%%") {
                  return "%";
                }
                index2++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                  const val = args[index2];
                  match = formatter.call(self2, val);
                  args.splice(index2, 1);
                  index2--;
                }
                return match;
              });
              createDebug.formatArgs.call(self2, args);
              const logFn = self2.log || createDebug.log;
              logFn.apply(self2, args);
            }
            debug.namespace = namespace;
            debug.useColors = createDebug.useColors();
            debug.color = createDebug.selectColor(namespace);
            debug.extend = extend;
            debug.destroy = createDebug.destroy;
            Object.defineProperty(debug, "enabled", {
              enumerable: true,
              configurable: false,
              get: () => {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
              },
              set: (v) => {
                enableOverride = v;
              }
            });
            if (typeof createDebug.init === "function") {
              createDebug.init(debug);
            }
            return debug;
          }
          function extend(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
          }
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;
            createDebug.names = [];
            createDebug.skips = [];
            let i;
            const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
            const len = split.length;
            for (i = 0; i < len; i++) {
              if (!split[i]) {
                continue;
              }
              namespaces = split[i].replace(/\*/g, ".*?");
              if (namespaces[0] === "-") {
                createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
              } else {
                createDebug.names.push(new RegExp("^" + namespaces + "$"));
              }
            }
          }
          function disable() {
            const namespaces = [
              ...createDebug.names.map(toNamespace),
              ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
            ].join(",");
            createDebug.enable("");
            return namespaces;
          }
          function enabled(name2) {
            if (name2[name2.length - 1] === "*") {
              return true;
            }
            let i;
            let len;
            for (i = 0, len = createDebug.skips.length; i < len; i++) {
              if (createDebug.skips[i].test(name2)) {
                return false;
              }
            }
            for (i = 0, len = createDebug.names.length; i < len; i++) {
              if (createDebug.names[i].test(name2)) {
                return true;
              }
            }
            return false;
          }
          function toNamespace(regexp) {
            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          function coerce(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }
          function destroy() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          createDebug.enable(createDebug.load());
          return createDebug;
        }
        module2.exports = setup;
      }, { "ms": 88 }], 23: [function(require2, module2, exports2) {
        (function(process, Buffer) {
          (function() {
            var stream = require2("readable-stream");
            var eos = require2("end-of-stream");
            var inherits = require2("inherits");
            var shift = require2("stream-shift");
            var SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]);
            var onuncork = function(self2, fn) {
              if (self2._corked)
                self2.once("uncork", fn);
              else
                fn();
            };
            var autoDestroy = function(self2, err) {
              if (self2._autoDestroy)
                self2.destroy(err);
            };
            var destroyer = function(self2, end2) {
              return function(err) {
                if (err)
                  autoDestroy(self2, err.message === "premature close" ? null : err);
                else if (end2 && !self2._ended)
                  self2.end();
              };
            };
            var end = function(ws, fn) {
              if (!ws)
                return fn();
              if (ws._writableState && ws._writableState.finished)
                return fn();
              if (ws._writableState)
                return ws.end(fn);
              ws.end();
              fn();
            };
            var noop = function() {
            };
            var toStreams2 = function(rs) {
              return new stream.Readable({ objectMode: true, highWaterMark: 16 }).wrap(rs);
            };
            var Duplexify = function(writable, readable, opts) {
              if (!(this instanceof Duplexify))
                return new Duplexify(writable, readable, opts);
              stream.Duplex.call(this, opts);
              this._writable = null;
              this._readable = null;
              this._readable2 = null;
              this._autoDestroy = !opts || opts.autoDestroy !== false;
              this._forwardDestroy = !opts || opts.destroy !== false;
              this._forwardEnd = !opts || opts.end !== false;
              this._corked = 1;
              this._ondrain = null;
              this._drained = false;
              this._forwarding = false;
              this._unwrite = null;
              this._unread = null;
              this._ended = false;
              this.destroyed = false;
              if (writable)
                this.setWritable(writable);
              if (readable)
                this.setReadable(readable);
            };
            inherits(Duplexify, stream.Duplex);
            Duplexify.obj = function(writable, readable, opts) {
              if (!opts)
                opts = {};
              opts.objectMode = true;
              opts.highWaterMark = 16;
              return new Duplexify(writable, readable, opts);
            };
            Duplexify.prototype.cork = function() {
              if (++this._corked === 1)
                this.emit("cork");
            };
            Duplexify.prototype.uncork = function() {
              if (this._corked && --this._corked === 0)
                this.emit("uncork");
            };
            Duplexify.prototype.setWritable = function(writable) {
              if (this._unwrite)
                this._unwrite();
              if (this.destroyed) {
                if (writable && writable.destroy)
                  writable.destroy();
                return;
              }
              if (writable === null || writable === false) {
                this.end();
                return;
              }
              var self2 = this;
              var unend = eos(writable, { writable: true, readable: false }, destroyer(this, this._forwardEnd));
              var ondrain = function() {
                var ondrain2 = self2._ondrain;
                self2._ondrain = null;
                if (ondrain2)
                  ondrain2();
              };
              var clear = function() {
                self2._writable.removeListener("drain", ondrain);
                unend();
              };
              if (this._unwrite)
                process.nextTick(ondrain);
              this._writable = writable;
              this._writable.on("drain", ondrain);
              this._unwrite = clear;
              this.uncork();
            };
            Duplexify.prototype.setReadable = function(readable) {
              if (this._unread)
                this._unread();
              if (this.destroyed) {
                if (readable && readable.destroy)
                  readable.destroy();
                return;
              }
              if (readable === null || readable === false) {
                this.push(null);
                this.resume();
                return;
              }
              var self2 = this;
              var unend = eos(readable, { writable: false, readable: true }, destroyer(this));
              var onreadable = function() {
                self2._forward();
              };
              var onend = function() {
                self2.push(null);
              };
              var clear = function() {
                self2._readable2.removeListener("readable", onreadable);
                self2._readable2.removeListener("end", onend);
                unend();
              };
              this._drained = true;
              this._readable = readable;
              this._readable2 = readable._readableState ? readable : toStreams2(readable);
              this._readable2.on("readable", onreadable);
              this._readable2.on("end", onend);
              this._unread = clear;
              this._forward();
            };
            Duplexify.prototype._read = function() {
              this._drained = true;
              this._forward();
            };
            Duplexify.prototype._forward = function() {
              if (this._forwarding || !this._readable2 || !this._drained)
                return;
              this._forwarding = true;
              var data;
              while (this._drained && (data = shift(this._readable2)) !== null) {
                if (this.destroyed)
                  continue;
                this._drained = this.push(data);
              }
              this._forwarding = false;
            };
            Duplexify.prototype.destroy = function(err, cb) {
              if (!cb)
                cb = noop;
              if (this.destroyed)
                return cb(null);
              this.destroyed = true;
              var self2 = this;
              process.nextTick(function() {
                self2._destroy(err);
                cb(null);
              });
            };
            Duplexify.prototype._destroy = function(err) {
              if (err) {
                var ondrain = this._ondrain;
                this._ondrain = null;
                if (ondrain)
                  ondrain(err);
                else
                  this.emit("error", err);
              }
              if (this._forwardDestroy) {
                if (this._readable && this._readable.destroy)
                  this._readable.destroy();
                if (this._writable && this._writable.destroy)
                  this._writable.destroy();
              }
              this.emit("close");
            };
            Duplexify.prototype._write = function(data, enc, cb) {
              if (this.destroyed)
                return;
              if (this._corked)
                return onuncork(this, this._write.bind(this, data, enc, cb));
              if (data === SIGNAL_FLUSH)
                return this._finish(cb);
              if (!this._writable)
                return cb();
              if (this._writable.write(data) === false)
                this._ondrain = cb;
              else if (!this.destroyed)
                cb();
            };
            Duplexify.prototype._finish = function(cb) {
              var self2 = this;
              this.emit("preend");
              onuncork(this, function() {
                end(self2._forwardEnd && self2._writable, function() {
                  if (self2._writableState.prefinished === false)
                    self2._writableState.prefinished = true;
                  self2.emit("prefinish");
                  onuncork(self2, cb);
                });
              });
            };
            Duplexify.prototype.end = function(data, enc, cb) {
              if (typeof data === "function")
                return this.end(null, null, data);
              if (typeof enc === "function")
                return this.end(data, null, enc);
              this._ended = true;
              if (data)
                this.write(data);
              if (!this._writableState.ending && !this._writableState.destroyed)
                this.write(SIGNAL_FLUSH);
              return stream.Writable.prototype.end.call(this, cb);
            };
            module2.exports = Duplexify;
          }).call(this);
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "_process": 93, "buffer": 20, "end-of-stream": 39, "inherits": 42, "readable-stream": 38, "stream-shift": 126 }], 24: [function(require2, module2, exports2) {
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var codes = {};
        function createErrorType(code, message, Base) {
          if (!Base) {
            Base = Error;
          }
          function getMessage(arg1, arg2, arg3) {
            if (typeof message === "string") {
              return message;
            } else {
              return message(arg1, arg2, arg3);
            }
          }
          var NodeError = /* @__PURE__ */ function(_Base) {
            _inheritsLoose(NodeError2, _Base);
            function NodeError2(arg1, arg2, arg3) {
              return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
            }
            return NodeError2;
          }(Base);
          NodeError.prototype.name = Base.name;
          NodeError.prototype.code = code;
          codes[code] = NodeError;
        }
        function oneOf(expected, thing) {
          if (Array.isArray(expected)) {
            var len = expected.length;
            expected = expected.map(function(i) {
              return String(i);
            });
            if (len > 2) {
              return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
            } else if (len === 2) {
              return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
            } else {
              return "of ".concat(thing, " ").concat(expected[0]);
            }
          } else {
            return "of ".concat(thing, " ").concat(String(expected));
          }
        }
        function startsWith(str, search, pos) {
          return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
        }
        function endsWith(str, search, this_len) {
          if (this_len === void 0 || this_len > str.length) {
            this_len = str.length;
          }
          return str.substring(this_len - search.length, this_len) === search;
        }
        function includes(str, search, start) {
          if (typeof start !== "number") {
            start = 0;
          }
          if (start + search.length > str.length) {
            return false;
          } else {
            return str.indexOf(search, start) !== -1;
          }
        }
        createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
          return 'The value "' + value + '" is invalid for option "' + name2 + '"';
        }, TypeError);
        createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
          var determiner;
          if (typeof expected === "string" && startsWith(expected, "not ")) {
            determiner = "must not be";
            expected = expected.replace(/^not /, "");
          } else {
            determiner = "must be";
          }
          var msg;
          if (endsWith(name2, " argument")) {
            msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
          } else {
            var type = includes(name2, ".") ? "property" : "argument";
            msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
          }
          msg += ". Received type ".concat(typeof actual);
          return msg;
        }, TypeError);
        createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
        createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
          return "The " + name2 + " method is not implemented";
        });
        createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
        createErrorType("ERR_STREAM_DESTROYED", function(name2) {
          return "Cannot call " + name2 + " after a stream was destroyed";
        });
        createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
        createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
        createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
        createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
        createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
          return "Unknown encoding: " + arg;
        }, TypeError);
        createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
        module2.exports.codes = codes;
      }, {}], 25: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            var objectKeys = Object.keys || function(obj) {
              var keys2 = [];
              for (var key in obj) {
                keys2.push(key);
              }
              return keys2;
            };
            module2.exports = Duplex;
            var Readable = require2("./_stream_readable");
            var Writable = require2("./_stream_writable");
            require2("inherits")(Duplex, Readable);
            {
              var keys = objectKeys(Writable.prototype);
              for (var v = 0; v < keys.length; v++) {
                var method = keys[v];
                if (!Duplex.prototype[method])
                  Duplex.prototype[method] = Writable.prototype[method];
              }
            }
            function Duplex(options) {
              if (!(this instanceof Duplex))
                return new Duplex(options);
              Readable.call(this, options);
              Writable.call(this, options);
              this.allowHalfOpen = true;
              if (options) {
                if (options.readable === false)
                  this.readable = false;
                if (options.writable === false)
                  this.writable = false;
                if (options.allowHalfOpen === false) {
                  this.allowHalfOpen = false;
                  this.once("end", onend);
                }
              }
            }
            Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.highWaterMark;
              }
            });
            Object.defineProperty(Duplex.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            Object.defineProperty(Duplex.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.length;
              }
            });
            function onend() {
              if (this._writableState.ended)
                return;
              process.nextTick(onEndNT, this);
            }
            function onEndNT(self2) {
              self2.end();
            }
            Object.defineProperty(Duplex.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed && this._writableState.destroyed;
              },
              set: function set(value) {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return;
                }
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
              }
            });
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./_stream_readable": 27, "./_stream_writable": 29, "_process": 93, "inherits": 42 }], 26: [function(require2, module2, exports2) {
        module2.exports = PassThrough;
        var Transform = require2("./_stream_transform");
        require2("inherits")(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding2, cb) {
          cb(null, chunk);
        };
      }, { "./_stream_transform": 28, "inherits": 42 }], 27: [function(require2, module2, exports2) {
        (function(process, global2) {
          (function() {
            module2.exports = Readable;
            var Duplex;
            Readable.ReadableState = ReadableState;
            require2("events").EventEmitter;
            var EElistenerCount = function EElistenerCount2(emitter, type) {
              return emitter.listeners(type).length;
            };
            var Stream = require2("./internal/streams/stream");
            var Buffer = require2("buffer").Buffer;
            var OurUint8Array = global2.Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var debugUtil = require2("util");
            var debug;
            if (debugUtil && debugUtil.debuglog) {
              debug = debugUtil.debuglog("stream");
            } else {
              debug = function debug2() {
              };
            }
            var BufferList = require2("./internal/streams/buffer_list");
            var destroyImpl = require2("./internal/streams/destroy");
            var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            var StringDecoder;
            var createReadableStreamAsyncIterator;
            var from;
            require2("inherits")(Readable, Stream);
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
            function prependListener(emitter, event, fn) {
              if (typeof emitter.prependListener === "function")
                return emitter.prependListener(event, fn);
              if (!emitter._events || !emitter._events[event])
                emitter.on(event, fn);
              else if (Array.isArray(emitter._events[event]))
                emitter._events[event].unshift(fn);
              else
                emitter._events[event] = [fn, emitter._events[event]];
            }
            function ReadableState(options, stream, isDuplex) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.readableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;
              this.sync = true;
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;
              this.paused = true;
              this.emitClose = options.emitClose !== false;
              this.autoDestroy = !!options.autoDestroy;
              this.destroyed = false;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.awaitDrain = 0;
              this.readingMore = false;
              this.decoder = null;
              this.encoding = null;
              if (options.encoding) {
                if (!StringDecoder)
                  StringDecoder = require2("string_decoder/").StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }
            function Readable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              if (!(this instanceof Readable))
                return new Readable(options);
              var isDuplex = this instanceof Duplex;
              this._readableState = new ReadableState(options, this, isDuplex);
              this.readable = true;
              if (options) {
                if (typeof options.read === "function")
                  this._read = options.read;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
              }
              Stream.call(this);
            }
            Object.defineProperty(Readable.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                if (this._readableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed;
              },
              set: function set(value) {
                if (!this._readableState) {
                  return;
                }
                this._readableState.destroyed = value;
              }
            });
            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;
            Readable.prototype._destroy = function(err, cb) {
              cb(err);
            };
            Readable.prototype.push = function(chunk, encoding2) {
              var state = this._readableState;
              var skipChunkCheck;
              if (!state.objectMode) {
                if (typeof chunk === "string") {
                  encoding2 = encoding2 || state.defaultEncoding;
                  if (encoding2 !== state.encoding) {
                    chunk = Buffer.from(chunk, encoding2);
                    encoding2 = "";
                  }
                  skipChunkCheck = true;
                }
              } else {
                skipChunkCheck = true;
              }
              return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
            };
            Readable.prototype.unshift = function(chunk) {
              return readableAddChunk(this, chunk, null, true, false);
            };
            function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
              debug("readableAddChunk", chunk);
              var state = stream._readableState;
              if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else {
                var er;
                if (!skipChunkCheck)
                  er = chunkInvalid(state, chunk);
                if (er) {
                  errorOrDestroy(stream, er);
                } else if (state.objectMode || chunk && chunk.length > 0) {
                  if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                    chunk = _uint8ArrayToBuffer(chunk);
                  }
                  if (addToFront) {
                    if (state.endEmitted)
                      errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                    else
                      addChunk(stream, state, chunk, true);
                  } else if (state.ended) {
                    errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                  } else if (state.destroyed) {
                    return false;
                  } else {
                    state.reading = false;
                    if (state.decoder && !encoding2) {
                      chunk = state.decoder.write(chunk);
                      if (state.objectMode || chunk.length !== 0)
                        addChunk(stream, state, chunk, false);
                      else
                        maybeReadMore(stream, state);
                    } else {
                      addChunk(stream, state, chunk, false);
                    }
                  }
                } else if (!addToFront) {
                  state.reading = false;
                  maybeReadMore(stream, state);
                }
              }
              return !state.ended && (state.length < state.highWaterMark || state.length === 0);
            }
            function addChunk(stream, state, chunk, addToFront) {
              if (state.flowing && state.length === 0 && !state.sync) {
                state.awaitDrain = 0;
                stream.emit("data", chunk);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
              maybeReadMore(stream, state);
            }
            function chunkInvalid(state, chunk) {
              var er;
              if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
              }
              return er;
            }
            Readable.prototype.isPaused = function() {
              return this._readableState.flowing === false;
            };
            Readable.prototype.setEncoding = function(enc) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              var decoder = new StringDecoder(enc);
              this._readableState.decoder = decoder;
              this._readableState.encoding = this._readableState.decoder.encoding;
              var p = this._readableState.buffer.head;
              var content = "";
              while (p !== null) {
                content += decoder.write(p.data);
                p = p.next;
              }
              this._readableState.buffer.clear();
              if (content !== "")
                this._readableState.buffer.push(content);
              this._readableState.length = content.length;
              return this;
            };
            var MAX_HWM = 1073741824;
            function computeNewHighWaterMark(n) {
              if (n >= MAX_HWM) {
                n = MAX_HWM;
              } else {
                n--;
                n |= n >>> 1;
                n |= n >>> 2;
                n |= n >>> 4;
                n |= n >>> 8;
                n |= n >>> 16;
                n++;
              }
              return n;
            }
            function howMuchToRead(n, state) {
              if (n <= 0 || state.length === 0 && state.ended)
                return 0;
              if (state.objectMode)
                return 1;
              if (n !== n) {
                if (state.flowing && state.length)
                  return state.buffer.head.data.length;
                else
                  return state.length;
              }
              if (n > state.highWaterMark)
                state.highWaterMark = computeNewHighWaterMark(n);
              if (n <= state.length)
                return n;
              if (!state.ended) {
                state.needReadable = true;
                return 0;
              }
              return state.length;
            }
            Readable.prototype.read = function(n) {
              debug("read", n);
              n = parseInt(n, 10);
              var state = this._readableState;
              var nOrig = n;
              if (n !== 0)
                state.emittedReadable = false;
              if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
                debug("read: emitReadable", state.length, state.ended);
                if (state.length === 0 && state.ended)
                  endReadable(this);
                else
                  emitReadable(this);
                return null;
              }
              n = howMuchToRead(n, state);
              if (n === 0 && state.ended) {
                if (state.length === 0)
                  endReadable(this);
                return null;
              }
              var doRead = state.needReadable;
              debug("need readable", doRead);
              if (state.length === 0 || state.length - n < state.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
              }
              if (state.ended || state.reading) {
                doRead = false;
                debug("reading or ended", doRead);
              } else if (doRead) {
                debug("do read");
                state.reading = true;
                state.sync = true;
                if (state.length === 0)
                  state.needReadable = true;
                this._read(state.highWaterMark);
                state.sync = false;
                if (!state.reading)
                  n = howMuchToRead(nOrig, state);
              }
              var ret;
              if (n > 0)
                ret = fromList(n, state);
              else
                ret = null;
              if (ret === null) {
                state.needReadable = state.length <= state.highWaterMark;
                n = 0;
              } else {
                state.length -= n;
                state.awaitDrain = 0;
              }
              if (state.length === 0) {
                if (!state.ended)
                  state.needReadable = true;
                if (nOrig !== n && state.ended)
                  endReadable(this);
              }
              if (ret !== null)
                this.emit("data", ret);
              return ret;
            };
            function onEofChunk(stream, state) {
              debug("onEofChunk");
              if (state.ended)
                return;
              if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }
              state.ended = true;
              if (state.sync) {
                emitReadable(stream);
              } else {
                state.needReadable = false;
                if (!state.emittedReadable) {
                  state.emittedReadable = true;
                  emitReadable_(stream);
                }
              }
            }
            function emitReadable(stream) {
              var state = stream._readableState;
              debug("emitReadable", state.needReadable, state.emittedReadable);
              state.needReadable = false;
              if (!state.emittedReadable) {
                debug("emitReadable", state.flowing);
                state.emittedReadable = true;
                process.nextTick(emitReadable_, stream);
              }
            }
            function emitReadable_(stream) {
              var state = stream._readableState;
              debug("emitReadable_", state.destroyed, state.length, state.ended);
              if (!state.destroyed && (state.length || state.ended)) {
                stream.emit("readable");
                state.emittedReadable = false;
              }
              state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
              flow(stream);
            }
            function maybeReadMore(stream, state) {
              if (!state.readingMore) {
                state.readingMore = true;
                process.nextTick(maybeReadMore_, stream, state);
              }
            }
            function maybeReadMore_(stream, state) {
              while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
                var len = state.length;
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state.length)
                  break;
              }
              state.readingMore = false;
            }
            Readable.prototype._read = function(n) {
              errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
              var src2 = this;
              var state = this._readableState;
              switch (state.pipesCount) {
                case 0:
                  state.pipes = dest;
                  break;
                case 1:
                  state.pipes = [state.pipes, dest];
                  break;
                default:
                  state.pipes.push(dest);
                  break;
              }
              state.pipesCount += 1;
              debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
              var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
              var endFn = doEnd ? onend : unpipe;
              if (state.endEmitted)
                process.nextTick(endFn);
              else
                src2.once("end", endFn);
              dest.on("unpipe", onunpipe);
              function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");
                if (readable === src2) {
                  if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                  }
                }
              }
              function onend() {
                debug("onend");
                dest.end();
              }
              var ondrain = pipeOnDrain(src2);
              dest.on("drain", ondrain);
              var cleanedUp = false;
              function cleanup() {
                debug("cleanup");
                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                dest.removeListener("drain", ondrain);
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src2.removeListener("end", onend);
                src2.removeListener("end", unpipe);
                src2.removeListener("data", ondata);
                cleanedUp = true;
                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                  ondrain();
              }
              src2.on("data", ondata);
              function ondata(chunk) {
                debug("ondata");
                var ret = dest.write(chunk);
                debug("dest.write", ret);
                if (ret === false) {
                  if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                    debug("false write response, pause", state.awaitDrain);
                    state.awaitDrain++;
                  }
                  src2.pause();
                }
              }
              function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (EElistenerCount(dest, "error") === 0)
                  errorOrDestroy(dest, er);
              }
              prependListener(dest, "error", onerror);
              function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
              }
              dest.once("close", onclose);
              function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
              }
              dest.once("finish", onfinish);
              function unpipe() {
                debug("unpipe");
                src2.unpipe(dest);
              }
              dest.emit("pipe", src2);
              if (!state.flowing) {
                debug("pipe resume");
                src2.resume();
              }
              return dest;
            };
            function pipeOnDrain(src2) {
              return function pipeOnDrainFunctionResult() {
                var state = src2._readableState;
                debug("pipeOnDrain", state.awaitDrain);
                if (state.awaitDrain)
                  state.awaitDrain--;
                if (state.awaitDrain === 0 && EElistenerCount(src2, "data")) {
                  state.flowing = true;
                  flow(src2);
                }
              };
            }
            Readable.prototype.unpipe = function(dest) {
              var state = this._readableState;
              var unpipeInfo = {
                hasUnpiped: false
              };
              if (state.pipesCount === 0)
                return this;
              if (state.pipesCount === 1) {
                if (dest && dest !== state.pipes)
                  return this;
                if (!dest)
                  dest = state.pipes;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest)
                  dest.emit("unpipe", this, unpipeInfo);
                return this;
              }
              if (!dest) {
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                for (var i = 0; i < len; i++) {
                  dests[i].emit("unpipe", this, {
                    hasUnpiped: false
                  });
                }
                return this;
              }
              var index2 = indexOf(state.pipes, dest);
              if (index2 === -1)
                return this;
              state.pipes.splice(index2, 1);
              state.pipesCount -= 1;
              if (state.pipesCount === 1)
                state.pipes = state.pipes[0];
              dest.emit("unpipe", this, unpipeInfo);
              return this;
            };
            Readable.prototype.on = function(ev, fn) {
              var res = Stream.prototype.on.call(this, ev, fn);
              var state = this._readableState;
              if (ev === "data") {
                state.readableListening = this.listenerCount("readable") > 0;
                if (state.flowing !== false)
                  this.resume();
              } else if (ev === "readable") {
                if (!state.endEmitted && !state.readableListening) {
                  state.readableListening = state.needReadable = true;
                  state.flowing = false;
                  state.emittedReadable = false;
                  debug("on readable", state.length, state.reading);
                  if (state.length) {
                    emitReadable(this);
                  } else if (!state.reading) {
                    process.nextTick(nReadingNextTick, this);
                  }
                }
              }
              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            Readable.prototype.removeListener = function(ev, fn) {
              var res = Stream.prototype.removeListener.call(this, ev, fn);
              if (ev === "readable") {
                process.nextTick(updateReadableListening, this);
              }
              return res;
            };
            Readable.prototype.removeAllListeners = function(ev) {
              var res = Stream.prototype.removeAllListeners.apply(this, arguments);
              if (ev === "readable" || ev === void 0) {
                process.nextTick(updateReadableListening, this);
              }
              return res;
            };
            function updateReadableListening(self2) {
              var state = self2._readableState;
              state.readableListening = self2.listenerCount("readable") > 0;
              if (state.resumeScheduled && !state.paused) {
                state.flowing = true;
              } else if (self2.listenerCount("data") > 0) {
                self2.resume();
              }
            }
            function nReadingNextTick(self2) {
              debug("readable nexttick read 0");
              self2.read(0);
            }
            Readable.prototype.resume = function() {
              var state = this._readableState;
              if (!state.flowing) {
                debug("resume");
                state.flowing = !state.readableListening;
                resume(this, state);
              }
              state.paused = false;
              return this;
            };
            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                process.nextTick(resume_, stream, state);
              }
            }
            function resume_(stream, state) {
              debug("resume", state.reading);
              if (!state.reading) {
                stream.read(0);
              }
              state.resumeScheduled = false;
              stream.emit("resume");
              flow(stream);
              if (state.flowing && !state.reading)
                stream.read(0);
            }
            Readable.prototype.pause = function() {
              debug("call pause flowing=%j", this._readableState.flowing);
              if (this._readableState.flowing !== false) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
              }
              this._readableState.paused = true;
              return this;
            };
            function flow(stream) {
              var state = stream._readableState;
              debug("flow", state.flowing);
              while (state.flowing && stream.read() !== null) {
              }
            }
            Readable.prototype.wrap = function(stream) {
              var _this = this;
              var state = this._readableState;
              var paused = false;
              stream.on("end", function() {
                debug("wrapped end");
                if (state.decoder && !state.ended) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length)
                    _this.push(chunk);
                }
                _this.push(null);
              });
              stream.on("data", function(chunk) {
                debug("wrapped data");
                if (state.decoder)
                  chunk = state.decoder.write(chunk);
                if (state.objectMode && (chunk === null || chunk === void 0))
                  return;
                else if (!state.objectMode && (!chunk || !chunk.length))
                  return;
                var ret = _this.push(chunk);
                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              });
              for (var i in stream) {
                if (this[i] === void 0 && typeof stream[i] === "function") {
                  this[i] = function methodWrap(method) {
                    return function methodWrapReturnFunction() {
                      return stream[method].apply(stream, arguments);
                    };
                  }(i);
                }
              }
              for (var n = 0; n < kProxyEvents.length; n++) {
                stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
              }
              this._read = function(n2) {
                debug("wrapped _read", n2);
                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };
              return this;
            };
            if (typeof Symbol === "function") {
              Readable.prototype[Symbol.asyncIterator] = function() {
                if (createReadableStreamAsyncIterator === void 0) {
                  createReadableStreamAsyncIterator = require2("./internal/streams/async_iterator");
                }
                return createReadableStreamAsyncIterator(this);
              };
            }
            Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState.highWaterMark;
              }
            });
            Object.defineProperty(Readable.prototype, "readableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState && this._readableState.buffer;
              }
            });
            Object.defineProperty(Readable.prototype, "readableFlowing", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState.flowing;
              },
              set: function set(state) {
                if (this._readableState) {
                  this._readableState.flowing = state;
                }
              }
            });
            Readable._fromList = fromList;
            Object.defineProperty(Readable.prototype, "readableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._readableState.length;
              }
            });
            function fromList(n, state) {
              if (state.length === 0)
                return null;
              var ret;
              if (state.objectMode)
                ret = state.buffer.shift();
              else if (!n || n >= state.length) {
                if (state.decoder)
                  ret = state.buffer.join("");
                else if (state.buffer.length === 1)
                  ret = state.buffer.first();
                else
                  ret = state.buffer.concat(state.length);
                state.buffer.clear();
              } else {
                ret = state.buffer.consume(n, state.decoder);
              }
              return ret;
            }
            function endReadable(stream) {
              var state = stream._readableState;
              debug("endReadable", state.endEmitted);
              if (!state.endEmitted) {
                state.ended = true;
                process.nextTick(endReadableNT, state, stream);
              }
            }
            function endReadableNT(state, stream) {
              debug("endReadableNT", state.endEmitted, state.length);
              if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit("end");
                if (state.autoDestroy) {
                  var wState = stream._writableState;
                  if (!wState || wState.autoDestroy && wState.finished) {
                    stream.destroy();
                  }
                }
              }
            }
            if (typeof Symbol === "function") {
              Readable.from = function(iterable, opts) {
                if (from === void 0) {
                  from = require2("./internal/streams/from");
                }
                return from(Readable, iterable, opts);
              };
            }
            function indexOf(xs, x) {
              for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x)
                  return i;
              }
              return -1;
            }
          }).call(this);
        }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../errors": 24, "./_stream_duplex": 25, "./internal/streams/async_iterator": 30, "./internal/streams/buffer_list": 31, "./internal/streams/destroy": 32, "./internal/streams/from": 34, "./internal/streams/state": 36, "./internal/streams/stream": 37, "_process": 93, "buffer": 20, "events": 40, "inherits": 42, "string_decoder/": 127, "util": 17 }], 28: [function(require2, module2, exports2) {
        module2.exports = Transform;
        var _require$codes = require2("../errors").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
        var Duplex = require2("./_stream_duplex");
        require2("inherits")(Transform, Duplex);
        function afterTransform(er, data) {
          var ts = this._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (cb === null) {
            return this.emit("error", new ERR_MULTIPLE_CALLBACK());
          }
          ts.writechunk = null;
          ts.writecb = null;
          if (data != null)
            this.push(data);
          cb(er);
          var rs = this._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null
          };
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform;
            if (typeof options.flush === "function")
              this._flush = options.flush;
          }
          this.on("prefinish", prefinish);
        }
        function prefinish() {
          var _this = this;
          if (typeof this._flush === "function" && !this._readableState.destroyed) {
            this._flush(function(er, data) {
              done(_this, er, data);
            });
          } else {
            done(this, null, null);
          }
        }
        Transform.prototype.push = function(chunk, encoding2) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding2);
        };
        Transform.prototype._transform = function(chunk, encoding2, cb) {
          cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
        };
        Transform.prototype._write = function(chunk, encoding2, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding2;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n) {
          var ts = this._transformState;
          if (ts.writechunk !== null && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        Transform.prototype._destroy = function(err, cb) {
          Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2);
          });
        };
        function done(stream, er, data) {
          if (er)
            return stream.emit("error", er);
          if (data != null)
            stream.push(data);
          if (stream._writableState.length)
            throw new ERR_TRANSFORM_WITH_LENGTH_0();
          if (stream._transformState.transforming)
            throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
          return stream.push(null);
        }
      }, { "../errors": 24, "./_stream_duplex": 25, "inherits": 42 }], 29: [function(require2, module2, exports2) {
        (function(process, global2) {
          (function() {
            module2.exports = Writable;
            function CorkedRequest(state) {
              var _this = this;
              this.next = null;
              this.entry = null;
              this.finish = function() {
                onCorkedFinish(_this, state);
              };
            }
            var Duplex;
            Writable.WritableState = WritableState;
            var internalUtil = {
              deprecate: require2("util-deprecate")
            };
            var Stream = require2("./internal/streams/stream");
            var Buffer = require2("buffer").Buffer;
            var OurUint8Array = global2.Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk) {
              return Buffer.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var destroyImpl = require2("./internal/streams/destroy");
            var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            require2("inherits")(Writable, Stream);
            function nop() {
            }
            function WritableState(options, stream, isDuplex) {
              Duplex = Duplex || require2("./_stream_duplex");
              options = options || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.writableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
              this.finalCalled = false;
              this.needDrain = false;
              this.ending = false;
              this.ended = false;
              this.finished = false;
              this.destroyed = false;
              var noDecode = options.decodeStrings === false;
              this.decodeStrings = !noDecode;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.length = 0;
              this.writing = false;
              this.corked = 0;
              this.sync = true;
              this.bufferProcessing = false;
              this.onwrite = function(er) {
                onwrite(stream, er);
              };
              this.writecb = null;
              this.writelen = 0;
              this.bufferedRequest = null;
              this.lastBufferedRequest = null;
              this.pendingcb = 0;
              this.prefinished = false;
              this.errorEmitted = false;
              this.emitClose = options.emitClose !== false;
              this.autoDestroy = !!options.autoDestroy;
              this.bufferedRequestCount = 0;
              this.corkedRequestsFree = new CorkedRequest(this);
            }
            WritableState.prototype.getBuffer = function getBuffer() {
              var current = this.bufferedRequest;
              var out = [];
              while (current) {
                out.push(current);
                current = current.next;
              }
              return out;
            };
            (function() {
              try {
                Object.defineProperty(WritableState.prototype, "buffer", {
                  get: internalUtil.deprecate(function writableStateBufferGetter() {
                    return this.getBuffer();
                  }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                });
              } catch (_) {
              }
            })();
            var realHasInstance;
            if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
              realHasInstance = Function.prototype[Symbol.hasInstance];
              Object.defineProperty(Writable, Symbol.hasInstance, {
                value: function value(object) {
                  if (realHasInstance.call(this, object))
                    return true;
                  if (this !== Writable)
                    return false;
                  return object && object._writableState instanceof WritableState;
                }
              });
            } else {
              realHasInstance = function realHasInstance2(object) {
                return object instanceof this;
              };
            }
            function Writable(options) {
              Duplex = Duplex || require2("./_stream_duplex");
              var isDuplex = this instanceof Duplex;
              if (!isDuplex && !realHasInstance.call(Writable, this))
                return new Writable(options);
              this._writableState = new WritableState(options, this, isDuplex);
              this.writable = true;
              if (options) {
                if (typeof options.write === "function")
                  this._write = options.write;
                if (typeof options.writev === "function")
                  this._writev = options.writev;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
                if (typeof options.final === "function")
                  this._final = options.final;
              }
              Stream.call(this);
            }
            Writable.prototype.pipe = function() {
              errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
            };
            function writeAfterEnd(stream, cb) {
              var er = new ERR_STREAM_WRITE_AFTER_END();
              errorOrDestroy(stream, er);
              process.nextTick(cb, er);
            }
            function validChunk(stream, state, chunk, cb) {
              var er;
              if (chunk === null) {
                er = new ERR_STREAM_NULL_VALUES();
              } else if (typeof chunk !== "string" && !state.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
              }
              if (er) {
                errorOrDestroy(stream, er);
                process.nextTick(cb, er);
                return false;
              }
              return true;
            }
            Writable.prototype.write = function(chunk, encoding2, cb) {
              var state = this._writableState;
              var ret = false;
              var isBuf = !state.objectMode && _isUint8Array(chunk);
              if (isBuf && !Buffer.isBuffer(chunk)) {
                chunk = _uint8ArrayToBuffer(chunk);
              }
              if (typeof encoding2 === "function") {
                cb = encoding2;
                encoding2 = null;
              }
              if (isBuf)
                encoding2 = "buffer";
              else if (!encoding2)
                encoding2 = state.defaultEncoding;
              if (typeof cb !== "function")
                cb = nop;
              if (state.ending)
                writeAfterEnd(this, cb);
              else if (isBuf || validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, isBuf, chunk, encoding2, cb);
              }
              return ret;
            };
            Writable.prototype.cork = function() {
              this._writableState.corked++;
            };
            Writable.prototype.uncork = function() {
              var state = this._writableState;
              if (state.corked) {
                state.corked--;
                if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                  clearBuffer(this, state);
              }
            };
            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
              if (typeof encoding2 === "string")
                encoding2 = encoding2.toLowerCase();
              if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
                throw new ERR_UNKNOWN_ENCODING(encoding2);
              this._writableState.defaultEncoding = encoding2;
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            function decodeChunk(state, chunk, encoding2) {
              if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                chunk = Buffer.from(chunk, encoding2);
              }
              return chunk;
            }
            Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.highWaterMark;
              }
            });
            function writeOrBuffer(stream, state, isBuf, chunk, encoding2, cb) {
              if (!isBuf) {
                var newChunk = decodeChunk(state, chunk, encoding2);
                if (chunk !== newChunk) {
                  isBuf = true;
                  encoding2 = "buffer";
                  chunk = newChunk;
                }
              }
              var len = state.objectMode ? 1 : chunk.length;
              state.length += len;
              var ret = state.length < state.highWaterMark;
              if (!ret)
                state.needDrain = true;
              if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = {
                  chunk,
                  encoding: encoding2,
                  isBuf,
                  callback: cb,
                  next: null
                };
                if (last) {
                  last.next = state.lastBufferedRequest;
                } else {
                  state.bufferedRequest = state.lastBufferedRequest;
                }
                state.bufferedRequestCount += 1;
              } else {
                doWrite(stream, state, false, len, chunk, encoding2, cb);
              }
              return ret;
            }
            function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
              state.writelen = len;
              state.writecb = cb;
              state.writing = true;
              state.sync = true;
              if (state.destroyed)
                state.onwrite(new ERR_STREAM_DESTROYED("write"));
              else if (writev)
                stream._writev(chunk, state.onwrite);
              else
                stream._write(chunk, encoding2, state.onwrite);
              state.sync = false;
            }
            function onwriteError(stream, state, sync, er, cb) {
              --state.pendingcb;
              if (sync) {
                process.nextTick(cb, er);
                process.nextTick(finishMaybe, stream, state);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
              } else {
                cb(er);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
                finishMaybe(stream, state);
              }
            }
            function onwriteStateUpdate(state) {
              state.writing = false;
              state.writecb = null;
              state.length -= state.writelen;
              state.writelen = 0;
            }
            function onwrite(stream, er) {
              var state = stream._writableState;
              var sync = state.sync;
              var cb = state.writecb;
              if (typeof cb !== "function")
                throw new ERR_MULTIPLE_CALLBACK();
              onwriteStateUpdate(state);
              if (er)
                onwriteError(stream, state, sync, er, cb);
              else {
                var finished = needFinish(state) || stream.destroyed;
                if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                  clearBuffer(stream, state);
                }
                if (sync) {
                  process.nextTick(afterWrite, stream, state, finished, cb);
                } else {
                  afterWrite(stream, state, finished, cb);
                }
              }
            }
            function afterWrite(stream, state, finished, cb) {
              if (!finished)
                onwriteDrain(stream, state);
              state.pendingcb--;
              cb();
              finishMaybe(stream, state);
            }
            function onwriteDrain(stream, state) {
              if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit("drain");
              }
            }
            function clearBuffer(stream, state) {
              state.bufferProcessing = true;
              var entry = state.bufferedRequest;
              if (stream._writev && entry && entry.next) {
                var l = state.bufferedRequestCount;
                var buffer = new Array(l);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;
                while (entry) {
                  buffer[count] = entry;
                  if (!entry.isBuf)
                    allBuffers = false;
                  entry = entry.next;
                  count += 1;
                }
                buffer.allBuffers = allBuffers;
                doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                state.pendingcb++;
                state.lastBufferedRequest = null;
                if (holder.next) {
                  state.corkedRequestsFree = holder.next;
                  holder.next = null;
                } else {
                  state.corkedRequestsFree = new CorkedRequest(state);
                }
                state.bufferedRequestCount = 0;
              } else {
                while (entry) {
                  var chunk = entry.chunk;
                  var encoding2 = entry.encoding;
                  var cb = entry.callback;
                  var len = state.objectMode ? 1 : chunk.length;
                  doWrite(stream, state, false, len, chunk, encoding2, cb);
                  entry = entry.next;
                  state.bufferedRequestCount--;
                  if (state.writing) {
                    break;
                  }
                }
                if (entry === null)
                  state.lastBufferedRequest = null;
              }
              state.bufferedRequest = entry;
              state.bufferProcessing = false;
            }
            Writable.prototype._write = function(chunk, encoding2, cb) {
              cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function(chunk, encoding2, cb) {
              var state = this._writableState;
              if (typeof chunk === "function") {
                cb = chunk;
                chunk = null;
                encoding2 = null;
              } else if (typeof encoding2 === "function") {
                cb = encoding2;
                encoding2 = null;
              }
              if (chunk !== null && chunk !== void 0)
                this.write(chunk, encoding2);
              if (state.corked) {
                state.corked = 1;
                this.uncork();
              }
              if (!state.ending)
                endWritable(this, state, cb);
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                return this._writableState.length;
              }
            });
            function needFinish(state) {
              return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
            }
            function callFinal(stream, state) {
              stream._final(function(err) {
                state.pendingcb--;
                if (err) {
                  errorOrDestroy(stream, err);
                }
                state.prefinished = true;
                stream.emit("prefinish");
                finishMaybe(stream, state);
              });
            }
            function prefinish(stream, state) {
              if (!state.prefinished && !state.finalCalled) {
                if (typeof stream._final === "function" && !state.destroyed) {
                  state.pendingcb++;
                  state.finalCalled = true;
                  process.nextTick(callFinal, stream, state);
                } else {
                  state.prefinished = true;
                  stream.emit("prefinish");
                }
              }
            }
            function finishMaybe(stream, state) {
              var need = needFinish(state);
              if (need) {
                prefinish(stream, state);
                if (state.pendingcb === 0) {
                  state.finished = true;
                  stream.emit("finish");
                  if (state.autoDestroy) {
                    var rState = stream._readableState;
                    if (!rState || rState.autoDestroy && rState.endEmitted) {
                      stream.destroy();
                    }
                  }
                }
              }
              return need;
            }
            function endWritable(stream, state, cb) {
              state.ending = true;
              finishMaybe(stream, state);
              if (cb) {
                if (state.finished)
                  process.nextTick(cb);
                else
                  stream.once("finish", cb);
              }
              state.ended = true;
              stream.writable = false;
            }
            function onCorkedFinish(corkReq, state, err) {
              var entry = corkReq.entry;
              corkReq.entry = null;
              while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err);
                entry = entry.next;
              }
              state.corkedRequestsFree.next = corkReq;
            }
            Object.defineProperty(Writable.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get() {
                if (this._writableState === void 0) {
                  return false;
                }
                return this._writableState.destroyed;
              },
              set: function set(value) {
                if (!this._writableState) {
                  return;
                }
                this._writableState.destroyed = value;
              }
            });
            Writable.prototype.destroy = destroyImpl.destroy;
            Writable.prototype._undestroy = destroyImpl.undestroy;
            Writable.prototype._destroy = function(err, cb) {
              cb(err);
            };
          }).call(this);
        }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../errors": 24, "./_stream_duplex": 25, "./internal/streams/destroy": 32, "./internal/streams/state": 36, "./internal/streams/stream": 37, "_process": 93, "buffer": 20, "inherits": 42, "util-deprecate": 130 }], 30: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            var _Object$setPrototypeO;
            function _defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var finished = require2("./end-of-stream");
            var kLastResolve = Symbol("lastResolve");
            var kLastReject = Symbol("lastReject");
            var kError = Symbol("error");
            var kEnded = Symbol("ended");
            var kLastPromise = Symbol("lastPromise");
            var kHandlePromise = Symbol("handlePromise");
            var kStream = Symbol("stream");
            function createIterResult(value, done) {
              return {
                value,
                done
              };
            }
            function readAndResolve(iter) {
              var resolve = iter[kLastResolve];
              if (resolve !== null) {
                var data = iter[kStream].read();
                if (data !== null) {
                  iter[kLastPromise] = null;
                  iter[kLastResolve] = null;
                  iter[kLastReject] = null;
                  resolve(createIterResult(data, false));
                }
              }
            }
            function onReadable(iter) {
              process.nextTick(readAndResolve, iter);
            }
            function wrapForNext(lastPromise, iter) {
              return function(resolve, reject) {
                lastPromise.then(function() {
                  if (iter[kEnded]) {
                    resolve(createIterResult(void 0, true));
                    return;
                  }
                  iter[kHandlePromise](resolve, reject);
                }, reject);
              };
            }
            var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
            });
            var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
              get stream() {
                return this[kStream];
              },
              next: function next() {
                var _this = this;
                var error = this[kError];
                if (error !== null) {
                  return Promise.reject(error);
                }
                if (this[kEnded]) {
                  return Promise.resolve(createIterResult(void 0, true));
                }
                if (this[kStream].destroyed) {
                  return new Promise(function(resolve, reject) {
                    process.nextTick(function() {
                      if (_this[kError]) {
                        reject(_this[kError]);
                      } else {
                        resolve(createIterResult(void 0, true));
                      }
                    });
                  });
                }
                var lastPromise = this[kLastPromise];
                var promise;
                if (lastPromise) {
                  promise = new Promise(wrapForNext(lastPromise, this));
                } else {
                  var data = this[kStream].read();
                  if (data !== null) {
                    return Promise.resolve(createIterResult(data, false));
                  }
                  promise = new Promise(this[kHandlePromise]);
                }
                this[kLastPromise] = promise;
                return promise;
              }
            }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
              return this;
            }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
              var _this2 = this;
              return new Promise(function(resolve, reject) {
                _this2[kStream].destroy(null, function(err) {
                  if (err) {
                    reject(err);
                    return;
                  }
                  resolve(createIterResult(void 0, true));
                });
              });
            }), _Object$setPrototypeO), AsyncIteratorPrototype);
            var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
              var _Object$create;
              var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
                value: stream,
                writable: true
              }), _defineProperty(_Object$create, kLastResolve, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kLastReject, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kError, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kEnded, {
                value: stream._readableState.endEmitted,
                writable: true
              }), _defineProperty(_Object$create, kHandlePromise, {
                value: function value(resolve, reject) {
                  var data = iterator[kStream].read();
                  if (data) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    resolve(createIterResult(data, false));
                  } else {
                    iterator[kLastResolve] = resolve;
                    iterator[kLastReject] = reject;
                  }
                },
                writable: true
              }), _Object$create));
              iterator[kLastPromise] = null;
              finished(stream, function(err) {
                if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                  var reject = iterator[kLastReject];
                  if (reject !== null) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    reject(err);
                  }
                  iterator[kError] = err;
                  return;
                }
                var resolve = iterator[kLastResolve];
                if (resolve !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve(createIterResult(void 0, true));
                }
                iterator[kEnded] = true;
              });
              stream.on("readable", onReadable.bind(null, iterator));
              return iterator;
            };
            module2.exports = createReadableStreamAsyncIterator;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "./end-of-stream": 33, "_process": 93 }], 31: [function(require2, module2, exports2) {
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        var _require = require2("buffer"), Buffer = _require.Buffer;
        var _require2 = require2("util"), inspect = _require2.inspect;
        var custom = inspect && inspect.custom || "inspect";
        function copyBuffer(src2, target, offset) {
          Buffer.prototype.copy.call(src2, target, offset);
        }
        module2.exports = /* @__PURE__ */ function() {
          function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
          }
          _createClass(BufferList, [{
            key: "push",
            value: function push(v) {
              var entry = {
                data: v,
                next: null
              };
              if (this.length > 0)
                this.tail.next = entry;
              else
                this.head = entry;
              this.tail = entry;
              ++this.length;
            }
          }, {
            key: "unshift",
            value: function unshift(v) {
              var entry = {
                data: v,
                next: this.head
              };
              if (this.length === 0)
                this.tail = entry;
              this.head = entry;
              ++this.length;
            }
          }, {
            key: "shift",
            value: function shift() {
              if (this.length === 0)
                return;
              var ret = this.head.data;
              if (this.length === 1)
                this.head = this.tail = null;
              else
                this.head = this.head.next;
              --this.length;
              return ret;
            }
          }, {
            key: "clear",
            value: function clear() {
              this.head = this.tail = null;
              this.length = 0;
            }
          }, {
            key: "join",
            value: function join(s) {
              if (this.length === 0)
                return "";
              var p = this.head;
              var ret = "" + p.data;
              while (p = p.next) {
                ret += s + p.data;
              }
              return ret;
            }
          }, {
            key: "concat",
            value: function concat(n) {
              if (this.length === 0)
                return Buffer.alloc(0);
              var ret = Buffer.allocUnsafe(n >>> 0);
              var p = this.head;
              var i = 0;
              while (p) {
                copyBuffer(p.data, ret, i);
                i += p.data.length;
                p = p.next;
              }
              return ret;
            }
            // Consumes a specified amount of bytes or characters from the buffered data.
          }, {
            key: "consume",
            value: function consume(n, hasStrings) {
              var ret;
              if (n < this.head.data.length) {
                ret = this.head.data.slice(0, n);
                this.head.data = this.head.data.slice(n);
              } else if (n === this.head.data.length) {
                ret = this.shift();
              } else {
                ret = hasStrings ? this._getString(n) : this._getBuffer(n);
              }
              return ret;
            }
          }, {
            key: "first",
            value: function first() {
              return this.head.data;
            }
            // Consumes a specified amount of characters from the buffered data.
          }, {
            key: "_getString",
            value: function _getString(n) {
              var p = this.head;
              var c = 1;
              var ret = p.data;
              n -= ret.length;
              while (p = p.next) {
                var str = p.data;
                var nb = n > str.length ? str.length : n;
                if (nb === str.length)
                  ret += str;
                else
                  ret += str.slice(0, n);
                n -= nb;
                if (n === 0) {
                  if (nb === str.length) {
                    ++c;
                    if (p.next)
                      this.head = p.next;
                    else
                      this.head = this.tail = null;
                  } else {
                    this.head = p;
                    p.data = str.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              this.length -= c;
              return ret;
            }
            // Consumes a specified amount of bytes from the buffered data.
          }, {
            key: "_getBuffer",
            value: function _getBuffer(n) {
              var ret = Buffer.allocUnsafe(n);
              var p = this.head;
              var c = 1;
              p.data.copy(ret);
              n -= p.data.length;
              while (p = p.next) {
                var buf = p.data;
                var nb = n > buf.length ? buf.length : n;
                buf.copy(ret, ret.length - n, 0, nb);
                n -= nb;
                if (n === 0) {
                  if (nb === buf.length) {
                    ++c;
                    if (p.next)
                      this.head = p.next;
                    else
                      this.head = this.tail = null;
                  } else {
                    this.head = p;
                    p.data = buf.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              this.length -= c;
              return ret;
            }
            // Make sure the linked list only shows the minimal necessary information.
          }, {
            key: custom,
            value: function value(_, options) {
              return inspect(this, _objectSpread({}, options, {
                // Only inspect one level.
                depth: 0,
                // It should not recurse.
                customInspect: false
              }));
            }
          }]);
          return BufferList;
        }();
      }, { "buffer": 20, "util": 17 }], 32: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            function destroy(err, cb) {
              var _this = this;
              var readableDestroyed = this._readableState && this._readableState.destroyed;
              var writableDestroyed = this._writableState && this._writableState.destroyed;
              if (readableDestroyed || writableDestroyed) {
                if (cb) {
                  cb(err);
                } else if (err) {
                  if (!this._writableState) {
                    process.nextTick(emitErrorNT, this, err);
                  } else if (!this._writableState.errorEmitted) {
                    this._writableState.errorEmitted = true;
                    process.nextTick(emitErrorNT, this, err);
                  }
                }
                return this;
              }
              if (this._readableState) {
                this._readableState.destroyed = true;
              }
              if (this._writableState) {
                this._writableState.destroyed = true;
              }
              this._destroy(err || null, function(err2) {
                if (!cb && err2) {
                  if (!_this._writableState) {
                    process.nextTick(emitErrorAndCloseNT, _this, err2);
                  } else if (!_this._writableState.errorEmitted) {
                    _this._writableState.errorEmitted = true;
                    process.nextTick(emitErrorAndCloseNT, _this, err2);
                  } else {
                    process.nextTick(emitCloseNT, _this);
                  }
                } else if (cb) {
                  process.nextTick(emitCloseNT, _this);
                  cb(err2);
                } else {
                  process.nextTick(emitCloseNT, _this);
                }
              });
              return this;
            }
            function emitErrorAndCloseNT(self2, err) {
              emitErrorNT(self2, err);
              emitCloseNT(self2);
            }
            function emitCloseNT(self2) {
              if (self2._writableState && !self2._writableState.emitClose)
                return;
              if (self2._readableState && !self2._readableState.emitClose)
                return;
              self2.emit("close");
            }
            function undestroy() {
              if (this._readableState) {
                this._readableState.destroyed = false;
                this._readableState.reading = false;
                this._readableState.ended = false;
                this._readableState.endEmitted = false;
              }
              if (this._writableState) {
                this._writableState.destroyed = false;
                this._writableState.ended = false;
                this._writableState.ending = false;
                this._writableState.finalCalled = false;
                this._writableState.prefinished = false;
                this._writableState.finished = false;
                this._writableState.errorEmitted = false;
              }
            }
            function emitErrorNT(self2, err) {
              self2.emit("error", err);
            }
            function errorOrDestroy(stream, err) {
              var rState = stream._readableState;
              var wState = stream._writableState;
              if (rState && rState.autoDestroy || wState && wState.autoDestroy)
                stream.destroy(err);
              else
                stream.emit("error", err);
            }
            module2.exports = {
              destroy,
              undestroy,
              errorOrDestroy
            };
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 93 }], 33: [function(require2, module2, exports2) {
        var ERR_STREAM_PREMATURE_CLOSE = require2("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function once(callback) {
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            callback.apply(this, args);
          };
        }
        function noop() {
        }
        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }
        function eos(stream, opts, callback) {
          if (typeof opts === "function")
            return eos(stream, null, opts);
          if (!opts)
            opts = {};
          callback = once(callback || noop);
          var readable = opts.readable || opts.readable !== false && stream.readable;
          var writable = opts.writable || opts.writable !== false && stream.writable;
          var onlegacyfinish = function onlegacyfinish2() {
            if (!stream.writable)
              onfinish();
          };
          var writableEnded = stream._writableState && stream._writableState.finished;
          var onfinish = function onfinish2() {
            writable = false;
            writableEnded = true;
            if (!readable)
              callback.call(stream);
          };
          var readableEnded = stream._readableState && stream._readableState.endEmitted;
          var onend = function onend2() {
            readable = false;
            readableEnded = true;
            if (!writable)
              callback.call(stream);
          };
          var onerror = function onerror2(err) {
            callback.call(stream, err);
          };
          var onclose = function onclose2() {
            var err;
            if (readable && !readableEnded) {
              if (!stream._readableState || !stream._readableState.ended)
                err = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err);
            }
            if (writable && !writableEnded) {
              if (!stream._writableState || !stream._writableState.ended)
                err = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err);
            }
          };
          var onrequest = function onrequest2() {
            stream.req.on("finish", onfinish);
          };
          if (isRequest(stream)) {
            stream.on("complete", onfinish);
            stream.on("abort", onclose);
            if (stream.req)
              onrequest();
            else
              stream.on("request", onrequest);
          } else if (writable && !stream._writableState) {
            stream.on("end", onlegacyfinish);
            stream.on("close", onlegacyfinish);
          }
          stream.on("end", onend);
          stream.on("finish", onfinish);
          if (opts.error !== false)
            stream.on("error", onerror);
          stream.on("close", onclose);
          return function() {
            stream.removeListener("complete", onfinish);
            stream.removeListener("abort", onclose);
            stream.removeListener("request", onrequest);
            if (stream.req)
              stream.req.removeListener("finish", onfinish);
            stream.removeListener("end", onlegacyfinish);
            stream.removeListener("close", onlegacyfinish);
            stream.removeListener("finish", onfinish);
            stream.removeListener("end", onend);
            stream.removeListener("error", onerror);
            stream.removeListener("close", onclose);
          };
        }
        module2.exports = eos;
      }, { "../../../errors": 24 }], 34: [function(require2, module2, exports2) {
        module2.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 35: [function(require2, module2, exports2) {
        var eos;
        function once(callback) {
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            callback.apply(void 0, arguments);
          };
        }
        var _require$codes = require2("../../../errors").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
        function noop(err) {
          if (err)
            throw err;
        }
        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }
        function destroyer(stream, reading, writing, callback) {
          callback = once(callback);
          var closed = false;
          stream.on("close", function() {
            closed = true;
          });
          if (eos === void 0)
            eos = require2("./end-of-stream");
          eos(stream, {
            readable: reading,
            writable: writing
          }, function(err) {
            if (err)
              return callback(err);
            closed = true;
            callback();
          });
          var destroyed = false;
          return function(err) {
            if (closed)
              return;
            if (destroyed)
              return;
            destroyed = true;
            if (isRequest(stream))
              return stream.abort();
            if (typeof stream.destroy === "function")
              return stream.destroy();
            callback(err || new ERR_STREAM_DESTROYED("pipe"));
          };
        }
        function call(fn) {
          fn();
        }
        function pipe(from, to) {
          return from.pipe(to);
        }
        function popCallback(streams) {
          if (!streams.length)
            return noop;
          if (typeof streams[streams.length - 1] !== "function")
            return noop;
          return streams.pop();
        }
        function pipeline() {
          for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
            streams[_key] = arguments[_key];
          }
          var callback = popCallback(streams);
          if (Array.isArray(streams[0]))
            streams = streams[0];
          if (streams.length < 2) {
            throw new ERR_MISSING_ARGS("streams");
          }
          var error;
          var destroys = streams.map(function(stream, i) {
            var reading = i < streams.length - 1;
            var writing = i > 0;
            return destroyer(stream, reading, writing, function(err) {
              if (!error)
                error = err;
              if (err)
                destroys.forEach(call);
              if (reading)
                return;
              destroys.forEach(call);
              callback(error);
            });
          });
          return streams.reduce(pipe);
        }
        module2.exports = pipeline;
      }, { "../../../errors": 24, "./end-of-stream": 33 }], 36: [function(require2, module2, exports2) {
        var ERR_INVALID_OPT_VALUE = require2("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        function highWaterMarkFrom(options, isDuplex, duplexKey) {
          return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
        }
        function getHighWaterMark(state, options, duplexKey, isDuplex) {
          var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
          if (hwm != null) {
            if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
              var name2 = isDuplex ? duplexKey : "highWaterMark";
              throw new ERR_INVALID_OPT_VALUE(name2, hwm);
            }
            return Math.floor(hwm);
          }
          return state.objectMode ? 16 : 16 * 1024;
        }
        module2.exports = {
          getHighWaterMark
        };
      }, { "../../../errors": 24 }], 37: [function(require2, module2, exports2) {
        module2.exports = require2("events").EventEmitter;
      }, { "events": 40 }], 38: [function(require2, module2, exports2) {
        exports2 = module2.exports = require2("./lib/_stream_readable.js");
        exports2.Stream = exports2;
        exports2.Readable = exports2;
        exports2.Writable = require2("./lib/_stream_writable.js");
        exports2.Duplex = require2("./lib/_stream_duplex.js");
        exports2.Transform = require2("./lib/_stream_transform.js");
        exports2.PassThrough = require2("./lib/_stream_passthrough.js");
        exports2.finished = require2("./lib/internal/streams/end-of-stream.js");
        exports2.pipeline = require2("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 25, "./lib/_stream_passthrough.js": 26, "./lib/_stream_readable.js": 27, "./lib/_stream_transform.js": 28, "./lib/_stream_writable.js": 29, "./lib/internal/streams/end-of-stream.js": 33, "./lib/internal/streams/pipeline.js": 35 }], 39: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            var once = require2("once");
            var noop = function() {
            };
            var isRequest = function(stream) {
              return stream.setHeader && typeof stream.abort === "function";
            };
            var isChildProcess = function(stream) {
              return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
            };
            var eos = function(stream, opts, callback) {
              if (typeof opts === "function")
                return eos(stream, null, opts);
              if (!opts)
                opts = {};
              callback = once(callback || noop);
              var ws = stream._writableState;
              var rs = stream._readableState;
              var readable = opts.readable || opts.readable !== false && stream.readable;
              var writable = opts.writable || opts.writable !== false && stream.writable;
              var cancelled = false;
              var onlegacyfinish = function() {
                if (!stream.writable)
                  onfinish();
              };
              var onfinish = function() {
                writable = false;
                if (!readable)
                  callback.call(stream);
              };
              var onend = function() {
                readable = false;
                if (!writable)
                  callback.call(stream);
              };
              var onexit = function(exitCode) {
                callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
              };
              var onerror = function(err) {
                callback.call(stream, err);
              };
              var onclose = function() {
                process.nextTick(onclosenexttick);
              };
              var onclosenexttick = function() {
                if (cancelled)
                  return;
                if (readable && !(rs && (rs.ended && !rs.destroyed)))
                  return callback.call(stream, new Error("premature close"));
                if (writable && !(ws && (ws.ended && !ws.destroyed)))
                  return callback.call(stream, new Error("premature close"));
              };
              var onrequest = function() {
                stream.req.on("finish", onfinish);
              };
              if (isRequest(stream)) {
                stream.on("complete", onfinish);
                stream.on("abort", onclose);
                if (stream.req)
                  onrequest();
                else
                  stream.on("request", onrequest);
              } else if (writable && !ws) {
                stream.on("end", onlegacyfinish);
                stream.on("close", onlegacyfinish);
              }
              if (isChildProcess(stream))
                stream.on("exit", onexit);
              stream.on("end", onend);
              stream.on("finish", onfinish);
              if (opts.error !== false)
                stream.on("error", onerror);
              stream.on("close", onclose);
              return function() {
                cancelled = true;
                stream.removeListener("complete", onfinish);
                stream.removeListener("abort", onclose);
                stream.removeListener("request", onrequest);
                if (stream.req)
                  stream.req.removeListener("finish", onfinish);
                stream.removeListener("end", onlegacyfinish);
                stream.removeListener("close", onlegacyfinish);
                stream.removeListener("finish", onfinish);
                stream.removeListener("exit", onexit);
                stream.removeListener("end", onend);
                stream.removeListener("error", onerror);
                stream.removeListener("close", onclose);
              };
            };
            module2.exports = eos;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 93, "once": 91 }], 40: [function(require2, module2, exports2) {
        var R = typeof Reflect === "object" ? Reflect : null;
        var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
          return Function.prototype.apply.call(target, receiver, args);
        };
        var ReflectOwnKeys;
        if (R && typeof R.ownKeys === "function") {
          ReflectOwnKeys = R.ownKeys;
        } else if (Object.getOwnPropertySymbols) {
          ReflectOwnKeys = function ReflectOwnKeys2(target) {
            return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
          };
        } else {
          ReflectOwnKeys = function ReflectOwnKeys2(target) {
            return Object.getOwnPropertyNames(target);
          };
        }
        function ProcessEmitWarning(warning) {
          if (console && console.warn)
            console.warn(warning);
        }
        var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
          return value !== value;
        };
        function EventEmitter() {
          EventEmitter.init.call(this);
        }
        module2.exports = EventEmitter;
        module2.exports.once = once;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = void 0;
        EventEmitter.prototype._eventsCount = 0;
        EventEmitter.prototype._maxListeners = void 0;
        var defaultMaxListeners = 10;
        function checkListener(listener) {
          if (typeof listener !== "function") {
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
          }
        }
        Object.defineProperty(EventEmitter, "defaultMaxListeners", {
          enumerable: true,
          get: function() {
            return defaultMaxListeners;
          },
          set: function(arg) {
            if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
              throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
            }
            defaultMaxListeners = arg;
          }
        });
        EventEmitter.init = function() {
          if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          }
          this._maxListeners = this._maxListeners || void 0;
        };
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
          }
          this._maxListeners = n;
          return this;
        };
        function _getMaxListeners(that) {
          if (that._maxListeners === void 0)
            return EventEmitter.defaultMaxListeners;
          return that._maxListeners;
        }
        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return _getMaxListeners(this);
        };
        EventEmitter.prototype.emit = function emit(type) {
          var args = [];
          for (var i = 1; i < arguments.length; i++)
            args.push(arguments[i]);
          var doError = type === "error";
          var events = this._events;
          if (events !== void 0)
            doError = doError && events.error === void 0;
          else if (!doError)
            return false;
          if (doError) {
            var er;
            if (args.length > 0)
              er = args[0];
            if (er instanceof Error) {
              throw er;
            }
            var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
            err.context = er;
            throw err;
          }
          var handler = events[type];
          if (handler === void 0)
            return false;
          if (typeof handler === "function") {
            ReflectApply(handler, this, args);
          } else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              ReflectApply(listeners[i], this, args);
          }
          return true;
        };
        function _addListener(target, type, listener, prepend) {
          var m;
          var events;
          var existing;
          checkListener(listener);
          events = target._events;
          if (events === void 0) {
            events = target._events = /* @__PURE__ */ Object.create(null);
            target._eventsCount = 0;
          } else {
            if (events.newListener !== void 0) {
              target.emit(
                "newListener",
                type,
                listener.listener ? listener.listener : listener
              );
              events = target._events;
            }
            existing = events[type];
          }
          if (existing === void 0) {
            existing = events[type] = listener;
            ++target._eventsCount;
          } else {
            if (typeof existing === "function") {
              existing = events[type] = prepend ? [listener, existing] : [existing, listener];
            } else if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
            m = _getMaxListeners(target);
            if (m > 0 && existing.length > m && !existing.warned) {
              existing.warned = true;
              var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type;
              w.count = existing.length;
              ProcessEmitWarning(w);
            }
          }
          return target;
        }
        EventEmitter.prototype.addListener = function addListener(type, listener) {
          return _addListener(this, type, listener, false);
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.prependListener = function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };
        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            if (arguments.length === 0)
              return this.listener.call(this.target);
            return this.listener.apply(this.target, arguments);
          }
        }
        function _onceWrap(target, type, listener) {
          var state = { fired: false, wrapFn: void 0, target, type, listener };
          var wrapped = onceWrapper.bind(state);
          wrapped.listener = listener;
          state.wrapFn = wrapped;
          return wrapped;
        }
        EventEmitter.prototype.once = function once2(type, listener) {
          checkListener(listener);
          this.on(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
          checkListener(listener);
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.removeListener = function removeListener(type, listener) {
          var list, events, position, i, originalListener;
          checkListener(listener);
          events = this._events;
          if (events === void 0)
            return this;
          list = events[type];
          if (list === void 0)
            return this;
          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else {
              delete events[type];
              if (events.removeListener)
                this.emit("removeListener", type, list.listener || listener);
            }
          } else if (typeof list !== "function") {
            position = -1;
            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }
            if (position < 0)
              return this;
            if (position === 0)
              list.shift();
            else {
              spliceOne(list, position);
            }
            if (list.length === 1)
              events[type] = list[0];
            if (events.removeListener !== void 0)
              this.emit("removeListener", type, originalListener || listener);
          }
          return this;
        };
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
          var listeners, events, i;
          events = this._events;
          if (events === void 0)
            return this;
          if (events.removeListener === void 0) {
            if (arguments.length === 0) {
              this._events = /* @__PURE__ */ Object.create(null);
              this._eventsCount = 0;
            } else if (events[type] !== void 0) {
              if (--this._eventsCount === 0)
                this._events = /* @__PURE__ */ Object.create(null);
              else
                delete events[type];
            }
            return this;
          }
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === "removeListener")
                continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
            return this;
          }
          listeners = events[type];
          if (typeof listeners === "function") {
            this.removeListener(type, listeners);
          } else if (listeners !== void 0) {
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }
          return this;
        };
        function _listeners(target, type, unwrap) {
          var events = target._events;
          if (events === void 0)
            return [];
          var evlistener = events[type];
          if (evlistener === void 0)
            return [];
          if (typeof evlistener === "function")
            return unwrap ? [evlistener.listener || evlistener] : [evlistener];
          return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }
        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true);
        };
        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false);
        };
        EventEmitter.listenerCount = function(emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type);
          } else {
            return listenerCount.call(emitter, type);
          }
        };
        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
          var events = this._events;
          if (events !== void 0) {
            var evlistener = events[type];
            if (typeof evlistener === "function") {
              return 1;
            } else if (evlistener !== void 0) {
              return evlistener.length;
            }
          }
          return 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
        };
        function arrayClone(arr, n) {
          var copy = new Array(n);
          for (var i = 0; i < n; ++i)
            copy[i] = arr[i];
          return copy;
        }
        function spliceOne(list, index2) {
          for (; index2 + 1 < list.length; index2++)
            list[index2] = list[index2 + 1];
          list.pop();
        }
        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i];
          }
          return ret;
        }
        function once(emitter, name2) {
          return new Promise(function(resolve, reject) {
            function errorListener(err) {
              emitter.removeListener(name2, resolver);
              reject(err);
            }
            function resolver() {
              if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
              }
              resolve([].slice.call(arguments));
            }
            eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
            if (name2 !== "error") {
              addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
            }
          });
        }
        function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
          if (typeof emitter.on === "function") {
            eventTargetAgnosticAddListener(emitter, "error", handler, flags);
          }
        }
        function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
          if (typeof emitter.on === "function") {
            if (flags.once) {
              emitter.once(name2, listener);
            } else {
              emitter.on(name2, listener);
            }
          } else if (typeof emitter.addEventListener === "function") {
            emitter.addEventListener(name2, function wrapListener(arg) {
              if (flags.once) {
                emitter.removeEventListener(name2, wrapListener);
              }
              listener(arg);
            });
          } else {
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
          }
        }
      }, {}], 41: [function(require2, module2, exports2) {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
      }, {}], 42: [function(require2, module2, exports2) {
        if (typeof Object.create === "function") {
          module2.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
            }
          };
        } else {
          module2.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {
              };
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            }
          };
        }
      }, {}], 43: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.ContainerIterator = exports2.Container = exports2.Base = void 0;
        class ContainerIterator {
          constructor(t = 0) {
            this.iteratorType = t;
          }
          equals(t) {
            return this.o === t.o;
          }
        }
        exports2.ContainerIterator = ContainerIterator;
        class Base {
          constructor() {
            this.i = 0;
          }
          get length() {
            return this.i;
          }
          size() {
            return this.i;
          }
          empty() {
            return this.i === 0;
          }
        }
        exports2.Base = Base;
        class Container extends Base {
        }
        exports2.Container = Container;
      }, {}], 44: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.HashContainerIterator = exports2.HashContainer = void 0;
        var _ContainerBase = require2("../../ContainerBase");
        var _checkObject = _interopRequireDefault(require2("../../../utils/checkObject"));
        var _throwError = require2("../../../utils/throwError");
        function _interopRequireDefault(t) {
          return t && t.t ? t : {
            default: t
          };
        }
        class HashContainerIterator extends _ContainerBase.ContainerIterator {
          constructor(t, e, i) {
            super(i);
            this.o = t;
            this.h = e;
            if (this.iteratorType === 0) {
              this.pre = function() {
                if (this.o.L === this.h) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L;
                return this;
              };
              this.next = function() {
                if (this.o === this.h) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B;
                return this;
              };
            } else {
              this.pre = function() {
                if (this.o.B === this.h) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B;
                return this;
              };
              this.next = function() {
                if (this.o === this.h) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L;
                return this;
              };
            }
          }
        }
        exports2.HashContainerIterator = HashContainerIterator;
        class HashContainer extends _ContainerBase.Container {
          constructor() {
            super();
            this.H = [];
            this.g = {};
            this.HASH_TAG = Symbol("@@HASH_TAG");
            Object.setPrototypeOf(this.g, null);
            this.h = {};
            this.h.L = this.h.B = this.p = this._ = this.h;
          }
          V(t) {
            const { L: e, B: i } = t;
            e.B = i;
            i.L = e;
            if (t === this.p) {
              this.p = i;
            }
            if (t === this._) {
              this._ = e;
            }
            this.i -= 1;
          }
          M(t, e, i) {
            if (i === void 0)
              i = (0, _checkObject.default)(t);
            let s;
            if (i) {
              const i2 = t[this.HASH_TAG];
              if (i2 !== void 0) {
                this.H[i2].l = e;
                return this.i;
              }
              Object.defineProperty(t, this.HASH_TAG, {
                value: this.H.length,
                configurable: true
              });
              s = {
                u: t,
                l: e,
                L: this._,
                B: this.h
              };
              this.H.push(s);
            } else {
              const i2 = this.g[t];
              if (i2) {
                i2.l = e;
                return this.i;
              }
              s = {
                u: t,
                l: e,
                L: this._,
                B: this.h
              };
              this.g[t] = s;
            }
            if (this.i === 0) {
              this.p = s;
              this.h.B = s;
            } else {
              this._.B = s;
            }
            this._ = s;
            this.h.L = s;
            return ++this.i;
          }
          I(t, e) {
            if (e === void 0)
              e = (0, _checkObject.default)(t);
            if (e) {
              const e2 = t[this.HASH_TAG];
              if (e2 === void 0)
                return this.h;
              return this.H[e2];
            } else {
              return this.g[t] || this.h;
            }
          }
          clear() {
            const t = this.HASH_TAG;
            this.H.forEach(function(e) {
              delete e.u[t];
            });
            this.H = [];
            this.g = {};
            Object.setPrototypeOf(this.g, null);
            this.i = 0;
            this.p = this._ = this.h.L = this.h.B = this.h;
          }
          eraseElementByKey(t, e) {
            let i;
            if (e === void 0)
              e = (0, _checkObject.default)(t);
            if (e) {
              const e2 = t[this.HASH_TAG];
              if (e2 === void 0)
                return false;
              delete t[this.HASH_TAG];
              i = this.H[e2];
              delete this.H[e2];
            } else {
              i = this.g[t];
              if (i === void 0)
                return false;
              delete this.g[t];
            }
            this.V(i);
            return true;
          }
          eraseElementByIterator(t) {
            const e = t.o;
            if (e === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.V(e);
            return t.next();
          }
          eraseElementByPos(t) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            let e = this.p;
            while (t--) {
              e = e.B;
            }
            this.V(e);
            return this.i;
          }
        }
        exports2.HashContainer = HashContainer;
      }, { "../../../utils/checkObject": 61, "../../../utils/throwError": 62, "../../ContainerBase": 43 }], 45: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _Base = require2("./Base");
        var _checkObject = _interopRequireDefault(require2("../../utils/checkObject"));
        var _throwError = require2("../../utils/throwError");
        function _interopRequireDefault(t) {
          return t && t.t ? t : {
            default: t
          };
        }
        class HashMapIterator extends _Base.HashContainerIterator {
          constructor(t, e, r, s) {
            super(t, e, s);
            this.container = r;
          }
          get pointer() {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            const t = this;
            return new Proxy([], {
              get(e, r) {
                if (r === "0")
                  return t.o.u;
                else if (r === "1")
                  return t.o.l;
              },
              set(e, r, s) {
                if (r !== "1") {
                  throw new TypeError("props must be 1");
                }
                t.o.l = s;
                return true;
              }
            });
          }
          copy() {
            return new HashMapIterator(this.o, this.h, this.container, this.iteratorType);
          }
        }
        class HashMap extends _Base.HashContainer {
          constructor(t = []) {
            super();
            const e = this;
            t.forEach(function(t2) {
              e.setElement(t2[0], t2[1]);
            });
          }
          begin() {
            return new HashMapIterator(this.p, this.h, this);
          }
          end() {
            return new HashMapIterator(this.h, this.h, this);
          }
          rBegin() {
            return new HashMapIterator(this._, this.h, this, 1);
          }
          rEnd() {
            return new HashMapIterator(this.h, this.h, this, 1);
          }
          front() {
            if (this.i === 0)
              return;
            return [this.p.u, this.p.l];
          }
          back() {
            if (this.i === 0)
              return;
            return [this._.u, this._.l];
          }
          setElement(t, e, r) {
            return this.M(t, e, r);
          }
          getElementByKey(t, e) {
            if (e === void 0)
              e = (0, _checkObject.default)(t);
            if (e) {
              const e2 = t[this.HASH_TAG];
              return e2 !== void 0 ? this.H[e2].l : void 0;
            }
            const r = this.g[t];
            return r ? r.l : void 0;
          }
          getElementByPos(t) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            let e = this.p;
            while (t--) {
              e = e.B;
            }
            return [e.u, e.l];
          }
          find(t, e) {
            const r = this.I(t, e);
            return new HashMapIterator(r, this.h, this);
          }
          forEach(t) {
            let e = 0;
            let r = this.p;
            while (r !== this.h) {
              t([r.u, r.l], e++, this);
              r = r.B;
            }
          }
          [Symbol.iterator]() {
            return function* () {
              let t = this.p;
              while (t !== this.h) {
                yield [t.u, t.l];
                t = t.B;
              }
            }.bind(this)();
          }
        }
        var _default = HashMap;
        exports2.default = _default;
      }, { "../../utils/checkObject": 61, "../../utils/throwError": 62, "./Base": 44 }], 46: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _Base = require2("./Base");
        var _throwError = require2("../../utils/throwError");
        class HashSetIterator extends _Base.HashContainerIterator {
          constructor(t, e, r, s) {
            super(t, e, s);
            this.container = r;
          }
          get pointer() {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            return this.o.u;
          }
          copy() {
            return new HashSetIterator(this.o, this.h, this.container, this.iteratorType);
          }
        }
        class HashSet extends _Base.HashContainer {
          constructor(t = []) {
            super();
            const e = this;
            t.forEach(function(t2) {
              e.insert(t2);
            });
          }
          begin() {
            return new HashSetIterator(this.p, this.h, this);
          }
          end() {
            return new HashSetIterator(this.h, this.h, this);
          }
          rBegin() {
            return new HashSetIterator(this._, this.h, this, 1);
          }
          rEnd() {
            return new HashSetIterator(this.h, this.h, this, 1);
          }
          front() {
            return this.p.u;
          }
          back() {
            return this._.u;
          }
          insert(t, e) {
            return this.M(t, void 0, e);
          }
          getElementByPos(t) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            let e = this.p;
            while (t--) {
              e = e.B;
            }
            return e.u;
          }
          find(t, e) {
            const r = this.I(t, e);
            return new HashSetIterator(r, this.h, this);
          }
          forEach(t) {
            let e = 0;
            let r = this.p;
            while (r !== this.h) {
              t(r.u, e++, this);
              r = r.B;
            }
          }
          [Symbol.iterator]() {
            return function* () {
              let t = this.p;
              while (t !== this.h) {
                yield t.u;
                t = t.B;
              }
            }.bind(this)();
          }
        }
        var _default = HashSet;
        exports2.default = _default;
      }, { "../../utils/throwError": 62, "./Base": 44 }], 47: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _ContainerBase = require2("../ContainerBase");
        class PriorityQueue extends _ContainerBase.Base {
          constructor(t = [], s = function(t2, s2) {
            if (t2 > s2)
              return -1;
            if (t2 < s2)
              return 1;
            return 0;
          }, i = true) {
            super();
            this.v = s;
            if (Array.isArray(t)) {
              this.C = i ? [...t] : t;
            } else {
              this.C = [];
              const s2 = this;
              t.forEach(function(t2) {
                s2.C.push(t2);
              });
            }
            this.i = this.C.length;
            const e = this.i >> 1;
            for (let t2 = this.i - 1 >> 1; t2 >= 0; --t2) {
              this.k(t2, e);
            }
          }
          m(t) {
            const s = this.C[t];
            while (t > 0) {
              const i = t - 1 >> 1;
              const e = this.C[i];
              if (this.v(e, s) <= 0)
                break;
              this.C[t] = e;
              t = i;
            }
            this.C[t] = s;
          }
          k(t, s) {
            const i = this.C[t];
            while (t < s) {
              let s2 = t << 1 | 1;
              const e = s2 + 1;
              let h = this.C[s2];
              if (e < this.i && this.v(h, this.C[e]) > 0) {
                s2 = e;
                h = this.C[e];
              }
              if (this.v(h, i) >= 0)
                break;
              this.C[t] = h;
              t = s2;
            }
            this.C[t] = i;
          }
          clear() {
            this.i = 0;
            this.C.length = 0;
          }
          push(t) {
            this.C.push(t);
            this.m(this.i);
            this.i += 1;
          }
          pop() {
            if (this.i === 0)
              return;
            const t = this.C[0];
            const s = this.C.pop();
            this.i -= 1;
            if (this.i) {
              this.C[0] = s;
              this.k(0, this.i >> 1);
            }
            return t;
          }
          top() {
            return this.C[0];
          }
          find(t) {
            return this.C.indexOf(t) >= 0;
          }
          remove(t) {
            const s = this.C.indexOf(t);
            if (s < 0)
              return false;
            if (s === 0) {
              this.pop();
            } else if (s === this.i - 1) {
              this.C.pop();
              this.i -= 1;
            } else {
              this.C.splice(s, 1, this.C.pop());
              this.i -= 1;
              this.m(s);
              this.k(s, this.i >> 1);
            }
            return true;
          }
          updateItem(t) {
            const s = this.C.indexOf(t);
            if (s < 0)
              return false;
            this.m(s);
            this.k(s, this.i >> 1);
            return true;
          }
          toArray() {
            return [...this.C];
          }
        }
        var _default = PriorityQueue;
        exports2.default = _default;
      }, { "../ContainerBase": 43 }], 48: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _ContainerBase = require2("../ContainerBase");
        class Queue extends _ContainerBase.Base {
          constructor(t = []) {
            super();
            this.j = 0;
            this.q = [];
            const s = this;
            t.forEach(function(t2) {
              s.push(t2);
            });
          }
          clear() {
            this.q = [];
            this.i = this.j = 0;
          }
          push(t) {
            const s = this.q.length;
            if (this.j / s > 0.5 && this.j + this.i >= s && s > 4096) {
              const s2 = this.i;
              for (let t2 = 0; t2 < s2; ++t2) {
                this.q[t2] = this.q[this.j + t2];
              }
              this.j = 0;
              this.q[this.i] = t;
            } else
              this.q[this.j + this.i] = t;
            return ++this.i;
          }
          pop() {
            if (this.i === 0)
              return;
            const t = this.q[this.j++];
            this.i -= 1;
            return t;
          }
          front() {
            if (this.i === 0)
              return;
            return this.q[this.j];
          }
        }
        var _default = Queue;
        exports2.default = _default;
      }, { "../ContainerBase": 43 }], 49: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _ContainerBase = require2("../ContainerBase");
        class Stack extends _ContainerBase.Base {
          constructor(t = []) {
            super();
            this.S = [];
            const s = this;
            t.forEach(function(t2) {
              s.push(t2);
            });
          }
          clear() {
            this.i = 0;
            this.S = [];
          }
          push(t) {
            this.S.push(t);
            this.i += 1;
            return this.i;
          }
          pop() {
            if (this.i === 0)
              return;
            this.i -= 1;
            return this.S.pop();
          }
          top() {
            return this.S[this.i - 1];
          }
        }
        var _default = Stack;
        exports2.default = _default;
      }, { "../ContainerBase": 43 }], 50: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.RandomIterator = void 0;
        var _ContainerBase = require2("../../ContainerBase");
        var _throwError = require2("../../../utils/throwError");
        class RandomIterator extends _ContainerBase.ContainerIterator {
          constructor(t, r) {
            super(r);
            this.o = t;
            if (this.iteratorType === 0) {
              this.pre = function() {
                if (this.o === 0) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o -= 1;
                return this;
              };
              this.next = function() {
                if (this.o === this.container.size()) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o += 1;
                return this;
              };
            } else {
              this.pre = function() {
                if (this.o === this.container.size() - 1) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o += 1;
                return this;
              };
              this.next = function() {
                if (this.o === -1) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o -= 1;
                return this;
              };
            }
          }
          get pointer() {
            return this.container.getElementByPos(this.o);
          }
          set pointer(t) {
            this.container.setElementByPos(this.o, t);
          }
        }
        exports2.RandomIterator = RandomIterator;
      }, { "../../../utils/throwError": 62, "../../ContainerBase": 43 }], 51: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _ContainerBase = require2("../../ContainerBase");
        class SequentialContainer extends _ContainerBase.Container {
        }
        var _default = SequentialContainer;
        exports2.default = _default;
      }, { "../../ContainerBase": 43 }], 52: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _Base = _interopRequireDefault(require2("./Base"));
        var _RandomIterator = require2("./Base/RandomIterator");
        function _interopRequireDefault(t) {
          return t && t.t ? t : {
            default: t
          };
        }
        class DequeIterator extends _RandomIterator.RandomIterator {
          constructor(t, i, s) {
            super(t, s);
            this.container = i;
          }
          copy() {
            return new DequeIterator(this.o, this.container, this.iteratorType);
          }
        }
        class Deque extends _Base.default {
          constructor(t = [], i = 1 << 12) {
            super();
            this.j = 0;
            this.D = 0;
            this.R = 0;
            this.N = 0;
            this.P = 0;
            this.A = [];
            const s = (() => {
              if (typeof t.length === "number")
                return t.length;
              if (typeof t.size === "number")
                return t.size;
              if (typeof t.size === "function")
                return t.size();
              throw new TypeError("Cannot get the length or size of the container");
            })();
            this.F = i;
            this.P = Math.max(Math.ceil(s / this.F), 1);
            for (let t2 = 0; t2 < this.P; ++t2) {
              this.A.push(new Array(this.F));
            }
            const h = Math.ceil(s / this.F);
            this.j = this.R = (this.P >> 1) - (h >> 1);
            this.D = this.N = this.F - s % this.F >> 1;
            const e = this;
            t.forEach(function(t2) {
              e.pushBack(t2);
            });
          }
          T() {
            const t = [];
            const i = Math.max(this.P >> 1, 1);
            for (let s = 0; s < i; ++s) {
              t[s] = new Array(this.F);
            }
            for (let i2 = this.j; i2 < this.P; ++i2) {
              t[t.length] = this.A[i2];
            }
            for (let i2 = 0; i2 < this.R; ++i2) {
              t[t.length] = this.A[i2];
            }
            t[t.length] = [...this.A[this.R]];
            this.j = i;
            this.R = t.length - 1;
            for (let s = 0; s < i; ++s) {
              t[t.length] = new Array(this.F);
            }
            this.A = t;
            this.P = t.length;
          }
          O(t) {
            const i = this.D + t + 1;
            const s = i % this.F;
            let h = s - 1;
            let e = this.j + (i - s) / this.F;
            if (s === 0)
              e -= 1;
            e %= this.P;
            if (h < 0)
              h += this.F;
            return {
              curNodeBucketIndex: e,
              curNodePointerIndex: h
            };
          }
          clear() {
            this.A = [new Array(this.F)];
            this.P = 1;
            this.j = this.R = this.i = 0;
            this.D = this.N = this.F >> 1;
          }
          begin() {
            return new DequeIterator(0, this);
          }
          end() {
            return new DequeIterator(this.i, this);
          }
          rBegin() {
            return new DequeIterator(this.i - 1, this, 1);
          }
          rEnd() {
            return new DequeIterator(-1, this, 1);
          }
          front() {
            if (this.i === 0)
              return;
            return this.A[this.j][this.D];
          }
          back() {
            if (this.i === 0)
              return;
            return this.A[this.R][this.N];
          }
          pushBack(t) {
            if (this.i) {
              if (this.N < this.F - 1) {
                this.N += 1;
              } else if (this.R < this.P - 1) {
                this.R += 1;
                this.N = 0;
              } else {
                this.R = 0;
                this.N = 0;
              }
              if (this.R === this.j && this.N === this.D)
                this.T();
            }
            this.i += 1;
            this.A[this.R][this.N] = t;
            return this.i;
          }
          popBack() {
            if (this.i === 0)
              return;
            const t = this.A[this.R][this.N];
            if (this.i !== 1) {
              if (this.N > 0) {
                this.N -= 1;
              } else if (this.R > 0) {
                this.R -= 1;
                this.N = this.F - 1;
              } else {
                this.R = this.P - 1;
                this.N = this.F - 1;
              }
            }
            this.i -= 1;
            return t;
          }
          pushFront(t) {
            if (this.i) {
              if (this.D > 0) {
                this.D -= 1;
              } else if (this.j > 0) {
                this.j -= 1;
                this.D = this.F - 1;
              } else {
                this.j = this.P - 1;
                this.D = this.F - 1;
              }
              if (this.j === this.R && this.D === this.N)
                this.T();
            }
            this.i += 1;
            this.A[this.j][this.D] = t;
            return this.i;
          }
          popFront() {
            if (this.i === 0)
              return;
            const t = this.A[this.j][this.D];
            if (this.i !== 1) {
              if (this.D < this.F - 1) {
                this.D += 1;
              } else if (this.j < this.P - 1) {
                this.j += 1;
                this.D = 0;
              } else {
                this.j = 0;
                this.D = 0;
              }
            }
            this.i -= 1;
            return t;
          }
          getElementByPos(t) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            const { curNodeBucketIndex: i, curNodePointerIndex: s } = this.O(t);
            return this.A[i][s];
          }
          setElementByPos(t, i) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            const { curNodeBucketIndex: s, curNodePointerIndex: h } = this.O(t);
            this.A[s][h] = i;
          }
          insert(t, i, s = 1) {
            if (t < 0 || t > this.i) {
              throw new RangeError();
            }
            if (t === 0) {
              while (s--)
                this.pushFront(i);
            } else if (t === this.i) {
              while (s--)
                this.pushBack(i);
            } else {
              const h = [];
              for (let i2 = t; i2 < this.i; ++i2) {
                h.push(this.getElementByPos(i2));
              }
              this.cut(t - 1);
              for (let t2 = 0; t2 < s; ++t2)
                this.pushBack(i);
              for (let t2 = 0; t2 < h.length; ++t2)
                this.pushBack(h[t2]);
            }
            return this.i;
          }
          cut(t) {
            if (t < 0) {
              this.clear();
              return 0;
            }
            const { curNodeBucketIndex: i, curNodePointerIndex: s } = this.O(t);
            this.R = i;
            this.N = s;
            this.i = t + 1;
            return this.i;
          }
          eraseElementByPos(t) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            if (t === 0)
              this.popFront();
            else if (t === this.i - 1)
              this.popBack();
            else {
              const i = [];
              for (let s2 = t + 1; s2 < this.i; ++s2) {
                i.push(this.getElementByPos(s2));
              }
              this.cut(t);
              this.popBack();
              const s = this;
              i.forEach(function(t2) {
                s.pushBack(t2);
              });
            }
            return this.i;
          }
          eraseElementByValue(t) {
            if (this.i === 0)
              return 0;
            const i = [];
            for (let s2 = 0; s2 < this.i; ++s2) {
              const h = this.getElementByPos(s2);
              if (h !== t)
                i.push(h);
            }
            const s = i.length;
            for (let t2 = 0; t2 < s; ++t2)
              this.setElementByPos(t2, i[t2]);
            return this.cut(s - 1);
          }
          eraseElementByIterator(t) {
            const i = t.o;
            this.eraseElementByPos(i);
            t = t.next();
            return t;
          }
          find(t) {
            for (let i = 0; i < this.i; ++i) {
              if (this.getElementByPos(i) === t) {
                return new DequeIterator(i, this);
              }
            }
            return this.end();
          }
          reverse() {
            let t = 0;
            let i = this.i - 1;
            while (t < i) {
              const s = this.getElementByPos(t);
              this.setElementByPos(t, this.getElementByPos(i));
              this.setElementByPos(i, s);
              t += 1;
              i -= 1;
            }
          }
          unique() {
            if (this.i <= 1) {
              return this.i;
            }
            let t = 1;
            let i = this.getElementByPos(0);
            for (let s = 1; s < this.i; ++s) {
              const h = this.getElementByPos(s);
              if (h !== i) {
                i = h;
                this.setElementByPos(t++, h);
              }
            }
            while (this.i > t)
              this.popBack();
            return this.i;
          }
          sort(t) {
            const i = [];
            for (let t2 = 0; t2 < this.i; ++t2) {
              i.push(this.getElementByPos(t2));
            }
            i.sort(t);
            for (let t2 = 0; t2 < this.i; ++t2)
              this.setElementByPos(t2, i[t2]);
          }
          shrinkToFit() {
            if (this.i === 0)
              return;
            const t = [];
            this.forEach(function(i) {
              t.push(i);
            });
            this.P = Math.max(Math.ceil(this.i / this.F), 1);
            this.i = this.j = this.R = this.D = this.N = 0;
            this.A = [];
            for (let t2 = 0; t2 < this.P; ++t2) {
              this.A.push(new Array(this.F));
            }
            for (let i = 0; i < t.length; ++i)
              this.pushBack(t[i]);
          }
          forEach(t) {
            for (let i = 0; i < this.i; ++i) {
              t(this.getElementByPos(i), i, this);
            }
          }
          [Symbol.iterator]() {
            return function* () {
              for (let t = 0; t < this.i; ++t) {
                yield this.getElementByPos(t);
              }
            }.bind(this)();
          }
        }
        var _default = Deque;
        exports2.default = _default;
      }, { "./Base": 51, "./Base/RandomIterator": 50 }], 53: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _Base = _interopRequireDefault(require2("./Base"));
        var _ContainerBase = require2("../ContainerBase");
        var _throwError = require2("../../utils/throwError");
        function _interopRequireDefault(t) {
          return t && t.t ? t : {
            default: t
          };
        }
        class LinkListIterator extends _ContainerBase.ContainerIterator {
          constructor(t, i, s, r) {
            super(r);
            this.o = t;
            this.h = i;
            this.container = s;
            if (this.iteratorType === 0) {
              this.pre = function() {
                if (this.o.L === this.h) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L;
                return this;
              };
              this.next = function() {
                if (this.o === this.h) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B;
                return this;
              };
            } else {
              this.pre = function() {
                if (this.o.B === this.h) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B;
                return this;
              };
              this.next = function() {
                if (this.o === this.h) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L;
                return this;
              };
            }
          }
          get pointer() {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            return this.o.l;
          }
          set pointer(t) {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            this.o.l = t;
          }
          copy() {
            return new LinkListIterator(this.o, this.h, this.container, this.iteratorType);
          }
        }
        class LinkList extends _Base.default {
          constructor(t = []) {
            super();
            this.h = {};
            this.p = this._ = this.h.L = this.h.B = this.h;
            const i = this;
            t.forEach(function(t2) {
              i.pushBack(t2);
            });
          }
          V(t) {
            const { L: i, B: s } = t;
            i.B = s;
            s.L = i;
            if (t === this.p) {
              this.p = s;
            }
            if (t === this._) {
              this._ = i;
            }
            this.i -= 1;
          }
          G(t, i) {
            const s = i.B;
            const r = {
              l: t,
              L: i,
              B: s
            };
            i.B = r;
            s.L = r;
            if (i === this.h) {
              this.p = r;
            }
            if (s === this.h) {
              this._ = r;
            }
            this.i += 1;
          }
          clear() {
            this.i = 0;
            this.p = this._ = this.h.L = this.h.B = this.h;
          }
          begin() {
            return new LinkListIterator(this.p, this.h, this);
          }
          end() {
            return new LinkListIterator(this.h, this.h, this);
          }
          rBegin() {
            return new LinkListIterator(this._, this.h, this, 1);
          }
          rEnd() {
            return new LinkListIterator(this.h, this.h, this, 1);
          }
          front() {
            return this.p.l;
          }
          back() {
            return this._.l;
          }
          getElementByPos(t) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            let i = this.p;
            while (t--) {
              i = i.B;
            }
            return i.l;
          }
          eraseElementByPos(t) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            let i = this.p;
            while (t--) {
              i = i.B;
            }
            this.V(i);
            return this.i;
          }
          eraseElementByValue(t) {
            let i = this.p;
            while (i !== this.h) {
              if (i.l === t) {
                this.V(i);
              }
              i = i.B;
            }
            return this.i;
          }
          eraseElementByIterator(t) {
            const i = t.o;
            if (i === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            t = t.next();
            this.V(i);
            return t;
          }
          pushBack(t) {
            this.G(t, this._);
            return this.i;
          }
          popBack() {
            if (this.i === 0)
              return;
            const t = this._.l;
            this.V(this._);
            return t;
          }
          pushFront(t) {
            this.G(t, this.h);
            return this.i;
          }
          popFront() {
            if (this.i === 0)
              return;
            const t = this.p.l;
            this.V(this.p);
            return t;
          }
          setElementByPos(t, i) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            let s = this.p;
            while (t--) {
              s = s.B;
            }
            s.l = i;
          }
          insert(t, i, s = 1) {
            if (t < 0 || t > this.i) {
              throw new RangeError();
            }
            if (s <= 0)
              return this.i;
            if (t === 0) {
              while (s--)
                this.pushFront(i);
            } else if (t === this.i) {
              while (s--)
                this.pushBack(i);
            } else {
              let r = this.p;
              for (let i2 = 1; i2 < t; ++i2) {
                r = r.B;
              }
              const e = r.B;
              this.i += s;
              while (s--) {
                r.B = {
                  l: i,
                  L: r
                };
                r.B.L = r;
                r = r.B;
              }
              r.B = e;
              e.L = r;
            }
            return this.i;
          }
          find(t) {
            let i = this.p;
            while (i !== this.h) {
              if (i.l === t) {
                return new LinkListIterator(i, this.h, this);
              }
              i = i.B;
            }
            return this.end();
          }
          reverse() {
            if (this.i <= 1)
              return;
            let t = this.p;
            let i = this._;
            let s = 0;
            while (s << 1 < this.i) {
              const r = t.l;
              t.l = i.l;
              i.l = r;
              t = t.B;
              i = i.L;
              s += 1;
            }
          }
          unique() {
            if (this.i <= 1) {
              return this.i;
            }
            let t = this.p;
            while (t !== this.h) {
              let i = t;
              while (i.B !== this.h && i.l === i.B.l) {
                i = i.B;
                this.i -= 1;
              }
              t.B = i.B;
              t.B.L = t;
              t = t.B;
            }
            return this.i;
          }
          sort(t) {
            if (this.i <= 1)
              return;
            const i = [];
            this.forEach(function(t2) {
              i.push(t2);
            });
            i.sort(t);
            let s = this.p;
            i.forEach(function(t2) {
              s.l = t2;
              s = s.B;
            });
          }
          merge(t) {
            const i = this;
            if (this.i === 0) {
              t.forEach(function(t2) {
                i.pushBack(t2);
              });
            } else {
              let s = this.p;
              t.forEach(function(t2) {
                while (s !== i.h && s.l <= t2) {
                  s = s.B;
                }
                i.G(t2, s.L);
              });
            }
            return this.i;
          }
          forEach(t) {
            let i = this.p;
            let s = 0;
            while (i !== this.h) {
              t(i.l, s++, this);
              i = i.B;
            }
          }
          [Symbol.iterator]() {
            return function* () {
              if (this.i === 0)
                return;
              let t = this.p;
              while (t !== this.h) {
                yield t.l;
                t = t.B;
              }
            }.bind(this)();
          }
        }
        var _default = LinkList;
        exports2.default = _default;
      }, { "../../utils/throwError": 62, "../ContainerBase": 43, "./Base": 51 }], 54: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _Base = _interopRequireDefault(require2("./Base"));
        var _RandomIterator = require2("./Base/RandomIterator");
        function _interopRequireDefault(t) {
          return t && t.t ? t : {
            default: t
          };
        }
        class VectorIterator extends _RandomIterator.RandomIterator {
          constructor(t, r, e) {
            super(t, e);
            this.container = r;
          }
          copy() {
            return new VectorIterator(this.o, this.container, this.iteratorType);
          }
        }
        class Vector extends _Base.default {
          constructor(t = [], r = true) {
            super();
            if (Array.isArray(t)) {
              this.J = r ? [...t] : t;
              this.i = t.length;
            } else {
              this.J = [];
              const r2 = this;
              t.forEach(function(t2) {
                r2.pushBack(t2);
              });
            }
          }
          clear() {
            this.i = 0;
            this.J.length = 0;
          }
          begin() {
            return new VectorIterator(0, this);
          }
          end() {
            return new VectorIterator(this.i, this);
          }
          rBegin() {
            return new VectorIterator(this.i - 1, this, 1);
          }
          rEnd() {
            return new VectorIterator(-1, this, 1);
          }
          front() {
            return this.J[0];
          }
          back() {
            return this.J[this.i - 1];
          }
          getElementByPos(t) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            return this.J[t];
          }
          eraseElementByPos(t) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            this.J.splice(t, 1);
            this.i -= 1;
            return this.i;
          }
          eraseElementByValue(t) {
            let r = 0;
            for (let e = 0; e < this.i; ++e) {
              if (this.J[e] !== t) {
                this.J[r++] = this.J[e];
              }
            }
            this.i = this.J.length = r;
            return this.i;
          }
          eraseElementByIterator(t) {
            const r = t.o;
            t = t.next();
            this.eraseElementByPos(r);
            return t;
          }
          pushBack(t) {
            this.J.push(t);
            this.i += 1;
            return this.i;
          }
          popBack() {
            if (this.i === 0)
              return;
            this.i -= 1;
            return this.J.pop();
          }
          setElementByPos(t, r) {
            if (t < 0 || t > this.i - 1) {
              throw new RangeError();
            }
            this.J[t] = r;
          }
          insert(t, r, e = 1) {
            if (t < 0 || t > this.i) {
              throw new RangeError();
            }
            this.J.splice(t, 0, ...new Array(e).fill(r));
            this.i += e;
            return this.i;
          }
          find(t) {
            for (let r = 0; r < this.i; ++r) {
              if (this.J[r] === t) {
                return new VectorIterator(r, this);
              }
            }
            return this.end();
          }
          reverse() {
            this.J.reverse();
          }
          unique() {
            let t = 1;
            for (let r = 1; r < this.i; ++r) {
              if (this.J[r] !== this.J[r - 1]) {
                this.J[t++] = this.J[r];
              }
            }
            this.i = this.J.length = t;
            return this.i;
          }
          sort(t) {
            this.J.sort(t);
          }
          forEach(t) {
            for (let r = 0; r < this.i; ++r) {
              t(this.J[r], r, this);
            }
          }
          [Symbol.iterator]() {
            return function* () {
              yield* this.J;
            }.bind(this)();
          }
        }
        var _default = Vector;
        exports2.default = _default;
      }, { "./Base": 51, "./Base/RandomIterator": 50 }], 55: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _ContainerBase = require2("../../ContainerBase");
        var _throwError = require2("../../../utils/throwError");
        class TreeIterator extends _ContainerBase.ContainerIterator {
          constructor(t, r, i) {
            super(i);
            this.o = t;
            this.h = r;
            if (this.iteratorType === 0) {
              this.pre = function() {
                if (this.o === this.h.U) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L();
                return this;
              };
              this.next = function() {
                if (this.o === this.h) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B();
                return this;
              };
            } else {
              this.pre = function() {
                if (this.o === this.h.W) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B();
                return this;
              };
              this.next = function() {
                if (this.o === this.h) {
                  (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L();
                return this;
              };
            }
          }
          get index() {
            let t = this.o;
            const r = this.h.tt;
            if (t === this.h) {
              if (r) {
                return r.rt - 1;
              }
              return 0;
            }
            let i = 0;
            if (t.U) {
              i += t.U.rt;
            }
            while (t !== r) {
              const r2 = t.tt;
              if (t === r2.W) {
                i += 1;
                if (r2.U) {
                  i += r2.U.rt;
                }
              }
              t = r2;
            }
            return i;
          }
        }
        var _default = TreeIterator;
        exports2.default = _default;
      }, { "../../../utils/throwError": 62, "../../ContainerBase": 43 }], 56: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.TreeNodeEnableIndex = exports2.TreeNode = void 0;
        class TreeNode {
          constructor(e, t) {
            this.ee = 1;
            this.u = void 0;
            this.l = void 0;
            this.U = void 0;
            this.W = void 0;
            this.tt = void 0;
            this.u = e;
            this.l = t;
          }
          L() {
            let e = this;
            if (e.ee === 1 && e.tt.tt === e) {
              e = e.W;
            } else if (e.U) {
              e = e.U;
              while (e.W) {
                e = e.W;
              }
            } else {
              let t = e.tt;
              while (t.U === e) {
                e = t;
                t = e.tt;
              }
              e = t;
            }
            return e;
          }
          B() {
            let e = this;
            if (e.W) {
              e = e.W;
              while (e.U) {
                e = e.U;
              }
              return e;
            } else {
              let t = e.tt;
              while (t.W === e) {
                e = t;
                t = e.tt;
              }
              if (e.W !== t) {
                return t;
              } else
                return e;
            }
          }
          te() {
            const e = this.tt;
            const t = this.W;
            const s = t.U;
            if (e.tt === this)
              e.tt = t;
            else if (e.U === this)
              e.U = t;
            else
              e.W = t;
            t.tt = e;
            t.U = this;
            this.tt = t;
            this.W = s;
            if (s)
              s.tt = this;
            return t;
          }
          se() {
            const e = this.tt;
            const t = this.U;
            const s = t.W;
            if (e.tt === this)
              e.tt = t;
            else if (e.U === this)
              e.U = t;
            else
              e.W = t;
            t.tt = e;
            t.W = this;
            this.tt = t;
            this.U = s;
            if (s)
              s.tt = this;
            return t;
          }
        }
        exports2.TreeNode = TreeNode;
        class TreeNodeEnableIndex extends TreeNode {
          constructor() {
            super(...arguments);
            this.rt = 1;
          }
          te() {
            const e = super.te();
            this.ie();
            e.ie();
            return e;
          }
          se() {
            const e = super.se();
            this.ie();
            e.ie();
            return e;
          }
          ie() {
            this.rt = 1;
            if (this.U) {
              this.rt += this.U.rt;
            }
            if (this.W) {
              this.rt += this.W.rt;
            }
          }
        }
        exports2.TreeNodeEnableIndex = TreeNodeEnableIndex;
      }, {}], 57: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _TreeNode = require2("./TreeNode");
        var _ContainerBase = require2("../../ContainerBase");
        var _throwError = require2("../../../utils/throwError");
        class TreeContainer extends _ContainerBase.Container {
          constructor(e = function(e2, t2) {
            if (e2 < t2)
              return -1;
            if (e2 > t2)
              return 1;
            return 0;
          }, t = false) {
            super();
            this.Y = void 0;
            this.v = e;
            if (t) {
              this.re = _TreeNode.TreeNodeEnableIndex;
              this.M = function(e2, t2, i) {
                const s = this.ne(e2, t2, i);
                if (s) {
                  let e3 = s.tt;
                  while (e3 !== this.h) {
                    e3.rt += 1;
                    e3 = e3.tt;
                  }
                  const t3 = this.he(s);
                  if (t3) {
                    const { parentNode: e4, grandParent: i2, curNode: s2 } = t3;
                    e4.ie();
                    i2.ie();
                    s2.ie();
                  }
                }
                return this.i;
              };
              this.V = function(e2) {
                let t2 = this.fe(e2);
                while (t2 !== this.h) {
                  t2.rt -= 1;
                  t2 = t2.tt;
                }
              };
            } else {
              this.re = _TreeNode.TreeNode;
              this.M = function(e2, t2, i) {
                const s = this.ne(e2, t2, i);
                if (s)
                  this.he(s);
                return this.i;
              };
              this.V = this.fe;
            }
            this.h = new this.re();
          }
          X(e, t) {
            let i = this.h;
            while (e) {
              const s = this.v(e.u, t);
              if (s < 0) {
                e = e.W;
              } else if (s > 0) {
                i = e;
                e = e.U;
              } else
                return e;
            }
            return i;
          }
          Z(e, t) {
            let i = this.h;
            while (e) {
              const s = this.v(e.u, t);
              if (s <= 0) {
                e = e.W;
              } else {
                i = e;
                e = e.U;
              }
            }
            return i;
          }
          $(e, t) {
            let i = this.h;
            while (e) {
              const s = this.v(e.u, t);
              if (s < 0) {
                i = e;
                e = e.W;
              } else if (s > 0) {
                e = e.U;
              } else
                return e;
            }
            return i;
          }
          rr(e, t) {
            let i = this.h;
            while (e) {
              const s = this.v(e.u, t);
              if (s < 0) {
                i = e;
                e = e.W;
              } else {
                e = e.U;
              }
            }
            return i;
          }
          ue(e) {
            while (true) {
              const t = e.tt;
              if (t === this.h)
                return;
              if (e.ee === 1) {
                e.ee = 0;
                return;
              }
              if (e === t.U) {
                const i = t.W;
                if (i.ee === 1) {
                  i.ee = 0;
                  t.ee = 1;
                  if (t === this.Y) {
                    this.Y = t.te();
                  } else
                    t.te();
                } else {
                  if (i.W && i.W.ee === 1) {
                    i.ee = t.ee;
                    t.ee = 0;
                    i.W.ee = 0;
                    if (t === this.Y) {
                      this.Y = t.te();
                    } else
                      t.te();
                    return;
                  } else if (i.U && i.U.ee === 1) {
                    i.ee = 1;
                    i.U.ee = 0;
                    i.se();
                  } else {
                    i.ee = 1;
                    e = t;
                  }
                }
              } else {
                const i = t.U;
                if (i.ee === 1) {
                  i.ee = 0;
                  t.ee = 1;
                  if (t === this.Y) {
                    this.Y = t.se();
                  } else
                    t.se();
                } else {
                  if (i.U && i.U.ee === 1) {
                    i.ee = t.ee;
                    t.ee = 0;
                    i.U.ee = 0;
                    if (t === this.Y) {
                      this.Y = t.se();
                    } else
                      t.se();
                    return;
                  } else if (i.W && i.W.ee === 1) {
                    i.ee = 1;
                    i.W.ee = 0;
                    i.te();
                  } else {
                    i.ee = 1;
                    e = t;
                  }
                }
              }
            }
          }
          fe(e) {
            if (this.i === 1) {
              this.clear();
              return this.h;
            }
            let t = e;
            while (t.U || t.W) {
              if (t.W) {
                t = t.W;
                while (t.U)
                  t = t.U;
              } else {
                t = t.U;
              }
              [e.u, t.u] = [t.u, e.u];
              [e.l, t.l] = [t.l, e.l];
              e = t;
            }
            if (this.h.U === t) {
              this.h.U = t.tt;
            } else if (this.h.W === t) {
              this.h.W = t.tt;
            }
            this.ue(t);
            const i = t.tt;
            if (t === i.U) {
              i.U = void 0;
            } else
              i.W = void 0;
            this.i -= 1;
            this.Y.ee = 0;
            return i;
          }
          oe(e, t) {
            if (e === void 0)
              return false;
            const i = this.oe(e.U, t);
            if (i)
              return true;
            if (t(e))
              return true;
            return this.oe(e.W, t);
          }
          he(e) {
            while (true) {
              const t = e.tt;
              if (t.ee === 0)
                return;
              const i = t.tt;
              if (t === i.U) {
                const s = i.W;
                if (s && s.ee === 1) {
                  s.ee = t.ee = 0;
                  if (i === this.Y)
                    return;
                  i.ee = 1;
                  e = i;
                  continue;
                } else if (e === t.W) {
                  e.ee = 0;
                  if (e.U)
                    e.U.tt = t;
                  if (e.W)
                    e.W.tt = i;
                  t.W = e.U;
                  i.U = e.W;
                  e.U = t;
                  e.W = i;
                  if (i === this.Y) {
                    this.Y = e;
                    this.h.tt = e;
                  } else {
                    const t2 = i.tt;
                    if (t2.U === i) {
                      t2.U = e;
                    } else
                      t2.W = e;
                  }
                  e.tt = i.tt;
                  t.tt = e;
                  i.tt = e;
                  i.ee = 1;
                  return {
                    parentNode: t,
                    grandParent: i,
                    curNode: e
                  };
                } else {
                  t.ee = 0;
                  if (i === this.Y) {
                    this.Y = i.se();
                  } else
                    i.se();
                  i.ee = 1;
                }
              } else {
                const s = i.U;
                if (s && s.ee === 1) {
                  s.ee = t.ee = 0;
                  if (i === this.Y)
                    return;
                  i.ee = 1;
                  e = i;
                  continue;
                } else if (e === t.U) {
                  e.ee = 0;
                  if (e.U)
                    e.U.tt = i;
                  if (e.W)
                    e.W.tt = t;
                  i.W = e.U;
                  t.U = e.W;
                  e.U = i;
                  e.W = t;
                  if (i === this.Y) {
                    this.Y = e;
                    this.h.tt = e;
                  } else {
                    const t2 = i.tt;
                    if (t2.U === i) {
                      t2.U = e;
                    } else
                      t2.W = e;
                  }
                  e.tt = i.tt;
                  t.tt = e;
                  i.tt = e;
                  i.ee = 1;
                  return {
                    parentNode: t,
                    grandParent: i,
                    curNode: e
                  };
                } else {
                  t.ee = 0;
                  if (i === this.Y) {
                    this.Y = i.te();
                  } else
                    i.te();
                  i.ee = 1;
                }
              }
              return;
            }
          }
          ne(e, t, i) {
            if (this.Y === void 0) {
              this.i += 1;
              this.Y = new this.re(e, t);
              this.Y.ee = 0;
              this.Y.tt = this.h;
              this.h.tt = this.Y;
              this.h.U = this.Y;
              this.h.W = this.Y;
              return;
            }
            let s;
            const r = this.h.U;
            const n = this.v(r.u, e);
            if (n === 0) {
              r.l = t;
              return;
            } else if (n > 0) {
              r.U = new this.re(e, t);
              r.U.tt = r;
              s = r.U;
              this.h.U = s;
            } else {
              const r2 = this.h.W;
              const n2 = this.v(r2.u, e);
              if (n2 === 0) {
                r2.l = t;
                return;
              } else if (n2 < 0) {
                r2.W = new this.re(e, t);
                r2.W.tt = r2;
                s = r2.W;
                this.h.W = s;
              } else {
                if (i !== void 0) {
                  const r3 = i.o;
                  if (r3 !== this.h) {
                    const i2 = this.v(r3.u, e);
                    if (i2 === 0) {
                      r3.l = t;
                      return;
                    } else if (i2 > 0) {
                      const i3 = r3.L();
                      const n3 = this.v(i3.u, e);
                      if (n3 === 0) {
                        i3.l = t;
                        return;
                      } else if (n3 < 0) {
                        s = new this.re(e, t);
                        if (i3.W === void 0) {
                          i3.W = s;
                          s.tt = i3;
                        } else {
                          r3.U = s;
                          s.tt = r3;
                        }
                      }
                    }
                  }
                }
                if (s === void 0) {
                  s = this.Y;
                  while (true) {
                    const i2 = this.v(s.u, e);
                    if (i2 > 0) {
                      if (s.U === void 0) {
                        s.U = new this.re(e, t);
                        s.U.tt = s;
                        s = s.U;
                        break;
                      }
                      s = s.U;
                    } else if (i2 < 0) {
                      if (s.W === void 0) {
                        s.W = new this.re(e, t);
                        s.W.tt = s;
                        s = s.W;
                        break;
                      }
                      s = s.W;
                    } else {
                      s.l = t;
                      return;
                    }
                  }
                }
              }
            }
            this.i += 1;
            return s;
          }
          I(e, t) {
            while (e) {
              const i = this.v(e.u, t);
              if (i < 0) {
                e = e.W;
              } else if (i > 0) {
                e = e.U;
              } else
                return e;
            }
            return e || this.h;
          }
          clear() {
            this.i = 0;
            this.Y = void 0;
            this.h.tt = void 0;
            this.h.U = this.h.W = void 0;
          }
          updateKeyByIterator(e, t) {
            const i = e.o;
            if (i === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            if (this.i === 1) {
              i.u = t;
              return true;
            }
            if (i === this.h.U) {
              if (this.v(i.B().u, t) > 0) {
                i.u = t;
                return true;
              }
              return false;
            }
            if (i === this.h.W) {
              if (this.v(i.L().u, t) < 0) {
                i.u = t;
                return true;
              }
              return false;
            }
            const s = i.L().u;
            if (this.v(s, t) >= 0)
              return false;
            const r = i.B().u;
            if (this.v(r, t) <= 0)
              return false;
            i.u = t;
            return true;
          }
          eraseElementByPos(e) {
            if (e < 0 || e > this.i - 1) {
              throw new RangeError();
            }
            let t = 0;
            const i = this;
            this.oe(this.Y, function(s) {
              if (e === t) {
                i.V(s);
                return true;
              }
              t += 1;
              return false;
            });
            return this.i;
          }
          eraseElementByKey(e) {
            if (this.i === 0)
              return false;
            const t = this.I(this.Y, e);
            if (t === this.h)
              return false;
            this.V(t);
            return true;
          }
          eraseElementByIterator(e) {
            const t = e.o;
            if (t === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            const i = t.W === void 0;
            const s = e.iteratorType === 0;
            if (s) {
              if (i)
                e.next();
            } else {
              if (!i || t.U === void 0)
                e.next();
            }
            this.V(t);
            return e;
          }
          forEach(e) {
            let t = 0;
            for (const i of this)
              e(i, t++, this);
          }
          getElementByPos(e) {
            if (e < 0 || e > this.i - 1) {
              throw new RangeError();
            }
            let t;
            let i = 0;
            for (const s of this) {
              if (i === e) {
                t = s;
                break;
              }
              i += 1;
            }
            return t;
          }
          getHeight() {
            if (this.i === 0)
              return 0;
            const traversal = function(e) {
              if (!e)
                return 0;
              return Math.max(traversal(e.U), traversal(e.W)) + 1;
            };
            return traversal(this.Y);
          }
        }
        var _default = TreeContainer;
        exports2.default = _default;
      }, { "../../../utils/throwError": 62, "../../ContainerBase": 43, "./TreeNode": 56 }], 58: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _Base = _interopRequireDefault(require2("./Base"));
        var _TreeIterator = _interopRequireDefault(require2("./Base/TreeIterator"));
        var _throwError = require2("../../utils/throwError");
        function _interopRequireDefault(r) {
          return r && r.t ? r : {
            default: r
          };
        }
        class OrderedMapIterator extends _TreeIterator.default {
          constructor(r, t, e, s) {
            super(r, t, s);
            this.container = e;
          }
          get pointer() {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            const r = this;
            return new Proxy([], {
              get(t, e) {
                if (e === "0")
                  return r.o.u;
                else if (e === "1")
                  return r.o.l;
              },
              set(t, e, s) {
                if (e !== "1") {
                  throw new TypeError("props must be 1");
                }
                r.o.l = s;
                return true;
              }
            });
          }
          copy() {
            return new OrderedMapIterator(this.o, this.h, this.container, this.iteratorType);
          }
        }
        class OrderedMap extends _Base.default {
          constructor(r = [], t, e) {
            super(t, e);
            const s = this;
            r.forEach(function(r2) {
              s.setElement(r2[0], r2[1]);
            });
          }
          *K(r) {
            if (r === void 0)
              return;
            yield* this.K(r.U);
            yield [r.u, r.l];
            yield* this.K(r.W);
          }
          begin() {
            return new OrderedMapIterator(this.h.U || this.h, this.h, this);
          }
          end() {
            return new OrderedMapIterator(this.h, this.h, this);
          }
          rBegin() {
            return new OrderedMapIterator(this.h.W || this.h, this.h, this, 1);
          }
          rEnd() {
            return new OrderedMapIterator(this.h, this.h, this, 1);
          }
          front() {
            if (this.i === 0)
              return;
            const r = this.h.U;
            return [r.u, r.l];
          }
          back() {
            if (this.i === 0)
              return;
            const r = this.h.W;
            return [r.u, r.l];
          }
          lowerBound(r) {
            const t = this.X(this.Y, r);
            return new OrderedMapIterator(t, this.h, this);
          }
          upperBound(r) {
            const t = this.Z(this.Y, r);
            return new OrderedMapIterator(t, this.h, this);
          }
          reverseLowerBound(r) {
            const t = this.$(this.Y, r);
            return new OrderedMapIterator(t, this.h, this);
          }
          reverseUpperBound(r) {
            const t = this.rr(this.Y, r);
            return new OrderedMapIterator(t, this.h, this);
          }
          setElement(r, t, e) {
            return this.M(r, t, e);
          }
          find(r) {
            const t = this.I(this.Y, r);
            return new OrderedMapIterator(t, this.h, this);
          }
          getElementByKey(r) {
            const t = this.I(this.Y, r);
            return t.l;
          }
          union(r) {
            const t = this;
            r.forEach(function(r2) {
              t.setElement(r2[0], r2[1]);
            });
            return this.i;
          }
          [Symbol.iterator]() {
            return this.K(this.Y);
          }
        }
        var _default = OrderedMap;
        exports2.default = _default;
      }, { "../../utils/throwError": 62, "./Base": 57, "./Base/TreeIterator": 55 }], 59: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = void 0;
        var _Base = _interopRequireDefault(require2("./Base"));
        var _TreeIterator = _interopRequireDefault(require2("./Base/TreeIterator"));
        var _throwError = require2("../../utils/throwError");
        function _interopRequireDefault(e) {
          return e && e.t ? e : {
            default: e
          };
        }
        class OrderedSetIterator extends _TreeIterator.default {
          constructor(e, t, r, i) {
            super(e, t, i);
            this.container = r;
          }
          get pointer() {
            if (this.o === this.h) {
              (0, _throwError.throwIteratorAccessError)();
            }
            return this.o.u;
          }
          copy() {
            return new OrderedSetIterator(this.o, this.h, this.container, this.iteratorType);
          }
        }
        class OrderedSet extends _Base.default {
          constructor(e = [], t, r) {
            super(t, r);
            const i = this;
            e.forEach(function(e2) {
              i.insert(e2);
            });
          }
          *K(e) {
            if (e === void 0)
              return;
            yield* this.K(e.U);
            yield e.u;
            yield* this.K(e.W);
          }
          begin() {
            return new OrderedSetIterator(this.h.U || this.h, this.h, this);
          }
          end() {
            return new OrderedSetIterator(this.h, this.h, this);
          }
          rBegin() {
            return new OrderedSetIterator(this.h.W || this.h, this.h, this, 1);
          }
          rEnd() {
            return new OrderedSetIterator(this.h, this.h, this, 1);
          }
          front() {
            return this.h.U ? this.h.U.u : void 0;
          }
          back() {
            return this.h.W ? this.h.W.u : void 0;
          }
          insert(e, t) {
            return this.M(e, void 0, t);
          }
          find(e) {
            const t = this.I(this.Y, e);
            return new OrderedSetIterator(t, this.h, this);
          }
          lowerBound(e) {
            const t = this.X(this.Y, e);
            return new OrderedSetIterator(t, this.h, this);
          }
          upperBound(e) {
            const t = this.Z(this.Y, e);
            return new OrderedSetIterator(t, this.h, this);
          }
          reverseLowerBound(e) {
            const t = this.$(this.Y, e);
            return new OrderedSetIterator(t, this.h, this);
          }
          reverseUpperBound(e) {
            const t = this.rr(this.Y, e);
            return new OrderedSetIterator(t, this.h, this);
          }
          union(e) {
            const t = this;
            e.forEach(function(e2) {
              t.insert(e2);
            });
            return this.i;
          }
          [Symbol.iterator]() {
            return this.K(this.Y);
          }
        }
        var _default = OrderedSet;
        exports2.default = _default;
      }, { "../../utils/throwError": 62, "./Base": 57, "./Base/TreeIterator": 55 }], 60: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        Object.defineProperty(exports2, "Deque", {
          enumerable: true,
          get: function() {
            return _Deque.default;
          }
        });
        Object.defineProperty(exports2, "HashMap", {
          enumerable: true,
          get: function() {
            return _HashMap.default;
          }
        });
        Object.defineProperty(exports2, "HashSet", {
          enumerable: true,
          get: function() {
            return _HashSet.default;
          }
        });
        Object.defineProperty(exports2, "LinkList", {
          enumerable: true,
          get: function() {
            return _LinkList.default;
          }
        });
        Object.defineProperty(exports2, "OrderedMap", {
          enumerable: true,
          get: function() {
            return _OrderedMap.default;
          }
        });
        Object.defineProperty(exports2, "OrderedSet", {
          enumerable: true,
          get: function() {
            return _OrderedSet.default;
          }
        });
        Object.defineProperty(exports2, "PriorityQueue", {
          enumerable: true,
          get: function() {
            return _PriorityQueue.default;
          }
        });
        Object.defineProperty(exports2, "Queue", {
          enumerable: true,
          get: function() {
            return _Queue.default;
          }
        });
        Object.defineProperty(exports2, "Stack", {
          enumerable: true,
          get: function() {
            return _Stack.default;
          }
        });
        Object.defineProperty(exports2, "Vector", {
          enumerable: true,
          get: function() {
            return _Vector.default;
          }
        });
        var _Stack = _interopRequireDefault(require2("./container/OtherContainer/Stack"));
        var _Queue = _interopRequireDefault(require2("./container/OtherContainer/Queue"));
        var _PriorityQueue = _interopRequireDefault(require2("./container/OtherContainer/PriorityQueue"));
        var _Vector = _interopRequireDefault(require2("./container/SequentialContainer/Vector"));
        var _LinkList = _interopRequireDefault(require2("./container/SequentialContainer/LinkList"));
        var _Deque = _interopRequireDefault(require2("./container/SequentialContainer/Deque"));
        var _OrderedSet = _interopRequireDefault(require2("./container/TreeContainer/OrderedSet"));
        var _OrderedMap = _interopRequireDefault(require2("./container/TreeContainer/OrderedMap"));
        var _HashSet = _interopRequireDefault(require2("./container/HashContainer/HashSet"));
        var _HashMap = _interopRequireDefault(require2("./container/HashContainer/HashMap"));
        function _interopRequireDefault(e) {
          return e && e.t ? e : {
            default: e
          };
        }
      }, { "./container/HashContainer/HashMap": 45, "./container/HashContainer/HashSet": 46, "./container/OtherContainer/PriorityQueue": 47, "./container/OtherContainer/Queue": 48, "./container/OtherContainer/Stack": 49, "./container/SequentialContainer/Deque": 52, "./container/SequentialContainer/LinkList": 53, "./container/SequentialContainer/Vector": 54, "./container/TreeContainer/OrderedMap": 58, "./container/TreeContainer/OrderedSet": 59 }], 61: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.default = checkObject;
        function checkObject(e) {
          const t = typeof e;
          return t === "object" && e !== null || t === "function";
        }
      }, {}], 62: [function(require2, module2, exports2) {
        Object.defineProperty(exports2, "t", {
          value: true
        });
        exports2.throwIteratorAccessError = throwIteratorAccessError;
        function throwIteratorAccessError() {
          throw new RangeError("Iterator access denied!");
        }
      }, {}], 63: [function(require2, module2, exports2) {
        const Yallist = require2("yallist");
        const MAX = Symbol("max");
        const LENGTH = Symbol("length");
        const LENGTH_CALCULATOR = Symbol("lengthCalculator");
        const ALLOW_STALE = Symbol("allowStale");
        const MAX_AGE = Symbol("maxAge");
        const DISPOSE = Symbol("dispose");
        const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
        const LRU_LIST = Symbol("lruList");
        const CACHE = Symbol("cache");
        const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
        const naiveLength = () => 1;
        class LRUCache {
          constructor(options) {
            if (typeof options === "number")
              options = { max: options };
            if (!options)
              options = {};
            if (options.max && (typeof options.max !== "number" || options.max < 0))
              throw new TypeError("max must be a non-negative number");
            this[MAX] = options.max || Infinity;
            const lc = options.length || naiveLength;
            this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
            this[ALLOW_STALE] = options.stale || false;
            if (options.maxAge && typeof options.maxAge !== "number")
              throw new TypeError("maxAge must be a number");
            this[MAX_AGE] = options.maxAge || 0;
            this[DISPOSE] = options.dispose;
            this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
            this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
            this.reset();
          }
          // resize the cache when the max changes.
          set max(mL) {
            if (typeof mL !== "number" || mL < 0)
              throw new TypeError("max must be a non-negative number");
            this[MAX] = mL || Infinity;
            trim(this);
          }
          get max() {
            return this[MAX];
          }
          set allowStale(allowStale) {
            this[ALLOW_STALE] = !!allowStale;
          }
          get allowStale() {
            return this[ALLOW_STALE];
          }
          set maxAge(mA) {
            if (typeof mA !== "number")
              throw new TypeError("maxAge must be a non-negative number");
            this[MAX_AGE] = mA;
            trim(this);
          }
          get maxAge() {
            return this[MAX_AGE];
          }
          // resize the cache when the lengthCalculator changes.
          set lengthCalculator(lC) {
            if (typeof lC !== "function")
              lC = naiveLength;
            if (lC !== this[LENGTH_CALCULATOR]) {
              this[LENGTH_CALCULATOR] = lC;
              this[LENGTH] = 0;
              this[LRU_LIST].forEach((hit) => {
                hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
                this[LENGTH] += hit.length;
              });
            }
            trim(this);
          }
          get lengthCalculator() {
            return this[LENGTH_CALCULATOR];
          }
          get length() {
            return this[LENGTH];
          }
          get itemCount() {
            return this[LRU_LIST].length;
          }
          rforEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST].tail; walker !== null; ) {
              const prev = walker.prev;
              forEachStep(this, fn, walker, thisp);
              walker = prev;
            }
          }
          forEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST].head; walker !== null; ) {
              const next = walker.next;
              forEachStep(this, fn, walker, thisp);
              walker = next;
            }
          }
          keys() {
            return this[LRU_LIST].toArray().map((k) => k.key);
          }
          values() {
            return this[LRU_LIST].toArray().map((k) => k.value);
          }
          reset() {
            if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
              this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
            }
            this[CACHE] = /* @__PURE__ */ new Map();
            this[LRU_LIST] = new Yallist();
            this[LENGTH] = 0;
          }
          dump() {
            return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
              k: hit.key,
              v: hit.value,
              e: hit.now + (hit.maxAge || 0)
            }).toArray().filter((h) => h);
          }
          dumpLru() {
            return this[LRU_LIST];
          }
          set(key, value, maxAge) {
            maxAge = maxAge || this[MAX_AGE];
            if (maxAge && typeof maxAge !== "number")
              throw new TypeError("maxAge must be a number");
            const now = maxAge ? Date.now() : 0;
            const len = this[LENGTH_CALCULATOR](value, key);
            if (this[CACHE].has(key)) {
              if (len > this[MAX]) {
                del(this, this[CACHE].get(key));
                return false;
              }
              const node = this[CACHE].get(key);
              const item = node.value;
              if (this[DISPOSE]) {
                if (!this[NO_DISPOSE_ON_SET])
                  this[DISPOSE](key, item.value);
              }
              item.now = now;
              item.maxAge = maxAge;
              item.value = value;
              this[LENGTH] += len - item.length;
              item.length = len;
              this.get(key);
              trim(this);
              return true;
            }
            const hit = new Entry(key, value, len, now, maxAge);
            if (hit.length > this[MAX]) {
              if (this[DISPOSE])
                this[DISPOSE](key, value);
              return false;
            }
            this[LENGTH] += hit.length;
            this[LRU_LIST].unshift(hit);
            this[CACHE].set(key, this[LRU_LIST].head);
            trim(this);
            return true;
          }
          has(key) {
            if (!this[CACHE].has(key))
              return false;
            const hit = this[CACHE].get(key).value;
            return !isStale(this, hit);
          }
          get(key) {
            return get(this, key, true);
          }
          peek(key) {
            return get(this, key, false);
          }
          pop() {
            const node = this[LRU_LIST].tail;
            if (!node)
              return null;
            del(this, node);
            return node.value;
          }
          del(key) {
            del(this, this[CACHE].get(key));
          }
          load(arr) {
            this.reset();
            const now = Date.now();
            for (let l = arr.length - 1; l >= 0; l--) {
              const hit = arr[l];
              const expiresAt = hit.e || 0;
              if (expiresAt === 0)
                this.set(hit.k, hit.v);
              else {
                const maxAge = expiresAt - now;
                if (maxAge > 0) {
                  this.set(hit.k, hit.v, maxAge);
                }
              }
            }
          }
          prune() {
            this[CACHE].forEach((value, key) => get(this, key, false));
          }
        }
        const get = (self2, key, doUse) => {
          const node = self2[CACHE].get(key);
          if (node) {
            const hit = node.value;
            if (isStale(self2, hit)) {
              del(self2, node);
              if (!self2[ALLOW_STALE])
                return void 0;
            } else {
              if (doUse) {
                if (self2[UPDATE_AGE_ON_GET])
                  node.value.now = Date.now();
                self2[LRU_LIST].unshiftNode(node);
              }
            }
            return hit.value;
          }
        };
        const isStale = (self2, hit) => {
          if (!hit || !hit.maxAge && !self2[MAX_AGE])
            return false;
          const diff = Date.now() - hit.now;
          return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
        };
        const trim = (self2) => {
          if (self2[LENGTH] > self2[MAX]) {
            for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
              const prev = walker.prev;
              del(self2, walker);
              walker = prev;
            }
          }
        };
        const del = (self2, node) => {
          if (node) {
            const hit = node.value;
            if (self2[DISPOSE])
              self2[DISPOSE](hit.key, hit.value);
            self2[LENGTH] -= hit.length;
            self2[CACHE].delete(hit.key);
            self2[LRU_LIST].removeNode(node);
          }
        };
        class Entry {
          constructor(key, value, length, now, maxAge) {
            this.key = key;
            this.value = value;
            this.length = length;
            this.now = now;
            this.maxAge = maxAge || 0;
          }
        }
        const forEachStep = (self2, fn, node, thisp) => {
          let hit = node.value;
          if (isStale(self2, hit)) {
            del(self2, node);
            if (!self2[ALLOW_STALE])
              hit = void 0;
          }
          if (hit)
            fn.call(thisp, hit.value, hit.key, self2);
        };
        module2.exports = LRUCache;
      }, { "yallist": 135 }], 64: [function(require2, module2, exports2) {
        const protocol = module2.exports;
        const { Buffer } = require2("buffer");
        protocol.types = {
          0: "reserved",
          1: "connect",
          2: "connack",
          3: "publish",
          4: "puback",
          5: "pubrec",
          6: "pubrel",
          7: "pubcomp",
          8: "subscribe",
          9: "suback",
          10: "unsubscribe",
          11: "unsuback",
          12: "pingreq",
          13: "pingresp",
          14: "disconnect",
          15: "auth"
        };
        protocol.requiredHeaderFlags = {
          1: 0,
          // 'connect'
          2: 0,
          // 'connack'
          4: 0,
          // 'puback'
          5: 0,
          // 'pubrec'
          6: 2,
          // 'pubrel'
          7: 0,
          // 'pubcomp'
          8: 2,
          // 'subscribe'
          9: 0,
          // 'suback'
          10: 2,
          // 'unsubscribe'
          11: 0,
          // 'unsuback'
          12: 0,
          // 'pingreq'
          13: 0,
          // 'pingresp'
          14: 0,
          // 'disconnect'
          15: 0
          // 'auth'
        };
        protocol.requiredHeaderFlagsErrors = {};
        for (const k in protocol.requiredHeaderFlags) {
          const v = protocol.requiredHeaderFlags[k];
          protocol.requiredHeaderFlagsErrors[k] = "Invalid header flag bits, must be 0x" + v.toString(16) + " for " + protocol.types[k] + " packet";
        }
        protocol.codes = {};
        for (const k in protocol.types) {
          const v = protocol.types[k];
          protocol.codes[v] = k;
        }
        protocol.CMD_SHIFT = 4;
        protocol.CMD_MASK = 240;
        protocol.DUP_MASK = 8;
        protocol.QOS_MASK = 3;
        protocol.QOS_SHIFT = 1;
        protocol.RETAIN_MASK = 1;
        protocol.VARBYTEINT_MASK = 127;
        protocol.VARBYTEINT_FIN_MASK = 128;
        protocol.VARBYTEINT_MAX = 268435455;
        protocol.SESSIONPRESENT_MASK = 1;
        protocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK]);
        protocol.CONNACK_HEADER = Buffer.from([protocol.codes.connack << protocol.CMD_SHIFT]);
        protocol.USERNAME_MASK = 128;
        protocol.PASSWORD_MASK = 64;
        protocol.WILL_RETAIN_MASK = 32;
        protocol.WILL_QOS_MASK = 24;
        protocol.WILL_QOS_SHIFT = 3;
        protocol.WILL_FLAG_MASK = 4;
        protocol.CLEAN_SESSION_MASK = 2;
        protocol.CONNECT_HEADER = Buffer.from([protocol.codes.connect << protocol.CMD_SHIFT]);
        protocol.properties = {
          sessionExpiryInterval: 17,
          willDelayInterval: 24,
          receiveMaximum: 33,
          maximumPacketSize: 39,
          topicAliasMaximum: 34,
          requestResponseInformation: 25,
          requestProblemInformation: 23,
          userProperties: 38,
          authenticationMethod: 21,
          authenticationData: 22,
          payloadFormatIndicator: 1,
          messageExpiryInterval: 2,
          contentType: 3,
          responseTopic: 8,
          correlationData: 9,
          maximumQoS: 36,
          retainAvailable: 37,
          assignedClientIdentifier: 18,
          reasonString: 31,
          wildcardSubscriptionAvailable: 40,
          subscriptionIdentifiersAvailable: 41,
          sharedSubscriptionAvailable: 42,
          serverKeepAlive: 19,
          responseInformation: 26,
          serverReference: 28,
          topicAlias: 35,
          subscriptionIdentifier: 11
        };
        protocol.propertiesCodes = {};
        for (const prop in protocol.properties) {
          const id = protocol.properties[prop];
          protocol.propertiesCodes[id] = prop;
        }
        protocol.propertiesTypes = {
          sessionExpiryInterval: "int32",
          willDelayInterval: "int32",
          receiveMaximum: "int16",
          maximumPacketSize: "int32",
          topicAliasMaximum: "int16",
          requestResponseInformation: "byte",
          requestProblemInformation: "byte",
          userProperties: "pair",
          authenticationMethod: "string",
          authenticationData: "binary",
          payloadFormatIndicator: "byte",
          messageExpiryInterval: "int32",
          contentType: "string",
          responseTopic: "string",
          correlationData: "binary",
          maximumQoS: "int8",
          retainAvailable: "byte",
          assignedClientIdentifier: "string",
          reasonString: "string",
          wildcardSubscriptionAvailable: "byte",
          subscriptionIdentifiersAvailable: "byte",
          sharedSubscriptionAvailable: "byte",
          serverKeepAlive: "int16",
          responseInformation: "string",
          serverReference: "string",
          topicAlias: "int16",
          subscriptionIdentifier: "var"
        };
        function genHeader(type) {
          return [0, 1, 2].map((qos) => {
            return [0, 1].map((dup) => {
              return [0, 1].map((retain) => {
                const buf = Buffer.alloc(1);
                buf.writeUInt8(
                  protocol.codes[type] << protocol.CMD_SHIFT | (dup ? protocol.DUP_MASK : 0) | qos << protocol.QOS_SHIFT | retain,
                  0,
                  true
                );
                return buf;
              });
            });
          });
        }
        protocol.PUBLISH_HEADER = genHeader("publish");
        protocol.SUBSCRIBE_HEADER = genHeader("subscribe");
        protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 3;
        protocol.SUBSCRIBE_OPTIONS_NL_MASK = 1;
        protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2;
        protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 1;
        protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3;
        protocol.SUBSCRIBE_OPTIONS_RH_MASK = 3;
        protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4;
        protocol.SUBSCRIBE_OPTIONS_RH = [0, 16, 32];
        protocol.SUBSCRIBE_OPTIONS_NL = 4;
        protocol.SUBSCRIBE_OPTIONS_RAP = 8;
        protocol.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2];
        protocol.UNSUBSCRIBE_HEADER = genHeader("unsubscribe");
        protocol.ACKS = {
          unsuback: genHeader("unsuback"),
          puback: genHeader("puback"),
          pubcomp: genHeader("pubcomp"),
          pubrel: genHeader("pubrel"),
          pubrec: genHeader("pubrec")
        };
        protocol.SUBACK_HEADER = Buffer.from([protocol.codes.suback << protocol.CMD_SHIFT]);
        protocol.VERSION3 = Buffer.from([3]);
        protocol.VERSION4 = Buffer.from([4]);
        protocol.VERSION5 = Buffer.from([5]);
        protocol.VERSION131 = Buffer.from([131]);
        protocol.VERSION132 = Buffer.from([132]);
        protocol.QOS = [0, 1, 2].map((qos) => {
          return Buffer.from([qos]);
        });
        protocol.EMPTY = {
          pingreq: Buffer.from([protocol.codes.pingreq << 4, 0]),
          pingresp: Buffer.from([protocol.codes.pingresp << 4, 0]),
          disconnect: Buffer.from([protocol.codes.disconnect << 4, 0])
        };
        protocol.MQTT5_PUBACK_PUBREC_CODES = {
          0: "Success",
          16: "No matching subscribers",
          128: "Unspecified error",
          131: "Implementation specific error",
          135: "Not authorized",
          144: "Topic Name invalid",
          145: "Packet identifier in use",
          151: "Quota exceeded",
          153: "Payload format invalid"
        };
        protocol.MQTT5_PUBREL_PUBCOMP_CODES = {
          0: "Success",
          146: "Packet Identifier not found"
        };
        protocol.MQTT5_SUBACK_CODES = {
          0: "Granted QoS 0",
          1: "Granted QoS 1",
          2: "Granted QoS 2",
          128: "Unspecified error",
          131: "Implementation specific error",
          135: "Not authorized",
          143: "Topic Filter invalid",
          145: "Packet Identifier in use",
          151: "Quota exceeded",
          158: "Shared Subscriptions not supported",
          161: "Subscription Identifiers not supported",
          162: "Wildcard Subscriptions not supported"
        };
        protocol.MQTT5_UNSUBACK_CODES = {
          0: "Success",
          17: "No subscription existed",
          128: "Unspecified error",
          131: "Implementation specific error",
          135: "Not authorized",
          143: "Topic Filter invalid",
          145: "Packet Identifier in use"
        };
        protocol.MQTT5_DISCONNECT_CODES = {
          0: "Normal disconnection",
          4: "Disconnect with Will Message",
          128: "Unspecified error",
          129: "Malformed Packet",
          130: "Protocol Error",
          131: "Implementation specific error",
          135: "Not authorized",
          137: "Server busy",
          139: "Server shutting down",
          141: "Keep Alive timeout",
          142: "Session taken over",
          143: "Topic Filter invalid",
          144: "Topic Name invalid",
          147: "Receive Maximum exceeded",
          148: "Topic Alias invalid",
          149: "Packet too large",
          150: "Message rate too high",
          151: "Quota exceeded",
          152: "Administrative action",
          153: "Payload format invalid",
          154: "Retain not supported",
          155: "QoS not supported",
          156: "Use another server",
          157: "Server moved",
          158: "Shared Subscriptions not supported",
          159: "Connection rate exceeded",
          160: "Maximum connect time",
          161: "Subscription Identifiers not supported",
          162: "Wildcard Subscriptions not supported"
        };
        protocol.MQTT5_AUTH_CODES = {
          0: "Success",
          24: "Continue authentication",
          25: "Re-authenticate"
        };
      }, { "buffer": 20 }], 65: [function(require2, module2, exports2) {
        const writeToStream = require2("./writeToStream");
        const EventEmitter = require2("events");
        const { Buffer } = require2("buffer");
        function generate(packet, opts) {
          const stream = new Accumulator();
          writeToStream(packet, stream, opts);
          return stream.concat();
        }
        class Accumulator extends EventEmitter {
          constructor() {
            super();
            this._array = new Array(20);
            this._i = 0;
          }
          write(chunk) {
            this._array[this._i++] = chunk;
            return true;
          }
          concat() {
            let length = 0;
            const lengths = new Array(this._array.length);
            const list = this._array;
            let pos = 0;
            let i;
            for (i = 0; i < list.length && list[i] !== void 0; i++) {
              if (typeof list[i] !== "string")
                lengths[i] = list[i].length;
              else
                lengths[i] = Buffer.byteLength(list[i]);
              length += lengths[i];
            }
            const result = Buffer.allocUnsafe(length);
            for (i = 0; i < list.length && list[i] !== void 0; i++) {
              if (typeof list[i] !== "string") {
                list[i].copy(result, pos);
                pos += lengths[i];
              } else {
                result.write(list[i], pos);
                pos += lengths[i];
              }
            }
            return result;
          }
          destroy(err) {
            if (err)
              this.emit("error", err);
          }
        }
        module2.exports = generate;
      }, { "./writeToStream": 87, "buffer": 20, "events": 40 }], 66: [function(require2, module2, exports2) {
        exports2.parser = require2("./parser").parser;
        exports2.generate = require2("./generate");
        exports2.writeToStream = require2("./writeToStream");
      }, { "./generate": 65, "./parser": 86, "./writeToStream": 87 }], 67: [function(require2, module2, exports2) {
        const { Buffer } = require2("buffer");
        const symbol = Symbol.for("BufferList");
        function BufferList(buf) {
          if (!(this instanceof BufferList)) {
            return new BufferList(buf);
          }
          BufferList._init.call(this, buf);
        }
        BufferList._init = function _init(buf) {
          Object.defineProperty(this, symbol, { value: true });
          this._bufs = [];
          this.length = 0;
          if (buf) {
            this.append(buf);
          }
        };
        BufferList.prototype._new = function _new(buf) {
          return new BufferList(buf);
        };
        BufferList.prototype._offset = function _offset(offset) {
          if (offset === 0) {
            return [0, 0];
          }
          let tot = 0;
          for (let i = 0; i < this._bufs.length; i++) {
            const _t = tot + this._bufs[i].length;
            if (offset < _t || i === this._bufs.length - 1) {
              return [i, offset - tot];
            }
            tot = _t;
          }
        };
        BufferList.prototype._reverseOffset = function(blOffset) {
          const bufferId = blOffset[0];
          let offset = blOffset[1];
          for (let i = 0; i < bufferId; i++) {
            offset += this._bufs[i].length;
          }
          return offset;
        };
        BufferList.prototype.get = function get(index2) {
          if (index2 > this.length || index2 < 0) {
            return void 0;
          }
          const offset = this._offset(index2);
          return this._bufs[offset[0]][offset[1]];
        };
        BufferList.prototype.slice = function slice(start, end) {
          if (typeof start === "number" && start < 0) {
            start += this.length;
          }
          if (typeof end === "number" && end < 0) {
            end += this.length;
          }
          return this.copy(null, 0, start, end);
        };
        BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
          if (typeof srcStart !== "number" || srcStart < 0) {
            srcStart = 0;
          }
          if (typeof srcEnd !== "number" || srcEnd > this.length) {
            srcEnd = this.length;
          }
          if (srcStart >= this.length) {
            return dst || Buffer.alloc(0);
          }
          if (srcEnd <= 0) {
            return dst || Buffer.alloc(0);
          }
          const copy2 = !!dst;
          const off = this._offset(srcStart);
          const len = srcEnd - srcStart;
          let bytes = len;
          let bufoff = copy2 && dstStart || 0;
          let start = off[1];
          if (srcStart === 0 && srcEnd === this.length) {
            if (!copy2) {
              return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);
            }
            for (let i = 0; i < this._bufs.length; i++) {
              this._bufs[i].copy(dst, bufoff);
              bufoff += this._bufs[i].length;
            }
            return dst;
          }
          if (bytes <= this._bufs[off[0]].length - start) {
            return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
          }
          if (!copy2) {
            dst = Buffer.allocUnsafe(len);
          }
          for (let i = off[0]; i < this._bufs.length; i++) {
            const l = this._bufs[i].length - start;
            if (bytes > l) {
              this._bufs[i].copy(dst, bufoff, start);
              bufoff += l;
            } else {
              this._bufs[i].copy(dst, bufoff, start, start + bytes);
              bufoff += l;
              break;
            }
            bytes -= l;
            if (start) {
              start = 0;
            }
          }
          if (dst.length > bufoff)
            return dst.slice(0, bufoff);
          return dst;
        };
        BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
          start = start || 0;
          end = typeof end !== "number" ? this.length : end;
          if (start < 0) {
            start += this.length;
          }
          if (end < 0) {
            end += this.length;
          }
          if (start === end) {
            return this._new();
          }
          const startOffset = this._offset(start);
          const endOffset = this._offset(end);
          const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
          if (endOffset[1] === 0) {
            buffers.pop();
          } else {
            buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
          }
          if (startOffset[1] !== 0) {
            buffers[0] = buffers[0].slice(startOffset[1]);
          }
          return this._new(buffers);
        };
        BufferList.prototype.toString = function toString(encoding2, start, end) {
          return this.slice(start, end).toString(encoding2);
        };
        BufferList.prototype.consume = function consume(bytes) {
          bytes = Math.trunc(bytes);
          if (Number.isNaN(bytes) || bytes <= 0)
            return this;
          while (this._bufs.length) {
            if (bytes >= this._bufs[0].length) {
              bytes -= this._bufs[0].length;
              this.length -= this._bufs[0].length;
              this._bufs.shift();
            } else {
              this._bufs[0] = this._bufs[0].slice(bytes);
              this.length -= bytes;
              break;
            }
          }
          return this;
        };
        BufferList.prototype.duplicate = function duplicate() {
          const copy = this._new();
          for (let i = 0; i < this._bufs.length; i++) {
            copy.append(this._bufs[i]);
          }
          return copy;
        };
        BufferList.prototype.append = function append(buf) {
          if (buf == null) {
            return this;
          }
          if (buf.buffer) {
            this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));
          } else if (Array.isArray(buf)) {
            for (let i = 0; i < buf.length; i++) {
              this.append(buf[i]);
            }
          } else if (this._isBufferList(buf)) {
            for (let i = 0; i < buf._bufs.length; i++) {
              this.append(buf._bufs[i]);
            }
          } else {
            if (typeof buf === "number") {
              buf = buf.toString();
            }
            this._appendBuffer(Buffer.from(buf));
          }
          return this;
        };
        BufferList.prototype._appendBuffer = function appendBuffer(buf) {
          this._bufs.push(buf);
          this.length += buf.length;
        };
        BufferList.prototype.indexOf = function(search, offset, encoding2) {
          if (encoding2 === void 0 && typeof offset === "string") {
            encoding2 = offset;
            offset = void 0;
          }
          if (typeof search === "function" || Array.isArray(search)) {
            throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
          } else if (typeof search === "number") {
            search = Buffer.from([search]);
          } else if (typeof search === "string") {
            search = Buffer.from(search, encoding2);
          } else if (this._isBufferList(search)) {
            search = search.slice();
          } else if (Array.isArray(search.buffer)) {
            search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);
          } else if (!Buffer.isBuffer(search)) {
            search = Buffer.from(search);
          }
          offset = Number(offset || 0);
          if (isNaN(offset)) {
            offset = 0;
          }
          if (offset < 0) {
            offset = this.length + offset;
          }
          if (offset < 0) {
            offset = 0;
          }
          if (search.length === 0) {
            return offset > this.length ? this.length : offset;
          }
          const blOffset = this._offset(offset);
          let blIndex = blOffset[0];
          let buffOffset = blOffset[1];
          for (; blIndex < this._bufs.length; blIndex++) {
            const buff = this._bufs[blIndex];
            while (buffOffset < buff.length) {
              const availableWindow = buff.length - buffOffset;
              if (availableWindow >= search.length) {
                const nativeSearchResult = buff.indexOf(search, buffOffset);
                if (nativeSearchResult !== -1) {
                  return this._reverseOffset([blIndex, nativeSearchResult]);
                }
                buffOffset = buff.length - search.length + 1;
              } else {
                const revOffset = this._reverseOffset([blIndex, buffOffset]);
                if (this._match(revOffset, search)) {
                  return revOffset;
                }
                buffOffset++;
              }
            }
            buffOffset = 0;
          }
          return -1;
        };
        BufferList.prototype._match = function(offset, search) {
          if (this.length - offset < search.length) {
            return false;
          }
          for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
            if (this.get(offset + searchOffset) !== search[searchOffset]) {
              return false;
            }
          }
          return true;
        };
        (function() {
          const methods = {
            readDoubleBE: 8,
            readDoubleLE: 8,
            readFloatBE: 4,
            readFloatLE: 4,
            readInt32BE: 4,
            readInt32LE: 4,
            readUInt32BE: 4,
            readUInt32LE: 4,
            readInt16BE: 2,
            readInt16LE: 2,
            readUInt16BE: 2,
            readUInt16LE: 2,
            readInt8: 1,
            readUInt8: 1,
            readIntBE: null,
            readIntLE: null,
            readUIntBE: null,
            readUIntLE: null
          };
          for (const m in methods) {
            (function(m2) {
              if (methods[m2] === null) {
                BufferList.prototype[m2] = function(offset, byteLength) {
                  return this.slice(offset, offset + byteLength)[m2](0, byteLength);
                };
              } else {
                BufferList.prototype[m2] = function(offset = 0) {
                  return this.slice(offset, offset + methods[m2])[m2](0);
                };
              }
            })(m);
          }
        })();
        BufferList.prototype._isBufferList = function _isBufferList(b) {
          return b instanceof BufferList || BufferList.isBufferList(b);
        };
        BufferList.isBufferList = function isBufferList(b) {
          return b != null && b[symbol];
        };
        module2.exports = BufferList;
      }, { "buffer": 20 }], 68: [function(require2, module2, exports2) {
        const DuplexStream = require2("readable-stream").Duplex;
        const inherits = require2("inherits");
        const BufferList = require2("./BufferList");
        function BufferListStream(callback) {
          if (!(this instanceof BufferListStream)) {
            return new BufferListStream(callback);
          }
          if (typeof callback === "function") {
            this._callback = callback;
            const piper = function piper2(err) {
              if (this._callback) {
                this._callback(err);
                this._callback = null;
              }
            }.bind(this);
            this.on("pipe", function onPipe(src2) {
              src2.on("error", piper);
            });
            this.on("unpipe", function onUnpipe(src2) {
              src2.removeListener("error", piper);
            });
            callback = null;
          }
          BufferList._init.call(this, callback);
          DuplexStream.call(this);
        }
        inherits(BufferListStream, DuplexStream);
        Object.assign(BufferListStream.prototype, BufferList.prototype);
        BufferListStream.prototype._new = function _new(callback) {
          return new BufferListStream(callback);
        };
        BufferListStream.prototype._write = function _write(buf, encoding2, callback) {
          this._appendBuffer(buf);
          if (typeof callback === "function") {
            callback();
          }
        };
        BufferListStream.prototype._read = function _read(size) {
          if (!this.length) {
            return this.push(null);
          }
          size = Math.min(size, this.length);
          this.push(this.slice(0, size));
          this.consume(size);
        };
        BufferListStream.prototype.end = function end(chunk) {
          DuplexStream.prototype.end.call(this, chunk);
          if (this._callback) {
            this._callback(null, this.slice());
            this._callback = null;
          }
        };
        BufferListStream.prototype._destroy = function _destroy(err, cb) {
          this._bufs.length = 0;
          this.length = 0;
          cb(err);
        };
        BufferListStream.prototype._isBufferList = function _isBufferList(b) {
          return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
        };
        BufferListStream.isBufferList = BufferList.isBufferList;
        module2.exports = BufferListStream;
        module2.exports.BufferListStream = BufferListStream;
        module2.exports.BufferList = BufferList;
      }, { "./BufferList": 67, "inherits": 42, "readable-stream": 83 }], 69: [function(require2, module2, exports2) {
        arguments[4][24][0].apply(exports2, arguments);
      }, { "dup": 24 }], 70: [function(require2, module2, exports2) {
        arguments[4][25][0].apply(exports2, arguments);
      }, { "./_stream_readable": 72, "./_stream_writable": 74, "_process": 93, "dup": 25, "inherits": 42 }], 71: [function(require2, module2, exports2) {
        arguments[4][26][0].apply(exports2, arguments);
      }, { "./_stream_transform": 73, "dup": 26, "inherits": 42 }], 72: [function(require2, module2, exports2) {
        arguments[4][27][0].apply(exports2, arguments);
      }, { "../errors": 69, "./_stream_duplex": 70, "./internal/streams/async_iterator": 75, "./internal/streams/buffer_list": 76, "./internal/streams/destroy": 77, "./internal/streams/from": 79, "./internal/streams/state": 81, "./internal/streams/stream": 82, "_process": 93, "buffer": 20, "dup": 27, "events": 40, "inherits": 42, "string_decoder/": 127, "util": 17 }], 73: [function(require2, module2, exports2) {
        arguments[4][28][0].apply(exports2, arguments);
      }, { "../errors": 69, "./_stream_duplex": 70, "dup": 28, "inherits": 42 }], 74: [function(require2, module2, exports2) {
        arguments[4][29][0].apply(exports2, arguments);
      }, { "../errors": 69, "./_stream_duplex": 70, "./internal/streams/destroy": 77, "./internal/streams/state": 81, "./internal/streams/stream": 82, "_process": 93, "buffer": 20, "dup": 29, "inherits": 42, "util-deprecate": 130 }], 75: [function(require2, module2, exports2) {
        arguments[4][30][0].apply(exports2, arguments);
      }, { "./end-of-stream": 78, "_process": 93, "dup": 30 }], 76: [function(require2, module2, exports2) {
        arguments[4][31][0].apply(exports2, arguments);
      }, { "buffer": 20, "dup": 31, "util": 17 }], 77: [function(require2, module2, exports2) {
        arguments[4][32][0].apply(exports2, arguments);
      }, { "_process": 93, "dup": 32 }], 78: [function(require2, module2, exports2) {
        arguments[4][33][0].apply(exports2, arguments);
      }, { "../../../errors": 69, "dup": 33 }], 79: [function(require2, module2, exports2) {
        arguments[4][34][0].apply(exports2, arguments);
      }, { "dup": 34 }], 80: [function(require2, module2, exports2) {
        arguments[4][35][0].apply(exports2, arguments);
      }, { "../../../errors": 69, "./end-of-stream": 78, "dup": 35 }], 81: [function(require2, module2, exports2) {
        arguments[4][36][0].apply(exports2, arguments);
      }, { "../../../errors": 69, "dup": 36 }], 82: [function(require2, module2, exports2) {
        arguments[4][37][0].apply(exports2, arguments);
      }, { "dup": 37, "events": 40 }], 83: [function(require2, module2, exports2) {
        arguments[4][38][0].apply(exports2, arguments);
      }, { "./lib/_stream_duplex.js": 70, "./lib/_stream_passthrough.js": 71, "./lib/_stream_readable.js": 72, "./lib/_stream_transform.js": 73, "./lib/_stream_writable.js": 74, "./lib/internal/streams/end-of-stream.js": 78, "./lib/internal/streams/pipeline.js": 80, "dup": 38 }], 84: [function(require2, module2, exports2) {
        const { Buffer } = require2("buffer");
        const max = 65536;
        const cache = {};
        const SubOk = Buffer.isBuffer(Buffer.from([1, 2]).subarray(0, 1));
        function generateBuffer(i) {
          const buffer = Buffer.allocUnsafe(2);
          buffer.writeUInt8(i >> 8, 0);
          buffer.writeUInt8(i & 255, 0 + 1);
          return buffer;
        }
        function generateCache() {
          for (let i = 0; i < max; i++) {
            cache[i] = generateBuffer(i);
          }
        }
        function genBufVariableByteInt(num) {
          const maxLength = 4;
          let digit = 0;
          let pos = 0;
          const buffer = Buffer.allocUnsafe(maxLength);
          do {
            digit = num % 128 | 0;
            num = num / 128 | 0;
            if (num > 0)
              digit = digit | 128;
            buffer.writeUInt8(digit, pos++);
          } while (num > 0 && pos < maxLength);
          if (num > 0) {
            pos = 0;
          }
          return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos);
        }
        function generate4ByteBuffer(num) {
          const buffer = Buffer.allocUnsafe(4);
          buffer.writeUInt32BE(num, 0);
          return buffer;
        }
        module2.exports = {
          cache,
          generateCache,
          generateNumber: generateBuffer,
          genBufVariableByteInt,
          generate4ByteBuffer
        };
      }, { "buffer": 20 }], 85: [function(require2, module2, exports2) {
        class Packet {
          constructor() {
            this.cmd = null;
            this.retain = false;
            this.qos = 0;
            this.dup = false;
            this.length = -1;
            this.topic = null;
            this.payload = null;
          }
        }
        module2.exports = Packet;
      }, {}], 86: [function(require2, module2, exports2) {
        const bl = require2("bl");
        const EventEmitter = require2("events");
        const Packet = require2("./packet");
        const constants = require2("./constants");
        const debug = require2("debug")("mqtt-packet:parser");
        class Parser extends EventEmitter {
          constructor() {
            super();
            this.parser = this.constructor.parser;
          }
          static parser(opt) {
            if (!(this instanceof Parser))
              return new Parser().parser(opt);
            this.settings = opt || {};
            this._states = [
              "_parseHeader",
              "_parseLength",
              "_parsePayload",
              "_newPacket"
            ];
            this._resetState();
            return this;
          }
          _resetState() {
            debug("_resetState: resetting packet, error, _list, and _stateCounter");
            this.packet = new Packet();
            this.error = null;
            this._list = bl();
            this._stateCounter = 0;
          }
          parse(buf) {
            if (this.error)
              this._resetState();
            this._list.append(buf);
            debug("parse: current state: %s", this._states[this._stateCounter]);
            while ((this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error) {
              this._stateCounter++;
              debug("parse: state complete. _stateCounter is now: %d", this._stateCounter);
              debug("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length);
              if (this._stateCounter >= this._states.length)
                this._stateCounter = 0;
            }
            debug("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length);
            return this._list.length;
          }
          _parseHeader() {
            const zero = this._list.readUInt8(0);
            const cmdIndex = zero >> constants.CMD_SHIFT;
            this.packet.cmd = constants.types[cmdIndex];
            const headerFlags = zero & 15;
            const requiredHeaderFlags = constants.requiredHeaderFlags[cmdIndex];
            if (requiredHeaderFlags != null && headerFlags !== requiredHeaderFlags) {
              return this._emitError(new Error(constants.requiredHeaderFlagsErrors[cmdIndex]));
            }
            this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;
            this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;
            if (this.packet.qos > 2) {
              return this._emitError(new Error("Packet must not have both QoS bits set to 1"));
            }
            this.packet.dup = (zero & constants.DUP_MASK) !== 0;
            debug("_parseHeader: packet: %o", this.packet);
            this._list.consume(1);
            return true;
          }
          _parseLength() {
            const result = this._parseVarByteNum(true);
            if (result) {
              this.packet.length = result.value;
              this._list.consume(result.bytes);
            }
            debug("_parseLength %d", result.value);
            return !!result;
          }
          _parsePayload() {
            debug("_parsePayload: payload %O", this._list);
            let result = false;
            if (this.packet.length === 0 || this._list.length >= this.packet.length) {
              this._pos = 0;
              switch (this.packet.cmd) {
                case "connect":
                  this._parseConnect();
                  break;
                case "connack":
                  this._parseConnack();
                  break;
                case "publish":
                  this._parsePublish();
                  break;
                case "puback":
                case "pubrec":
                case "pubrel":
                case "pubcomp":
                  this._parseConfirmation();
                  break;
                case "subscribe":
                  this._parseSubscribe();
                  break;
                case "suback":
                  this._parseSuback();
                  break;
                case "unsubscribe":
                  this._parseUnsubscribe();
                  break;
                case "unsuback":
                  this._parseUnsuback();
                  break;
                case "pingreq":
                case "pingresp":
                  break;
                case "disconnect":
                  this._parseDisconnect();
                  break;
                case "auth":
                  this._parseAuth();
                  break;
                default:
                  this._emitError(new Error("Not supported"));
              }
              result = true;
            }
            debug("_parsePayload complete result: %s", result);
            return result;
          }
          _parseConnect() {
            debug("_parseConnect");
            let topic;
            let payload;
            let password;
            let username;
            const flags = {};
            const packet = this.packet;
            const protocolId = this._parseString();
            if (protocolId === null)
              return this._emitError(new Error("Cannot parse protocolId"));
            if (protocolId !== "MQTT" && protocolId !== "MQIsdp") {
              return this._emitError(new Error("Invalid protocolId"));
            }
            packet.protocolId = protocolId;
            if (this._pos >= this._list.length)
              return this._emitError(new Error("Packet too short"));
            packet.protocolVersion = this._list.readUInt8(this._pos);
            if (packet.protocolVersion >= 128) {
              packet.bridgeMode = true;
              packet.protocolVersion = packet.protocolVersion - 128;
            }
            if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {
              return this._emitError(new Error("Invalid protocol version"));
            }
            this._pos++;
            if (this._pos >= this._list.length) {
              return this._emitError(new Error("Packet too short"));
            }
            if (this._list.readUInt8(this._pos) & 1) {
              return this._emitError(new Error("Connect flag bit 0 must be 0, but got 1"));
            }
            flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;
            flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;
            flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;
            const willRetain = !!(this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK);
            const willQos = (this._list.readUInt8(this._pos) & constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;
            if (flags.will) {
              packet.will = {};
              packet.will.retain = willRetain;
              packet.will.qos = willQos;
            } else {
              if (willRetain) {
                return this._emitError(new Error("Will Retain Flag must be set to zero when Will Flag is set to 0"));
              }
              if (willQos) {
                return this._emitError(new Error("Will QoS must be set to zero when Will Flag is set to 0"));
              }
            }
            packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;
            this._pos++;
            packet.keepalive = this._parseNum();
            if (packet.keepalive === -1)
              return this._emitError(new Error("Packet too short"));
            if (packet.protocolVersion === 5) {
              const properties = this._parseProperties();
              if (Object.getOwnPropertyNames(properties).length) {
                packet.properties = properties;
              }
            }
            const clientId = this._parseString();
            if (clientId === null)
              return this._emitError(new Error("Packet too short"));
            packet.clientId = clientId;
            debug("_parseConnect: packet.clientId: %s", packet.clientId);
            if (flags.will) {
              if (packet.protocolVersion === 5) {
                const willProperties = this._parseProperties();
                if (Object.getOwnPropertyNames(willProperties).length) {
                  packet.will.properties = willProperties;
                }
              }
              topic = this._parseString();
              if (topic === null)
                return this._emitError(new Error("Cannot parse will topic"));
              packet.will.topic = topic;
              debug("_parseConnect: packet.will.topic: %s", packet.will.topic);
              payload = this._parseBuffer();
              if (payload === null)
                return this._emitError(new Error("Cannot parse will payload"));
              packet.will.payload = payload;
              debug("_parseConnect: packet.will.paylaod: %s", packet.will.payload);
            }
            if (flags.username) {
              username = this._parseString();
              if (username === null)
                return this._emitError(new Error("Cannot parse username"));
              packet.username = username;
              debug("_parseConnect: packet.username: %s", packet.username);
            }
            if (flags.password) {
              password = this._parseBuffer();
              if (password === null)
                return this._emitError(new Error("Cannot parse password"));
              packet.password = password;
            }
            this.settings = packet;
            debug("_parseConnect: complete");
            return packet;
          }
          _parseConnack() {
            debug("_parseConnack");
            const packet = this.packet;
            if (this._list.length < 1)
              return null;
            const flags = this._list.readUInt8(this._pos++);
            if (flags > 1) {
              return this._emitError(new Error("Invalid connack flags, bits 7-1 must be set to 0"));
            }
            packet.sessionPresent = !!(flags & constants.SESSIONPRESENT_MASK);
            if (this.settings.protocolVersion === 5) {
              if (this._list.length >= 2) {
                packet.reasonCode = this._list.readUInt8(this._pos++);
              } else {
                packet.reasonCode = 0;
              }
            } else {
              if (this._list.length < 2)
                return null;
              packet.returnCode = this._list.readUInt8(this._pos++);
            }
            if (packet.returnCode === -1 || packet.reasonCode === -1)
              return this._emitError(new Error("Cannot parse return code"));
            if (this.settings.protocolVersion === 5) {
              const properties = this._parseProperties();
              if (Object.getOwnPropertyNames(properties).length) {
                packet.properties = properties;
              }
            }
            debug("_parseConnack: complete");
          }
          _parsePublish() {
            debug("_parsePublish");
            const packet = this.packet;
            packet.topic = this._parseString();
            if (packet.topic === null)
              return this._emitError(new Error("Cannot parse topic"));
            if (packet.qos > 0) {
              if (!this._parseMessageId()) {
                return;
              }
            }
            if (this.settings.protocolVersion === 5) {
              const properties = this._parseProperties();
              if (Object.getOwnPropertyNames(properties).length) {
                packet.properties = properties;
              }
            }
            packet.payload = this._list.slice(this._pos, packet.length);
            debug("_parsePublish: payload from buffer list: %o", packet.payload);
          }
          _parseSubscribe() {
            debug("_parseSubscribe");
            const packet = this.packet;
            let topic;
            let options;
            let qos;
            let rh;
            let rap;
            let nl;
            let subscription;
            packet.subscriptions = [];
            if (!this._parseMessageId()) {
              return;
            }
            if (this.settings.protocolVersion === 5) {
              const properties = this._parseProperties();
              if (Object.getOwnPropertyNames(properties).length) {
                packet.properties = properties;
              }
            }
            if (packet.length <= 0) {
              return this._emitError(new Error("Malformed subscribe, no payload specified"));
            }
            while (this._pos < packet.length) {
              topic = this._parseString();
              if (topic === null)
                return this._emitError(new Error("Cannot parse topic"));
              if (this._pos >= packet.length)
                return this._emitError(new Error("Malformed Subscribe Payload"));
              options = this._parseByte();
              if (this.settings.protocolVersion === 5) {
                if (options & 192) {
                  return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-6 must be 0"));
                }
              } else {
                if (options & 252) {
                  return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-2 must be 0"));
                }
              }
              qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;
              if (qos > 2) {
                return this._emitError(new Error("Invalid subscribe QoS, must be <= 2"));
              }
              nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;
              rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;
              rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;
              if (rh > 2) {
                return this._emitError(new Error("Invalid retain handling, must be <= 2"));
              }
              subscription = { topic, qos };
              if (this.settings.protocolVersion === 5) {
                subscription.nl = nl;
                subscription.rap = rap;
                subscription.rh = rh;
              } else if (this.settings.bridgeMode) {
                subscription.rh = 0;
                subscription.rap = true;
                subscription.nl = true;
              }
              debug("_parseSubscribe: push subscription `%s` to subscription", subscription);
              packet.subscriptions.push(subscription);
            }
          }
          _parseSuback() {
            debug("_parseSuback");
            const packet = this.packet;
            this.packet.granted = [];
            if (!this._parseMessageId()) {
              return;
            }
            if (this.settings.protocolVersion === 5) {
              const properties = this._parseProperties();
              if (Object.getOwnPropertyNames(properties).length) {
                packet.properties = properties;
              }
            }
            if (packet.length <= 0) {
              return this._emitError(new Error("Malformed suback, no payload specified"));
            }
            while (this._pos < this.packet.length) {
              const code = this._list.readUInt8(this._pos++);
              if (this.settings.protocolVersion === 5) {
                if (!constants.MQTT5_SUBACK_CODES[code]) {
                  return this._emitError(new Error("Invalid suback code"));
                }
              } else {
                if (code > 2 && code !== 128) {
                  return this._emitError(new Error("Invalid suback QoS, must be 0, 1, 2 or 128"));
                }
              }
              this.packet.granted.push(code);
            }
          }
          _parseUnsubscribe() {
            debug("_parseUnsubscribe");
            const packet = this.packet;
            packet.unsubscriptions = [];
            if (!this._parseMessageId()) {
              return;
            }
            if (this.settings.protocolVersion === 5) {
              const properties = this._parseProperties();
              if (Object.getOwnPropertyNames(properties).length) {
                packet.properties = properties;
              }
            }
            if (packet.length <= 0) {
              return this._emitError(new Error("Malformed unsubscribe, no payload specified"));
            }
            while (this._pos < packet.length) {
              const topic = this._parseString();
              if (topic === null)
                return this._emitError(new Error("Cannot parse topic"));
              debug("_parseUnsubscribe: push topic `%s` to unsubscriptions", topic);
              packet.unsubscriptions.push(topic);
            }
          }
          _parseUnsuback() {
            debug("_parseUnsuback");
            const packet = this.packet;
            if (!this._parseMessageId())
              return this._emitError(new Error("Cannot parse messageId"));
            if ((this.settings.protocolVersion === 3 || this.settings.protocolVersion === 4) && packet.length !== 2) {
              return this._emitError(new Error("Malformed unsuback, payload length must be 2"));
            }
            if (packet.length <= 0) {
              return this._emitError(new Error("Malformed unsuback, no payload specified"));
            }
            if (this.settings.protocolVersion === 5) {
              const properties = this._parseProperties();
              if (Object.getOwnPropertyNames(properties).length) {
                packet.properties = properties;
              }
              packet.granted = [];
              while (this._pos < this.packet.length) {
                const code = this._list.readUInt8(this._pos++);
                if (!constants.MQTT5_UNSUBACK_CODES[code]) {
                  return this._emitError(new Error("Invalid unsuback code"));
                }
                this.packet.granted.push(code);
              }
            }
          }
          // parse packets like puback, pubrec, pubrel, pubcomp
          _parseConfirmation() {
            debug("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
            const packet = this.packet;
            this._parseMessageId();
            if (this.settings.protocolVersion === 5) {
              if (packet.length > 2) {
                packet.reasonCode = this._parseByte();
                switch (this.packet.cmd) {
                  case "puback":
                  case "pubrec":
                    if (!constants.MQTT5_PUBACK_PUBREC_CODES[packet.reasonCode]) {
                      return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                    }
                    break;
                  case "pubrel":
                  case "pubcomp":
                    if (!constants.MQTT5_PUBREL_PUBCOMP_CODES[packet.reasonCode]) {
                      return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                    }
                    break;
                }
                debug("_parseConfirmation: packet.reasonCode `%d`", packet.reasonCode);
              } else {
                packet.reasonCode = 0;
              }
              if (packet.length > 3) {
                const properties = this._parseProperties();
                if (Object.getOwnPropertyNames(properties).length) {
                  packet.properties = properties;
                }
              }
            }
            return true;
          }
          // parse disconnect packet
          _parseDisconnect() {
            const packet = this.packet;
            debug("_parseDisconnect");
            if (this.settings.protocolVersion === 5) {
              if (this._list.length > 0) {
                packet.reasonCode = this._parseByte();
                if (!constants.MQTT5_DISCONNECT_CODES[packet.reasonCode]) {
                  this._emitError(new Error("Invalid disconnect reason code"));
                }
              } else {
                packet.reasonCode = 0;
              }
              const properties = this._parseProperties();
              if (Object.getOwnPropertyNames(properties).length) {
                packet.properties = properties;
              }
            }
            debug("_parseDisconnect result: true");
            return true;
          }
          // parse auth packet
          _parseAuth() {
            debug("_parseAuth");
            const packet = this.packet;
            if (this.settings.protocolVersion !== 5) {
              return this._emitError(new Error("Not supported auth packet for this version MQTT"));
            }
            packet.reasonCode = this._parseByte();
            if (!constants.MQTT5_AUTH_CODES[packet.reasonCode]) {
              return this._emitError(new Error("Invalid auth reason code"));
            }
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
            debug("_parseAuth: result: true");
            return true;
          }
          _parseMessageId() {
            const packet = this.packet;
            packet.messageId = this._parseNum();
            if (packet.messageId === null) {
              this._emitError(new Error("Cannot parse messageId"));
              return false;
            }
            debug("_parseMessageId: packet.messageId %d", packet.messageId);
            return true;
          }
          _parseString(maybeBuffer) {
            const length = this._parseNum();
            const end = length + this._pos;
            if (length === -1 || end > this._list.length || end > this.packet.length)
              return null;
            const result = this._list.toString("utf8", this._pos, end);
            this._pos += length;
            debug("_parseString: result: %s", result);
            return result;
          }
          _parseStringPair() {
            debug("_parseStringPair");
            return {
              name: this._parseString(),
              value: this._parseString()
            };
          }
          _parseBuffer() {
            const length = this._parseNum();
            const end = length + this._pos;
            if (length === -1 || end > this._list.length || end > this.packet.length)
              return null;
            const result = this._list.slice(this._pos, end);
            this._pos += length;
            debug("_parseBuffer: result: %o", result);
            return result;
          }
          _parseNum() {
            if (this._list.length - this._pos < 2)
              return -1;
            const result = this._list.readUInt16BE(this._pos);
            this._pos += 2;
            debug("_parseNum: result: %s", result);
            return result;
          }
          _parse4ByteNum() {
            if (this._list.length - this._pos < 4)
              return -1;
            const result = this._list.readUInt32BE(this._pos);
            this._pos += 4;
            debug("_parse4ByteNum: result: %s", result);
            return result;
          }
          _parseVarByteNum(fullInfoFlag) {
            debug("_parseVarByteNum");
            const maxBytes = 4;
            let bytes = 0;
            let mul = 1;
            let value = 0;
            let result = false;
            let current;
            const padding = this._pos ? this._pos : 0;
            while (bytes < maxBytes && padding + bytes < this._list.length) {
              current = this._list.readUInt8(padding + bytes++);
              value += mul * (current & constants.VARBYTEINT_MASK);
              mul *= 128;
              if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {
                result = true;
                break;
              }
              if (this._list.length <= bytes) {
                break;
              }
            }
            if (!result && bytes === maxBytes && this._list.length >= bytes) {
              this._emitError(new Error("Invalid variable byte integer"));
            }
            if (padding) {
              this._pos += bytes;
            }
            if (result) {
              if (fullInfoFlag) {
                result = { bytes, value };
              } else {
                result = value;
              }
            } else {
              result = false;
            }
            debug("_parseVarByteNum: result: %o", result);
            return result;
          }
          _parseByte() {
            let result;
            if (this._pos < this._list.length) {
              result = this._list.readUInt8(this._pos);
              this._pos++;
            }
            debug("_parseByte: result: %o", result);
            return result;
          }
          _parseByType(type) {
            debug("_parseByType: type: %s", type);
            switch (type) {
              case "byte": {
                return this._parseByte() !== 0;
              }
              case "int8": {
                return this._parseByte();
              }
              case "int16": {
                return this._parseNum();
              }
              case "int32": {
                return this._parse4ByteNum();
              }
              case "var": {
                return this._parseVarByteNum();
              }
              case "string": {
                return this._parseString();
              }
              case "pair": {
                return this._parseStringPair();
              }
              case "binary": {
                return this._parseBuffer();
              }
            }
          }
          _parseProperties() {
            debug("_parseProperties");
            const length = this._parseVarByteNum();
            const start = this._pos;
            const end = start + length;
            const result = {};
            while (this._pos < end) {
              const type = this._parseByte();
              if (!type) {
                this._emitError(new Error("Cannot parse property code type"));
                return false;
              }
              const name2 = constants.propertiesCodes[type];
              if (!name2) {
                this._emitError(new Error("Unknown property"));
                return false;
              }
              if (name2 === "userProperties") {
                if (!result[name2]) {
                  result[name2] = /* @__PURE__ */ Object.create(null);
                }
                const currentUserProperty = this._parseByType(constants.propertiesTypes[name2]);
                if (result[name2][currentUserProperty.name]) {
                  if (Array.isArray(result[name2][currentUserProperty.name])) {
                    result[name2][currentUserProperty.name].push(currentUserProperty.value);
                  } else {
                    const currentValue = result[name2][currentUserProperty.name];
                    result[name2][currentUserProperty.name] = [currentValue];
                    result[name2][currentUserProperty.name].push(currentUserProperty.value);
                  }
                } else {
                  result[name2][currentUserProperty.name] = currentUserProperty.value;
                }
                continue;
              }
              if (result[name2]) {
                if (Array.isArray(result[name2])) {
                  result[name2].push(this._parseByType(constants.propertiesTypes[name2]));
                } else {
                  result[name2] = [result[name2]];
                  result[name2].push(this._parseByType(constants.propertiesTypes[name2]));
                }
              } else {
                result[name2] = this._parseByType(constants.propertiesTypes[name2]);
              }
            }
            return result;
          }
          _newPacket() {
            debug("_newPacket");
            if (this.packet) {
              this._list.consume(this.packet.length);
              debug("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length);
              this.emit("packet", this.packet);
            }
            debug("_newPacket: new packet");
            this.packet = new Packet();
            this._pos = 0;
            return true;
          }
          _emitError(err) {
            debug("_emitError", err);
            this.error = err;
            this.emit("error", err);
          }
        }
        module2.exports = Parser;
      }, { "./constants": 64, "./packet": 85, "bl": 68, "debug": 21, "events": 40 }], 87: [function(require2, module2, exports2) {
        const protocol = require2("./constants");
        const { Buffer } = require2("buffer");
        const empty = Buffer.allocUnsafe(0);
        const zeroBuf = Buffer.from([0]);
        const numbers = require2("./numbers");
        const nextTick = require2("process-nextick-args").nextTick;
        const debug = require2("debug")("mqtt-packet:writeToStream");
        const numCache = numbers.cache;
        const generateNumber = numbers.generateNumber;
        const generateCache = numbers.generateCache;
        const genBufVariableByteInt = numbers.genBufVariableByteInt;
        const generate4ByteBuffer = numbers.generate4ByteBuffer;
        let writeNumber = writeNumberCached;
        let toGenerate = true;
        function generate(packet, stream, opts) {
          debug("generate called");
          if (stream.cork) {
            stream.cork();
            nextTick(uncork, stream);
          }
          if (toGenerate) {
            toGenerate = false;
            generateCache();
          }
          debug("generate: packet.cmd: %s", packet.cmd);
          switch (packet.cmd) {
            case "connect":
              return connect(packet, stream);
            case "connack":
              return connack(packet, stream, opts);
            case "publish":
              return publish(packet, stream, opts);
            case "puback":
            case "pubrec":
            case "pubrel":
            case "pubcomp":
              return confirmation(packet, stream, opts);
            case "subscribe":
              return subscribe(packet, stream, opts);
            case "suback":
              return suback(packet, stream, opts);
            case "unsubscribe":
              return unsubscribe(packet, stream, opts);
            case "unsuback":
              return unsuback(packet, stream, opts);
            case "pingreq":
            case "pingresp":
              return emptyPacket(packet, stream);
            case "disconnect":
              return disconnect(packet, stream, opts);
            case "auth":
              return auth(packet, stream, opts);
            default:
              stream.destroy(new Error("Unknown command"));
              return false;
          }
        }
        Object.defineProperty(generate, "cacheNumbers", {
          get() {
            return writeNumber === writeNumberCached;
          },
          set(value) {
            if (value) {
              if (!numCache || Object.keys(numCache).length === 0)
                toGenerate = true;
              writeNumber = writeNumberCached;
            } else {
              toGenerate = false;
              writeNumber = writeNumberGenerated;
            }
          }
        });
        function uncork(stream) {
          stream.uncork();
        }
        function connect(packet, stream, opts) {
          const settings = packet || {};
          const protocolId = settings.protocolId || "MQTT";
          let protocolVersion = settings.protocolVersion || 4;
          const will = settings.will;
          let clean = settings.clean;
          const keepalive = settings.keepalive || 0;
          const clientId = settings.clientId || "";
          const username = settings.username;
          const password = settings.password;
          const properties = settings.properties;
          if (clean === void 0)
            clean = true;
          let length = 0;
          if (!protocolId || typeof protocolId !== "string" && !Buffer.isBuffer(protocolId)) {
            stream.destroy(new Error("Invalid protocolId"));
            return false;
          } else
            length += protocolId.length + 2;
          if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {
            stream.destroy(new Error("Invalid protocol version"));
            return false;
          } else
            length += 1;
          if ((typeof clientId === "string" || Buffer.isBuffer(clientId)) && (clientId || protocolVersion >= 4) && (clientId || clean)) {
            length += Buffer.byteLength(clientId) + 2;
          } else {
            if (protocolVersion < 4) {
              stream.destroy(new Error("clientId must be supplied before 3.1.1"));
              return false;
            }
            if (clean * 1 === 0) {
              stream.destroy(new Error("clientId must be given if cleanSession set to 0"));
              return false;
            }
          }
          if (typeof keepalive !== "number" || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {
            stream.destroy(new Error("Invalid keepalive"));
            return false;
          } else
            length += 2;
          length += 1;
          let propertiesData;
          let willProperties;
          if (protocolVersion === 5) {
            propertiesData = getProperties(stream, properties);
            if (!propertiesData) {
              return false;
            }
            length += propertiesData.length;
          }
          if (will) {
            if (typeof will !== "object") {
              stream.destroy(new Error("Invalid will"));
              return false;
            }
            if (!will.topic || typeof will.topic !== "string") {
              stream.destroy(new Error("Invalid will topic"));
              return false;
            } else {
              length += Buffer.byteLength(will.topic) + 2;
            }
            length += 2;
            if (will.payload) {
              if (will.payload.length >= 0) {
                if (typeof will.payload === "string") {
                  length += Buffer.byteLength(will.payload);
                } else {
                  length += will.payload.length;
                }
              } else {
                stream.destroy(new Error("Invalid will payload"));
                return false;
              }
            }
            willProperties = {};
            if (protocolVersion === 5) {
              willProperties = getProperties(stream, will.properties);
              if (!willProperties) {
                return false;
              }
              length += willProperties.length;
            }
          }
          let providedUsername = false;
          if (username != null) {
            if (isStringOrBuffer(username)) {
              providedUsername = true;
              length += Buffer.byteLength(username) + 2;
            } else {
              stream.destroy(new Error("Invalid username"));
              return false;
            }
          }
          if (password != null) {
            if (!providedUsername) {
              stream.destroy(new Error("Username is required to use password"));
              return false;
            }
            if (isStringOrBuffer(password)) {
              length += byteLength(password) + 2;
            } else {
              stream.destroy(new Error("Invalid password"));
              return false;
            }
          }
          stream.write(protocol.CONNECT_HEADER);
          writeVarByteInt(stream, length);
          writeStringOrBuffer(stream, protocolId);
          if (settings.bridgeMode) {
            protocolVersion += 128;
          }
          stream.write(
            protocolVersion === 131 ? protocol.VERSION131 : protocolVersion === 132 ? protocol.VERSION132 : protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3
          );
          let flags = 0;
          flags |= username != null ? protocol.USERNAME_MASK : 0;
          flags |= password != null ? protocol.PASSWORD_MASK : 0;
          flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;
          flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;
          flags |= will ? protocol.WILL_FLAG_MASK : 0;
          flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;
          stream.write(Buffer.from([flags]));
          writeNumber(stream, keepalive);
          if (protocolVersion === 5) {
            propertiesData.write();
          }
          writeStringOrBuffer(stream, clientId);
          if (will) {
            if (protocolVersion === 5) {
              willProperties.write();
            }
            writeString(stream, will.topic);
            writeStringOrBuffer(stream, will.payload);
          }
          if (username != null) {
            writeStringOrBuffer(stream, username);
          }
          if (password != null) {
            writeStringOrBuffer(stream, password);
          }
          return true;
        }
        function connack(packet, stream, opts) {
          const version2 = opts ? opts.protocolVersion : 4;
          const settings = packet || {};
          const rc = version2 === 5 ? settings.reasonCode : settings.returnCode;
          const properties = settings.properties;
          let length = 2;
          if (typeof rc !== "number") {
            stream.destroy(new Error("Invalid return code"));
            return false;
          }
          let propertiesData = null;
          if (version2 === 5) {
            propertiesData = getProperties(stream, properties);
            if (!propertiesData) {
              return false;
            }
            length += propertiesData.length;
          }
          stream.write(protocol.CONNACK_HEADER);
          writeVarByteInt(stream, length);
          stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);
          stream.write(Buffer.from([rc]));
          if (propertiesData != null) {
            propertiesData.write();
          }
          return true;
        }
        function publish(packet, stream, opts) {
          debug("publish: packet: %o", packet);
          const version2 = opts ? opts.protocolVersion : 4;
          const settings = packet || {};
          const qos = settings.qos || 0;
          const retain = settings.retain ? protocol.RETAIN_MASK : 0;
          const topic = settings.topic;
          const payload = settings.payload || empty;
          const id = settings.messageId;
          const properties = settings.properties;
          let length = 0;
          if (typeof topic === "string")
            length += Buffer.byteLength(topic) + 2;
          else if (Buffer.isBuffer(topic))
            length += topic.length + 2;
          else {
            stream.destroy(new Error("Invalid topic"));
            return false;
          }
          if (!Buffer.isBuffer(payload))
            length += Buffer.byteLength(payload);
          else
            length += payload.length;
          if (qos && typeof id !== "number") {
            stream.destroy(new Error("Invalid messageId"));
            return false;
          } else if (qos)
            length += 2;
          let propertiesData = null;
          if (version2 === 5) {
            propertiesData = getProperties(stream, properties);
            if (!propertiesData) {
              return false;
            }
            length += propertiesData.length;
          }
          stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]);
          writeVarByteInt(stream, length);
          writeNumber(stream, byteLength(topic));
          stream.write(topic);
          if (qos > 0)
            writeNumber(stream, id);
          if (propertiesData != null) {
            propertiesData.write();
          }
          debug("publish: payload: %o", payload);
          return stream.write(payload);
        }
        function confirmation(packet, stream, opts) {
          const version2 = opts ? opts.protocolVersion : 4;
          const settings = packet || {};
          const type = settings.cmd || "puback";
          const id = settings.messageId;
          const dup = settings.dup && type === "pubrel" ? protocol.DUP_MASK : 0;
          let qos = 0;
          const reasonCode = settings.reasonCode;
          const properties = settings.properties;
          let length = version2 === 5 ? 3 : 2;
          if (type === "pubrel")
            qos = 1;
          if (typeof id !== "number") {
            stream.destroy(new Error("Invalid messageId"));
            return false;
          }
          let propertiesData = null;
          if (version2 === 5) {
            if (typeof properties === "object") {
              propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
              if (!propertiesData) {
                return false;
              }
              length += propertiesData.length;
            }
          }
          stream.write(protocol.ACKS[type][qos][dup][0]);
          writeVarByteInt(stream, length);
          writeNumber(stream, id);
          if (version2 === 5) {
            stream.write(Buffer.from([reasonCode]));
          }
          if (propertiesData !== null) {
            propertiesData.write();
          }
          return true;
        }
        function subscribe(packet, stream, opts) {
          debug("subscribe: packet: ");
          const version2 = opts ? opts.protocolVersion : 4;
          const settings = packet || {};
          const dup = settings.dup ? protocol.DUP_MASK : 0;
          const id = settings.messageId;
          const subs = settings.subscriptions;
          const properties = settings.properties;
          let length = 0;
          if (typeof id !== "number") {
            stream.destroy(new Error("Invalid messageId"));
            return false;
          } else
            length += 2;
          let propertiesData = null;
          if (version2 === 5) {
            propertiesData = getProperties(stream, properties);
            if (!propertiesData) {
              return false;
            }
            length += propertiesData.length;
          }
          if (typeof subs === "object" && subs.length) {
            for (let i = 0; i < subs.length; i += 1) {
              const itopic = subs[i].topic;
              const iqos = subs[i].qos;
              if (typeof itopic !== "string") {
                stream.destroy(new Error("Invalid subscriptions - invalid topic"));
                return false;
              }
              if (typeof iqos !== "number") {
                stream.destroy(new Error("Invalid subscriptions - invalid qos"));
                return false;
              }
              if (version2 === 5) {
                const nl = subs[i].nl || false;
                if (typeof nl !== "boolean") {
                  stream.destroy(new Error("Invalid subscriptions - invalid No Local"));
                  return false;
                }
                const rap = subs[i].rap || false;
                if (typeof rap !== "boolean") {
                  stream.destroy(new Error("Invalid subscriptions - invalid Retain as Published"));
                  return false;
                }
                const rh = subs[i].rh || 0;
                if (typeof rh !== "number" || rh > 2) {
                  stream.destroy(new Error("Invalid subscriptions - invalid Retain Handling"));
                  return false;
                }
              }
              length += Buffer.byteLength(itopic) + 2 + 1;
            }
          } else {
            stream.destroy(new Error("Invalid subscriptions"));
            return false;
          }
          debug("subscribe: writing to stream: %o", protocol.SUBSCRIBE_HEADER);
          stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);
          writeVarByteInt(stream, length);
          writeNumber(stream, id);
          if (propertiesData !== null) {
            propertiesData.write();
          }
          let result = true;
          for (const sub of subs) {
            const jtopic = sub.topic;
            const jqos = sub.qos;
            const jnl = +sub.nl;
            const jrap = +sub.rap;
            const jrh = sub.rh;
            let joptions;
            writeString(stream, jtopic);
            joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];
            if (version2 === 5) {
              joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;
              joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;
              joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;
            }
            result = stream.write(Buffer.from([joptions]));
          }
          return result;
        }
        function suback(packet, stream, opts) {
          const version2 = opts ? opts.protocolVersion : 4;
          const settings = packet || {};
          const id = settings.messageId;
          const granted = settings.granted;
          const properties = settings.properties;
          let length = 0;
          if (typeof id !== "number") {
            stream.destroy(new Error("Invalid messageId"));
            return false;
          } else
            length += 2;
          if (typeof granted === "object" && granted.length) {
            for (let i = 0; i < granted.length; i += 1) {
              if (typeof granted[i] !== "number") {
                stream.destroy(new Error("Invalid qos vector"));
                return false;
              }
              length += 1;
            }
          } else {
            stream.destroy(new Error("Invalid qos vector"));
            return false;
          }
          let propertiesData = null;
          if (version2 === 5) {
            propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
            if (!propertiesData) {
              return false;
            }
            length += propertiesData.length;
          }
          stream.write(protocol.SUBACK_HEADER);
          writeVarByteInt(stream, length);
          writeNumber(stream, id);
          if (propertiesData !== null) {
            propertiesData.write();
          }
          return stream.write(Buffer.from(granted));
        }
        function unsubscribe(packet, stream, opts) {
          const version2 = opts ? opts.protocolVersion : 4;
          const settings = packet || {};
          const id = settings.messageId;
          const dup = settings.dup ? protocol.DUP_MASK : 0;
          const unsubs = settings.unsubscriptions;
          const properties = settings.properties;
          let length = 0;
          if (typeof id !== "number") {
            stream.destroy(new Error("Invalid messageId"));
            return false;
          } else {
            length += 2;
          }
          if (typeof unsubs === "object" && unsubs.length) {
            for (let i = 0; i < unsubs.length; i += 1) {
              if (typeof unsubs[i] !== "string") {
                stream.destroy(new Error("Invalid unsubscriptions"));
                return false;
              }
              length += Buffer.byteLength(unsubs[i]) + 2;
            }
          } else {
            stream.destroy(new Error("Invalid unsubscriptions"));
            return false;
          }
          let propertiesData = null;
          if (version2 === 5) {
            propertiesData = getProperties(stream, properties);
            if (!propertiesData) {
              return false;
            }
            length += propertiesData.length;
          }
          stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);
          writeVarByteInt(stream, length);
          writeNumber(stream, id);
          if (propertiesData !== null) {
            propertiesData.write();
          }
          let result = true;
          for (let j = 0; j < unsubs.length; j++) {
            result = writeString(stream, unsubs[j]);
          }
          return result;
        }
        function unsuback(packet, stream, opts) {
          const version2 = opts ? opts.protocolVersion : 4;
          const settings = packet || {};
          const id = settings.messageId;
          const dup = settings.dup ? protocol.DUP_MASK : 0;
          const granted = settings.granted;
          const properties = settings.properties;
          const type = settings.cmd;
          const qos = 0;
          let length = 2;
          if (typeof id !== "number") {
            stream.destroy(new Error("Invalid messageId"));
            return false;
          }
          if (version2 === 5) {
            if (typeof granted === "object" && granted.length) {
              for (let i = 0; i < granted.length; i += 1) {
                if (typeof granted[i] !== "number") {
                  stream.destroy(new Error("Invalid qos vector"));
                  return false;
                }
                length += 1;
              }
            } else {
              stream.destroy(new Error("Invalid qos vector"));
              return false;
            }
          }
          let propertiesData = null;
          if (version2 === 5) {
            propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
            if (!propertiesData) {
              return false;
            }
            length += propertiesData.length;
          }
          stream.write(protocol.ACKS[type][qos][dup][0]);
          writeVarByteInt(stream, length);
          writeNumber(stream, id);
          if (propertiesData !== null) {
            propertiesData.write();
          }
          if (version2 === 5) {
            stream.write(Buffer.from(granted));
          }
          return true;
        }
        function emptyPacket(packet, stream, opts) {
          return stream.write(protocol.EMPTY[packet.cmd]);
        }
        function disconnect(packet, stream, opts) {
          const version2 = opts ? opts.protocolVersion : 4;
          const settings = packet || {};
          const reasonCode = settings.reasonCode;
          const properties = settings.properties;
          let length = version2 === 5 ? 1 : 0;
          let propertiesData = null;
          if (version2 === 5) {
            propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
            if (!propertiesData) {
              return false;
            }
            length += propertiesData.length;
          }
          stream.write(Buffer.from([protocol.codes.disconnect << 4]));
          writeVarByteInt(stream, length);
          if (version2 === 5) {
            stream.write(Buffer.from([reasonCode]));
          }
          if (propertiesData !== null) {
            propertiesData.write();
          }
          return true;
        }
        function auth(packet, stream, opts) {
          const version2 = opts ? opts.protocolVersion : 4;
          const settings = packet || {};
          const reasonCode = settings.reasonCode;
          const properties = settings.properties;
          let length = version2 === 5 ? 1 : 0;
          if (version2 !== 5)
            stream.destroy(new Error("Invalid mqtt version for auth packet"));
          const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
          stream.write(Buffer.from([protocol.codes.auth << 4]));
          writeVarByteInt(stream, length);
          stream.write(Buffer.from([reasonCode]));
          if (propertiesData !== null) {
            propertiesData.write();
          }
          return true;
        }
        const varByteIntCache = {};
        function writeVarByteInt(stream, num) {
          if (num > protocol.VARBYTEINT_MAX) {
            stream.destroy(new Error(`Invalid variable byte integer: ${num}`));
            return false;
          }
          let buffer = varByteIntCache[num];
          if (!buffer) {
            buffer = genBufVariableByteInt(num);
            if (num < 16384)
              varByteIntCache[num] = buffer;
          }
          debug("writeVarByteInt: writing to stream: %o", buffer);
          return stream.write(buffer);
        }
        function writeString(stream, string) {
          const strlen = Buffer.byteLength(string);
          writeNumber(stream, strlen);
          debug("writeString: %s", string);
          return stream.write(string, "utf8");
        }
        function writeStringPair(stream, name2, value) {
          writeString(stream, name2);
          writeString(stream, value);
        }
        function writeNumberCached(stream, number) {
          debug("writeNumberCached: number: %d", number);
          debug("writeNumberCached: %o", numCache[number]);
          return stream.write(numCache[number]);
        }
        function writeNumberGenerated(stream, number) {
          const generatedNumber = generateNumber(number);
          debug("writeNumberGenerated: %o", generatedNumber);
          return stream.write(generatedNumber);
        }
        function write4ByteNumber(stream, number) {
          const generated4ByteBuffer = generate4ByteBuffer(number);
          debug("write4ByteNumber: %o", generated4ByteBuffer);
          return stream.write(generated4ByteBuffer);
        }
        function writeStringOrBuffer(stream, toWrite) {
          if (typeof toWrite === "string") {
            writeString(stream, toWrite);
          } else if (toWrite) {
            writeNumber(stream, toWrite.length);
            stream.write(toWrite);
          } else
            writeNumber(stream, 0);
        }
        function getProperties(stream, properties) {
          if (typeof properties !== "object" || properties.length != null) {
            return {
              length: 1,
              write() {
                writeProperties(stream, {}, 0);
              }
            };
          }
          let propertiesLength = 0;
          function getLengthProperty(name2, value) {
            const type = protocol.propertiesTypes[name2];
            let length = 0;
            switch (type) {
              case "byte": {
                if (typeof value !== "boolean") {
                  stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                  return false;
                }
                length += 1 + 1;
                break;
              }
              case "int8": {
                if (typeof value !== "number" || value < 0 || value > 255) {
                  stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                  return false;
                }
                length += 1 + 1;
                break;
              }
              case "binary": {
                if (value && value === null) {
                  stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                  return false;
                }
                length += 1 + Buffer.byteLength(value) + 2;
                break;
              }
              case "int16": {
                if (typeof value !== "number" || value < 0 || value > 65535) {
                  stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                  return false;
                }
                length += 1 + 2;
                break;
              }
              case "int32": {
                if (typeof value !== "number" || value < 0 || value > 4294967295) {
                  stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                  return false;
                }
                length += 1 + 4;
                break;
              }
              case "var": {
                if (typeof value !== "number" || value < 0 || value > 268435455) {
                  stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                  return false;
                }
                length += 1 + Buffer.byteLength(genBufVariableByteInt(value));
                break;
              }
              case "string": {
                if (typeof value !== "string") {
                  stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                  return false;
                }
                length += 1 + 2 + Buffer.byteLength(value.toString());
                break;
              }
              case "pair": {
                if (typeof value !== "object") {
                  stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                  return false;
                }
                length += Object.getOwnPropertyNames(value).reduce((result, name3) => {
                  const currentValue = value[name3];
                  if (Array.isArray(currentValue)) {
                    result += currentValue.reduce((currentLength, value2) => {
                      currentLength += 1 + 2 + Buffer.byteLength(name3.toString()) + 2 + Buffer.byteLength(value2.toString());
                      return currentLength;
                    }, 0);
                  } else {
                    result += 1 + 2 + Buffer.byteLength(name3.toString()) + 2 + Buffer.byteLength(value[name3].toString());
                  }
                  return result;
                }, 0);
                break;
              }
              default: {
                stream.destroy(new Error(`Invalid property ${name2}: ${value}`));
                return false;
              }
            }
            return length;
          }
          if (properties) {
            for (const propName in properties) {
              let propLength = 0;
              let propValueLength = 0;
              const propValue = properties[propName];
              if (Array.isArray(propValue)) {
                for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {
                  propValueLength = getLengthProperty(propName, propValue[valueIndex]);
                  if (!propValueLength) {
                    return false;
                  }
                  propLength += propValueLength;
                }
              } else {
                propValueLength = getLengthProperty(propName, propValue);
                if (!propValueLength) {
                  return false;
                }
                propLength = propValueLength;
              }
              if (!propLength)
                return false;
              propertiesLength += propLength;
            }
          }
          const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength));
          return {
            length: propertiesLengthLength + propertiesLength,
            write() {
              writeProperties(stream, properties, propertiesLength);
            }
          };
        }
        function getPropertiesByMaximumPacketSize(stream, properties, opts, length) {
          const mayEmptyProps = ["reasonString", "userProperties"];
          const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;
          let propertiesData = getProperties(stream, properties);
          if (maximumPacketSize) {
            while (length + propertiesData.length > maximumPacketSize) {
              const currentMayEmptyProp = mayEmptyProps.shift();
              if (currentMayEmptyProp && properties[currentMayEmptyProp]) {
                delete properties[currentMayEmptyProp];
                propertiesData = getProperties(stream, properties);
              } else {
                return false;
              }
            }
          }
          return propertiesData;
        }
        function writeProperty(stream, propName, value) {
          const type = protocol.propertiesTypes[propName];
          switch (type) {
            case "byte": {
              stream.write(Buffer.from([protocol.properties[propName]]));
              stream.write(Buffer.from([+value]));
              break;
            }
            case "int8": {
              stream.write(Buffer.from([protocol.properties[propName]]));
              stream.write(Buffer.from([value]));
              break;
            }
            case "binary": {
              stream.write(Buffer.from([protocol.properties[propName]]));
              writeStringOrBuffer(stream, value);
              break;
            }
            case "int16": {
              stream.write(Buffer.from([protocol.properties[propName]]));
              writeNumber(stream, value);
              break;
            }
            case "int32": {
              stream.write(Buffer.from([protocol.properties[propName]]));
              write4ByteNumber(stream, value);
              break;
            }
            case "var": {
              stream.write(Buffer.from([protocol.properties[propName]]));
              writeVarByteInt(stream, value);
              break;
            }
            case "string": {
              stream.write(Buffer.from([protocol.properties[propName]]));
              writeString(stream, value);
              break;
            }
            case "pair": {
              Object.getOwnPropertyNames(value).forEach((name2) => {
                const currentValue = value[name2];
                if (Array.isArray(currentValue)) {
                  currentValue.forEach((value2) => {
                    stream.write(Buffer.from([protocol.properties[propName]]));
                    writeStringPair(stream, name2.toString(), value2.toString());
                  });
                } else {
                  stream.write(Buffer.from([protocol.properties[propName]]));
                  writeStringPair(stream, name2.toString(), currentValue.toString());
                }
              });
              break;
            }
            default: {
              stream.destroy(new Error(`Invalid property ${propName} value: ${value}`));
              return false;
            }
          }
        }
        function writeProperties(stream, properties, propertiesLength) {
          writeVarByteInt(stream, propertiesLength);
          for (const propName in properties) {
            if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {
              const value = properties[propName];
              if (Array.isArray(value)) {
                for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {
                  writeProperty(stream, propName, value[valueIndex]);
                }
              } else {
                writeProperty(stream, propName, value);
              }
            }
          }
        }
        function byteLength(bufOrString) {
          if (!bufOrString)
            return 0;
          else if (bufOrString instanceof Buffer)
            return bufOrString.length;
          else
            return Buffer.byteLength(bufOrString);
        }
        function isStringOrBuffer(field) {
          return typeof field === "string" || field instanceof Buffer;
        }
        module2.exports = generate;
      }, { "./constants": 64, "./numbers": 84, "buffer": 20, "debug": 21, "process-nextick-args": 92 }], 88: [function(require2, module2, exports2) {
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        module2.exports = function(val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse(val);
          } else if (type === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
          );
        };
        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return void 0;
          }
        }
        function fmtShort(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return Math.round(ms / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms / m) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms / s) + "s";
          }
          return ms + "ms";
        }
        function fmtLong(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return plural(ms, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms, msAbs, m, "minute");
          }
          if (msAbs >= s) {
            return plural(ms, msAbs, s, "second");
          }
          return ms + " ms";
        }
        function plural(ms, msAbs, n, name2) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
        }
      }, {}], 89: [function(require2, module2, exports2) {
        const NumberAllocator = require2("./lib/number-allocator.js");
        module2.exports.NumberAllocator = NumberAllocator;
      }, { "./lib/number-allocator.js": 90 }], 90: [function(require2, module2, exports2) {
        const SortedSet = require2("js-sdsl").OrderedSet;
        const debugTrace = require2("debug")("number-allocator:trace");
        const debugError = require2("debug")("number-allocator:error");
        function Interval(low, high) {
          this.low = low;
          this.high = high;
        }
        Interval.prototype.equals = function(other) {
          return this.low === other.low && this.high === other.high;
        };
        Interval.prototype.compare = function(other) {
          if (this.low < other.low && this.high < other.low)
            return -1;
          if (other.low < this.low && other.high < this.low)
            return 1;
          return 0;
        };
        function NumberAllocator(min, max) {
          if (!(this instanceof NumberAllocator)) {
            return new NumberAllocator(min, max);
          }
          this.min = min;
          this.max = max;
          this.ss = new SortedSet(
            [],
            (lhs, rhs) => {
              return lhs.compare(rhs);
            }
          );
          debugTrace("Create");
          this.clear();
        }
        NumberAllocator.prototype.firstVacant = function() {
          if (this.ss.size() === 0)
            return null;
          return this.ss.front().low;
        };
        NumberAllocator.prototype.alloc = function() {
          if (this.ss.size() === 0) {
            debugTrace("alloc():empty");
            return null;
          }
          const it = this.ss.begin();
          const low = it.pointer.low;
          const high = it.pointer.high;
          const num = low;
          if (num + 1 <= high) {
            this.ss.updateKeyByIterator(it, new Interval(low + 1, high));
          } else {
            this.ss.eraseElementByPos(0);
          }
          debugTrace("alloc():" + num);
          return num;
        };
        NumberAllocator.prototype.use = function(num) {
          const key = new Interval(num, num);
          const it = this.ss.lowerBound(key);
          if (!it.equals(this.ss.end())) {
            const low = it.pointer.low;
            const high = it.pointer.high;
            if (it.pointer.equals(key)) {
              this.ss.eraseElementByIterator(it);
              debugTrace("use():" + num);
              return true;
            }
            if (low > num)
              return false;
            if (low === num) {
              this.ss.updateKeyByIterator(it, new Interval(low + 1, high));
              debugTrace("use():" + num);
              return true;
            }
            if (high === num) {
              this.ss.updateKeyByIterator(it, new Interval(low, high - 1));
              debugTrace("use():" + num);
              return true;
            }
            this.ss.updateKeyByIterator(it, new Interval(num + 1, high));
            this.ss.insert(new Interval(low, num - 1));
            debugTrace("use():" + num);
            return true;
          }
          debugTrace("use():failed");
          return false;
        };
        NumberAllocator.prototype.free = function(num) {
          if (num < this.min || num > this.max) {
            debugError("free():" + num + " is out of range");
            return;
          }
          const key = new Interval(num, num);
          const it = this.ss.upperBound(key);
          if (it.equals(this.ss.end())) {
            if (it.equals(this.ss.begin())) {
              this.ss.insert(key);
              return;
            }
            it.pre();
            const low = it.pointer.high;
            const high = it.pointer.high;
            if (high + 1 === num) {
              this.ss.updateKeyByIterator(it, new Interval(low, num));
            } else {
              this.ss.insert(key);
            }
          } else {
            if (it.equals(this.ss.begin())) {
              if (num + 1 === it.pointer.low) {
                const high = it.pointer.high;
                this.ss.updateKeyByIterator(it, new Interval(num, high));
              } else {
                this.ss.insert(key);
              }
            } else {
              const rLow = it.pointer.low;
              const rHigh = it.pointer.high;
              it.pre();
              const lLow = it.pointer.low;
              const lHigh = it.pointer.high;
              if (lHigh + 1 === num) {
                if (num + 1 === rLow) {
                  this.ss.eraseElementByIterator(it);
                  this.ss.updateKeyByIterator(it, new Interval(lLow, rHigh));
                } else {
                  this.ss.updateKeyByIterator(it, new Interval(lLow, num));
                }
              } else {
                if (num + 1 === rLow) {
                  this.ss.eraseElementByIterator(it.next());
                  this.ss.insert(new Interval(num, rHigh));
                } else {
                  this.ss.insert(key);
                }
              }
            }
          }
          debugTrace("free():" + num);
        };
        NumberAllocator.prototype.clear = function() {
          debugTrace("clear()");
          this.ss.clear();
          this.ss.insert(new Interval(this.min, this.max));
        };
        NumberAllocator.prototype.intervalCount = function() {
          return this.ss.size();
        };
        NumberAllocator.prototype.dump = function() {
          console.log("length:" + this.ss.size());
          for (const element of this.ss) {
            console.log(element);
          }
        };
        module2.exports = NumberAllocator;
      }, { "debug": 21, "js-sdsl": 60 }], 91: [function(require2, module2, exports2) {
        var wrappy = require2("wrappy");
        module2.exports = wrappy(once);
        module2.exports.strict = wrappy(onceStrict);
        once.proto = once(function() {
          Object.defineProperty(Function.prototype, "once", {
            value: function() {
              return once(this);
            },
            configurable: true
          });
          Object.defineProperty(Function.prototype, "onceStrict", {
            value: function() {
              return onceStrict(this);
            },
            configurable: true
          });
        });
        function once(fn) {
          var f = function() {
            if (f.called)
              return f.value;
            f.called = true;
            return f.value = fn.apply(this, arguments);
          };
          f.called = false;
          return f;
        }
        function onceStrict(fn) {
          var f = function() {
            if (f.called)
              throw new Error(f.onceError);
            f.called = true;
            return f.value = fn.apply(this, arguments);
          };
          var name2 = fn.name || "Function wrapped with `once`";
          f.onceError = name2 + " shouldn't be called more than once";
          f.called = false;
          return f;
        }
      }, { "wrappy": 131 }], 92: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
              module2.exports = { nextTick };
            } else {
              module2.exports = process;
            }
            function nextTick(fn, arg1, arg2, arg3) {
              if (typeof fn !== "function") {
                throw new TypeError('"callback" argument must be a function');
              }
              var len = arguments.length;
              var args, i;
              switch (len) {
                case 0:
                case 1:
                  return process.nextTick(fn);
                case 2:
                  return process.nextTick(function afterTickOne() {
                    fn.call(null, arg1);
                  });
                case 3:
                  return process.nextTick(function afterTickTwo() {
                    fn.call(null, arg1, arg2);
                  });
                case 4:
                  return process.nextTick(function afterTickThree() {
                    fn.call(null, arg1, arg2, arg3);
                  });
                default:
                  args = new Array(len - 1);
                  i = 0;
                  while (i < args.length) {
                    args[i++] = arguments[i];
                  }
                  return process.nextTick(function afterTick() {
                    fn.apply(null, args);
                  });
              }
            }
          }).call(this);
        }).call(this, require2("_process"));
      }, { "_process": 93 }], 93: [function(require2, module2, exports2) {
        var process = module2.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {
        }
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name2) {
          return [];
        };
        process.binding = function(name2) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      }, {}], 94: [function(require2, module2, exports2) {
        (function(global2) {
          (function() {
            (function(root) {
              var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
              var freeModule = typeof module2 == "object" && module2 && !module2.nodeType && module2;
              var freeGlobal = typeof global2 == "object" && global2;
              if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                root = freeGlobal;
              }
              var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                "overflow": "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
              }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
              function error(type) {
                throw new RangeError(errors[type]);
              }
              function map(array, fn) {
                var length = array.length;
                var result = [];
                while (length--) {
                  result[length] = fn(array[length]);
                }
                return result;
              }
              function mapDomain(string, fn) {
                var parts = string.split("@");
                var result = "";
                if (parts.length > 1) {
                  result = parts[0] + "@";
                  string = parts[1];
                }
                string = string.replace(regexSeparators, ".");
                var labels = string.split(".");
                var encoded = map(labels, fn).join(".");
                return result + encoded;
              }
              function ucs2decode(string) {
                var output = [], counter = 0, length = string.length, value, extra;
                while (counter < length) {
                  value = string.charCodeAt(counter++);
                  if (value >= 55296 && value <= 56319 && counter < length) {
                    extra = string.charCodeAt(counter++);
                    if ((extra & 64512) == 56320) {
                      output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                    } else {
                      output.push(value);
                      counter--;
                    }
                  } else {
                    output.push(value);
                  }
                }
                return output;
              }
              function ucs2encode(array) {
                return map(array, function(value) {
                  var output = "";
                  if (value > 65535) {
                    value -= 65536;
                    output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                    value = 56320 | value & 1023;
                  }
                  output += stringFromCharCode(value);
                  return output;
                }).join("");
              }
              function basicToDigit(codePoint) {
                if (codePoint - 48 < 10) {
                  return codePoint - 22;
                }
                if (codePoint - 65 < 26) {
                  return codePoint - 65;
                }
                if (codePoint - 97 < 26) {
                  return codePoint - 97;
                }
                return base;
              }
              function digitToBasic(digit, flag) {
                return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
              }
              function adapt(delta, numPoints, firstTime) {
                var k = 0;
                delta = firstTime ? floor(delta / damp) : delta >> 1;
                delta += floor(delta / numPoints);
                for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                  delta = floor(delta / baseMinusTMin);
                }
                return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
              }
              function decode(input) {
                var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index2, oldi, w, k, digit, t, baseMinusT;
                basic = input.lastIndexOf(delimiter);
                if (basic < 0) {
                  basic = 0;
                }
                for (j = 0; j < basic; ++j) {
                  if (input.charCodeAt(j) >= 128) {
                    error("not-basic");
                  }
                  output.push(input.charCodeAt(j));
                }
                for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
                  for (oldi = i, w = 1, k = base; ; k += base) {
                    if (index2 >= inputLength) {
                      error("invalid-input");
                    }
                    digit = basicToDigit(input.charCodeAt(index2++));
                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                      error("overflow");
                    }
                    i += digit * w;
                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (digit < t) {
                      break;
                    }
                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                      error("overflow");
                    }
                    w *= baseMinusT;
                  }
                  out = output.length + 1;
                  bias = adapt(i - oldi, out, oldi == 0);
                  if (floor(i / out) > maxInt - n) {
                    error("overflow");
                  }
                  n += floor(i / out);
                  i %= out;
                  output.splice(i++, 0, n);
                }
                return ucs2encode(output);
              }
              function encode(input) {
                var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                input = ucs2decode(input);
                inputLength = input.length;
                n = initialN;
                delta = 0;
                bias = initialBias;
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue < 128) {
                    output.push(stringFromCharCode(currentValue));
                  }
                }
                handledCPCount = basicLength = output.length;
                if (basicLength) {
                  output.push(delimiter);
                }
                while (handledCPCount < inputLength) {
                  for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                      m = currentValue;
                    }
                  }
                  handledCPCountPlusOne = handledCPCount + 1;
                  if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error("overflow");
                  }
                  delta += (m - n) * handledCPCountPlusOne;
                  n = m;
                  for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue < n && ++delta > maxInt) {
                      error("overflow");
                    }
                    if (currentValue == n) {
                      for (q = delta, k = base; ; k += base) {
                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (q < t) {
                          break;
                        }
                        qMinusT = q - t;
                        baseMinusT = base - t;
                        output.push(
                          stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                        );
                        q = floor(qMinusT / baseMinusT);
                      }
                      output.push(stringFromCharCode(digitToBasic(q, 0)));
                      bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                      delta = 0;
                      ++handledCPCount;
                    }
                  }
                  ++delta;
                  ++n;
                }
                return output.join("");
              }
              function toUnicode(input) {
                return mapDomain(input, function(string) {
                  return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                });
              }
              function toASCII(input) {
                return mapDomain(input, function(string) {
                  return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                });
              }
              punycode = {
                /**
                 * A string representing the current Punycode.js version number.
                 * @memberOf punycode
                 * @type String
                 */
                "version": "1.4.1",
                /**
                 * An object of methods to convert from JavaScript's internal character
                 * representation (UCS-2) to Unicode code points, and back.
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode
                 * @type Object
                 */
                "ucs2": {
                  "decode": ucs2decode,
                  "encode": ucs2encode
                },
                "decode": decode,
                "encode": encode,
                "toASCII": toASCII,
                "toUnicode": toUnicode
              };
              if (freeExports && freeModule) {
                if (module2.exports == freeExports) {
                  freeModule.exports = punycode;
                } else {
                  for (key in punycode) {
                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                  }
                }
              } else {
                root.punycode = punycode;
              }
            })(this);
          }).call(this);
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 95: [function(require2, module2, exports2) {
        function hasOwnProperty2(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module2.exports = function(qs, sep, eq, options) {
          sep = sep || "&";
          eq = eq || "=";
          var obj = {};
          if (typeof qs !== "string" || qs.length === 0) {
            return obj;
          }
          var regexp = /\+/g;
          qs = qs.split(sep);
          var maxKeys = 1e3;
          if (options && typeof options.maxKeys === "number") {
            maxKeys = options.maxKeys;
          }
          var len = qs.length;
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }
          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = "";
            }
            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);
            if (!hasOwnProperty2(obj, k)) {
              obj[k] = v;
            } else if (isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [obj[k], v];
            }
          }
          return obj;
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
      }, {}], 96: [function(require2, module2, exports2) {
        var stringifyPrimitive = function(v) {
          switch (typeof v) {
            case "string":
              return v;
            case "boolean":
              return v ? "true" : "false";
            case "number":
              return isFinite(v) ? v : "";
            default:
              return "";
          }
        };
        module2.exports = function(obj, sep, eq, name2) {
          sep = sep || "&";
          eq = eq || "=";
          if (obj === null) {
            obj = void 0;
          }
          if (typeof obj === "object") {
            return map(objectKeys(obj), function(k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray(obj[k])) {
                return map(obj[k], function(v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);
          }
          if (!name2)
            return "";
          return encodeURIComponent(stringifyPrimitive(name2)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
        function map(xs, f) {
          if (xs.map)
            return xs.map(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
          }
          return res;
        }
        var objectKeys = Object.keys || function(obj) {
          var res = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              res.push(key);
          }
          return res;
        };
      }, {}], 97: [function(require2, module2, exports2) {
        exports2.decode = exports2.parse = require2("./decode");
        exports2.encode = exports2.stringify = require2("./encode");
      }, { "./decode": 95, "./encode": 96 }], 98: [function(require2, module2, exports2) {
        const { AbortError, codes } = require2("../../ours/errors");
        const eos = require2("./end-of-stream");
        const { ERR_INVALID_ARG_TYPE } = codes;
        const validateAbortSignal = (signal, name2) => {
          if (typeof signal !== "object" || !("aborted" in signal)) {
            throw new ERR_INVALID_ARG_TYPE(name2, "AbortSignal", signal);
          }
        };
        function isNodeStream(obj) {
          return !!(obj && typeof obj.pipe === "function");
        }
        module2.exports.addAbortSignal = function addAbortSignal(signal, stream) {
          validateAbortSignal(signal, "signal");
          if (!isNodeStream(stream)) {
            throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
          }
          return module2.exports.addAbortSignalNoValidate(signal, stream);
        };
        module2.exports.addAbortSignalNoValidate = function(signal, stream) {
          if (typeof signal !== "object" || !("aborted" in signal)) {
            return stream;
          }
          const onAbort = () => {
            stream.destroy(
              new AbortError(void 0, {
                cause: signal.reason
              })
            );
          };
          if (signal.aborted) {
            onAbort();
          } else {
            signal.addEventListener("abort", onAbort);
            eos(stream, () => signal.removeEventListener("abort", onAbort));
          }
          return stream;
        };
      }, { "../../ours/errors": 117, "./end-of-stream": 104 }], 99: [function(require2, module2, exports2) {
        (function(Buffer) {
          (function() {
            const { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require2("../../ours/primordials");
            const { inspect } = require2("../../ours/util");
            module2.exports = class BufferList {
              constructor() {
                this.head = null;
                this.tail = null;
                this.length = 0;
              }
              push(v) {
                const entry = {
                  data: v,
                  next: null
                };
                if (this.length > 0)
                  this.tail.next = entry;
                else
                  this.head = entry;
                this.tail = entry;
                ++this.length;
              }
              unshift(v) {
                const entry = {
                  data: v,
                  next: this.head
                };
                if (this.length === 0)
                  this.tail = entry;
                this.head = entry;
                ++this.length;
              }
              shift() {
                if (this.length === 0)
                  return;
                const ret = this.head.data;
                if (this.length === 1)
                  this.head = this.tail = null;
                else
                  this.head = this.head.next;
                --this.length;
                return ret;
              }
              clear() {
                this.head = this.tail = null;
                this.length = 0;
              }
              join(s) {
                if (this.length === 0)
                  return "";
                let p = this.head;
                let ret = "" + p.data;
                while ((p = p.next) !== null)
                  ret += s + p.data;
                return ret;
              }
              concat(n) {
                if (this.length === 0)
                  return Buffer.alloc(0);
                const ret = Buffer.allocUnsafe(n >>> 0);
                let p = this.head;
                let i = 0;
                while (p) {
                  TypedArrayPrototypeSet(ret, p.data, i);
                  i += p.data.length;
                  p = p.next;
                }
                return ret;
              }
              // Consumes a specified amount of bytes or characters from the buffered data.
              consume(n, hasStrings) {
                const data = this.head.data;
                if (n < data.length) {
                  const slice = data.slice(0, n);
                  this.head.data = data.slice(n);
                  return slice;
                }
                if (n === data.length) {
                  return this.shift();
                }
                return hasStrings ? this._getString(n) : this._getBuffer(n);
              }
              first() {
                return this.head.data;
              }
              *[SymbolIterator]() {
                for (let p = this.head; p; p = p.next) {
                  yield p.data;
                }
              }
              // Consumes a specified amount of characters from the buffered data.
              _getString(n) {
                let ret = "";
                let p = this.head;
                let c = 0;
                do {
                  const str = p.data;
                  if (n > str.length) {
                    ret += str;
                    n -= str.length;
                  } else {
                    if (n === str.length) {
                      ret += str;
                      ++c;
                      if (p.next)
                        this.head = p.next;
                      else
                        this.head = this.tail = null;
                    } else {
                      ret += StringPrototypeSlice(str, 0, n);
                      this.head = p;
                      p.data = StringPrototypeSlice(str, n);
                    }
                    break;
                  }
                  ++c;
                } while ((p = p.next) !== null);
                this.length -= c;
                return ret;
              }
              // Consumes a specified amount of bytes from the buffered data.
              _getBuffer(n) {
                const ret = Buffer.allocUnsafe(n);
                const retLen = n;
                let p = this.head;
                let c = 0;
                do {
                  const buf = p.data;
                  if (n > buf.length) {
                    TypedArrayPrototypeSet(ret, buf, retLen - n);
                    n -= buf.length;
                  } else {
                    if (n === buf.length) {
                      TypedArrayPrototypeSet(ret, buf, retLen - n);
                      ++c;
                      if (p.next)
                        this.head = p.next;
                      else
                        this.head = this.tail = null;
                    } else {
                      TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
                      this.head = p;
                      p.data = buf.slice(n);
                    }
                    break;
                  }
                  ++c;
                } while ((p = p.next) !== null);
                this.length -= c;
                return ret;
              }
              // Make sure the linked list only shows the minimal necessary information.
              [Symbol.for("nodejs.util.inspect.custom")](_, options) {
                return inspect(this, {
                  ...options,
                  // Only inspect one level.
                  depth: 0,
                  // It should not recurse.
                  customInspect: false
                });
              }
            };
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "../../ours/primordials": 118, "../../ours/util": 119, "buffer": 20 }], 100: [function(require2, module2, exports2) {
        const { pipeline } = require2("./pipeline");
        const Duplex = require2("./duplex");
        const { destroyer } = require2("./destroy");
        const { isNodeStream, isReadable, isWritable } = require2("./utils");
        const {
          AbortError,
          codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
        } = require2("../../ours/errors");
        module2.exports = function compose(...streams) {
          if (streams.length === 0) {
            throw new ERR_MISSING_ARGS("streams");
          }
          if (streams.length === 1) {
            return Duplex.from(streams[0]);
          }
          const orgStreams = [...streams];
          if (typeof streams[0] === "function") {
            streams[0] = Duplex.from(streams[0]);
          }
          if (typeof streams[streams.length - 1] === "function") {
            const idx = streams.length - 1;
            streams[idx] = Duplex.from(streams[idx]);
          }
          for (let n = 0; n < streams.length; ++n) {
            if (!isNodeStream(streams[n])) {
              continue;
            }
            if (n < streams.length - 1 && !isReadable(streams[n])) {
              throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
            }
            if (n > 0 && !isWritable(streams[n])) {
              throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
            }
          }
          let ondrain;
          let onfinish;
          let onreadable;
          let onclose;
          let d;
          function onfinished(err) {
            const cb = onclose;
            onclose = null;
            if (cb) {
              cb(err);
            } else if (err) {
              d.destroy(err);
            } else if (!readable && !writable) {
              d.destroy();
            }
          }
          const head = streams[0];
          const tail = pipeline(streams, onfinished);
          const writable = !!isWritable(head);
          const readable = !!isReadable(tail);
          d = new Duplex({
            // TODO (ronag): highWaterMark?
            writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
            readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),
            writable,
            readable
          });
          if (writable) {
            d._write = function(chunk, encoding2, callback) {
              if (head.write(chunk, encoding2)) {
                callback();
              } else {
                ondrain = callback;
              }
            };
            d._final = function(callback) {
              head.end();
              onfinish = callback;
            };
            head.on("drain", function() {
              if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
              }
            });
            tail.on("finish", function() {
              if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
              }
            });
          }
          if (readable) {
            tail.on("readable", function() {
              if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
              }
            });
            tail.on("end", function() {
              d.push(null);
            });
            d._read = function() {
              while (true) {
                const buf = tail.read();
                if (buf === null) {
                  onreadable = d._read;
                  return;
                }
                if (!d.push(buf)) {
                  return;
                }
              }
            };
          }
          d._destroy = function(err, callback) {
            if (!err && onclose !== null) {
              err = new AbortError();
            }
            onreadable = null;
            ondrain = null;
            onfinish = null;
            if (onclose === null) {
              callback(err);
            } else {
              onclose = callback;
              destroyer(tail, err);
            }
          };
          return d;
        };
      }, { "../../ours/errors": 117, "./destroy": 101, "./duplex": 102, "./pipeline": 109, "./utils": 113 }], 101: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            const {
              aggregateTwoErrors,
              codes: { ERR_MULTIPLE_CALLBACK },
              AbortError
            } = require2("../../ours/errors");
            const { Symbol: Symbol2 } = require2("../../ours/primordials");
            const { kDestroyed, isDestroyed, isFinished, isServerRequest } = require2("./utils");
            const kDestroy = Symbol2("kDestroy");
            const kConstruct = Symbol2("kConstruct");
            function checkError(err, w, r) {
              if (err) {
                err.stack;
                if (w && !w.errored) {
                  w.errored = err;
                }
                if (r && !r.errored) {
                  r.errored = err;
                }
              }
            }
            function destroy(err, cb) {
              const r = this._readableState;
              const w = this._writableState;
              const s = w || r;
              if (w && w.destroyed || r && r.destroyed) {
                if (typeof cb === "function") {
                  cb();
                }
                return this;
              }
              checkError(err, w, r);
              if (w) {
                w.destroyed = true;
              }
              if (r) {
                r.destroyed = true;
              }
              if (!s.constructed) {
                this.once(kDestroy, function(er) {
                  _destroy(this, aggregateTwoErrors(er, err), cb);
                });
              } else {
                _destroy(this, err, cb);
              }
              return this;
            }
            function _destroy(self2, err, cb) {
              let called = false;
              function onDestroy(err2) {
                if (called) {
                  return;
                }
                called = true;
                const r = self2._readableState;
                const w = self2._writableState;
                checkError(err2, w, r);
                if (w) {
                  w.closed = true;
                }
                if (r) {
                  r.closed = true;
                }
                if (typeof cb === "function") {
                  cb(err2);
                }
                if (err2) {
                  process.nextTick(emitErrorCloseNT, self2, err2);
                } else {
                  process.nextTick(emitCloseNT, self2);
                }
              }
              try {
                self2._destroy(err || null, onDestroy);
              } catch (err2) {
                onDestroy(err2);
              }
            }
            function emitErrorCloseNT(self2, err) {
              emitErrorNT(self2, err);
              emitCloseNT(self2);
            }
            function emitCloseNT(self2) {
              const r = self2._readableState;
              const w = self2._writableState;
              if (w) {
                w.closeEmitted = true;
              }
              if (r) {
                r.closeEmitted = true;
              }
              if (w && w.emitClose || r && r.emitClose) {
                self2.emit("close");
              }
            }
            function emitErrorNT(self2, err) {
              const r = self2._readableState;
              const w = self2._writableState;
              if (w && w.errorEmitted || r && r.errorEmitted) {
                return;
              }
              if (w) {
                w.errorEmitted = true;
              }
              if (r) {
                r.errorEmitted = true;
              }
              self2.emit("error", err);
            }
            function undestroy() {
              const r = this._readableState;
              const w = this._writableState;
              if (r) {
                r.constructed = true;
                r.closed = false;
                r.closeEmitted = false;
                r.destroyed = false;
                r.errored = null;
                r.errorEmitted = false;
                r.reading = false;
                r.ended = r.readable === false;
                r.endEmitted = r.readable === false;
              }
              if (w) {
                w.constructed = true;
                w.destroyed = false;
                w.closed = false;
                w.closeEmitted = false;
                w.errored = null;
                w.errorEmitted = false;
                w.finalCalled = false;
                w.prefinished = false;
                w.ended = w.writable === false;
                w.ending = w.writable === false;
                w.finished = w.writable === false;
              }
            }
            function errorOrDestroy(stream, err, sync) {
              const r = stream._readableState;
              const w = stream._writableState;
              if (w && w.destroyed || r && r.destroyed) {
                return this;
              }
              if (r && r.autoDestroy || w && w.autoDestroy)
                stream.destroy(err);
              else if (err) {
                err.stack;
                if (w && !w.errored) {
                  w.errored = err;
                }
                if (r && !r.errored) {
                  r.errored = err;
                }
                if (sync) {
                  process.nextTick(emitErrorNT, stream, err);
                } else {
                  emitErrorNT(stream, err);
                }
              }
            }
            function construct(stream, cb) {
              if (typeof stream._construct !== "function") {
                return;
              }
              const r = stream._readableState;
              const w = stream._writableState;
              if (r) {
                r.constructed = false;
              }
              if (w) {
                w.constructed = false;
              }
              stream.once(kConstruct, cb);
              if (stream.listenerCount(kConstruct) > 1) {
                return;
              }
              process.nextTick(constructNT, stream);
            }
            function constructNT(stream) {
              let called = false;
              function onConstruct(err) {
                if (called) {
                  errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
                  return;
                }
                called = true;
                const r = stream._readableState;
                const w = stream._writableState;
                const s = w || r;
                if (r) {
                  r.constructed = true;
                }
                if (w) {
                  w.constructed = true;
                }
                if (s.destroyed) {
                  stream.emit(kDestroy, err);
                } else if (err) {
                  errorOrDestroy(stream, err, true);
                } else {
                  process.nextTick(emitConstructNT, stream);
                }
              }
              try {
                stream._construct(onConstruct);
              } catch (err) {
                onConstruct(err);
              }
            }
            function emitConstructNT(stream) {
              stream.emit(kConstruct);
            }
            function isRequest(stream) {
              return stream && stream.setHeader && typeof stream.abort === "function";
            }
            function emitCloseLegacy(stream) {
              stream.emit("close");
            }
            function emitErrorCloseLegacy(stream, err) {
              stream.emit("error", err);
              process.nextTick(emitCloseLegacy, stream);
            }
            function destroyer(stream, err) {
              if (!stream || isDestroyed(stream)) {
                return;
              }
              if (!err && !isFinished(stream)) {
                err = new AbortError();
              }
              if (isServerRequest(stream)) {
                stream.socket = null;
                stream.destroy(err);
              } else if (isRequest(stream)) {
                stream.abort();
              } else if (isRequest(stream.req)) {
                stream.req.abort();
              } else if (typeof stream.destroy === "function") {
                stream.destroy(err);
              } else if (typeof stream.close === "function") {
                stream.close();
              } else if (err) {
                process.nextTick(emitErrorCloseLegacy, stream);
              } else {
                process.nextTick(emitCloseLegacy, stream);
              }
              if (!stream.destroyed) {
                stream[kDestroyed] = true;
              }
            }
            module2.exports = {
              construct,
              destroyer,
              destroy,
              undestroy,
              errorOrDestroy
            };
          }).call(this);
        }).call(this, require2("_process"));
      }, { "../../ours/errors": 117, "../../ours/primordials": 118, "./utils": 113, "_process": 93 }], 102: [function(require2, module2, exports2) {
        const {
          ObjectDefineProperties,
          ObjectGetOwnPropertyDescriptor,
          ObjectKeys,
          ObjectSetPrototypeOf
        } = require2("../../ours/primordials");
        module2.exports = Duplex;
        const Readable = require2("./readable");
        const Writable = require2("./writable");
        ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
        ObjectSetPrototypeOf(Duplex, Readable);
        {
          const keys = ObjectKeys(Writable.prototype);
          for (let i = 0; i < keys.length; i++) {
            const method = keys[i];
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method];
          }
        }
        function Duplex(options) {
          if (!(this instanceof Duplex))
            return new Duplex(options);
          Readable.call(this, options);
          Writable.call(this, options);
          if (options) {
            this.allowHalfOpen = options.allowHalfOpen !== false;
            if (options.readable === false) {
              this._readableState.readable = false;
              this._readableState.ended = true;
              this._readableState.endEmitted = true;
            }
            if (options.writable === false) {
              this._writableState.writable = false;
              this._writableState.ending = true;
              this._writableState.ended = true;
              this._writableState.finished = true;
            }
          } else {
            this.allowHalfOpen = true;
          }
        }
        ObjectDefineProperties(Duplex.prototype, {
          writable: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable"),
          writableHighWaterMark: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark"),
          writableObjectMode: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode"),
          writableBuffer: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer"),
          writableLength: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength"),
          writableFinished: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished"),
          writableCorked: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked"),
          writableEnded: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded"),
          writableNeedDrain: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain"),
          destroyed: {
            get() {
              if (this._readableState === void 0 || this._writableState === void 0) {
                return false;
              }
              return this._readableState.destroyed && this._writableState.destroyed;
            },
            set(value) {
              if (this._readableState && this._writableState) {
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
              }
            }
          }
        });
        let webStreamsAdapters;
        function lazyWebStreams() {
          if (webStreamsAdapters === void 0)
            webStreamsAdapters = {};
          return webStreamsAdapters;
        }
        Duplex.fromWeb = function(pair, options) {
          return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
        };
        Duplex.toWeb = function(duplex) {
          return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
        };
        let duplexify;
        Duplex.from = function(body) {
          if (!duplexify) {
            duplexify = require2("./duplexify");
          }
          return duplexify(body, "body");
        };
      }, { "../../ours/primordials": 118, "./duplexify": 103, "./readable": 110, "./writable": 114 }], 103: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            const bufferModule = require2("buffer");
            const {
              isReadable,
              isWritable,
              isIterable,
              isNodeStream,
              isReadableNodeStream,
              isWritableNodeStream,
              isDuplexNodeStream
            } = require2("./utils");
            const eos = require2("./end-of-stream");
            const {
              AbortError,
              codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
            } = require2("../../ours/errors");
            const { destroyer } = require2("./destroy");
            const Duplex = require2("./duplex");
            const Readable = require2("./readable");
            const { createDeferredPromise } = require2("../../ours/util");
            const from = require2("./from");
            const Blob = globalThis.Blob || bufferModule.Blob;
            const isBlob = typeof Blob !== "undefined" ? function isBlob2(b) {
              return b instanceof Blob;
            } : function isBlob2(b) {
              return false;
            };
            const AbortController = globalThis.AbortController || require2("abort-controller").AbortController;
            const { FunctionPrototypeCall } = require2("../../ours/primordials");
            class Duplexify extends Duplex {
              constructor(options) {
                super(options);
                if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
                  this._readableState.readable = false;
                  this._readableState.ended = true;
                  this._readableState.endEmitted = true;
                }
                if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
                  this._writableState.writable = false;
                  this._writableState.ending = true;
                  this._writableState.ended = true;
                  this._writableState.finished = true;
                }
              }
            }
            module2.exports = function duplexify(body, name2) {
              if (isDuplexNodeStream(body)) {
                return body;
              }
              if (isReadableNodeStream(body)) {
                return _duplexify({
                  readable: body
                });
              }
              if (isWritableNodeStream(body)) {
                return _duplexify({
                  writable: body
                });
              }
              if (isNodeStream(body)) {
                return _duplexify({
                  writable: false,
                  readable: false
                });
              }
              if (typeof body === "function") {
                const { value, write, final, destroy } = fromAsyncGen(body);
                if (isIterable(value)) {
                  return from(Duplexify, value, {
                    // TODO (ronag): highWaterMark?
                    objectMode: true,
                    write,
                    final,
                    destroy
                  });
                }
                const then2 = value === null || value === void 0 ? void 0 : value.then;
                if (typeof then2 === "function") {
                  let d;
                  const promise = FunctionPrototypeCall(
                    then2,
                    value,
                    (val) => {
                      if (val != null) {
                        throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
                      }
                    },
                    (err) => {
                      destroyer(d, err);
                    }
                  );
                  return d = new Duplexify({
                    // TODO (ronag): highWaterMark?
                    objectMode: true,
                    readable: false,
                    write,
                    final(cb) {
                      final(async () => {
                        try {
                          await promise;
                          process.nextTick(cb, null);
                        } catch (err) {
                          process.nextTick(cb, err);
                        }
                      });
                    },
                    destroy
                  });
                }
                throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name2, value);
              }
              if (isBlob(body)) {
                return duplexify(body.arrayBuffer());
              }
              if (isIterable(body)) {
                return from(Duplexify, body, {
                  // TODO (ronag): highWaterMark?
                  objectMode: true,
                  writable: false
                });
              }
              if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
                const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
                const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
                return _duplexify({
                  readable,
                  writable
                });
              }
              const then = body === null || body === void 0 ? void 0 : body.then;
              if (typeof then === "function") {
                let d;
                FunctionPrototypeCall(
                  then,
                  body,
                  (val) => {
                    if (val != null) {
                      d.push(val);
                    }
                    d.push(null);
                  },
                  (err) => {
                    destroyer(d, err);
                  }
                );
                return d = new Duplexify({
                  objectMode: true,
                  writable: false,
                  read() {
                  }
                });
              }
              throw new ERR_INVALID_ARG_TYPE(
                name2,
                [
                  "Blob",
                  "ReadableStream",
                  "WritableStream",
                  "Stream",
                  "Iterable",
                  "AsyncIterable",
                  "Function",
                  "{ readable, writable } pair",
                  "Promise"
                ],
                body
              );
            };
            function fromAsyncGen(fn) {
              let { promise, resolve } = createDeferredPromise();
              const ac = new AbortController();
              const signal = ac.signal;
              const value = fn(
                async function* () {
                  while (true) {
                    const _promise = promise;
                    promise = null;
                    const { chunk, done, cb } = await _promise;
                    process.nextTick(cb);
                    if (done)
                      return;
                    if (signal.aborted)
                      throw new AbortError(void 0, {
                        cause: signal.reason
                      });
                    ({ promise, resolve } = createDeferredPromise());
                    yield chunk;
                  }
                }(),
                {
                  signal
                }
              );
              return {
                value,
                write(chunk, encoding2, cb) {
                  const _resolve = resolve;
                  resolve = null;
                  _resolve({
                    chunk,
                    done: false,
                    cb
                  });
                },
                final(cb) {
                  const _resolve = resolve;
                  resolve = null;
                  _resolve({
                    done: true,
                    cb
                  });
                },
                destroy(err, cb) {
                  ac.abort();
                  cb(err);
                }
              };
            }
            function _duplexify(pair) {
              const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
              const w = pair.writable;
              let readable = !!isReadable(r);
              let writable = !!isWritable(w);
              let ondrain;
              let onfinish;
              let onreadable;
              let onclose;
              let d;
              function onfinished(err) {
                const cb = onclose;
                onclose = null;
                if (cb) {
                  cb(err);
                } else if (err) {
                  d.destroy(err);
                } else if (!readable && !writable) {
                  d.destroy();
                }
              }
              d = new Duplexify({
                // TODO (ronag): highWaterMark?
                readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
                writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
                readable,
                writable
              });
              if (writable) {
                eos(w, (err) => {
                  writable = false;
                  if (err) {
                    destroyer(r, err);
                  }
                  onfinished(err);
                });
                d._write = function(chunk, encoding2, callback) {
                  if (w.write(chunk, encoding2)) {
                    callback();
                  } else {
                    ondrain = callback;
                  }
                };
                d._final = function(callback) {
                  w.end();
                  onfinish = callback;
                };
                w.on("drain", function() {
                  if (ondrain) {
                    const cb = ondrain;
                    ondrain = null;
                    cb();
                  }
                });
                w.on("finish", function() {
                  if (onfinish) {
                    const cb = onfinish;
                    onfinish = null;
                    cb();
                  }
                });
              }
              if (readable) {
                eos(r, (err) => {
                  readable = false;
                  if (err) {
                    destroyer(r, err);
                  }
                  onfinished(err);
                });
                r.on("readable", function() {
                  if (onreadable) {
                    const cb = onreadable;
                    onreadable = null;
                    cb();
                  }
                });
                r.on("end", function() {
                  d.push(null);
                });
                d._read = function() {
                  while (true) {
                    const buf = r.read();
                    if (buf === null) {
                      onreadable = d._read;
                      return;
                    }
                    if (!d.push(buf)) {
                      return;
                    }
                  }
                };
              }
              d._destroy = function(err, callback) {
                if (!err && onclose !== null) {
                  err = new AbortError();
                }
                onreadable = null;
                ondrain = null;
                onfinish = null;
                if (onclose === null) {
                  callback(err);
                } else {
                  onclose = callback;
                  destroyer(w, err);
                  destroyer(r, err);
                }
              };
              return d;
            }
          }).call(this);
        }).call(this, require2("_process"));
      }, { "../../ours/errors": 117, "../../ours/primordials": 118, "../../ours/util": 119, "./destroy": 101, "./duplex": 102, "./end-of-stream": 104, "./from": 105, "./readable": 110, "./utils": 113, "_process": 93, "abort-controller": 15, "buffer": 20 }], 104: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            const { AbortError, codes } = require2("../../ours/errors");
            const { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
            const { once } = require2("../../ours/util");
            const { validateAbortSignal, validateFunction, validateObject } = require2("../validators");
            const { Promise: Promise2 } = require2("../../ours/primordials");
            const {
              isClosed,
              isReadable,
              isReadableNodeStream,
              isReadableFinished,
              isReadableErrored,
              isWritable,
              isWritableNodeStream,
              isWritableFinished,
              isWritableErrored,
              isNodeStream,
              willEmitClose: _willEmitClose
            } = require2("./utils");
            function isRequest(stream) {
              return stream.setHeader && typeof stream.abort === "function";
            }
            const nop = () => {
            };
            function eos(stream, options, callback) {
              var _options$readable, _options$writable;
              if (arguments.length === 2) {
                callback = options;
                options = {};
              } else if (options == null) {
                options = {};
              } else {
                validateObject(options, "options");
              }
              validateFunction(callback, "callback");
              validateAbortSignal(options.signal, "options.signal");
              callback = once(callback);
              const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
              const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
              if (!isNodeStream(stream)) {
                throw new ERR_INVALID_ARG_TYPE("stream", "Stream", stream);
              }
              const wState = stream._writableState;
              const rState = stream._readableState;
              const onlegacyfinish = () => {
                if (!stream.writable) {
                  onfinish();
                }
              };
              let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
              let writableFinished = isWritableFinished(stream, false);
              const onfinish = () => {
                writableFinished = true;
                if (stream.destroyed) {
                  willEmitClose = false;
                }
                if (willEmitClose && (!stream.readable || readable)) {
                  return;
                }
                if (!readable || readableFinished) {
                  callback.call(stream);
                }
              };
              let readableFinished = isReadableFinished(stream, false);
              const onend = () => {
                readableFinished = true;
                if (stream.destroyed) {
                  willEmitClose = false;
                }
                if (willEmitClose && (!stream.writable || writable)) {
                  return;
                }
                if (!writable || writableFinished) {
                  callback.call(stream);
                }
              };
              const onerror = (err) => {
                callback.call(stream, err);
              };
              let closed = isClosed(stream);
              const onclose = () => {
                closed = true;
                const errored = isWritableErrored(stream) || isReadableErrored(stream);
                if (errored && typeof errored !== "boolean") {
                  return callback.call(stream, errored);
                }
                if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
                  if (!isReadableFinished(stream, false))
                    return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
                }
                if (writable && !writableFinished) {
                  if (!isWritableFinished(stream, false))
                    return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
                }
                callback.call(stream);
              };
              const onrequest = () => {
                stream.req.on("finish", onfinish);
              };
              if (isRequest(stream)) {
                stream.on("complete", onfinish);
                if (!willEmitClose) {
                  stream.on("abort", onclose);
                }
                if (stream.req) {
                  onrequest();
                } else {
                  stream.on("request", onrequest);
                }
              } else if (writable && !wState) {
                stream.on("end", onlegacyfinish);
                stream.on("close", onlegacyfinish);
              }
              if (!willEmitClose && typeof stream.aborted === "boolean") {
                stream.on("aborted", onclose);
              }
              stream.on("end", onend);
              stream.on("finish", onfinish);
              if (options.error !== false) {
                stream.on("error", onerror);
              }
              stream.on("close", onclose);
              if (closed) {
                process.nextTick(onclose);
              } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
                if (!willEmitClose) {
                  process.nextTick(onclose);
                }
              } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
                process.nextTick(onclose);
              } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
                process.nextTick(onclose);
              } else if (rState && stream.req && stream.aborted) {
                process.nextTick(onclose);
              }
              const cleanup = () => {
                callback = nop;
                stream.removeListener("aborted", onclose);
                stream.removeListener("complete", onfinish);
                stream.removeListener("abort", onclose);
                stream.removeListener("request", onrequest);
                if (stream.req)
                  stream.req.removeListener("finish", onfinish);
                stream.removeListener("end", onlegacyfinish);
                stream.removeListener("close", onlegacyfinish);
                stream.removeListener("finish", onfinish);
                stream.removeListener("end", onend);
                stream.removeListener("error", onerror);
                stream.removeListener("close", onclose);
              };
              if (options.signal && !closed) {
                const abort = () => {
                  const endCallback = callback;
                  cleanup();
                  endCallback.call(
                    stream,
                    new AbortError(void 0, {
                      cause: options.signal.reason
                    })
                  );
                };
                if (options.signal.aborted) {
                  process.nextTick(abort);
                } else {
                  const originalCallback = callback;
                  callback = once((...args) => {
                    options.signal.removeEventListener("abort", abort);
                    originalCallback.apply(stream, args);
                  });
                  options.signal.addEventListener("abort", abort);
                }
              }
              return cleanup;
            }
            function finished(stream, opts) {
              return new Promise2((resolve, reject) => {
                eos(stream, opts, (err) => {
                  if (err) {
                    reject(err);
                  } else {
                    resolve();
                  }
                });
              });
            }
            module2.exports = eos;
            module2.exports.finished = finished;
          }).call(this);
        }).call(this, require2("_process"));
      }, { "../../ours/errors": 117, "../../ours/primordials": 118, "../../ours/util": 119, "../validators": 115, "./utils": 113, "_process": 93 }], 105: [function(require2, module2, exports2) {
        (function(process, Buffer) {
          (function() {
            const { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require2("../../ours/primordials");
            const { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require2("../../ours/errors").codes;
            function from(Readable, iterable, opts) {
              let iterator;
              if (typeof iterable === "string" || iterable instanceof Buffer) {
                return new Readable({
                  objectMode: true,
                  ...opts,
                  read() {
                    this.push(iterable);
                    this.push(null);
                  }
                });
              }
              let isAsync;
              if (iterable && iterable[SymbolAsyncIterator]) {
                isAsync = true;
                iterator = iterable[SymbolAsyncIterator]();
              } else if (iterable && iterable[SymbolIterator]) {
                isAsync = false;
                iterator = iterable[SymbolIterator]();
              } else {
                throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
              }
              const readable = new Readable({
                objectMode: true,
                highWaterMark: 1,
                // TODO(ronag): What options should be allowed?
                ...opts
              });
              let reading = false;
              readable._read = function() {
                if (!reading) {
                  reading = true;
                  next();
                }
              };
              readable._destroy = function(error, cb) {
                PromisePrototypeThen(
                  close(error),
                  () => process.nextTick(cb, error),
                  // nextTick is here in case cb throws
                  (e) => process.nextTick(cb, e || error)
                );
              };
              async function close(error) {
                const hadError = error !== void 0 && error !== null;
                const hasThrow = typeof iterator.throw === "function";
                if (hadError && hasThrow) {
                  const { value, done } = await iterator.throw(error);
                  await value;
                  if (done) {
                    return;
                  }
                }
                if (typeof iterator.return === "function") {
                  const { value } = await iterator.return();
                  await value;
                }
              }
              async function next() {
                for (; ; ) {
                  try {
                    const { value, done } = isAsync ? await iterator.next() : iterator.next();
                    if (done) {
                      readable.push(null);
                    } else {
                      const res = value && typeof value.then === "function" ? await value : value;
                      if (res === null) {
                        reading = false;
                        throw new ERR_STREAM_NULL_VALUES();
                      } else if (readable.push(res)) {
                        continue;
                      } else {
                        reading = false;
                      }
                    }
                  } catch (err) {
                    readable.destroy(err);
                  }
                  break;
                }
              }
              return readable;
            }
            module2.exports = from;
          }).call(this);
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "../../ours/errors": 117, "../../ours/primordials": 118, "_process": 93, "buffer": 20 }], 106: [function(require2, module2, exports2) {
        const { ArrayIsArray, ObjectSetPrototypeOf } = require2("../../ours/primordials");
        const { EventEmitter: EE } = require2("events");
        function Stream(opts) {
          EE.call(this, opts);
        }
        ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
        ObjectSetPrototypeOf(Stream, EE);
        Stream.prototype.pipe = function(dest, options) {
          const source = this;
          function ondata(chunk) {
            if (dest.writable && dest.write(chunk) === false && source.pause) {
              source.pause();
            }
          }
          source.on("data", ondata);
          function ondrain() {
            if (source.readable && source.resume) {
              source.resume();
            }
          }
          dest.on("drain", ondrain);
          if (!dest._isStdio && (!options || options.end !== false)) {
            source.on("end", onend);
            source.on("close", onclose);
          }
          let didOnEnd = false;
          function onend() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            dest.end();
          }
          function onclose() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            if (typeof dest.destroy === "function")
              dest.destroy();
          }
          function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, "error") === 0) {
              this.emit("error", er);
            }
          }
          prependListener(source, "error", onerror);
          prependListener(dest, "error", onerror);
          function cleanup() {
            source.removeListener("data", ondata);
            dest.removeListener("drain", ondrain);
            source.removeListener("end", onend);
            source.removeListener("close", onclose);
            source.removeListener("error", onerror);
            dest.removeListener("error", onerror);
            source.removeListener("end", cleanup);
            source.removeListener("close", cleanup);
            dest.removeListener("close", cleanup);
          }
          source.on("end", cleanup);
          source.on("close", cleanup);
          dest.on("close", cleanup);
          dest.emit("pipe", source);
          return dest;
        };
        function prependListener(emitter, event, fn) {
          if (typeof emitter.prependListener === "function")
            return emitter.prependListener(event, fn);
          if (!emitter._events || !emitter._events[event])
            emitter.on(event, fn);
          else if (ArrayIsArray(emitter._events[event]))
            emitter._events[event].unshift(fn);
          else
            emitter._events[event] = [fn, emitter._events[event]];
        }
        module2.exports = {
          Stream,
          prependListener
        };
      }, { "../../ours/primordials": 118, "events": 40 }], 107: [function(require2, module2, exports2) {
        const AbortController = globalThis.AbortController || require2("abort-controller").AbortController;
        const {
          codes: { ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
          AbortError
        } = require2("../../ours/errors");
        const { validateAbortSignal, validateInteger, validateObject } = require2("../validators");
        const kWeakHandler = require2("../../ours/primordials").Symbol("kWeak");
        const { finished } = require2("./end-of-stream");
        const {
          ArrayPrototypePush,
          MathFloor,
          Number: Number2,
          NumberIsNaN,
          Promise: Promise2,
          PromiseReject,
          PromisePrototypeCatch,
          Symbol: Symbol2
        } = require2("../../ours/primordials");
        const kEmpty = Symbol2("kEmpty");
        const kEof = Symbol2("kEof");
        function map(fn, options) {
          if (typeof fn !== "function") {
            throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
          }
          if (options != null) {
            validateObject(options, "options");
          }
          if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
            validateAbortSignal(options.signal, "options.signal");
          }
          let concurrency = 1;
          if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
            concurrency = MathFloor(options.concurrency);
          }
          validateInteger(concurrency, "concurrency", 1);
          return async function* map2() {
            var _options$signal, _options$signal2;
            const ac = new AbortController();
            const stream = this;
            const queue = [];
            const signal = ac.signal;
            const signalOpt = {
              signal
            };
            const abort = () => ac.abort();
            if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
              abort();
            }
            options === null || options === void 0 ? void 0 : (_options$signal2 = options.signal) === null || _options$signal2 === void 0 ? void 0 : _options$signal2.addEventListener("abort", abort);
            let next;
            let resume;
            let done = false;
            function onDone() {
              done = true;
            }
            async function pump() {
              try {
                for await (let val of stream) {
                  var _val;
                  if (done) {
                    return;
                  }
                  if (signal.aborted) {
                    throw new AbortError();
                  }
                  try {
                    val = fn(val, signalOpt);
                  } catch (err) {
                    val = PromiseReject(err);
                  }
                  if (val === kEmpty) {
                    continue;
                  }
                  if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === "function") {
                    val.catch(onDone);
                  }
                  queue.push(val);
                  if (next) {
                    next();
                    next = null;
                  }
                  if (!done && queue.length && queue.length >= concurrency) {
                    await new Promise2((resolve) => {
                      resume = resolve;
                    });
                  }
                }
                queue.push(kEof);
              } catch (err) {
                const val = PromiseReject(err);
                PromisePrototypeCatch(val, onDone);
                queue.push(val);
              } finally {
                var _options$signal3;
                done = true;
                if (next) {
                  next();
                  next = null;
                }
                options === null || options === void 0 ? void 0 : (_options$signal3 = options.signal) === null || _options$signal3 === void 0 ? void 0 : _options$signal3.removeEventListener("abort", abort);
              }
            }
            pump();
            try {
              while (true) {
                while (queue.length > 0) {
                  const val = await queue[0];
                  if (val === kEof) {
                    return;
                  }
                  if (signal.aborted) {
                    throw new AbortError();
                  }
                  if (val !== kEmpty) {
                    yield val;
                  }
                  queue.shift();
                  if (resume) {
                    resume();
                    resume = null;
                  }
                }
                await new Promise2((resolve) => {
                  next = resolve;
                });
              }
            } finally {
              ac.abort();
              done = true;
              if (resume) {
                resume();
                resume = null;
              }
            }
          }.call(this);
        }
        function asIndexedPairs(options = void 0) {
          if (options != null) {
            validateObject(options, "options");
          }
          if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
            validateAbortSignal(options.signal, "options.signal");
          }
          return async function* asIndexedPairs2() {
            let index2 = 0;
            for await (const val of this) {
              var _options$signal4;
              if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
                throw new AbortError({
                  cause: options.signal.reason
                });
              }
              yield [index2++, val];
            }
          }.call(this);
        }
        async function some(fn, options = void 0) {
          for await (const unused of filter.call(this, fn, options)) {
            return true;
          }
          return false;
        }
        async function every(fn, options = void 0) {
          if (typeof fn !== "function") {
            throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
          }
          return !await some.call(
            this,
            async (...args) => {
              return !await fn(...args);
            },
            options
          );
        }
        async function find(fn, options) {
          for await (const result of filter.call(this, fn, options)) {
            return result;
          }
          return void 0;
        }
        async function forEach(fn, options) {
          if (typeof fn !== "function") {
            throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
          }
          async function forEachFn(value, options2) {
            await fn(value, options2);
            return kEmpty;
          }
          for await (const unused of map.call(this, forEachFn, options))
            ;
        }
        function filter(fn, options) {
          if (typeof fn !== "function") {
            throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
          }
          async function filterFn(value, options2) {
            if (await fn(value, options2)) {
              return value;
            }
            return kEmpty;
          }
          return map.call(this, filterFn, options);
        }
        class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
          constructor() {
            super("reduce");
            this.message = "Reduce of an empty stream requires an initial value";
          }
        }
        async function reduce(reducer, initialValue, options) {
          var _options$signal5;
          if (typeof reducer !== "function") {
            throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
          }
          if (options != null) {
            validateObject(options, "options");
          }
          if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
            validateAbortSignal(options.signal, "options.signal");
          }
          let hasInitialValue = arguments.length > 1;
          if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
            const err = new AbortError(void 0, {
              cause: options.signal.reason
            });
            this.once("error", () => {
            });
            await finished(this.destroy(err));
            throw err;
          }
          const ac = new AbortController();
          const signal = ac.signal;
          if (options !== null && options !== void 0 && options.signal) {
            const opts = {
              once: true,
              [kWeakHandler]: this
            };
            options.signal.addEventListener("abort", () => ac.abort(), opts);
          }
          let gotAnyItemFromStream = false;
          try {
            for await (const value of this) {
              var _options$signal6;
              gotAnyItemFromStream = true;
              if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
                throw new AbortError();
              }
              if (!hasInitialValue) {
                initialValue = value;
                hasInitialValue = true;
              } else {
                initialValue = await reducer(initialValue, value, {
                  signal
                });
              }
            }
            if (!gotAnyItemFromStream && !hasInitialValue) {
              throw new ReduceAwareErrMissingArgs();
            }
          } finally {
            ac.abort();
          }
          return initialValue;
        }
        async function toArray(options) {
          if (options != null) {
            validateObject(options, "options");
          }
          if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
            validateAbortSignal(options.signal, "options.signal");
          }
          const result = [];
          for await (const val of this) {
            var _options$signal7;
            if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
              throw new AbortError(void 0, {
                cause: options.signal.reason
              });
            }
            ArrayPrototypePush(result, val);
          }
          return result;
        }
        function flatMap(fn, options) {
          const values = map.call(this, fn, options);
          return async function* flatMap2() {
            for await (const val of values) {
              yield* val;
            }
          }.call(this);
        }
        function toIntegerOrInfinity(number) {
          number = Number2(number);
          if (NumberIsNaN(number)) {
            return 0;
          }
          if (number < 0) {
            throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
          }
          return number;
        }
        function drop(number, options = void 0) {
          if (options != null) {
            validateObject(options, "options");
          }
          if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
            validateAbortSignal(options.signal, "options.signal");
          }
          number = toIntegerOrInfinity(number);
          return async function* drop2() {
            var _options$signal8;
            if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
              throw new AbortError();
            }
            for await (const val of this) {
              var _options$signal9;
              if (options !== null && options !== void 0 && (_options$signal9 = options.signal) !== null && _options$signal9 !== void 0 && _options$signal9.aborted) {
                throw new AbortError();
              }
              if (number-- <= 0) {
                yield val;
              }
            }
          }.call(this);
        }
        function take(number, options = void 0) {
          if (options != null) {
            validateObject(options, "options");
          }
          if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
            validateAbortSignal(options.signal, "options.signal");
          }
          number = toIntegerOrInfinity(number);
          return async function* take2() {
            var _options$signal10;
            if (options !== null && options !== void 0 && (_options$signal10 = options.signal) !== null && _options$signal10 !== void 0 && _options$signal10.aborted) {
              throw new AbortError();
            }
            for await (const val of this) {
              var _options$signal11;
              if (options !== null && options !== void 0 && (_options$signal11 = options.signal) !== null && _options$signal11 !== void 0 && _options$signal11.aborted) {
                throw new AbortError();
              }
              if (number-- > 0) {
                yield val;
              } else {
                return;
              }
            }
          }.call(this);
        }
        module2.exports.streamReturningOperators = {
          asIndexedPairs,
          drop,
          filter,
          flatMap,
          map,
          take
        };
        module2.exports.promiseReturningOperators = {
          every,
          forEach,
          reduce,
          toArray,
          some,
          find
        };
      }, { "../../ours/errors": 117, "../../ours/primordials": 118, "../validators": 115, "./end-of-stream": 104, "abort-controller": 15 }], 108: [function(require2, module2, exports2) {
        const { ObjectSetPrototypeOf } = require2("../../ours/primordials");
        module2.exports = PassThrough;
        const Transform = require2("./transform");
        ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
        ObjectSetPrototypeOf(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding2, cb) {
          cb(null, chunk);
        };
      }, { "../../ours/primordials": 118, "./transform": 112 }], 109: [function(require2, module2, exports2) {
        (function(process) {
          (function() {
            const { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require2("../../ours/primordials");
            const eos = require2("./end-of-stream");
            const { once } = require2("../../ours/util");
            const destroyImpl = require2("./destroy");
            const Duplex = require2("./duplex");
            const {
              aggregateTwoErrors,
              codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED },
              AbortError
            } = require2("../../ours/errors");
            const { validateFunction, validateAbortSignal } = require2("../validators");
            const { isIterable, isReadable, isReadableNodeStream, isNodeStream } = require2("./utils");
            const AbortController = globalThis.AbortController || require2("abort-controller").AbortController;
            let PassThrough;
            let Readable;
            function destroyer(stream, reading, writing) {
              let finished = false;
              stream.on("close", () => {
                finished = true;
              });
              const cleanup = eos(
                stream,
                {
                  readable: reading,
                  writable: writing
                },
                (err) => {
                  finished = !err;
                }
              );
              return {
                destroy: (err) => {
                  if (finished)
                    return;
                  finished = true;
                  destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
                },
                cleanup
              };
            }
            function popCallback(streams) {
              validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
              return streams.pop();
            }
            function makeAsyncIterable(val) {
              if (isIterable(val)) {
                return val;
              } else if (isReadableNodeStream(val)) {
                return fromReadable(val);
              }
              throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
            }
            async function* fromReadable(val) {
              if (!Readable) {
                Readable = require2("./readable");
              }
              yield* Readable.prototype[SymbolAsyncIterator].call(val);
            }
            async function pump(iterable, writable, finish, { end }) {
              let error;
              let onresolve = null;
              const resume = (err) => {
                if (err) {
                  error = err;
                }
                if (onresolve) {
                  const callback = onresolve;
                  onresolve = null;
                  callback();
                }
              };
              const wait = () => new Promise2((resolve, reject) => {
                if (error) {
                  reject(error);
                } else {
                  onresolve = () => {
                    if (error) {
                      reject(error);
                    } else {
                      resolve();
                    }
                  };
                }
              });
              writable.on("drain", resume);
              const cleanup = eos(
                writable,
                {
                  readable: false
                },
                resume
              );
              try {
                if (writable.writableNeedDrain) {
                  await wait();
                }
                for await (const chunk of iterable) {
                  if (!writable.write(chunk)) {
                    await wait();
                  }
                }
                if (end) {
                  writable.end();
                }
                await wait();
                finish();
              } catch (err) {
                finish(error !== err ? aggregateTwoErrors(error, err) : err);
              } finally {
                cleanup();
                writable.off("drain", resume);
              }
            }
            function pipeline(...streams) {
              return pipelineImpl(streams, once(popCallback(streams)));
            }
            function pipelineImpl(streams, callback, opts) {
              if (streams.length === 1 && ArrayIsArray(streams[0])) {
                streams = streams[0];
              }
              if (streams.length < 2) {
                throw new ERR_MISSING_ARGS("streams");
              }
              const ac = new AbortController();
              const signal = ac.signal;
              const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
              const lastStreamCleanup = [];
              validateAbortSignal(outerSignal, "options.signal");
              function abort() {
                finishImpl(new AbortError());
              }
              outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener("abort", abort);
              let error;
              let value;
              const destroys = [];
              let finishCount = 0;
              function finish(err) {
                finishImpl(err, --finishCount === 0);
              }
              function finishImpl(err, final) {
                if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
                  error = err;
                }
                if (!error && !final) {
                  return;
                }
                while (destroys.length) {
                  destroys.shift()(error);
                }
                outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener("abort", abort);
                ac.abort();
                if (final) {
                  if (!error) {
                    lastStreamCleanup.forEach((fn) => fn());
                  }
                  process.nextTick(callback, error, value);
                }
              }
              let ret;
              for (let i = 0; i < streams.length; i++) {
                const stream = streams[i];
                const reading = i < streams.length - 1;
                const writing = i > 0;
                const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
                const isLastStream = i === streams.length - 1;
                if (isNodeStream(stream)) {
                  let onError2 = function(err) {
                    if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                      finish(err);
                    }
                  };
                  if (end) {
                    const { destroy, cleanup } = destroyer(stream, reading, writing);
                    destroys.push(destroy);
                    if (isReadable(stream) && isLastStream) {
                      lastStreamCleanup.push(cleanup);
                    }
                  }
                  stream.on("error", onError2);
                  if (isReadable(stream) && isLastStream) {
                    lastStreamCleanup.push(() => {
                      stream.removeListener("error", onError2);
                    });
                  }
                }
                if (i === 0) {
                  if (typeof stream === "function") {
                    ret = stream({
                      signal
                    });
                    if (!isIterable(ret)) {
                      throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
                    }
                  } else if (isIterable(stream) || isReadableNodeStream(stream)) {
                    ret = stream;
                  } else {
                    ret = Duplex.from(stream);
                  }
                } else if (typeof stream === "function") {
                  ret = makeAsyncIterable(ret);
                  ret = stream(ret, {
                    signal
                  });
                  if (reading) {
                    if (!isIterable(ret, true)) {
                      throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
                    }
                  } else {
                    var _ret;
                    if (!PassThrough) {
                      PassThrough = require2("./passthrough");
                    }
                    const pt = new PassThrough({
                      objectMode: true
                    });
                    const then = (_ret = ret) === null || _ret === void 0 ? void 0 : _ret.then;
                    if (typeof then === "function") {
                      finishCount++;
                      then.call(
                        ret,
                        (val) => {
                          value = val;
                          if (val != null) {
                            pt.write(val);
                          }
                          if (end) {
                            pt.end();
                          }
                          process.nextTick(finish);
                        },
                        (err) => {
                          pt.destroy(err);
                          process.nextTick(finish, err);
                        }
                      );
                    } else if (isIterable(ret, true)) {
                      finishCount++;
                      pump(ret, pt, finish, {
                        end
                      });
                    } else {
                      throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
                    }
                    ret = pt;
                    const { destroy, cleanup } = destroyer(ret, false, true);
                    destroys.push(destroy);
                    if (isLastStream) {
                      lastStreamCleanup.push(cleanup);
                    }
                  }
                } else if (isNodeStream(stream)) {
                  if (isReadableNodeStream(ret)) {
                    finishCount += 2;
                    const cleanup = pipe(ret, stream, finish, {
                      end
                    });
                    if (isReadable(stream) && isLastStream) {
                      lastStreamCleanup.push(cleanup);
                    }
                  } else if (isIterable(ret)) {
                    finishCount++;
                    pump(ret, stream, finish, {
                      end
                    });
                  } else {
                    throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], ret);
                  }
                  ret = stream;
                } else {
                  ret = Duplex.from(stream);
                }
              }
              if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
                process.nextTick(abort);
              }
              return ret;
            }
            function pipe(src2, dst, finish, { end }) {
              src2.pipe(dst, {
                end
              });
              if (end) {
                src2.once("end", () => dst.end());
              } else {
                finish();
              }
              eos(
                src2,
                {
                  readable: true,
                  writable: false
                },
                (err) => {
                  const rState = src2._readableState;
                  if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
                    src2.once("end", finish).once("error", finish);
                  } else {
                    finish(err);
                  }
                }
              );
              return eos(
                dst,
                {
                  readable: false,
                  writable: true
                },
                finish
              );
            }
            module2.exports = {
              pipelineImpl,
              pipeline
            };
          }).call(this);
        }).call(this, require2("_process"));
      }, { "../../ours/errors": 117, "../../ours/primordials": 118, "../../ours/util": 119, "../validators": 115, "./destroy": 101, "./duplex": 102, "./end-of-stream": 104, "./passthrough": 108, "./readable": 110, "./utils": 113, "_process": 93, "abort-controller": 15 }], 110: [function(require2, module2, exports2) {
        (function(process, Buffer) {
          (function() {
            const {
              ArrayPrototypeIndexOf,
              NumberIsInteger,
              NumberIsNaN,
              NumberParseInt,
              ObjectDefineProperties,
              ObjectKeys,
              ObjectSetPrototypeOf,
              Promise: Promise2,
              SafeSet,
              SymbolAsyncIterator,
              Symbol: Symbol2
            } = require2("../../ours/primordials");
            module2.exports = Readable;
            Readable.ReadableState = ReadableState;
            const { EventEmitter: EE } = require2("events");
            const { Stream, prependListener } = require2("./legacy");
            const { addAbortSignal } = require2("./add-abort-signal");
            const eos = require2("./end-of-stream");
            let debug = require2("../../ours/util").debuglog("stream", (fn) => {
              debug = fn;
            });
            const BufferList = require2("./buffer_list");
            const destroyImpl = require2("./destroy");
            const { getHighWaterMark, getDefaultHighWaterMark } = require2("./state");
            const {
              aggregateTwoErrors,
              codes: {
                ERR_INVALID_ARG_TYPE,
                ERR_METHOD_NOT_IMPLEMENTED,
                ERR_OUT_OF_RANGE,
                ERR_STREAM_PUSH_AFTER_EOF,
                ERR_STREAM_UNSHIFT_AFTER_END_EVENT
              }
            } = require2("../../ours/errors");
            const { validateObject } = require2("../validators");
            const kPaused = Symbol2("kPaused");
            const { StringDecoder } = require2("string_decoder");
            const from = require2("./from");
            ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
            ObjectSetPrototypeOf(Readable, Stream);
            const nop = () => {
            };
            const { errorOrDestroy } = destroyImpl;
            function ReadableState(options, stream, isDuplex) {
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof require2("./duplex");
              this.objectMode = !!(options && options.objectMode);
              if (isDuplex)
                this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
              this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = [];
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;
              this.constructed = true;
              this.sync = true;
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;
              this[kPaused] = null;
              this.errorEmitted = false;
              this.emitClose = !options || options.emitClose !== false;
              this.autoDestroy = !options || options.autoDestroy !== false;
              this.destroyed = false;
              this.errored = null;
              this.closed = false;
              this.closeEmitted = false;
              this.defaultEncoding = options && options.defaultEncoding || "utf8";
              this.awaitDrainWriters = null;
              this.multiAwaitDrain = false;
              this.readingMore = false;
              this.dataEmitted = false;
              this.decoder = null;
              this.encoding = null;
              if (options && options.encoding) {
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }
            function Readable(options) {
              if (!(this instanceof Readable))
                return new Readable(options);
              const isDuplex = this instanceof require2("./duplex");
              this._readableState = new ReadableState(options, this, isDuplex);
              if (options) {
                if (typeof options.read === "function")
                  this._read = options.read;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
                if (typeof options.construct === "function")
                  this._construct = options.construct;
                if (options.signal && !isDuplex)
                  addAbortSignal(options.signal, this);
              }
              Stream.call(this, options);
              destroyImpl.construct(this, () => {
                if (this._readableState.needReadable) {
                  maybeReadMore(this, this._readableState);
                }
              });
            }
            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;
            Readable.prototype._destroy = function(err, cb) {
              cb(err);
            };
            Readable.prototype[EE.captureRejectionSymbol] = function(err) {
              this.destroy(err);
            };
            Readable.prototype.push = function(chunk, encoding2) {
              return readableAddChunk(this, chunk, encoding2, false);
            };
            Readable.prototype.unshift = function(chunk, encoding2) {
              return readableAddChunk(this, chunk, encoding2, true);
            };
            function readableAddChunk(stream, chunk, encoding2, addToFront) {
              debug("readableAddChunk", chunk);
              const state = stream._readableState;
              let err;
              if (!state.objectMode) {
                if (typeof chunk === "string") {
                  encoding2 = encoding2 || state.defaultEncoding;
                  if (state.encoding !== encoding2) {
                    if (addToFront && state.encoding) {
                      chunk = Buffer.from(chunk, encoding2).toString(state.encoding);
                    } else {
                      chunk = Buffer.from(chunk, encoding2);
                      encoding2 = "";
                    }
                  }
                } else if (chunk instanceof Buffer) {
                  encoding2 = "";
                } else if (Stream._isUint8Array(chunk)) {
                  chunk = Stream._uint8ArrayToBuffer(chunk);
                  encoding2 = "";
                } else if (chunk != null) {
                  err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
                }
              }
              if (err) {
                errorOrDestroy(stream, err);
              } else if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (addToFront) {
                  if (state.endEmitted)
                    errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                  else if (state.destroyed || state.errored)
                    return false;
                  else
                    addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                } else if (state.destroyed || state.errored) {
                  return false;
                } else {
                  state.reading = false;
                  if (state.decoder && !encoding2) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false);
                    else
                      maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
                maybeReadMore(stream, state);
              }
              return !state.ended && (state.length < state.highWaterMark || state.length === 0);
            }
            function addChunk(stream, state, chunk, addToFront) {
              if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
                if (state.multiAwaitDrain) {
                  state.awaitDrainWriters.clear();
                } else {
                  state.awaitDrainWriters = null;
                }
                state.dataEmitted = true;
                stream.emit("data", chunk);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
              maybeReadMore(stream, state);
            }
            Readable.prototype.isPaused = function() {
              const state = this._readableState;
              return state[kPaused] === true || state.flowing === false;
            };
            Readable.prototype.setEncoding = function(enc) {
              const decoder = new StringDecoder(enc);
              this._readableState.decoder = decoder;
              this._readableState.encoding = this._readableState.decoder.encoding;
              const buffer = this._readableState.buffer;
              let content = "";
              for (const data of buffer) {
                content += decoder.write(data);
              }
              buffer.clear();
              if (content !== "")
                buffer.push(content);
              this._readableState.length = content.length;
              return this;
            };
            const MAX_HWM = 1073741824;
            function computeNewHighWaterMark(n) {
              if (n > MAX_HWM) {
                throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
              } else {
                n--;
                n |= n >>> 1;
                n |= n >>> 2;
                n |= n >>> 4;
                n |= n >>> 8;
                n |= n >>> 16;
                n++;
              }
              return n;
            }
            function howMuchToRead(n, state) {
              if (n <= 0 || state.length === 0 && state.ended)
                return 0;
              if (state.objectMode)
                return 1;
              if (NumberIsNaN(n)) {
                if (state.flowing && state.length)
                  return state.buffer.first().length;
                return state.length;
              }
              if (n <= state.length)
                return n;
              return state.ended ? state.length : 0;
            }
            Readable.prototype.read = function(n) {
              debug("read", n);
              if (n === void 0) {
                n = NaN;
              } else if (!NumberIsInteger(n)) {
                n = NumberParseInt(n, 10);
              }
              const state = this._readableState;
              const nOrig = n;
              if (n > state.highWaterMark)
                state.highWaterMark = computeNewHighWaterMark(n);
              if (n !== 0)
                state.emittedReadable = false;
              if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
                debug("read: emitReadable", state.length, state.ended);
                if (state.length === 0 && state.ended)
                  endReadable(this);
                else
                  emitReadable(this);
                return null;
              }
              n = howMuchToRead(n, state);
              if (n === 0 && state.ended) {
                if (state.length === 0)
                  endReadable(this);
                return null;
              }
              let doRead = state.needReadable;
              debug("need readable", doRead);
              if (state.length === 0 || state.length - n < state.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
              }
              if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
                doRead = false;
                debug("reading, ended or constructing", doRead);
              } else if (doRead) {
                debug("do read");
                state.reading = true;
                state.sync = true;
                if (state.length === 0)
                  state.needReadable = true;
                try {
                  this._read(state.highWaterMark);
                } catch (err) {
                  errorOrDestroy(this, err);
                }
                state.sync = false;
                if (!state.reading)
                  n = howMuchToRead(nOrig, state);
              }
              let ret;
              if (n > 0)
                ret = fromList(n, state);
              else
                ret = null;
              if (ret === null) {
                state.needReadable = state.length <= state.highWaterMark;
                n = 0;
              } else {
                state.length -= n;
                if (state.multiAwaitDrain) {
                  state.awaitDrainWriters.clear();
                } else {
                  state.awaitDrainWriters = null;
                }
              }
              if (state.length === 0) {
                if (!state.ended)
                  state.needReadable = true;
                if (nOrig !== n && state.ended)
                  endReadable(this);
              }
              if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
                state.dataEmitted = true;
                this.emit("data", ret);
              }
              return ret;
            };
            function onEofChunk(stream, state) {
              debug("onEofChunk");
              if (state.ended)
                return;
              if (state.decoder) {
                const chunk = state.decoder.end();
                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }
              state.ended = true;
              if (state.sync) {
                emitReadable(stream);
              } else {
                state.needReadable = false;
                state.emittedReadable = true;
                emitReadable_(stream);
              }
            }
            function emitReadable(stream) {
              const state = stream._readableState;
              debug("emitReadable", state.needReadable, state.emittedReadable);
              state.needReadable = false;
              if (!state.emittedReadable) {
                debug("emitReadable", state.flowing);
                state.emittedReadable = true;
                process.nextTick(emitReadable_, stream);
              }
            }
            function emitReadable_(stream) {
              const state = stream._readableState;
              debug("emitReadable_", state.destroyed, state.length, state.ended);
              if (!state.destroyed && !state.errored && (state.length || state.ended)) {
                stream.emit("readable");
                state.emittedReadable = false;
              }
              state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
              flow(stream);
            }
            function maybeReadMore(stream, state) {
              if (!state.readingMore && state.constructed) {
                state.readingMore = true;
                process.nextTick(maybeReadMore_, stream, state);
              }
            }
            function maybeReadMore_(stream, state) {
              while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
                const len = state.length;
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state.length)
                  break;
              }
              state.readingMore = false;
            }
            Readable.prototype._read = function(n) {
              throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
              const src2 = this;
              const state = this._readableState;
              if (state.pipes.length === 1) {
                if (!state.multiAwaitDrain) {
                  state.multiAwaitDrain = true;
                  state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
                }
              }
              state.pipes.push(dest);
              debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
              const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
              const endFn = doEnd ? onend : unpipe;
              if (state.endEmitted)
                process.nextTick(endFn);
              else
                src2.once("end", endFn);
              dest.on("unpipe", onunpipe);
              function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");
                if (readable === src2) {
                  if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                  }
                }
              }
              function onend() {
                debug("onend");
                dest.end();
              }
              let ondrain;
              let cleanedUp = false;
              function cleanup() {
                debug("cleanup");
                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                if (ondrain) {
                  dest.removeListener("drain", ondrain);
                }
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src2.removeListener("end", onend);
                src2.removeListener("end", unpipe);
                src2.removeListener("data", ondata);
                cleanedUp = true;
                if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
                  ondrain();
              }
              function pause() {
                if (!cleanedUp) {
                  if (state.pipes.length === 1 && state.pipes[0] === dest) {
                    debug("false write response, pause", 0);
                    state.awaitDrainWriters = dest;
                    state.multiAwaitDrain = false;
                  } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
                    debug("false write response, pause", state.awaitDrainWriters.size);
                    state.awaitDrainWriters.add(dest);
                  }
                  src2.pause();
                }
                if (!ondrain) {
                  ondrain = pipeOnDrain(src2, dest);
                  dest.on("drain", ondrain);
                }
              }
              src2.on("data", ondata);
              function ondata(chunk) {
                debug("ondata");
                const ret = dest.write(chunk);
                debug("dest.write", ret);
                if (ret === false) {
                  pause();
                }
              }
              function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (dest.listenerCount("error") === 0) {
                  const s = dest._writableState || dest._readableState;
                  if (s && !s.errorEmitted) {
                    errorOrDestroy(dest, er);
                  } else {
                    dest.emit("error", er);
                  }
                }
              }
              prependListener(dest, "error", onerror);
              function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
              }
              dest.once("close", onclose);
              function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
              }
              dest.once("finish", onfinish);
              function unpipe() {
                debug("unpipe");
                src2.unpipe(dest);
              }
              dest.emit("pipe", src2);
              if (dest.writableNeedDrain === true) {
                if (state.flowing) {
                  pause();
                }
              } else if (!state.flowing) {
                debug("pipe resume");
                src2.resume();
              }
              return dest;
            };
            function pipeOnDrain(src2, dest) {
              return function pipeOnDrainFunctionResult() {
                const state = src2._readableState;
                if (state.awaitDrainWriters === dest) {
                  debug("pipeOnDrain", 1);
                  state.awaitDrainWriters = null;
                } else if (state.multiAwaitDrain) {
                  debug("pipeOnDrain", state.awaitDrainWriters.size);
                  state.awaitDrainWriters.delete(dest);
                }
                if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src2.listenerCount("data")) {
                  src2.resume();
                }
              };
            }
            Readable.prototype.unpipe = function(dest) {
              const state = this._readableState;
              const unpipeInfo = {
                hasUnpiped: false
              };
              if (state.pipes.length === 0)
                return this;
              if (!dest) {
                const dests = state.pipes;
                state.pipes = [];
                this.pause();
                for (let i = 0; i < dests.length; i++)
                  dests[i].emit("unpipe", this, {
                    hasUnpiped: false
                  });
                return this;
              }
              const index2 = ArrayPrototypeIndexOf(state.pipes, dest);
              if (index2 === -1)
                return this;
              state.pipes.splice(index2, 1);
              if (state.pipes.length === 0)
                this.pause();
              dest.emit("unpipe", this, unpipeInfo);
              return this;
            };
            Readable.prototype.on = function(ev, fn) {
              const res = Stream.prototype.on.call(this, ev, fn);
              const state = this._readableState;
              if (ev === "data") {
                state.readableListening = this.listenerCount("readable") > 0;
                if (state.flowing !== false)
                  this.resume();
              } else if (ev === "readable") {
                if (!state.endEmitted && !state.readableListening) {
                  state.readableListening = state.needReadable = true;
                  state.flowing = false;
                  state.emittedReadable = false;
                  debug("on readable", state.length, state.reading);
                  if (state.length) {
                    emitReadable(this);
                  } else if (!state.reading) {
                    process.nextTick(nReadingNextTick, this);
                  }
                }
              }
              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            Readable.prototype.removeListener = function(ev, fn) {
              const res = Stream.prototype.removeListener.call(this, ev, fn);
              if (ev === "readable") {
                process.nextTick(updateReadableListening, this);
              }
              return res;
            };
            Readable.prototype.off = Readable.prototype.removeListener;
            Readable.prototype.removeAllListeners = function(ev) {
              const res = Stream.prototype.removeAllListeners.apply(this, arguments);
              if (ev === "readable" || ev === void 0) {
                process.nextTick(updateReadableListening, this);
              }
              return res;
            };
            function updateReadableListening(self2) {
              const state = self2._readableState;
              state.readableListening = self2.listenerCount("readable") > 0;
              if (state.resumeScheduled && state[kPaused] === false) {
                state.flowing = true;
              } else if (self2.listenerCount("data") > 0) {
                self2.resume();
              } else if (!state.readableListening) {
                state.flowing = null;
              }
            }
            function nReadingNextTick(self2) {
              debug("readable nexttick read 0");
              self2.read(0);
            }
            Readable.prototype.resume = function() {
              const state = this._readableState;
              if (!state.flowing) {
                debug("resume");
                state.flowing = !state.readableListening;
                resume(this, state);
              }
              state[kPaused] = false;
              return this;
            };
            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                process.nextTick(resume_, stream, state);
              }
            }
            function resume_(stream, state) {
              debug("resume", state.reading);
              if (!state.reading) {
                stream.read(0);
              }
              state.resumeScheduled = false;
              stream.emit("resume");
              flow(stream);
              if (state.flowing && !state.reading)
                stream.read(0);
            }
            Readable.prototype.pause = function() {
              debug("call pause flowing=%j", this._readableState.flowing);
              if (this._readableState.flowing !== false) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
              }
              this._readableState[kPaused] = true;
              return this;
            };
            function flow(stream) {
              const state = stream._readableState;
              debug("flow", state.flowing);
              while (state.flowing && stream.read() !== null)
                ;
            }
            Readable.prototype.wrap = function(stream) {
              let paused = false;
              stream.on("data", (chunk) => {
                if (!this.push(chunk) && stream.pause) {
                  paused = true;
                  stream.pause();
                }
              });
              stream.on("end", () => {
                this.push(null);
              });
              stream.on("error", (err) => {
                errorOrDestroy(this, err);
              });
              stream.on("close", () => {
                this.destroy();
              });
              stream.on("destroy", () => {
                this.destroy();
              });
              this._read = () => {
                if (paused && stream.resume) {
                  paused = false;
                  stream.resume();
                }
              };
              const streamKeys = ObjectKeys(stream);
              for (let j = 1; j < streamKeys.length; j++) {
                const i = streamKeys[j];
                if (this[i] === void 0 && typeof stream[i] === "function") {
                  this[i] = stream[i].bind(stream);
                }
              }
              return this;
            };
            Readable.prototype[SymbolAsyncIterator] = function() {
              return streamToAsyncIterator(this);
            };
            Readable.prototype.iterator = function(options) {
              if (options !== void 0) {
                validateObject(options, "options");
              }
              return streamToAsyncIterator(this, options);
            };
            function streamToAsyncIterator(stream, options) {
              if (typeof stream.read !== "function") {
                stream = Readable.wrap(stream, {
                  objectMode: true
                });
              }
              const iter = createAsyncIterator(stream, options);
              iter.stream = stream;
              return iter;
            }
            async function* createAsyncIterator(stream, options) {
              let callback = nop;
              function next(resolve) {
                if (this === stream) {
                  callback();
                  callback = nop;
                } else {
                  callback = resolve;
                }
              }
              stream.on("readable", next);
              let error;
              const cleanup = eos(
                stream,
                {
                  writable: false
                },
                (err) => {
                  error = err ? aggregateTwoErrors(error, err) : null;
                  callback();
                  callback = nop;
                }
              );
              try {
                while (true) {
                  const chunk = stream.destroyed ? null : stream.read();
                  if (chunk !== null) {
                    yield chunk;
                  } else if (error) {
                    throw error;
                  } else if (error === null) {
                    return;
                  } else {
                    await new Promise2(next);
                  }
                }
              } catch (err) {
                error = aggregateTwoErrors(error, err);
                throw error;
              } finally {
                if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
                  destroyImpl.destroyer(stream, null);
                } else {
                  stream.off("readable", next);
                  cleanup();
                }
              }
            }
            ObjectDefineProperties(Readable.prototype, {
              readable: {
                get() {
                  const r = this._readableState;
                  return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
                },
                set(val) {
                  if (this._readableState) {
                    this._readableState.readable = !!val;
                  }
                }
              },
              readableDidRead: {
                enumerable: false,
                get: function() {
                  return this._readableState.dataEmitted;
                }
              },
              readableAborted: {
                enumerable: false,
                get: function() {
                  return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
                }
              },
              readableHighWaterMark: {
                enumerable: false,
                get: function() {
                  return this._readableState.highWaterMark;
                }
              },
              readableBuffer: {
                enumerable: false,
                get: function() {
                  return this._readableState && this._readableState.buffer;
                }
              },
              readableFlowing: {
                enumerable: false,
                get: function() {
                  return this._readableState.flowing;
                },
                set: function(state) {
                  if (this._readableState) {
                    this._readableState.flowing = state;
                  }
                }
              },
              readableLength: {
                enumerable: false,
                get() {
                  return this._readableState.length;
                }
              },
              readableObjectMode: {
                enumerable: false,
                get() {
                  return this._readableState ? this._readableState.objectMode : false;
                }
              },
              readableEncoding: {
                enumerable: false,
                get() {
                  return this._readableState ? this._readableState.encoding : null;
                }
              },
              errored: {
                enumerable: false,
                get() {
                  return this._readableState ? this._readableState.errored : null;
                }
              },
              closed: {
                get() {
                  return this._readableState ? this._readableState.closed : false;
                }
              },
              destroyed: {
                enumerable: false,
                get() {
                  return this._readableState ? this._readableState.destroyed : false;
                },
                set(value) {
                  if (!this._readableState) {
                    return;
                  }
                  this._readableState.destroyed = value;
                }
              },
              readableEnded: {
                enumerable: false,
                get() {
                  return this._readableState ? this._readableState.endEmitted : false;
                }
              }
            });
            ObjectDefineProperties(ReadableState.prototype, {
              // Legacy getter for `pipesCount`.
              pipesCount: {
                get() {
                  return this.pipes.length;
                }
              },
              // Legacy property for `paused`.
              paused: {
                get() {
                  return this[kPaused] !== false;
                },
                set(value) {
                  this[kPaused] = !!value;
                }
              }
            });
            Readable._fromList = fromList;
            function fromList(n, state) {
              if (state.length === 0)
                return null;
              let ret;
              if (state.objectMode)
                ret = state.buffer.shift();
              else if (!n || n >= state.length) {
                if (state.decoder)
                  ret = state.buffer.join("");
                else if (state.buffer.length === 1)
                  ret = state.buffer.first();
                else
                  ret = state.buffer.concat(state.length);
                state.buffer.clear();
              } else {
                ret = state.buffer.consume(n, state.decoder);
              }
              return ret;
            }
            function endReadable(stream) {
              const state = stream._readableState;
              debug("endReadable", state.endEmitted);
              if (!state.endEmitted) {
                state.ended = true;
                process.nextTick(endReadableNT, state, stream);
              }
            }
            function endReadableNT(state, stream) {
              debug("endReadableNT", state.endEmitted, state.length);
              if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.emit("end");
                if (stream.writable && stream.allowHalfOpen === false) {
                  process.nextTick(endWritableNT, stream);
                } else if (state.autoDestroy) {
                  const wState = stream._writableState;
                  const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
                  // if writable is explicitly set to false.
                  (wState.finished || wState.writable === false);
                  if (autoDestroy) {
                    stream.destroy();
                  }
                }
              }
            }
            function endWritableNT(stream) {
              const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
              if (writable) {
                stream.end();
              }
            }
            Readable.from = function(iterable, opts) {
              return from(Readable, iterable, opts);
            };
            let webStreamsAdapters;
            function lazyWebStreams() {
              if (webStreamsAdapters === void 0)
                webStreamsAdapters = {};
              return webStreamsAdapters;
            }
            Readable.fromWeb = function(readableStream, options) {
              return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
            };
            Readable.toWeb = function(streamReadable) {
              return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable);
            };
            Readable.wrap = function(src2, options) {
              var _ref, _src$readableObjectMo;
              return new Readable({
                objectMode: (_ref = (_src$readableObjectMo = src2.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src2.objectMode) !== null && _ref !== void 0 ? _ref : true,
                ...options,
                destroy(err, callback) {
                  destroyImpl.destroyer(src2, err);
                  callback(err);
                }
              }).wrap(src2);
            };
          }).call(this);
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "../../ours/errors": 117, "../../ours/primordials": 118, "../../ours/util": 119, "../validators": 115, "./add-abort-signal": 98, "./buffer_list": 99, "./destroy": 101, "./duplex": 102, "./end-of-stream": 104, "./from": 105, "./legacy": 106, "./state": 111, "_process": 93, "buffer": 20, "events": 40, "string_decoder": 19 }], 111: [function(require2, module2, exports2) {
        const { MathFloor, NumberIsInteger } = require2("../../ours/primordials");
        const { ERR_INVALID_ARG_VALUE } = require2("../../ours/errors").codes;
        function highWaterMarkFrom(options, isDuplex, duplexKey) {
          return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
        }
        function getDefaultHighWaterMark(objectMode) {
          return objectMode ? 16 : 16 * 1024;
        }
        function getHighWaterMark(state, options, duplexKey, isDuplex) {
          const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
          if (hwm != null) {
            if (!NumberIsInteger(hwm) || hwm < 0) {
              const name2 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
              throw new ERR_INVALID_ARG_VALUE(name2, hwm);
            }
            return MathFloor(hwm);
          }
          return getDefaultHighWaterMark(state.objectMode);
        }
        module2.exports = {
          getHighWaterMark,
          getDefaultHighWaterMark
        };
      }, { "../../ours/errors": 117, "../../ours/primordials": 118 }], 112: [function(require2, module2, exports2) {
        const { ObjectSetPrototypeOf, Symbol: Symbol2 } = require2("../../ours/primordials");
        module2.exports = Transform;
        const { ERR_METHOD_NOT_IMPLEMENTED } = require2("../../ours/errors").codes;
        const Duplex = require2("./duplex");
        ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
        ObjectSetPrototypeOf(Transform, Duplex);
        const kCallback = Symbol2("kCallback");
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._readableState.sync = false;
          this[kCallback] = null;
          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform;
            if (typeof options.flush === "function")
              this._flush = options.flush;
          }
          this.on("prefinish", prefinish);
        }
        function final(cb) {
          if (typeof this._flush === "function" && !this.destroyed) {
            this._flush((er, data) => {
              if (er) {
                if (cb) {
                  cb(er);
                } else {
                  this.destroy(er);
                }
                return;
              }
              if (data != null) {
                this.push(data);
              }
              this.push(null);
              if (cb) {
                cb();
              }
            });
          } else {
            this.push(null);
            if (cb) {
              cb();
            }
          }
        }
        function prefinish() {
          if (this._final !== final) {
            final.call(this);
          }
        }
        Transform.prototype._final = final;
        Transform.prototype._transform = function(chunk, encoding2, callback) {
          throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
        };
        Transform.prototype._write = function(chunk, encoding2, callback) {
          const rState = this._readableState;
          const wState = this._writableState;
          const length = rState.length;
          this._transform(chunk, encoding2, (err, val) => {
            if (err) {
              callback(err);
              return;
            }
            if (val != null) {
              this.push(val);
            }
            if (wState.ended || // Backwards compat.
            length === rState.length || // Backwards compat.
            rState.length < rState.highWaterMark || rState.highWaterMark === 0 || rState.length === 0) {
              callback();
            } else {
              this[kCallback] = callback;
            }
          });
        };
        Transform.prototype._read = function() {
          if (this[kCallback]) {
            const callback = this[kCallback];
            this[kCallback] = null;
            callback();
          }
        };
      }, { "../../ours/errors": 117, "../../ours/primordials": 118, "./duplex": 102 }], 113: [function(require2, module2, exports2) {
        const { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator } = require2("../../ours/primordials");
        const kDestroyed = Symbol2("kDestroyed");
        const kIsErrored = Symbol2("kIsErrored");
        const kIsReadable = Symbol2("kIsReadable");
        const kIsDisturbed = Symbol2("kIsDisturbed");
        function isReadableNodeStream(obj, strict = false) {
          var _obj$_readableState;
          return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
          (!obj._writableState || obj._readableState));
        }
        function isWritableNodeStream(obj) {
          var _obj$_writableState;
          return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
        }
        function isDuplexNodeStream(obj) {
          return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
        }
        function isNodeStream(obj) {
          return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
        }
        function isIterable(obj, isAsync) {
          if (obj == null)
            return false;
          if (isAsync === true)
            return typeof obj[SymbolAsyncIterator] === "function";
          if (isAsync === false)
            return typeof obj[SymbolIterator] === "function";
          return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
        }
        function isDestroyed(stream) {
          if (!isNodeStream(stream))
            return null;
          const wState = stream._writableState;
          const rState = stream._readableState;
          const state = wState || rState;
          return !!(stream.destroyed || stream[kDestroyed] || state !== null && state !== void 0 && state.destroyed);
        }
        function isWritableEnded(stream) {
          if (!isWritableNodeStream(stream))
            return null;
          if (stream.writableEnded === true)
            return true;
          const wState = stream._writableState;
          if (wState !== null && wState !== void 0 && wState.errored)
            return false;
          if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
            return null;
          return wState.ended;
        }
        function isWritableFinished(stream, strict) {
          if (!isWritableNodeStream(stream))
            return null;
          if (stream.writableFinished === true)
            return true;
          const wState = stream._writableState;
          if (wState !== null && wState !== void 0 && wState.errored)
            return false;
          if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
            return null;
          return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
        }
        function isReadableEnded(stream) {
          if (!isReadableNodeStream(stream))
            return null;
          if (stream.readableEnded === true)
            return true;
          const rState = stream._readableState;
          if (!rState || rState.errored)
            return false;
          if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
            return null;
          return rState.ended;
        }
        function isReadableFinished(stream, strict) {
          if (!isReadableNodeStream(stream))
            return null;
          const rState = stream._readableState;
          if (rState !== null && rState !== void 0 && rState.errored)
            return false;
          if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
            return null;
          return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
        }
        function isReadable(stream) {
          if (stream && stream[kIsReadable] != null)
            return stream[kIsReadable];
          if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
            return null;
          if (isDestroyed(stream))
            return false;
          return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
        }
        function isWritable(stream) {
          if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
            return null;
          if (isDestroyed(stream))
            return false;
          return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
        }
        function isFinished(stream, opts) {
          if (!isNodeStream(stream)) {
            return null;
          }
          if (isDestroyed(stream)) {
            return true;
          }
          if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
            return false;
          }
          if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
            return false;
          }
          return true;
        }
        function isWritableErrored(stream) {
          var _stream$_writableStat, _stream$_writableStat2;
          if (!isNodeStream(stream)) {
            return null;
          }
          if (stream.writableErrored) {
            return stream.writableErrored;
          }
          return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
        }
        function isReadableErrored(stream) {
          var _stream$_readableStat, _stream$_readableStat2;
          if (!isNodeStream(stream)) {
            return null;
          }
          if (stream.readableErrored) {
            return stream.readableErrored;
          }
          return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
        }
        function isClosed(stream) {
          if (!isNodeStream(stream)) {
            return null;
          }
          if (typeof stream.closed === "boolean") {
            return stream.closed;
          }
          const wState = stream._writableState;
          const rState = stream._readableState;
          if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
            return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
          }
          if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
            return stream._closed;
          }
          return null;
        }
        function isOutgoingMessage(stream) {
          return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
        }
        function isServerResponse(stream) {
          return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
        }
        function isServerRequest(stream) {
          var _stream$req;
          return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
        }
        function willEmitClose(stream) {
          if (!isNodeStream(stream))
            return null;
          const wState = stream._writableState;
          const rState = stream._readableState;
          const state = wState || rState;
          return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
        }
        function isDisturbed(stream) {
          var _stream$kIsDisturbed;
          return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
        }
        function isErrored(stream) {
          var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
          return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
        }
        module2.exports = {
          kDestroyed,
          isDisturbed,
          kIsDisturbed,
          isErrored,
          kIsErrored,
          isReadable,
          kIsReadable,
          isClosed,
          isDestroyed,
          isDuplexNodeStream,
          isFinished,
          isIterable,
          isReadableNodeStream,
          isReadableEnded,
          isReadableFinished,
          isReadableErrored,
          isNodeStream,
          isWritable,
          isWritableNodeStream,
          isWritableEnded,
          isWritableFinished,
          isWritableErrored,
          isServerRequest,
          isServerResponse,
          willEmitClose
        };
      }, { "../../ours/primordials": 118 }], 114: [function(require2, module2, exports2) {
        (function(process, Buffer) {
          (function() {
            const {
              ArrayPrototypeSlice,
              Error: Error2,
              FunctionPrototypeSymbolHasInstance,
              ObjectDefineProperty,
              ObjectDefineProperties,
              ObjectSetPrototypeOf,
              StringPrototypeToLowerCase,
              Symbol: Symbol2,
              SymbolHasInstance
            } = require2("../../ours/primordials");
            module2.exports = Writable;
            Writable.WritableState = WritableState;
            const { EventEmitter: EE } = require2("events");
            const Stream = require2("./legacy").Stream;
            const destroyImpl = require2("./destroy");
            const { addAbortSignal } = require2("./add-abort-signal");
            const { getHighWaterMark, getDefaultHighWaterMark } = require2("./state");
            const {
              ERR_INVALID_ARG_TYPE,
              ERR_METHOD_NOT_IMPLEMENTED,
              ERR_MULTIPLE_CALLBACK,
              ERR_STREAM_CANNOT_PIPE,
              ERR_STREAM_DESTROYED,
              ERR_STREAM_ALREADY_FINISHED,
              ERR_STREAM_NULL_VALUES,
              ERR_STREAM_WRITE_AFTER_END,
              ERR_UNKNOWN_ENCODING
            } = require2("../../ours/errors").codes;
            const { errorOrDestroy } = destroyImpl;
            ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
            ObjectSetPrototypeOf(Writable, Stream);
            function nop() {
            }
            const kOnFinished = Symbol2("kOnFinished");
            function WritableState(options, stream, isDuplex) {
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof require2("./duplex");
              this.objectMode = !!(options && options.objectMode);
              if (isDuplex)
                this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
              this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
              this.finalCalled = false;
              this.needDrain = false;
              this.ending = false;
              this.ended = false;
              this.finished = false;
              this.destroyed = false;
              const noDecode = !!(options && options.decodeStrings === false);
              this.decodeStrings = !noDecode;
              this.defaultEncoding = options && options.defaultEncoding || "utf8";
              this.length = 0;
              this.writing = false;
              this.corked = 0;
              this.sync = true;
              this.bufferProcessing = false;
              this.onwrite = onwrite.bind(void 0, stream);
              this.writecb = null;
              this.writelen = 0;
              this.afterWriteTickInfo = null;
              resetBuffer(this);
              this.pendingcb = 0;
              this.constructed = true;
              this.prefinished = false;
              this.errorEmitted = false;
              this.emitClose = !options || options.emitClose !== false;
              this.autoDestroy = !options || options.autoDestroy !== false;
              this.errored = null;
              this.closed = false;
              this.closeEmitted = false;
              this[kOnFinished] = [];
            }
            function resetBuffer(state) {
              state.buffered = [];
              state.bufferedIndex = 0;
              state.allBuffers = true;
              state.allNoop = true;
            }
            WritableState.prototype.getBuffer = function getBuffer() {
              return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
            };
            ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
              get() {
                return this.buffered.length - this.bufferedIndex;
              }
            });
            function Writable(options) {
              const isDuplex = this instanceof require2("./duplex");
              if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
                return new Writable(options);
              this._writableState = new WritableState(options, this, isDuplex);
              if (options) {
                if (typeof options.write === "function")
                  this._write = options.write;
                if (typeof options.writev === "function")
                  this._writev = options.writev;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
                if (typeof options.final === "function")
                  this._final = options.final;
                if (typeof options.construct === "function")
                  this._construct = options.construct;
                if (options.signal)
                  addAbortSignal(options.signal, this);
              }
              Stream.call(this, options);
              destroyImpl.construct(this, () => {
                const state = this._writableState;
                if (!state.writing) {
                  clearBuffer(this, state);
                }
                finishMaybe(this, state);
              });
            }
            ObjectDefineProperty(Writable, SymbolHasInstance, {
              value: function(object) {
                if (FunctionPrototypeSymbolHasInstance(this, object))
                  return true;
                if (this !== Writable)
                  return false;
                return object && object._writableState instanceof WritableState;
              }
            });
            Writable.prototype.pipe = function() {
              errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
            };
            function _write(stream, chunk, encoding2, cb) {
              const state = stream._writableState;
              if (typeof encoding2 === "function") {
                cb = encoding2;
                encoding2 = state.defaultEncoding;
              } else {
                if (!encoding2)
                  encoding2 = state.defaultEncoding;
                else if (encoding2 !== "buffer" && !Buffer.isEncoding(encoding2))
                  throw new ERR_UNKNOWN_ENCODING(encoding2);
                if (typeof cb !== "function")
                  cb = nop;
              }
              if (chunk === null) {
                throw new ERR_STREAM_NULL_VALUES();
              } else if (!state.objectMode) {
                if (typeof chunk === "string") {
                  if (state.decodeStrings !== false) {
                    chunk = Buffer.from(chunk, encoding2);
                    encoding2 = "buffer";
                  }
                } else if (chunk instanceof Buffer) {
                  encoding2 = "buffer";
                } else if (Stream._isUint8Array(chunk)) {
                  chunk = Stream._uint8ArrayToBuffer(chunk);
                  encoding2 = "buffer";
                } else {
                  throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
                }
              }
              let err;
              if (state.ending) {
                err = new ERR_STREAM_WRITE_AFTER_END();
              } else if (state.destroyed) {
                err = new ERR_STREAM_DESTROYED("write");
              }
              if (err) {
                process.nextTick(cb, err);
                errorOrDestroy(stream, err, true);
                return err;
              }
              state.pendingcb++;
              return writeOrBuffer(stream, state, chunk, encoding2, cb);
            }
            Writable.prototype.write = function(chunk, encoding2, cb) {
              return _write(this, chunk, encoding2, cb) === true;
            };
            Writable.prototype.cork = function() {
              this._writableState.corked++;
            };
            Writable.prototype.uncork = function() {
              const state = this._writableState;
              if (state.corked) {
                state.corked--;
                if (!state.writing)
                  clearBuffer(this, state);
              }
            };
            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
              if (typeof encoding2 === "string")
                encoding2 = StringPrototypeToLowerCase(encoding2);
              if (!Buffer.isEncoding(encoding2))
                throw new ERR_UNKNOWN_ENCODING(encoding2);
              this._writableState.defaultEncoding = encoding2;
              return this;
            };
            function writeOrBuffer(stream, state, chunk, encoding2, callback) {
              const len = state.objectMode ? 1 : chunk.length;
              state.length += len;
              const ret = state.length < state.highWaterMark;
              if (!ret)
                state.needDrain = true;
              if (state.writing || state.corked || state.errored || !state.constructed) {
                state.buffered.push({
                  chunk,
                  encoding: encoding2,
                  callback
                });
                if (state.allBuffers && encoding2 !== "buffer") {
                  state.allBuffers = false;
                }
                if (state.allNoop && callback !== nop) {
                  state.allNoop = false;
                }
              } else {
                state.writelen = len;
                state.writecb = callback;
                state.writing = true;
                state.sync = true;
                stream._write(chunk, encoding2, state.onwrite);
                state.sync = false;
              }
              return ret && !state.errored && !state.destroyed;
            }
            function doWrite(stream, state, writev, len, chunk, encoding2, cb) {
              state.writelen = len;
              state.writecb = cb;
              state.writing = true;
              state.sync = true;
              if (state.destroyed)
                state.onwrite(new ERR_STREAM_DESTROYED("write"));
              else if (writev)
                stream._writev(chunk, state.onwrite);
              else
                stream._write(chunk, encoding2, state.onwrite);
              state.sync = false;
            }
            function onwriteError(stream, state, er, cb) {
              --state.pendingcb;
              cb(er);
              errorBuffer(state);
              errorOrDestroy(stream, er);
            }
            function onwrite(stream, er) {
              const state = stream._writableState;
              const sync = state.sync;
              const cb = state.writecb;
              if (typeof cb !== "function") {
                errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
                return;
              }
              state.writing = false;
              state.writecb = null;
              state.length -= state.writelen;
              state.writelen = 0;
              if (er) {
                er.stack;
                if (!state.errored) {
                  state.errored = er;
                }
                if (stream._readableState && !stream._readableState.errored) {
                  stream._readableState.errored = er;
                }
                if (sync) {
                  process.nextTick(onwriteError, stream, state, er, cb);
                } else {
                  onwriteError(stream, state, er, cb);
                }
              } else {
                if (state.buffered.length > state.bufferedIndex) {
                  clearBuffer(stream, state);
                }
                if (sync) {
                  if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
                    state.afterWriteTickInfo.count++;
                  } else {
                    state.afterWriteTickInfo = {
                      count: 1,
                      cb,
                      stream,
                      state
                    };
                    process.nextTick(afterWriteTick, state.afterWriteTickInfo);
                  }
                } else {
                  afterWrite(stream, state, 1, cb);
                }
              }
            }
            function afterWriteTick({ stream, state, count, cb }) {
              state.afterWriteTickInfo = null;
              return afterWrite(stream, state, count, cb);
            }
            function afterWrite(stream, state, count, cb) {
              const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
              if (needDrain) {
                state.needDrain = false;
                stream.emit("drain");
              }
              while (count-- > 0) {
                state.pendingcb--;
                cb();
              }
              if (state.destroyed) {
                errorBuffer(state);
              }
              finishMaybe(stream, state);
            }
            function errorBuffer(state) {
              if (state.writing) {
                return;
              }
              for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
                var _state$errored;
                const { chunk, callback } = state.buffered[n];
                const len = state.objectMode ? 1 : chunk.length;
                state.length -= len;
                callback(
                  (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
                );
              }
              const onfinishCallbacks = state[kOnFinished].splice(0);
              for (let i = 0; i < onfinishCallbacks.length; i++) {
                var _state$errored2;
                onfinishCallbacks[i](
                  (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
                );
              }
              resetBuffer(state);
            }
            function clearBuffer(stream, state) {
              if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
                return;
              }
              const { buffered, bufferedIndex, objectMode } = state;
              const bufferedLength = buffered.length - bufferedIndex;
              if (!bufferedLength) {
                return;
              }
              let i = bufferedIndex;
              state.bufferProcessing = true;
              if (bufferedLength > 1 && stream._writev) {
                state.pendingcb -= bufferedLength - 1;
                const callback = state.allNoop ? nop : (err) => {
                  for (let n = i; n < buffered.length; ++n) {
                    buffered[n].callback(err);
                  }
                };
                const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
                chunks.allBuffers = state.allBuffers;
                doWrite(stream, state, true, state.length, chunks, "", callback);
                resetBuffer(state);
              } else {
                do {
                  const { chunk, encoding: encoding2, callback } = buffered[i];
                  buffered[i++] = null;
                  const len = objectMode ? 1 : chunk.length;
                  doWrite(stream, state, false, len, chunk, encoding2, callback);
                } while (i < buffered.length && !state.writing);
                if (i === buffered.length) {
                  resetBuffer(state);
                } else if (i > 256) {
                  buffered.splice(0, i);
                  state.bufferedIndex = 0;
                } else {
                  state.bufferedIndex = i;
                }
              }
              state.bufferProcessing = false;
            }
            Writable.prototype._write = function(chunk, encoding2, cb) {
              if (this._writev) {
                this._writev(
                  [
                    {
                      chunk,
                      encoding: encoding2
                    }
                  ],
                  cb
                );
              } else {
                throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
              }
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function(chunk, encoding2, cb) {
              const state = this._writableState;
              if (typeof chunk === "function") {
                cb = chunk;
                chunk = null;
                encoding2 = null;
              } else if (typeof encoding2 === "function") {
                cb = encoding2;
                encoding2 = null;
              }
              let err;
              if (chunk !== null && chunk !== void 0) {
                const ret = _write(this, chunk, encoding2);
                if (ret instanceof Error2) {
                  err = ret;
                }
              }
              if (state.corked) {
                state.corked = 1;
                this.uncork();
              }
              if (err)
                ;
              else if (!state.errored && !state.ending) {
                state.ending = true;
                finishMaybe(this, state, true);
                state.ended = true;
              } else if (state.finished) {
                err = new ERR_STREAM_ALREADY_FINISHED("end");
              } else if (state.destroyed) {
                err = new ERR_STREAM_DESTROYED("end");
              }
              if (typeof cb === "function") {
                if (err || state.finished) {
                  process.nextTick(cb, err);
                } else {
                  state[kOnFinished].push(cb);
                }
              }
              return this;
            };
            function needFinish(state) {
              return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
            }
            function callFinal(stream, state) {
              let called = false;
              function onFinish(err) {
                if (called) {
                  errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
                  return;
                }
                called = true;
                state.pendingcb--;
                if (err) {
                  const onfinishCallbacks = state[kOnFinished].splice(0);
                  for (let i = 0; i < onfinishCallbacks.length; i++) {
                    onfinishCallbacks[i](err);
                  }
                  errorOrDestroy(stream, err, state.sync);
                } else if (needFinish(state)) {
                  state.prefinished = true;
                  stream.emit("prefinish");
                  state.pendingcb++;
                  process.nextTick(finish, stream, state);
                }
              }
              state.sync = true;
              state.pendingcb++;
              try {
                stream._final(onFinish);
              } catch (err) {
                onFinish(err);
              }
              state.sync = false;
            }
            function prefinish(stream, state) {
              if (!state.prefinished && !state.finalCalled) {
                if (typeof stream._final === "function" && !state.destroyed) {
                  state.finalCalled = true;
                  callFinal(stream, state);
                } else {
                  state.prefinished = true;
                  stream.emit("prefinish");
                }
              }
            }
            function finishMaybe(stream, state, sync) {
              if (needFinish(state)) {
                prefinish(stream, state);
                if (state.pendingcb === 0) {
                  if (sync) {
                    state.pendingcb++;
                    process.nextTick(
                      (stream2, state2) => {
                        if (needFinish(state2)) {
                          finish(stream2, state2);
                        } else {
                          state2.pendingcb--;
                        }
                      },
                      stream,
                      state
                    );
                  } else if (needFinish(state)) {
                    state.pendingcb++;
                    finish(stream, state);
                  }
                }
              }
            }
            function finish(stream, state) {
              state.pendingcb--;
              state.finished = true;
              const onfinishCallbacks = state[kOnFinished].splice(0);
              for (let i = 0; i < onfinishCallbacks.length; i++) {
                onfinishCallbacks[i]();
              }
              stream.emit("finish");
              if (state.autoDestroy) {
                const rState = stream._readableState;
                const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
                // if readable is explicitly set to false.
                (rState.endEmitted || rState.readable === false);
                if (autoDestroy) {
                  stream.destroy();
                }
              }
            }
            ObjectDefineProperties(Writable.prototype, {
              closed: {
                get() {
                  return this._writableState ? this._writableState.closed : false;
                }
              },
              destroyed: {
                get() {
                  return this._writableState ? this._writableState.destroyed : false;
                },
                set(value) {
                  if (this._writableState) {
                    this._writableState.destroyed = value;
                  }
                }
              },
              writable: {
                get() {
                  const w = this._writableState;
                  return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
                },
                set(val) {
                  if (this._writableState) {
                    this._writableState.writable = !!val;
                  }
                }
              },
              writableFinished: {
                get() {
                  return this._writableState ? this._writableState.finished : false;
                }
              },
              writableObjectMode: {
                get() {
                  return this._writableState ? this._writableState.objectMode : false;
                }
              },
              writableBuffer: {
                get() {
                  return this._writableState && this._writableState.getBuffer();
                }
              },
              writableEnded: {
                get() {
                  return this._writableState ? this._writableState.ending : false;
                }
              },
              writableNeedDrain: {
                get() {
                  const wState = this._writableState;
                  if (!wState)
                    return false;
                  return !wState.destroyed && !wState.ending && wState.needDrain;
                }
              },
              writableHighWaterMark: {
                get() {
                  return this._writableState && this._writableState.highWaterMark;
                }
              },
              writableCorked: {
                get() {
                  return this._writableState ? this._writableState.corked : 0;
                }
              },
              writableLength: {
                get() {
                  return this._writableState && this._writableState.length;
                }
              },
              errored: {
                enumerable: false,
                get() {
                  return this._writableState ? this._writableState.errored : null;
                }
              },
              writableAborted: {
                enumerable: false,
                get: function() {
                  return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
                }
              }
            });
            const destroy = destroyImpl.destroy;
            Writable.prototype.destroy = function(err, cb) {
              const state = this._writableState;
              if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
                process.nextTick(errorBuffer, state);
              }
              destroy.call(this, err, cb);
              return this;
            };
            Writable.prototype._undestroy = destroyImpl.undestroy;
            Writable.prototype._destroy = function(err, cb) {
              cb(err);
            };
            Writable.prototype[EE.captureRejectionSymbol] = function(err) {
              this.destroy(err);
            };
            let webStreamsAdapters;
            function lazyWebStreams() {
              if (webStreamsAdapters === void 0)
                webStreamsAdapters = {};
              return webStreamsAdapters;
            }
            Writable.fromWeb = function(writableStream, options) {
              return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
            };
            Writable.toWeb = function(streamWritable) {
              return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
            };
          }).call(this);
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "../../ours/errors": 117, "../../ours/primordials": 118, "./add-abort-signal": 98, "./destroy": 101, "./duplex": 102, "./legacy": 106, "./state": 111, "_process": 93, "buffer": 20, "events": 40 }], 115: [function(require2, module2, exports2) {
        const {
          ArrayIsArray,
          ArrayPrototypeIncludes,
          ArrayPrototypeJoin,
          ArrayPrototypeMap,
          NumberIsInteger,
          NumberMAX_SAFE_INTEGER,
          NumberMIN_SAFE_INTEGER,
          NumberParseInt,
          RegExpPrototypeTest,
          String: String2,
          StringPrototypeToUpperCase,
          StringPrototypeTrim
        } = require2("../ours/primordials");
        const {
          hideStackFrames,
          codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
        } = require2("../ours/errors");
        const { normalizeEncoding } = require2("../ours/util");
        const { isAsyncFunction, isArrayBufferView } = require2("../ours/util").types;
        const signals = {};
        function isInt32(value) {
          return value === (value | 0);
        }
        function isUint32(value) {
          return value === value >>> 0;
        }
        const octalReg = /^[0-7]+$/;
        const modeDesc = "must be a 32-bit unsigned integer or an octal string";
        function parseFileMode(value, name2, def) {
          if (typeof value === "undefined") {
            value = def;
          }
          if (typeof value === "string") {
            if (!RegExpPrototypeTest(octalReg, value)) {
              throw new ERR_INVALID_ARG_VALUE(name2, value, modeDesc);
            }
            value = NumberParseInt(value, 8);
          }
          validateInt32(value, name2, 0, 2 ** 32 - 1);
          return value;
        }
        const validateInteger = hideStackFrames((value, name2, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
          if (typeof value !== "number")
            throw new ERR_INVALID_ARG_TYPE(name2, "number", value);
          if (!NumberIsInteger(value))
            throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
          if (value < min || value > max)
            throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
        });
        const validateInt32 = hideStackFrames((value, name2, min = -2147483648, max = 2147483647) => {
          if (typeof value !== "number") {
            throw new ERR_INVALID_ARG_TYPE(name2, "number", value);
          }
          if (!isInt32(value)) {
            if (!NumberIsInteger(value)) {
              throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
            }
            throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
          }
          if (value < min || value > max) {
            throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
          }
        });
        const validateUint32 = hideStackFrames((value, name2, positive) => {
          if (typeof value !== "number") {
            throw new ERR_INVALID_ARG_TYPE(name2, "number", value);
          }
          if (!isUint32(value)) {
            if (!NumberIsInteger(value)) {
              throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
            }
            const min = positive ? 1 : 0;
            throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && < 4294967296`, value);
          }
          if (positive && value === 0) {
            throw new ERR_OUT_OF_RANGE(name2, ">= 1 && < 4294967296", value);
          }
        });
        function validateString(value, name2) {
          if (typeof value !== "string")
            throw new ERR_INVALID_ARG_TYPE(name2, "string", value);
        }
        function validateNumber(value, name2) {
          if (typeof value !== "number")
            throw new ERR_INVALID_ARG_TYPE(name2, "number", value);
        }
        const validateOneOf = hideStackFrames((value, name2, oneOf) => {
          if (!ArrayPrototypeIncludes(oneOf, value)) {
            const allowed = ArrayPrototypeJoin(
              ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
              ", "
            );
            const reason = "must be one of: " + allowed;
            throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
          }
        });
        function validateBoolean(value, name2) {
          if (typeof value !== "boolean")
            throw new ERR_INVALID_ARG_TYPE(name2, "boolean", value);
        }
        const validateObject = hideStackFrames((value, name2, options) => {
          const useDefaultOptions = options == null;
          const allowArray = useDefaultOptions ? false : options.allowArray;
          const allowFunction = useDefaultOptions ? false : options.allowFunction;
          const nullable = useDefaultOptions ? false : options.nullable;
          if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
            throw new ERR_INVALID_ARG_TYPE(name2, "Object", value);
          }
        });
        const validateArray = hideStackFrames((value, name2, minLength = 0) => {
          if (!ArrayIsArray(value)) {
            throw new ERR_INVALID_ARG_TYPE(name2, "Array", value);
          }
          if (value.length < minLength) {
            const reason = `must be longer than ${minLength}`;
            throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
          }
        });
        function validateSignalName(signal, name2 = "signal") {
          validateString(signal, name2);
          if (signals[signal] === void 0) {
            if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
              throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
            }
            throw new ERR_UNKNOWN_SIGNAL(signal);
          }
        }
        const validateBuffer = hideStackFrames((buffer, name2 = "buffer") => {
          if (!isArrayBufferView(buffer)) {
            throw new ERR_INVALID_ARG_TYPE(name2, ["Buffer", "TypedArray", "DataView"], buffer);
          }
        });
        function validateEncoding(data, encoding2) {
          const normalizedEncoding = normalizeEncoding(encoding2);
          const length = data.length;
          if (normalizedEncoding === "hex" && length % 2 !== 0) {
            throw new ERR_INVALID_ARG_VALUE("encoding", encoding2, `is invalid for data of length ${length}`);
          }
        }
        function validatePort(port, name2 = "Port", allowZero = true) {
          if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
            throw new ERR_SOCKET_BAD_PORT(name2, port, allowZero);
          }
          return port | 0;
        }
        const validateAbortSignal = hideStackFrames((signal, name2) => {
          if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
            throw new ERR_INVALID_ARG_TYPE(name2, "AbortSignal", signal);
          }
        });
        const validateFunction = hideStackFrames((value, name2) => {
          if (typeof value !== "function")
            throw new ERR_INVALID_ARG_TYPE(name2, "Function", value);
        });
        const validatePlainFunction = hideStackFrames((value, name2) => {
          if (typeof value !== "function" || isAsyncFunction(value))
            throw new ERR_INVALID_ARG_TYPE(name2, "Function", value);
        });
        const validateUndefined = hideStackFrames((value, name2) => {
          if (value !== void 0)
            throw new ERR_INVALID_ARG_TYPE(name2, "undefined", value);
        });
        module2.exports = {
          isInt32,
          isUint32,
          parseFileMode,
          validateArray,
          validateBoolean,
          validateBuffer,
          validateEncoding,
          validateFunction,
          validateInt32,
          validateInteger,
          validateNumber,
          validateObject,
          validateOneOf,
          validatePlainFunction,
          validatePort,
          validateSignalName,
          validateString,
          validateUint32,
          validateUndefined,
          validateAbortSignal
        };
      }, { "../ours/errors": 117, "../ours/primordials": 118, "../ours/util": 119 }], 116: [function(require2, module2, exports2) {
        const CustomStream = require2("../stream");
        const promises = require2("../stream/promises");
        const originalDestroy = CustomStream.Readable.destroy;
        module2.exports = CustomStream.Readable;
        module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
        module2.exports._isUint8Array = CustomStream._isUint8Array;
        module2.exports.isDisturbed = CustomStream.isDisturbed;
        module2.exports.isErrored = CustomStream.isErrored;
        module2.exports.isReadable = CustomStream.isReadable;
        module2.exports.Readable = CustomStream.Readable;
        module2.exports.Writable = CustomStream.Writable;
        module2.exports.Duplex = CustomStream.Duplex;
        module2.exports.Transform = CustomStream.Transform;
        module2.exports.PassThrough = CustomStream.PassThrough;
        module2.exports.addAbortSignal = CustomStream.addAbortSignal;
        module2.exports.finished = CustomStream.finished;
        module2.exports.destroy = CustomStream.destroy;
        module2.exports.destroy = originalDestroy;
        module2.exports.pipeline = CustomStream.pipeline;
        module2.exports.compose = CustomStream.compose;
        Object.defineProperty(CustomStream, "promises", {
          configurable: true,
          enumerable: true,
          get() {
            return promises;
          }
        });
        module2.exports.Stream = CustomStream.Stream;
        module2.exports.default = module2.exports;
      }, { "../stream": 120, "../stream/promises": 121 }], 117: [function(require2, module2, exports2) {
        const { format, inspect, AggregateError: CustomAggregateError } = require2("./util");
        const AggregateError = globalThis.AggregateError || CustomAggregateError;
        const kIsNodeError = Symbol("kIsNodeError");
        const kTypes = [
          "string",
          "function",
          "number",
          "object",
          // Accept 'Function' and 'Object' as alternative to the lower cased version.
          "Function",
          "Object",
          "boolean",
          "bigint",
          "symbol"
        ];
        const classRegExp = /^([A-Z][a-z0-9]*)+$/;
        const nodeInternalPrefix = "__node_internal_";
        const codes = {};
        function assert(value, message) {
          if (!value) {
            throw new codes.ERR_INTERNAL_ASSERTION(message);
          }
        }
        function addNumericalSeparator(val) {
          let res = "";
          let i = val.length;
          const start = val[0] === "-" ? 1 : 0;
          for (; i >= start + 4; i -= 3) {
            res = `_${val.slice(i - 3, i)}${res}`;
          }
          return `${val.slice(0, i)}${res}`;
        }
        function getMessage(key, msg, args) {
          if (typeof msg === "function") {
            assert(
              msg.length <= args.length,
              // Default options do not count.
              `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
            );
            return msg(...args);
          }
          const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
          assert(
            expectedLength === args.length,
            `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
          );
          if (args.length === 0) {
            return msg;
          }
          return format(msg, ...args);
        }
        function E(code, message, Base) {
          if (!Base) {
            Base = Error;
          }
          class NodeError extends Base {
            constructor(...args) {
              super(getMessage(code, message, args));
            }
            toString() {
              return `${this.name} [${code}]: ${this.message}`;
            }
          }
          Object.defineProperties(NodeError.prototype, {
            name: {
              value: Base.name,
              writable: true,
              enumerable: false,
              configurable: true
            },
            toString: {
              value() {
                return `${this.name} [${code}]: ${this.message}`;
              },
              writable: true,
              enumerable: false,
              configurable: true
            }
          });
          NodeError.prototype.code = code;
          NodeError.prototype[kIsNodeError] = true;
          codes[code] = NodeError;
        }
        function hideStackFrames(fn) {
          const hidden = nodeInternalPrefix + fn.name;
          Object.defineProperty(fn, "name", {
            value: hidden
          });
          return fn;
        }
        function aggregateTwoErrors(innerError, outerError) {
          if (innerError && outerError && innerError !== outerError) {
            if (Array.isArray(outerError.errors)) {
              outerError.errors.push(innerError);
              return outerError;
            }
            const err = new AggregateError([outerError, innerError], outerError.message);
            err.code = outerError.code;
            return err;
          }
          return innerError || outerError;
        }
        class AbortError extends Error {
          constructor(message = "The operation was aborted", options = void 0) {
            if (options !== void 0 && typeof options !== "object") {
              throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
            }
            super(message, options);
            this.code = "ABORT_ERR";
            this.name = "AbortError";
          }
        }
        E("ERR_ASSERTION", "%s", Error);
        E(
          "ERR_INVALID_ARG_TYPE",
          (name2, expected, actual) => {
            assert(typeof name2 === "string", "'name' must be a string");
            if (!Array.isArray(expected)) {
              expected = [expected];
            }
            let msg = "The ";
            if (name2.endsWith(" argument")) {
              msg += `${name2} `;
            } else {
              msg += `"${name2}" ${name2.includes(".") ? "property" : "argument"} `;
            }
            msg += "must be ";
            const types = [];
            const instances = [];
            const other = [];
            for (const value of expected) {
              assert(typeof value === "string", "All expected entries have to be of type string");
              if (kTypes.includes(value)) {
                types.push(value.toLowerCase());
              } else if (classRegExp.test(value)) {
                instances.push(value);
              } else {
                assert(value !== "object", 'The value "object" should be written as "Object"');
                other.push(value);
              }
            }
            if (instances.length > 0) {
              const pos = types.indexOf("object");
              if (pos !== -1) {
                types.splice(types, pos, 1);
                instances.push("Object");
              }
            }
            if (types.length > 0) {
              switch (types.length) {
                case 1:
                  msg += `of type ${types[0]}`;
                  break;
                case 2:
                  msg += `one of type ${types[0]} or ${types[1]}`;
                  break;
                default: {
                  const last = types.pop();
                  msg += `one of type ${types.join(", ")}, or ${last}`;
                }
              }
              if (instances.length > 0 || other.length > 0) {
                msg += " or ";
              }
            }
            if (instances.length > 0) {
              switch (instances.length) {
                case 1:
                  msg += `an instance of ${instances[0]}`;
                  break;
                case 2:
                  msg += `an instance of ${instances[0]} or ${instances[1]}`;
                  break;
                default: {
                  const last = instances.pop();
                  msg += `an instance of ${instances.join(", ")}, or ${last}`;
                }
              }
              if (other.length > 0) {
                msg += " or ";
              }
            }
            switch (other.length) {
              case 0:
                break;
              case 1:
                if (other[0].toLowerCase() !== other[0]) {
                  msg += "an ";
                }
                msg += `${other[0]}`;
                break;
              case 2:
                msg += `one of ${other[0]} or ${other[1]}`;
                break;
              default: {
                const last = other.pop();
                msg += `one of ${other.join(", ")}, or ${last}`;
              }
            }
            if (actual == null) {
              msg += `. Received ${actual}`;
            } else if (typeof actual === "function" && actual.name) {
              msg += `. Received function ${actual.name}`;
            } else if (typeof actual === "object") {
              var _actual$constructor;
              if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
                msg += `. Received an instance of ${actual.constructor.name}`;
              } else {
                const inspected = inspect(actual, {
                  depth: -1
                });
                msg += `. Received ${inspected}`;
              }
            } else {
              let inspected = inspect(actual, {
                colors: false
              });
              if (inspected.length > 25) {
                inspected = `${inspected.slice(0, 25)}...`;
              }
              msg += `. Received type ${typeof actual} (${inspected})`;
            }
            return msg;
          },
          TypeError
        );
        E(
          "ERR_INVALID_ARG_VALUE",
          (name2, value, reason = "is invalid") => {
            let inspected = inspect(value);
            if (inspected.length > 128) {
              inspected = inspected.slice(0, 128) + "...";
            }
            const type = name2.includes(".") ? "property" : "argument";
            return `The ${type} '${name2}' ${reason}. Received ${inspected}`;
          },
          TypeError
        );
        E(
          "ERR_INVALID_RETURN_VALUE",
          (input, name2, value) => {
            var _value$constructor;
            const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
            return `Expected ${input} to be returned from the "${name2}" function but got ${type}.`;
          },
          TypeError
        );
        E(
          "ERR_MISSING_ARGS",
          (...args) => {
            assert(args.length > 0, "At least one arg needs to be specified");
            let msg;
            const len = args.length;
            args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
            switch (len) {
              case 1:
                msg += `The ${args[0]} argument`;
                break;
              case 2:
                msg += `The ${args[0]} and ${args[1]} arguments`;
                break;
              default:
                {
                  const last = args.pop();
                  msg += `The ${args.join(", ")}, and ${last} arguments`;
                }
                break;
            }
            return `${msg} must be specified`;
          },
          TypeError
        );
        E(
          "ERR_OUT_OF_RANGE",
          (str, range, input) => {
            assert(range, 'Missing "range" argument');
            let received;
            if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
              received = addNumericalSeparator(String(input));
            } else if (typeof input === "bigint") {
              received = String(input);
              if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
              }
              received += "n";
            } else {
              received = inspect(input);
            }
            return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
          },
          RangeError
        );
        E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
        E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
        E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
        E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
        E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
        E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
        E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
        E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
        E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
        E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
        E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
        module2.exports = {
          AbortError,
          aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
          hideStackFrames,
          codes
        };
      }, { "./util": 119 }], 118: [function(require2, module2, exports2) {
        module2.exports = {
          ArrayIsArray(self2) {
            return Array.isArray(self2);
          },
          ArrayPrototypeIncludes(self2, el) {
            return self2.includes(el);
          },
          ArrayPrototypeIndexOf(self2, el) {
            return self2.indexOf(el);
          },
          ArrayPrototypeJoin(self2, sep) {
            return self2.join(sep);
          },
          ArrayPrototypeMap(self2, fn) {
            return self2.map(fn);
          },
          ArrayPrototypePop(self2, el) {
            return self2.pop(el);
          },
          ArrayPrototypePush(self2, el) {
            return self2.push(el);
          },
          ArrayPrototypeSlice(self2, start, end) {
            return self2.slice(start, end);
          },
          Error,
          FunctionPrototypeCall(fn, thisArgs, ...args) {
            return fn.call(thisArgs, ...args);
          },
          FunctionPrototypeSymbolHasInstance(self2, instance) {
            return Function.prototype[Symbol.hasInstance].call(self2, instance);
          },
          MathFloor: Math.floor,
          Number,
          NumberIsInteger: Number.isInteger,
          NumberIsNaN: Number.isNaN,
          NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
          NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
          NumberParseInt: Number.parseInt,
          ObjectDefineProperties(self2, props) {
            return Object.defineProperties(self2, props);
          },
          ObjectDefineProperty(self2, name2, prop) {
            return Object.defineProperty(self2, name2, prop);
          },
          ObjectGetOwnPropertyDescriptor(self2, name2) {
            return Object.getOwnPropertyDescriptor(self2, name2);
          },
          ObjectKeys(obj) {
            return Object.keys(obj);
          },
          ObjectSetPrototypeOf(target, proto) {
            return Object.setPrototypeOf(target, proto);
          },
          Promise,
          PromisePrototypeCatch(self2, fn) {
            return self2.catch(fn);
          },
          PromisePrototypeThen(self2, thenFn, catchFn) {
            return self2.then(thenFn, catchFn);
          },
          PromiseReject(err) {
            return Promise.reject(err);
          },
          ReflectApply: Reflect.apply,
          RegExpPrototypeTest(self2, value) {
            return self2.test(value);
          },
          SafeSet: Set,
          String,
          StringPrototypeSlice(self2, start, end) {
            return self2.slice(start, end);
          },
          StringPrototypeToLowerCase(self2) {
            return self2.toLowerCase();
          },
          StringPrototypeToUpperCase(self2) {
            return self2.toUpperCase();
          },
          StringPrototypeTrim(self2) {
            return self2.trim();
          },
          Symbol,
          SymbolAsyncIterator: Symbol.asyncIterator,
          SymbolHasInstance: Symbol.hasInstance,
          SymbolIterator: Symbol.iterator,
          TypedArrayPrototypeSet(self2, buf, len) {
            return self2.set(buf, len);
          },
          Uint8Array
        };
      }, {}], 119: [function(require2, module2, exports2) {
        const bufferModule = require2("buffer");
        const AsyncFunction = Object.getPrototypeOf(async function() {
        }).constructor;
        const Blob = globalThis.Blob || bufferModule.Blob;
        const isBlob = typeof Blob !== "undefined" ? function isBlob2(b) {
          return b instanceof Blob;
        } : function isBlob2(b) {
          return false;
        };
        class AggregateError extends Error {
          constructor(errors) {
            if (!Array.isArray(errors)) {
              throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
            }
            let message = "";
            for (let i = 0; i < errors.length; i++) {
              message += `    ${errors[i].stack}
`;
            }
            super(message);
            this.name = "AggregateError";
            this.errors = errors;
          }
        }
        module2.exports = {
          AggregateError,
          once(callback) {
            let called = false;
            return function(...args) {
              if (called) {
                return;
              }
              called = true;
              callback.apply(this, args);
            };
          },
          createDeferredPromise: function() {
            let resolve;
            let reject;
            const promise = new Promise((res, rej) => {
              resolve = res;
              reject = rej;
            });
            return {
              promise,
              resolve,
              reject
            };
          },
          promisify(fn) {
            return new Promise((resolve, reject) => {
              fn((err, ...args) => {
                if (err) {
                  return reject(err);
                }
                return resolve(...args);
              });
            });
          },
          debuglog() {
            return function() {
            };
          },
          format(format, ...args) {
            return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
              const replacement = args.shift();
              if (type === "f") {
                return replacement.toFixed(6);
              } else if (type === "j") {
                return JSON.stringify(replacement);
              } else if (type === "s" && typeof replacement === "object") {
                const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
                return `${ctor} {}`.trim();
              } else {
                return replacement.toString();
              }
            });
          },
          inspect(value) {
            switch (typeof value) {
              case "string":
                if (value.includes("'")) {
                  if (!value.includes('"')) {
                    return `"${value}"`;
                  } else if (!value.includes("`") && !value.includes("${")) {
                    return `\`${value}\``;
                  }
                }
                return `'${value}'`;
              case "number":
                if (isNaN(value)) {
                  return "NaN";
                } else if (Object.is(value, -0)) {
                  return String(value);
                }
                return value;
              case "bigint":
                return `${String(value)}n`;
              case "boolean":
              case "undefined":
                return String(value);
              case "object":
                return "{}";
            }
          },
          types: {
            isAsyncFunction(fn) {
              return fn instanceof AsyncFunction;
            },
            isArrayBufferView(arr) {
              return ArrayBuffer.isView(arr);
            }
          },
          isBlob
        };
        module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
      }, { "buffer": 20 }], 120: [function(require2, module2, exports2) {
        (function(Buffer) {
          (function() {
            const { ObjectDefineProperty, ObjectKeys, ReflectApply } = require2("./ours/primordials");
            const {
              promisify: { custom: customPromisify }
            } = require2("./ours/util");
            const { streamReturningOperators, promiseReturningOperators } = require2("./internal/streams/operators");
            const {
              codes: { ERR_ILLEGAL_CONSTRUCTOR }
            } = require2("./ours/errors");
            const compose = require2("./internal/streams/compose");
            const { pipeline } = require2("./internal/streams/pipeline");
            const { destroyer } = require2("./internal/streams/destroy");
            const eos = require2("./internal/streams/end-of-stream");
            const promises = require2("./stream/promises");
            const utils = require2("./internal/streams/utils");
            const Stream = module2.exports = require2("./internal/streams/legacy").Stream;
            Stream.isDisturbed = utils.isDisturbed;
            Stream.isErrored = utils.isErrored;
            Stream.isReadable = utils.isReadable;
            Stream.Readable = require2("./internal/streams/readable");
            for (const key of ObjectKeys(streamReturningOperators)) {
              let fn2 = function(...args) {
                if (new.target) {
                  throw ERR_ILLEGAL_CONSTRUCTOR();
                }
                return Stream.Readable.from(ReflectApply(op, this, args));
              };
              const op = streamReturningOperators[key];
              ObjectDefineProperty(fn2, "name", {
                value: op.name
              });
              ObjectDefineProperty(fn2, "length", {
                value: op.length
              });
              ObjectDefineProperty(Stream.Readable.prototype, key, {
                value: fn2,
                enumerable: false,
                configurable: true,
                writable: true
              });
            }
            for (const key of ObjectKeys(promiseReturningOperators)) {
              let fn2 = function(...args) {
                if (new.target) {
                  throw ERR_ILLEGAL_CONSTRUCTOR();
                }
                return ReflectApply(op, this, args);
              };
              const op = promiseReturningOperators[key];
              ObjectDefineProperty(fn2, "name", {
                value: op.name
              });
              ObjectDefineProperty(fn2, "length", {
                value: op.length
              });
              ObjectDefineProperty(Stream.Readable.prototype, key, {
                value: fn2,
                enumerable: false,
                configurable: true,
                writable: true
              });
            }
            Stream.Writable = require2("./internal/streams/writable");
            Stream.Duplex = require2("./internal/streams/duplex");
            Stream.Transform = require2("./internal/streams/transform");
            Stream.PassThrough = require2("./internal/streams/passthrough");
            Stream.pipeline = pipeline;
            const { addAbortSignal } = require2("./internal/streams/add-abort-signal");
            Stream.addAbortSignal = addAbortSignal;
            Stream.finished = eos;
            Stream.destroy = destroyer;
            Stream.compose = compose;
            ObjectDefineProperty(Stream, "promises", {
              configurable: true,
              enumerable: true,
              get() {
                return promises;
              }
            });
            ObjectDefineProperty(pipeline, customPromisify, {
              enumerable: true,
              get() {
                return promises.pipeline;
              }
            });
            ObjectDefineProperty(eos, customPromisify, {
              enumerable: true,
              get() {
                return promises.finished;
              }
            });
            Stream.Stream = Stream;
            Stream._isUint8Array = function isUint8Array(value) {
              return value instanceof Uint8Array;
            };
            Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
              return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            };
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "./internal/streams/add-abort-signal": 98, "./internal/streams/compose": 100, "./internal/streams/destroy": 101, "./internal/streams/duplex": 102, "./internal/streams/end-of-stream": 104, "./internal/streams/legacy": 106, "./internal/streams/operators": 107, "./internal/streams/passthrough": 108, "./internal/streams/pipeline": 109, "./internal/streams/readable": 110, "./internal/streams/transform": 112, "./internal/streams/utils": 113, "./internal/streams/writable": 114, "./ours/errors": 117, "./ours/primordials": 118, "./ours/util": 119, "./stream/promises": 121, "buffer": 20 }], 121: [function(require2, module2, exports2) {
        const { ArrayPrototypePop, Promise: Promise2 } = require2("../ours/primordials");
        const { isIterable, isNodeStream } = require2("../internal/streams/utils");
        const { pipelineImpl: pl } = require2("../internal/streams/pipeline");
        const { finished } = require2("../internal/streams/end-of-stream");
        function pipeline(...streams) {
          return new Promise2((resolve, reject) => {
            let signal;
            let end;
            const lastArg = streams[streams.length - 1];
            if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
              const options = ArrayPrototypePop(streams);
              signal = options.signal;
              end = options.end;
            }
            pl(
              streams,
              (err, value) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(value);
                }
              },
              {
                signal,
                end
              }
            );
          });
        }
        module2.exports = {
          finished,
          pipeline
        };
      }, { "../internal/streams/end-of-stream": 104, "../internal/streams/pipeline": 109, "../internal/streams/utils": 113, "../ours/primordials": 118 }], 122: [function(require2, module2, exports2) {
        function ReInterval(callback, interval, args) {
          var self2 = this;
          this._callback = callback;
          this._args = args;
          this._interval = setInterval(callback, interval, this._args);
          this.reschedule = function(interval2) {
            if (!interval2)
              interval2 = self2._interval;
            if (self2._interval)
              clearInterval(self2._interval);
            self2._interval = setInterval(self2._callback, interval2, self2._args);
          };
          this.clear = function() {
            if (self2._interval) {
              clearInterval(self2._interval);
              self2._interval = void 0;
            }
          };
          this.destroy = function() {
            if (self2._interval) {
              clearInterval(self2._interval);
            }
            self2._callback = void 0;
            self2._interval = void 0;
            self2._args = void 0;
          };
        }
        function reInterval() {
          if (typeof arguments[0] !== "function")
            throw new Error("callback needed");
          if (typeof arguments[1] !== "number")
            throw new Error("interval needed");
          var args;
          if (arguments.length > 0) {
            args = new Array(arguments.length - 2);
            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i + 2];
            }
          }
          return new ReInterval(arguments[0], arguments[1], args);
        }
        module2.exports = reInterval;
      }, {}], 123: [function(require2, module2, exports2) {
        module2.exports = require2("./index.js")();
      }, { "./index.js": 124 }], 124: [function(require2, module2, exports2) {
        (function(Buffer) {
          (function() {
            module2.exports = rfdc;
            function copyBuffer(cur) {
              if (cur instanceof Buffer) {
                return Buffer.from(cur);
              }
              return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
            }
            function rfdc(opts) {
              opts = opts || {};
              if (opts.circles)
                return rfdcCircles(opts);
              return opts.proto ? cloneProto : clone;
              function cloneArray(a, fn) {
                var keys = Object.keys(a);
                var a2 = new Array(keys.length);
                for (var i = 0; i < keys.length; i++) {
                  var k = keys[i];
                  var cur = a[k];
                  if (typeof cur !== "object" || cur === null) {
                    a2[k] = cur;
                  } else if (cur instanceof Date) {
                    a2[k] = new Date(cur);
                  } else if (ArrayBuffer.isView(cur)) {
                    a2[k] = copyBuffer(cur);
                  } else {
                    a2[k] = fn(cur);
                  }
                }
                return a2;
              }
              function clone(o) {
                if (typeof o !== "object" || o === null)
                  return o;
                if (o instanceof Date)
                  return new Date(o);
                if (Array.isArray(o))
                  return cloneArray(o, clone);
                if (o instanceof Map)
                  return new Map(cloneArray(Array.from(o), clone));
                if (o instanceof Set)
                  return new Set(cloneArray(Array.from(o), clone));
                var o2 = {};
                for (var k in o) {
                  if (Object.hasOwnProperty.call(o, k) === false)
                    continue;
                  var cur = o[k];
                  if (typeof cur !== "object" || cur === null) {
                    o2[k] = cur;
                  } else if (cur instanceof Date) {
                    o2[k] = new Date(cur);
                  } else if (cur instanceof Map) {
                    o2[k] = new Map(cloneArray(Array.from(cur), clone));
                  } else if (cur instanceof Set) {
                    o2[k] = new Set(cloneArray(Array.from(cur), clone));
                  } else if (ArrayBuffer.isView(cur)) {
                    o2[k] = copyBuffer(cur);
                  } else {
                    o2[k] = clone(cur);
                  }
                }
                return o2;
              }
              function cloneProto(o) {
                if (typeof o !== "object" || o === null)
                  return o;
                if (o instanceof Date)
                  return new Date(o);
                if (Array.isArray(o))
                  return cloneArray(o, cloneProto);
                if (o instanceof Map)
                  return new Map(cloneArray(Array.from(o), cloneProto));
                if (o instanceof Set)
                  return new Set(cloneArray(Array.from(o), cloneProto));
                var o2 = {};
                for (var k in o) {
                  var cur = o[k];
                  if (typeof cur !== "object" || cur === null) {
                    o2[k] = cur;
                  } else if (cur instanceof Date) {
                    o2[k] = new Date(cur);
                  } else if (cur instanceof Map) {
                    o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
                  } else if (cur instanceof Set) {
                    o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
                  } else if (ArrayBuffer.isView(cur)) {
                    o2[k] = copyBuffer(cur);
                  } else {
                    o2[k] = cloneProto(cur);
                  }
                }
                return o2;
              }
            }
            function rfdcCircles(opts) {
              var refs = [];
              var refsNew = [];
              return opts.proto ? cloneProto : clone;
              function cloneArray(a, fn) {
                var keys = Object.keys(a);
                var a2 = new Array(keys.length);
                for (var i = 0; i < keys.length; i++) {
                  var k = keys[i];
                  var cur = a[k];
                  if (typeof cur !== "object" || cur === null) {
                    a2[k] = cur;
                  } else if (cur instanceof Date) {
                    a2[k] = new Date(cur);
                  } else if (ArrayBuffer.isView(cur)) {
                    a2[k] = copyBuffer(cur);
                  } else {
                    var index2 = refs.indexOf(cur);
                    if (index2 !== -1) {
                      a2[k] = refsNew[index2];
                    } else {
                      a2[k] = fn(cur);
                    }
                  }
                }
                return a2;
              }
              function clone(o) {
                if (typeof o !== "object" || o === null)
                  return o;
                if (o instanceof Date)
                  return new Date(o);
                if (Array.isArray(o))
                  return cloneArray(o, clone);
                if (o instanceof Map)
                  return new Map(cloneArray(Array.from(o), clone));
                if (o instanceof Set)
                  return new Set(cloneArray(Array.from(o), clone));
                var o2 = {};
                refs.push(o);
                refsNew.push(o2);
                for (var k in o) {
                  if (Object.hasOwnProperty.call(o, k) === false)
                    continue;
                  var cur = o[k];
                  if (typeof cur !== "object" || cur === null) {
                    o2[k] = cur;
                  } else if (cur instanceof Date) {
                    o2[k] = new Date(cur);
                  } else if (cur instanceof Map) {
                    o2[k] = new Map(cloneArray(Array.from(cur), clone));
                  } else if (cur instanceof Set) {
                    o2[k] = new Set(cloneArray(Array.from(cur), clone));
                  } else if (ArrayBuffer.isView(cur)) {
                    o2[k] = copyBuffer(cur);
                  } else {
                    var i = refs.indexOf(cur);
                    if (i !== -1) {
                      o2[k] = refsNew[i];
                    } else {
                      o2[k] = clone(cur);
                    }
                  }
                }
                refs.pop();
                refsNew.pop();
                return o2;
              }
              function cloneProto(o) {
                if (typeof o !== "object" || o === null)
                  return o;
                if (o instanceof Date)
                  return new Date(o);
                if (Array.isArray(o))
                  return cloneArray(o, cloneProto);
                if (o instanceof Map)
                  return new Map(cloneArray(Array.from(o), cloneProto));
                if (o instanceof Set)
                  return new Set(cloneArray(Array.from(o), cloneProto));
                var o2 = {};
                refs.push(o);
                refsNew.push(o2);
                for (var k in o) {
                  var cur = o[k];
                  if (typeof cur !== "object" || cur === null) {
                    o2[k] = cur;
                  } else if (cur instanceof Date) {
                    o2[k] = new Date(cur);
                  } else if (cur instanceof Map) {
                    o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
                  } else if (cur instanceof Set) {
                    o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
                  } else if (ArrayBuffer.isView(cur)) {
                    o2[k] = copyBuffer(cur);
                  } else {
                    var i = refs.indexOf(cur);
                    if (i !== -1) {
                      o2[k] = refsNew[i];
                    } else {
                      o2[k] = cloneProto(cur);
                    }
                  }
                }
                refs.pop();
                refsNew.pop();
                return o2;
              }
            }
          }).call(this);
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 20 }], 125: [function(require2, module2, exports2) {
        /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
        var buffer = require2("buffer");
        var Buffer = buffer.Buffer;
        function copyProps(src2, dst) {
          for (var key in src2) {
            dst[key] = src2[key];
          }
        }
        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
          module2.exports = buffer;
        } else {
          copyProps(buffer, exports2);
          exports2.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length);
        }
        SafeBuffer.prototype = Object.create(Buffer.prototype);
        copyProps(Buffer, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding2) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer(size);
          if (fill !== void 0) {
            if (typeof encoding2 === "string") {
              buf.fill(fill, encoding2);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      }, { "buffer": 20 }], 126: [function(require2, module2, exports2) {
        module2.exports = shift;
        function shift(stream) {
          var rs = stream._readableState;
          if (!rs)
            return null;
          return rs.objectMode || typeof stream._duplexState === "number" ? stream.read() : stream.read(getStateLength(rs));
        }
        function getStateLength(state) {
          if (state.buffer.length) {
            if (state.buffer.head) {
              return state.buffer.head.data.length;
            }
            return state.buffer[0].length;
          }
          return state.length;
        }
      }, {}], 127: [function(require2, module2, exports2) {
        arguments[4][19][0].apply(exports2, arguments);
      }, { "dup": 19, "safe-buffer": 125 }], 128: [function(require2, module2, exports2) {
        var punycode = require2("punycode");
        var util2 = require2("./util");
        exports2.parse = urlParse;
        exports2.resolve = urlResolve;
        exports2.resolveObject = urlResolveObject;
        exports2.format = urlFormat;
        exports2.Url = Url;
        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
          "javascript": true,
          "javascript:": true
        }, hostlessProtocol = {
          "javascript": true,
          "javascript:": true
        }, slashedProtocol = {
          "http": true,
          "https": true,
          "ftp": true,
          "gopher": true,
          "file": true,
          "http:": true,
          "https:": true,
          "ftp:": true,
          "gopher:": true,
          "file:": true
        }, querystring = require2("querystring");
        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && util2.isObject(url) && url instanceof Url)
            return url;
          var u = new Url();
          u.parse(url, parseQueryString, slashesDenoteHost);
          return u;
        }
        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
          if (!util2.isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
          }
          var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
          uSplit[0] = uSplit[0].replace(slashRegex, "/");
          url = uSplit.join(splitter);
          var rest = url;
          rest = rest.trim();
          if (!slashesDenoteHost && url.split("#").length === 1) {
            var simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
              this.path = rest;
              this.href = rest;
              this.pathname = simplePath[1];
              if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                  this.query = querystring.parse(this.search.substr(1));
                } else {
                  this.query = this.search.substr(1);
                }
              } else if (parseQueryString) {
                this.search = "";
                this.query = {};
              }
              return this;
            }
          }
          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }
          if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === "//";
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }
          if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            var auth, atSign;
            if (hostEnd === -1) {
              atSign = rest.lastIndexOf("@");
            } else {
              atSign = rest.lastIndexOf("@", hostEnd);
            }
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            if (hostEnd === -1)
              hostEnd = rest.length;
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            this.parseHost();
            this.hostname = this.hostname || "";
            var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./);
              for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part)
                  continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = "";
                  for (var j = 0, k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      newpart += "x";
                    } else {
                      newpart += part[j];
                    }
                  }
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = "/" + notHost.join(".") + rest;
                    }
                    this.hostname = validParts.join(".");
                    break;
                  }
                }
              }
            }
            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = "";
            } else {
              this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
              this.hostname = punycode.toASCII(this.hostname);
            }
            var p = this.port ? ":" + this.port : "";
            var h = this.hostname || "";
            this.host = h + p;
            this.href += this.host;
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== "/") {
                rest = "/" + rest;
              }
            }
          }
          if (!unsafeProtocol[lowerProto]) {
            for (var i = 0, l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              if (rest.indexOf(ae) === -1)
                continue;
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }
          var hash = rest.indexOf("#");
          if (hash !== -1) {
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf("?");
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          if (rest)
            this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = "/";
          }
          if (this.pathname || this.search) {
            var p = this.pathname || "";
            var s = this.search || "";
            this.path = p + s;
          }
          this.href = this.format();
          return this;
        };
        function urlFormat(obj) {
          if (util2.isString(obj))
            obj = urlParse(obj);
          if (!(obj instanceof Url))
            return Url.prototype.format.call(obj);
          return obj.format();
        }
        Url.prototype.format = function() {
          var auth = this.auth || "";
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ":");
            auth += "@";
          }
          var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
            if (this.port) {
              host += ":" + this.port;
            }
          }
          if (this.query && util2.isObject(this.query) && Object.keys(this.query).length) {
            query = querystring.stringify(this.query);
          }
          var search = this.search || query && "?" + query || "";
          if (protocol && protocol.substr(-1) !== ":")
            protocol += ":";
          if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
            host = "//" + (host || "");
            if (pathname && pathname.charAt(0) !== "/")
              pathname = "/" + pathname;
          } else if (!host) {
            host = "";
          }
          if (hash && hash.charAt(0) !== "#")
            hash = "#" + hash;
          if (search && search.charAt(0) !== "?")
            search = "?" + search;
          pathname = pathname.replace(/[?#]/g, function(match) {
            return encodeURIComponent(match);
          });
          search = search.replace("#", "%23");
          return protocol + host + pathname + search + hash;
        };
        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }
        Url.prototype.resolve = function(relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };
        function urlResolveObject(source, relative) {
          if (!source)
            return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }
        Url.prototype.resolveObject = function(relative) {
          if (util2.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }
          var result = new Url();
          var tkeys = Object.keys(this);
          for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
          }
          result.hash = relative.hash;
          if (relative.href === "") {
            result.href = result.format();
            return result;
          }
          if (relative.slashes && !relative.protocol) {
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
              var rkey = rkeys[rk];
              if (rkey !== "protocol")
                result[rkey] = relative[rkey];
            }
            if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
              result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
          }
          if (relative.protocol && relative.protocol !== result.protocol) {
            if (!slashedProtocol[relative.protocol]) {
              var keys = Object.keys(relative);
              for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
              }
              result.href = result.format();
              return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || "").split("/");
              while (relPath.length && !(relative.host = relPath.shift()))
                ;
              if (!relative.host)
                relative.host = "";
              if (!relative.hostname)
                relative.hostname = "";
              if (relPath[0] !== "")
                relPath.unshift("");
              if (relPath.length < 2)
                relPath.unshift("");
              result.pathname = relPath.join("/");
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || "";
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            if (result.pathname || result.search) {
              var p = result.pathname || "";
              var s = result.search || "";
              result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }
          var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
          if (psychotic) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
              if (srcPath[0] === "")
                srcPath[0] = result.host;
              else
                srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === "")
                  relPath[0] = relative.host;
                else
                  relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
          }
          if (isRelAbs) {
            result.host = relative.host || relative.host === "" ? relative.host : result.host;
            result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
          } else if (relPath.length) {
            if (!srcPath)
              srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!util2.isNullOrUndefined(relative.search)) {
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            if (!util2.isNull(result.pathname) || !util2.isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
          }
          if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
              result.path = "/" + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === ".") {
              srcPath.splice(i, 1);
            } else if (last === "..") {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift("..");
            }
          }
          if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
          }
          if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
          }
          var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
          if (psychotic) {
            result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          mustEndAbs = mustEndAbs || result.host && srcPath.length;
          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift("");
          }
          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join("/");
          }
          if (!util2.isNull(result.pathname) || !util2.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };
        Url.prototype.parseHost = function() {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ":") {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host)
            this.hostname = host;
        };
      }, { "./util": 129, "punycode": 94, "querystring": 97 }], 129: [function(require2, module2, exports2) {
        module2.exports = {
          isString: function(arg) {
            return typeof arg === "string";
          },
          isObject: function(arg) {
            return typeof arg === "object" && arg !== null;
          },
          isNull: function(arg) {
            return arg === null;
          },
          isNullOrUndefined: function(arg) {
            return arg == null;
          }
        };
      }, {}], 130: [function(require2, module2, exports2) {
        (function(global2) {
          (function() {
            module2.exports = deprecate;
            function deprecate(fn, msg) {
              if (config2("noDeprecation")) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (config2("throwDeprecation")) {
                    throw new Error(msg);
                  } else if (config2("traceDeprecation")) {
                    console.trace(msg);
                  } else {
                    console.warn(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            }
            function config2(name2) {
              try {
                if (!global2.localStorage)
                  return false;
              } catch (_) {
                return false;
              }
              var val = global2.localStorage[name2];
              if (null == val)
                return false;
              return String(val).toLowerCase() === "true";
            }
          }).call(this);
        }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 131: [function(require2, module2, exports2) {
        module2.exports = wrappy;
        function wrappy(fn, cb) {
          if (fn && cb)
            return wrappy(fn)(cb);
          if (typeof fn !== "function")
            throw new TypeError("need wrapper function");
          Object.keys(fn).forEach(function(k) {
            wrapper[k] = fn[k];
          });
          return wrapper;
          function wrapper() {
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i];
            }
            var ret = fn.apply(this, args);
            var cb2 = args[args.length - 1];
            if (typeof ret === "function" && ret !== cb2) {
              Object.keys(cb2).forEach(function(k) {
                ret[k] = cb2[k];
              });
            }
            return ret;
          }
        }
      }, {}], 132: [function(require2, module2, exports2) {
        module2.exports = function() {
          throw new Error(
            "ws does not work in the browser. Browser clients must use the native WebSocket object"
          );
        };
      }, {}], 133: [function(require2, module2, exports2) {
        module2.exports = extend;
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        function extend() {
          var target = {};
          for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (hasOwnProperty2.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        }
      }, {}], 134: [function(require2, module2, exports2) {
        module2.exports = function(Yallist) {
          Yallist.prototype[Symbol.iterator] = function* () {
            for (let walker = this.head; walker; walker = walker.next) {
              yield walker.value;
            }
          };
        };
      }, {}], 135: [function(require2, module2, exports2) {
        module2.exports = Yallist;
        Yallist.Node = Node;
        Yallist.create = Yallist;
        function Yallist(list) {
          var self2 = this;
          if (!(self2 instanceof Yallist)) {
            self2 = new Yallist();
          }
          self2.tail = null;
          self2.head = null;
          self2.length = 0;
          if (list && typeof list.forEach === "function") {
            list.forEach(function(item) {
              self2.push(item);
            });
          } else if (arguments.length > 0) {
            for (var i = 0, l = arguments.length; i < l; i++) {
              self2.push(arguments[i]);
            }
          }
          return self2;
        }
        Yallist.prototype.removeNode = function(node) {
          if (node.list !== this) {
            throw new Error("removing node which does not belong to this list");
          }
          var next = node.next;
          var prev = node.prev;
          if (next) {
            next.prev = prev;
          }
          if (prev) {
            prev.next = next;
          }
          if (node === this.head) {
            this.head = next;
          }
          if (node === this.tail) {
            this.tail = prev;
          }
          node.list.length--;
          node.next = null;
          node.prev = null;
          node.list = null;
          return next;
        };
        Yallist.prototype.unshiftNode = function(node) {
          if (node === this.head) {
            return;
          }
          if (node.list) {
            node.list.removeNode(node);
          }
          var head = this.head;
          node.list = this;
          node.next = head;
          if (head) {
            head.prev = node;
          }
          this.head = node;
          if (!this.tail) {
            this.tail = node;
          }
          this.length++;
        };
        Yallist.prototype.pushNode = function(node) {
          if (node === this.tail) {
            return;
          }
          if (node.list) {
            node.list.removeNode(node);
          }
          var tail = this.tail;
          node.list = this;
          node.prev = tail;
          if (tail) {
            tail.next = node;
          }
          this.tail = node;
          if (!this.head) {
            this.head = node;
          }
          this.length++;
        };
        Yallist.prototype.push = function() {
          for (var i = 0, l = arguments.length; i < l; i++) {
            push(this, arguments[i]);
          }
          return this.length;
        };
        Yallist.prototype.unshift = function() {
          for (var i = 0, l = arguments.length; i < l; i++) {
            unshift(this, arguments[i]);
          }
          return this.length;
        };
        Yallist.prototype.pop = function() {
          if (!this.tail) {
            return void 0;
          }
          var res = this.tail.value;
          this.tail = this.tail.prev;
          if (this.tail) {
            this.tail.next = null;
          } else {
            this.head = null;
          }
          this.length--;
          return res;
        };
        Yallist.prototype.shift = function() {
          if (!this.head) {
            return void 0;
          }
          var res = this.head.value;
          this.head = this.head.next;
          if (this.head) {
            this.head.prev = null;
          } else {
            this.tail = null;
          }
          this.length--;
          return res;
        };
        Yallist.prototype.forEach = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.head, i = 0; walker !== null; i++) {
            fn.call(thisp, walker.value, i, this);
            walker = walker.next;
          }
        };
        Yallist.prototype.forEachReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
            fn.call(thisp, walker.value, i, this);
            walker = walker.prev;
          }
        };
        Yallist.prototype.get = function(n) {
          for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
            walker = walker.next;
          }
          if (i === n && walker !== null) {
            return walker.value;
          }
        };
        Yallist.prototype.getReverse = function(n) {
          for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
            walker = walker.prev;
          }
          if (i === n && walker !== null) {
            return walker.value;
          }
        };
        Yallist.prototype.map = function(fn, thisp) {
          thisp = thisp || this;
          var res = new Yallist();
          for (var walker = this.head; walker !== null; ) {
            res.push(fn.call(thisp, walker.value, this));
            walker = walker.next;
          }
          return res;
        };
        Yallist.prototype.mapReverse = function(fn, thisp) {
          thisp = thisp || this;
          var res = new Yallist();
          for (var walker = this.tail; walker !== null; ) {
            res.push(fn.call(thisp, walker.value, this));
            walker = walker.prev;
          }
          return res;
        };
        Yallist.prototype.reduce = function(fn, initial) {
          var acc;
          var walker = this.head;
          if (arguments.length > 1) {
            acc = initial;
          } else if (this.head) {
            walker = this.head.next;
            acc = this.head.value;
          } else {
            throw new TypeError("Reduce of empty list with no initial value");
          }
          for (var i = 0; walker !== null; i++) {
            acc = fn(acc, walker.value, i);
            walker = walker.next;
          }
          return acc;
        };
        Yallist.prototype.reduceReverse = function(fn, initial) {
          var acc;
          var walker = this.tail;
          if (arguments.length > 1) {
            acc = initial;
          } else if (this.tail) {
            walker = this.tail.prev;
            acc = this.tail.value;
          } else {
            throw new TypeError("Reduce of empty list with no initial value");
          }
          for (var i = this.length - 1; walker !== null; i--) {
            acc = fn(acc, walker.value, i);
            walker = walker.prev;
          }
          return acc;
        };
        Yallist.prototype.toArray = function() {
          var arr = new Array(this.length);
          for (var i = 0, walker = this.head; walker !== null; i++) {
            arr[i] = walker.value;
            walker = walker.next;
          }
          return arr;
        };
        Yallist.prototype.toArrayReverse = function() {
          var arr = new Array(this.length);
          for (var i = 0, walker = this.tail; walker !== null; i++) {
            arr[i] = walker.value;
            walker = walker.prev;
          }
          return arr;
        };
        Yallist.prototype.slice = function(from, to) {
          to = to || this.length;
          if (to < 0) {
            to += this.length;
          }
          from = from || 0;
          if (from < 0) {
            from += this.length;
          }
          var ret = new Yallist();
          if (to < from || to < 0) {
            return ret;
          }
          if (from < 0) {
            from = 0;
          }
          if (to > this.length) {
            to = this.length;
          }
          for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
            walker = walker.next;
          }
          for (; walker !== null && i < to; i++, walker = walker.next) {
            ret.push(walker.value);
          }
          return ret;
        };
        Yallist.prototype.sliceReverse = function(from, to) {
          to = to || this.length;
          if (to < 0) {
            to += this.length;
          }
          from = from || 0;
          if (from < 0) {
            from += this.length;
          }
          var ret = new Yallist();
          if (to < from || to < 0) {
            return ret;
          }
          if (from < 0) {
            from = 0;
          }
          if (to > this.length) {
            to = this.length;
          }
          for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
            walker = walker.prev;
          }
          for (; walker !== null && i > from; i--, walker = walker.prev) {
            ret.push(walker.value);
          }
          return ret;
        };
        Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
          if (start > this.length) {
            start = this.length - 1;
          }
          if (start < 0) {
            start = this.length + start;
          }
          for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
            walker = walker.next;
          }
          var ret = [];
          for (var i = 0; walker && i < deleteCount; i++) {
            ret.push(walker.value);
            walker = this.removeNode(walker);
          }
          if (walker === null) {
            walker = this.tail;
          }
          if (walker !== this.head && walker !== this.tail) {
            walker = walker.prev;
          }
          for (var i = 0; i < nodes.length; i++) {
            walker = insert2(this, walker, nodes[i]);
          }
          return ret;
        };
        Yallist.prototype.reverse = function() {
          var head = this.head;
          var tail = this.tail;
          for (var walker = head; walker !== null; walker = walker.prev) {
            var p = walker.prev;
            walker.prev = walker.next;
            walker.next = p;
          }
          this.head = tail;
          this.tail = head;
          return this;
        };
        function insert2(self2, node, value) {
          var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
          if (inserted.next === null) {
            self2.tail = inserted;
          }
          if (inserted.prev === null) {
            self2.head = inserted;
          }
          self2.length++;
          return inserted;
        }
        function push(self2, item) {
          self2.tail = new Node(item, self2.tail, null, self2);
          if (!self2.head) {
            self2.head = self2.tail;
          }
          self2.length++;
        }
        function unshift(self2, item) {
          self2.head = new Node(item, null, self2.head, self2);
          if (!self2.tail) {
            self2.tail = self2.head;
          }
          self2.length++;
        }
        function Node(value, prev, next, list) {
          if (!(this instanceof Node)) {
            return new Node(value, prev, next, list);
          }
          this.list = list;
          this.value = value;
          if (prev) {
            prev.next = this;
            this.prev = prev;
          } else {
            this.prev = null;
          }
          if (next) {
            next.prev = this;
            this.next = next;
          } else {
            this.next = null;
          }
        }
        try {
          require2("./iterator.js")(Yallist);
        } catch (er) {
        }
      }, { "./iterator.js": 134 }] }, {}, [14])(14);
    });
  })(mqtt$1);
  var mqttExports = mqtt$1.exports;
  const mqtt = /* @__PURE__ */ getDefaultExportFromCjs(mqttExports);
  const _tmpl$$1 = /* @__PURE__ */ template(`<svg stroke-width="0"></svg>`, 2), _tmpl$2$1 = /* @__PURE__ */ template(`<title></title>`, 2);
  function IconTemplate(iconSrc, props) {
    const mergedProps = mergeProps(iconSrc.a, props);
    const [_, svgProps] = splitProps(mergedProps, ["src"]);
    return (() => {
      const _el$ = _tmpl$$1.cloneNode(true);
      spread(_el$, mergeProps({
        get stroke() {
          return iconSrc.a.stroke;
        },
        get color() {
          return props.color || "currentColor";
        },
        get style() {
          return {
            ...props.style,
            overflow: "visible"
          };
        }
      }, svgProps, {
        get height() {
          return props.size || "1em";
        },
        get width() {
          return props.size || "1em";
        },
        get innerHTML() {
          return iconSrc.c;
        },
        "xmlns": "http://www.w3.org/2000/svg"
      }), true, true);
      insert(_el$, () => isServer, null);
      insert(_el$, (() => {
        const _c$ = createMemo(() => !!props.title);
        return () => _c$() && (() => {
          const _el$2 = _tmpl$2$1.cloneNode(true);
          insert(_el$2, () => props.title);
          return _el$2;
        })();
      })(), null);
      return _el$;
    })();
  }
  function FiArrowDown(props) {
    return IconTemplate({
      a: { "fill": "none", "stroke": "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2", "viewBox": "0 0 24 24" },
      c: '<path d="M12 5v14M19 12l-7 7-7-7"/>'
    }, props);
  }
  var config$2 = {};
  var util$2 = {};
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil)
      return util$2;
    hasRequiredUtil = 1;
    var config2 = requireConfig();
    var fromCharCode = String.fromCharCode;
    var slice = Array.prototype.slice;
    var toString = Object.prototype.toString;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var nativeIsArray = Array.isArray;
    var nativeObjectKeys = Object.keys;
    function isObject(x) {
      var type = typeof x;
      return type === "function" || type === "object" && !!x;
    }
    util$2.isObject = isObject;
    function isArray(x) {
      return nativeIsArray ? nativeIsArray(x) : toString.call(x) === "[object Array]";
    }
    util$2.isArray = isArray;
    function isString(x) {
      return typeof x === "string" || toString.call(x) === "[object String]";
    }
    util$2.isString = isString;
    function objectKeys(object) {
      if (nativeObjectKeys) {
        return nativeObjectKeys(object);
      }
      var keys = [];
      for (var key in object) {
        if (hasOwnProperty2.call(object, key)) {
          keys[keys.length] = key;
        }
      }
      return keys;
    }
    util$2.objectKeys = objectKeys;
    function createBuffer(bits, size) {
      if (config2.HAS_TYPED) {
        switch (bits) {
          case 8:
            return new Uint8Array(size);
          case 16:
            return new Uint16Array(size);
        }
      }
      return new Array(size);
    }
    util$2.createBuffer = createBuffer;
    function stringToBuffer(string) {
      var length = string.length;
      var buffer = createBuffer(16, length);
      for (var i = 0; i < length; i++) {
        buffer[i] = string.charCodeAt(i);
      }
      return buffer;
    }
    util$2.stringToBuffer = stringToBuffer;
    function codeToString_fast(code) {
      if (config2.CAN_CHARCODE_APPLY && config2.CAN_CHARCODE_APPLY_TYPED) {
        var len = code && code.length;
        if (len < config2.APPLY_BUFFER_SIZE && config2.APPLY_BUFFER_SIZE_OK) {
          return fromCharCode.apply(null, code);
        }
        if (config2.APPLY_BUFFER_SIZE_OK === null) {
          try {
            var s = fromCharCode.apply(null, code);
            if (len > config2.APPLY_BUFFER_SIZE) {
              config2.APPLY_BUFFER_SIZE_OK = true;
            }
            return s;
          } catch (e) {
            config2.APPLY_BUFFER_SIZE_OK = false;
          }
        }
      }
      return codeToString_chunked(code);
    }
    util$2.codeToString_fast = codeToString_fast;
    function codeToString_chunked(code) {
      var string = "";
      var length = code && code.length;
      var i = 0;
      var sub;
      while (i < length) {
        if (code.subarray) {
          sub = code.subarray(i, i + config2.APPLY_BUFFER_SIZE);
        } else {
          sub = code.slice(i, i + config2.APPLY_BUFFER_SIZE);
        }
        i += config2.APPLY_BUFFER_SIZE;
        if (config2.APPLY_BUFFER_SIZE_OK) {
          string += fromCharCode.apply(null, sub);
          continue;
        }
        if (config2.APPLY_BUFFER_SIZE_OK === null) {
          try {
            string += fromCharCode.apply(null, sub);
            if (sub.length > config2.APPLY_BUFFER_SIZE) {
              config2.APPLY_BUFFER_SIZE_OK = true;
            }
            continue;
          } catch (e) {
            config2.APPLY_BUFFER_SIZE_OK = false;
          }
        }
        return codeToString_slow(code);
      }
      return string;
    }
    util$2.codeToString_chunked = codeToString_chunked;
    function codeToString_slow(code) {
      var string = "";
      var length = code && code.length;
      for (var i = 0; i < length; i++) {
        string += fromCharCode(code[i]);
      }
      return string;
    }
    util$2.codeToString_slow = codeToString_slow;
    function stringToCode(string) {
      var code = [];
      var len = string && string.length;
      for (var i = 0; i < len; i++) {
        code[i] = string.charCodeAt(i);
      }
      return code;
    }
    util$2.stringToCode = stringToCode;
    function codeToBuffer(code) {
      if (config2.HAS_TYPED) {
        return new Uint16Array(code);
      }
      if (isArray(code)) {
        return code;
      }
      var length = code && code.length;
      var buffer = [];
      for (var i = 0; i < length; i++) {
        buffer[i] = code[i];
      }
      return buffer;
    }
    util$2.codeToBuffer = codeToBuffer;
    function bufferToCode(buffer) {
      if (isArray(buffer)) {
        return buffer;
      }
      return slice.call(buffer);
    }
    util$2.bufferToCode = bufferToCode;
    function canonicalizeEncodingName(target) {
      var name2 = "";
      var expect = ("" + target).toUpperCase().replace(/[^A-Z0-9]+/g, "");
      var aliasNames = objectKeys(config2.EncodingAliases);
      var len = aliasNames.length;
      var hit = 0;
      var encoding2, encodingLen, j;
      for (var i = 0; i < len; i++) {
        encoding2 = aliasNames[i];
        if (encoding2 === expect) {
          name2 = encoding2;
          break;
        }
        encodingLen = encoding2.length;
        for (j = hit; j < encodingLen; j++) {
          if (encoding2.slice(0, j) === expect.slice(0, j) || encoding2.slice(-j) === expect.slice(-j)) {
            name2 = encoding2;
            hit = j;
          }
        }
      }
      if (hasOwnProperty2.call(config2.EncodingAliases, name2)) {
        return config2.EncodingAliases[name2];
      }
      return name2;
    }
    util$2.canonicalizeEncodingName = canonicalizeEncodingName;
    var base64EncodeChars = [
      65,
      66,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      97,
      98,
      99,
      100,
      101,
      102,
      103,
      104,
      105,
      106,
      107,
      108,
      109,
      110,
      111,
      112,
      113,
      114,
      115,
      116,
      117,
      118,
      119,
      120,
      121,
      122,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      43,
      47
    ];
    var base64DecodeChars = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      62,
      -1,
      -1,
      -1,
      63,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    var base64EncodePadding = "=".charCodeAt(0);
    function base64encode(data) {
      var out, i, len;
      var c1, c2, c3;
      len = data && data.length;
      i = 0;
      out = [];
      while (i < len) {
        c1 = data[i++];
        if (i == len) {
          out[out.length] = base64EncodeChars[c1 >> 2];
          out[out.length] = base64EncodeChars[(c1 & 3) << 4];
          out[out.length] = base64EncodePadding;
          out[out.length] = base64EncodePadding;
          break;
        }
        c2 = data[i++];
        if (i == len) {
          out[out.length] = base64EncodeChars[c1 >> 2];
          out[out.length] = base64EncodeChars[(c1 & 3) << 4 | (c2 & 240) >> 4];
          out[out.length] = base64EncodeChars[(c2 & 15) << 2];
          out[out.length] = base64EncodePadding;
          break;
        }
        c3 = data[i++];
        out[out.length] = base64EncodeChars[c1 >> 2];
        out[out.length] = base64EncodeChars[(c1 & 3) << 4 | (c2 & 240) >> 4];
        out[out.length] = base64EncodeChars[(c2 & 15) << 2 | (c3 & 192) >> 6];
        out[out.length] = base64EncodeChars[c3 & 63];
      }
      return codeToString_fast(out);
    }
    util$2.base64encode = base64encode;
    function base64decode(str) {
      var c1, c2, c3, c4;
      var i, len, out;
      len = str && str.length;
      i = 0;
      out = [];
      while (i < len) {
        do {
          c1 = base64DecodeChars[str.charCodeAt(i++) & 255];
        } while (i < len && c1 == -1);
        if (c1 == -1) {
          break;
        }
        do {
          c2 = base64DecodeChars[str.charCodeAt(i++) & 255];
        } while (i < len && c2 == -1);
        if (c2 == -1) {
          break;
        }
        out[out.length] = c1 << 2 | (c2 & 48) >> 4;
        do {
          c3 = str.charCodeAt(i++) & 255;
          if (c3 == 61) {
            return out;
          }
          c3 = base64DecodeChars[c3];
        } while (i < len && c3 == -1);
        if (c3 == -1) {
          break;
        }
        out[out.length] = (c2 & 15) << 4 | (c3 & 60) >> 2;
        do {
          c4 = str.charCodeAt(i++) & 255;
          if (c4 == 61) {
            return out;
          }
          c4 = base64DecodeChars[c4];
        } while (i < len && c4 == -1);
        if (c4 == -1) {
          break;
        }
        out[out.length] = (c3 & 3) << 6 | c4;
      }
      return out;
    }
    util$2.base64decode = base64decode;
    return util$2;
  }
  var encodingTable = {};
  var utf8ToJisTable = {
    15711649: 33,
    15711650: 34,
    15711651: 35,
    15711652: 36,
    15711653: 37,
    15711654: 38,
    15711655: 39,
    15711656: 40,
    15711657: 41,
    15711658: 42,
    15711659: 43,
    15711660: 44,
    15711661: 45,
    15711662: 46,
    15711663: 47,
    15711664: 48,
    15711665: 49,
    15711666: 50,
    15711667: 51,
    15711668: 52,
    15711669: 53,
    15711670: 54,
    15711671: 55,
    15711672: 56,
    15711673: 57,
    15711674: 58,
    15711675: 59,
    15711676: 60,
    15711677: 61,
    15711678: 62,
    15711679: 63,
    15711872: 64,
    15711873: 65,
    15711874: 66,
    15711875: 67,
    15711876: 68,
    15711877: 69,
    15711878: 70,
    15711879: 71,
    15711880: 72,
    15711881: 73,
    15711882: 74,
    15711883: 75,
    15711884: 76,
    15711885: 77,
    15711886: 78,
    15711887: 79,
    15711888: 80,
    15711889: 81,
    15711890: 82,
    15711891: 83,
    15711892: 84,
    15711893: 85,
    15711894: 86,
    15711895: 87,
    15711896: 88,
    15711897: 89,
    15711898: 90,
    15711899: 91,
    15711900: 92,
    15711901: 93,
    15711902: 94,
    15711903: 95,
    14848416: 11553,
    14848417: 11554,
    14848418: 11555,
    14848419: 11556,
    14848420: 11557,
    14848421: 11558,
    14848422: 11559,
    14848423: 11560,
    14848424: 11561,
    14848425: 11562,
    14848426: 11563,
    14848427: 11564,
    14848428: 11565,
    14848429: 11566,
    14848430: 11567,
    14848431: 11568,
    14848432: 11569,
    14848433: 11570,
    14848434: 11571,
    14848435: 11572,
    14845344: 11573,
    14845345: 11574,
    14845346: 11575,
    14845347: 11576,
    14845348: 11577,
    14845349: 11578,
    14845350: 11579,
    14845351: 11580,
    14845352: 11581,
    14845353: 11582,
    14912905: 11584,
    14912660: 11585,
    14912674: 11586,
    14912909: 11587,
    14912664: 11588,
    14912679: 11589,
    14912643: 11590,
    14912694: 11591,
    14912913: 11592,
    14912919: 11593,
    14912653: 11594,
    14912678: 11595,
    14912675: 11596,
    14912683: 11597,
    14912906: 11598,
    14912699: 11599,
    14913180: 11600,
    14913181: 11601,
    14913182: 11602,
    14913166: 11603,
    14913167: 11604,
    14913412: 11605,
    14913185: 11606,
    14912955: 11615,
    14909597: 11616,
    14909599: 11617,
    14845078: 11618,
    14913421: 11619,
    14845089: 11620,
    14912164: 11621,
    14912165: 11622,
    14912166: 11623,
    14912167: 11624,
    14912168: 11625,
    14911665: 11626,
    14911666: 11627,
    14911673: 11628,
    14912958: 11629,
    14912957: 11630,
    14912956: 11631,
    14846126: 11635,
    14846097: 11636,
    14846111: 11640,
    14846655: 11641,
    14909568: 8481,
    14909569: 8482,
    14909570: 8483,
    15711372: 8484,
    15711374: 8485,
    14910395: 8486,
    15711386: 8487,
    15711387: 8488,
    15711391: 8489,
    15711361: 8490,
    14910107: 8491,
    14910108: 8492,
    49844: 8493,
    15711616: 8494,
    49832: 8495,
    15711422: 8496,
    15712163: 8497,
    15711423: 8498,
    14910397: 8499,
    14910398: 8500,
    14910109: 8501,
    14910110: 8502,
    14909571: 8503,
    14990237: 8504,
    14909573: 8505,
    14909574: 8506,
    14909575: 8507,
    14910396: 8508,
    14844053: 8509,
    14844048: 8510,
    15711375: 8511,
    15711420: 8512,
    15711646: 8513,
    14844054: 8514,
    15711644: 8515,
    14844070: 8516,
    14844069: 8517,
    14844056: 8518,
    14844057: 8519,
    14844060: 8520,
    14844061: 8521,
    15711368: 8522,
    15711369: 8523,
    14909588: 8524,
    14909589: 8525,
    15711419: 8526,
    15711421: 8527,
    15711643: 8528,
    15711645: 8529,
    14909576: 8530,
    14909577: 8531,
    14909578: 8532,
    14909579: 8533,
    14909580: 8534,
    14909581: 8535,
    14909582: 8536,
    14909583: 8537,
    14909584: 8538,
    14909585: 8539,
    15711371: 8540,
    15711373: 8541,
    49841: 8542,
    50071: 8543,
    50103: 8544,
    15711389: 8545,
    14846368: 8546,
    15711388: 8547,
    15711390: 8548,
    14846374: 8549,
    14846375: 8550,
    14846110: 8551,
    14846132: 8552,
    14850434: 8553,
    14850432: 8554,
    49840: 8555,
    14844082: 8556,
    14844083: 8557,
    14845059: 8558,
    15712165: 8559,
    15711364: 8560,
    15712160: 8561,
    15712161: 8562,
    15711365: 8563,
    15711363: 8564,
    15711366: 8565,
    15711370: 8566,
    15711392: 8567,
    49831: 8568,
    14850182: 8569,
    14850181: 8570,
    14849931: 8571,
    14849935: 8572,
    14849934: 8573,
    14849927: 8574,
    14849926: 8737,
    14849697: 8738,
    14849696: 8739,
    14849715: 8740,
    14849714: 8741,
    14849725: 8742,
    14849724: 8743,
    14844091: 8744,
    14909586: 8745,
    14845586: 8746,
    14845584: 8747,
    14845585: 8748,
    14845587: 8749,
    14909587: 8750,
    14846088: 8762,
    14846091: 8763,
    14846598: 8764,
    14846599: 8765,
    14846594: 8766,
    14846595: 8767,
    14846122: 8768,
    14846121: 8769,
    14846119: 8778,
    14846120: 8779,
    49836: 8780,
    14845842: 8781,
    14845844: 8782,
    14846080: 8783,
    14846083: 8784,
    14846112: 8796,
    14846629: 8797,
    14847122: 8798,
    14846082: 8799,
    14846087: 8800,
    14846369: 8801,
    14846354: 8802,
    14846378: 8803,
    14846379: 8804,
    14846106: 8805,
    14846141: 8806,
    14846109: 8807,
    14846133: 8808,
    14846123: 8809,
    14846124: 8810,
    14845099: 8818,
    14844080: 8819,
    14850479: 8820,
    14850477: 8821,
    14850474: 8822,
    14844064: 8823,
    14844065: 8824,
    49846: 8825,
    14849967: 8830,
    15711376: 9008,
    15711377: 9009,
    15711378: 9010,
    15711379: 9011,
    15711380: 9012,
    15711381: 9013,
    15711382: 9014,
    15711383: 9015,
    15711384: 9016,
    15711385: 9017,
    15711393: 9025,
    15711394: 9026,
    15711395: 9027,
    15711396: 9028,
    15711397: 9029,
    15711398: 9030,
    15711399: 9031,
    15711400: 9032,
    15711401: 9033,
    15711402: 9034,
    15711403: 9035,
    15711404: 9036,
    15711405: 9037,
    15711406: 9038,
    15711407: 9039,
    15711408: 9040,
    15711409: 9041,
    15711410: 9042,
    15711411: 9043,
    15711412: 9044,
    15711413: 9045,
    15711414: 9046,
    15711415: 9047,
    15711416: 9048,
    15711417: 9049,
    15711418: 9050,
    15711617: 9057,
    15711618: 9058,
    15711619: 9059,
    15711620: 9060,
    15711621: 9061,
    15711622: 9062,
    15711623: 9063,
    15711624: 9064,
    15711625: 9065,
    15711626: 9066,
    15711627: 9067,
    15711628: 9068,
    15711629: 9069,
    15711630: 9070,
    15711631: 9071,
    15711632: 9072,
    15711633: 9073,
    15711634: 9074,
    15711635: 9075,
    15711636: 9076,
    15711637: 9077,
    15711638: 9078,
    15711639: 9079,
    15711640: 9080,
    15711641: 9081,
    15711642: 9082,
    14909825: 9249,
    14909826: 9250,
    14909827: 9251,
    14909828: 9252,
    14909829: 9253,
    14909830: 9254,
    14909831: 9255,
    14909832: 9256,
    14909833: 9257,
    14909834: 9258,
    14909835: 9259,
    14909836: 9260,
    14909837: 9261,
    14909838: 9262,
    14909839: 9263,
    14909840: 9264,
    14909841: 9265,
    14909842: 9266,
    14909843: 9267,
    14909844: 9268,
    14909845: 9269,
    14909846: 9270,
    14909847: 9271,
    14909848: 9272,
    14909849: 9273,
    14909850: 9274,
    14909851: 9275,
    14909852: 9276,
    14909853: 9277,
    14909854: 9278,
    14909855: 9279,
    14909856: 9280,
    14909857: 9281,
    14909858: 9282,
    14909859: 9283,
    14909860: 9284,
    14909861: 9285,
    14909862: 9286,
    14909863: 9287,
    14909864: 9288,
    14909865: 9289,
    14909866: 9290,
    14909867: 9291,
    14909868: 9292,
    14909869: 9293,
    14909870: 9294,
    14909871: 9295,
    14909872: 9296,
    14909873: 9297,
    14909874: 9298,
    14909875: 9299,
    14909876: 9300,
    14909877: 9301,
    14909878: 9302,
    14909879: 9303,
    14909880: 9304,
    14909881: 9305,
    14909882: 9306,
    14909883: 9307,
    14909884: 9308,
    14909885: 9309,
    14909886: 9310,
    14909887: 9311,
    14910080: 9312,
    14910081: 9313,
    14910082: 9314,
    14910083: 9315,
    14910084: 9316,
    14910085: 9317,
    14910086: 9318,
    14910087: 9319,
    14910088: 9320,
    14910089: 9321,
    14910090: 9322,
    14910091: 9323,
    14910092: 9324,
    14910093: 9325,
    14910094: 9326,
    14910095: 9327,
    14910096: 9328,
    14910097: 9329,
    14910098: 9330,
    14910099: 9331,
    14910113: 9505,
    14910114: 9506,
    14910115: 9507,
    14910116: 9508,
    14910117: 9509,
    14910118: 9510,
    14910119: 9511,
    14910120: 9512,
    14910121: 9513,
    14910122: 9514,
    14910123: 9515,
    14910124: 9516,
    14910125: 9517,
    14910126: 9518,
    14910127: 9519,
    14910128: 9520,
    14910129: 9521,
    14910130: 9522,
    14910131: 9523,
    14910132: 9524,
    14910133: 9525,
    14910134: 9526,
    14910135: 9527,
    14910136: 9528,
    14910137: 9529,
    14910138: 9530,
    14910139: 9531,
    14910140: 9532,
    14910141: 9533,
    14910142: 9534,
    14910143: 9535,
    14910336: 9536,
    14910337: 9537,
    14910338: 9538,
    14910339: 9539,
    14910340: 9540,
    14910341: 9541,
    14910342: 9542,
    14910343: 9543,
    14910344: 9544,
    14910345: 9545,
    14910346: 9546,
    14910347: 9547,
    14910348: 9548,
    14910349: 9549,
    14910350: 9550,
    14910351: 9551,
    14910352: 9552,
    14910353: 9553,
    14910354: 9554,
    14910355: 9555,
    14910356: 9556,
    14910357: 9557,
    14910358: 9558,
    14910359: 9559,
    14910360: 9560,
    14910361: 9561,
    14910362: 9562,
    14910363: 9563,
    14910364: 9564,
    14910365: 9565,
    14910366: 9566,
    14910367: 9567,
    14910368: 9568,
    14910369: 9569,
    14910370: 9570,
    14910371: 9571,
    14910372: 9572,
    14910373: 9573,
    14910374: 9574,
    14910375: 9575,
    14910376: 9576,
    14910377: 9577,
    14910378: 9578,
    14910379: 9579,
    14910380: 9580,
    14910381: 9581,
    14910382: 9582,
    14910383: 9583,
    14910384: 9584,
    14910385: 9585,
    14910386: 9586,
    14910387: 9587,
    14910388: 9588,
    14910389: 9589,
    14910390: 9590,
    52881: 9761,
    52882: 9762,
    52883: 9763,
    52884: 9764,
    52885: 9765,
    52886: 9766,
    52887: 9767,
    52888: 9768,
    52889: 9769,
    52890: 9770,
    52891: 9771,
    52892: 9772,
    52893: 9773,
    52894: 9774,
    52895: 9775,
    52896: 9776,
    52897: 9777,
    52899: 9778,
    52900: 9779,
    52901: 9780,
    52902: 9781,
    52903: 9782,
    52904: 9783,
    52905: 9784,
    52913: 9793,
    52914: 9794,
    52915: 9795,
    52916: 9796,
    52917: 9797,
    52918: 9798,
    52919: 9799,
    52920: 9800,
    52921: 9801,
    52922: 9802,
    52923: 9803,
    52924: 9804,
    52925: 9805,
    52926: 9806,
    52927: 9807,
    53120: 9808,
    53121: 9809,
    53123: 9810,
    53124: 9811,
    53125: 9812,
    53126: 9813,
    53127: 9814,
    53128: 9815,
    53129: 9816,
    53392: 10017,
    53393: 10018,
    53394: 10019,
    53395: 10020,
    53396: 10021,
    53397: 10022,
    53377: 10023,
    53398: 10024,
    53399: 10025,
    53400: 10026,
    53401: 10027,
    53402: 10028,
    53403: 10029,
    53404: 10030,
    53405: 10031,
    53406: 10032,
    53407: 10033,
    53408: 10034,
    53409: 10035,
    53410: 10036,
    53411: 10037,
    53412: 10038,
    53413: 10039,
    53414: 10040,
    53415: 10041,
    53416: 10042,
    53417: 10043,
    53418: 10044,
    53419: 10045,
    53420: 10046,
    53421: 10047,
    53422: 10048,
    53423: 10049,
    53424: 10065,
    53425: 10066,
    53426: 10067,
    53427: 10068,
    53428: 10069,
    53429: 10070,
    53649: 10071,
    53430: 10072,
    53431: 10073,
    53432: 10074,
    53433: 10075,
    53434: 10076,
    53435: 10077,
    53436: 10078,
    53437: 10079,
    53438: 10080,
    53439: 10081,
    53632: 10082,
    53633: 10083,
    53634: 10084,
    53635: 10085,
    53636: 10086,
    53637: 10087,
    53638: 10088,
    53639: 10089,
    53640: 10090,
    53641: 10091,
    53642: 10092,
    53643: 10093,
    53644: 10094,
    53645: 10095,
    53646: 10096,
    53647: 10097,
    14849152: 10273,
    14849154: 10274,
    14849164: 10275,
    14849168: 10276,
    14849176: 10277,
    14849172: 10278,
    14849180: 10279,
    14849196: 10280,
    14849188: 10281,
    14849204: 10282,
    14849212: 10283,
    14849153: 10284,
    14849155: 10285,
    14849167: 10286,
    14849171: 10287,
    14849179: 10288,
    14849175: 10289,
    14849187: 10290,
    14849203: 10291,
    14849195: 10292,
    14849211: 10293,
    14849419: 10294,
    14849184: 10295,
    14849199: 10296,
    14849192: 10297,
    14849207: 10298,
    14849215: 10299,
    14849181: 10300,
    14849200: 10301,
    14849189: 10302,
    14849208: 10303,
    14849410: 10304,
    14989980: 12321,
    15045782: 12322,
    15050883: 12323,
    15308991: 12324,
    15045504: 12325,
    15107227: 12326,
    15109288: 12327,
    15050678: 12328,
    15302818: 12329,
    15241653: 12330,
    15240348: 12331,
    15182224: 12332,
    15106730: 12333,
    15110049: 12334,
    15120549: 12335,
    15112109: 12336,
    15241638: 12337,
    15239846: 12338,
    15314869: 12339,
    15114899: 12340,
    15047847: 12341,
    15111841: 12342,
    15108529: 12343,
    15052443: 12344,
    15050640: 12345,
    15243707: 12346,
    15311796: 12347,
    15185314: 12348,
    15185598: 12349,
    15314574: 12350,
    15108246: 12351,
    15184543: 12352,
    15246007: 12353,
    15052425: 12354,
    15055541: 12355,
    15109257: 12356,
    15112855: 12357,
    15114632: 12358,
    15308679: 12359,
    15310477: 12360,
    15113615: 12361,
    14990245: 12362,
    14990474: 12363,
    14990733: 12364,
    14991005: 12365,
    15040905: 12366,
    15047602: 12367,
    15049911: 12368,
    15050644: 12369,
    15050881: 12370,
    15052937: 12371,
    15106975: 12372,
    15107215: 12373,
    15107504: 12374,
    15112339: 12375,
    15115397: 12376,
    15172282: 12377,
    15177103: 12378,
    15177136: 12379,
    15181755: 12380,
    15185581: 12381,
    15185839: 12382,
    15238019: 12383,
    15241358: 12384,
    15245731: 12385,
    15248514: 12386,
    15303061: 12387,
    15303098: 12388,
    15043771: 12389,
    14989973: 12390,
    14989989: 12391,
    15048607: 12392,
    15237810: 12393,
    15303553: 12394,
    15180719: 12395,
    14989440: 12396,
    15049649: 12397,
    15121058: 12398,
    15302840: 12399,
    15182002: 12400,
    15240360: 12401,
    15239819: 12402,
    15315119: 12403,
    15041921: 12404,
    15044016: 12405,
    15045309: 12406,
    15045537: 12407,
    15047584: 12408,
    15050683: 12409,
    15056021: 12410,
    15311794: 12411,
    15120299: 12412,
    15238052: 12413,
    15242413: 12414,
    15309218: 12577,
    15309232: 12578,
    15309472: 12579,
    15310779: 12580,
    15044747: 12581,
    15044531: 12582,
    15052423: 12583,
    15172495: 12584,
    15187645: 12585,
    15253378: 12586,
    15309736: 12587,
    15044015: 12588,
    15316380: 12589,
    15182522: 12590,
    14989457: 12591,
    15180435: 12592,
    15239100: 12593,
    15120550: 12594,
    15046808: 12595,
    15045764: 12596,
    15117469: 12597,
    15242394: 12598,
    15315131: 12599,
    15050661: 12600,
    15044265: 12601,
    15119782: 12602,
    15176604: 12603,
    15308431: 12604,
    15047042: 12605,
    14989969: 12606,
    15303051: 12607,
    15309746: 12608,
    15240591: 12609,
    15312012: 12610,
    15044513: 12611,
    15046326: 12612,
    15051952: 12613,
    15056305: 12614,
    15112352: 12615,
    15113139: 12616,
    15114372: 12617,
    15118520: 12618,
    15119283: 12619,
    15119529: 12620,
    15176091: 12621,
    15178632: 12622,
    15182222: 12623,
    15311028: 12624,
    15240113: 12625,
    15245723: 12626,
    15247776: 12627,
    15305645: 12628,
    15120050: 12629,
    15177387: 12630,
    15178634: 12631,
    15312773: 12632,
    15106726: 12633,
    15248513: 12634,
    15251082: 12635,
    15308466: 12636,
    15115918: 12637,
    15044269: 12638,
    15042182: 12639,
    15047826: 12640,
    15048880: 12641,
    15050116: 12642,
    15052468: 12643,
    15055798: 12644,
    15106216: 12645,
    15109801: 12646,
    15110068: 12647,
    15119039: 12648,
    15121556: 12649,
    15172238: 12650,
    15172756: 12651,
    15173017: 12652,
    15173525: 12653,
    15174847: 12654,
    15186049: 12655,
    15239606: 12656,
    15240081: 12657,
    15242903: 12658,
    15303072: 12659,
    15305115: 12660,
    15316123: 12661,
    15049129: 12662,
    15111868: 12663,
    15118746: 12664,
    15176869: 12665,
    15042489: 12666,
    15049902: 12667,
    15050149: 12668,
    15056512: 12669,
    15056796: 12670,
    15108796: 12833,
    15112122: 12834,
    15116458: 12835,
    15117479: 12836,
    15118004: 12837,
    15175307: 12838,
    15187841: 12839,
    15246742: 12840,
    15316140: 12841,
    15316110: 12842,
    15317892: 12843,
    15053473: 12844,
    15118998: 12845,
    15240635: 12846,
    15041668: 12847,
    15053195: 12848,
    15107766: 12849,
    15239046: 12850,
    15114678: 12851,
    15174049: 12852,
    14989721: 12853,
    14991290: 12854,
    15044024: 12855,
    15106473: 12856,
    15120553: 12857,
    15182223: 12858,
    15310771: 12859,
    14989451: 12860,
    15043734: 12861,
    14990254: 12862,
    14990741: 12863,
    14990525: 12864,
    14991009: 12865,
    14990771: 12866,
    15043232: 12867,
    15044527: 12868,
    15046793: 12869,
    15049871: 12870,
    15051649: 12871,
    15052470: 12872,
    15052705: 12873,
    15181713: 12874,
    15112839: 12875,
    15113884: 12876,
    15113910: 12877,
    15117708: 12878,
    15119027: 12879,
    15172011: 12880,
    15175554: 12881,
    15181453: 12882,
    15181502: 12883,
    15182012: 12884,
    15183495: 12885,
    15239857: 12886,
    15240091: 12887,
    15240324: 12888,
    15240631: 12889,
    15241135: 12890,
    15241107: 12891,
    15244710: 12892,
    15248050: 12893,
    15046825: 12894,
    15250088: 12895,
    15253414: 12896,
    15303054: 12897,
    15309982: 12898,
    15243914: 12899,
    14991236: 12900,
    15053736: 12901,
    15108241: 12902,
    15174041: 12903,
    15176891: 12904,
    15239077: 12905,
    15239869: 12906,
    15244222: 12907,
    15250304: 12908,
    15309701: 12909,
    15312019: 12910,
    15312789: 12911,
    14990219: 12912,
    14990490: 12913,
    15247267: 12914,
    15047582: 12915,
    15049098: 12916,
    15049610: 12917,
    15055803: 12918,
    15056811: 12919,
    15106218: 12920,
    15106708: 12921,
    15106466: 12922,
    15107984: 12923,
    15108242: 12924,
    15109008: 12925,
    15111353: 12926,
    15314305: 13089,
    15112614: 13090,
    15114928: 13091,
    15119799: 13092,
    15172016: 13093,
    15177100: 13094,
    15178374: 13095,
    15185333: 13096,
    15239845: 13097,
    15245241: 13098,
    15308427: 13099,
    15309454: 13100,
    15250077: 13101,
    15042481: 13102,
    15043262: 13103,
    15049878: 13104,
    15045299: 13105,
    15052467: 13106,
    15053974: 13107,
    15107496: 13108,
    15115906: 13109,
    15120047: 13110,
    15180429: 13111,
    15242123: 13112,
    15245719: 13113,
    15247794: 13114,
    15306407: 13115,
    15313592: 13116,
    15119788: 13117,
    15312552: 13118,
    15244185: 13119,
    15048355: 13120,
    15114175: 13121,
    15244174: 13122,
    15304846: 13123,
    15043203: 13124,
    15047303: 13125,
    15044740: 13126,
    15055763: 13127,
    15109025: 13128,
    15110841: 13129,
    15114428: 13130,
    15114424: 13131,
    15118011: 13132,
    15175090: 13133,
    15180474: 13134,
    15182251: 13135,
    15247002: 13136,
    15247250: 13137,
    15250859: 13138,
    15252611: 13139,
    15303597: 13140,
    15308451: 13141,
    15309460: 13142,
    15310249: 13143,
    15052198: 13144,
    15053491: 13145,
    15115709: 13146,
    15311245: 13147,
    15311246: 13148,
    15109787: 13149,
    15183008: 13150,
    15116459: 13151,
    15116735: 13152,
    15114934: 13153,
    15315085: 13154,
    15121823: 13155,
    15042994: 13156,
    15046301: 13157,
    15106480: 13158,
    15109036: 13159,
    15119547: 13160,
    15120519: 13161,
    15121297: 13162,
    15241627: 13163,
    15246480: 13164,
    15252868: 13165,
    14989460: 13166,
    15315129: 13167,
    15044534: 13168,
    15115419: 13169,
    15116474: 13170,
    15310468: 13171,
    15114410: 13172,
    15041948: 13173,
    15182723: 13174,
    15241906: 13175,
    15304604: 13176,
    15306380: 13177,
    15047067: 13178,
    15316136: 13179,
    15114402: 13180,
    15240325: 13181,
    15241393: 13182,
    15184549: 13345,
    15042696: 13346,
    15240069: 13347,
    15176614: 13348,
    14989758: 13349,
    14990979: 13350,
    15042208: 13351,
    15052690: 13352,
    15042698: 13353,
    15043480: 13354,
    15043495: 13355,
    15054779: 13356,
    15046298: 13357,
    15048874: 13358,
    15050662: 13359,
    15052428: 13360,
    15052440: 13361,
    15052699: 13362,
    15055282: 13363,
    15055289: 13364,
    15106723: 13365,
    15107231: 13366,
    15107491: 13367,
    15107774: 13368,
    15110043: 13369,
    15111586: 13370,
    15114129: 13371,
    15114643: 13372,
    15115194: 13373,
    15117502: 13374,
    15117715: 13375,
    15118743: 13376,
    15121570: 13377,
    15122071: 13378,
    15121797: 13379,
    15176368: 13380,
    15176856: 13381,
    15178659: 13382,
    15178891: 13383,
    15182783: 13384,
    15183521: 13385,
    15184033: 13386,
    15185833: 13387,
    15187126: 13388,
    15187888: 13389,
    15237789: 13390,
    15239590: 13391,
    15240862: 13392,
    15247027: 13393,
    15248268: 13394,
    15250091: 13395,
    15303300: 13396,
    15307153: 13397,
    15308435: 13398,
    15308433: 13399,
    15308450: 13400,
    15309221: 13401,
    15310739: 13402,
    15312040: 13403,
    15239320: 13404,
    14989496: 13405,
    15044779: 13406,
    15053496: 13407,
    15054732: 13408,
    15175337: 13409,
    15178124: 13410,
    15178940: 13411,
    15053481: 13412,
    15187883: 13413,
    15250571: 13414,
    15309697: 13415,
    15310993: 13416,
    15311252: 13417,
    15311256: 13418,
    14990465: 13419,
    14990478: 13420,
    15044017: 13421,
    15046300: 13422,
    15047080: 13423,
    15048634: 13424,
    15050119: 13425,
    15051913: 13426,
    15052676: 13427,
    15053456: 13428,
    15054988: 13429,
    15055294: 13430,
    15056780: 13431,
    15110062: 13432,
    15113402: 13433,
    15112087: 13434,
    15112098: 13435,
    15113375: 13436,
    15115147: 13437,
    15115140: 13438,
    15116703: 13601,
    15055024: 13602,
    15118213: 13603,
    15118487: 13604,
    15118781: 13605,
    15177151: 13606,
    15181192: 13607,
    15052195: 13608,
    15181952: 13609,
    15185024: 13610,
    15056573: 13611,
    15246991: 13612,
    15247512: 13613,
    15250100: 13614,
    15250871: 13615,
    15252364: 13616,
    15252637: 13617,
    15311778: 13618,
    15313038: 13619,
    15314108: 13620,
    14989952: 13621,
    15040957: 13622,
    15041664: 13623,
    15050387: 13624,
    15052444: 13625,
    15108271: 13626,
    15108736: 13627,
    15111084: 13628,
    15117498: 13629,
    15174304: 13630,
    15177361: 13631,
    15181191: 13632,
    15187625: 13633,
    15245243: 13634,
    15248060: 13635,
    15248816: 13636,
    15109804: 13637,
    15241098: 13638,
    15310496: 13639,
    15044745: 13640,
    15044739: 13641,
    15046315: 13642,
    15114644: 13643,
    15116696: 13644,
    15247792: 13645,
    15179943: 13646,
    15113653: 13647,
    15317901: 13648,
    15044020: 13649,
    15052450: 13650,
    15238298: 13651,
    15243664: 13652,
    15302790: 13653,
    14989464: 13654,
    14989701: 13655,
    14990215: 13656,
    14990481: 13657,
    15044490: 13658,
    15044792: 13659,
    15052462: 13660,
    15056019: 13661,
    15106213: 13662,
    15111569: 13663,
    15113405: 13664,
    15118722: 13665,
    15118770: 13666,
    15119267: 13667,
    15172024: 13668,
    15175811: 13669,
    15182262: 13670,
    15182510: 13671,
    15182984: 13672,
    15185050: 13673,
    15184830: 13674,
    15185318: 13675,
    15112103: 13676,
    15174043: 13677,
    15044283: 13678,
    15053189: 13679,
    15054760: 13680,
    15109010: 13681,
    15109024: 13682,
    15109273: 13683,
    15120544: 13684,
    15243674: 13685,
    15247537: 13686,
    15251357: 13687,
    15305656: 13688,
    15121537: 13689,
    15181478: 13690,
    15314330: 13691,
    14989992: 13692,
    14989995: 13693,
    14989996: 13694,
    14991003: 13857,
    14991008: 13858,
    15041425: 13859,
    15041927: 13860,
    15182774: 13861,
    15041969: 13862,
    15042486: 13863,
    15043988: 13864,
    15043745: 13865,
    15044031: 13866,
    15044523: 13867,
    15046316: 13868,
    15049347: 13869,
    15053729: 13870,
    15056055: 13871,
    15056266: 13872,
    15106223: 13873,
    15106448: 13874,
    15106477: 13875,
    15109279: 13876,
    15111577: 13877,
    15116683: 13878,
    15119233: 13879,
    15174530: 13880,
    15174573: 13881,
    15179695: 13882,
    15238072: 13883,
    15238277: 13884,
    15239304: 13885,
    15242638: 13886,
    15303607: 13887,
    15306657: 13888,
    15310783: 13889,
    15312279: 13890,
    15313306: 13891,
    14990256: 13892,
    15042461: 13893,
    15052973: 13894,
    15112833: 13895,
    15115693: 13896,
    15053184: 13897,
    15113138: 13898,
    15115701: 13899,
    15175305: 13900,
    15114640: 13901,
    15184513: 13902,
    15041413: 13903,
    15043492: 13904,
    15048071: 13905,
    15054782: 13906,
    15305894: 13907,
    15111844: 13908,
    15117475: 13909,
    15117501: 13910,
    15175860: 13911,
    15181441: 13912,
    15181501: 13913,
    15183243: 13914,
    15185802: 13915,
    15239865: 13916,
    15241100: 13917,
    15245759: 13918,
    15246751: 13919,
    15248569: 13920,
    15253393: 13921,
    15304593: 13922,
    15044767: 13923,
    15305344: 13924,
    14989725: 13925,
    15040694: 13926,
    15044517: 13927,
    15043770: 13928,
    15174551: 13929,
    15175318: 13930,
    15179689: 13931,
    15240102: 13932,
    15252143: 13933,
    15312774: 13934,
    15312776: 13935,
    15312786: 13936,
    15041975: 13937,
    15107226: 13938,
    15243678: 13939,
    15046320: 13940,
    15182266: 13941,
    15040950: 13942,
    15052691: 13943,
    15303047: 13944,
    15309445: 13945,
    14989490: 13946,
    15117211: 13947,
    15304615: 13948,
    15053201: 13949,
    15053192: 13950,
    15109784: 14113,
    15182495: 14114,
    15118995: 14115,
    15310260: 14116,
    15252897: 14117,
    15182506: 14118,
    15173258: 14119,
    15309448: 14120,
    15184514: 14121,
    15114391: 14122,
    15186352: 14123,
    15114641: 14124,
    15306156: 14125,
    15043506: 14126,
    15044763: 14127,
    15242923: 14128,
    15247507: 14129,
    15187620: 14130,
    15252365: 14131,
    15303585: 14132,
    15044006: 14133,
    15245960: 14134,
    15181185: 14135,
    14991234: 14136,
    15041214: 14137,
    15042705: 14138,
    15041924: 14139,
    15046035: 14140,
    15047853: 14141,
    15175594: 14142,
    15048331: 14143,
    15050129: 14144,
    15056290: 14145,
    15056516: 14146,
    15106485: 14147,
    15107510: 14148,
    15107495: 14149,
    15107753: 14150,
    15109810: 14151,
    15110330: 14152,
    15111596: 14153,
    15112623: 14154,
    15114626: 14155,
    15120531: 14156,
    15177126: 14157,
    15182013: 14158,
    15184827: 14159,
    15185292: 14160,
    15185561: 14161,
    15186315: 14162,
    15187371: 14163,
    15240334: 14164,
    15240586: 14165,
    15244173: 14166,
    15247496: 14167,
    15247779: 14168,
    15248806: 14169,
    15252413: 14170,
    15311002: 14171,
    15316623: 14172,
    15239864: 14173,
    15253390: 14174,
    15314856: 14175,
    15043207: 14176,
    15108255: 14177,
    15110787: 14178,
    15122304: 14179,
    15309465: 14180,
    15114625: 14181,
    15041169: 14182,
    15117472: 14183,
    15118778: 14184,
    15121812: 14185,
    15182260: 14186,
    15185296: 14187,
    15245696: 14188,
    15247523: 14189,
    15113352: 14190,
    14990262: 14191,
    15040697: 14192,
    15040678: 14193,
    15040933: 14194,
    15041980: 14195,
    15042744: 14196,
    15042979: 14197,
    15046311: 14198,
    15047823: 14199,
    15048837: 14200,
    15051660: 14201,
    15055802: 14202,
    15107762: 14203,
    15108024: 14204,
    15109043: 14205,
    15109554: 14206,
    15115420: 14369,
    15116457: 14370,
    15174077: 14371,
    15174316: 14372,
    15174830: 14373,
    15179924: 14374,
    15180207: 14375,
    15185337: 14376,
    15178892: 14377,
    15237801: 14378,
    15246987: 14379,
    15248537: 14380,
    15250338: 14381,
    15252370: 14382,
    15303075: 14383,
    15306165: 14384,
    15309242: 14385,
    15311253: 14386,
    15313043: 14387,
    15317432: 14388,
    15041923: 14389,
    15044255: 14390,
    15044275: 14391,
    15055291: 14392,
    15056038: 14393,
    15120539: 14394,
    15121040: 14395,
    15175300: 14396,
    15175614: 14397,
    15185283: 14398,
    15239351: 14399,
    15247488: 14400,
    15248314: 14401,
    15309200: 14402,
    14989710: 14403,
    15040651: 14404,
    15044516: 14405,
    15045052: 14406,
    15047610: 14407,
    15050641: 14408,
    15052196: 14409,
    15054769: 14410,
    15055531: 14411,
    15056039: 14412,
    15108280: 14413,
    15111557: 14414,
    15113903: 14415,
    15120790: 14416,
    15174544: 14417,
    15184778: 14418,
    15246004: 14419,
    15237793: 14420,
    15238049: 14421,
    15241136: 14422,
    15243662: 14423,
    15248007: 14424,
    15251368: 14425,
    15304887: 14426,
    15309703: 14427,
    15311271: 14428,
    15318163: 14429,
    14989972: 14430,
    14989970: 14431,
    14990477: 14432,
    15043976: 14433,
    15045001: 14434,
    15044798: 14435,
    15050927: 14436,
    15056524: 14437,
    15056545: 14438,
    15106719: 14439,
    15114919: 14440,
    15116942: 14441,
    15176090: 14442,
    15180417: 14443,
    15248030: 14444,
    15248036: 14445,
    15248823: 14446,
    15304336: 14447,
    14989726: 14448,
    15314825: 14449,
    14989988: 14450,
    14990780: 14451,
    14991023: 14452,
    15040665: 14453,
    15040662: 14454,
    15041929: 14455,
    15041964: 14456,
    15043231: 14457,
    15043257: 14458,
    15043518: 14459,
    15044250: 14460,
    15044515: 14461,
    15044753: 14462,
    15044750: 14625,
    15046281: 14626,
    15048081: 14627,
    15048354: 14628,
    15050173: 14629,
    15052180: 14630,
    15052189: 14631,
    15052431: 14632,
    15054757: 14633,
    15054759: 14634,
    15054775: 14635,
    15055288: 14636,
    15055491: 14637,
    15055514: 14638,
    15055543: 14639,
    15056024: 14640,
    15106450: 14641,
    15107468: 14642,
    15108759: 14643,
    15109016: 14644,
    15109799: 14645,
    15111355: 14646,
    15112322: 14647,
    15112579: 14648,
    15113140: 14649,
    15113645: 14650,
    15114401: 14651,
    15114903: 14652,
    15116171: 14653,
    15118751: 14654,
    15119530: 14655,
    15119785: 14656,
    15120559: 14657,
    15121053: 14658,
    15176882: 14659,
    15178375: 14660,
    15180204: 14661,
    15182015: 14662,
    15184800: 14663,
    15185029: 14664,
    15185048: 14665,
    15185310: 14666,
    15185585: 14667,
    15237269: 14668,
    15237251: 14669,
    15237807: 14670,
    15237809: 14671,
    15238548: 14672,
    15238799: 14673,
    15239338: 14674,
    15240594: 14675,
    15245708: 14676,
    15245729: 14677,
    15248539: 14678,
    15250082: 14679,
    15250364: 14680,
    15303562: 14681,
    15304117: 14682,
    15305137: 14683,
    15179967: 14684,
    15305660: 14685,
    15308452: 14686,
    15309197: 14687,
    15310981: 14688,
    15312537: 14689,
    15313816: 14690,
    15316155: 14691,
    15042971: 14692,
    15043243: 14693,
    15044535: 14694,
    15044744: 14695,
    15049621: 14696,
    15109047: 14697,
    15122336: 14698,
    15249834: 14699,
    15252895: 14700,
    15317689: 14701,
    15041931: 14702,
    15042747: 14703,
    15045002: 14704,
    15047613: 14705,
    15182208: 14706,
    15304119: 14707,
    15316384: 14708,
    15317906: 14709,
    15175044: 14710,
    15121545: 14711,
    15238576: 14712,
    15176849: 14713,
    15056829: 14714,
    15106970: 14715,
    15313576: 14716,
    15174555: 14717,
    15253180: 14718,
    15117732: 14881,
    15310979: 14882,
    14990218: 14883,
    15047600: 14884,
    15048100: 14885,
    15049406: 14886,
    15051162: 14887,
    15106472: 14888,
    15107975: 14889,
    15112335: 14890,
    15112326: 14891,
    15114425: 14892,
    15114929: 14893,
    15120311: 14894,
    15177621: 14895,
    15185082: 14896,
    15239598: 14897,
    15314306: 14898,
    14989979: 14899,
    14990736: 14900,
    15044489: 14901,
    15045766: 14902,
    15054255: 14903,
    15054758: 14904,
    15054766: 14905,
    15114171: 14906,
    15119001: 14907,
    15176115: 14908,
    15179906: 14909,
    15247760: 14910,
    15306390: 14911,
    15246239: 14912,
    15048080: 14913,
    15055527: 14914,
    15109291: 14915,
    15041205: 14916,
    15041196: 14917,
    15042189: 14918,
    15113344: 14919,
    15045513: 14920,
    15049118: 14921,
    15050427: 14922,
    15052464: 14923,
    15056297: 14924,
    15108493: 14925,
    15109793: 14926,
    15114429: 14927,
    15117747: 14928,
    15120520: 14929,
    15172029: 14930,
    15304583: 14931,
    15174272: 14932,
    15179925: 14933,
    15179942: 14934,
    15181229: 14935,
    15111822: 14936,
    15185072: 14937,
    15241116: 14938,
    15246209: 14939,
    15252617: 14940,
    15309467: 14941,
    15042980: 14942,
    15047848: 14943,
    15113616: 14944,
    15187370: 14945,
    15250081: 14946,
    15042228: 14947,
    15048066: 14948,
    15308970: 14949,
    15048890: 14950,
    15115914: 14951,
    15237812: 14952,
    15045298: 14953,
    15053966: 14954,
    15048636: 14955,
    15180437: 14956,
    15316922: 14957,
    14990748: 14958,
    15042954: 14959,
    15045259: 14960,
    15110334: 14961,
    15112360: 14962,
    15113364: 14963,
    15114165: 14964,
    15182468: 14965,
    15183254: 14966,
    15185058: 14967,
    15305903: 14968,
    15114652: 14969,
    15314605: 14970,
    15183033: 14971,
    15043737: 14972,
    15042186: 14973,
    15042743: 14974,
    15052703: 15137,
    15109046: 15138,
    15110830: 15139,
    15111078: 15140,
    15113389: 15141,
    15118010: 15142,
    15242921: 15143,
    15309713: 15144,
    15178384: 15145,
    15314838: 15146,
    15109516: 15147,
    15305862: 15148,
    15314603: 15149,
    15178431: 15150,
    15112594: 15151,
    14989449: 15152,
    15041176: 15153,
    15044482: 15154,
    15053233: 15155,
    15106984: 15156,
    15110802: 15157,
    15111587: 15158,
    15114655: 15159,
    15173542: 15160,
    15175562: 15161,
    15176867: 15162,
    15183511: 15163,
    15186562: 15164,
    15243925: 15165,
    15249027: 15166,
    15250331: 15167,
    15304120: 15168,
    15312016: 15169,
    15111852: 15170,
    15112875: 15171,
    15117963: 15172,
    14990229: 15173,
    14990228: 15174,
    14990522: 15175,
    14990783: 15176,
    15042746: 15177,
    15044536: 15178,
    15044530: 15179,
    15046563: 15180,
    15047579: 15181,
    15049643: 15182,
    15050635: 15183,
    15050633: 15184,
    15050687: 15185,
    15052176: 15186,
    15053197: 15187,
    15054978: 15188,
    15055019: 15189,
    15056791: 15190,
    15106205: 15191,
    15109255: 15192,
    15111343: 15193,
    15052188: 15194,
    15111855: 15195,
    15111869: 15196,
    15112104: 15197,
    15113885: 15198,
    15117730: 15199,
    15117755: 15200,
    15118479: 15201,
    15175045: 15202,
    15181193: 15203,
    15181697: 15204,
    15184824: 15205,
    15185049: 15206,
    15185067: 15207,
    15237794: 15208,
    15238274: 15209,
    15239091: 15210,
    15246998: 15211,
    15247774: 15212,
    15247785: 15213,
    15247782: 15214,
    15248012: 15215,
    15248302: 15216,
    15250311: 15217,
    15250332: 15218,
    15309708: 15219,
    15311804: 15220,
    15117743: 15221,
    14989963: 15222,
    14990524: 15223,
    14990989: 15224,
    15041936: 15225,
    15052183: 15226,
    15052730: 15227,
    15107464: 15228,
    15109249: 15229,
    15112578: 15230,
    15117473: 15393,
    15121291: 15394,
    15119035: 15395,
    15173822: 15396,
    15176381: 15397,
    15177620: 15398,
    15180673: 15399,
    15180986: 15400,
    15237260: 15401,
    15237299: 15402,
    15239082: 15403,
    15241876: 15404,
    15253150: 15405,
    15118736: 15406,
    15317439: 15407,
    15056015: 15408,
    15248792: 15409,
    15316139: 15410,
    15182778: 15411,
    15252408: 15412,
    15052429: 15413,
    15309739: 15414,
    14989443: 15415,
    15044529: 15416,
    15048631: 15417,
    15049905: 15418,
    15051657: 15419,
    15052452: 15420,
    15106697: 15421,
    15120831: 15422,
    15121542: 15423,
    15177406: 15424,
    15250346: 15425,
    15052447: 15426,
    15242368: 15427,
    15183776: 15428,
    15040946: 15429,
    15114164: 15430,
    15239837: 15431,
    15053217: 15432,
    15242634: 15433,
    15186078: 15434,
    15239310: 15435,
    15042201: 15436,
    15052932: 15437,
    15109544: 15438,
    15250854: 15439,
    15111836: 15440,
    15173038: 15441,
    15180990: 15442,
    15185047: 15443,
    15237253: 15444,
    15248541: 15445,
    15252362: 15446,
    15303086: 15447,
    15244167: 15448,
    15303338: 15449,
    15040671: 15450,
    15043514: 15451,
    15052986: 15452,
    15113619: 15453,
    15172028: 15454,
    15173813: 15455,
    15304076: 15456,
    15304584: 15457,
    15305899: 15458,
    15240101: 15459,
    15052674: 15460,
    15056049: 15461,
    15107001: 15462,
    14989499: 15463,
    15044502: 15464,
    15052424: 15465,
    15108491: 15466,
    15113393: 15467,
    15117962: 15468,
    15174569: 15469,
    15175584: 15470,
    15181998: 15471,
    15238571: 15472,
    15251107: 15473,
    15304082: 15474,
    15312534: 15475,
    15041682: 15476,
    15044503: 15477,
    15045034: 15478,
    15052735: 15479,
    15109768: 15480,
    15116473: 15481,
    15185580: 15482,
    15309952: 15483,
    15047578: 15484,
    15044494: 15485,
    15045032: 15486,
    15052439: 15649,
    15052977: 15650,
    15054750: 15651,
    14991278: 15652,
    15107201: 15653,
    15109054: 15654,
    15119538: 15655,
    15181696: 15656,
    15181707: 15657,
    15185282: 15658,
    15186317: 15659,
    15187858: 15660,
    15239085: 15661,
    15239327: 15662,
    15241872: 15663,
    15245702: 15664,
    15246770: 15665,
    15249040: 15666,
    15251892: 15667,
    15252655: 15668,
    15302833: 15669,
    15304075: 15670,
    15304108: 15671,
    15309702: 15672,
    15304348: 15673,
    14990208: 15674,
    14990735: 15675,
    15041925: 15676,
    15043969: 15677,
    15056531: 15678,
    15108238: 15679,
    15114132: 15680,
    15118721: 15681,
    15120523: 15682,
    15175075: 15683,
    15186086: 15684,
    15304589: 15685,
    15305347: 15686,
    15044500: 15687,
    15049881: 15688,
    15052479: 15689,
    15120273: 15690,
    15181213: 15691,
    15186094: 15692,
    15184539: 15693,
    15049150: 15694,
    15173279: 15695,
    15042490: 15696,
    15245715: 15697,
    15253424: 15698,
    14991242: 15699,
    15053755: 15700,
    15112357: 15701,
    15179436: 15702,
    15182755: 15703,
    15239324: 15704,
    15312831: 15705,
    15042438: 15706,
    15056554: 15707,
    15112108: 15708,
    15115695: 15709,
    15117961: 15710,
    15120307: 15711,
    15121046: 15712,
    15121828: 15713,
    15178686: 15714,
    15185044: 15715,
    15054753: 15716,
    15303093: 15717,
    15304327: 15718,
    15310982: 15719,
    15042470: 15720,
    15042717: 15721,
    15108480: 15722,
    15112849: 15723,
    15113113: 15724,
    15120538: 15725,
    15055542: 15726,
    15185810: 15727,
    15187378: 15728,
    15113144: 15729,
    15242927: 15730,
    15243191: 15731,
    15248312: 15732,
    15043241: 15733,
    15044505: 15734,
    15050163: 15735,
    15055503: 15736,
    15056528: 15737,
    15106453: 15738,
    15305636: 15739,
    15309220: 15740,
    15041207: 15741,
    15041695: 15742,
    15043485: 15905,
    15043744: 15906,
    15043975: 15907,
    15044524: 15908,
    15045544: 15909,
    15046022: 15910,
    15045809: 15911,
    15046807: 15912,
    15050152: 15913,
    15050430: 15914,
    15050940: 15915,
    15052469: 15916,
    15052934: 15917,
    15052943: 15918,
    15052945: 15919,
    15052954: 15920,
    15055492: 15921,
    15055498: 15922,
    15055776: 15923,
    15056304: 15924,
    15108543: 15925,
    15108740: 15926,
    15109019: 15927,
    15109772: 15928,
    15109559: 15929,
    15112327: 15930,
    15112332: 15931,
    15112365: 15932,
    15112630: 15933,
    15113662: 15934,
    15114914: 15935,
    15116447: 15936,
    15116469: 15937,
    15119036: 15938,
    15120008: 15939,
    15120521: 15940,
    15120792: 15941,
    15172796: 15942,
    15172774: 15943,
    15173031: 15944,
    15177607: 15945,
    15178881: 15946,
    15180189: 15947,
    15180929: 15948,
    15181221: 15949,
    15181744: 15950,
    15182752: 15951,
    15182993: 15952,
    15184551: 15953,
    15185081: 15954,
    15237782: 15955,
    15241110: 15956,
    15241867: 15957,
    15242633: 15958,
    15245725: 15959,
    15246259: 15960,
    15247519: 15961,
    15247548: 15962,
    15247764: 15963,
    15247795: 15964,
    15249825: 15965,
    15250334: 15966,
    15304356: 15967,
    15305126: 15968,
    15306174: 15969,
    15306904: 15970,
    15309468: 15971,
    15310488: 15972,
    14989450: 15973,
    14989448: 15974,
    14989470: 15975,
    14989719: 15976,
    15042199: 15977,
    15042992: 15978,
    15048590: 15979,
    15048884: 15980,
    15049612: 15981,
    15051938: 15982,
    15055032: 15983,
    15106949: 15984,
    15111102: 15985,
    15113633: 15986,
    15113622: 15987,
    15119748: 15988,
    15174326: 15989,
    15177139: 15990,
    15182243: 15991,
    15241912: 15992,
    15248818: 15993,
    15304376: 15994,
    15305888: 15995,
    15046833: 15996,
    15048628: 15997,
    15311806: 15998,
    15109037: 16161,
    15115405: 16162,
    15117974: 16163,
    15173549: 16164,
    15186324: 16165,
    15237559: 16166,
    15239602: 16167,
    15247270: 16168,
    15311775: 16169,
    15244693: 16170,
    15253169: 16171,
    15052987: 16172,
    14990520: 16173,
    14991265: 16174,
    14991029: 16175,
    15045767: 16176,
    15050912: 16177,
    15052701: 16178,
    15052713: 16179,
    15056771: 16180,
    15107470: 16181,
    15109295: 16182,
    15111856: 16183,
    15112587: 16184,
    15115182: 16185,
    15115931: 16186,
    15119800: 16187,
    15120305: 16188,
    15176883: 16189,
    15177401: 16190,
    15178911: 16191,
    15181214: 16192,
    15181734: 16193,
    15185075: 16194,
    15239075: 16195,
    15239855: 16196,
    15242922: 16197,
    15247018: 16198,
    15247546: 16199,
    15252139: 16200,
    15253147: 16201,
    15302834: 16202,
    15304605: 16203,
    15309959: 16204,
    14990010: 16205,
    14990209: 16206,
    15042691: 16207,
    15049141: 16208,
    15049644: 16209,
    15052939: 16210,
    15176858: 16211,
    15052989: 16212,
    15238542: 16213,
    15247498: 16214,
    15253381: 16215,
    15309219: 16216,
    15310253: 16217,
    15183013: 16218,
    15248271: 16219,
    15310984: 16220,
    15304098: 16221,
    15047603: 16222,
    15044264: 16223,
    15302807: 16224,
    15044793: 16225,
    15048322: 16226,
    15055013: 16227,
    15109800: 16228,
    15118516: 16229,
    15172234: 16230,
    15179169: 16231,
    15184523: 16232,
    15187872: 16233,
    15245744: 16234,
    15303042: 16235,
    15304084: 16236,
    15305872: 16237,
    15305880: 16238,
    15309455: 16239,
    15176094: 16240,
    15313796: 16241,
    15053959: 16242,
    15054249: 16243,
    15111600: 16244,
    15113890: 16245,
    15251112: 16246,
    15309723: 16247,
    15109550: 16248,
    15113609: 16249,
    15115417: 16250,
    15241093: 16251,
    15310999: 16252,
    15309696: 16253,
    15246270: 16254,
    15122052: 16417,
    15110586: 16418,
    15052728: 16419,
    14989462: 16420,
    15171756: 16421,
    15177117: 16422,
    15112367: 16423,
    15042436: 16424,
    15042742: 16425,
    15043490: 16426,
    15050643: 16427,
    15056513: 16428,
    15106215: 16429,
    15108240: 16430,
    15111359: 16431,
    15111604: 16432,
    15112351: 16433,
    15112628: 16434,
    15115186: 16435,
    15114390: 16436,
    15117731: 16437,
    15120517: 16438,
    15174066: 16439,
    15176863: 16440,
    15178651: 16441,
    15184574: 16442,
    15237526: 16443,
    15049648: 16444,
    15246269: 16445,
    15246783: 16446,
    15248032: 16447,
    15248019: 16448,
    15248267: 16449,
    15302813: 16450,
    15304338: 16451,
    15310226: 16452,
    15310233: 16453,
    15111817: 16454,
    15181966: 16455,
    15238278: 16456,
    15309499: 16457,
    15055021: 16458,
    15106972: 16459,
    15108250: 16460,
    15111845: 16461,
    15112340: 16462,
    15113872: 16463,
    15179699: 16464,
    15182221: 16465,
    15184269: 16466,
    15186110: 16467,
    15238282: 16468,
    15250092: 16469,
    15250852: 16470,
    15251361: 16471,
    15251871: 16472,
    15180457: 16473,
    15042695: 16474,
    15109017: 16475,
    15109797: 16476,
    15110530: 16477,
    15108760: 16478,
    15247533: 16479,
    15182467: 16480,
    15183744: 16481,
    15248044: 16482,
    15309738: 16483,
    15185334: 16484,
    15239308: 16485,
    15244681: 16486,
    14990233: 16487,
    15041928: 16488,
    15043971: 16489,
    15044e3: 16490,
    15052451: 16491,
    15052930: 16492,
    15052950: 16493,
    15054749: 16494,
    15108262: 16495,
    15108487: 16496,
    15110832: 16497,
    15114387: 16498,
    15114420: 16499,
    15119241: 16500,
    15119749: 16501,
    15119511: 16502,
    15114131: 16503,
    15121820: 16504,
    15173006: 16505,
    15173053: 16506,
    15112075: 16507,
    15182271: 16508,
    15183533: 16509,
    15185818: 16510,
    15186314: 16673,
    15187624: 16674,
    15238586: 16675,
    15239323: 16676,
    15239353: 16677,
    15242918: 16678,
    15247790: 16679,
    15250318: 16680,
    15251381: 16681,
    15303096: 16682,
    15303095: 16683,
    15305389: 16684,
    15305361: 16685,
    15308419: 16686,
    15314606: 16687,
    15042957: 16688,
    15046276: 16689,
    15121592: 16690,
    15172790: 16691,
    15041960: 16692,
    15181445: 16693,
    15186325: 16694,
    15238835: 16695,
    15184782: 16696,
    15047052: 16697,
    15049105: 16698,
    15053480: 16699,
    15109802: 16700,
    15113150: 16701,
    15113149: 16702,
    15115674: 16703,
    15174553: 16704,
    15177359: 16705,
    15177358: 16706,
    15180942: 16707,
    15181206: 16708,
    15181727: 16709,
    15184535: 16710,
    15185056: 16711,
    15185284: 16712,
    15243399: 16713,
    15247540: 16714,
    15308987: 16715,
    15303073: 16716,
    15318176: 16717,
    15041447: 16718,
    15042997: 16719,
    15044492: 16720,
    15044514: 16721,
    15040649: 16722,
    15046314: 16723,
    15049646: 16724,
    15050127: 16725,
    15173821: 16726,
    15052427: 16727,
    15053220: 16728,
    15043741: 16729,
    15106979: 16730,
    15106995: 16731,
    15109532: 16732,
    15109763: 16733,
    15109311: 16734,
    15109819: 16735,
    15111053: 16736,
    15112105: 16737,
    15113145: 16738,
    15054755: 16739,
    15116173: 16740,
    15116221: 16741,
    15121557: 16742,
    15173541: 16743,
    14989961: 16744,
    15177641: 16745,
    15178680: 16746,
    15182483: 16747,
    15184799: 16748,
    15185807: 16749,
    15185564: 16750,
    15237537: 16751,
    15240585: 16752,
    15240600: 16753,
    15241644: 16754,
    15241916: 16755,
    15243195: 16756,
    15246213: 16757,
    15250864: 16758,
    15302785: 16759,
    15303085: 16760,
    15306391: 16761,
    15309980: 16762,
    15313042: 16763,
    15041423: 16764,
    15049367: 16765,
    15107726: 16766,
    15239059: 16929,
    15242421: 16930,
    15250568: 16931,
    15302816: 16932,
    14991235: 16933,
    15040948: 16934,
    15042951: 16935,
    15044019: 16936,
    15106479: 16937,
    15109513: 16938,
    15113631: 16939,
    15120556: 16940,
    15251123: 16941,
    15302815: 16942,
    14991255: 16943,
    15053214: 16944,
    15250314: 16945,
    15112079: 16946,
    15185562: 16947,
    15043986: 16948,
    15245974: 16949,
    15041974: 16950,
    15110019: 16951,
    15052184: 16952,
    15052203: 16953,
    15052938: 16954,
    15110285: 16955,
    15113617: 16956,
    15303068: 16957,
    14990230: 16958,
    15049882: 16959,
    15049898: 16960,
    15118768: 16961,
    15247761: 16962,
    15045822: 16963,
    15048853: 16964,
    15050405: 16965,
    15106992: 16966,
    15108499: 16967,
    15114113: 16968,
    15239349: 16969,
    15115669: 16970,
    15309184: 16971,
    15312772: 16972,
    15313064: 16973,
    14990739: 16974,
    15048838: 16975,
    15052734: 16976,
    15237264: 16977,
    15053489: 16978,
    15055023: 16979,
    15056517: 16980,
    15106208: 16981,
    15107467: 16982,
    15108276: 16983,
    15113151: 16984,
    15119280: 16985,
    15121310: 16986,
    15238030: 16987,
    15238591: 16988,
    15240084: 16989,
    15245963: 16990,
    15250104: 16991,
    15302784: 16992,
    15302830: 16993,
    15309450: 16994,
    15317915: 16995,
    15314843: 16996,
    14990243: 16997,
    15044528: 16998,
    15049895: 16999,
    15183020: 17e3,
    15304333: 17001,
    15311244: 17002,
    15316921: 17003,
    15121309: 17004,
    15171751: 17005,
    15043987: 17006,
    15046020: 17007,
    15052421: 17008,
    15108504: 17009,
    15108766: 17010,
    15109011: 17011,
    15119010: 17012,
    15122351: 17013,
    15175842: 17014,
    15247511: 17015,
    15306936: 17016,
    15122305: 17017,
    15248318: 17018,
    15240376: 17019,
    15042471: 17020,
    15244216: 17021,
    15044522: 17022,
    15044521: 17185,
    14990726: 17186,
    15303060: 17187,
    15253168: 17188,
    15050154: 17189,
    15238321: 17190,
    15054781: 17191,
    15182762: 17192,
    15253183: 17193,
    15115162: 17194,
    15249591: 17195,
    15174584: 17196,
    15315336: 17197,
    15116477: 17198,
    15248048: 17199,
    14989497: 17200,
    15043992: 17201,
    15046790: 17202,
    15048102: 17203,
    15108997: 17204,
    15109794: 17205,
    15112102: 17206,
    15117710: 17207,
    15120289: 17208,
    15120795: 17209,
    15172269: 17210,
    15179693: 17211,
    15182767: 17212,
    15183530: 17213,
    15185595: 17214,
    15237309: 17215,
    15238022: 17216,
    15244171: 17217,
    15248021: 17218,
    15306139: 17219,
    15047587: 17220,
    15049607: 17221,
    15056062: 17222,
    15111853: 17223,
    15112854: 17224,
    15116928: 17225,
    15118005: 17226,
    15176887: 17227,
    15248263: 17228,
    15040676: 17229,
    15179685: 17230,
    15047856: 17231,
    15056027: 17232,
    15106469: 17233,
    15112634: 17234,
    15118752: 17235,
    15177652: 17236,
    15181978: 17237,
    15187374: 17238,
    15239092: 17239,
    15244440: 17240,
    15303045: 17241,
    15312563: 17242,
    15183753: 17243,
    15177116: 17244,
    15182777: 17245,
    15183249: 17246,
    15242116: 17247,
    15302800: 17248,
    15181737: 17249,
    15182482: 17250,
    15240374: 17251,
    15051681: 17252,
    15179136: 17253,
    14989485: 17254,
    14990258: 17255,
    15052441: 17256,
    15056800: 17257,
    15108797: 17258,
    15112380: 17259,
    15114161: 17260,
    15119272: 17261,
    15243691: 17262,
    15245751: 17263,
    15247547: 17264,
    15304078: 17265,
    15305651: 17266,
    15312784: 17267,
    15116439: 17268,
    15171750: 17269,
    15174826: 17270,
    15240103: 17271,
    15241623: 17272,
    15250095: 17273,
    14989441: 17274,
    15041926: 17275,
    15042443: 17276,
    15046283: 17277,
    15052725: 17278,
    15054998: 17441,
    15055027: 17442,
    15055489: 17443,
    15056020: 17444,
    15056053: 17445,
    15056299: 17446,
    15056564: 17447,
    15108018: 17448,
    15109265: 17449,
    15112866: 17450,
    15113373: 17451,
    15121838: 17452,
    15174034: 17453,
    15176890: 17454,
    15178938: 17455,
    15237556: 17456,
    15238329: 17457,
    15238584: 17458,
    15244726: 17459,
    15248063: 17460,
    15248284: 17461,
    15251077: 17462,
    15251379: 17463,
    15305370: 17464,
    15308215: 17465,
    15310978: 17466,
    15315877: 17467,
    15043461: 17468,
    15109527: 17469,
    15178676: 17470,
    15113365: 17471,
    15118984: 17472,
    15175565: 17473,
    15250307: 17474,
    15306414: 17475,
    15309235: 17476,
    15119525: 17477,
    15049372: 17478,
    15115406: 17479,
    15116172: 17480,
    15253437: 17481,
    15306394: 17482,
    15177627: 17483,
    15302810: 17484,
    15049114: 17485,
    15114370: 17486,
    15109812: 17487,
    15116219: 17488,
    14990723: 17489,
    15121580: 17490,
    15114136: 17491,
    15253179: 17492,
    15242406: 17493,
    15185588: 17494,
    15306132: 17495,
    15115455: 17496,
    15121840: 17497,
    15048106: 17498,
    15049655: 17499,
    15051948: 17500,
    15185068: 17501,
    15173802: 17502,
    15044746: 17503,
    15304611: 17504,
    15316660: 17505,
    14989997: 17506,
    14990734: 17507,
    15040924: 17508,
    15040949: 17509,
    15042947: 17510,
    15250078: 17511,
    15045e3: 17512,
    15048868: 17513,
    15052442: 17514,
    15055005: 17515,
    15055509: 17516,
    15055533: 17517,
    15055799: 17518,
    15056031: 17519,
    15106700: 17520,
    15108789: 17521,
    15109306: 17522,
    15110032: 17523,
    15114927: 17524,
    15118720: 17525,
    15180423: 17526,
    15181454: 17527,
    15181963: 17528,
    15185824: 17529,
    15239559: 17530,
    15247490: 17531,
    15248294: 17532,
    15251844: 17533,
    15302803: 17534,
    15303352: 17697,
    15303853: 17698,
    15304600: 17699,
    15318158: 17700,
    15119269: 17701,
    15110552: 17702,
    15111074: 17703,
    15111605: 17704,
    15121332: 17705,
    15178372: 17706,
    15183003: 17707,
    15303081: 17708,
    15306641: 17709,
    15121082: 17710,
    15045554: 17711,
    15056569: 17712,
    15110820: 17713,
    15252877: 17714,
    15253421: 17715,
    15305092: 17716,
    15041976: 17717,
    15049131: 17718,
    15049897: 17719,
    15053205: 17720,
    15055511: 17721,
    15120315: 17722,
    15186575: 17723,
    15176860: 17724,
    15250108: 17725,
    15252386: 17726,
    15311259: 17727,
    15172281: 17728,
    14990493: 17729,
    15118015: 17730,
    15122097: 17731,
    15176880: 17732,
    15309755: 17733,
    15041934: 17734,
    15044752: 17735,
    15048885: 17736,
    15049111: 17737,
    15050412: 17738,
    15053216: 17739,
    15056530: 17740,
    15111831: 17741,
    15113628: 17742,
    15120545: 17743,
    15178171: 17744,
    15241119: 17745,
    15250349: 17746,
    15302804: 17747,
    15303613: 17748,
    15306125: 17749,
    15179941: 17750,
    15179962: 17751,
    15043242: 17752,
    15055526: 17753,
    15047839: 17754,
    15050164: 17755,
    15106194: 17756,
    15040658: 17757,
    15041946: 17758,
    15042220: 17759,
    15042445: 17760,
    15042688: 17761,
    15045776: 17762,
    15049108: 17763,
    15049112: 17764,
    15050135: 17765,
    15052437: 17766,
    15053750: 17767,
    15054475: 17768,
    15106748: 17769,
    15108757: 17770,
    15110317: 17771,
    15113649: 17772,
    15114627: 17773,
    15114940: 17774,
    15115167: 17775,
    15178647: 17776,
    15120280: 17777,
    15120815: 17778,
    15120027: 17779,
    15172015: 17780,
    15173512: 17781,
    15056275: 17782,
    15177624: 17783,
    15181239: 17784,
    15183241: 17785,
    15183252: 17786,
    15183250: 17787,
    15184790: 17788,
    15185329: 17789,
    15042736: 17790,
    15241635: 17953,
    15242665: 17954,
    15243172: 17955,
    15247502: 17956,
    15248516: 17957,
    15249798: 17958,
    15251599: 17959,
    15302787: 17960,
    15302799: 17961,
    15306905: 17962,
    15309238: 17963,
    15311021: 17964,
    15313072: 17965,
    15308696: 17966,
    15041421: 17967,
    15043477: 17968,
    15044748: 17969,
    15048834: 17970,
    15052942: 17971,
    15107751: 17972,
    15110814: 17973,
    15119518: 17974,
    15179443: 17975,
    15182757: 17976,
    15238068: 17977,
    15241348: 17978,
    15303059: 17979,
    15305349: 17980,
    15053728: 17981,
    15316103: 17982,
    15043775: 17983,
    15056535: 17984,
    15056563: 17985,
    15120028: 17986,
    15174073: 17987,
    15179171: 17988,
    15181503: 17989,
    15183780: 17990,
    15118226: 17991,
    15174572: 17992,
    15248045: 17993,
    15114371: 17994,
    15116705: 17995,
    15042488: 17996,
    15182465: 17997,
    15115444: 17998,
    15053194: 17999,
    15315894: 18e3,
    15240107: 18001,
    15052677: 18002,
    15304073: 18003,
    15171742: 18004,
    15047096: 18005,
    15053231: 18006,
    15106951: 18007,
    15111590: 18008,
    15118988: 18009,
    15249818: 18010,
    15303041: 18011,
    15310995: 18012,
    15045009: 18013,
    15113095: 18014,
    15304845: 18015,
    15050120: 18016,
    15303331: 18017,
    15042181: 18018,
    14989709: 18019,
    15042474: 18020,
    15242905: 18021,
    15248526: 18022,
    15171992: 18023,
    15109562: 18024,
    15306123: 18025,
    15115682: 18026,
    15312564: 18027,
    15186052: 18028,
    15177143: 18029,
    15043991: 18030,
    15115680: 18031,
    15252383: 18032,
    15309731: 18033,
    15118749: 18034,
    14989964: 18035,
    15052988: 18036,
    15056016: 18037,
    15253417: 18038,
    15043714: 18039,
    15250321: 18040,
    15237769: 18041,
    15243705: 18042,
    15055807: 18043,
    15112101: 18044,
    14989747: 18045,
    15041957: 18046,
    15050370: 18209,
    15052991: 18210,
    15310766: 18211,
    14990267: 18212,
    15050378: 18213,
    15056781: 18214,
    15248013: 18215,
    15122337: 18216,
    15181488: 18217,
    15181218: 18218,
    15052711: 18219,
    15241649: 18220,
    15174827: 18221,
    15173297: 18222,
    15055284: 18223,
    15056821: 18224,
    15109563: 18225,
    15110810: 18226,
    15173507: 18227,
    15184536: 18228,
    14989699: 18229,
    15055804: 18230,
    14989707: 18231,
    15048604: 18232,
    15047330: 18233,
    15106729: 18234,
    15122307: 18235,
    15185037: 18236,
    15238077: 18237,
    15238323: 18238,
    15238847: 18239,
    15253170: 18240,
    15246999: 18241,
    15243940: 18242,
    15054772: 18243,
    15108746: 18244,
    15110829: 18245,
    15246983: 18246,
    15113655: 18247,
    15119266: 18248,
    15119550: 18249,
    15175862: 18250,
    15179956: 18251,
    15051142: 18252,
    15187381: 18253,
    15239853: 18254,
    15312556: 18255,
    14991283: 18256,
    15055747: 18257,
    15109021: 18258,
    15109778: 18259,
    15111575: 18260,
    15113647: 18261,
    15178627: 18262,
    15174028: 18263,
    15238028: 18264,
    15237818: 18265,
    15252649: 18266,
    15304077: 18267,
    15040653: 18268,
    15048633: 18269,
    15051410: 18270,
    15114885: 18271,
    15115699: 18272,
    15173028: 18273,
    15174589: 18274,
    15250103: 18275,
    15049650: 18276,
    15250336: 18277,
    15309226: 18278,
    15302809: 18279,
    15244735: 18280,
    15181732: 18281,
    15179687: 18282,
    15241385: 18283,
    14990511: 18284,
    15042981: 18285,
    15043994: 18286,
    15109005: 18287,
    15114127: 18288,
    15119242: 18289,
    15178173: 18290,
    15183508: 18291,
    15184533: 18292,
    15239350: 18293,
    15242884: 18294,
    15253419: 18295,
    15113117: 18296,
    15121568: 18297,
    15173766: 18298,
    15186075: 18299,
    15240875: 18300,
    15312769: 18301,
    15317670: 18302,
    15042493: 18465,
    15183537: 18466,
    15180210: 18467,
    15183544: 18468,
    15237767: 18469,
    15183240: 18470,
    15117224: 18471,
    15055265: 18472,
    15237772: 18473,
    15177105: 18474,
    15177120: 18475,
    15041963: 18476,
    15305122: 18477,
    15121036: 18478,
    15178170: 18479,
    15304343: 18480,
    15313834: 18481,
    14990480: 18482,
    15187376: 18483,
    15108764: 18484,
    15183247: 18485,
    15308453: 18486,
    15315881: 18487,
    15047098: 18488,
    15049113: 18489,
    15244196: 18490,
    15309500: 18491,
    14990516: 18492,
    15042724: 18493,
    15043978: 18494,
    15044493: 18495,
    15044507: 18496,
    15054982: 18497,
    15110316: 18498,
    15111825: 18499,
    15113663: 18500,
    15118526: 18501,
    15118734: 18502,
    15174024: 18503,
    15174319: 18504,
    15175597: 18505,
    15177108: 18506,
    15186305: 18507,
    15239340: 18508,
    15243177: 18509,
    15250089: 18510,
    15183748: 18511,
    15304582: 18512,
    15173033: 18513,
    15310994: 18514,
    15311791: 18515,
    15109309: 18516,
    15112617: 18517,
    15177130: 18518,
    15178660: 18519,
    15180688: 18520,
    15242627: 18521,
    15244206: 18522,
    15043754: 18523,
    15043985: 18524,
    15044774: 18525,
    15050371: 18526,
    15055495: 18527,
    15056316: 18528,
    15106738: 18529,
    15108489: 18530,
    15108537: 18531,
    15108779: 18532,
    15111824: 18533,
    15118228: 18534,
    15119244: 18535,
    15177394: 18536,
    15178414: 18537,
    15180433: 18538,
    15181720: 18539,
    15185803: 18540,
    15187383: 18541,
    15237797: 18542,
    15245995: 18543,
    15248057: 18544,
    15250107: 18545,
    15303103: 18546,
    15310238: 18547,
    15311771: 18548,
    15116427: 18549,
    15184056: 18550,
    15041177: 18551,
    15052990: 18552,
    15056558: 18553,
    15113863: 18554,
    15118232: 18555,
    15175861: 18556,
    15178889: 18557,
    15187598: 18558,
    15318203: 18721,
    15114122: 18722,
    15181975: 18723,
    15043769: 18724,
    15177355: 18725,
    15313837: 18726,
    15056294: 18727,
    15238813: 18728,
    15241137: 18729,
    15237784: 18730,
    15056060: 18731,
    15056773: 18732,
    15177122: 18733,
    15183238: 18734,
    15302844: 18735,
    15114663: 18736,
    15050667: 18737,
    15051419: 18738,
    15185040: 18739,
    15178174: 18740,
    15248556: 18741,
    14991285: 18742,
    15056298: 18743,
    15116441: 18744,
    15118519: 18745,
    15121538: 18746,
    15176610: 18747,
    15181224: 18748,
    15245736: 18749,
    15247765: 18750,
    15249849: 18751,
    15055775: 18752,
    15110031: 18753,
    15177605: 18754,
    15181714: 18755,
    15240087: 18756,
    15305896: 18757,
    15305650: 18758,
    15241884: 18759,
    15244205: 18760,
    15315117: 18761,
    15045505: 18762,
    15056300: 18763,
    15111820: 18764,
    15119772: 18765,
    15171733: 18766,
    15250087: 18767,
    15250323: 18768,
    15311035: 18769,
    15111567: 18770,
    15176630: 18771,
    14989453: 18772,
    14990232: 18773,
    15048608: 18774,
    15049899: 18775,
    15051174: 18776,
    15052684: 18777,
    15042216: 18778,
    15054979: 18779,
    15055516: 18780,
    15106198: 18781,
    15108534: 18782,
    15111607: 18783,
    15111847: 18784,
    15112622: 18785,
    15119790: 18786,
    15173814: 18787,
    15183014: 18788,
    15238544: 18789,
    15238810: 18790,
    15239833: 18791,
    15248796: 18792,
    15250080: 18793,
    15250342: 18794,
    15250868: 18795,
    15308956: 18796,
    15309188: 18797,
    14991022: 18798,
    15110827: 18799,
    15117734: 18800,
    15239326: 18801,
    15241633: 18802,
    15242666: 18803,
    15303592: 18804,
    15052929: 18805,
    15115667: 18806,
    15311528: 18807,
    15241658: 18808,
    15242647: 18809,
    14990479: 18810,
    15042991: 18811,
    15056553: 18812,
    15055237: 18813,
    15113357: 18814,
    15181455: 18977,
    15238585: 18978,
    15246471: 18979,
    15246982: 18980,
    15120309: 18981,
    15056023: 18982,
    15108501: 18983,
    15119032: 18984,
    14990223: 18985,
    15174057: 18986,
    15314578: 18987,
    15042694: 18988,
    15044795: 18989,
    15047092: 18990,
    15049395: 18991,
    15107748: 18992,
    15108526: 18993,
    15172762: 18994,
    15050158: 18995,
    15184521: 18996,
    15184798: 18997,
    15185051: 18998,
    15309744: 18999,
    15111815: 19e3,
    15237534: 19001,
    14989465: 19002,
    14990773: 19003,
    15041973: 19004,
    15049088: 19005,
    15055267: 19006,
    15055283: 19007,
    15056010: 19008,
    15114116: 19009,
    14989478: 19010,
    15242429: 19011,
    15308425: 19012,
    15309211: 19013,
    15184307: 19014,
    15310977: 19015,
    15041467: 19016,
    15049601: 19017,
    15178134: 19018,
    15180455: 19019,
    15042725: 19020,
    15179429: 19021,
    15242385: 19022,
    15183494: 19023,
    15040911: 19024,
    15049865: 19025,
    15174023: 19026,
    15183751: 19027,
    15185832: 19028,
    15253178: 19029,
    15253396: 19030,
    15303053: 19031,
    14991039: 19032,
    15043465: 19033,
    15050921: 19034,
    15056001: 19035,
    15310509: 19036,
    14991261: 19037,
    15239319: 19038,
    15305642: 19039,
    15047811: 19040,
    15109525: 19041,
    15117737: 19042,
    15176875: 19043,
    15246236: 19044,
    15252628: 19045,
    15182210: 19046,
    15043487: 19047,
    15049363: 19048,
    15107477: 19049,
    15108234: 19050,
    15112878: 19051,
    15118221: 19052,
    15184063: 19053,
    15241129: 19054,
    15040675: 19055,
    14991288: 19056,
    15043717: 19057,
    15044998: 19058,
    15048881: 19059,
    15050121: 19060,
    15052445: 19061,
    15053744: 19062,
    15053743: 19063,
    15053993: 19064,
    15055510: 19065,
    15108785: 19066,
    15109543: 19067,
    15111358: 19068,
    15111865: 19069,
    15113355: 19070,
    15119253: 19233,
    15119265: 19234,
    15172537: 19235,
    15179954: 19236,
    15186091: 19237,
    15238046: 19238,
    15239859: 19239,
    15241356: 19240,
    15242156: 19241,
    15244418: 19242,
    15246482: 19243,
    15247530: 19244,
    15249802: 19245,
    15303334: 19246,
    15305618: 19247,
    15311805: 19248,
    15315891: 19249,
    15316396: 19250,
    14989711: 19251,
    14989985: 19252,
    15041165: 19253,
    15042966: 19254,
    15048074: 19255,
    15050408: 19256,
    15055037: 19257,
    15056792: 19258,
    15056793: 19259,
    15108287: 19260,
    15112884: 19261,
    15113371: 19262,
    15114128: 19263,
    15115154: 19264,
    15042194: 19265,
    15185057: 19266,
    15237802: 19267,
    15238824: 19268,
    15248512: 19269,
    15250060: 19270,
    15250111: 19271,
    15305150: 19272,
    15308978: 19273,
    15044768: 19274,
    15311020: 19275,
    15043735: 19276,
    15041429: 19277,
    15043996: 19278,
    15049384: 19279,
    15110834: 19280,
    15113396: 19281,
    15174055: 19282,
    15179174: 19283,
    15182214: 19284,
    15304614: 19285,
    15043459: 19286,
    15119009: 19287,
    15117958: 19288,
    15048832: 19289,
    15055244: 19290,
    15050132: 19291,
    15113388: 19292,
    15187899: 19293,
    15042465: 19294,
    15178630: 19295,
    15110569: 19296,
    15180712: 19297,
    15314324: 19298,
    15317691: 19299,
    15048587: 19300,
    15050425: 19301,
    15112359: 19302,
    15113882: 19303,
    15118222: 19304,
    15045545: 19305,
    15116185: 19306,
    15055253: 19307,
    15238812: 19308,
    15113877: 19309,
    15314602: 19310,
    15114174: 19311,
    15315346: 19312,
    15114653: 19313,
    14989990: 19314,
    14991267: 19315,
    15044488: 19316,
    15108793: 19317,
    15113387: 19318,
    15119019: 19319,
    15253380: 19320,
    14991021: 19321,
    15186349: 19322,
    15317695: 19323,
    14989447: 19324,
    15107490: 19325,
    15121024: 19326,
    15121579: 19489,
    15242387: 19490,
    15045043: 19491,
    15113386: 19492,
    15314309: 19493,
    15054771: 19494,
    15183509: 19495,
    15053484: 19496,
    15052678: 19497,
    15244444: 19498,
    15120778: 19499,
    15242129: 19500,
    15181972: 19501,
    15238280: 19502,
    15050393: 19503,
    15184525: 19504,
    15118481: 19505,
    15178912: 19506,
    15043481: 19507,
    15049890: 19508,
    15172769: 19509,
    15174047: 19510,
    15179675: 19511,
    15309991: 19512,
    15316385: 19513,
    15115403: 19514,
    15051199: 19515,
    15050904: 19516,
    15042213: 19517,
    15044749: 19518,
    15045053: 19519,
    15112334: 19520,
    15178655: 19521,
    15253431: 19522,
    15305368: 19523,
    15315892: 19524,
    15050666: 19525,
    15174045: 19526,
    15121285: 19527,
    15041933: 19528,
    15115145: 19529,
    15185599: 19530,
    15185836: 19531,
    15310242: 19532,
    15317690: 19533,
    15110584: 19534,
    15116449: 19535,
    15240322: 19536,
    15050372: 19537,
    15052191: 19538,
    15118235: 19539,
    15174811: 19540,
    15178674: 19541,
    15185586: 19542,
    15237271: 19543,
    15241881: 19544,
    15041714: 19545,
    15113384: 19546,
    15317913: 19547,
    15178670: 19548,
    15113634: 19549,
    15043519: 19550,
    15312005: 19551,
    15052964: 19552,
    15108283: 19553,
    15184318: 19554,
    15250096: 19555,
    15046031: 19556,
    15106742: 19557,
    15185035: 19558,
    15308416: 19559,
    15043713: 19560,
    14989727: 19561,
    15042230: 19562,
    15049884: 19563,
    15173818: 19564,
    15237302: 19565,
    15304590: 19566,
    15056037: 19567,
    15179682: 19568,
    15044228: 19569,
    15056313: 19570,
    15185028: 19571,
    15242924: 19572,
    15247539: 19573,
    15252109: 19574,
    15310230: 19575,
    15114163: 19576,
    15242926: 19577,
    15307155: 19578,
    15107209: 19579,
    15107208: 19580,
    15119033: 19581,
    15178130: 19582,
    15248301: 19745,
    15252664: 19746,
    15045807: 19747,
    14990737: 19748,
    15041706: 19749,
    15043463: 19750,
    15044491: 19751,
    15052453: 19752,
    15055293: 19753,
    15106720: 19754,
    15107714: 19755,
    15110038: 19756,
    15113353: 19757,
    15114138: 19758,
    15120807: 19759,
    15120012: 19760,
    15174838: 19761,
    15174839: 19762,
    15176881: 19763,
    15181200: 19764,
    15246229: 19765,
    15248024: 19766,
    15303050: 19767,
    15303313: 19768,
    15303605: 19769,
    15309700: 19770,
    15244941: 19771,
    15049877: 19772,
    14989960: 19773,
    14990745: 19774,
    14989454: 19775,
    15248009: 19776,
    15252671: 19777,
    15310992: 19778,
    15041197: 19779,
    15055292: 19780,
    15050390: 19781,
    15052473: 19782,
    15055544: 19783,
    15110042: 19784,
    15110074: 19785,
    15111041: 19786,
    15113116: 19787,
    15115658: 19788,
    15116184: 19789,
    15119499: 19790,
    15121078: 19791,
    15173268: 19792,
    15176872: 19793,
    15182511: 19794,
    15187594: 19795,
    15237248: 19796,
    15241609: 19797,
    15242121: 19798,
    15246977: 19799,
    15248545: 19800,
    15251594: 19801,
    15303077: 19802,
    15309245: 19803,
    15312010: 19804,
    15107518: 19805,
    15108753: 19806,
    15117490: 19807,
    15118979: 19808,
    15119796: 19809,
    15187852: 19810,
    15187900: 19811,
    15120256: 19812,
    15187589: 19813,
    15244986: 19814,
    15246264: 19815,
    15113637: 19816,
    15240881: 19817,
    15311036: 19818,
    15309751: 19819,
    15119515: 19820,
    15185313: 19821,
    15241405: 19822,
    15304106: 19823,
    14989745: 19824,
    15044021: 19825,
    15054224: 19826,
    15117444: 19827,
    15122347: 19828,
    15243149: 19829,
    15243437: 19830,
    15247015: 19831,
    15042729: 19832,
    15044751: 19833,
    15053221: 19834,
    15113614: 19835,
    15114920: 19836,
    15175814: 19837,
    15176323: 19838,
    15177634: 20001,
    15246223: 20002,
    15246241: 20003,
    15304588: 20004,
    15309730: 20005,
    15309240: 20006,
    15056523: 20007,
    15175303: 20008,
    15182731: 20009,
    15241614: 20010,
    15109792: 20011,
    15177125: 20012,
    15043209: 20013,
    15119745: 20014,
    15121052: 20015,
    15175817: 20016,
    15177113: 20017,
    15180203: 20018,
    15184530: 20019,
    15309446: 20020,
    15182748: 20021,
    15318669: 20022,
    14991030: 20023,
    15107502: 20024,
    15112069: 20025,
    15243676: 20026,
    14989958: 20027,
    14989998: 20028,
    15041434: 20029,
    14989473: 20030,
    15042444: 20031,
    15052718: 20032,
    15111833: 20033,
    15114881: 20034,
    15120060: 20035,
    15174815: 20036,
    15178114: 20037,
    15179437: 20038,
    15181980: 20039,
    15184807: 20040,
    15239599: 20041,
    15248274: 20042,
    15303100: 20043,
    15304591: 20044,
    15309237: 20045,
    15311e3: 20046,
    15043227: 20047,
    15185809: 20048,
    15040683: 20049,
    15044248: 20050,
    15113879: 20051,
    15120267: 20052,
    15173520: 20053,
    15175859: 20054,
    15239080: 20055,
    15252650: 20056,
    15309475: 20057,
    15315351: 20058,
    15317663: 20059,
    15176096: 20060,
    15049089: 20061,
    15120025: 20062,
    15185071: 20063,
    15311262: 20064,
    14990244: 20065,
    14990518: 20066,
    14990987: 20067,
    15042231: 20068,
    15043249: 20069,
    15054522: 20070,
    15106204: 20071,
    15175346: 20072,
    15180988: 20073,
    15240083: 20074,
    15304884: 20075,
    15309495: 20076,
    15309750: 20077,
    15309962: 20078,
    15317655: 20079,
    15318434: 20080,
    15112870: 20081,
    15117748: 20082,
    15042711: 20083,
    15043235: 20084,
    15172488: 20085,
    15246210: 20086,
    15055753: 20087,
    15106443: 20088,
    15107728: 20089,
    15121571: 20090,
    15173001: 20091,
    15184062: 20092,
    15185844: 20093,
    15237551: 20094,
    15242158: 20257,
    15302819: 20258,
    15305900: 20259,
    15044994: 20260,
    15314351: 20261,
    15117203: 20262,
    15172233: 20263,
    15250306: 20264,
    15251375: 20265,
    15310002: 20266,
    15043252: 20267,
    15051137: 20268,
    15055754: 20269,
    15056004: 20270,
    15113367: 20271,
    15115708: 20272,
    15115924: 20273,
    15119786: 20274,
    15121551: 20275,
    15174050: 20276,
    15174588: 20277,
    15183789: 20278,
    15237249: 20279,
    15237566: 20280,
    15244683: 20281,
    15303566: 20282,
    15041965: 20283,
    15317651: 20284,
    15181444: 20285,
    15237771: 20286,
    15305906: 20287,
    15248278: 20288,
    15040685: 20289,
    15045260: 20290,
    15247793: 20291,
    15117738: 20292,
    15250308: 20293,
    15238279: 20294,
    15106961: 20295,
    15113888: 20296,
    15316914: 20297,
    14989977: 20298,
    14989976: 20299,
    15315088: 20300,
    15247787: 20301,
    15243137: 20302,
    15242664: 20303,
    15115392: 20304,
    15120830: 20305,
    15180439: 20306,
    15238549: 20307,
    15056012: 20513,
    14989456: 20514,
    14989461: 20515,
    14989482: 20516,
    14989489: 20517,
    14989494: 20518,
    14989500: 20519,
    14989503: 20520,
    14989698: 20521,
    14989718: 20522,
    14989720: 20523,
    14989954: 20524,
    14989957: 20525,
    15249835: 20526,
    14989962: 20527,
    15239314: 20528,
    15056013: 20529,
    14989966: 20530,
    14989982: 20531,
    14989983: 20532,
    14989984: 20533,
    14989986: 20534,
    1499e4: 20535,
    14990003: 20536,
    14990006: 20537,
    14990222: 20538,
    14990221: 20539,
    14990212: 20540,
    14990214: 20541,
    14990210: 20542,
    14990231: 20543,
    14990238: 20544,
    14990253: 20545,
    14990239: 20546,
    14990263: 20547,
    14990473: 20548,
    14990746: 20549,
    14990512: 20550,
    14990747: 20551,
    14990749: 20552,
    14990743: 20553,
    14990727: 20554,
    14990774: 20555,
    14990984: 20556,
    14990991: 20557,
    14991e3: 20558,
    14990779: 20559,
    14990761: 20560,
    14990768: 20561,
    14990993: 20562,
    14990767: 20563,
    14990982: 20564,
    14990998: 20565,
    15041688: 20566,
    14991252: 20567,
    14991263: 20568,
    14991246: 20569,
    14991256: 20570,
    14991259: 20571,
    14991249: 20572,
    14991258: 20573,
    14991248: 20574,
    14991268: 20575,
    14991269: 20576,
    15040666: 20577,
    15040680: 20578,
    15040660: 20579,
    15040682: 20580,
    15040677: 20581,
    15040645: 20582,
    14990492: 20583,
    14991286: 20584,
    15040673: 20585,
    15040681: 20586,
    15040684: 20587,
    14991294: 20588,
    14991279: 20589,
    15040657: 20590,
    15040646: 20591,
    15040899: 20592,
    15040903: 20593,
    15113347: 20594,
    15040917: 20595,
    15040912: 20596,
    15040904: 20597,
    15040922: 20598,
    15040918: 20599,
    15040940: 20600,
    15040952: 20601,
    15041152: 20602,
    15041178: 20603,
    15041157: 20604,
    15041204: 20605,
    15041202: 20606,
    15041417: 20769,
    15041418: 20770,
    15041203: 20771,
    15041410: 20772,
    15041430: 20773,
    15041438: 20774,
    15041445: 20775,
    15041453: 20776,
    15041443: 20777,
    15041454: 20778,
    15041465: 20779,
    15041461: 20780,
    15041673: 20781,
    15041665: 20782,
    15041666: 20783,
    15041686: 20784,
    15041685: 20785,
    15041684: 20786,
    15041690: 20787,
    15041697: 20788,
    15041722: 20789,
    15041719: 20790,
    15041724: 20791,
    15041723: 20792,
    15041727: 20793,
    15041920: 20794,
    15041938: 20795,
    15041932: 20796,
    15041940: 20797,
    15041954: 20798,
    15182776: 20799,
    15041961: 20800,
    15041962: 20801,
    15041966: 20802,
    15042176: 20803,
    15042178: 20804,
    15047576: 20805,
    15042188: 20806,
    15042185: 20807,
    15042191: 20808,
    15042193: 20809,
    15042195: 20810,
    15042197: 20811,
    15042198: 20812,
    15042212: 20813,
    15042214: 20814,
    15042210: 20815,
    15042217: 20816,
    15042218: 20817,
    15042219: 20818,
    15042227: 20819,
    15042225: 20820,
    15042226: 20821,
    15042224: 20822,
    15042229: 20823,
    15042237: 20824,
    15042437: 20825,
    15042441: 20826,
    15042459: 20827,
    15042464: 20828,
    15243669: 20829,
    15042473: 20830,
    15042477: 20831,
    15042480: 20832,
    15042485: 20833,
    15042494: 20834,
    15042692: 20835,
    15042699: 20836,
    15042708: 20837,
    15042702: 20838,
    15042727: 20839,
    15042730: 20840,
    15042734: 20841,
    15042739: 20842,
    15042745: 20843,
    15042959: 20844,
    15042948: 20845,
    15042955: 20846,
    15042956: 20847,
    15042974: 20848,
    15042964: 20849,
    15042986: 20850,
    15042996: 20851,
    15042985: 20852,
    15042995: 20853,
    15043007: 20854,
    15043005: 20855,
    15043213: 20856,
    15043220: 20857,
    15043218: 20858,
    15042993: 20859,
    15043208: 20860,
    15043217: 20861,
    15253160: 20862,
    15253159: 21025,
    15043244: 21026,
    15043245: 21027,
    15043260: 21028,
    15043253: 21029,
    15043457: 21030,
    15043469: 21031,
    15043479: 21032,
    15043486: 21033,
    15043491: 21034,
    15043494: 21035,
    15311789: 21036,
    15043488: 21037,
    15043507: 21038,
    15043509: 21039,
    15043512: 21040,
    15043513: 21041,
    15043718: 21042,
    15043720: 21043,
    15176888: 21044,
    15043725: 21045,
    15043728: 21046,
    15043727: 21047,
    15043733: 21048,
    15043738: 21049,
    15043747: 21050,
    15043759: 21051,
    15043761: 21052,
    15043763: 21053,
    15043768: 21054,
    15043968: 21055,
    15043974: 21056,
    15043973: 21057,
    14989463: 21058,
    15043977: 21059,
    15043981: 21060,
    15042454: 21061,
    15043998: 21062,
    15044009: 21063,
    15044014: 21064,
    15049880: 21065,
    15044027: 21066,
    15044023: 21067,
    15044226: 21068,
    15044246: 21069,
    15044256: 21070,
    15044262: 21071,
    15044261: 21072,
    15044270: 21073,
    15044272: 21074,
    15044278: 21075,
    15044483: 21076,
    15184018: 21077,
    15309721: 21078,
    15044511: 21079,
    15113148: 21080,
    15173550: 21081,
    15044526: 21082,
    15044520: 21083,
    15044525: 21084,
    15044538: 21085,
    15044737: 21086,
    15044797: 21087,
    15044992: 21088,
    15044780: 21089,
    15044781: 21090,
    15044796: 21091,
    15044782: 21092,
    15044790: 21093,
    15044777: 21094,
    15044765: 21095,
    15045006: 21096,
    15045263: 21097,
    15045045: 21098,
    15045262: 21099,
    15045023: 21100,
    15045041: 21101,
    15045047: 21102,
    15045040: 21103,
    15045266: 21104,
    15045051: 21105,
    15045248: 21106,
    15045046: 21107,
    15045252: 21108,
    15045264: 21109,
    15045254: 21110,
    15045511: 21111,
    15045282: 21112,
    15045304: 21113,
    15045285: 21114,
    15045292: 21115,
    15045508: 21116,
    15045512: 21117,
    15045288: 21118,
    15045291: 21281,
    15045506: 21282,
    15045284: 21283,
    15045310: 21284,
    15045308: 21285,
    15045528: 21286,
    15045541: 21287,
    15045542: 21288,
    15045775: 21289,
    15045780: 21290,
    15045565: 21291,
    15045550: 21292,
    15045549: 21293,
    15045562: 21294,
    15045538: 21295,
    15045817: 21296,
    15046016: 21297,
    15046051: 21298,
    15046028: 21299,
    15045806: 21300,
    15046044: 21301,
    15046021: 21302,
    15046038: 21303,
    15046039: 21304,
    15045816: 21305,
    15045811: 21306,
    15046045: 21307,
    15046297: 21308,
    15046272: 21309,
    15045295: 21310,
    15046282: 21311,
    15046303: 21312,
    15046075: 21313,
    15046078: 21314,
    15046296: 21315,
    15046302: 21316,
    15046318: 21317,
    15046076: 21318,
    15046275: 21319,
    15046313: 21320,
    15046279: 21321,
    15046312: 21322,
    15046554: 21323,
    15046533: 21324,
    15046559: 21325,
    15046532: 21326,
    15046556: 21327,
    15046564: 21328,
    15046548: 21329,
    15046804: 21330,
    15046583: 21331,
    15046806: 21332,
    15046590: 21333,
    15046589: 21334,
    15046811: 21335,
    15046585: 21336,
    15047054: 21337,
    15047056: 21338,
    15173535: 21339,
    15046836: 21340,
    15046838: 21341,
    15046834: 21342,
    15046840: 21343,
    15047083: 21344,
    15047076: 21345,
    15046831: 21346,
    15047084: 21347,
    15047082: 21348,
    15047302: 21349,
    15047296: 21350,
    15047306: 21351,
    15047328: 21352,
    15047316: 21353,
    15047311: 21354,
    15047333: 21355,
    15047342: 21356,
    15047350: 21357,
    15047348: 21358,
    15047554: 21359,
    15047356: 21360,
    15047553: 21361,
    15047555: 21362,
    15047552: 21363,
    15047560: 21364,
    15047566: 21365,
    15047569: 21366,
    15047571: 21367,
    15047575: 21368,
    15047598: 21369,
    15047609: 21370,
    15047808: 21371,
    15047615: 21372,
    15047812: 21373,
    15047817: 21374,
    15047816: 21537,
    15047819: 21538,
    15047821: 21539,
    15047827: 21540,
    15047832: 21541,
    15047830: 21542,
    15046535: 21543,
    15047836: 21544,
    15047846: 21545,
    15047863: 21546,
    15047864: 21547,
    15048078: 21548,
    15047867: 21549,
    15048064: 21550,
    15048079: 21551,
    15048105: 21552,
    15048576: 21553,
    15048328: 21554,
    15048097: 21555,
    15048127: 21556,
    15048329: 21557,
    15048339: 21558,
    15048352: 21559,
    15048371: 21560,
    15048356: 21561,
    15048362: 21562,
    15048368: 21563,
    15048579: 21564,
    15048582: 21565,
    15048596: 21566,
    15048594: 21567,
    15048595: 21568,
    15048842: 21569,
    15048598: 21570,
    15048611: 21571,
    15048843: 21572,
    15048857: 21573,
    15048861: 21574,
    15049138: 21575,
    15048865: 21576,
    15049122: 21577,
    15049099: 21578,
    15049136: 21579,
    15118208: 21580,
    15049106: 21581,
    15048893: 21582,
    15049145: 21583,
    15049349: 21584,
    15049401: 21585,
    15049375: 21586,
    15049387: 21587,
    15049402: 21588,
    15049630: 21589,
    15049403: 21590,
    15049400: 21591,
    15049390: 21592,
    15049605: 21593,
    15049619: 21594,
    15049617: 21595,
    15049623: 21596,
    15049625: 21597,
    15049624: 21598,
    15049637: 21599,
    15049628: 21600,
    15049636: 21601,
    15049631: 21602,
    15049647: 21603,
    15049658: 21604,
    15049657: 21605,
    15049659: 21606,
    15049660: 21607,
    15049661: 21608,
    15049858: 21609,
    15049866: 21610,
    15049872: 21611,
    15049883: 21612,
    15114918: 21613,
    15049893: 21614,
    15049900: 21615,
    15049901: 21616,
    15049906: 21617,
    15049912: 21618,
    15049918: 21619,
    15182738: 21620,
    15050133: 21621,
    15050128: 21622,
    15050126: 21623,
    15050138: 21624,
    15050136: 21625,
    15050146: 21626,
    15050144: 21627,
    15050151: 21628,
    15050156: 21629,
    15050153: 21630,
    15050168: 21793,
    15050369: 21794,
    15050397: 21795,
    14990750: 21796,
    14991019: 21797,
    15050403: 21798,
    15050418: 21799,
    15050630: 21800,
    15050664: 21801,
    15050652: 21802,
    15050381: 21803,
    15050649: 21804,
    15050650: 21805,
    15050917: 21806,
    15050911: 21807,
    15050897: 21808,
    15050908: 21809,
    15050889: 21810,
    15050906: 21811,
    15051136: 21812,
    15051180: 21813,
    15051145: 21814,
    15050933: 21815,
    15050934: 21816,
    15051170: 21817,
    15051178: 21818,
    15051418: 21819,
    15051452: 21820,
    15051454: 21821,
    15051659: 21822,
    15051650: 21823,
    15051453: 21824,
    15051683: 21825,
    15051671: 21826,
    15051686: 21827,
    15051689: 21828,
    15051670: 21829,
    15051706: 21830,
    15051707: 21831,
    15051916: 21832,
    15051915: 21833,
    15051926: 21834,
    15051954: 21835,
    15051664: 21836,
    15051946: 21837,
    15051958: 21838,
    15051966: 21839,
    15052163: 21840,
    15052165: 21841,
    15052160: 21842,
    15052177: 21843,
    15052181: 21844,
    15052186: 21845,
    15052187: 21846,
    15052197: 21847,
    15052201: 21848,
    15052208: 21849,
    15052211: 21850,
    15052213: 21851,
    15052216: 21852,
    15111816: 21853,
    15052218: 21854,
    15052416: 21855,
    15052419: 21856,
    15052454: 21857,
    15052472: 21858,
    15052675: 21859,
    15052679: 21860,
    15052681: 21861,
    15052692: 21862,
    15052688: 21863,
    15052708: 21864,
    15052710: 21865,
    15052706: 21866,
    15052702: 21867,
    15052709: 21868,
    15052715: 21869,
    15052720: 21870,
    15052726: 21871,
    15052723: 21872,
    15052933: 21873,
    15052935: 21874,
    15052936: 21875,
    15052941: 21876,
    15052947: 21877,
    15052960: 21878,
    15052962: 21879,
    15052968: 21880,
    15052984: 21881,
    15052985: 21882,
    15053185: 21883,
    15053190: 21884,
    15053198: 21885,
    15053203: 21886,
    15053200: 22049,
    15053199: 22050,
    15052209: 22051,
    15053228: 22052,
    15053230: 22053,
    14989730: 22054,
    15053238: 22055,
    15053241: 22056,
    15053452: 22057,
    15053457: 22058,
    15053460: 22059,
    15050395: 22060,
    15053483: 22061,
    15053499: 22062,
    15053494: 22063,
    15053500: 22064,
    15053495: 22065,
    15053701: 22066,
    15053502: 22067,
    15053703: 22068,
    15053721: 22069,
    15053737: 22070,
    15053757: 22071,
    15053754: 22072,
    15053741: 22073,
    15054476: 22074,
    15053738: 22075,
    15053963: 22076,
    15053973: 22077,
    15053975: 22078,
    15054236: 22079,
    15053983: 22080,
    15053979: 22081,
    15053969: 22082,
    15053972: 22083,
    15053986: 22084,
    15053978: 22085,
    15053977: 22086,
    15053976: 22087,
    15054220: 22088,
    15054226: 22089,
    15054222: 22090,
    15054219: 22091,
    15054252: 22092,
    15054259: 22093,
    15054262: 22094,
    15054471: 22095,
    15054468: 22096,
    15054466: 22097,
    15054498: 22098,
    15054493: 22099,
    15054508: 22100,
    15054510: 22101,
    15054525: 22102,
    15054480: 22103,
    15054519: 22104,
    15054524: 22105,
    15054729: 22106,
    15054733: 22107,
    15054739: 22108,
    15054738: 22109,
    15054742: 22110,
    15054747: 22111,
    15054763: 22112,
    15054770: 22113,
    15054773: 22114,
    15054987: 22115,
    15055002: 22116,
    15055001: 22117,
    15054993: 22118,
    15055003: 22119,
    15055030: 22120,
    15055031: 22121,
    15055236: 22122,
    15055235: 22123,
    15055232: 22124,
    15055246: 22125,
    15055255: 22126,
    15055252: 22127,
    15055263: 22128,
    15055266: 22129,
    15055268: 22130,
    15055239: 22131,
    15055285: 22132,
    15055286: 22133,
    15055290: 22134,
    15317692: 22135,
    15055295: 22136,
    15055520: 22137,
    15055745: 22138,
    15055746: 22139,
    15055752: 22140,
    15055760: 22141,
    15055759: 22142,
    15055766: 22305,
    15055779: 22306,
    15055773: 22307,
    15055770: 22308,
    15055771: 22309,
    15055778: 22310,
    15055777: 22311,
    15055784: 22312,
    15055785: 22313,
    15055788: 22314,
    15055793: 22315,
    15055795: 22316,
    15055792: 22317,
    15055796: 22318,
    15055800: 22319,
    15055806: 22320,
    15056003: 22321,
    15056009: 22322,
    15056285: 22323,
    15056284: 22324,
    15056011: 22325,
    15056017: 22326,
    15056022: 22327,
    15056041: 22328,
    15056045: 22329,
    15056056: 22330,
    15056257: 22331,
    15056264: 22332,
    15056268: 22333,
    15056270: 22334,
    15056047: 22335,
    15056273: 22336,
    15056278: 22337,
    15056279: 22338,
    15056281: 22339,
    15056289: 22340,
    15056301: 22341,
    15056307: 22342,
    15056311: 22343,
    15056515: 22344,
    15056514: 22345,
    15056319: 22346,
    15056522: 22347,
    15056520: 22348,
    15056529: 22349,
    15056519: 22350,
    15056542: 22351,
    15056537: 22352,
    15056536: 22353,
    15056544: 22354,
    15056552: 22355,
    15056557: 22356,
    15056572: 22357,
    15056790: 22358,
    15056827: 22359,
    15056804: 22360,
    15056824: 22361,
    15056817: 22362,
    15056797: 22363,
    15106739: 22364,
    15056831: 22365,
    15106209: 22366,
    15106464: 22367,
    15106201: 22368,
    15106192: 22369,
    15106217: 22370,
    15106190: 22371,
    15106225: 22372,
    15106203: 22373,
    15106197: 22374,
    15106219: 22375,
    15106214: 22376,
    15106191: 22377,
    15106234: 22378,
    15106458: 22379,
    15106433: 22380,
    15106474: 22381,
    15106487: 22382,
    15106463: 22383,
    15106442: 22384,
    15106438: 22385,
    15106445: 22386,
    15106467: 22387,
    15106435: 22388,
    15106468: 22389,
    15106434: 22390,
    15106476: 22391,
    15106475: 22392,
    15106457: 22393,
    15106689: 22394,
    15106701: 22395,
    15106983: 22396,
    15106691: 22397,
    15106714: 22398,
    15106692: 22561,
    15106715: 22562,
    15106710: 22563,
    15106711: 22564,
    15106706: 22565,
    15106727: 22566,
    15106699: 22567,
    15106977: 22568,
    15106744: 22569,
    15106976: 22570,
    15106963: 22571,
    15106740: 22572,
    15056816: 22573,
    15106749: 22574,
    15106950: 22575,
    15106741: 22576,
    15106968: 22577,
    15107469: 22578,
    15107221: 22579,
    15107206: 22580,
    15106998: 22581,
    15106999: 22582,
    15107200: 22583,
    15106996: 22584,
    15107002: 22585,
    15107203: 22586,
    15107233: 22587,
    15107003: 22588,
    15106993: 22589,
    15107213: 22590,
    15107214: 22591,
    15107463: 22592,
    15107262: 22593,
    15107240: 22594,
    15107239: 22595,
    15107466: 22596,
    15107263: 22597,
    15107260: 22598,
    15107244: 22599,
    15107252: 22600,
    15107261: 22601,
    15107458: 22602,
    15107460: 22603,
    15107507: 22604,
    15107511: 22605,
    15107480: 22606,
    15107481: 22607,
    15107482: 22608,
    15107499: 22609,
    15107508: 22610,
    15107503: 22611,
    15107493: 22612,
    15107505: 22613,
    15107487: 22614,
    15107485: 22615,
    15107475: 22616,
    15107509: 22617,
    15107737: 22618,
    15107734: 22619,
    15107719: 22620,
    15107756: 22621,
    15107732: 22622,
    15107738: 22623,
    15107722: 22624,
    15107729: 22625,
    15107755: 22626,
    15107758: 22627,
    15107980: 22628,
    15107978: 22629,
    15107977: 22630,
    15108023: 22631,
    15107976: 22632,
    15107971: 22633,
    15107974: 22634,
    15107770: 22635,
    15107979: 22636,
    15187385: 22637,
    15107981: 22638,
    15108006: 22639,
    15108003: 22640,
    15108022: 22641,
    15108026: 22642,
    15108020: 22643,
    15108031: 22644,
    15108029: 22645,
    15108028: 22646,
    15108030: 22647,
    15108224: 22648,
    15108232: 22649,
    15108233: 22650,
    15108237: 22651,
    15108236: 22652,
    15108244: 22653,
    15108251: 22654,
    15108254: 22817,
    15108257: 22818,
    15108266: 22819,
    15108270: 22820,
    15108272: 22821,
    15108274: 22822,
    15108275: 22823,
    15108481: 22824,
    15108494: 22825,
    15108510: 22826,
    15108515: 22827,
    15108507: 22828,
    15108512: 22829,
    15108520: 22830,
    15108540: 22831,
    15108738: 22832,
    15108745: 22833,
    15108542: 22834,
    15108754: 22835,
    15108755: 22836,
    15108758: 22837,
    15109012: 22838,
    15108739: 22839,
    15108756: 22840,
    15109015: 22841,
    15109009: 22842,
    15108795: 22843,
    15109007: 22844,
    15109055: 22845,
    15108998: 22846,
    15111060: 22847,
    15109e3: 22848,
    15109020: 22849,
    15109004: 22850,
    15109002: 22851,
    15108994: 22852,
    15108999: 22853,
    15108763: 22854,
    15109001: 22855,
    15109260: 22856,
    15109038: 22857,
    15109041: 22858,
    15109287: 22859,
    15109250: 22860,
    15109256: 22861,
    15109039: 22862,
    15109045: 22863,
    15109520: 22864,
    15109310: 22865,
    15109517: 22866,
    15110300: 22867,
    15109519: 22868,
    15109782: 22869,
    15109774: 22870,
    15109760: 22871,
    15109803: 22872,
    15109558: 22873,
    15109795: 22874,
    15109775: 22875,
    15109769: 22876,
    15109791: 22877,
    15109813: 22878,
    15109547: 22879,
    15109545: 22880,
    15109822: 22881,
    15110057: 22882,
    15110016: 22883,
    15110022: 22884,
    15110051: 22885,
    15110025: 22886,
    15110034: 22887,
    15110070: 22888,
    15110020: 22889,
    15110294: 22890,
    15110324: 22891,
    15110278: 22892,
    15110291: 22893,
    15110310: 22894,
    15110326: 22895,
    15111325: 22896,
    15110295: 22897,
    15110312: 22898,
    15110287: 22899,
    15110567: 22900,
    15110575: 22901,
    15110582: 22902,
    15110542: 22903,
    15111338: 22904,
    15110805: 22905,
    15110803: 22906,
    15110821: 22907,
    15110825: 22908,
    15110792: 22909,
    15110844: 22910,
    15111066: 23073,
    15111058: 23074,
    15111045: 23075,
    15111047: 23076,
    15110843: 23077,
    15111064: 23078,
    15111042: 23079,
    15111089: 23080,
    15111079: 23081,
    15239305: 23082,
    15111072: 23083,
    15111073: 23084,
    15108780: 23085,
    15111075: 23086,
    15111087: 23087,
    15111340: 23088,
    15111094: 23089,
    15111092: 23090,
    15111090: 23091,
    15111098: 23092,
    15111296: 23093,
    15111101: 23094,
    15111320: 23095,
    15111324: 23096,
    15111301: 23097,
    15111332: 23098,
    15111331: 23099,
    15111339: 23100,
    15111348: 23101,
    15111349: 23102,
    15111351: 23103,
    15111350: 23104,
    15111352: 23105,
    15177099: 23106,
    15111560: 23107,
    15111574: 23108,
    15111573: 23109,
    15111565: 23110,
    15111576: 23111,
    15111582: 23112,
    15111581: 23113,
    15111602: 23114,
    15111608: 23115,
    15111810: 23116,
    15111811: 23117,
    15249034: 23118,
    15111835: 23119,
    15111839: 23120,
    15111851: 23121,
    15111863: 23122,
    15112067: 23123,
    15112070: 23124,
    15112065: 23125,
    15112068: 23126,
    15112076: 23127,
    15112082: 23128,
    15112091: 23129,
    15112089: 23130,
    15112096: 23131,
    15112097: 23132,
    15112113: 23133,
    15113650: 23134,
    15112330: 23135,
    15112323: 23136,
    15112123: 23137,
    15113651: 23138,
    15112373: 23139,
    15112374: 23140,
    15112372: 23141,
    15112348: 23142,
    15112591: 23143,
    15112580: 23144,
    15112585: 23145,
    15112577: 23146,
    15112606: 23147,
    15112605: 23148,
    15112612: 23149,
    15112615: 23150,
    15112616: 23151,
    15112607: 23152,
    15112610: 23153,
    15112624: 23154,
    15112835: 23155,
    15112840: 23156,
    15112846: 23157,
    15112841: 23158,
    15112836: 23159,
    15112856: 23160,
    15112861: 23161,
    15113089: 23162,
    15112889: 23163,
    15113097: 23164,
    15112894: 23165,
    15112892: 23166,
    15113092: 23329,
    15112888: 23330,
    15113110: 23331,
    15113114: 23332,
    15113120: 23333,
    15112383: 23334,
    15113126: 23335,
    15113129: 23336,
    15113136: 23337,
    15113141: 23338,
    15113143: 23339,
    15113359: 23340,
    15113366: 23341,
    15113374: 23342,
    15113382: 23343,
    15113383: 23344,
    15310008: 23345,
    15113390: 23346,
    15113407: 23347,
    15113398: 23348,
    15113601: 23349,
    15113400: 23350,
    15113399: 23351,
    15113606: 23352,
    15113630: 23353,
    15113632: 23354,
    15113625: 23355,
    15113635: 23356,
    15113636: 23357,
    15113865: 23358,
    15113648: 23359,
    15113897: 23360,
    15113660: 23361,
    15113642: 23362,
    15113868: 23363,
    15113867: 23364,
    15113894: 23365,
    15113889: 23366,
    15113861: 23367,
    15113911: 23368,
    15114159: 23369,
    15113908: 23370,
    15114156: 23371,
    15113907: 23372,
    15114153: 23373,
    15113912: 23374,
    15114148: 23375,
    15114142: 23376,
    15114141: 23377,
    15114146: 23378,
    15114158: 23379,
    15113913: 23380,
    15114126: 23381,
    15114118: 23382,
    15114151: 23383,
    15116956: 23384,
    15114398: 23385,
    15114630: 23386,
    15114409: 23387,
    15114624: 23388,
    15114637: 23389,
    15114418: 23390,
    15114638: 23391,
    15114931: 23392,
    15114411: 23393,
    15114649: 23394,
    15114659: 23395,
    15114679: 23396,
    15114687: 23397,
    15114911: 23398,
    15114895: 23399,
    15114925: 23400,
    15114900: 23401,
    15114909: 23402,
    15114907: 23403,
    15114883: 23404,
    15116974: 23405,
    15114937: 23406,
    15114676: 23407,
    15114933: 23408,
    15114912: 23409,
    15114938: 23410,
    15115407: 23411,
    15114893: 23412,
    15114686: 23413,
    15115393: 23414,
    15115146: 23415,
    15115400: 23416,
    15115160: 23417,
    15115426: 23418,
    15115430: 23419,
    15115169: 23420,
    15115404: 23421,
    15115149: 23422,
    15115156: 23585,
    15115175: 23586,
    15115157: 23587,
    15115446: 23588,
    15115410: 23589,
    15115396: 23590,
    15115159: 23591,
    15115171: 23592,
    15115429: 23593,
    15115193: 23594,
    15115168: 23595,
    15115183: 23596,
    15115432: 23597,
    15115434: 23598,
    15115418: 23599,
    15115427: 23600,
    15115425: 23601,
    15115142: 23602,
    15115705: 23603,
    15115703: 23604,
    15115676: 23605,
    15115704: 23606,
    15115691: 23607,
    15115668: 23608,
    15115710: 23609,
    15115694: 23610,
    15115449: 23611,
    15115700: 23612,
    15115453: 23613,
    15115673: 23614,
    15115440: 23615,
    15115681: 23616,
    15115678: 23617,
    15115677: 23618,
    15115905: 23619,
    15115690: 23620,
    15115954: 23621,
    15115950: 23622,
    15116176: 23623,
    15115967: 23624,
    15116161: 23625,
    15116179: 23626,
    15115966: 23627,
    15116174: 23628,
    15052712: 23629,
    15116170: 23630,
    15116189: 23631,
    15115963: 23632,
    15116163: 23633,
    15115943: 23634,
    15116462: 23635,
    15115921: 23636,
    15115936: 23637,
    15115932: 23638,
    15115925: 23639,
    15115956: 23640,
    15116190: 23641,
    15116200: 23642,
    15116418: 23643,
    15116443: 23644,
    15116223: 23645,
    15117450: 23646,
    15116217: 23647,
    15116210: 23648,
    15116199: 23649,
    15116421: 23650,
    15115953: 23651,
    15116446: 23652,
    15116205: 23653,
    15116436: 23654,
    15116203: 23655,
    15116426: 23656,
    15116434: 23657,
    15117185: 23658,
    15116451: 23659,
    15116435: 23660,
    15116676: 23661,
    15116428: 23662,
    15116722: 23663,
    15116470: 23664,
    15116728: 23665,
    15116679: 23666,
    15116706: 23667,
    15116697: 23668,
    15116710: 23669,
    15116680: 23670,
    15116472: 23671,
    15116450: 23672,
    15116944: 23673,
    15116941: 23674,
    15116960: 23675,
    15116932: 23676,
    15116962: 23677,
    15116963: 23678,
    15116951: 23841,
    15243415: 23842,
    15116987: 23843,
    15117187: 23844,
    15117186: 23845,
    15116984: 23846,
    15116979: 23847,
    15116972: 23848,
    15117214: 23849,
    15117201: 23850,
    15117215: 23851,
    15116970: 23852,
    15117210: 23853,
    15117226: 23854,
    15117243: 23855,
    15117445: 23856,
    15243414: 23857,
    15117242: 23858,
    15117458: 23859,
    15117462: 23860,
    15314097: 23861,
    15117471: 23862,
    15117496: 23863,
    15117495: 23864,
    15178652: 23865,
    15117497: 23866,
    15311790: 23867,
    15117703: 23868,
    15117699: 23869,
    15117705: 23870,
    15117712: 23871,
    15117721: 23872,
    15117716: 23873,
    15117723: 23874,
    15117727: 23875,
    15117729: 23876,
    15117752: 23877,
    15117753: 23878,
    15117759: 23879,
    15117952: 23880,
    15117956: 23881,
    15117955: 23882,
    15117965: 23883,
    15117976: 23884,
    15117973: 23885,
    15117982: 23886,
    15117988: 23887,
    15117994: 23888,
    15117995: 23889,
    15117999: 23890,
    15118002: 23891,
    15118001: 23892,
    15118003: 23893,
    15118007: 23894,
    15118012: 23895,
    15118214: 23896,
    15118219: 23897,
    15118227: 23898,
    15118239: 23899,
    15118252: 23900,
    15118251: 23901,
    15118259: 23902,
    15118255: 23903,
    15317694: 23904,
    15118472: 23905,
    15118483: 23906,
    15118484: 23907,
    15118491: 23908,
    15118500: 23909,
    15118499: 23910,
    15118750: 23911,
    15118741: 23912,
    15118754: 23913,
    15118762: 23914,
    15118978: 23915,
    15118989: 23916,
    15119002: 23917,
    15118977: 23918,
    15119003: 23919,
    15118782: 23920,
    15118760: 23921,
    15118771: 23922,
    15118994: 23923,
    15118992: 23924,
    15119236: 23925,
    15119281: 23926,
    15119251: 23927,
    15119037: 23928,
    15119255: 23929,
    15119237: 23930,
    15119261: 23931,
    15119022: 23932,
    15119025: 23933,
    15119038: 23934,
    15119034: 24097,
    15119259: 24098,
    15119279: 24099,
    15119257: 24100,
    15119274: 24101,
    15119519: 24102,
    15245709: 24103,
    15119542: 24104,
    15119531: 24105,
    15119549: 24106,
    15119544: 24107,
    15119513: 24108,
    15119541: 24109,
    15119539: 24110,
    15119506: 24111,
    15119500: 24112,
    15119779: 24113,
    15120019: 24114,
    15119780: 24115,
    15119770: 24116,
    15119801: 24117,
    15119769: 24118,
    15120014: 24119,
    15120021: 24120,
    15122340: 24121,
    15120005: 24122,
    15120313: 24123,
    15120533: 24124,
    15120522: 24125,
    15120053: 24126,
    15120263: 24127,
    15120294: 24128,
    15120056: 24129,
    15120262: 24130,
    15120300: 24131,
    15120286: 24132,
    15120268: 24133,
    15120296: 24134,
    15120274: 24135,
    15120261: 24136,
    15120314: 24137,
    15120281: 24138,
    15120292: 24139,
    15120277: 24140,
    15120298: 24141,
    15120302: 24142,
    15120557: 24143,
    15120814: 24144,
    15120558: 24145,
    15120537: 24146,
    15120818: 24147,
    15120799: 24148,
    15120574: 24149,
    15120547: 24150,
    15120811: 24151,
    15120555: 24152,
    15120822: 24153,
    15120781: 24154,
    15120543: 24155,
    15120771: 24156,
    15120570: 24157,
    15120782: 24158,
    15120548: 24159,
    15121343: 24160,
    15120541: 24161,
    15120568: 24162,
    15121026: 24163,
    15121066: 24164,
    15121048: 24165,
    15121289: 24166,
    15121079: 24167,
    15121299: 24168,
    15121085: 24169,
    15121071: 24170,
    15121284: 24171,
    15121074: 24172,
    15121300: 24173,
    15121301: 24174,
    15121039: 24175,
    15121061: 24176,
    15121282: 24177,
    15121055: 24178,
    15121793: 24179,
    15121553: 24180,
    15171980: 24181,
    15121324: 24182,
    15121336: 24183,
    15121342: 24184,
    15121599: 24185,
    15121330: 24186,
    15121585: 24187,
    15121327: 24188,
    15121586: 24189,
    15121292: 24190,
    15121598: 24353,
    15121555: 24354,
    15121335: 24355,
    15122054: 24356,
    15121850: 24357,
    15121848: 24358,
    15122049: 24359,
    15122048: 24360,
    15121839: 24361,
    15121819: 24362,
    15122355: 24363,
    15121837: 24364,
    15122050: 24365,
    15121852: 24366,
    15121816: 24367,
    15122062: 24368,
    15122065: 24369,
    15122306: 24370,
    15121830: 24371,
    15122099: 24372,
    15122083: 24373,
    15122081: 24374,
    15122084: 24375,
    15122105: 24376,
    15122310: 24377,
    15122090: 24378,
    15122335: 24379,
    15122325: 24380,
    15122348: 24381,
    15122324: 24382,
    15122328: 24383,
    15122353: 24384,
    15122350: 24385,
    15122331: 24386,
    15171721: 24387,
    15171723: 24388,
    15122362: 24389,
    15171729: 24390,
    15171713: 24391,
    15171727: 24392,
    15122366: 24393,
    15171739: 24394,
    15171738: 24395,
    15121844: 24396,
    15171741: 24397,
    15171736: 24398,
    15171743: 24399,
    15171760: 24400,
    15171774: 24401,
    15171762: 24402,
    15171985: 24403,
    15172003: 24404,
    15172249: 24405,
    15172242: 24406,
    15172271: 24407,
    15172529: 24408,
    15172268: 24409,
    15172280: 24410,
    15172275: 24411,
    15172270: 24412,
    15172511: 24413,
    15172491: 24414,
    15172509: 24415,
    15172505: 24416,
    15172745: 24417,
    15172541: 24418,
    15172764: 24419,
    15172761: 24420,
    15173029: 24421,
    15173013: 24422,
    15173256: 24423,
    15173030: 24424,
    15173026: 24425,
    15173004: 24426,
    15173014: 24427,
    15173036: 24428,
    15173263: 24429,
    15173563: 24430,
    15173252: 24431,
    15173269: 24432,
    15173288: 24433,
    15173292: 24434,
    15173527: 24435,
    15173305: 24436,
    15173310: 24437,
    15173522: 24438,
    15173513: 24439,
    15173524: 24440,
    15173518: 24441,
    15173536: 24442,
    15173548: 24443,
    15173543: 24444,
    15173557: 24445,
    15173564: 24446,
    15173561: 24609,
    15173567: 24610,
    15173773: 24611,
    15173776: 24612,
    15173787: 24613,
    15173800: 24614,
    15173805: 24615,
    15173804: 24616,
    15173808: 24617,
    15173810: 24618,
    15173819: 24619,
    15173820: 24620,
    15173823: 24621,
    15174016: 24622,
    15174022: 24623,
    15174027: 24624,
    15174040: 24625,
    15174068: 24626,
    15174078: 24627,
    15174274: 24628,
    15174273: 24629,
    15174279: 24630,
    15174290: 24631,
    15174294: 24632,
    15174306: 24633,
    15174311: 24634,
    15174329: 24635,
    15174322: 24636,
    15174531: 24637,
    15174534: 24638,
    15174532: 24639,
    15174542: 24640,
    15174546: 24641,
    15174562: 24642,
    15174560: 24643,
    15174561: 24644,
    15174585: 24645,
    15174583: 24646,
    15040655: 24647,
    15174807: 24648,
    15174794: 24649,
    15174812: 24650,
    15174806: 24651,
    15174813: 24652,
    15174836: 24653,
    15174831: 24654,
    15174825: 24655,
    15174821: 24656,
    15174846: 24657,
    15175054: 24658,
    15175055: 24659,
    15317912: 24660,
    15175063: 24661,
    15175082: 24662,
    15175080: 24663,
    15175088: 24664,
    15175096: 24665,
    15175093: 24666,
    15175099: 24667,
    15175098: 24668,
    15175560: 24669,
    15175347: 24670,
    15175566: 24671,
    15175355: 24672,
    15175552: 24673,
    15175589: 24674,
    15175598: 24675,
    15175582: 24676,
    15176354: 24677,
    15175813: 24678,
    15176111: 24679,
    15175845: 24680,
    15175608: 24681,
    15175858: 24682,
    15175866: 24683,
    15176085: 24684,
    15175871: 24685,
    15176095: 24686,
    15176089: 24687,
    15176065: 24688,
    15176092: 24689,
    15176105: 24690,
    15176112: 24691,
    15176099: 24692,
    15176106: 24693,
    15176118: 24694,
    15176126: 24695,
    15176331: 24696,
    15176350: 24697,
    15176359: 24698,
    15176586: 24699,
    15176591: 24700,
    15176596: 24701,
    15175601: 24702,
    15176608: 24865,
    15176611: 24866,
    15176615: 24867,
    15176617: 24868,
    15176622: 24869,
    15176626: 24870,
    15176624: 24871,
    15176625: 24872,
    15176632: 24873,
    15176631: 24874,
    15176836: 24875,
    15176835: 24876,
    15176837: 24877,
    15176844: 24878,
    15176846: 24879,
    15176845: 24880,
    15176853: 24881,
    15176851: 24882,
    15176862: 24883,
    15176870: 24884,
    15176876: 24885,
    15176892: 24886,
    15177092: 24887,
    15177101: 24888,
    15177098: 24889,
    15177097: 24890,
    15177115: 24891,
    15177094: 24892,
    15177114: 24893,
    15177129: 24894,
    15177124: 24895,
    15177127: 24896,
    15177131: 24897,
    15177133: 24898,
    15177144: 24899,
    15177142: 24900,
    15177350: 24901,
    15177351: 24902,
    15177140: 24903,
    15177354: 24904,
    15177353: 24905,
    15177346: 24906,
    15177364: 24907,
    15177370: 24908,
    15177373: 24909,
    15177381: 24910,
    15177379: 24911,
    15177602: 24912,
    15177395: 24913,
    15177603: 24914,
    15177397: 24915,
    15177405: 24916,
    15177400: 24917,
    15177404: 24918,
    15177393: 24919,
    15177613: 24920,
    15177610: 24921,
    15177618: 24922,
    15177625: 24923,
    15177635: 24924,
    15177630: 24925,
    15177662: 24926,
    15177663: 24927,
    15177660: 24928,
    15177857: 24929,
    15177648: 24930,
    15177658: 24931,
    15177650: 24932,
    15177651: 24933,
    15177867: 24934,
    15177869: 24935,
    15177865: 24936,
    15177887: 24937,
    15177895: 24938,
    15177888: 24939,
    15177889: 24940,
    15177890: 24941,
    15177892: 24942,
    15177908: 24943,
    15177904: 24944,
    15177915: 24945,
    15178119: 24946,
    15178120: 24947,
    15178118: 24948,
    15178140: 24949,
    15178136: 24950,
    15178145: 24951,
    15178146: 24952,
    15178152: 24953,
    15178153: 24954,
    15178154: 24955,
    15178151: 24956,
    15178156: 24957,
    15178160: 24958,
    15178162: 25121,
    15178166: 25122,
    15178168: 25123,
    15178172: 25124,
    15178368: 25125,
    15178371: 25126,
    15178376: 25127,
    15178379: 25128,
    15178382: 25129,
    15178390: 25130,
    15178387: 25131,
    15178393: 25132,
    15178394: 25133,
    15178416: 25134,
    15178420: 25135,
    15178424: 25136,
    15178425: 25137,
    15178426: 25138,
    15178626: 25139,
    15178637: 25140,
    15178646: 25141,
    15178642: 25142,
    15178654: 25143,
    15178657: 25144,
    15178661: 25145,
    15178663: 25146,
    15178666: 25147,
    15243439: 25148,
    15178683: 25149,
    15178888: 25150,
    15178887: 25151,
    15178884: 25152,
    15178921: 25153,
    15178916: 25154,
    15178910: 25155,
    15178917: 25156,
    15178918: 25157,
    15178907: 25158,
    15178935: 25159,
    15178936: 25160,
    15179143: 25161,
    15179162: 25162,
    15179176: 25163,
    15179179: 25164,
    15179163: 25165,
    15179173: 25166,
    15179199: 25167,
    15179198: 25168,
    15179193: 25169,
    15179406: 25170,
    15179403: 25171,
    15179409: 25172,
    15179424: 25173,
    15179422: 25174,
    15179440: 25175,
    15179446: 25176,
    15179449: 25177,
    15179455: 25178,
    15179452: 25179,
    15179453: 25180,
    15179451: 25181,
    15179655: 25182,
    15179661: 25183,
    15179671: 25184,
    15179674: 25185,
    15179676: 25186,
    15179683: 25187,
    15179694: 25188,
    15179708: 25189,
    15179916: 25190,
    15179922: 25191,
    15180966: 25192,
    15179936: 25193,
    15180970: 25194,
    15180165: 25195,
    15180430: 25196,
    15180212: 25197,
    15180422: 25198,
    15180220: 25199,
    15180442: 25200,
    15180428: 25201,
    15180451: 25202,
    15180469: 25203,
    15180458: 25204,
    15180463: 25205,
    15180689: 25206,
    15180678: 25207,
    15180683: 25208,
    15180692: 25209,
    15180478: 25210,
    15180476: 25211,
    15180677: 25212,
    15180682: 25213,
    15180716: 25214,
    15180711: 25377,
    15180698: 25378,
    15180733: 25379,
    15180724: 25380,
    15180935: 25381,
    15180946: 25382,
    15180945: 25383,
    15180953: 25384,
    15180972: 25385,
    15180971: 25386,
    15181184: 25387,
    15181216: 25388,
    15181207: 25389,
    15181215: 25390,
    15181210: 25391,
    15181205: 25392,
    15181203: 25393,
    15181242: 25394,
    15181247: 25395,
    15181450: 25396,
    15181469: 25397,
    15181479: 25398,
    15318411: 25399,
    15181482: 25400,
    15181486: 25401,
    15181491: 25402,
    15181497: 25403,
    15181498: 25404,
    15181705: 25405,
    15181717: 25406,
    15181735: 25407,
    15181740: 25408,
    15181729: 25409,
    15181731: 25410,
    15181960: 25411,
    15181965: 25412,
    15181976: 25413,
    15181977: 25414,
    15181984: 25415,
    15181983: 25416,
    15181440: 25417,
    15182001: 25418,
    15182011: 25419,
    15182014: 25420,
    15182007: 25421,
    15182211: 25422,
    15182231: 25423,
    15182217: 25424,
    15182241: 25425,
    15182242: 25426,
    15182249: 25427,
    15318685: 25428,
    15182256: 25429,
    15182265: 25430,
    15182269: 25431,
    15182472: 25432,
    15182487: 25433,
    15182485: 25434,
    15182488: 25435,
    15182486: 25436,
    15182505: 25437,
    15182728: 25438,
    15182512: 25439,
    15182518: 25440,
    15182725: 25441,
    15182724: 25442,
    15182527: 25443,
    15303299: 25444,
    15182727: 25445,
    15182730: 25446,
    15182733: 25447,
    15182735: 25448,
    15182741: 25449,
    15182739: 25450,
    15182745: 25451,
    15182746: 25452,
    15182749: 25453,
    15182753: 25454,
    15182754: 25455,
    15182758: 25456,
    15182765: 25457,
    15182768: 25458,
    15182978: 25459,
    15182991: 25460,
    15182986: 25461,
    15182982: 25462,
    15183027: 25463,
    15183e3: 25464,
    15183001: 25465,
    15183006: 25466,
    15183029: 25467,
    15183016: 25468,
    15183030: 25469,
    15183248: 25470,
    15183290: 25633,
    15182980: 25634,
    15183245: 25635,
    15182987: 25636,
    15183244: 25637,
    15183237: 25638,
    15183285: 25639,
    15183269: 25640,
    15183284: 25641,
    15183271: 25642,
    15183280: 25643,
    15183281: 25644,
    15183276: 25645,
    15183278: 25646,
    15183517: 25647,
    15183512: 25648,
    15183519: 25649,
    15183501: 25650,
    15183516: 25651,
    15183514: 25652,
    15183499: 25653,
    15183506: 25654,
    15183503: 25655,
    15183261: 25656,
    15183513: 25657,
    15183755: 25658,
    15183745: 25659,
    15183756: 25660,
    15183759: 25661,
    15183540: 25662,
    15183750: 25663,
    15183773: 25664,
    15183785: 25665,
    15184017: 25666,
    15184020: 25667,
    15183782: 25668,
    15183781: 25669,
    15184288: 25670,
    15184e3: 25671,
    15184007: 25672,
    15184019: 25673,
    15183795: 25674,
    15183799: 25675,
    15184023: 25676,
    15184013: 25677,
    15183798: 25678,
    15184035: 25679,
    15184039: 25680,
    15184042: 25681,
    15184031: 25682,
    15184055: 25683,
    15184043: 25684,
    15184061: 25685,
    15184268: 25686,
    15184259: 25687,
    15184276: 25688,
    15184271: 25689,
    15184256: 25690,
    15184272: 25691,
    15184280: 25692,
    15184287: 25693,
    15184292: 25694,
    15184278: 25695,
    15184293: 25696,
    15184300: 25697,
    15184309: 25698,
    15184515: 25699,
    15184528: 25700,
    15184548: 25701,
    15184557: 25702,
    15184546: 25703,
    15184555: 25704,
    15184545: 25705,
    15184552: 25706,
    15184563: 25707,
    15184562: 25708,
    15184561: 25709,
    15184558: 25710,
    15184569: 25711,
    15184573: 25712,
    15184768: 25713,
    15184773: 25714,
    15184770: 25715,
    15184792: 25716,
    15184786: 25717,
    15184796: 25718,
    15184802: 25719,
    15314107: 25720,
    15184815: 25721,
    15184818: 25722,
    15184820: 25723,
    15184822: 25724,
    15184826: 25725,
    15185030: 25726,
    15185026: 25889,
    15185052: 25890,
    15185045: 25891,
    15185034: 25892,
    15185285: 25893,
    15185291: 25894,
    15185070: 25895,
    15185074: 25896,
    15185087: 25897,
    15185077: 25898,
    15185286: 25899,
    15185331: 25900,
    15185302: 25901,
    15185294: 25902,
    15185330: 25903,
    15185320: 25904,
    15185326: 25905,
    15185295: 25906,
    15185315: 25907,
    15185555: 25908,
    15185545: 25909,
    15185307: 25910,
    15185551: 25911,
    15185341: 25912,
    15185563: 25913,
    15185594: 25914,
    15185582: 25915,
    15185571: 25916,
    15185589: 25917,
    15185799: 25918,
    15185597: 25919,
    15185579: 25920,
    15186109: 25921,
    15185570: 25922,
    15185583: 25923,
    15185820: 25924,
    15185592: 25925,
    15185567: 25926,
    15185584: 25927,
    15185816: 25928,
    15185821: 25929,
    15185828: 25930,
    15185822: 25931,
    15185851: 25932,
    15185842: 25933,
    15185825: 25934,
    15186053: 25935,
    15186058: 25936,
    15186083: 25937,
    15186081: 25938,
    15186066: 25939,
    15186097: 25940,
    15186079: 25941,
    15186057: 25942,
    15186059: 25943,
    15186082: 25944,
    15186310: 25945,
    15186342: 25946,
    15186107: 25947,
    15186101: 25948,
    15186105: 25949,
    15186307: 25950,
    15186103: 25951,
    15186098: 25952,
    15186106: 25953,
    15186343: 25954,
    15186333: 25955,
    15186326: 25956,
    15186334: 25957,
    15186329: 25958,
    15186330: 25959,
    15186361: 25960,
    15186346: 25961,
    15186345: 25962,
    15186364: 25963,
    15186363: 25964,
    15186563: 25965,
    15185813: 25966,
    15186365: 25967,
    15253166: 25968,
    15186367: 25969,
    15186568: 25970,
    15186569: 25971,
    15186572: 25972,
    15186578: 25973,
    15186576: 25974,
    15186579: 25975,
    15186580: 25976,
    15186582: 25977,
    15186574: 25978,
    15186587: 25979,
    15186588: 25980,
    15187128: 25981,
    15187130: 25982,
    15187333: 26145,
    15187340: 26146,
    15187341: 26147,
    15187342: 26148,
    15187344: 26149,
    15187345: 26150,
    15187349: 26151,
    15187348: 26152,
    15187352: 26153,
    15187359: 26154,
    15187360: 26155,
    15187368: 26156,
    15187369: 26157,
    15187367: 26158,
    15187384: 26159,
    15187586: 26160,
    15187590: 26161,
    15187587: 26162,
    15187592: 26163,
    15187591: 26164,
    15187596: 26165,
    15187604: 26166,
    15187614: 26167,
    15187613: 26168,
    15187610: 26169,
    15187619: 26170,
    15187631: 26171,
    15187634: 26172,
    15187641: 26173,
    15187630: 26174,
    15187638: 26175,
    15187640: 26176,
    15248817: 26177,
    15187845: 26178,
    15187846: 26179,
    15187850: 26180,
    15187861: 26181,
    15187860: 26182,
    15187873: 26183,
    15187878: 26184,
    15187881: 26185,
    15187891: 26186,
    15187897: 26187,
    15311772: 26188,
    15237254: 26189,
    15237252: 26190,
    15237259: 26191,
    15237266: 26192,
    15237272: 26193,
    15237273: 26194,
    15237276: 26195,
    15237281: 26196,
    15237288: 26197,
    15237311: 26198,
    15237307: 26199,
    15237514: 26200,
    15237510: 26201,
    15237522: 26202,
    15237528: 26203,
    15237530: 26204,
    15237535: 26205,
    15237538: 26206,
    15237544: 26207,
    15237555: 26208,
    15237554: 26209,
    15237552: 26210,
    15237558: 26211,
    15237561: 26212,
    15237565: 26213,
    15237567: 26214,
    15237764: 26215,
    15237766: 26216,
    15237765: 26217,
    15237787: 26218,
    15237779: 26219,
    15237786: 26220,
    15237805: 26221,
    15042192: 26222,
    15237804: 26223,
    15238043: 26224,
    15238053: 26225,
    15238041: 26226,
    15238045: 26227,
    15238020: 26228,
    15238042: 26229,
    15238038: 26230,
    15238281: 26231,
    15238063: 26232,
    15238065: 26233,
    15238299: 26234,
    15238313: 26235,
    15238307: 26236,
    15238319: 26237,
    15238539: 26238,
    15309451: 26401,
    15238534: 26402,
    15238334: 26403,
    15238547: 26404,
    15238545: 26405,
    15238076: 26406,
    15238577: 26407,
    15238574: 26408,
    15238565: 26409,
    15238566: 26410,
    15238580: 26411,
    15238787: 26412,
    15238792: 26413,
    15238794: 26414,
    15238784: 26415,
    15238786: 26416,
    15238816: 26417,
    15238805: 26418,
    15238820: 26419,
    15238819: 26420,
    15238559: 26421,
    15238803: 26422,
    15238825: 26423,
    15238832: 26424,
    15238837: 26425,
    15238846: 26426,
    15238840: 26427,
    15238845: 26428,
    15239040: 26429,
    15239042: 26430,
    15238842: 26431,
    15239049: 26432,
    15239053: 26433,
    15239057: 26434,
    15239065: 26435,
    15239064: 26436,
    15239048: 26437,
    15239066: 26438,
    15239071: 26439,
    15239072: 26440,
    15239079: 26441,
    15239098: 26442,
    15239099: 26443,
    15239102: 26444,
    15239297: 26445,
    15239298: 26446,
    15239301: 26447,
    15239303: 26448,
    15239306: 26449,
    15239309: 26450,
    15239312: 26451,
    15239318: 26452,
    15239337: 26453,
    15239339: 26454,
    15239352: 26455,
    15239347: 26456,
    15239552: 26457,
    15239577: 26458,
    15239576: 26459,
    15239581: 26460,
    15239578: 26461,
    15239583: 26462,
    15239588: 26463,
    15239586: 26464,
    15239592: 26465,
    15239594: 26466,
    15239595: 26467,
    15239342: 26468,
    15239601: 26469,
    15239607: 26470,
    15239608: 26471,
    15239614: 26472,
    15239821: 26473,
    15239826: 26474,
    15239851: 26475,
    15239839: 26476,
    15239867: 26477,
    15239852: 26478,
    15240097: 26479,
    15240099: 26480,
    15240095: 26481,
    15240082: 26482,
    15240116: 26483,
    15240115: 26484,
    15240122: 26485,
    15240851: 26486,
    15240323: 26487,
    15240123: 26488,
    15240121: 26489,
    15240094: 26490,
    15240326: 26491,
    15240092: 26492,
    15240329: 26493,
    15240089: 26494,
    15240373: 26657,
    15240372: 26658,
    15240342: 26659,
    15240370: 26660,
    15240369: 26661,
    15240576: 26662,
    15240377: 26663,
    15240592: 26664,
    15240581: 26665,
    15240367: 26666,
    15240363: 26667,
    15240343: 26668,
    15240344: 26669,
    15240837: 26670,
    15240858: 26671,
    15240874: 26672,
    15240863: 26673,
    15240866: 26674,
    15240854: 26675,
    15240355: 26676,
    15240846: 26677,
    15240839: 26678,
    15240842: 26679,
    15240636: 26680,
    15240885: 26681,
    15240627: 26682,
    15240629: 26683,
    15240864: 26684,
    15240841: 26685,
    15240872: 26686,
    15241140: 26687,
    15241363: 26688,
    15241131: 26689,
    15241102: 26690,
    15241149: 26691,
    15241347: 26692,
    15241112: 26693,
    15241355: 26694,
    15241089: 26695,
    15241143: 26696,
    15241351: 26697,
    15241120: 26698,
    15241138: 26699,
    15241357: 26700,
    15241378: 26701,
    15241376: 26702,
    15240893: 26703,
    15241400: 26704,
    15242374: 26705,
    15241147: 26706,
    15241645: 26707,
    15241386: 26708,
    15241404: 26709,
    15242650: 26710,
    15241860: 26711,
    15241655: 26712,
    15241643: 26713,
    15241901: 26714,
    15241646: 26715,
    15241858: 26716,
    15241641: 26717,
    15241606: 26718,
    15241388: 26719,
    15241647: 26720,
    15241657: 26721,
    15241397: 26722,
    15242122: 26723,
    15241634: 26724,
    15241913: 26725,
    15241919: 26726,
    15241887: 26727,
    15242137: 26728,
    15242125: 26729,
    15241915: 26730,
    15242138: 26731,
    15242128: 26732,
    15242113: 26733,
    15242118: 26734,
    15242134: 26735,
    15241889: 26736,
    15242401: 26737,
    15242175: 26738,
    15242164: 26739,
    15242391: 26740,
    15242392: 26741,
    15242412: 26742,
    15242399: 26743,
    15242389: 26744,
    15242388: 26745,
    15242172: 26746,
    15242624: 26747,
    15242659: 26748,
    15242648: 26749,
    15242632: 26750,
    15242625: 26913,
    15243394: 26914,
    15242635: 26915,
    15242645: 26916,
    15242880: 26917,
    15242916: 26918,
    15242888: 26919,
    15242897: 26920,
    15242890: 26921,
    15242920: 26922,
    15242669: 26923,
    15242900: 26924,
    15242907: 26925,
    15243178: 26926,
    15242887: 26927,
    15242908: 26928,
    15242679: 26929,
    15242686: 26930,
    15242896: 26931,
    15243145: 26932,
    15242938: 26933,
    15243151: 26934,
    15242937: 26935,
    15243152: 26936,
    15243157: 26937,
    15243165: 26938,
    15243173: 26939,
    15243164: 26940,
    15243193: 26941,
    15243402: 26942,
    15243411: 26943,
    15243403: 26944,
    15243198: 26945,
    15243194: 26946,
    15243398: 26947,
    15243426: 26948,
    15243418: 26949,
    15243440: 26950,
    15243455: 26951,
    15243661: 26952,
    14989717: 26953,
    15243668: 26954,
    15243679: 26955,
    15243687: 26956,
    15243697: 26957,
    15243923: 26958,
    15243939: 26959,
    15243945: 26960,
    15243946: 26961,
    15243915: 26962,
    15243916: 26963,
    15243958: 26964,
    15243951: 26965,
    15244164: 26966,
    15244166: 26967,
    15243952: 26968,
    15244169: 26969,
    15245475: 26970,
    15243947: 26971,
    15244180: 26972,
    15244190: 26973,
    15244201: 26974,
    15244204: 26975,
    15244191: 26976,
    15244187: 26977,
    15244207: 26978,
    15244434: 26979,
    15244422: 26980,
    15244424: 26981,
    15244416: 26982,
    15244419: 26983,
    15244219: 26984,
    15244433: 26985,
    15244425: 26986,
    15244429: 26987,
    15244217: 26988,
    15244426: 26989,
    15244468: 26990,
    15244479: 26991,
    15244471: 26992,
    15244475: 26993,
    15244453: 26994,
    15244457: 26995,
    15244442: 26996,
    15244704: 26997,
    15244703: 26998,
    15244728: 26999,
    15244684: 27e3,
    15244686: 27001,
    15244724: 27002,
    15244695: 27003,
    15244712: 27004,
    15244718: 27005,
    15244697: 27006,
    15244691: 27169,
    15244707: 27170,
    15244714: 27171,
    15245445: 27172,
    15244962: 27173,
    15244959: 27174,
    15244930: 27175,
    15244975: 27176,
    15245195: 27177,
    15244989: 27178,
    15245184: 27179,
    15245200: 27180,
    15309718: 27181,
    15244971: 27182,
    15245188: 27183,
    15244979: 27184,
    15245191: 27185,
    15245190: 27186,
    15244987: 27187,
    15245231: 27188,
    15245234: 27189,
    15245216: 27190,
    15245455: 27191,
    15245453: 27192,
    15245246: 27193,
    15245238: 27194,
    15245239: 27195,
    15245454: 27196,
    15245202: 27197,
    15245457: 27198,
    15245462: 27199,
    15245461: 27200,
    15245474: 27201,
    15245473: 27202,
    15245489: 27203,
    15245494: 27204,
    15245497: 27205,
    15245479: 27206,
    15245499: 27207,
    15245700: 27208,
    15245698: 27209,
    15245714: 27210,
    15245721: 27211,
    15245726: 27212,
    15245730: 27213,
    15245739: 27214,
    15245953: 27215,
    15245758: 27216,
    15245982: 27217,
    15245749: 27218,
    15245757: 27219,
    15246005: 27220,
    15245746: 27221,
    15245954: 27222,
    15245975: 27223,
    15245970: 27224,
    15245998: 27225,
    15245977: 27226,
    15245986: 27227,
    15245965: 27228,
    15245988: 27229,
    15246e3: 27230,
    15246015: 27231,
    15246001: 27232,
    15246211: 27233,
    15246212: 27234,
    15246228: 27235,
    15246232: 27236,
    15246233: 27237,
    15246237: 27238,
    15246265: 27239,
    15246466: 27240,
    15246268: 27241,
    15246260: 27242,
    15246248: 27243,
    15246258: 27244,
    15246468: 27245,
    15246476: 27246,
    15246474: 27247,
    15246483: 27248,
    15246723: 27249,
    15246494: 27250,
    15246501: 27251,
    15246506: 27252,
    15246507: 27253,
    15246721: 27254,
    15246724: 27255,
    15246523: 27256,
    15246518: 27257,
    15246520: 27258,
    15246732: 27259,
    15246493: 27260,
    15246752: 27261,
    15246750: 27262,
    15246758: 27425,
    15246756: 27426,
    15246765: 27427,
    15246762: 27428,
    15246767: 27429,
    15246772: 27430,
    15246775: 27431,
    15246782: 27432,
    15246979: 27433,
    15246984: 27434,
    15246986: 27435,
    15246995: 27436,
    15247e3: 27437,
    15247009: 27438,
    15247017: 27439,
    15247014: 27440,
    15247020: 27441,
    15247023: 27442,
    15247026: 27443,
    15247034: 27444,
    15247037: 27445,
    15247039: 27446,
    15247232: 27447,
    15247258: 27448,
    15247260: 27449,
    15247261: 27450,
    15247271: 27451,
    15247284: 27452,
    15247288: 27453,
    15247491: 27454,
    15247510: 27455,
    15247504: 27456,
    15247500: 27457,
    15247515: 27458,
    15247517: 27459,
    15247525: 27460,
    15247542: 27461,
    15247745: 27462,
    15247771: 27463,
    15247762: 27464,
    15247750: 27465,
    15247752: 27466,
    15247804: 27467,
    15247789: 27468,
    15247788: 27469,
    15247778: 27470,
    15248005: 27471,
    15248002: 27472,
    15248004: 27473,
    15248040: 27474,
    15248033: 27475,
    15248017: 27476,
    15248037: 27477,
    15248038: 27478,
    15248026: 27479,
    15248035: 27480,
    15248260: 27481,
    15248269: 27482,
    15248258: 27483,
    15248282: 27484,
    15248299: 27485,
    15248307: 27486,
    15248295: 27487,
    15248292: 27488,
    15248305: 27489,
    15248532: 27490,
    15248288: 27491,
    15248290: 27492,
    15248311: 27493,
    15248286: 27494,
    15248283: 27495,
    15248524: 27496,
    15248519: 27497,
    15248538: 27498,
    15248289: 27499,
    15248534: 27500,
    15248528: 27501,
    15248535: 27502,
    15248544: 27503,
    15248563: 27504,
    15310507: 27505,
    15248550: 27506,
    15248555: 27507,
    15248574: 27508,
    15248552: 27509,
    15248769: 27510,
    15248780: 27511,
    15248783: 27512,
    15248782: 27513,
    15248777: 27514,
    15248790: 27515,
    15248795: 27516,
    15248794: 27517,
    15248811: 27518,
    15248799: 27681,
    15248812: 27682,
    15248815: 27683,
    15248820: 27684,
    15248829: 27685,
    15249024: 27686,
    15249036: 27687,
    15249038: 27688,
    15249042: 27689,
    15249043: 27690,
    15249046: 27691,
    15249049: 27692,
    15249050: 27693,
    15249594: 27694,
    15249793: 27695,
    15249599: 27696,
    15249800: 27697,
    15249804: 27698,
    15249806: 27699,
    15249808: 27700,
    15249813: 27701,
    15249826: 27702,
    15249836: 27703,
    15249848: 27704,
    15249850: 27705,
    15250050: 27706,
    15250057: 27707,
    15250053: 27708,
    15250058: 27709,
    15250061: 27710,
    15250062: 27711,
    15250068: 27712,
    15249852: 27713,
    15250072: 27714,
    15108253: 27715,
    15250093: 27716,
    15250090: 27717,
    15250109: 27718,
    15250098: 27719,
    15250099: 27720,
    15250094: 27721,
    15250102: 27722,
    15250312: 27723,
    15250305: 27724,
    15250340: 27725,
    15250339: 27726,
    15250330: 27727,
    15250365: 27728,
    15250362: 27729,
    15250363: 27730,
    15250564: 27731,
    15250565: 27732,
    15250570: 27733,
    15250567: 27734,
    15250575: 27735,
    15250573: 27736,
    15250576: 27737,
    15318414: 27738,
    15250579: 27739,
    15250317: 27740,
    15250580: 27741,
    15250582: 27742,
    15250855: 27743,
    15250861: 27744,
    15250865: 27745,
    15250867: 27746,
    15251073: 27747,
    15251097: 27748,
    15251330: 27749,
    15251134: 27750,
    15251130: 27751,
    15251343: 27752,
    15251354: 27753,
    15251350: 27754,
    15251340: 27755,
    15251355: 27756,
    15251339: 27757,
    15251370: 27758,
    15251371: 27759,
    15251359: 27760,
    15251363: 27761,
    15251388: 27762,
    15251592: 27763,
    15251593: 27764,
    15251391: 27765,
    15251613: 27766,
    15251614: 27767,
    15251600: 27768,
    15251615: 27769,
    15251842: 27770,
    15251637: 27771,
    15251632: 27772,
    15251636: 27773,
    15251850: 27774,
    15251847: 27937,
    15251849: 27938,
    15251852: 27939,
    15251856: 27940,
    15251848: 27941,
    15251865: 27942,
    15251876: 27943,
    15251872: 27944,
    15251626: 27945,
    15251875: 27946,
    15251861: 27947,
    15251894: 27948,
    15251890: 27949,
    15251900: 27950,
    15252097: 27951,
    15252103: 27952,
    15252101: 27953,
    15252100: 27954,
    15252107: 27955,
    15252106: 27956,
    15252115: 27957,
    15252113: 27958,
    15252116: 27959,
    15252121: 27960,
    15252138: 27961,
    15252129: 27962,
    15252140: 27963,
    15252144: 27964,
    15252358: 27965,
    15252145: 27966,
    15252158: 27967,
    15252357: 27968,
    15252360: 27969,
    15252363: 27970,
    15252379: 27971,
    15252387: 27972,
    15252412: 27973,
    15252411: 27974,
    15252395: 27975,
    15252414: 27976,
    15252618: 27977,
    15252613: 27978,
    15252629: 27979,
    15252626: 27980,
    15252633: 27981,
    15252627: 27982,
    15252636: 27983,
    15252639: 27984,
    15252635: 27985,
    15252620: 27986,
    15252646: 27987,
    15252659: 27988,
    15252667: 27989,
    15252665: 27990,
    15252869: 27991,
    15252866: 27992,
    15252670: 27993,
    15252876: 27994,
    15252873: 27995,
    15252870: 27996,
    15252878: 27997,
    15252887: 27998,
    15252892: 27999,
    15252898: 28e3,
    15252899: 28001,
    15252900: 28002,
    15253148: 28003,
    15253151: 28004,
    15253155: 28005,
    15253165: 28006,
    15253167: 28007,
    15253175: 28008,
    15253402: 28009,
    15253413: 28010,
    15253410: 28011,
    15253418: 28012,
    15253423: 28013,
    15303303: 28014,
    15253428: 28015,
    15302789: 28016,
    15253433: 28017,
    15253434: 28018,
    15302801: 28019,
    15302805: 28020,
    15302817: 28021,
    15302797: 28022,
    15302814: 28023,
    15302806: 28024,
    15302795: 28025,
    15302823: 28026,
    15302838: 28027,
    15302837: 28028,
    15302841: 28029,
    15253432: 28030,
    15303055: 28193,
    15303056: 28194,
    15303057: 28195,
    15303058: 28196,
    15302798: 28197,
    15303049: 28198,
    15302846: 28199,
    15303062: 28200,
    15303064: 28201,
    15303070: 28202,
    15303080: 28203,
    15303087: 28204,
    15303094: 28205,
    15309480: 28206,
    15303090: 28207,
    15303298: 28208,
    15303101: 28209,
    15303297: 28210,
    15303296: 28211,
    15303306: 28212,
    15303305: 28213,
    15303311: 28214,
    15303336: 28215,
    15303343: 28216,
    15303345: 28217,
    15303349: 28218,
    15303586: 28219,
    15303588: 28220,
    15108488: 28221,
    15303579: 28222,
    15303810: 28223,
    15303826: 28224,
    15303833: 28225,
    15303858: 28226,
    15303856: 28227,
    15304074: 28228,
    15304086: 28229,
    15304088: 28230,
    15304099: 28231,
    15304101: 28232,
    15304105: 28233,
    15304115: 28234,
    15304114: 28235,
    15304331: 28236,
    15304329: 28237,
    15304322: 28238,
    15304354: 28239,
    15304363: 28240,
    15304367: 28241,
    15304362: 28242,
    15304373: 28243,
    15304372: 28244,
    15304378: 28245,
    15304576: 28246,
    15304577: 28247,
    15304585: 28248,
    15304587: 28249,
    15304592: 28250,
    15304598: 28251,
    15304607: 28252,
    15304609: 28253,
    15304603: 28254,
    15304636: 28255,
    15304629: 28256,
    15304630: 28257,
    15304862: 28258,
    15304639: 28259,
    15304852: 28260,
    15304876: 28261,
    15304853: 28262,
    15304849: 28263,
    15305118: 28264,
    15305111: 28265,
    15305093: 28266,
    15305097: 28267,
    15305124: 28268,
    15305096: 28269,
    15305365: 28270,
    15304895: 28271,
    15305099: 28272,
    15305104: 28273,
    15305372: 28274,
    15305366: 28275,
    15305363: 28276,
    15305371: 28277,
    15305114: 28278,
    15305615: 28279,
    15305401: 28280,
    15305399: 28281,
    15305641: 28282,
    15305871: 28283,
    15305658: 28284,
    15306116: 28285,
    15305902: 28286,
    15305881: 28449,
    15305890: 28450,
    15305882: 28451,
    15305891: 28452,
    15305914: 28453,
    15305909: 28454,
    15305915: 28455,
    15306140: 28456,
    15306144: 28457,
    15306172: 28458,
    15306158: 28459,
    15306134: 28460,
    15306416: 28461,
    15306412: 28462,
    15306413: 28463,
    15306388: 28464,
    15306425: 28465,
    15306646: 28466,
    15306647: 28467,
    15306664: 28468,
    15306661: 28469,
    15306648: 28470,
    15306627: 28471,
    15306653: 28472,
    15306640: 28473,
    15306632: 28474,
    15306660: 28475,
    15306906: 28476,
    15306900: 28477,
    15306899: 28478,
    15306883: 28479,
    15306887: 28480,
    15306896: 28481,
    15306934: 28482,
    15306923: 28483,
    15306933: 28484,
    15306913: 28485,
    15306938: 28486,
    15307137: 28487,
    15307154: 28488,
    15307140: 28489,
    15307163: 28490,
    15307168: 28491,
    15307170: 28492,
    15307166: 28493,
    15307178: 28494,
    15304873: 28495,
    15307184: 28496,
    15307189: 28497,
    15307191: 28498,
    15307197: 28499,
    15307162: 28500,
    15307196: 28501,
    15307198: 28502,
    15307393: 28503,
    15307199: 28504,
    15308418: 28505,
    15308423: 28506,
    15308426: 28507,
    15308436: 28508,
    15308438: 28509,
    15308440: 28510,
    15308441: 28511,
    15308448: 28512,
    15308456: 28513,
    15308455: 28514,
    15308461: 28515,
    15308476: 28516,
    15308475: 28517,
    15308473: 28518,
    15308478: 28519,
    15308682: 28520,
    15122358: 28521,
    15308675: 28522,
    15308685: 28523,
    15308684: 28524,
    15308693: 28525,
    15308692: 28526,
    15308694: 28527,
    15308700: 28528,
    15308705: 28529,
    15308709: 28530,
    15308706: 28531,
    15308961: 28532,
    15308968: 28533,
    15308974: 28534,
    15308975: 28535,
    15309186: 28536,
    15309196: 28537,
    15309199: 28538,
    15309195: 28539,
    15309239: 28540,
    15309212: 28541,
    15309214: 28542,
    15309213: 28705,
    15309215: 28706,
    15309222: 28707,
    15309234: 28708,
    15309228: 28709,
    15309453: 28710,
    15309464: 28711,
    15309461: 28712,
    15309463: 28713,
    15309482: 28714,
    15309479: 28715,
    15309489: 28716,
    15309490: 28717,
    15309488: 28718,
    15309492: 28719,
    15309494: 28720,
    15309496: 28721,
    15309497: 28722,
    15309710: 28723,
    15309707: 28724,
    15309705: 28725,
    15309709: 28726,
    15246733: 28727,
    15309724: 28728,
    15309965: 28729,
    15309717: 28730,
    15309753: 28731,
    15309956: 28732,
    15309958: 28733,
    15309960: 28734,
    15309971: 28735,
    15309966: 28736,
    15309969: 28737,
    15309967: 28738,
    15309974: 28739,
    15309977: 28740,
    15309988: 28741,
    15309994: 28742,
    1531e4: 28743,
    15310009: 28744,
    15310013: 28745,
    15310014: 28746,
    15310212: 28747,
    15310214: 28748,
    15310216: 28749,
    15310210: 28750,
    15310217: 28751,
    15310236: 28752,
    15310240: 28753,
    15310244: 28754,
    15310246: 28755,
    15310248: 28756,
    15043474: 28757,
    15310251: 28758,
    15310257: 28759,
    15310265: 28760,
    15310469: 28761,
    15310268: 28762,
    15310465: 28763,
    15310266: 28764,
    15310470: 28765,
    15310475: 28766,
    15310479: 28767,
    15310480: 28768,
    15310492: 28769,
    15310504: 28770,
    15310502: 28771,
    15310499: 28772,
    15310515: 28773,
    15310516: 28774,
    15310723: 28775,
    15310726: 28776,
    15310728: 28777,
    15310731: 28778,
    15310748: 28779,
    15310765: 28780,
    15318415: 28781,
    15310770: 28782,
    15182751: 28783,
    15310774: 28784,
    15310773: 28785,
    15310991: 28786,
    15310988: 28787,
    15311032: 28788,
    15311012: 28789,
    15311009: 28790,
    15311031: 28791,
    15311037: 28792,
    15311238: 28793,
    15311247: 28794,
    15311243: 28795,
    15311275: 28796,
    15311279: 28797,
    15311280: 28798,
    15311281: 28961,
    15311284: 28962,
    15311283: 28963,
    15311530: 28964,
    15311535: 28965,
    15311537: 28966,
    15311542: 28967,
    15311748: 28968,
    15311747: 28969,
    15311750: 28970,
    15311785: 28971,
    15311787: 28972,
    15312003: 28973,
    15312009: 28974,
    15312018: 28975,
    15312020: 28976,
    15312024: 28977,
    15312033: 28978,
    15312029: 28979,
    15312030: 28980,
    15312036: 28981,
    15312032: 28982,
    15312044: 28983,
    15312046: 28984,
    15312061: 28985,
    15312062: 28986,
    15312258: 28987,
    15312265: 28988,
    15312261: 28989,
    15312272: 28990,
    15312267: 28991,
    15312273: 28992,
    15312274: 28993,
    15312268: 28994,
    15312277: 28995,
    15312535: 28996,
    15312536: 28997,
    15312549: 28998,
    15312557: 28999,
    15312558: 29e3,
    15312572: 29001,
    15312799: 29002,
    15312795: 29003,
    15312797: 29004,
    15312792: 29005,
    15312785: 29006,
    15312813: 29007,
    15312814: 29008,
    15312817: 29009,
    15312818: 29010,
    15312827: 29011,
    15312824: 29012,
    15313025: 29013,
    15313039: 29014,
    15313029: 29015,
    15312802: 29016,
    15313049: 29017,
    15313067: 29018,
    15313079: 29019,
    15313285: 29020,
    15313282: 29021,
    15313280: 29022,
    15313283: 29023,
    15313086: 29024,
    15313301: 29025,
    15313293: 29026,
    15313307: 29027,
    15313303: 29028,
    15313311: 29029,
    15313314: 29030,
    15313317: 29031,
    15313316: 29032,
    15313321: 29033,
    15313323: 29034,
    15313322: 29035,
    15313581: 29036,
    15313584: 29037,
    15313596: 29038,
    15313792: 29039,
    15313807: 29040,
    15313809: 29041,
    15313811: 29042,
    15313812: 29043,
    15313822: 29044,
    15313823: 29045,
    15313826: 29046,
    15313827: 29047,
    15313830: 29048,
    15313839: 29049,
    15313835: 29050,
    15313838: 29051,
    15313844: 29052,
    15313841: 29053,
    15313847: 29054,
    15313851: 29217,
    15314054: 29218,
    15314072: 29219,
    15314074: 29220,
    15314079: 29221,
    15314082: 29222,
    15314083: 29223,
    15314085: 29224,
    15314087: 29225,
    15314088: 29226,
    15314089: 29227,
    15314090: 29228,
    15314094: 29229,
    15314095: 29230,
    15314098: 29231,
    15314308: 29232,
    15314307: 29233,
    15314319: 29234,
    15314317: 29235,
    15314318: 29236,
    15314321: 29237,
    15314328: 29238,
    15314356: 29239,
    15314579: 29240,
    15314563: 29241,
    15314577: 29242,
    15314582: 29243,
    15314583: 29244,
    15314591: 29245,
    15314592: 29246,
    15314600: 29247,
    15314612: 29248,
    15314816: 29249,
    15314826: 29250,
    15314617: 29251,
    15314822: 29252,
    15314831: 29253,
    15314833: 29254,
    15314834: 29255,
    15314851: 29256,
    15314850: 29257,
    15314852: 29258,
    15314836: 29259,
    15314849: 29260,
    15315130: 29261,
    15314866: 29262,
    15314865: 29263,
    15314864: 29264,
    15315093: 29265,
    15315092: 29266,
    15315081: 29267,
    15315091: 29268,
    15315084: 29269,
    15315078: 29270,
    15315080: 29271,
    15315090: 29272,
    15315082: 29273,
    15315076: 29274,
    15315118: 29275,
    15315099: 29276,
    15315109: 29277,
    15315108: 29278,
    15315105: 29279,
    15315120: 29280,
    15315335: 29281,
    15315122: 29282,
    15315334: 29283,
    15315134: 29284,
    15315354: 29285,
    15315360: 29286,
    15315367: 29287,
    15315382: 29288,
    15315384: 29289,
    15315879: 29290,
    15315884: 29291,
    15315888: 29292,
    15316105: 29293,
    15316104: 29294,
    15315883: 29295,
    15316099: 29296,
    15316102: 29297,
    15316138: 29298,
    15316134: 29299,
    15316655: 29300,
    15316131: 29301,
    15316127: 29302,
    15316356: 29303,
    15316117: 29304,
    15316114: 29305,
    15316353: 29306,
    15316159: 29307,
    15316158: 29308,
    15316358: 29309,
    15316360: 29310,
    15316381: 29473,
    15316382: 29474,
    15316388: 29475,
    15316369: 29476,
    15316368: 29477,
    15316377: 29478,
    15316402: 29479,
    15316617: 29480,
    15316615: 29481,
    15316651: 29482,
    15316399: 29483,
    15316410: 29484,
    15316634: 29485,
    15316644: 29486,
    15316649: 29487,
    15316658: 29488,
    15316868: 29489,
    15316865: 29490,
    15316667: 29491,
    15316664: 29492,
    15316666: 29493,
    15316870: 29494,
    15316879: 29495,
    15316866: 29496,
    15316889: 29497,
    15316883: 29498,
    15316920: 29499,
    15316902: 29500,
    15316909: 29501,
    15316911: 29502,
    15316925: 29503,
    15317146: 29504,
    15317147: 29505,
    15317150: 29506,
    15317429: 29507,
    15317433: 29508,
    15317437: 29509,
    15317633: 29510,
    15317640: 29511,
    15317643: 29512,
    15317644: 29513,
    15317650: 29514,
    15317653: 29515,
    15317649: 29516,
    15317661: 29517,
    15317669: 29518,
    15317673: 29519,
    15317688: 29520,
    15317674: 29521,
    15317677: 29522,
    15310241: 29523,
    15317900: 29524,
    15317902: 29525,
    15317903: 29526,
    15317904: 29527,
    15317908: 29528,
    15317916: 29529,
    15317918: 29530,
    15317917: 29531,
    15317920: 29532,
    15317925: 29533,
    15317928: 29534,
    15317935: 29535,
    15317940: 29536,
    15317942: 29537,
    15317943: 29538,
    15317945: 29539,
    15317947: 29540,
    15317948: 29541,
    15317949: 29542,
    15318151: 29543,
    15318152: 29544,
    15178423: 29545,
    15318165: 29546,
    15318177: 29547,
    15318188: 29548,
    15318206: 29549,
    15318410: 29550,
    15318418: 29551,
    15318420: 29552,
    15318435: 29553,
    15318431: 29554,
    15318432: 29555,
    15318433: 29556,
    15318438: 29557,
    15318439: 29558,
    15318444: 29559,
    15318442: 29560,
    15318455: 29561,
    15318450: 29562,
    15318454: 29563,
    15318677: 29564,
    15318684: 29565,
    15318688: 29566,
    15048879: 29729,
    15116167: 29730,
    15303065: 29731,
    15176100: 29732,
    15042460: 29733,
    15173273: 29734,
    15186570: 31009,
    15246492: 31010,
    15306120: 31011,
    15305352: 31012,
    15242140: 31013,
    14991241: 31014,
    15172283: 31015,
    15112369: 31016,
    15115144: 31017,
    15305657: 31018,
    15113147: 31019,
    15056261: 31020,
    14989480: 31021,
    14990241: 31022,
    14990268: 31023,
    14990464: 31024,
    14990467: 31025,
    14990521: 31026,
    14990742: 31027,
    14990994: 31028,
    14990986: 31029,
    14991002: 31030,
    14990996: 31031,
    14991245: 31032,
    15040896: 31033,
    15040674: 31034,
    14991295: 31035,
    15040670: 31036,
    15040902: 31037,
    15040944: 31038,
    15040898: 31039,
    15041172: 31040,
    15041460: 31041,
    15041432: 31042,
    15041930: 31043,
    15041956: 31044,
    15042205: 31045,
    15042238: 31046,
    15042476: 31047,
    15042709: 31048,
    15043228: 31049,
    15043238: 31050,
    15043456: 31051,
    15043483: 31052,
    15043712: 31053,
    15043719: 31054,
    15043748: 31055,
    15044018: 31056,
    15044243: 31057,
    15044274: 31058,
    15044509: 31059,
    15706254: 31060,
    15045276: 31061,
    15045258: 31062,
    15045289: 31063,
    15045567: 31064,
    15046278: 31065,
    15048089: 31066,
    15048101: 31067,
    15048364: 31068,
    15048584: 31069,
    15048583: 31070,
    15706255: 31071,
    15706256: 31072,
    15049374: 31073,
    15049394: 31074,
    15049867: 31075,
    15050131: 31076,
    15050139: 31077,
    15050141: 31078,
    15050147: 31079,
    15050404: 31080,
    15050426: 31081,
    15052182: 31082,
    15052672: 31083,
    15176879: 31084,
    15052696: 31085,
    15052716: 31086,
    15052958: 31087,
    15053478: 31088,
    15053498: 31089,
    15053749: 31090,
    15053991: 31091,
    15054227: 31092,
    15706257: 31093,
    15054210: 31094,
    15054253: 31095,
    15054520: 31096,
    15054521: 31097,
    15054736: 31098,
    15056033: 31099,
    15056052: 31100,
    15056295: 31101,
    15056567: 31102,
    15056798: 31265,
    15106461: 31266,
    15106693: 31267,
    15106698: 31268,
    15106974: 31269,
    15106965: 31270,
    15107232: 31271,
    15106994: 31272,
    15107217: 31273,
    15107255: 31274,
    15107248: 31275,
    15107736: 31276,
    15108243: 31277,
    15108774: 31278,
    15110069: 31279,
    15110560: 31280,
    15110813: 31281,
    15111054: 31282,
    15111566: 31283,
    15112320: 31284,
    15112341: 31285,
    15112379: 31286,
    15112329: 31287,
    15112366: 31288,
    15112350: 31289,
    15112356: 31290,
    15112613: 31291,
    15112599: 31292,
    15112601: 31293,
    15706258: 31294,
    15112627: 31295,
    15112857: 31296,
    15112864: 31297,
    15112882: 31298,
    15112895: 31299,
    15113146: 31300,
    15113358: 31301,
    15705257: 31302,
    15113638: 31303,
    15113915: 31304,
    15114642: 31305,
    15114112: 31306,
    15114369: 31307,
    15114628: 31308,
    15115151: 31309,
    15706259: 31310,
    15115688: 31311,
    15706260: 31312,
    15115928: 31313,
    15116194: 31314,
    15116464: 31315,
    15116715: 31316,
    15116678: 31317,
    15116723: 31318,
    15116734: 31319,
    15117218: 31320,
    15117220: 31321,
    15118230: 31322,
    15118527: 31323,
    15118748: 31324,
    15118982: 31325,
    15118767: 31326,
    15119258: 31327,
    15119492: 31328,
    15120007: 31329,
    15119791: 31330,
    15120022: 31331,
    15120044: 31332,
    15120271: 31333,
    15120312: 31334,
    15120306: 31335,
    15120316: 31336,
    15120569: 31337,
    15120796: 31338,
    15120551: 31339,
    15120572: 31340,
    15121087: 31341,
    15122056: 31342,
    15122101: 31343,
    15122357: 31344,
    15171717: 31345,
    15171719: 31346,
    15171752: 31347,
    15172229: 31348,
    15172267: 31349,
    15172751: 31350,
    15172740: 31351,
    15173020: 31352,
    15172998: 31353,
    15172999: 31354,
    15706261: 31355,
    15173505: 31356,
    15173566: 31357,
    15174321: 31358,
    15174334: 31521,
    15174820: 31522,
    15706262: 31523,
    15175095: 31524,
    15175357: 31525,
    15175561: 31526,
    15175574: 31527,
    15175587: 31528,
    15175570: 31529,
    15175815: 31530,
    15175605: 31531,
    15175846: 31532,
    15175850: 31533,
    15175849: 31534,
    15175854: 31535,
    15176098: 31536,
    15176329: 31537,
    15176351: 31538,
    15176833: 31539,
    15177135: 31540,
    15178370: 31541,
    15178396: 31542,
    15178398: 31543,
    15178395: 31544,
    15178406: 31545,
    15706263: 31546,
    15179142: 31547,
    15043247: 31548,
    15179937: 31549,
    15180174: 31550,
    15180196: 31551,
    15180218: 31552,
    15180976: 31553,
    15706264: 31554,
    15706265: 31555,
    15706266: 31556,
    15181460: 31557,
    15706267: 31558,
    15181467: 31559,
    15182737: 31560,
    15182759: 31561,
    15706268: 31562,
    15182763: 31563,
    15183518: 31564,
    15706269: 31565,
    15185288: 31566,
    15185308: 31567,
    15185591: 31568,
    15185568: 31569,
    15185814: 31570,
    15186322: 31571,
    15187335: 31572,
    15187617: 31573,
    15706270: 31574,
    15240321: 31575,
    15240610: 31576,
    15240639: 31577,
    15241095: 31578,
    15241142: 31579,
    15241608: 31580,
    15241908: 31581,
    15242643: 31582,
    15242649: 31583,
    15242667: 31584,
    15706271: 31585,
    15242928: 31586,
    15706272: 31587,
    15706273: 31588,
    15245447: 31589,
    15246261: 31590,
    15247506: 31591,
    15247543: 31592,
    15247801: 31593,
    15248039: 31594,
    15248062: 31595,
    15248287: 31596,
    15706274: 31597,
    15248310: 31598,
    15248787: 31599,
    15248831: 31600,
    15250352: 31601,
    15250356: 31602,
    15250578: 31603,
    15250870: 31604,
    15706275: 31605,
    15252367: 31606,
    15706276: 31607,
    15706277: 31608,
    15303079: 31609,
    15303582: 31610,
    15706278: 31611,
    15303829: 31612,
    15303847: 31613,
    15304602: 31614,
    15304599: 31777,
    15304606: 31778,
    15304621: 31779,
    15304622: 31780,
    15304612: 31781,
    15304613: 31782,
    15304838: 31783,
    15304848: 31784,
    15304842: 31785,
    15304890: 31786,
    15305088: 31787,
    15304892: 31788,
    15305102: 31789,
    15305113: 31790,
    15305105: 31791,
    15304889: 31792,
    15305127: 31793,
    15305383: 31794,
    15305143: 31795,
    15305144: 31796,
    15305639: 31797,
    15305623: 31798,
    15305625: 31799,
    15305616: 31800,
    15706279: 31801,
    15305621: 31802,
    15305632: 31803,
    15305619: 31804,
    15305893: 31805,
    15305889: 31806,
    15305659: 31807,
    15706280: 31808,
    15305886: 31809,
    15305663: 31810,
    15305885: 31811,
    15305858: 31812,
    15306160: 31813,
    15306135: 31814,
    15306404: 31815,
    15306630: 31816,
    15306654: 31817,
    15306680: 31818,
    15306929: 31819,
    15307141: 31820,
    15307144: 31821,
    15308434: 31822,
    15706012: 31823,
    15706281: 31824,
    15309469: 31825,
    15309487: 31826,
    15310003: 31827,
    15310011: 31828,
    15310211: 31829,
    15310221: 31830,
    15310223: 31831,
    15310225: 31832,
    15310229: 31833,
    15311255: 31834,
    15311269: 31835,
    15706282: 31836,
    15706283: 31837,
    15312039: 31838,
    15706284: 31839,
    15312542: 31840,
    15313294: 31841,
    15313817: 31842,
    15313820: 31843,
    15314357: 31844,
    15314354: 31845,
    15314575: 31846,
    15314609: 31847,
    15314619: 31848,
    15315072: 31849,
    15316400: 31850,
    15316395: 31851,
    15706285: 31852,
    15317145: 31853,
    15317905: 31854,
    14845360: 31857,
    14845361: 31858,
    14845362: 31859,
    14845363: 31860,
    14845364: 31861,
    14845365: 31862,
    14845366: 31863,
    14845367: 31864,
    14845368: 31865,
    14845369: 31866,
    15712164: 31868,
    15711367: 31869,
    15711362: 31870,
    //FIXME: mojibake
    14846117: 8514,
    15712162: 8780,
    14846098: 74077
  };
  var utf8ToJisx0212Table = {
    52120: 8751,
    52103: 8752,
    49848: 8753,
    52121: 8754,
    52125: 8755,
    49839: 8756,
    52123: 8757,
    52122: 8758,
    126: 8759,
    52868: 8760,
    52869: 8761,
    49825: 8770,
    49830: 8771,
    49855: 8772,
    49850: 8811,
    49834: 8812,
    49833: 8813,
    49838: 8814,
    14845090: 8815,
    49828: 8816,
    14845078: 8817,
    52870: 9825,
    52872: 9826,
    52873: 9827,
    52874: 9828,
    52906: 9829,
    52876: 9831,
    52878: 9833,
    52907: 9834,
    52879: 9836,
    52908: 9841,
    52909: 9842,
    52910: 9843,
    52911: 9844,
    53130: 9845,
    52880: 9846,
    53132: 9847,
    53122: 9848,
    53133: 9849,
    53131: 9850,
    52912: 9851,
    53134: 9852,
    53378: 10050,
    53379: 10051,
    53380: 10052,
    53381: 10053,
    53382: 10054,
    53383: 10055,
    53384: 10056,
    53385: 10057,
    53386: 10058,
    53387: 10059,
    53388: 10060,
    53390: 10061,
    53391: 10062,
    53650: 10098,
    53651: 10099,
    53652: 10100,
    53653: 10101,
    53654: 10102,
    53655: 10103,
    53656: 10104,
    53657: 10105,
    53658: 10106,
    53659: 10107,
    53660: 10108,
    53662: 10109,
    53663: 10110,
    50054: 10529,
    50320: 10530,
    50342: 10532,
    50354: 10534,
    50561: 10536,
    50367: 10537,
    50570: 10539,
    50072: 10540,
    50578: 10541,
    50598: 10543,
    50078: 10544,
    50086: 10561,
    50321: 10562,
    50096: 10563,
    50343: 10564,
    50353: 10565,
    50355: 10566,
    50360: 10567,
    50562: 10568,
    50560: 10569,
    50569: 10570,
    50571: 10571,
    50104: 10572,
    50579: 10573,
    50079: 10574,
    50599: 10575,
    50110: 10576,
    50049: 10785,
    50048: 10786,
    50052: 10787,
    50050: 10788,
    50306: 10789,
    51085: 10790,
    50304: 10791,
    50308: 10792,
    50053: 10793,
    50051: 10794,
    50310: 10795,
    50312: 10796,
    50316: 10797,
    50055: 10798,
    50314: 10799,
    50318: 10800,
    50057: 10801,
    50056: 10802,
    50059: 10803,
    50058: 10804,
    50330: 10805,
    50326: 10806,
    50322: 10807,
    50328: 10808,
    50332: 10810,
    50334: 10811,
    50338: 10812,
    50336: 10813,
    50340: 10814,
    50061: 10815,
    50060: 10816,
    50063: 10817,
    50062: 10818,
    51087: 10819,
    50352: 10820,
    50346: 10821,
    50350: 10822,
    50344: 10823,
    50356: 10824,
    50358: 10825,
    50361: 10826,
    50365: 10827,
    50363: 10828,
    50563: 10829,
    50567: 10830,
    50565: 10831,
    50065: 10832,
    50067: 10833,
    50066: 10834,
    50070: 10835,
    50068: 10836,
    51089: 10837,
    50576: 10838,
    50572: 10839,
    50069: 10840,
    50580: 10841,
    50584: 10842,
    50582: 10843,
    50586: 10844,
    50588: 10845,
    50592: 10846,
    50590: 10847,
    50596: 10848,
    50594: 10849,
    50074: 10850,
    50073: 10851,
    50076: 10852,
    50075: 10853,
    50604: 10854,
    51091: 10855,
    50608: 10856,
    50602: 10857,
    50610: 10858,
    50606: 10859,
    50600: 10860,
    51095: 10861,
    51099: 10862,
    51097: 10863,
    51093: 10864,
    50612: 10865,
    50077: 10866,
    50616: 10867,
    50614: 10868,
    50617: 10869,
    50621: 10870,
    50619: 10871,
    50081: 11041,
    50080: 11042,
    50084: 11043,
    50082: 11044,
    50307: 11045,
    51086: 11046,
    50305: 11047,
    50309: 11048,
    50085: 11049,
    50083: 11050,
    50311: 11051,
    50313: 11052,
    50317: 11053,
    50087: 11054,
    50315: 11055,
    50319: 11056,
    50089: 11057,
    50088: 11058,
    50091: 11059,
    50090: 11060,
    50331: 11061,
    50327: 11062,
    50323: 11063,
    50329: 11064,
    51125: 11065,
    50333: 11066,
    50335: 11067,
    50337: 11069,
    50341: 11070,
    50093: 11071,
    50092: 11072,
    50095: 11073,
    50094: 11074,
    51088: 11075,
    50347: 11077,
    50351: 11078,
    50345: 11079,
    50357: 11080,
    50359: 11081,
    50362: 11082,
    50366: 11083,
    50364: 11084,
    50564: 11085,
    50568: 11086,
    50566: 11087,
    50097: 11088,
    50099: 11089,
    50098: 11090,
    50102: 11091,
    50100: 11092,
    51090: 11093,
    50577: 11094,
    50573: 11095,
    50101: 11096,
    50581: 11097,
    50585: 11098,
    50583: 11099,
    50587: 11100,
    50589: 11101,
    50593: 11102,
    50591: 11103,
    50597: 11104,
    50595: 11105,
    50106: 11106,
    50105: 11107,
    50108: 11108,
    50107: 11109,
    50605: 11110,
    51092: 11111,
    50609: 11112,
    50603: 11113,
    50611: 11114,
    50607: 11115,
    50601: 11116,
    51096: 11117,
    51100: 11118,
    51098: 11119,
    51094: 11120,
    50613: 11121,
    50109: 11122,
    50111: 11123,
    50615: 11124,
    50618: 11125,
    50622: 11126,
    50620: 11127,
    14989442: 12321,
    14989444: 12322,
    14989445: 12323,
    14989452: 12324,
    14989458: 12325,
    14989471: 12326,
    14989475: 12327,
    14989476: 12328,
    14989480: 12329,
    14989483: 12330,
    14989486: 12331,
    14989487: 12332,
    14989488: 12333,
    14989493: 12334,
    14989696: 12335,
    14989697: 12336,
    14989700: 12337,
    14989703: 12338,
    14989713: 12339,
    14989722: 12340,
    14989724: 12341,
    14989731: 12342,
    14989736: 12343,
    14989737: 12344,
    14989748: 12345,
    14989749: 12346,
    14989753: 12347,
    14989759: 12348,
    14989965: 12349,
    14989974: 12350,
    14989975: 12351,
    14989981: 12352,
    14989999: 12353,
    14990009: 12354,
    14990211: 12355,
    14990224: 12356,
    14990234: 12357,
    14990235: 12358,
    14990240: 12359,
    14990241: 12360,
    14990242: 12361,
    14990248: 12362,
    14990255: 12363,
    14990257: 12364,
    14990259: 12365,
    14990261: 12366,
    14990269: 12367,
    14990270: 12368,
    14990271: 12369,
    14990464: 12370,
    14990466: 12371,
    14990467: 12372,
    14990472: 12373,
    14990475: 12374,
    14990476: 12375,
    14990482: 12376,
    14990485: 12377,
    14990486: 12378,
    14990487: 12379,
    14990489: 12380,
    14990510: 12381,
    14990513: 12382,
    14990752: 12383,
    14990515: 12384,
    14990517: 12385,
    14990519: 12386,
    14990521: 12387,
    14990523: 12388,
    14990526: 12389,
    14990720: 12390,
    14990722: 12391,
    14990728: 12392,
    14990729: 12393,
    14990731: 12394,
    14990732: 12395,
    14990738: 12396,
    14990740: 12397,
    14990742: 12398,
    14990744: 12399,
    14990751: 12400,
    14990755: 12401,
    14990762: 12402,
    14990764: 12403,
    14990766: 12404,
    14990769: 12405,
    14990775: 12406,
    14990776: 12407,
    14990777: 12408,
    14990778: 12409,
    14990781: 12410,
    14990782: 12411,
    14990977: 12412,
    14990978: 12413,
    14990980: 12414,
    14990981: 12577,
    14990985: 12578,
    14990986: 12579,
    14990988: 12580,
    14990990: 12581,
    14990992: 12582,
    14990994: 12583,
    14990995: 12584,
    14990996: 12585,
    14990999: 12586,
    14991001: 12587,
    14991002: 12588,
    14991006: 12589,
    14991007: 12590,
    14991026: 12591,
    14991031: 12592,
    14991033: 12593,
    14991035: 12594,
    14991036: 12595,
    14991037: 12596,
    14991038: 12597,
    14991232: 12598,
    14991233: 12599,
    14991237: 12600,
    14991238: 12601,
    14991240: 12602,
    14991241: 12603,
    14991243: 12604,
    14991244: 12605,
    14991245: 12606,
    14991247: 12607,
    14991250: 12608,
    14991260: 12609,
    14991264: 12610,
    14991266: 12611,
    14991280: 12612,
    14991282: 12613,
    14991292: 12614,
    14991293: 12615,
    14991295: 12616,
    15040640: 12617,
    15040641: 12618,
    15040644: 12619,
    15040647: 12620,
    15040650: 12621,
    15040652: 12622,
    15040654: 12623,
    15040656: 12624,
    15040659: 12625,
    15040663: 12626,
    15040664: 12627,
    15040667: 12628,
    15040668: 12629,
    15040669: 12630,
    15040670: 12631,
    15040674: 12632,
    15040679: 12633,
    15040686: 12634,
    15040688: 12635,
    15040690: 12636,
    15040691: 12637,
    15040693: 12638,
    15040896: 12639,
    15040897: 12640,
    15040898: 12641,
    15040901: 12642,
    15040902: 12643,
    15040906: 12644,
    15040908: 12645,
    15040910: 12646,
    15040913: 12647,
    15040914: 12648,
    15040915: 12649,
    15040919: 12650,
    15040921: 12651,
    15040927: 12652,
    15040928: 12653,
    15040930: 12654,
    15040931: 12655,
    15040934: 12656,
    15040935: 12657,
    15040938: 12658,
    15040941: 12659,
    15040944: 12660,
    15040945: 12661,
    15040699: 12662,
    15041153: 12663,
    15041155: 12664,
    15041156: 12665,
    15041158: 12666,
    15041162: 12667,
    15041166: 12668,
    15041167: 12669,
    15041168: 12670,
    15041170: 12833,
    15041171: 12834,
    15041172: 12835,
    15041174: 12836,
    15041179: 12837,
    15041180: 12838,
    15041182: 12839,
    15041183: 12840,
    15041184: 12841,
    15041185: 12842,
    15041186: 12843,
    15041194: 12844,
    15041199: 12845,
    15041200: 12846,
    15041209: 12847,
    15041210: 12848,
    15041213: 12849,
    15041408: 12850,
    15041411: 12851,
    15041412: 12852,
    15041415: 12853,
    15041420: 12854,
    15041422: 12855,
    15041424: 12856,
    15041427: 12857,
    15041428: 12858,
    15041432: 12859,
    15041436: 12860,
    15041437: 12861,
    15041439: 12862,
    15041442: 12863,
    15041444: 12864,
    15041446: 12865,
    15041448: 12866,
    15041449: 12867,
    15041455: 12868,
    15041457: 12869,
    15041462: 12870,
    15041466: 12871,
    15041470: 12872,
    15041667: 12873,
    15041670: 12874,
    15041671: 12875,
    15041672: 12876,
    15041675: 12877,
    15041676: 12878,
    15041677: 12879,
    15041678: 12880,
    15041458: 12881,
    15041680: 12882,
    15041687: 12883,
    15041689: 12884,
    15041691: 12885,
    15041692: 12886,
    15041693: 12887,
    15041694: 12888,
    15041699: 12889,
    15041703: 12890,
    15041704: 12891,
    15041708: 12892,
    15041709: 12893,
    15041711: 12894,
    15041713: 12895,
    15041715: 12896,
    15041716: 12897,
    15041717: 12898,
    15041720: 12899,
    15041721: 12900,
    15041922: 12901,
    15041930: 12902,
    15041935: 12903,
    15041939: 12904,
    15041941: 12905,
    15041943: 12906,
    15041944: 12907,
    15041951: 12908,
    15041956: 12909,
    15041958: 12910,
    15041982: 12911,
    15042179: 12912,
    15042180: 12913,
    15042187: 12914,
    15042190: 12915,
    15042200: 12916,
    15042205: 12917,
    15042209: 12918,
    15042211: 12919,
    15042221: 12920,
    15042232: 12921,
    15042234: 12922,
    15042236: 12923,
    15042238: 12924,
    15042239: 12925,
    15042434: 12926,
    15042440: 13089,
    15042447: 13090,
    15042449: 13091,
    15042450: 13092,
    15042451: 13093,
    15042453: 13094,
    15042456: 13095,
    15042462: 13096,
    15042466: 13097,
    15042469: 13098,
    15042478: 13099,
    15042482: 13100,
    15042483: 13101,
    15042484: 13102,
    15042487: 13103,
    15042689: 13104,
    15042690: 13105,
    15042693: 13106,
    15042706: 13107,
    15042707: 13108,
    15042709: 13109,
    15042710: 13110,
    15042712: 13111,
    15042722: 13112,
    15042728: 13113,
    15042737: 13114,
    15042738: 13115,
    15042741: 13116,
    15042748: 13117,
    15042949: 13118,
    15042953: 13119,
    15042965: 13120,
    15042967: 13121,
    15042968: 13122,
    15042970: 13123,
    15042972: 13124,
    15042975: 13125,
    15042976: 13126,
    15042977: 13127,
    15042982: 13128,
    15042990: 13129,
    15042999: 13130,
    15043e3: 13131,
    15043001: 13132,
    15043200: 13133,
    15043202: 13134,
    15043205: 13135,
    15043210: 13136,
    15043212: 13137,
    15043219: 13138,
    15043221: 13139,
    15043222: 13140,
    15043223: 13141,
    15043224: 13142,
    15043226: 13143,
    15043228: 13144,
    15043236: 13145,
    15043237: 13146,
    15043238: 13147,
    15043239: 13148,
    15043247: 13149,
    15043248: 13150,
    15043254: 13151,
    15043255: 13152,
    15043256: 13153,
    15043258: 13154,
    15043259: 13155,
    15043261: 13156,
    15043456: 13157,
    15043460: 13158,
    15043462: 13159,
    15043464: 13160,
    15043468: 13161,
    15043471: 13162,
    15043473: 13163,
    15043476: 13164,
    15043478: 13165,
    15043483: 13166,
    15043484: 13167,
    15043489: 13168,
    15043493: 13169,
    15043496: 13170,
    15043497: 13171,
    15043498: 13172,
    15043500: 13173,
    15043504: 13174,
    15043505: 13175,
    15043508: 13176,
    15043510: 13177,
    15043511: 13178,
    15043712: 13179,
    15043715: 13180,
    15043722: 13181,
    15043723: 13182,
    15043724: 13345,
    15043729: 13346,
    15043731: 13347,
    15043736: 13348,
    15043739: 13349,
    15043740: 13350,
    15043742: 13351,
    15043743: 13352,
    15043749: 13353,
    15043751: 13354,
    15043752: 13355,
    15043753: 13356,
    15043755: 13357,
    15043756: 13358,
    15043757: 13359,
    15043760: 13360,
    15043762: 13361,
    15043765: 13362,
    15043772: 13363,
    15043773: 13364,
    15043774: 13365,
    15043970: 13366,
    15043980: 13367,
    15043979: 13368,
    15043993: 13369,
    15043995: 13370,
    15044001: 13371,
    15044003: 13372,
    15044005: 13373,
    15044012: 13374,
    15044013: 13375,
    15044018: 13376,
    15044025: 13377,
    15044030: 13378,
    15044227: 13379,
    15044231: 13380,
    15044232: 13381,
    15044238: 13382,
    15044243: 13383,
    15044244: 13384,
    15044249: 13385,
    15044253: 13386,
    15044257: 13387,
    15044260: 13388,
    15044266: 13389,
    15044267: 13390,
    15044271: 13391,
    15044274: 13392,
    15044276: 13393,
    15044277: 13394,
    15044279: 13395,
    15044280: 13396,
    15044282: 13397,
    15044285: 13398,
    15044480: 13399,
    15044485: 13400,
    15044495: 13401,
    15044498: 13402,
    15044499: 13403,
    15044501: 13404,
    15044506: 13405,
    15044509: 13406,
    15044510: 13407,
    15044512: 13408,
    15044518: 13409,
    15044519: 13410,
    15044533: 13411,
    15044738: 13412,
    15044755: 13413,
    15044762: 13414,
    15044769: 13415,
    15044775: 13416,
    15044776: 13417,
    15044778: 13418,
    15044783: 13419,
    15044785: 13420,
    15044788: 13421,
    15044789: 13422,
    15044995: 13423,
    15044996: 13424,
    15044999: 13425,
    15045005: 13426,
    15045007: 13427,
    15045022: 13428,
    15045026: 13429,
    15045028: 13430,
    15045030: 13431,
    15045031: 13432,
    15045033: 13433,
    15045035: 13434,
    15045037: 13435,
    15045038: 13436,
    15045044: 13437,
    15045055: 13438,
    15045249: 13601,
    15045251: 13602,
    15045253: 13603,
    15045256: 13604,
    15045257: 13605,
    15045261: 13606,
    15045265: 13607,
    15045269: 13608,
    15045270: 13609,
    15045276: 13610,
    15045279: 13611,
    15045281: 13612,
    15045286: 13613,
    15045287: 13614,
    15045289: 13615,
    15045290: 13616,
    15045293: 13617,
    15045294: 13618,
    15045297: 13619,
    15045303: 13620,
    15045305: 13621,
    15045306: 13622,
    15045307: 13623,
    15045311: 13624,
    15045510: 13625,
    15045514: 13626,
    15045517: 13627,
    15045518: 13628,
    15045536: 13629,
    15045546: 13630,
    15045548: 13631,
    15045551: 13632,
    15045558: 13633,
    15045564: 13634,
    15045566: 13635,
    15045567: 13636,
    15045760: 13637,
    15045761: 13638,
    15045765: 13639,
    15045768: 13640,
    15045769: 13641,
    15045772: 13642,
    15045773: 13643,
    15045774: 13644,
    15045781: 13645,
    15045802: 13646,
    15045803: 13647,
    15045810: 13648,
    15045813: 13649,
    15045814: 13650,
    15045819: 13651,
    15045820: 13652,
    15045821: 13653,
    15046017: 13654,
    15046023: 13655,
    15046025: 13656,
    15046026: 13657,
    15046029: 13658,
    15046032: 13659,
    15046033: 13660,
    15046040: 13661,
    15046042: 13662,
    15046043: 13663,
    15046046: 13664,
    15046048: 13665,
    15046049: 13666,
    15046052: 13667,
    15046054: 13668,
    15046079: 13669,
    15046273: 13670,
    15046274: 13671,
    15046278: 13672,
    15046280: 13673,
    15046286: 13674,
    15046287: 13675,
    15046289: 13676,
    15046290: 13677,
    15046291: 13678,
    15046292: 13679,
    15046295: 13680,
    15046307: 13681,
    15046308: 13682,
    15046317: 13683,
    15046322: 13684,
    15046335: 13685,
    15046529: 13686,
    15046531: 13687,
    15046534: 13688,
    15046537: 13689,
    15046539: 13690,
    15046540: 13691,
    15046542: 13692,
    15046545: 13693,
    15046546: 13694,
    15046547: 13857,
    15046551: 13858,
    15046552: 13859,
    15046555: 13860,
    15046558: 13861,
    15046562: 13862,
    15046569: 13863,
    15046582: 13864,
    15046591: 13865,
    15046789: 13866,
    15046792: 13867,
    15046794: 13868,
    15046797: 13869,
    15046798: 13870,
    15046799: 13871,
    15046800: 13872,
    15046801: 13873,
    15046802: 13874,
    15046809: 13875,
    15046828: 13876,
    15046832: 13877,
    15046835: 13878,
    15046837: 13879,
    15046839: 13880,
    15046841: 13881,
    15046843: 13882,
    15046844: 13883,
    15046845: 13884,
    15046847: 13885,
    15047040: 13886,
    15047041: 13887,
    15047043: 13888,
    15047044: 13889,
    15047046: 13890,
    15047049: 13891,
    15047051: 13892,
    15047053: 13893,
    15047055: 13894,
    15047060: 13895,
    15047070: 13896,
    15047072: 13897,
    15047073: 13898,
    15047074: 13899,
    15047075: 13900,
    15047078: 13901,
    15047081: 13902,
    15047085: 13903,
    15047087: 13904,
    15047089: 13905,
    15047090: 13906,
    15047093: 13907,
    15047300: 13908,
    15047301: 13909,
    15047304: 13910,
    15047307: 13911,
    15047308: 13912,
    15047317: 13913,
    15047321: 13914,
    15047322: 13915,
    15047325: 13916,
    15047326: 13917,
    15047327: 13918,
    15047334: 13919,
    15047335: 13920,
    15047336: 13921,
    15047337: 13922,
    15047339: 13923,
    15047340: 13924,
    15047341: 13925,
    15047345: 13926,
    15047347: 13927,
    15047351: 13928,
    15047358: 13929,
    15047557: 13930,
    15047561: 13931,
    15047562: 13932,
    15047563: 13933,
    15047567: 13934,
    15047568: 13935,
    15047564: 13936,
    15047565: 13937,
    15047577: 13938,
    15047580: 13939,
    15047581: 13940,
    15047583: 13941,
    15047585: 13942,
    15047588: 13943,
    15047589: 13944,
    15047590: 13945,
    15047591: 13946,
    15047592: 13947,
    15047601: 13948,
    15047595: 13949,
    15047597: 13950,
    15047606: 14113,
    15047607: 14114,
    15047809: 14115,
    15047810: 14116,
    15047815: 14117,
    15047818: 14118,
    15047820: 14119,
    15047825: 14120,
    15047829: 14121,
    15047834: 14122,
    15047835: 14123,
    15047837: 14124,
    15047840: 14125,
    15047842: 14126,
    15047843: 14127,
    15047844: 14128,
    15047845: 14129,
    15047849: 14130,
    15047850: 14131,
    15047852: 14132,
    15047854: 14133,
    15047855: 14134,
    15047859: 14135,
    15047860: 14136,
    15047869: 14137,
    15047870: 14138,
    15047871: 14139,
    15048069: 14140,
    15048070: 14141,
    15048076: 14142,
    15048077: 14143,
    15048082: 14144,
    15048098: 14145,
    15048101: 14146,
    15048103: 14147,
    15048104: 14148,
    15048107: 14149,
    15048109: 14150,
    15048110: 14151,
    15048111: 14152,
    15048112: 14153,
    15048113: 14154,
    15048115: 14155,
    15048116: 14156,
    15048117: 14157,
    15048119: 14158,
    15048121: 14159,
    15048122: 14160,
    15048123: 14161,
    15048124: 14162,
    15048126: 14163,
    15048321: 14164,
    15048323: 14165,
    15048332: 14166,
    15048340: 14167,
    15048343: 14168,
    15048345: 14169,
    15048346: 14170,
    15048348: 14171,
    15048349: 14172,
    15048350: 14173,
    15048351: 14174,
    15048353: 14175,
    15048341: 14176,
    15048359: 14177,
    15048360: 14178,
    15048361: 14179,
    15048364: 14180,
    15048376: 14181,
    15048381: 14182,
    15048583: 14183,
    15048584: 14184,
    15048588: 14185,
    15048591: 14186,
    15048597: 14187,
    15048605: 14188,
    15048606: 14189,
    15048612: 14190,
    15048614: 14191,
    15048615: 14192,
    15048617: 14193,
    15048621: 14194,
    15048624: 14195,
    15048629: 14196,
    15048630: 14197,
    15048632: 14198,
    15048637: 14199,
    15048638: 14200,
    15048639: 14201,
    15048835: 14202,
    15048836: 14203,
    15048840: 14204,
    15048841: 14205,
    15048609: 14206,
    15048844: 14369,
    15048845: 14370,
    15048859: 14371,
    15048862: 14372,
    15048863: 14373,
    15048864: 14374,
    15048870: 14375,
    15048871: 14376,
    15048877: 14377,
    15048882: 14378,
    15048889: 14379,
    15048895: 14380,
    15049097: 14381,
    15049100: 14382,
    15049101: 14383,
    15049103: 14384,
    15049104: 14385,
    15049109: 14386,
    15049119: 14387,
    15049121: 14388,
    15049124: 14389,
    15049127: 14390,
    15049128: 14391,
    15049144: 14392,
    15049148: 14393,
    15049151: 14394,
    15049344: 14395,
    15049345: 14396,
    15049351: 14397,
    15049352: 14398,
    15049353: 14399,
    15049354: 14400,
    15049356: 14401,
    15049357: 14402,
    15049359: 14403,
    15049360: 14404,
    15049364: 14405,
    15049366: 14406,
    15049373: 14407,
    15049376: 14408,
    15049377: 14409,
    15049378: 14410,
    15049382: 14411,
    15049385: 14412,
    15049393: 14413,
    15049394: 14414,
    15049604: 14415,
    15049404: 14416,
    15049602: 14417,
    15049608: 14418,
    15049613: 14419,
    15049614: 14420,
    15049616: 14421,
    15049618: 14422,
    15049620: 14423,
    15049622: 14424,
    15049626: 14425,
    15049629: 14426,
    15049633: 14427,
    15049634: 14428,
    15049641: 14429,
    15049651: 14430,
    15049861: 14431,
    15049862: 14432,
    15049867: 14433,
    15049868: 14434,
    15049874: 14435,
    15049875: 14436,
    15049876: 14437,
    15243649: 14438,
    15049885: 14439,
    15049889: 14440,
    15049891: 14441,
    15049892: 14442,
    15049896: 14443,
    15049903: 14444,
    15049904: 14445,
    15049907: 14446,
    15049909: 14447,
    15049910: 14448,
    15049919: 14449,
    15050115: 14450,
    15050118: 14451,
    15050130: 14452,
    15050131: 14453,
    15050137: 14454,
    15050139: 14455,
    15050141: 14456,
    15050142: 14457,
    15050143: 14458,
    15050145: 14459,
    15050147: 14460,
    15050155: 14461,
    15050157: 14462,
    15050159: 14625,
    15050162: 14626,
    15050165: 14627,
    15050166: 14628,
    15050169: 14629,
    15050171: 14630,
    15050172: 14631,
    15050379: 14632,
    15050380: 14633,
    15050382: 14634,
    15050386: 14635,
    15050389: 14636,
    15050391: 14637,
    15050399: 14638,
    15050404: 14639,
    15050407: 14640,
    15050413: 14641,
    15050414: 14642,
    15050415: 14643,
    15050416: 14644,
    15050419: 14645,
    15050423: 14646,
    15050426: 14647,
    15050428: 14648,
    15050625: 14649,
    15050627: 14650,
    15050628: 14651,
    15050632: 14652,
    15050634: 14653,
    15050637: 14654,
    15050642: 14655,
    15050653: 14656,
    15050654: 14657,
    15050655: 14658,
    15050659: 14659,
    15050660: 14660,
    15050663: 14661,
    15050670: 14662,
    15050671: 14663,
    15050673: 14664,
    15050674: 14665,
    15050676: 14666,
    15050679: 14667,
    15050880: 14668,
    15050884: 14669,
    15050892: 14670,
    15050893: 14671,
    15050894: 14672,
    15050898: 14673,
    15050899: 14674,
    15050910: 14675,
    15050915: 14676,
    15050916: 14677,
    15050919: 14678,
    15050920: 14679,
    15050922: 14680,
    15050925: 14681,
    15050928: 14682,
    15051140: 14683,
    15051141: 14684,
    15051143: 14685,
    15051144: 14686,
    15051148: 14687,
    15051152: 14688,
    15051157: 14689,
    15051166: 14690,
    15051171: 14691,
    15051173: 14692,
    15051175: 14693,
    15051181: 14694,
    15051191: 14695,
    15051194: 14696,
    15051195: 14697,
    15051198: 14698,
    15051403: 14699,
    15051408: 14700,
    15051411: 14701,
    15051414: 14702,
    15051417: 14703,
    15051420: 14704,
    15051422: 14705,
    15051423: 14706,
    15051424: 14707,
    15051426: 14708,
    15051431: 14709,
    15051436: 14710,
    15051441: 14711,
    15051442: 14712,
    15051443: 14713,
    15051445: 14714,
    15051448: 14715,
    15051450: 14716,
    15051451: 14717,
    15051455: 14718,
    15051652: 14881,
    15051654: 14882,
    15051656: 14883,
    15051663: 14884,
    15051674: 14885,
    15051676: 14886,
    15051680: 14887,
    15051685: 14888,
    15051690: 14889,
    15051694: 14890,
    15051701: 14891,
    15051702: 14892,
    15051709: 14893,
    15051904: 14894,
    15051905: 14895,
    15051912: 14896,
    15051927: 14897,
    15051956: 14898,
    15051929: 14899,
    15051931: 14900,
    15051933: 14901,
    15051937: 14902,
    15051941: 14903,
    15051949: 14904,
    15051960: 14905,
    15052161: 14906,
    15052171: 14907,
    15052172: 14908,
    15052178: 14909,
    15052182: 14910,
    15052190: 14911,
    15052200: 14912,
    15052206: 14913,
    15052207: 14914,
    15052220: 14915,
    15052221: 14916,
    15052222: 14917,
    15052223: 14918,
    15052417: 14919,
    15052420: 14920,
    15052422: 14921,
    15052426: 14922,
    15052430: 14923,
    15052432: 14924,
    15052433: 14925,
    15052435: 14926,
    15052436: 14927,
    15052438: 14928,
    15052456: 14929,
    15052457: 14930,
    15052460: 14931,
    15052461: 14932,
    15052463: 14933,
    15052465: 14934,
    15052466: 14935,
    15052471: 14936,
    15052474: 14937,
    15052476: 14938,
    15052672: 14939,
    15052673: 14940,
    15052685: 14941,
    15052687: 14942,
    15052694: 14943,
    15052695: 14944,
    15052696: 14945,
    15052697: 14946,
    15052698: 14947,
    15052704: 14948,
    15052719: 14949,
    15052721: 14950,
    15052724: 14951,
    15052733: 14952,
    15052940: 14953,
    15052951: 14954,
    15052958: 14955,
    15052959: 14956,
    15052963: 14957,
    15052966: 14958,
    15052969: 14959,
    15052971: 14960,
    15052972: 14961,
    15052974: 14962,
    15052976: 14963,
    15052978: 14964,
    15052981: 14965,
    15052982: 14966,
    15053209: 14967,
    15053210: 14968,
    15053212: 14969,
    15053218: 14970,
    15053219: 14971,
    15053223: 14972,
    15053224: 14973,
    15053225: 14974,
    15053229: 15137,
    15053232: 15138,
    15053236: 15139,
    15053237: 15140,
    15053242: 15141,
    15053243: 15142,
    15053244: 15143,
    15053245: 15144,
    15053447: 15145,
    15053448: 15146,
    15053450: 15147,
    15053455: 15148,
    15053458: 15149,
    15053469: 15150,
    15053471: 15151,
    15053472: 15152,
    15053474: 15153,
    15053475: 15154,
    15053478: 15155,
    15053482: 15156,
    15053490: 15157,
    15053492: 15158,
    15053493: 15159,
    15053498: 15160,
    15053705: 15161,
    15053707: 15162,
    15053714: 15163,
    15053725: 15164,
    15053719: 15165,
    15053742: 15166,
    15053745: 15167,
    15053746: 15168,
    15053748: 15169,
    15053953: 15170,
    15053958: 15171,
    15053965: 15172,
    15053970: 15173,
    15053995: 15174,
    15053987: 15175,
    15053988: 15176,
    15053990: 15177,
    15053991: 15178,
    15054001: 15179,
    15054004: 15180,
    15054009: 15181,
    15054013: 15182,
    15054015: 15183,
    15054210: 15184,
    15054211: 15185,
    15054214: 15186,
    15054216: 15187,
    15054229: 15188,
    15054225: 15189,
    15054233: 15190,
    15054218: 15191,
    15054239: 15192,
    15054240: 15193,
    15054241: 15194,
    15054242: 15195,
    15054244: 15196,
    15054250: 15197,
    15054253: 15198,
    15054256: 15199,
    15054265: 15200,
    15054266: 15201,
    15054270: 15202,
    15054271: 15203,
    15054465: 15204,
    15054467: 15205,
    15054472: 15206,
    15054474: 15207,
    15054482: 15208,
    15054483: 15209,
    15054484: 15210,
    15054485: 15211,
    15054489: 15212,
    15054491: 15213,
    15054495: 15214,
    15054496: 15215,
    15054503: 15216,
    15054507: 15217,
    15054512: 15218,
    15054516: 15219,
    15054520: 15220,
    15054521: 15221,
    15054723: 15222,
    15054727: 15223,
    15054731: 15224,
    15054736: 15225,
    15054734: 15226,
    15054744: 15227,
    15054745: 15228,
    15054752: 15229,
    15054756: 15230,
    15054761: 15393,
    15054776: 15394,
    15054777: 15395,
    15054976: 15396,
    15054983: 15397,
    15054989: 15398,
    15054994: 15399,
    15054996: 15400,
    15054997: 15401,
    15055e3: 15402,
    15055007: 15403,
    15055008: 15404,
    15055022: 15405,
    15055016: 15406,
    15055026: 15407,
    15055029: 15408,
    15055038: 15409,
    15055243: 15410,
    15055248: 15411,
    15055241: 15412,
    15055249: 15413,
    15055254: 15414,
    15055256: 15415,
    15055259: 15416,
    15055260: 15417,
    15055262: 15418,
    15055272: 15419,
    15055274: 15420,
    15055275: 15421,
    15055276: 15422,
    15055277: 15423,
    15055278: 15424,
    15055280: 15425,
    15055488: 15426,
    15055499: 15427,
    15055502: 15428,
    15055522: 15429,
    15055524: 15430,
    15055525: 15431,
    15055528: 15432,
    15055530: 15433,
    15055532: 15434,
    15055537: 15435,
    15055539: 15436,
    15055549: 15437,
    15055550: 15438,
    15055551: 15439,
    15055750: 15440,
    15055756: 15441,
    15055755: 15442,
    15055758: 15443,
    15055761: 15444,
    15055762: 15445,
    15055764: 15446,
    15055765: 15447,
    15055772: 15448,
    15055774: 15449,
    15055781: 15450,
    15055787: 15451,
    15056002: 15452,
    15056006: 15453,
    15056007: 15454,
    15056008: 15455,
    15056014: 15456,
    15056025: 15457,
    15056028: 15458,
    15056029: 15459,
    15056033: 15460,
    15056034: 15461,
    15056035: 15462,
    15056036: 15463,
    15056040: 15464,
    15056043: 15465,
    15056044: 15466,
    15056046: 15467,
    15056048: 15468,
    15056052: 15469,
    15056054: 15470,
    15056059: 15471,
    15056061: 15472,
    15056063: 15473,
    15056256: 15474,
    15056260: 15475,
    15056261: 15476,
    15056263: 15477,
    15056269: 15478,
    15056272: 15479,
    15056276: 15480,
    15056280: 15481,
    15056283: 15482,
    15056288: 15483,
    15056291: 15484,
    15056292: 15485,
    15056295: 15486,
    15056303: 15649,
    15056306: 15650,
    15056308: 15651,
    15056309: 15652,
    15056312: 15653,
    15056314: 15654,
    15056317: 15655,
    15056318: 15656,
    15056521: 15657,
    15056525: 15658,
    15056527: 15659,
    15056534: 15660,
    15056540: 15661,
    15056541: 15662,
    15056546: 15663,
    15056551: 15664,
    15056555: 15665,
    15056548: 15666,
    15056556: 15667,
    15056559: 15668,
    15056560: 15669,
    15056561: 15670,
    15056568: 15671,
    15056772: 15672,
    15056775: 15673,
    15056776: 15674,
    15056777: 15675,
    15056779: 15676,
    15056784: 15677,
    15056785: 15678,
    15056786: 15679,
    15056787: 15680,
    15056788: 15681,
    15056798: 15682,
    15056801: 15683,
    15056802: 15684,
    15056808: 15685,
    15056809: 15686,
    15056810: 15687,
    15056812: 15688,
    15056813: 15689,
    15056814: 15690,
    15056815: 15691,
    15056818: 15692,
    15056819: 15693,
    15056822: 15694,
    15056826: 15695,
    15056828: 15696,
    15106183: 15697,
    15106186: 15698,
    15106189: 15699,
    15106195: 15700,
    15106196: 15701,
    15106199: 15702,
    15106200: 15703,
    15106202: 15704,
    15106207: 15705,
    15106212: 15706,
    15106221: 15707,
    15106227: 15708,
    15106229: 15709,
    15106432: 15710,
    15106439: 15711,
    15106440: 15712,
    15106441: 15713,
    15106444: 15714,
    15106449: 15715,
    15106452: 15716,
    15106454: 15717,
    15106455: 15718,
    15106461: 15719,
    15106465: 15720,
    15106471: 15721,
    15106481: 15722,
    15106494: 15723,
    15106495: 15724,
    15106690: 15725,
    15106694: 15726,
    15106696: 15727,
    15106698: 15728,
    15106702: 15729,
    15106705: 15730,
    15106707: 15731,
    15106709: 15732,
    15106712: 15733,
    15106717: 15734,
    15106718: 15735,
    15106722: 15736,
    15106724: 15737,
    15106725: 15738,
    15106728: 15739,
    15106736: 15740,
    15106737: 15741,
    15106743: 15742,
    15106747: 15905,
    15106750: 15906,
    15106946: 15907,
    15106948: 15908,
    15106952: 15909,
    15106953: 15910,
    15106954: 15911,
    15106955: 15912,
    15106958: 15913,
    15106959: 15914,
    15106964: 15915,
    15106965: 15916,
    15106969: 15917,
    15106971: 15918,
    15106973: 15919,
    15106974: 15920,
    15106978: 15921,
    15106981: 15922,
    15106994: 15923,
    15106997: 15924,
    15107e3: 15925,
    15107004: 15926,
    15107005: 15927,
    15107202: 15928,
    15107207: 15929,
    15107210: 15930,
    15107212: 15931,
    15107216: 15932,
    15107217: 15933,
    15107218: 15934,
    15107219: 15935,
    15107220: 15936,
    15107222: 15937,
    15107223: 15938,
    15107225: 15939,
    15107228: 15940,
    15107230: 15941,
    15107234: 15942,
    15107242: 15943,
    15107243: 15944,
    15107248: 15945,
    15107249: 15946,
    15107253: 15947,
    15107254: 15948,
    15107255: 15949,
    15107257: 15950,
    15107457: 15951,
    15107461: 15952,
    15107462: 15953,
    15107465: 15954,
    15107486: 15955,
    15107488: 15956,
    15107500: 15957,
    15107506: 15958,
    15107512: 15959,
    15107515: 15960,
    15107516: 15961,
    15107519: 15962,
    15107712: 15963,
    15107713: 15964,
    15107715: 15965,
    15107716: 15966,
    15107723: 15967,
    15107725: 15968,
    15107730: 15969,
    15107731: 15970,
    15107735: 15971,
    15107736: 15972,
    15107740: 15973,
    15107741: 15974,
    15107743: 15975,
    15107744: 15976,
    15107749: 15977,
    15107752: 15978,
    15107754: 15979,
    15107757: 15980,
    15107768: 15981,
    15107769: 15982,
    15107772: 15983,
    15107968: 15984,
    15107969: 15985,
    15107970: 15986,
    15107982: 15987,
    15107983: 15988,
    15107989: 15989,
    15107996: 15990,
    15107997: 15991,
    15107998: 15992,
    15107999: 15993,
    15108001: 15994,
    15108002: 15995,
    15108007: 15996,
    15108009: 15997,
    15108005: 15998,
    15108012: 16161,
    15108013: 16162,
    15108015: 16163,
    15108225: 16164,
    15108227: 16165,
    15108228: 16166,
    15108231: 16167,
    15108243: 16168,
    15108245: 16169,
    15108252: 16170,
    15108256: 16171,
    15108258: 16172,
    15108259: 16173,
    15108263: 16174,
    15108265: 16175,
    15108267: 16176,
    15108281: 16177,
    15108285: 16178,
    15108482: 16179,
    15108483: 16180,
    15108484: 16181,
    15108486: 16182,
    15108492: 16183,
    15108496: 16184,
    15108497: 16185,
    15108498: 16186,
    15108500: 16187,
    15108502: 16188,
    15108506: 16189,
    15108508: 16190,
    15108516: 16191,
    15108525: 16192,
    15108527: 16193,
    15108531: 16194,
    15108538: 16195,
    15108541: 16196,
    15108749: 16197,
    15108750: 16198,
    15108751: 16199,
    15108752: 16200,
    15108774: 16201,
    15108776: 16202,
    15108787: 16203,
    15108790: 16204,
    15108791: 16205,
    15108794: 16206,
    15108798: 16207,
    15108799: 16208,
    15108996: 16209,
    15109006: 16210,
    15109013: 16211,
    15109014: 16212,
    15109018: 16213,
    15109034: 16214,
    15109042: 16215,
    15109044: 16216,
    15109052: 16217,
    15109053: 16218,
    15109251: 16219,
    15109252: 16220,
    15109258: 16221,
    15109259: 16222,
    15109261: 16223,
    15109264: 16224,
    15109267: 16225,
    15109270: 16226,
    15109272: 16227,
    15109289: 16228,
    15109290: 16229,
    15109293: 16230,
    15109301: 16231,
    15109302: 16232,
    15109305: 16233,
    15109308: 16234,
    15109505: 16235,
    15109506: 16236,
    15109507: 16237,
    15109508: 16238,
    15109510: 16239,
    15109514: 16240,
    15109515: 16241,
    15109518: 16242,
    15109522: 16243,
    15109523: 16244,
    15109524: 16245,
    15109528: 16246,
    15109531: 16247,
    15109541: 16248,
    15109542: 16249,
    15109548: 16250,
    15109549: 16251,
    15109553: 16252,
    15109556: 16253,
    15109557: 16254,
    15109560: 16417,
    15109564: 16418,
    15109565: 16419,
    15109567: 16420,
    15109762: 16421,
    15109764: 16422,
    15109767: 16423,
    15109770: 16424,
    15109776: 16425,
    15109780: 16426,
    15109781: 16427,
    15109785: 16428,
    15109786: 16429,
    15109790: 16430,
    15109796: 16431,
    15109798: 16432,
    15109805: 16433,
    15109806: 16434,
    15109807: 16435,
    15109821: 16436,
    15110017: 16437,
    15110021: 16438,
    15110024: 16439,
    15110030: 16440,
    15110033: 16441,
    15110035: 16442,
    15110036: 16443,
    15110037: 16444,
    15110044: 16445,
    15110048: 16446,
    15110053: 16447,
    15110058: 16448,
    15110060: 16449,
    15110066: 16450,
    15110067: 16451,
    15110069: 16452,
    15110072: 16453,
    15110073: 16454,
    15110281: 16455,
    15110282: 16456,
    15110288: 16457,
    15110290: 16458,
    15110292: 16459,
    15110296: 16460,
    15110302: 16461,
    15110304: 16462,
    15110306: 16463,
    15110308: 16464,
    15110309: 16465,
    15110313: 16466,
    15110314: 16467,
    15110319: 16468,
    15110320: 16469,
    15110325: 16470,
    15110333: 16471,
    15110335: 16472,
    15110539: 16473,
    15110543: 16474,
    15110545: 16475,
    15110546: 16476,
    15110547: 16477,
    15110548: 16478,
    15110554: 16479,
    15110555: 16480,
    15110556: 16481,
    15110557: 16482,
    15110559: 16483,
    15110560: 16484,
    15110561: 16485,
    15110563: 16486,
    15110573: 16487,
    15110579: 16488,
    15110580: 16489,
    15110587: 16490,
    15110589: 16491,
    15110789: 16492,
    15110791: 16493,
    15110799: 16494,
    15110800: 16495,
    15110801: 16496,
    15110808: 16497,
    15110809: 16498,
    15110811: 16499,
    15110813: 16500,
    15110815: 16501,
    15110817: 16502,
    15110819: 16503,
    15110822: 16504,
    15110824: 16505,
    15110828: 16506,
    15110835: 16507,
    15110845: 16508,
    15110846: 16509,
    15110847: 16510,
    15111044: 16673,
    15111049: 16674,
    15111050: 16675,
    15111051: 16676,
    15111052: 16677,
    15111054: 16678,
    15111056: 16679,
    15111057: 16680,
    15111061: 16681,
    15111063: 16682,
    15111076: 16683,
    15111077: 16684,
    15111081: 16685,
    15111082: 16686,
    15111085: 16687,
    15111088: 16688,
    15111093: 16689,
    15111095: 16690,
    15111099: 16691,
    15111103: 16692,
    15111297: 16693,
    15111300: 16694,
    15111304: 16695,
    15111305: 16696,
    15111306: 16697,
    15111311: 16698,
    15111315: 16699,
    15111316: 16700,
    15111318: 16701,
    15111321: 16702,
    15111323: 16703,
    15111326: 16704,
    15111327: 16705,
    15111330: 16706,
    15111334: 16707,
    15111337: 16708,
    15111342: 16709,
    15111345: 16710,
    15111354: 16711,
    15111356: 16712,
    15111357: 16713,
    15111555: 16714,
    15111559: 16715,
    15111561: 16716,
    15111568: 16717,
    15111570: 16718,
    15111572: 16719,
    15111583: 16720,
    15111584: 16721,
    15111591: 16722,
    15111595: 16723,
    15111610: 16724,
    15111613: 16725,
    15111809: 16726,
    15111813: 16727,
    15111818: 16728,
    15111826: 16729,
    15111829: 16730,
    15111832: 16731,
    15111837: 16732,
    15111840: 16733,
    15111843: 16734,
    15111846: 16735,
    15111854: 16736,
    15111858: 16737,
    15111859: 16738,
    15111860: 16739,
    15111871: 16740,
    15112066: 16741,
    15112072: 16742,
    15112073: 16743,
    15112078: 16744,
    15112080: 16745,
    15112084: 16746,
    15112086: 16747,
    15112088: 16748,
    15112095: 16749,
    15112112: 16750,
    15112114: 16751,
    15112116: 16752,
    15112117: 16753,
    15112121: 16754,
    15112126: 16755,
    15112127: 16756,
    15112320: 16757,
    15112324: 16758,
    15112328: 16759,
    15112329: 16760,
    15112333: 16761,
    15112337: 16762,
    15112338: 16763,
    15112341: 16764,
    15112342: 16765,
    15112349: 16766,
    15112350: 16929,
    15112353: 16930,
    15112354: 16931,
    15112355: 16932,
    15112356: 16933,
    15112358: 16934,
    15112361: 16935,
    15112362: 16936,
    15112363: 16937,
    15112364: 16938,
    15112366: 16939,
    15112368: 16940,
    15112369: 16941,
    15112371: 16942,
    15112377: 16943,
    15112375: 16944,
    15112576: 16945,
    15112581: 16946,
    15112582: 16947,
    15112586: 16948,
    15112588: 16949,
    15112593: 16950,
    15112590: 16951,
    15112599: 16952,
    15112600: 16953,
    15112601: 16954,
    15112603: 16955,
    15112604: 16956,
    15112608: 16957,
    15112609: 16958,
    15113147: 16959,
    15112618: 16960,
    15112619: 16961,
    15112620: 16962,
    15112638: 16963,
    15112627: 16964,
    15112629: 16965,
    15112639: 16966,
    15112631: 16967,
    15112632: 16968,
    15112633: 16969,
    15112635: 16970,
    15112832: 16971,
    15112636: 16972,
    15112843: 16973,
    15112844: 16974,
    15112845: 16975,
    15112848: 16976,
    15112850: 16977,
    15112857: 16978,
    15112858: 16979,
    15112859: 16980,
    15112860: 16981,
    15112863: 16982,
    15112864: 16983,
    15112868: 16984,
    15112877: 16985,
    15112881: 16986,
    15112882: 16987,
    15112885: 16988,
    15112891: 16989,
    15112895: 16990,
    15113088: 16991,
    15113090: 16992,
    15113091: 16993,
    15113096: 16994,
    15113100: 16995,
    15113102: 16996,
    15113103: 16997,
    15113108: 16998,
    15113115: 16999,
    15113119: 17e3,
    15113128: 17001,
    15113131: 17002,
    15113132: 17003,
    15113134: 17004,
    15113146: 17005,
    15113349: 17006,
    15113351: 17007,
    15113358: 17008,
    15113363: 17009,
    15113369: 17010,
    15113372: 17011,
    15113376: 17012,
    15113378: 17013,
    15113395: 17014,
    15113406: 17015,
    15113605: 17016,
    15113607: 17017,
    15113608: 17018,
    15113612: 17019,
    15113620: 17020,
    15113621: 17021,
    15113629: 17022,
    15113638: 17185,
    15113644: 17186,
    15113646: 17187,
    15113652: 17188,
    15113654: 17189,
    15113659: 17190,
    15113857: 17191,
    15113860: 17192,
    15113870: 17193,
    15113871: 17194,
    15113873: 17195,
    15113875: 17196,
    15113878: 17197,
    15113880: 17198,
    15113881: 17199,
    15113883: 17200,
    15113904: 17201,
    15113905: 17202,
    15113906: 17203,
    15113909: 17204,
    15113915: 17205,
    15113916: 17206,
    15113917: 17207,
    15114169: 17208,
    15114112: 17209,
    15114114: 17210,
    15114115: 17211,
    15114117: 17212,
    15114120: 17213,
    15114121: 17214,
    15114130: 17215,
    15114135: 17216,
    15114137: 17217,
    15114140: 17218,
    15114145: 17219,
    15114150: 17220,
    15114160: 17221,
    15114162: 17222,
    15114166: 17223,
    15114167: 17224,
    15114642: 17225,
    15114388: 17226,
    15114393: 17227,
    15114397: 17228,
    15114399: 17229,
    15114408: 17230,
    15114407: 17231,
    15114412: 17232,
    15114413: 17233,
    15114415: 17234,
    15114416: 17235,
    15114417: 17236,
    15114419: 17237,
    15114427: 17238,
    15114431: 17239,
    15114628: 17240,
    15114629: 17241,
    15114634: 17242,
    15114636: 17243,
    15114645: 17244,
    15114647: 17245,
    15114648: 17246,
    15114651: 17247,
    15114667: 17248,
    15114670: 17249,
    15114671: 17250,
    15114672: 17251,
    15114673: 17252,
    15114674: 17253,
    15114677: 17254,
    15114681: 17255,
    15114682: 17256,
    15114683: 17257,
    15114684: 17258,
    15114882: 17259,
    15114884: 17260,
    15114886: 17261,
    15114888: 17262,
    15114902: 17263,
    15114904: 17264,
    15114906: 17265,
    15114908: 17266,
    15114913: 17267,
    15114915: 17268,
    15114917: 17269,
    15114921: 17270,
    15114922: 17271,
    15114926: 17272,
    15114930: 17273,
    15114939: 17274,
    15115141: 17275,
    15115144: 17276,
    15115148: 17277,
    15115151: 17278,
    15115152: 17441,
    15115153: 17442,
    15115155: 17443,
    15115158: 17444,
    15115161: 17445,
    15115164: 17446,
    15115165: 17447,
    15115173: 17448,
    15115176: 17449,
    15115178: 17450,
    15115179: 17451,
    15115180: 17452,
    15115181: 17453,
    15115184: 17454,
    15115185: 17455,
    15115189: 17456,
    15115190: 17457,
    15115195: 17458,
    15115196: 17459,
    15115197: 17460,
    15115398: 17461,
    15115401: 17462,
    15115402: 17463,
    15115408: 17464,
    15115409: 17465,
    15115411: 17466,
    15115414: 17467,
    15115415: 17468,
    15115441: 17469,
    15115443: 17470,
    15115445: 17471,
    15115448: 17472,
    15115451: 17473,
    15115650: 17474,
    15115653: 17475,
    15115657: 17476,
    15115662: 17477,
    15115671: 17478,
    15115675: 17479,
    15115683: 17480,
    15115684: 17481,
    15115685: 17482,
    15115686: 17483,
    15115688: 17484,
    15115689: 17485,
    15115692: 17486,
    15115696: 17487,
    15115697: 17488,
    15115698: 17489,
    15115706: 17490,
    15115707: 17491,
    15115711: 17492,
    15115904: 17493,
    15115917: 17494,
    15115922: 17495,
    15115926: 17496,
    15115928: 17497,
    15115937: 17498,
    15115941: 17499,
    15115942: 17500,
    15115944: 17501,
    15115947: 17502,
    15115949: 17503,
    15115951: 17504,
    15115959: 17505,
    15115960: 17506,
    15115962: 17507,
    15115964: 17508,
    15116165: 17509,
    15116168: 17510,
    15116177: 17511,
    15116182: 17512,
    15116183: 17513,
    15116194: 17514,
    15116197: 17515,
    15116206: 17516,
    15116207: 17517,
    15116209: 17518,
    15116211: 17519,
    15116213: 17520,
    15116222: 17521,
    15116416: 17522,
    15116417: 17523,
    15116419: 17524,
    15116431: 17525,
    15116433: 17526,
    15116437: 17527,
    15116442: 17528,
    15116445: 17529,
    15116448: 17530,
    15116452: 17531,
    15116456: 17532,
    15116464: 17533,
    15116466: 17534,
    15116468: 17697,
    15116471: 17698,
    15116475: 17699,
    15116478: 17700,
    15116479: 17701,
    15116677: 17702,
    15116678: 17703,
    15116681: 17704,
    15116682: 17705,
    15116686: 17706,
    15116688: 17707,
    15116689: 17708,
    15116690: 17709,
    15116693: 17710,
    15116694: 17711,
    15116699: 17712,
    15116708: 17713,
    15116711: 17714,
    15116714: 17715,
    15116721: 17716,
    15116723: 17717,
    15116734: 17718,
    15116929: 17719,
    15116931: 17720,
    15116934: 17721,
    15116935: 17722,
    15116937: 17723,
    15116939: 17724,
    15116945: 17725,
    15116955: 17726,
    15116957: 17727,
    15116958: 17728,
    15116959: 17729,
    15116965: 17730,
    15116971: 17731,
    15116975: 17732,
    15116976: 17733,
    15116977: 17734,
    15116980: 17735,
    15116989: 17736,
    15116990: 17737,
    15116991: 17738,
    15117190: 17739,
    15117193: 17740,
    15117192: 17741,
    15117196: 17742,
    15117200: 17743,
    15117204: 17744,
    15117205: 17745,
    15117206: 17746,
    15117212: 17747,
    15117213: 17748,
    15117220: 17749,
    15117223: 17750,
    15117228: 17751,
    15117232: 17752,
    15117233: 17753,
    15117234: 17754,
    15117244: 17755,
    15117245: 17756,
    15117442: 17757,
    15117443: 17758,
    15117446: 17759,
    15117447: 17760,
    15117449: 17761,
    15117455: 17762,
    15117456: 17763,
    15117457: 17764,
    15117463: 17765,
    15117467: 17766,
    15117470: 17767,
    15117476: 17768,
    15117480: 17769,
    15117483: 17770,
    15117484: 17771,
    15117487: 17772,
    15117493: 17773,
    15117494: 17774,
    15117499: 17775,
    15117503: 17776,
    15117702: 17777,
    15117706: 17778,
    15117709: 17779,
    15117714: 17780,
    15117718: 17781,
    15117720: 17782,
    15117725: 17783,
    15117728: 17784,
    15117735: 17785,
    15117739: 17786,
    15117742: 17787,
    15117744: 17788,
    15117749: 17789,
    15117757: 17790,
    15117758: 17953,
    15117954: 17954,
    15117957: 17955,
    15117975: 17956,
    15117979: 17957,
    15117983: 17958,
    15117984: 17959,
    15117986: 17960,
    15117987: 17961,
    15117992: 17962,
    15117993: 17963,
    15117996: 17964,
    15117997: 17965,
    15117998: 17966,
    15118e3: 17967,
    15118008: 17968,
    15118009: 17969,
    15118013: 17970,
    15118014: 17971,
    15118211: 17972,
    15118212: 17973,
    15118217: 17974,
    15118220: 17975,
    15118230: 17976,
    15118234: 17977,
    15118241: 17978,
    15118243: 17979,
    15118246: 17980,
    15118247: 17981,
    15118254: 17982,
    15118257: 17983,
    15118263: 17984,
    15118265: 17985,
    15118271: 17986,
    15118466: 17987,
    15118468: 17988,
    15118469: 17989,
    15118473: 17990,
    15118477: 17991,
    15118478: 17992,
    15118480: 17993,
    15118482: 17994,
    15118489: 17995,
    15118495: 17996,
    15118502: 17997,
    15118503: 17998,
    15118504: 17999,
    15118508: 18e3,
    15118510: 18001,
    15118515: 18002,
    15118517: 18003,
    15118518: 18004,
    15118522: 18005,
    15118523: 18006,
    15118527: 18007,
    15118730: 18008,
    15118731: 18009,
    15118733: 18010,
    15118735: 18011,
    15118738: 18012,
    15118740: 18013,
    15118745: 18014,
    15118747: 18015,
    15118748: 18016,
    15118763: 18017,
    15118765: 18018,
    15118767: 18019,
    15118772: 18020,
    15118774: 18021,
    15118776: 18022,
    15118777: 18023,
    15118779: 18024,
    15118981: 18025,
    15118982: 18026,
    15118983: 18027,
    15118985: 18028,
    15118996: 18029,
    15118997: 18030,
    15118999: 18031,
    15119e3: 18032,
    15119004: 18033,
    15119007: 18034,
    15119024: 18035,
    15119026: 18036,
    15119028: 18037,
    15119234: 18038,
    15119238: 18039,
    15119245: 18040,
    15119247: 18041,
    15119248: 18042,
    15119249: 18043,
    15119250: 18044,
    15119252: 18045,
    15119254: 18046,
    15119258: 18209,
    15119260: 18210,
    15119264: 18211,
    15119271: 18212,
    15119273: 18213,
    15119275: 18214,
    15119276: 18215,
    15119278: 18216,
    15119282: 18217,
    15119284: 18218,
    15119492: 18219,
    15119495: 18220,
    15119498: 18221,
    15119502: 18222,
    15119503: 18223,
    15119505: 18224,
    15119507: 18225,
    15119514: 18226,
    15119526: 18227,
    15119527: 18228,
    15119528: 18229,
    15118759: 18230,
    15119534: 18231,
    15119535: 18232,
    15119537: 18233,
    15119545: 18234,
    15119548: 18235,
    15119551: 18236,
    15119767: 18237,
    15119774: 18238,
    15119775: 18239,
    15119777: 18240,
    15119781: 18241,
    15119783: 18242,
    15119791: 18243,
    15119792: 18244,
    15119804: 18245,
    15120002: 18246,
    15120007: 18247,
    15120017: 18248,
    15120018: 18249,
    15120020: 18250,
    15120022: 18251,
    15120023: 18252,
    15120024: 18253,
    15120042: 18254,
    15120044: 18255,
    15120052: 18256,
    15120055: 18257,
    15120057: 18258,
    15120061: 18259,
    15120063: 18260,
    15120260: 18261,
    15120264: 18262,
    15120266: 18263,
    15120270: 18264,
    15120271: 18265,
    15120278: 18266,
    15120283: 18267,
    15120285: 18268,
    15120287: 18269,
    15120288: 18270,
    15120290: 18271,
    15120293: 18272,
    15120297: 18273,
    15120303: 18274,
    15120304: 18275,
    15120308: 18276,
    15120310: 18277,
    15120316: 18278,
    15120512: 18279,
    15120516: 18280,
    15120542: 18281,
    15120546: 18282,
    15120551: 18283,
    15120562: 18284,
    15120566: 18285,
    15120569: 18286,
    15120571: 18287,
    15120572: 18288,
    15120772: 18289,
    15120773: 18290,
    15120776: 18291,
    15120777: 18292,
    15120779: 18293,
    15120783: 18294,
    15120785: 18295,
    15120786: 18296,
    15120787: 18297,
    15120788: 18298,
    15120791: 18299,
    15120796: 18300,
    15120797: 18301,
    15120798: 18302,
    15120802: 18465,
    15120803: 18466,
    15120808: 18467,
    15120819: 18468,
    15120827: 18469,
    15120829: 18470,
    15121037: 18471,
    15121043: 18472,
    15121049: 18473,
    15121056: 18474,
    15121063: 18475,
    15121069: 18476,
    15121070: 18477,
    15121073: 18478,
    15121075: 18479,
    15121083: 18480,
    15121087: 18481,
    15121280: 18482,
    15121281: 18483,
    15121283: 18484,
    15121287: 18485,
    15121288: 18486,
    15121290: 18487,
    15121293: 18488,
    15121294: 18489,
    15121295: 18490,
    15121323: 18491,
    15121325: 18492,
    15121326: 18493,
    15121337: 18494,
    15121339: 18495,
    15121341: 18496,
    15121540: 18497,
    15121544: 18498,
    15121546: 18499,
    15121548: 18500,
    15121549: 18501,
    15121558: 18502,
    15121560: 18503,
    15121562: 18504,
    15121563: 18505,
    15121574: 18506,
    15121577: 18507,
    15121578: 18508,
    15121583: 18509,
    15121584: 18510,
    15121587: 18511,
    15121590: 18512,
    15121595: 18513,
    15121596: 18514,
    15121581: 18515,
    15121807: 18516,
    15121809: 18517,
    15121810: 18518,
    15121811: 18519,
    15121815: 18520,
    15121817: 18521,
    15121818: 18522,
    15121821: 18523,
    15121822: 18524,
    15121825: 18525,
    15121826: 18526,
    15121832: 18527,
    15121836: 18528,
    15121853: 18529,
    15121854: 18530,
    15122051: 18531,
    15122055: 18532,
    15122056: 18533,
    15122059: 18534,
    15122060: 18535,
    15122061: 18536,
    15122064: 18537,
    15122066: 18538,
    15122067: 18539,
    15122068: 18540,
    15122070: 18541,
    15122074: 18542,
    15122079: 18543,
    15122080: 18544,
    15122085: 18545,
    15122086: 18546,
    15122087: 18547,
    15122088: 18548,
    15122094: 18549,
    15122095: 18550,
    15122096: 18551,
    15122101: 18552,
    15122102: 18553,
    15122108: 18554,
    15122309: 18555,
    15122311: 18556,
    15122312: 18557,
    15122314: 18558,
    15122330: 18721,
    15122334: 18722,
    15122344: 18723,
    15122345: 18724,
    15122352: 18725,
    15122357: 18726,
    15122361: 18727,
    15122364: 18728,
    15122365: 18729,
    15171712: 18730,
    15171717: 18731,
    15171718: 18732,
    15171719: 18733,
    15171725: 18734,
    15171735: 18735,
    15171744: 18736,
    15171747: 18737,
    15171759: 18738,
    15171764: 18739,
    15171767: 18740,
    15171769: 18741,
    15171772: 18742,
    15171971: 18743,
    15171972: 18744,
    15171976: 18745,
    15171977: 18746,
    15171978: 18747,
    15171979: 18748,
    15171988: 18749,
    15171989: 18750,
    15171997: 18751,
    15171998: 18752,
    15171982: 18753,
    15172004: 18754,
    15172005: 18755,
    15172012: 18756,
    15172014: 18757,
    15172021: 18758,
    15172022: 18759,
    15172030: 18760,
    15172225: 18761,
    15172229: 18762,
    15172230: 18763,
    15172244: 18764,
    15172245: 18765,
    15172246: 18766,
    15172247: 18767,
    15172248: 18768,
    15172251: 18769,
    15172260: 18770,
    15172267: 18771,
    15172272: 18772,
    15172273: 18773,
    15172276: 18774,
    15172279: 18775,
    15172490: 18776,
    15172497: 18777,
    15172499: 18778,
    15172500: 18779,
    15172501: 18780,
    15172502: 18781,
    15172504: 18782,
    15172508: 18783,
    15172516: 18784,
    15172538: 18785,
    15172739: 18786,
    15172740: 18787,
    15172741: 18788,
    15172742: 18789,
    15172743: 18790,
    15172747: 18791,
    15172748: 18792,
    15172751: 18793,
    15172766: 18794,
    15172768: 18795,
    15172779: 18796,
    15172781: 18797,
    15172783: 18798,
    15172784: 18799,
    15172785: 18800,
    15172792: 18801,
    15172993: 18802,
    15172997: 18803,
    15172998: 18804,
    15172999: 18805,
    15173002: 18806,
    15173003: 18807,
    15173008: 18808,
    15173010: 18809,
    15173015: 18810,
    15173018: 18811,
    15173020: 18812,
    15173022: 18813,
    15173024: 18814,
    15173032: 18977,
    15173049: 18978,
    15173248: 18979,
    15173253: 18980,
    15173255: 18981,
    15173260: 18982,
    15173266: 18983,
    15173274: 18984,
    15173275: 18985,
    15173280: 18986,
    15173282: 18987,
    15173295: 18988,
    15173296: 18989,
    15173298: 18990,
    15173299: 18991,
    15173306: 18992,
    15173311: 18993,
    15173504: 18994,
    15173505: 18995,
    15173508: 18996,
    15173515: 18997,
    15173516: 18998,
    15173523: 18999,
    15173526: 19e3,
    15173529: 19001,
    15173530: 19002,
    15173532: 19003,
    15173560: 19004,
    15173566: 19005,
    15173760: 19006,
    15173767: 19007,
    15173768: 19008,
    15173769: 19009,
    15173779: 19010,
    15173783: 19011,
    15173786: 19012,
    15173789: 19013,
    15173791: 19014,
    15173796: 19015,
    15173803: 19016,
    15173807: 19017,
    15173812: 19018,
    15173816: 19019,
    15173817: 19020,
    15174017: 19021,
    15174018: 19022,
    15174019: 19023,
    15174021: 19024,
    15174030: 19025,
    15174031: 19026,
    15174032: 19027,
    15174035: 19028,
    15174037: 19029,
    15174038: 19030,
    15174042: 19031,
    15174044: 19032,
    15174046: 19033,
    15174048: 19034,
    15174051: 19035,
    15174056: 19036,
    15174059: 19037,
    15174062: 19038,
    15174063: 19039,
    15174065: 19040,
    15174071: 19041,
    15174072: 19042,
    15174075: 19043,
    15174076: 19044,
    15174079: 19045,
    15174276: 19046,
    15174281: 19047,
    15174285: 19048,
    15174286: 19049,
    15174291: 19050,
    15174299: 19051,
    15174312: 19052,
    15174317: 19053,
    15174318: 19054,
    15174321: 19055,
    15174324: 19056,
    15174334: 19057,
    15174529: 19058,
    15174535: 19059,
    15174537: 19060,
    15174540: 19061,
    15174549: 19062,
    15174550: 19063,
    15174552: 19064,
    15174559: 19065,
    15174565: 19066,
    15174579: 19067,
    15174580: 19068,
    15174586: 19069,
    15174587: 19070,
    15174590: 19233,
    15174786: 19234,
    15174788: 19235,
    15174789: 19236,
    15174791: 19237,
    15174795: 19238,
    15174797: 19239,
    15174802: 19240,
    15174803: 19241,
    15174808: 19242,
    15174809: 19243,
    15174814: 19244,
    15174818: 19245,
    15174820: 19246,
    15174823: 19247,
    15174824: 19248,
    15174828: 19249,
    15174833: 19250,
    15174834: 19251,
    15174837: 19252,
    15174842: 19253,
    15174843: 19254,
    15174845: 19255,
    15175043: 19256,
    15175053: 19257,
    15175056: 19258,
    15175058: 19259,
    15175062: 19260,
    15175064: 19261,
    15175069: 19262,
    15175070: 19263,
    15175071: 19264,
    15175072: 19265,
    15175078: 19266,
    15175079: 19267,
    15175081: 19268,
    15175083: 19269,
    15175084: 19270,
    15175086: 19271,
    15175087: 19272,
    15175089: 19273,
    15175095: 19274,
    15175097: 19275,
    15175100: 19276,
    15175296: 19277,
    15175297: 19278,
    15175299: 19279,
    15175301: 19280,
    15175302: 19281,
    15175310: 19282,
    15175312: 19283,
    15175315: 19284,
    15175317: 19285,
    15175319: 19286,
    15175320: 19287,
    15175324: 19288,
    15175326: 19289,
    15175327: 19290,
    15175328: 19291,
    15175330: 19292,
    15175333: 19293,
    15175334: 19294,
    15175338: 19295,
    15175339: 19296,
    15175341: 19297,
    15175349: 19298,
    15175351: 19299,
    15175353: 19300,
    15175356: 19301,
    15175357: 19302,
    15175359: 19303,
    15175557: 19304,
    15175558: 19305,
    15175561: 19306,
    15175563: 19307,
    15175564: 19308,
    15175567: 19309,
    15175570: 19310,
    15175571: 19311,
    15175574: 19312,
    15175577: 19313,
    15175581: 19314,
    15175585: 19315,
    15175587: 19316,
    15175590: 19317,
    15175591: 19318,
    15175593: 19319,
    15175604: 19320,
    15175605: 19321,
    15175607: 19322,
    15175609: 19323,
    15175610: 19324,
    15175611: 19325,
    15175613: 19326,
    15175615: 19489,
    15175808: 19490,
    15175809: 19491,
    15175812: 19492,
    15175815: 19493,
    15175818: 19494,
    15175825: 19495,
    15175834: 19496,
    15175835: 19497,
    15175844: 19498,
    15175846: 19499,
    15175848: 19500,
    15175849: 19501,
    15175850: 19502,
    15175851: 19503,
    15175852: 19504,
    15175853: 19505,
    15175854: 19506,
    15175855: 19507,
    15175856: 19508,
    15175857: 19509,
    15175865: 19510,
    15176064: 19511,
    15176067: 19512,
    15176068: 19513,
    15176070: 19514,
    15176071: 19515,
    15176075: 19516,
    15176077: 19517,
    15176081: 19518,
    15176082: 19519,
    15176087: 19520,
    15176093: 19521,
    15176098: 19522,
    15176102: 19523,
    15176103: 19524,
    15176104: 19525,
    15176107: 19526,
    15176109: 19527,
    15176110: 19528,
    15176113: 19529,
    15176114: 19530,
    15176320: 19531,
    15176321: 19532,
    15176325: 19533,
    15176326: 19534,
    15176327: 19535,
    15176329: 19536,
    15176335: 19537,
    15176336: 19538,
    15176337: 19539,
    15176338: 19540,
    15176344: 19541,
    15176345: 19542,
    15176346: 19543,
    15176348: 19544,
    15176351: 19545,
    15176352: 19546,
    15176353: 19547,
    15176355: 19548,
    15176358: 19549,
    15176360: 19550,
    15176361: 19551,
    15176362: 19552,
    15176363: 19553,
    15176366: 19554,
    15176367: 19555,
    15176369: 19556,
    15176370: 19557,
    15176373: 19558,
    15176377: 19559,
    15176379: 19560,
    15176383: 19561,
    15176584: 19562,
    15176585: 19563,
    15176588: 19564,
    15176592: 19565,
    15176595: 19566,
    15176600: 19567,
    15176602: 19568,
    15176603: 19569,
    15176606: 19570,
    15176607: 19571,
    15176612: 19572,
    15176616: 19573,
    15176618: 19574,
    15176619: 19575,
    15176623: 19576,
    15176628: 19577,
    15176634: 19578,
    15176635: 19579,
    15176636: 19580,
    15176639: 19581,
    15176838: 19582,
    15176850: 19745,
    15176854: 19746,
    15176855: 19747,
    15176864: 19748,
    15176865: 19749,
    15176868: 19750,
    15176871: 19751,
    15176873: 19752,
    15176874: 19753,
    15176879: 19754,
    15176886: 19755,
    15176889: 19756,
    15176893: 19757,
    15176894: 19758,
    15176895: 19759,
    15177088: 19760,
    15177091: 19761,
    15177095: 19762,
    15177096: 19763,
    15177102: 19764,
    15177104: 19765,
    15177106: 19766,
    15177111: 19767,
    15177118: 19768,
    15177119: 19769,
    15177121: 19770,
    15177135: 19771,
    15177137: 19772,
    15177145: 19773,
    15177146: 19774,
    15177147: 19775,
    15177148: 19776,
    15177149: 19777,
    15177150: 19778,
    15177345: 19779,
    15177349: 19780,
    15177360: 19781,
    15177362: 19782,
    15177363: 19783,
    15177365: 19784,
    15177369: 19785,
    15177372: 19786,
    15177378: 19787,
    15177380: 19788,
    15177396: 19789,
    15177402: 19790,
    15177407: 19791,
    15177600: 19792,
    15177601: 19793,
    15177604: 19794,
    15177606: 19795,
    15177612: 19796,
    15177614: 19797,
    15177615: 19798,
    15177623: 19799,
    15177628: 19800,
    15177631: 19801,
    15177632: 19802,
    15177633: 19803,
    15177636: 19804,
    15177639: 19805,
    15177644: 19806,
    15177646: 19807,
    15177647: 19808,
    15177649: 19809,
    15177657: 19810,
    15177856: 19811,
    15177858: 19812,
    15177859: 19813,
    15177860: 19814,
    15177863: 19815,
    15177864: 19816,
    15177866: 19817,
    15177868: 19818,
    15177871: 19819,
    15177874: 19820,
    15177875: 19821,
    15177877: 19822,
    15177878: 19823,
    15177881: 19824,
    15177883: 19825,
    15177884: 19826,
    15177885: 19827,
    15177886: 19828,
    15177891: 19829,
    15177893: 19830,
    15177894: 19831,
    15177897: 19832,
    15177901: 19833,
    15177906: 19834,
    15177907: 19835,
    15177909: 19836,
    15177912: 19837,
    15177913: 19838,
    15177914: 20001,
    15177916: 20002,
    15178122: 20003,
    15178112: 20004,
    15178113: 20005,
    15178115: 20006,
    15178116: 20007,
    15178117: 20008,
    15178121: 20009,
    15178123: 20010,
    15178133: 20011,
    15178137: 20012,
    15178143: 20013,
    15178148: 20014,
    15178149: 20015,
    15178157: 20016,
    15178158: 20017,
    15178159: 20018,
    15178161: 20019,
    15178164: 20020,
    15178369: 20021,
    15178373: 20022,
    15178380: 20023,
    15178381: 20024,
    15178389: 20025,
    15178395: 20026,
    15178396: 20027,
    15178397: 20028,
    15178399: 20029,
    15178400: 20030,
    15178402: 20031,
    15178403: 20032,
    15178404: 20033,
    15178405: 20034,
    15178406: 20035,
    15178407: 20036,
    15178408: 20037,
    15178410: 20038,
    15178413: 20039,
    15178429: 20040,
    15178625: 20041,
    15178629: 20042,
    15178633: 20043,
    15178635: 20044,
    15178636: 20045,
    15178638: 20046,
    15178644: 20047,
    15178649: 20048,
    15178656: 20049,
    15178662: 20050,
    15178664: 20051,
    15178668: 20052,
    15178672: 20053,
    15178673: 20054,
    15178678: 20055,
    15178681: 20056,
    15178684: 20057,
    15178880: 20058,
    15178886: 20059,
    15178890: 20060,
    15178894: 20061,
    15178898: 20062,
    15178900: 20063,
    15178901: 20064,
    15178903: 20065,
    15178905: 20066,
    15178906: 20067,
    15178908: 20068,
    15178914: 20069,
    15178920: 20070,
    15178925: 20071,
    15178926: 20072,
    15178927: 20073,
    15178932: 20074,
    15178933: 20075,
    15178934: 20076,
    15178937: 20077,
    15178941: 20078,
    15178942: 20079,
    15179138: 20080,
    15179141: 20081,
    15179142: 20082,
    15179146: 20083,
    15179149: 20084,
    15179150: 20085,
    15179151: 20086,
    15179154: 20087,
    15179158: 20088,
    15179159: 20089,
    15179164: 20090,
    15179166: 20091,
    15179167: 20092,
    15179168: 20093,
    15179170: 20094,
    15179172: 20257,
    15179175: 20258,
    15179178: 20259,
    15179180: 20260,
    15179184: 20261,
    15179186: 20262,
    15179187: 20263,
    15179188: 20264,
    15179194: 20265,
    15179197: 20266,
    15179392: 20267,
    15179396: 20268,
    15179404: 20269,
    15179405: 20270,
    15179412: 20271,
    15179413: 20272,
    15179414: 20273,
    15179418: 20274,
    15179423: 20275,
    15179426: 20276,
    15179431: 20277,
    15179434: 20278,
    15179438: 20279,
    15179439: 20280,
    15179441: 20281,
    15179445: 20282,
    15179454: 20283,
    15179651: 20284,
    15179657: 20285,
    15179665: 20286,
    15179666: 20287,
    15179669: 20288,
    15179673: 20289,
    15179678: 20290,
    15179679: 20291,
    15179680: 20292,
    15179684: 20293,
    15179686: 20294,
    15179690: 20295,
    15179692: 20296,
    15179696: 20297,
    15179697: 20298,
    15179700: 20299,
    15179704: 20300,
    15179707: 20301,
    15179909: 20302,
    15179910: 20303,
    15179913: 20304,
    15179917: 20305,
    15179918: 20306,
    15179921: 20307,
    15179933: 20308,
    15179937: 20309,
    15179938: 20310,
    15179939: 20311,
    15179949: 20312,
    15179950: 20313,
    15179952: 20314,
    15179957: 20315,
    15179959: 20316,
    15180163: 20317,
    15180164: 20318,
    15180167: 20319,
    15180168: 20320,
    15180172: 20321,
    15180174: 20322,
    15180178: 20323,
    15180188: 20324,
    15180190: 20325,
    15180192: 20326,
    15180193: 20327,
    15180195: 20328,
    15180196: 20329,
    15180200: 20330,
    15180202: 20331,
    15180206: 20332,
    15180218: 20333,
    15180222: 20334,
    15180426: 20335,
    15180431: 20336,
    15180436: 20337,
    15180440: 20338,
    15180449: 20339,
    15180445: 20340,
    15180446: 20341,
    15180447: 20342,
    15180452: 20343,
    15180456: 20344,
    15180460: 20345,
    15180461: 20346,
    15180464: 20347,
    15180465: 20348,
    15180466: 20349,
    15180467: 20350,
    15180475: 20513,
    15180477: 20514,
    15180479: 20515,
    15180679: 20516,
    15180680: 20517,
    15180681: 20518,
    15180684: 20519,
    15180686: 20520,
    15180690: 20521,
    15180691: 20522,
    15180693: 20523,
    15180694: 20524,
    15180708: 20525,
    15180699: 20526,
    15180703: 20527,
    15180704: 20528,
    15180705: 20529,
    15180710: 20530,
    15180714: 20531,
    15180722: 20532,
    15180723: 20533,
    15180928: 20534,
    15180726: 20535,
    15180727: 20536,
    15180730: 20537,
    15180731: 20538,
    15180735: 20539,
    15180934: 20540,
    15180940: 20541,
    15180944: 20542,
    15180954: 20543,
    15180956: 20544,
    15180958: 20545,
    15180959: 20546,
    15180960: 20547,
    15180965: 20548,
    15180967: 20549,
    15180969: 20550,
    15180973: 20551,
    15180977: 20552,
    15180980: 20553,
    15180981: 20554,
    15180987: 20555,
    15180989: 20556,
    15180991: 20557,
    15181188: 20558,
    15181189: 20559,
    15181190: 20560,
    15181194: 20561,
    15181195: 20562,
    15181199: 20563,
    15181201: 20564,
    15181204: 20565,
    15181208: 20566,
    15181211: 20567,
    15181212: 20568,
    15181223: 20569,
    15181225: 20570,
    15181227: 20571,
    15181234: 20572,
    15181241: 20573,
    15181243: 20574,
    15181244: 20575,
    15181246: 20576,
    15181451: 20577,
    15181452: 20578,
    15181457: 20579,
    15181459: 20580,
    15181460: 20581,
    15181461: 20582,
    15181462: 20583,
    15181464: 20584,
    15181467: 20585,
    15181468: 20586,
    15181473: 20587,
    15181480: 20588,
    15181481: 20589,
    15181483: 20590,
    15181487: 20591,
    15181489: 20592,
    15181492: 20593,
    15181496: 20594,
    15181499: 20595,
    15181698: 20596,
    15181700: 20597,
    15181703: 20598,
    15181704: 20599,
    15181706: 20600,
    15181711: 20601,
    15181716: 20602,
    15181718: 20603,
    15181722: 20604,
    15181725: 20605,
    15181726: 20606,
    15181728: 20769,
    15181730: 20770,
    15181733: 20771,
    15181738: 20772,
    15181739: 20773,
    15181741: 20774,
    15181745: 20775,
    15181752: 20776,
    15181756: 20777,
    15181954: 20778,
    15181955: 20779,
    15181959: 20780,
    15181961: 20781,
    15181962: 20782,
    15181964: 20783,
    15181969: 20784,
    15181973: 20785,
    15181979: 20786,
    15181982: 20787,
    15181985: 20788,
    15181991: 20789,
    15181995: 20790,
    15181997: 20791,
    15181999: 20792,
    15182e3: 20793,
    15182004: 20794,
    15182005: 20795,
    15182008: 20796,
    15182009: 20797,
    15182010: 20798,
    15182212: 20799,
    15182213: 20800,
    15182215: 20801,
    15182216: 20802,
    15182220: 20803,
    15182229: 20804,
    15182230: 20805,
    15182233: 20806,
    15182236: 20807,
    15182237: 20808,
    15182239: 20809,
    15182240: 20810,
    15182245: 20811,
    15182247: 20812,
    15182250: 20813,
    15182253: 20814,
    15182261: 20815,
    15182264: 20816,
    15182270: 20817,
    15182464: 20818,
    15182466: 20819,
    15182469: 20820,
    15182470: 20821,
    15182474: 20822,
    15182475: 20823,
    15182480: 20824,
    15182481: 20825,
    15182484: 20826,
    15182494: 20827,
    15182496: 20828,
    15182499: 20829,
    15182508: 20830,
    15182515: 20831,
    15182517: 20832,
    15182521: 20833,
    15182523: 20834,
    15182524: 20835,
    15182726: 20836,
    15182729: 20837,
    15182732: 20838,
    15182734: 20839,
    15182737: 20840,
    15182747: 20841,
    15182760: 20842,
    15182761: 20843,
    15182763: 20844,
    15182764: 20845,
    15182769: 20846,
    15182772: 20847,
    15182779: 20848,
    15182781: 20849,
    15182782: 20850,
    15182983: 20851,
    15182996: 20852,
    15183007: 20853,
    15183011: 20854,
    15183015: 20855,
    15183017: 20856,
    15183018: 20857,
    15183019: 20858,
    15183021: 20859,
    15183022: 20860,
    15183023: 20861,
    15183024: 20862,
    15183025: 21025,
    15183028: 21026,
    15183037: 21027,
    15183039: 21028,
    15183232: 21029,
    15183233: 21030,
    15183239: 21031,
    15183246: 21032,
    15183253: 21033,
    15183264: 21034,
    15183268: 21035,
    15183270: 21036,
    15183273: 21037,
    15183274: 21038,
    15183277: 21039,
    15183279: 21040,
    15183282: 21041,
    15183283: 21042,
    15183287: 21043,
    15183492: 21044,
    15183497: 21045,
    15183502: 21046,
    15183504: 21047,
    15183505: 21048,
    15183510: 21049,
    15183515: 21050,
    15183518: 21051,
    15183520: 21052,
    15183525: 21053,
    15183532: 21054,
    15183535: 21055,
    15183536: 21056,
    15183538: 21057,
    15183541: 21058,
    15183542: 21059,
    15183546: 21060,
    15183547: 21061,
    15183548: 21062,
    15183549: 21063,
    15183746: 21064,
    15183749: 21065,
    15183752: 21066,
    15183754: 21067,
    15183764: 21068,
    15183766: 21069,
    15183767: 21070,
    15183769: 21071,
    15183770: 21072,
    15183771: 21073,
    15183784: 21074,
    15183786: 21075,
    15183794: 21076,
    15183796: 21077,
    15183797: 21078,
    15183800: 21079,
    15183801: 21080,
    15183802: 21081,
    15183804: 21082,
    15183806: 21083,
    15184001: 21084,
    15184002: 21085,
    15184003: 21086,
    15184004: 21087,
    15184006: 21088,
    15184009: 21089,
    15184011: 21090,
    15184012: 21091,
    15184014: 21092,
    15184015: 21093,
    15184025: 21094,
    15184027: 21095,
    15184032: 21096,
    15184037: 21097,
    15184038: 21098,
    15184040: 21099,
    15184044: 21100,
    15184049: 21101,
    15184051: 21102,
    15184052: 21103,
    15184054: 21104,
    15184057: 21105,
    15184058: 21106,
    15184262: 21107,
    15184266: 21108,
    15184277: 21109,
    15184273: 21110,
    15184274: 21111,
    15184275: 21112,
    15184281: 21113,
    15184282: 21114,
    15184283: 21115,
    15184284: 21116,
    15184285: 21117,
    15184286: 21118,
    15184289: 21281,
    15184291: 21282,
    15184295: 21283,
    15184297: 21284,
    15184301: 21285,
    15184302: 21286,
    15184304: 21287,
    15184306: 21288,
    15184313: 21289,
    15184316: 21290,
    15184317: 21291,
    15184518: 21292,
    15184519: 21293,
    15184527: 21294,
    15184532: 21295,
    15184542: 21296,
    15184544: 21297,
    15184550: 21298,
    15184560: 21299,
    15184566: 21300,
    15184567: 21301,
    15184570: 21302,
    15184571: 21303,
    15184572: 21304,
    15184575: 21305,
    15184772: 21306,
    15184775: 21307,
    15184776: 21308,
    15184777: 21309,
    15184781: 21310,
    15184783: 21311,
    15184787: 21312,
    15184788: 21313,
    15184789: 21314,
    15184791: 21315,
    15184793: 21316,
    15184794: 21317,
    15184797: 21318,
    15184806: 21319,
    15184809: 21320,
    15184811: 21321,
    15184821: 21322,
    15185027: 21323,
    15185031: 21324,
    15185032: 21325,
    15185033: 21326,
    15185039: 21327,
    15185041: 21328,
    15185042: 21329,
    15185043: 21330,
    15185046: 21331,
    15185053: 21332,
    15185054: 21333,
    15185059: 21334,
    15185062: 21335,
    15185066: 21336,
    15185069: 21337,
    15185073: 21338,
    15185084: 21339,
    15185085: 21340,
    15185086: 21341,
    15185280: 21342,
    15185281: 21343,
    15185287: 21344,
    15185288: 21345,
    15185293: 21346,
    15185297: 21347,
    15185299: 21348,
    15185303: 21349,
    15185305: 21350,
    15185306: 21351,
    15185308: 21352,
    15185309: 21353,
    15185317: 21354,
    15185319: 21355,
    15185322: 21356,
    15185328: 21357,
    15185336: 21358,
    15185338: 21359,
    15185339: 21360,
    15185343: 21361,
    15185537: 21362,
    15185538: 21363,
    15185539: 21364,
    15185541: 21365,
    15185542: 21366,
    15185544: 21367,
    15185547: 21368,
    15185548: 21369,
    15185549: 21370,
    15185553: 21371,
    15185558: 21372,
    15185559: 21373,
    15185565: 21374,
    15185566: 21537,
    15185574: 21538,
    15185575: 21539,
    15185578: 21540,
    15185587: 21541,
    15185590: 21542,
    15185591: 21543,
    15185593: 21544,
    15185794: 21545,
    15185795: 21546,
    15185796: 21547,
    15185797: 21548,
    15185798: 21549,
    15185804: 21550,
    15185805: 21551,
    15185806: 21552,
    15185815: 21553,
    15185817: 21554,
    15186048: 21555,
    15185826: 21556,
    15185829: 21557,
    15185830: 21558,
    15185834: 21559,
    15185835: 21560,
    15185837: 21561,
    15185841: 21562,
    15185845: 21563,
    15185846: 21564,
    15185849: 21565,
    15185850: 21566,
    15186056: 21567,
    15186064: 21568,
    15186065: 21569,
    15186069: 21570,
    15186071: 21571,
    15186076: 21572,
    15186077: 21573,
    15186080: 21574,
    15186087: 21575,
    15186088: 21576,
    15186092: 21577,
    15186093: 21578,
    15186095: 21579,
    15186099: 21580,
    15186102: 21581,
    15186111: 21582,
    15186308: 21583,
    15186309: 21584,
    15186311: 21585,
    15186318: 21586,
    15186320: 21587,
    15186322: 21588,
    15186328: 21589,
    15186335: 21590,
    15186337: 21591,
    15186338: 21592,
    15186341: 21593,
    15186347: 21594,
    15186350: 21595,
    15186351: 21596,
    15186355: 21597,
    15186360: 21598,
    15186366: 21599,
    15186561: 21600,
    15186566: 21601,
    15186567: 21602,
    15186570: 21603,
    15186573: 21604,
    15186577: 21605,
    15186581: 21606,
    15186584: 21607,
    15186586: 21608,
    15186589: 21609,
    15186590: 21610,
    15187132: 21611,
    15187131: 21612,
    15187133: 21613,
    15187134: 21614,
    15187135: 21615,
    15187331: 21616,
    15187332: 21617,
    15187335: 21618,
    15187343: 21619,
    15187346: 21620,
    15187347: 21621,
    15187355: 21622,
    15187356: 21623,
    15187357: 21624,
    15187361: 21625,
    15187363: 21626,
    15187364: 21627,
    15187365: 21628,
    15187366: 21629,
    15187373: 21630,
    15187377: 21793,
    15187389: 21794,
    15187390: 21795,
    15187391: 21796,
    15187584: 21797,
    15187595: 21798,
    15187597: 21799,
    15187599: 21800,
    15187600: 21801,
    15187601: 21802,
    15187606: 21803,
    15187607: 21804,
    15187612: 21805,
    15187617: 21806,
    15187618: 21807,
    15187622: 21808,
    15187626: 21809,
    15187629: 21810,
    15187636: 21811,
    15187644: 21812,
    15187647: 21813,
    15187840: 21814,
    15187843: 21815,
    15187848: 21816,
    15187854: 21817,
    15187855: 21818,
    15187867: 21819,
    15187871: 21820,
    15187875: 21821,
    15187877: 21822,
    15187880: 21823,
    15187884: 21824,
    15187886: 21825,
    15187887: 21826,
    15187890: 21827,
    15187898: 21828,
    15187901: 21829,
    15187902: 21830,
    15187903: 21831,
    15237255: 21832,
    15237256: 21833,
    15237258: 21834,
    15237261: 21835,
    15237262: 21836,
    15237263: 21837,
    15237265: 21838,
    15237267: 21839,
    15237268: 21840,
    15237270: 21841,
    15237277: 21842,
    15237278: 21843,
    15237279: 21844,
    15237280: 21845,
    15237284: 21846,
    15237286: 21847,
    15237292: 21848,
    15237294: 21849,
    15237296: 21850,
    15237300: 21851,
    15237301: 21852,
    15237303: 21853,
    15237305: 21854,
    15237306: 21855,
    15237308: 21856,
    15237310: 21857,
    15237504: 21858,
    15237508: 21859,
    15237536: 21860,
    15237540: 21861,
    15237542: 21862,
    15237549: 21863,
    15237553: 21864,
    15237557: 21865,
    15237761: 21866,
    15237768: 21867,
    15237774: 21868,
    15237788: 21869,
    15237790: 21870,
    15237798: 21871,
    15237799: 21872,
    15237803: 21873,
    15237816: 21874,
    15237817: 21875,
    15238024: 21876,
    15238029: 21877,
    15238031: 21878,
    15238034: 21879,
    15238036: 21880,
    15238037: 21881,
    15238039: 21882,
    15238040: 21883,
    15238048: 21884,
    15238061: 21885,
    15238062: 21886,
    15238064: 22049,
    15238066: 22050,
    15238067: 22051,
    15238070: 22052,
    15238073: 22053,
    15238074: 22054,
    15238078: 22055,
    15238275: 22056,
    15238283: 22057,
    15238294: 22058,
    15238295: 22059,
    15238296: 22060,
    15238300: 22061,
    15238302: 22062,
    15238304: 22063,
    15238308: 22064,
    15238311: 22065,
    15238316: 22066,
    15238320: 22067,
    15238325: 22068,
    15238330: 22069,
    15238332: 22070,
    15238533: 22071,
    15238535: 22072,
    15238538: 22073,
    15238540: 22074,
    15238546: 22075,
    15238551: 22076,
    15238560: 22077,
    15238561: 22078,
    15238567: 22079,
    15238568: 22080,
    15238569: 22081,
    15238573: 22082,
    15238575: 22083,
    15238583: 22084,
    15238785: 22085,
    15238800: 22086,
    15238788: 22087,
    15238789: 22088,
    15238790: 22089,
    15238795: 22090,
    15238798: 22091,
    15238806: 22092,
    15238808: 22093,
    15238811: 22094,
    15238814: 22095,
    15238818: 22096,
    15238830: 22097,
    15238834: 22098,
    15238836: 22099,
    15238843: 22100,
    15239051: 22101,
    15239043: 22102,
    15239045: 22103,
    15239050: 22104,
    15239054: 22105,
    15239055: 22106,
    15239061: 22107,
    15239063: 22108,
    15239067: 22109,
    15239069: 22110,
    15239070: 22111,
    15239073: 22112,
    15239076: 22113,
    15239083: 22114,
    15239084: 22115,
    15239088: 22116,
    15239089: 22117,
    15239090: 22118,
    15239093: 22119,
    15239094: 22120,
    15239096: 22121,
    15239097: 22122,
    15239101: 22123,
    15239103: 22124,
    15239296: 22125,
    15239299: 22126,
    15239311: 22127,
    15239315: 22128,
    15239316: 22129,
    15239321: 22130,
    15239322: 22131,
    15239325: 22132,
    15239329: 22133,
    15239330: 22134,
    15239336: 22135,
    15239346: 22136,
    15239348: 22137,
    15239354: 22138,
    15239555: 22139,
    15239556: 22140,
    15239557: 22141,
    15239558: 22142,
    15239563: 22305,
    15239566: 22306,
    15239567: 22307,
    15239569: 22308,
    15239574: 22309,
    15239580: 22310,
    15239584: 22311,
    15239587: 22312,
    15239591: 22313,
    15239597: 22314,
    15239604: 22315,
    15239611: 22316,
    15239613: 22317,
    15239615: 22318,
    15239808: 22319,
    15239809: 22320,
    15239811: 22321,
    15239812: 22322,
    15239815: 22323,
    15239817: 22324,
    15239818: 22325,
    15239822: 22326,
    15239825: 22327,
    15239828: 22328,
    15239830: 22329,
    15239832: 22330,
    15239834: 22331,
    15239835: 22332,
    15239840: 22333,
    15239841: 22334,
    15239843: 22335,
    15239844: 22336,
    15239847: 22337,
    15239848: 22338,
    15239849: 22339,
    15239850: 22340,
    15239854: 22341,
    15239856: 22342,
    15239858: 22343,
    15239860: 22344,
    15239863: 22345,
    15239866: 22346,
    15239868: 22347,
    15239870: 22348,
    15239871: 22349,
    15240070: 22350,
    15240080: 22351,
    15240085: 22352,
    15240090: 22353,
    15240096: 22354,
    15240098: 22355,
    15240100: 22356,
    15240104: 22357,
    15240106: 22358,
    15240109: 22359,
    15240111: 22360,
    15240118: 22361,
    15240119: 22362,
    15240125: 22363,
    15240126: 22364,
    15240320: 22365,
    15240321: 22366,
    15240327: 22367,
    15240328: 22368,
    15240330: 22369,
    15240331: 22370,
    15240596: 22371,
    15240347: 22372,
    15240349: 22373,
    15240350: 22374,
    15240351: 22375,
    15240353: 22376,
    15240354: 22377,
    15240364: 22378,
    15240365: 22379,
    15240366: 22380,
    15240368: 22381,
    15240371: 22382,
    15240375: 22383,
    15240378: 22384,
    15240380: 22385,
    15240381: 22386,
    15240578: 22387,
    15240579: 22388,
    15240580: 22389,
    15240583: 22390,
    15240589: 22391,
    15240590: 22392,
    15240593: 22393,
    15240597: 22394,
    15240598: 22395,
    15240599: 22396,
    15240624: 22397,
    15240632: 22398,
    15240637: 22561,
    15240639: 22562,
    15240832: 22563,
    15240834: 22564,
    15240836: 22565,
    15240838: 22566,
    15240845: 22567,
    15240850: 22568,
    15240852: 22569,
    15240853: 22570,
    15240856: 22571,
    15240857: 22572,
    15240859: 22573,
    15240860: 22574,
    15240861: 22575,
    15240870: 22576,
    15240871: 22577,
    15240873: 22578,
    15240876: 22579,
    15240894: 22580,
    15240895: 22581,
    15241088: 22582,
    15241095: 22583,
    15241097: 22584,
    15241103: 22585,
    15241104: 22586,
    15241105: 22587,
    15241108: 22588,
    15241117: 22589,
    15240595: 22590,
    15241128: 22591,
    15241130: 22592,
    15241142: 22593,
    15241144: 22594,
    15241145: 22595,
    15241148: 22596,
    15241345: 22597,
    15241350: 22598,
    15241354: 22599,
    15241359: 22600,
    15241361: 22601,
    15241365: 22602,
    15241369: 22603,
    15240877: 22604,
    15241391: 22605,
    15241401: 22606,
    15241605: 22607,
    15241607: 22608,
    15241608: 22609,
    15241610: 22610,
    15241613: 22611,
    15241615: 22612,
    15241617: 22613,
    15241618: 22614,
    15241622: 22615,
    15241624: 22616,
    15241625: 22617,
    15241626: 22618,
    15241628: 22619,
    15241632: 22620,
    15241636: 22621,
    15241637: 22622,
    15241639: 22623,
    15241642: 22624,
    15241648: 22625,
    15241651: 22626,
    15241652: 22627,
    15241654: 22628,
    15241656: 22629,
    15241660: 22630,
    15241661: 22631,
    15241857: 22632,
    15241861: 22633,
    15241874: 22634,
    15241875: 22635,
    15241877: 22636,
    15241886: 22637,
    15241894: 22638,
    15241896: 22639,
    15241897: 22640,
    15241898: 22641,
    15241903: 22642,
    15241905: 22643,
    15241908: 22644,
    15241914: 22645,
    15241917: 22646,
    15241918: 22647,
    15242112: 22648,
    15242114: 22649,
    15242119: 22650,
    15242120: 22651,
    15242124: 22652,
    15242127: 22653,
    15242131: 22654,
    15242140: 22817,
    15242151: 22818,
    15242154: 22819,
    15242159: 22820,
    15242160: 22821,
    15242161: 22822,
    15242162: 22823,
    15242167: 22824,
    15242418: 22825,
    15242170: 22826,
    15242171: 22827,
    15242173: 22828,
    15242370: 22829,
    15242371: 22830,
    15242375: 22831,
    15242380: 22832,
    15242382: 22833,
    15242384: 22834,
    15242396: 22835,
    15242398: 22836,
    15242402: 22837,
    15242403: 22838,
    15242404: 22839,
    15242405: 22840,
    15242407: 22841,
    15242410: 22842,
    15242411: 22843,
    15242415: 22844,
    15242419: 22845,
    15242420: 22846,
    15242422: 22847,
    15242431: 22848,
    15242630: 22849,
    15242639: 22850,
    15242640: 22851,
    15242641: 22852,
    15242642: 22853,
    15242643: 22854,
    15242646: 22855,
    15242649: 22856,
    15242652: 22857,
    15242653: 22858,
    15242654: 22859,
    15242655: 22860,
    15242656: 22861,
    15242657: 22862,
    15242658: 22863,
    15242660: 22864,
    15242667: 22865,
    15242671: 22866,
    15242681: 22867,
    15242682: 22868,
    15242683: 22869,
    15242685: 22870,
    15242687: 22871,
    15242881: 22872,
    15242885: 22873,
    15242886: 22874,
    15242889: 22875,
    15242891: 22876,
    15242892: 22877,
    15242895: 22878,
    15242899: 22879,
    15242904: 22880,
    15242909: 22881,
    15242911: 22882,
    15242912: 22883,
    15242914: 22884,
    15242917: 22885,
    15242919: 22886,
    15242932: 22887,
    15242934: 22888,
    15242935: 22889,
    15242936: 22890,
    15242940: 22891,
    15242941: 22892,
    15242942: 22893,
    15242943: 22894,
    15243138: 22895,
    15243143: 22896,
    15243146: 22897,
    15243147: 22898,
    15243150: 22899,
    15242925: 22900,
    15243160: 22901,
    15243162: 22902,
    15243167: 22903,
    15243168: 22904,
    15243174: 22905,
    15243176: 22906,
    15243181: 22907,
    15243187: 22908,
    15243190: 22909,
    15243196: 22910,
    15243199: 23073,
    15243392: 23074,
    15243396: 23075,
    15243397: 23076,
    15243405: 23077,
    15243406: 23078,
    15243408: 23079,
    15243409: 23080,
    15243410: 23081,
    15243416: 23082,
    15243417: 23083,
    15243419: 23084,
    15243422: 23085,
    15243425: 23086,
    15243431: 23087,
    15243433: 23088,
    15243446: 23089,
    15243448: 23090,
    15243450: 23091,
    15243452: 23092,
    15243453: 23093,
    15243648: 23094,
    15243650: 23095,
    15243654: 23096,
    15243666: 23097,
    15243667: 23098,
    15243670: 23099,
    15243671: 23100,
    15243672: 23101,
    15243673: 23102,
    15243677: 23103,
    15243680: 23104,
    15243681: 23105,
    15243682: 23106,
    15243683: 23107,
    15243684: 23108,
    15243689: 23109,
    15243692: 23110,
    15243695: 23111,
    15243701: 23112,
    15243702: 23113,
    15243703: 23114,
    15243706: 23115,
    15243917: 23116,
    15243921: 23117,
    15243926: 23118,
    15243928: 23119,
    15243930: 23120,
    15243932: 23121,
    15243937: 23122,
    15243942: 23123,
    15243943: 23124,
    15243944: 23125,
    15243949: 23126,
    15243953: 23127,
    15243955: 23128,
    15243956: 23129,
    15243957: 23130,
    15243959: 23131,
    15243960: 23132,
    15243961: 23133,
    15243967: 23134,
    15244160: 23135,
    15244161: 23136,
    15244163: 23137,
    15244165: 23138,
    15244177: 23139,
    15244178: 23140,
    15244181: 23141,
    15244183: 23142,
    15244186: 23143,
    15244188: 23144,
    15244192: 23145,
    15244195: 23146,
    15244197: 23147,
    15244199: 23148,
    15243912: 23149,
    15244218: 23150,
    15244220: 23151,
    15244221: 23152,
    15244420: 23153,
    15244421: 23154,
    15244423: 23155,
    15244427: 23156,
    15244430: 23157,
    15244431: 23158,
    15244432: 23159,
    15244435: 23160,
    15244436: 23161,
    15244441: 23162,
    15244446: 23163,
    15244447: 23164,
    15244449: 23165,
    15244451: 23166,
    15244456: 23329,
    15244462: 23330,
    15244463: 23331,
    15244465: 23332,
    15244466: 23333,
    15244473: 23334,
    15244474: 23335,
    15244476: 23336,
    15244477: 23337,
    15244478: 23338,
    15244672: 23339,
    15244675: 23340,
    15244677: 23341,
    15244685: 23342,
    15244696: 23343,
    15244701: 23344,
    15244705: 23345,
    15244708: 23346,
    15244709: 23347,
    15244719: 23348,
    15244721: 23349,
    15244722: 23350,
    15244731: 23351,
    15244931: 23352,
    15244932: 23353,
    15244933: 23354,
    15244934: 23355,
    15244935: 23356,
    15244936: 23357,
    15244937: 23358,
    15244939: 23359,
    15244940: 23360,
    15244944: 23361,
    15244947: 23362,
    15244949: 23363,
    15244951: 23364,
    15244952: 23365,
    15244953: 23366,
    15244958: 23367,
    15244960: 23368,
    15244963: 23369,
    15244967: 23370,
    15244972: 23371,
    15244973: 23372,
    15244974: 23373,
    15244977: 23374,
    15244981: 23375,
    15244990: 23376,
    15244991: 23377,
    15245185: 23378,
    15245192: 23379,
    15245193: 23380,
    15245194: 23381,
    15245198: 23382,
    15245205: 23383,
    15245206: 23384,
    15245209: 23385,
    15245210: 23386,
    15245212: 23387,
    15245215: 23388,
    15245218: 23389,
    15245219: 23390,
    15245220: 23391,
    15245226: 23392,
    15245227: 23393,
    15245229: 23394,
    15245233: 23395,
    15245235: 23396,
    15245240: 23397,
    15245242: 23398,
    15245247: 23399,
    15245441: 23400,
    15245443: 23401,
    15245446: 23402,
    15245449: 23403,
    15245450: 23404,
    15245451: 23405,
    15245456: 23406,
    15245465: 23407,
    15245458: 23408,
    15245459: 23409,
    15245460: 23410,
    15245464: 23411,
    15245466: 23412,
    15245467: 23413,
    15245468: 23414,
    15245470: 23415,
    15245471: 23416,
    15245480: 23417,
    15245485: 23418,
    15245486: 23419,
    15245488: 23420,
    15245490: 23421,
    15245493: 23422,
    15245498: 23585,
    15245500: 23586,
    15245697: 23587,
    15245699: 23588,
    15245701: 23589,
    15245704: 23590,
    15245705: 23591,
    15245706: 23592,
    15245707: 23593,
    15245710: 23594,
    15245713: 23595,
    15245717: 23596,
    15245718: 23597,
    15245720: 23598,
    15245722: 23599,
    15245724: 23600,
    15245727: 23601,
    15245728: 23602,
    15245732: 23603,
    15245737: 23604,
    15245745: 23605,
    15245753: 23606,
    15245755: 23607,
    15245952: 23608,
    15245976: 23609,
    15245978: 23610,
    15245979: 23611,
    15245980: 23612,
    15245983: 23613,
    15245984: 23614,
    15245992: 23615,
    15245994: 23616,
    15246010: 23617,
    15246013: 23618,
    15246014: 23619,
    15246208: 23620,
    15246218: 23621,
    15246219: 23622,
    15246220: 23623,
    15246221: 23624,
    15246222: 23625,
    15246225: 23626,
    15246226: 23627,
    15246227: 23628,
    15246235: 23629,
    15246238: 23630,
    15246247: 23631,
    15246255: 23632,
    15246256: 23633,
    15246257: 23634,
    15246261: 23635,
    15246263: 23636,
    15246465: 23637,
    15246470: 23638,
    15246477: 23639,
    15246478: 23640,
    15246479: 23641,
    15246485: 23642,
    15246486: 23643,
    15246488: 23644,
    15246489: 23645,
    15246490: 23646,
    15246492: 23647,
    15246496: 23648,
    15246502: 23649,
    15246503: 23650,
    15246504: 23651,
    15246512: 23652,
    15246513: 23653,
    15246514: 23654,
    15246517: 23655,
    15246521: 23656,
    15246522: 23657,
    15246526: 23658,
    15246720: 23659,
    15246722: 23660,
    15246725: 23661,
    15246726: 23662,
    15246729: 23663,
    15246735: 23664,
    15246738: 23665,
    15246743: 23666,
    15246746: 23667,
    15246747: 23668,
    15246748: 23669,
    15246753: 23670,
    15246754: 23671,
    15246755: 23672,
    15246763: 23673,
    15246766: 23674,
    15246768: 23675,
    15246771: 23676,
    15246773: 23677,
    15246778: 23678,
    15246779: 23841,
    15246780: 23842,
    15246781: 23843,
    15246985: 23844,
    15246989: 23845,
    15246992: 23846,
    15246996: 23847,
    15246997: 23848,
    15247003: 23849,
    15247004: 23850,
    15247007: 23851,
    15247008: 23852,
    15247013: 23853,
    15247024: 23854,
    15247028: 23855,
    15247029: 23856,
    15247030: 23857,
    15247031: 23858,
    15247036: 23859,
    15247252: 23860,
    15247253: 23861,
    15247254: 23862,
    15247255: 23863,
    15247256: 23864,
    15247269: 23865,
    15247273: 23866,
    15247275: 23867,
    15247277: 23868,
    15247281: 23869,
    15247283: 23870,
    15247286: 23871,
    15247289: 23872,
    15247293: 23873,
    15247295: 23874,
    15247492: 23875,
    15247493: 23876,
    15247495: 23877,
    15247503: 23878,
    15247505: 23879,
    15247506: 23880,
    15247508: 23881,
    15247509: 23882,
    15247518: 23883,
    15247520: 23884,
    15247522: 23885,
    15247524: 23886,
    15247526: 23887,
    15247531: 23888,
    15247532: 23889,
    15247535: 23890,
    15247541: 23891,
    15247543: 23892,
    15247549: 23893,
    15247550: 23894,
    15247744: 23895,
    15247747: 23896,
    15247749: 23897,
    15247751: 23898,
    15247753: 23899,
    15247757: 23900,
    15247758: 23901,
    15247763: 23902,
    15247766: 23903,
    15247767: 23904,
    15247768: 23905,
    15247772: 23906,
    15247773: 23907,
    15247777: 23908,
    15247781: 23909,
    15247783: 23910,
    15247797: 23911,
    15247798: 23912,
    15247799: 23913,
    15247801: 23914,
    15247802: 23915,
    15247803: 23916,
    15247806: 23917,
    15247807: 23918,
    15248e3: 23919,
    15248003: 23920,
    15248006: 23921,
    15248011: 23922,
    15248015: 23923,
    15248016: 23924,
    15248018: 23925,
    15248022: 23926,
    15248023: 23927,
    15248025: 23928,
    15248031: 23929,
    15248039: 23930,
    15248041: 23931,
    15248046: 23932,
    15248047: 23933,
    15248051: 23934,
    15248054: 24097,
    15248055: 24098,
    15248059: 24099,
    15248062: 24100,
    15248259: 24101,
    15248262: 24102,
    15248264: 24103,
    15248265: 24104,
    15248266: 24105,
    15248273: 24106,
    15248275: 24107,
    15248276: 24108,
    15248277: 24109,
    15248279: 24110,
    15248285: 24111,
    15248287: 24112,
    15248300: 24113,
    15248304: 24114,
    15248308: 24115,
    15248309: 24116,
    15248310: 24117,
    15248316: 24118,
    15248319: 24119,
    15248517: 24120,
    15248518: 24121,
    15248523: 24122,
    15248529: 24123,
    15248540: 24124,
    15248542: 24125,
    15248543: 24126,
    15248522: 24127,
    15248557: 24128,
    15248560: 24129,
    15248567: 24130,
    15248572: 24131,
    15248770: 24132,
    15248771: 24133,
    15248772: 24134,
    15248773: 24135,
    15248774: 24136,
    15248776: 24137,
    15248786: 24138,
    15248787: 24139,
    15248788: 24140,
    15248793: 24141,
    15248781: 24142,
    15248798: 24143,
    15248803: 24144,
    15248813: 24145,
    15248822: 24146,
    15248824: 24147,
    15248825: 24148,
    15248828: 24149,
    15248830: 24150,
    15249025: 24151,
    15249028: 24152,
    15249029: 24153,
    15249035: 24154,
    15249037: 24155,
    15249039: 24156,
    15249044: 24157,
    15249045: 24158,
    15249052: 24159,
    15249054: 24160,
    15249055: 24161,
    15249592: 24162,
    15249593: 24163,
    15249597: 24164,
    15249598: 24165,
    15249797: 24166,
    15249799: 24167,
    15249801: 24168,
    15249803: 24169,
    15249807: 24170,
    15249809: 24171,
    15249811: 24172,
    15249812: 24173,
    15249815: 24174,
    15249816: 24175,
    15249819: 24176,
    15249821: 24177,
    15249817: 24178,
    15249827: 24179,
    15249828: 24180,
    15249830: 24181,
    15249832: 24182,
    15249833: 24183,
    15249837: 24184,
    15249843: 24185,
    15249845: 24186,
    15249846: 24187,
    15249851: 24188,
    15249854: 24189,
    15250054: 24190,
    15250055: 24353,
    15250059: 24354,
    15250064: 24355,
    15250066: 24356,
    15250067: 24357,
    15250073: 24358,
    15250075: 24359,
    15250076: 24360,
    15250084: 24361,
    15250105: 24362,
    15250106: 24363,
    15250309: 24364,
    15250310: 24365,
    15250313: 24366,
    15250315: 24367,
    15250319: 24368,
    15250326: 24369,
    15250325: 24370,
    15250329: 24371,
    15250333: 24372,
    15250337: 24373,
    15250344: 24374,
    15250348: 24375,
    15250351: 24376,
    15250352: 24377,
    15250354: 24378,
    15250357: 24379,
    15250359: 24380,
    15250360: 24381,
    15250366: 24382,
    15250367: 24383,
    15250561: 24384,
    15250563: 24385,
    15250569: 24386,
    15250578: 24387,
    15250583: 24388,
    15250587: 24389,
    15250853: 24390,
    15250857: 24391,
    15250860: 24392,
    15250862: 24393,
    15250879: 24394,
    15251074: 24395,
    15251076: 24396,
    15251080: 24397,
    15251085: 24398,
    15251088: 24399,
    15251089: 24400,
    15251093: 24401,
    15251102: 24402,
    15251103: 24403,
    15251104: 24404,
    15251110: 24405,
    15251115: 24406,
    15251116: 24407,
    15251119: 24408,
    15251122: 24409,
    15251125: 24410,
    15251127: 24411,
    15251129: 24412,
    15251131: 24413,
    15251328: 24414,
    15251333: 24415,
    15251334: 24416,
    15251335: 24417,
    15251336: 24418,
    15251338: 24419,
    15251342: 24420,
    15251345: 24421,
    15251348: 24422,
    15251349: 24423,
    15251351: 24424,
    15251353: 24425,
    15251364: 24426,
    15251365: 24427,
    15251367: 24428,
    15251372: 24429,
    15251376: 24430,
    15251132: 24431,
    15251377: 24432,
    15251378: 24433,
    15251380: 24434,
    15251389: 24435,
    15251585: 24436,
    15251588: 24437,
    15251589: 24438,
    15251590: 24439,
    15251595: 24440,
    15251601: 24441,
    15251604: 24442,
    15251606: 24443,
    15251616: 24444,
    15251617: 24445,
    15251618: 24446,
    15251619: 24609,
    15251622: 24610,
    15251623: 24611,
    15251633: 24612,
    15251635: 24613,
    15251638: 24614,
    15251639: 24615,
    15251640: 24616,
    15251641: 24617,
    15251645: 24618,
    15251840: 24619,
    15251841: 24620,
    15251851: 24621,
    15251853: 24622,
    15251854: 24623,
    15251855: 24624,
    15251860: 24625,
    15251867: 24626,
    15251868: 24627,
    15251869: 24628,
    15251870: 24629,
    15251873: 24630,
    15251874: 24631,
    15251881: 24632,
    15251884: 24633,
    15251885: 24634,
    15251887: 24635,
    15251888: 24636,
    15251889: 24637,
    15251897: 24638,
    15251898: 24639,
    15251899: 24640,
    15252098: 24641,
    15252099: 24642,
    15252105: 24643,
    15252112: 24644,
    15252114: 24645,
    15252117: 24646,
    15252122: 24647,
    15252123: 24648,
    15252125: 24649,
    15252126: 24650,
    15252130: 24651,
    15252135: 24652,
    15252137: 24653,
    15252141: 24654,
    15252142: 24655,
    15252147: 24656,
    15252149: 24657,
    15252154: 24658,
    15252155: 24659,
    15252352: 24660,
    15252353: 24661,
    15252355: 24662,
    15252356: 24663,
    15252359: 24664,
    15252367: 24665,
    15252369: 24666,
    15252372: 24667,
    15252380: 24668,
    15252392: 24669,
    15252398: 24670,
    15252400: 24671,
    15252401: 24672,
    15252407: 24673,
    15252409: 24674,
    15252410: 24675,
    15252397: 24676,
    15252608: 24677,
    15252610: 24678,
    15252615: 24679,
    15252616: 24680,
    15252623: 24681,
    15252624: 24682,
    15252630: 24683,
    15252631: 24684,
    15252632: 24685,
    15252638: 24686,
    15252640: 24687,
    15252641: 24688,
    15252643: 24689,
    15252645: 24690,
    15252647: 24691,
    15252648: 24692,
    15252652: 24693,
    15252653: 24694,
    15252654: 24695,
    15252660: 24696,
    15252661: 24697,
    15252662: 24698,
    15252663: 24699,
    15252666: 24700,
    15252864: 24701,
    15252865: 24702,
    15252867: 24865,
    15252871: 24866,
    15252879: 24867,
    15252881: 24868,
    15252882: 24869,
    15252883: 24870,
    15252884: 24871,
    15252885: 24872,
    15252888: 24873,
    15252893: 24874,
    15252894: 24875,
    15252901: 24876,
    15253149: 24877,
    15253152: 24878,
    15253153: 24879,
    15253156: 24880,
    15253157: 24881,
    15253158: 24882,
    15253173: 24883,
    15253174: 24884,
    15253176: 24885,
    15253182: 24886,
    15253376: 24887,
    15253377: 24888,
    15253382: 24889,
    15253386: 24890,
    15253387: 24891,
    15253389: 24892,
    15253392: 24893,
    15253394: 24894,
    15253395: 24895,
    15253397: 24896,
    15253408: 24897,
    15253411: 24898,
    15253412: 24899,
    15253416: 24900,
    15253422: 24901,
    15253425: 24902,
    15253429: 24903,
    15253430: 24904,
    15253435: 24905,
    15253438: 24906,
    15302786: 24907,
    15302788: 24908,
    15302792: 24909,
    15302796: 24910,
    15302808: 24911,
    15302811: 24912,
    15302824: 24913,
    15302825: 24914,
    15302831: 24915,
    15302826: 24916,
    15302828: 24917,
    15302829: 24918,
    15302835: 24919,
    15302836: 24920,
    15302839: 24921,
    15302847: 24922,
    15303043: 24923,
    15303044: 24924,
    15303052: 24925,
    15303067: 24926,
    15303069: 24927,
    15303074: 24928,
    15303078: 24929,
    15303079: 24930,
    15303084: 24931,
    15303088: 24932,
    15303092: 24933,
    15303097: 24934,
    15303301: 24935,
    15303304: 24936,
    15303307: 24937,
    15303308: 24938,
    15303310: 24939,
    15303312: 24940,
    15303317: 24941,
    15303319: 24942,
    15303320: 24943,
    15303321: 24944,
    15303323: 24945,
    15303328: 24946,
    15303329: 24947,
    15303330: 24948,
    15303333: 24949,
    15303344: 24950,
    15303346: 24951,
    15303347: 24952,
    15303348: 24953,
    15303350: 24954,
    15303357: 24955,
    15303564: 24956,
    15303358: 24957,
    15303555: 24958,
    15303556: 25121,
    15303557: 25122,
    15303559: 25123,
    15303560: 25124,
    15303573: 25125,
    15303575: 25126,
    15303576: 25127,
    15303577: 25128,
    15303580: 25129,
    15303581: 25130,
    15303583: 25131,
    15303589: 25132,
    15303570: 25133,
    15303606: 25134,
    15303595: 25135,
    15303599: 25136,
    15303600: 25137,
    15303604: 25138,
    15303614: 25139,
    15303615: 25140,
    15303808: 25141,
    15303812: 25142,
    15303813: 25143,
    15303814: 25144,
    15303816: 25145,
    15303821: 25146,
    15303824: 25147,
    15303828: 25148,
    15303830: 25149,
    15303831: 25150,
    15303832: 25151,
    15303834: 25152,
    15303836: 25153,
    15303838: 25154,
    15303840: 25155,
    15303845: 25156,
    15303842: 25157,
    15303843: 25158,
    15303847: 25159,
    15303849: 25160,
    15303854: 25161,
    15303855: 25162,
    15303857: 25163,
    15303860: 25164,
    15303862: 25165,
    15303863: 25166,
    15303865: 25167,
    15303866: 25168,
    15303868: 25169,
    15303869: 25170,
    15304067: 25171,
    15304071: 25172,
    15304072: 25173,
    15304079: 25174,
    15304083: 25175,
    15304087: 25176,
    15304089: 25177,
    15304090: 25178,
    15304091: 25179,
    15304097: 25180,
    15304100: 25181,
    15304103: 25182,
    15304109: 25183,
    15304116: 25184,
    15304121: 25185,
    15304122: 25186,
    15304123: 25187,
    15304321: 25188,
    15304323: 25189,
    15304325: 25190,
    15304326: 25191,
    15304330: 25192,
    15304334: 25193,
    15304337: 25194,
    15304339: 25195,
    15304340: 25196,
    15304341: 25197,
    15304344: 25198,
    15304350: 25199,
    15304353: 25200,
    15304358: 25201,
    15304360: 25202,
    15304364: 25203,
    15304365: 25204,
    15304366: 25205,
    15304368: 25206,
    15304369: 25207,
    15304370: 25208,
    15304371: 25209,
    15304374: 25210,
    15304379: 25211,
    15304380: 25212,
    15304381: 25213,
    15304383: 25214,
    15304578: 25377,
    15304579: 25378,
    15304581: 25379,
    15304595: 25380,
    15304596: 25381,
    15304599: 25382,
    15304601: 25383,
    15304602: 25384,
    15304606: 25385,
    15304612: 25386,
    15304613: 25387,
    15304617: 25388,
    15304618: 25389,
    15304620: 25390,
    15304621: 25391,
    15304622: 25392,
    15304623: 25393,
    15304624: 25394,
    15304625: 25395,
    15304631: 25396,
    15304633: 25397,
    15304635: 25398,
    15304637: 25399,
    15304832: 25400,
    15304833: 25401,
    15304836: 25402,
    15304837: 25403,
    15304838: 25404,
    15304839: 25405,
    15304841: 25406,
    15304842: 25407,
    15304844: 25408,
    15304848: 25409,
    15304850: 25410,
    15304851: 25411,
    15304854: 25412,
    15304856: 25413,
    15304860: 25414,
    15304861: 25415,
    15304867: 25416,
    15304868: 25417,
    15304869: 25418,
    15304870: 25419,
    15304872: 25420,
    15304878: 25421,
    15304879: 25422,
    15304880: 25423,
    15304883: 25424,
    15304885: 25425,
    15304886: 25426,
    15304888: 25427,
    15304889: 25428,
    15304890: 25429,
    15304892: 25430,
    15304894: 25431,
    15305088: 25432,
    15305090: 25433,
    15305091: 25434,
    15305094: 25435,
    15305095: 25436,
    15305098: 25437,
    15305101: 25438,
    15305102: 25439,
    15305103: 25440,
    15305105: 25441,
    15305112: 25442,
    15305113: 25443,
    15305116: 25444,
    15305117: 25445,
    15305120: 25446,
    15305121: 25447,
    15305125: 25448,
    15305127: 25449,
    15305128: 25450,
    15305129: 25451,
    15305134: 25452,
    15305135: 25453,
    15305136: 25454,
    15305141: 25455,
    15305142: 25456,
    15305143: 25457,
    15305144: 25458,
    15305145: 25459,
    15305147: 25460,
    15305148: 25461,
    15305149: 25462,
    15305151: 25463,
    15305352: 25464,
    15305353: 25465,
    15305354: 25466,
    15305357: 25467,
    15305358: 25468,
    15305362: 25469,
    15305367: 25470,
    15305369: 25633,
    15305375: 25634,
    15305376: 25635,
    15305380: 25636,
    15305381: 25637,
    15305383: 25638,
    15305384: 25639,
    15305387: 25640,
    15305391: 25641,
    15305394: 25642,
    15305398: 25643,
    15305400: 25644,
    15305402: 25645,
    15305403: 25646,
    15305404: 25647,
    15305405: 25648,
    15305407: 25649,
    15305600: 25650,
    15305601: 25651,
    15305602: 25652,
    15305603: 25653,
    15305605: 25654,
    15305606: 25655,
    15305607: 25656,
    15305608: 25657,
    15305611: 25658,
    15305612: 25659,
    15305613: 25660,
    15305614: 25661,
    15305616: 25662,
    15305619: 25663,
    15305621: 25664,
    15305623: 25665,
    15305624: 25666,
    15305625: 25667,
    15305628: 25668,
    15305629: 25669,
    15305631: 25670,
    15305632: 25671,
    15305633: 25672,
    15305635: 25673,
    15305637: 25674,
    15305639: 25675,
    15305640: 25676,
    15305644: 25677,
    15305646: 25678,
    15305648: 25679,
    15305657: 25680,
    15305659: 25681,
    15305663: 25682,
    15305856: 25683,
    15305858: 25684,
    15305864: 25685,
    15305869: 25686,
    15305873: 25687,
    15305876: 25688,
    15305877: 25689,
    15305884: 25690,
    15305885: 25691,
    15305886: 25692,
    15305887: 25693,
    15305889: 25694,
    15305892: 25695,
    15305893: 25696,
    15305895: 25697,
    15305897: 25698,
    15305898: 25699,
    15305907: 25700,
    15305908: 25701,
    15305910: 25702,
    15305911: 25703,
    15306119: 25704,
    15306120: 25705,
    15306121: 25706,
    15306128: 25707,
    15306129: 25708,
    15306130: 25709,
    15306133: 25710,
    15306135: 25711,
    15306136: 25712,
    15306138: 25713,
    15306142: 25714,
    15306148: 25715,
    15306149: 25716,
    15306151: 25717,
    15306153: 25718,
    15306154: 25719,
    15306157: 25720,
    15306159: 25721,
    15306160: 25722,
    15306161: 25723,
    15306163: 25724,
    15306164: 25725,
    15306166: 25726,
    15306170: 25889,
    15306173: 25890,
    15306175: 25891,
    15306368: 25892,
    15306369: 25893,
    15306370: 25894,
    15306376: 25895,
    15306378: 25896,
    15306379: 25897,
    15306381: 25898,
    15306383: 25899,
    15306386: 25900,
    15306389: 25901,
    15306392: 25902,
    15306395: 25903,
    15306398: 25904,
    15306401: 25905,
    15306403: 25906,
    15306404: 25907,
    15306406: 25908,
    15306408: 25909,
    15306411: 25910,
    15306420: 25911,
    15306421: 25912,
    15306422: 25913,
    15306426: 25914,
    15306409: 25915,
    15306625: 25916,
    15306628: 25917,
    15306629: 25918,
    15306630: 25919,
    15306631: 25920,
    15306633: 25921,
    15306634: 25922,
    15306635: 25923,
    15306636: 25924,
    15306637: 25925,
    15306643: 25926,
    15306649: 25927,
    15306652: 25928,
    15306654: 25929,
    15306655: 25930,
    15306658: 25931,
    15306662: 25932,
    15306663: 25933,
    15306681: 25934,
    15306679: 25935,
    15306680: 25936,
    15306682: 25937,
    15306683: 25938,
    15306685: 25939,
    15306881: 25940,
    15306882: 25941,
    15306884: 25942,
    15306888: 25943,
    15306889: 25944,
    15306893: 25945,
    15306894: 25946,
    15306895: 25947,
    15306901: 25948,
    15306902: 25949,
    15306903: 25950,
    15306911: 25951,
    15306926: 25952,
    15306927: 25953,
    15306929: 25954,
    15306930: 25955,
    15306931: 25956,
    15306932: 25957,
    15306939: 25958,
    15306943: 25959,
    15306941: 25960,
    15307139: 25961,
    15307141: 25962,
    15307144: 25963,
    15307146: 25964,
    15307148: 25965,
    15307157: 25966,
    15307161: 25967,
    15307164: 25968,
    15307167: 25969,
    15307169: 25970,
    15307171: 25971,
    15307176: 25972,
    15307179: 25973,
    15307181: 25974,
    15307182: 25975,
    15307183: 25976,
    15307185: 25977,
    15307186: 25978,
    15307396: 25979,
    15307395: 25980,
    15308216: 25981,
    15308217: 25982,
    15308222: 26145,
    15308420: 26146,
    15308424: 26147,
    15308428: 26148,
    15308429: 26149,
    15308430: 26150,
    15308445: 26151,
    15308446: 26152,
    15308447: 26153,
    15308449: 26154,
    15308454: 26155,
    15308457: 26156,
    15308459: 26157,
    15308460: 26158,
    15308468: 26159,
    15308470: 26160,
    15308474: 26161,
    15308477: 26162,
    15308479: 26163,
    15308678: 26164,
    15308680: 26165,
    15308681: 26166,
    15308683: 26167,
    15308688: 26168,
    15308689: 26169,
    15308690: 26170,
    15308691: 26171,
    15308697: 26172,
    15308698: 26173,
    15308701: 26174,
    15308702: 26175,
    15308703: 26176,
    15308704: 26177,
    15308708: 26178,
    15308710: 26179,
    15308957: 26180,
    15308958: 26181,
    15308962: 26182,
    15308964: 26183,
    15308965: 26184,
    15308966: 26185,
    15308972: 26186,
    15308977: 26187,
    15308979: 26188,
    15308983: 26189,
    15308984: 26190,
    15308985: 26191,
    15308986: 26192,
    15308988: 26193,
    15308989: 26194,
    15309185: 26195,
    15309202: 26196,
    15309204: 26197,
    15309206: 26198,
    15309207: 26199,
    15309208: 26200,
    15309217: 26201,
    15309230: 26202,
    15309236: 26203,
    15309243: 26204,
    15309244: 26205,
    15309246: 26206,
    15309247: 26207,
    15309441: 26208,
    15309442: 26209,
    15309443: 26210,
    15309444: 26211,
    15309449: 26212,
    15309457: 26213,
    15309462: 26214,
    15309466: 26215,
    15309469: 26216,
    15309471: 26217,
    15309476: 26218,
    15309477: 26219,
    15309478: 26220,
    15309481: 26221,
    15309486: 26222,
    15309487: 26223,
    15309491: 26224,
    15309498: 26225,
    15309706: 26226,
    15309714: 26227,
    15054514: 26228,
    15309720: 26229,
    15309722: 26230,
    15309725: 26231,
    15309726: 26232,
    15309727: 26233,
    15309737: 26234,
    15309743: 26235,
    15309745: 26236,
    15309754: 26237,
    15309954: 26238,
    15309955: 26401,
    15309957: 26402,
    15309961: 26403,
    15309978: 26404,
    15309979: 26405,
    15309981: 26406,
    15309985: 26407,
    15309986: 26408,
    15309987: 26409,
    15309992: 26410,
    15310001: 26411,
    15310003: 26412,
    15310209: 26413,
    15310211: 26414,
    15310218: 26415,
    15310222: 26416,
    15310223: 26417,
    15310229: 26418,
    15310231: 26419,
    15310232: 26420,
    15310234: 26421,
    15310235: 26422,
    15310243: 26423,
    15310247: 26424,
    15310250: 26425,
    15310254: 26426,
    15310259: 26427,
    15310262: 26428,
    15310263: 26429,
    15310264: 26430,
    15310267: 26431,
    15310269: 26432,
    15310271: 26433,
    15310464: 26434,
    15310473: 26435,
    15310485: 26436,
    15310486: 26437,
    15310487: 26438,
    15310489: 26439,
    15310490: 26440,
    15310494: 26441,
    15310495: 26442,
    15310498: 26443,
    15310508: 26444,
    15310510: 26445,
    15310513: 26446,
    15310514: 26447,
    15310517: 26448,
    15310518: 26449,
    15310520: 26450,
    15310521: 26451,
    15310522: 26452,
    15310524: 26453,
    15310526: 26454,
    15310527: 26455,
    15310721: 26456,
    15310724: 26457,
    15310725: 26458,
    15310727: 26459,
    15310729: 26460,
    15310730: 26461,
    15310732: 26462,
    15310733: 26463,
    15310734: 26464,
    15310736: 26465,
    15310737: 26466,
    15310740: 26467,
    15310743: 26468,
    15310744: 26469,
    15310745: 26470,
    15310749: 26471,
    15310750: 26472,
    15310752: 26473,
    15310747: 26474,
    15310753: 26475,
    15310756: 26476,
    15310767: 26477,
    15310769: 26478,
    15310772: 26479,
    15310775: 26480,
    15310776: 26481,
    15310778: 26482,
    15310983: 26483,
    15310986: 26484,
    15311001: 26485,
    15310989: 26486,
    15310990: 26487,
    15310996: 26488,
    15310998: 26489,
    15311004: 26490,
    15311006: 26491,
    15311008: 26492,
    15311011: 26493,
    15311014: 26494,
    15311019: 26657,
    15311022: 26658,
    15311023: 26659,
    15311024: 26660,
    15311026: 26661,
    15311027: 26662,
    15311029: 26663,
    15311013: 26664,
    15311038: 26665,
    15311236: 26666,
    15311239: 26667,
    15311242: 26668,
    15311249: 26669,
    15311250: 26670,
    15311251: 26671,
    15311254: 26672,
    15311255: 26673,
    15311257: 26674,
    15311258: 26675,
    15311266: 26676,
    15311267: 26677,
    15311269: 26678,
    15311270: 26679,
    15311274: 26680,
    15311276: 26681,
    15311531: 26682,
    15311533: 26683,
    15311534: 26684,
    15311536: 26685,
    15311540: 26686,
    15311543: 26687,
    15311544: 26688,
    15311546: 26689,
    15311547: 26690,
    15311551: 26691,
    15311746: 26692,
    15311749: 26693,
    15311752: 26694,
    15311756: 26695,
    15311777: 26696,
    15311779: 26697,
    15311781: 26698,
    15311782: 26699,
    15311783: 26700,
    15311786: 26701,
    15311795: 26702,
    15311798: 26703,
    15312002: 26704,
    15312007: 26705,
    15312008: 26706,
    15312017: 26707,
    15312021: 26708,
    15312022: 26709,
    15312023: 26710,
    15312026: 26711,
    15312027: 26712,
    15312028: 26713,
    15312031: 26714,
    15312034: 26715,
    15312038: 26716,
    15312039: 26717,
    15312043: 26718,
    15312049: 26719,
    15312050: 26720,
    15312051: 26721,
    15312052: 26722,
    15312053: 26723,
    15312057: 26724,
    15312058: 26725,
    15312059: 26726,
    15312060: 26727,
    15312256: 26728,
    15312257: 26729,
    15312262: 26730,
    15312263: 26731,
    15312264: 26732,
    15312269: 26733,
    15312270: 26734,
    15312276: 26735,
    15312280: 26736,
    15312281: 26737,
    15312283: 26738,
    15312284: 26739,
    15312286: 26740,
    15312287: 26741,
    15312288: 26742,
    15312539: 26743,
    15312541: 26744,
    15312543: 26745,
    15312550: 26746,
    15312560: 26747,
    15312561: 26748,
    15312562: 26749,
    15312565: 26750,
    15312569: 26913,
    15312570: 26914,
    15312573: 26915,
    15312575: 26916,
    15312771: 26917,
    15312777: 26918,
    15312787: 26919,
    15312788: 26920,
    15312793: 26921,
    15312794: 26922,
    15312796: 26923,
    15312798: 26924,
    15312807: 26925,
    15312810: 26926,
    15312811: 26927,
    15312812: 26928,
    15312816: 26929,
    15312820: 26930,
    15312821: 26931,
    15312825: 26932,
    15312829: 26933,
    15312830: 26934,
    15313026: 26935,
    15313027: 26936,
    15313028: 26937,
    15313035: 26938,
    15313036: 26939,
    15313040: 26940,
    15313041: 26941,
    15313046: 26942,
    15313054: 26943,
    15313056: 26944,
    15313058: 26945,
    15313059: 26946,
    15313060: 26947,
    15313063: 26948,
    15313069: 26949,
    15313070: 26950,
    15313075: 26951,
    15313077: 26952,
    15313078: 26953,
    15313080: 26954,
    15313287: 26955,
    15313281: 26956,
    15313284: 26957,
    15313290: 26958,
    15313291: 26959,
    15313292: 26960,
    15313294: 26961,
    15313297: 26962,
    15313300: 26963,
    15313302: 26964,
    15313309: 26965,
    15313578: 26966,
    15313580: 26967,
    15313582: 26968,
    15313583: 26969,
    15313586: 26970,
    15313588: 26971,
    15313589: 26972,
    15313590: 26973,
    15313593: 26974,
    15313595: 26975,
    15313598: 26976,
    15313599: 26977,
    15313793: 26978,
    15313795: 26979,
    15313798: 26980,
    15313800: 26981,
    15313806: 26982,
    15313808: 26983,
    15313810: 26984,
    15313813: 26985,
    15313814: 26986,
    15313815: 26987,
    15313819: 26988,
    15313820: 26989,
    15313824: 26990,
    15313828: 26991,
    15313829: 26992,
    15313831: 26993,
    15313833: 26994,
    15313836: 26995,
    15313842: 26996,
    15313843: 26997,
    15313845: 26998,
    15313849: 26999,
    15313850: 27e3,
    15313853: 27001,
    15313855: 27002,
    15314048: 27003,
    15314049: 27004,
    15314050: 27005,
    15314051: 27006,
    15314052: 27169,
    15314053: 27170,
    15314056: 27171,
    15314057: 27172,
    15314059: 27173,
    15314060: 27174,
    15314061: 27175,
    15314062: 27176,
    15314064: 27177,
    15314066: 27178,
    15314070: 27179,
    15314073: 27180,
    15314075: 27181,
    15314076: 27182,
    15314080: 27183,
    15314086: 27184,
    15314091: 27185,
    15314093: 27186,
    15314099: 27187,
    15314100: 27188,
    15314101: 27189,
    15314103: 27190,
    15314105: 27191,
    15314106: 27192,
    15314109: 27193,
    15314312: 27194,
    15314315: 27195,
    15314316: 27196,
    15314325: 27197,
    15314326: 27198,
    15314327: 27199,
    15314331: 27200,
    15314334: 27201,
    15314337: 27202,
    15314339: 27203,
    15314341: 27204,
    15314342: 27205,
    15314344: 27206,
    15314346: 27207,
    15314347: 27208,
    15314348: 27209,
    15314349: 27210,
    15314350: 27211,
    15314355: 27212,
    15314357: 27213,
    15314359: 27214,
    15314360: 27215,
    15314361: 27216,
    15314367: 27217,
    15314560: 27218,
    15314564: 27219,
    15314565: 27220,
    15314566: 27221,
    15314567: 27222,
    15314569: 27223,
    15314570: 27224,
    15314571: 27225,
    15314573: 27226,
    15314575: 27227,
    15314576: 27228,
    15314580: 27229,
    15314586: 27230,
    15314589: 27231,
    15314590: 27232,
    15314598: 27233,
    15314599: 27234,
    15314601: 27235,
    15314604: 27236,
    15314608: 27237,
    15314609: 27238,
    15314610: 27239,
    15314615: 27240,
    15314616: 27241,
    15314619: 27242,
    15314620: 27243,
    15314622: 27244,
    15314623: 27245,
    15314817: 27246,
    15314823: 27247,
    15314824: 27248,
    15314830: 27249,
    15314832: 27250,
    15314839: 27251,
    15314840: 27252,
    15314845: 27253,
    15314847: 27254,
    15314853: 27255,
    15314855: 27256,
    15314858: 27257,
    15314859: 27258,
    15314863: 27259,
    15314867: 27260,
    15314871: 27261,
    15314872: 27262,
    15314873: 27425,
    15314874: 27426,
    15314877: 27427,
    15314879: 27428,
    15315072: 27429,
    15315074: 27430,
    15315083: 27431,
    15315087: 27432,
    15315089: 27433,
    15315094: 27434,
    15315096: 27435,
    15315097: 27436,
    15315098: 27437,
    15315100: 27438,
    15315102: 27439,
    15315106: 27440,
    15315107: 27441,
    15315110: 27442,
    15315111: 27443,
    15315112: 27444,
    15315113: 27445,
    15315114: 27446,
    15315121: 27447,
    15315125: 27448,
    15315126: 27449,
    15315127: 27450,
    15315133: 27451,
    15315329: 27452,
    15315331: 27453,
    15315332: 27454,
    15315333: 27455,
    15315337: 27456,
    15315338: 27457,
    15315342: 27458,
    15315343: 27459,
    15315344: 27460,
    15315347: 27461,
    15315348: 27462,
    15315350: 27463,
    15315352: 27464,
    15315355: 27465,
    15315357: 27466,
    15315358: 27467,
    15315359: 27468,
    15315363: 27469,
    15315369: 27470,
    15315370: 27471,
    15315356: 27472,
    15315371: 27473,
    15315368: 27474,
    15315374: 27475,
    15315376: 27476,
    15315378: 27477,
    15315381: 27478,
    15315383: 27479,
    15315387: 27480,
    15315878: 27481,
    15315890: 27482,
    15315895: 27483,
    15315897: 27484,
    15316107: 27485,
    15316098: 27486,
    15316113: 27487,
    15316119: 27488,
    15316120: 27489,
    15316124: 27490,
    15316125: 27491,
    15316126: 27492,
    15316143: 27493,
    15316144: 27494,
    15316146: 27495,
    15316147: 27496,
    15316148: 27497,
    15316154: 27498,
    15316156: 27499,
    15316357: 27500,
    15316157: 27501,
    15316354: 27502,
    15316355: 27503,
    15316359: 27504,
    15316362: 27505,
    15316371: 27506,
    15316372: 27507,
    15316383: 27508,
    15316387: 27509,
    15316386: 27510,
    15316389: 27511,
    15316393: 27512,
    15316394: 27513,
    15316395: 27514,
    15316400: 27515,
    15316406: 27516,
    15316407: 27517,
    15316411: 27518,
    15316412: 27681,
    15316414: 27682,
    15316611: 27683,
    15316612: 27684,
    15316614: 27685,
    15316618: 27686,
    15316621: 27687,
    15316622: 27688,
    15316626: 27689,
    15316627: 27690,
    15316629: 27691,
    15316630: 27692,
    15316631: 27693,
    15316632: 27694,
    15316641: 27695,
    15316650: 27696,
    15316652: 27697,
    15316654: 27698,
    15316657: 27699,
    15316661: 27700,
    15316665: 27701,
    15316668: 27702,
    15316671: 27703,
    15316867: 27704,
    15316871: 27705,
    15316873: 27706,
    15316874: 27707,
    15316884: 27708,
    15316885: 27709,
    15316886: 27710,
    15316887: 27711,
    15316890: 27712,
    15316894: 27713,
    15316895: 27714,
    15316896: 27715,
    15316901: 27716,
    15316903: 27717,
    15316905: 27718,
    15316907: 27719,
    15316910: 27720,
    15316912: 27721,
    15316915: 27722,
    15316916: 27723,
    15316926: 27724,
    15317130: 27725,
    15317122: 27726,
    15317127: 27727,
    15317134: 27728,
    15317136: 27729,
    15317137: 27730,
    15317138: 27731,
    15317141: 27732,
    15317142: 27733,
    15317145: 27734,
    15317148: 27735,
    15317149: 27736,
    15317434: 27737,
    15317435: 27738,
    15317436: 27739,
    15317632: 27740,
    15317634: 27741,
    15317635: 27742,
    15317636: 27743,
    15317637: 27744,
    15317639: 27745,
    15317646: 27746,
    15317647: 27747,
    15317654: 27748,
    15317656: 27749,
    15317659: 27750,
    15317662: 27751,
    15317668: 27752,
    15317672: 27753,
    15317676: 27754,
    15317678: 27755,
    15317679: 27756,
    15317680: 27757,
    15317683: 27758,
    15317684: 27759,
    15317685: 27760,
    15317894: 27761,
    15317896: 27762,
    15317899: 27763,
    15317909: 27764,
    15317919: 27765,
    15317924: 27766,
    15317927: 27767,
    15317932: 27768,
    15317933: 27769,
    15317934: 27770,
    15317936: 27771,
    15317937: 27772,
    15317938: 27773,
    15317941: 27774,
    15317944: 27937,
    15317951: 27938,
    15318146: 27939,
    15318147: 27940,
    15318153: 27941,
    15318159: 27942,
    15318160: 27943,
    15318161: 27944,
    15318162: 27945,
    15318164: 27946,
    15318166: 27947,
    15318167: 27948,
    15318169: 27949,
    15318170: 27950,
    15318171: 27951,
    15318175: 27952,
    15318178: 27953,
    15318182: 27954,
    15318186: 27955,
    15318187: 27956,
    15318191: 27957,
    15318193: 27958,
    15318194: 27959,
    15318196: 27960,
    15318199: 27961,
    15318201: 27962,
    15318202: 27963,
    15318204: 27964,
    15318205: 27965,
    15318207: 27966,
    15318401: 27967,
    15318403: 27968,
    15318404: 27969,
    15318405: 27970,
    15318406: 27971,
    15318407: 27972,
    15318419: 27973,
    15318421: 27974,
    15318422: 27975,
    15318423: 27976,
    15318424: 27977,
    15318426: 27978,
    15318429: 27979,
    15318430: 27980,
    15318440: 27981,
    15318441: 27982,
    15318445: 27983,
    15318446: 27984,
    15318447: 27985,
    15318448: 27986,
    15318449: 27987,
    15318451: 27988,
    15318453: 27989,
    15318458: 27990,
    15318461: 27991,
    15318671: 27992,
    15318672: 27993,
    15318673: 27994,
    15318674: 27995,
    15318676: 27996,
    15318678: 27997,
    15318679: 27998,
    15318686: 27999,
    15318689: 28e3,
    15318690: 28001,
    15318691: 28002,
    15318693: 28003,
    //FIXME: mojibake
    14909596: 8513
  };
  var JIS_TO_UTF8_TABLE = null;
  var jisToUtf8Table = JIS_TO_UTF8_TABLE;
  var JISX0212_TO_UTF8_TABLE = null;
  var jisx0212ToUtf8Table = JISX0212_TO_UTF8_TABLE;
  encodingTable.UTF8_TO_JIS_TABLE = utf8ToJisTable;
  encodingTable.UTF8_TO_JISX0212_TABLE = utf8ToJisx0212Table;
  encodingTable.JIS_TO_UTF8_TABLE = jisToUtf8Table;
  encodingTable.JISX0212_TO_UTF8_TABLE = jisx0212ToUtf8Table;
  var hasRequiredConfig;
  function requireConfig() {
    if (hasRequiredConfig)
      return config$2;
    hasRequiredConfig = 1;
    var util2 = requireUtil();
    var EncodingTable2 = encodingTable;
    config$2.FALLBACK_CHARACTER = 63;
    var HAS_TYPED = config$2.HAS_TYPED = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined";
    var CAN_CHARCODE_APPLY = false;
    var CAN_CHARCODE_APPLY_TYPED = false;
    try {
      if (String.fromCharCode.apply(null, [97]) === "a") {
        CAN_CHARCODE_APPLY = true;
      }
    } catch (e) {
    }
    if (HAS_TYPED) {
      try {
        if (String.fromCharCode.apply(null, new Uint8Array([97])) === "a") {
          CAN_CHARCODE_APPLY_TYPED = true;
        }
      } catch (e) {
      }
    }
    config$2.CAN_CHARCODE_APPLY = CAN_CHARCODE_APPLY;
    config$2.CAN_CHARCODE_APPLY_TYPED = CAN_CHARCODE_APPLY_TYPED;
    config$2.APPLY_BUFFER_SIZE = 65533;
    config$2.APPLY_BUFFER_SIZE_OK = null;
    var EncodingNames = config$2.EncodingNames = {
      UTF32: {
        order: 0
      },
      UTF32BE: {
        alias: ["UCS4"]
      },
      UTF32LE: null,
      UTF16: {
        order: 1
      },
      UTF16BE: {
        alias: ["UCS2"]
      },
      UTF16LE: null,
      BINARY: {
        order: 2
      },
      ASCII: {
        order: 3,
        alias: ["ISO646", "CP367"]
      },
      JIS: {
        order: 4,
        alias: ["ISO2022JP"]
      },
      UTF8: {
        order: 5
      },
      EUCJP: {
        order: 6
      },
      SJIS: {
        order: 7,
        alias: ["CP932", "MSKANJI", "WINDOWS31J"]
      },
      UNICODE: {
        order: 8
      }
    };
    var EncodingAliases = {};
    config$2.EncodingAliases = EncodingAliases;
    config$2.EncodingOrders = function() {
      var aliases = EncodingAliases;
      var names = util2.objectKeys(EncodingNames);
      var orders = [];
      var name2, encoding2, j, l;
      for (var i = 0, len = names.length; i < len; i++) {
        name2 = names[i];
        aliases[name2] = name2;
        encoding2 = EncodingNames[name2];
        if (encoding2 != null) {
          if (encoding2.order != null) {
            orders[orders.length] = name2;
          }
          if (encoding2.alias) {
            for (j = 0, l = encoding2.alias.length; j < l; j++) {
              aliases[encoding2.alias[j]] = name2;
            }
          }
        }
      }
      orders.sort(function(a, b) {
        return EncodingNames[a].order - EncodingNames[b].order;
      });
      return orders;
    }();
    function init_JIS_TO_UTF8_TABLE() {
      if (EncodingTable2.JIS_TO_UTF8_TABLE === null) {
        EncodingTable2.JIS_TO_UTF8_TABLE = {};
        var keys = util2.objectKeys(EncodingTable2.UTF8_TO_JIS_TABLE);
        var i = 0;
        var len = keys.length;
        var key, value;
        for (; i < len; i++) {
          key = keys[i];
          value = EncodingTable2.UTF8_TO_JIS_TABLE[key];
          if (value > 95) {
            EncodingTable2.JIS_TO_UTF8_TABLE[value] = key | 0;
          }
        }
        EncodingTable2.JISX0212_TO_UTF8_TABLE = {};
        keys = util2.objectKeys(EncodingTable2.UTF8_TO_JISX0212_TABLE);
        len = keys.length;
        for (i = 0; i < len; i++) {
          key = keys[i];
          value = EncodingTable2.UTF8_TO_JISX0212_TABLE[key];
          EncodingTable2.JISX0212_TO_UTF8_TABLE[value] = key | 0;
        }
      }
    }
    config$2.init_JIS_TO_UTF8_TABLE = init_JIS_TO_UTF8_TABLE;
    return config$2;
  }
  var encodingDetect = {};
  function isBINARY(data) {
    var i = 0;
    var len = data && data.length;
    var c;
    for (; i < len; i++) {
      c = data[i];
      if (c > 255) {
        return false;
      }
      if (c >= 0 && c <= 7 || c === 255) {
        return true;
      }
    }
    return false;
  }
  encodingDetect.isBINARY = isBINARY;
  function isASCII(data) {
    var i = 0;
    var len = data && data.length;
    var b;
    for (; i < len; i++) {
      b = data[i];
      if (b > 255 || b >= 128 && b <= 255 || b === 27) {
        return false;
      }
    }
    return true;
  }
  encodingDetect.isASCII = isASCII;
  function isJIS(data) {
    var i = 0;
    var len = data && data.length;
    var b, esc1, esc2;
    for (; i < len; i++) {
      b = data[i];
      if (b > 255 || b >= 128 && b <= 255) {
        return false;
      }
      if (b === 27) {
        if (i + 2 >= len) {
          return false;
        }
        esc1 = data[i + 1];
        esc2 = data[i + 2];
        if (esc1 === 36) {
          if (esc2 === 40 || // JIS X 0208-1990/2000/2004
          esc2 === 64 || // JIS X 0208-1978
          esc2 === 66) {
            return true;
          }
        } else if (esc1 === 38 && // JIS X 0208-1990
        esc2 === 64) {
          return true;
        } else if (esc1 === 40) {
          if (esc2 === 66 || // ASCII
          esc2 === 73 || // JIS X 0201 Halfwidth Katakana
          esc2 === 74) {
            return true;
          }
        }
      }
    }
    return false;
  }
  encodingDetect.isJIS = isJIS;
  function isEUCJP(data) {
    var i = 0;
    var len = data && data.length;
    var b;
    for (; i < len; i++) {
      b = data[i];
      if (b < 128) {
        continue;
      }
      if (b > 255 || b < 142) {
        return false;
      }
      if (b === 142) {
        if (i + 1 >= len) {
          return false;
        }
        b = data[++i];
        if (b < 161 || 223 < b) {
          return false;
        }
      } else if (b === 143) {
        if (i + 2 >= len) {
          return false;
        }
        b = data[++i];
        if (b < 162 || 237 < b) {
          return false;
        }
        b = data[++i];
        if (b < 161 || 254 < b) {
          return false;
        }
      } else if (161 <= b && b <= 254) {
        if (i + 1 >= len) {
          return false;
        }
        b = data[++i];
        if (b < 161 || 254 < b) {
          return false;
        }
      } else {
        return false;
      }
    }
    return true;
  }
  encodingDetect.isEUCJP = isEUCJP;
  function isSJIS(data) {
    var i = 0;
    var len = data && data.length;
    var b;
    while (i < len && data[i] > 128) {
      if (data[i++] > 255) {
        return false;
      }
    }
    for (; i < len; i++) {
      b = data[i];
      if (b <= 128 || 161 <= b && b <= 223) {
        continue;
      }
      if (b === 160 || b > 239 || i + 1 >= len) {
        return false;
      }
      b = data[++i];
      if (b < 64 || b === 127 || b > 252) {
        return false;
      }
    }
    return true;
  }
  encodingDetect.isSJIS = isSJIS;
  function isUTF8(data) {
    var i = 0;
    var len = data && data.length;
    var b;
    for (; i < len; i++) {
      b = data[i];
      if (b > 255) {
        return false;
      }
      if (b === 9 || b === 10 || b === 13 || b >= 32 && b <= 126) {
        continue;
      }
      if (b >= 194 && b <= 223) {
        if (i + 1 >= len || data[i + 1] < 128 || data[i + 1] > 191) {
          return false;
        }
        i++;
      } else if (b === 224) {
        if (i + 2 >= len || data[i + 1] < 160 || data[i + 1] > 191 || data[i + 2] < 128 || data[i + 2] > 191) {
          return false;
        }
        i += 2;
      } else if (b >= 225 && b <= 236 || b === 238 || b === 239) {
        if (i + 2 >= len || data[i + 1] < 128 || data[i + 1] > 191 || data[i + 2] < 128 || data[i + 2] > 191) {
          return false;
        }
        i += 2;
      } else if (b === 237) {
        if (i + 2 >= len || data[i + 1] < 128 || data[i + 1] > 159 || data[i + 2] < 128 || data[i + 2] > 191) {
          return false;
        }
        i += 2;
      } else if (b === 240) {
        if (i + 3 >= len || data[i + 1] < 144 || data[i + 1] > 191 || data[i + 2] < 128 || data[i + 2] > 191 || data[i + 3] < 128 || data[i + 3] > 191) {
          return false;
        }
        i += 3;
      } else if (b >= 241 && b <= 243) {
        if (i + 3 >= len || data[i + 1] < 128 || data[i + 1] > 191 || data[i + 2] < 128 || data[i + 2] > 191 || data[i + 3] < 128 || data[i + 3] > 191) {
          return false;
        }
        i += 3;
      } else if (b === 244) {
        if (i + 3 >= len || data[i + 1] < 128 || data[i + 1] > 143 || data[i + 2] < 128 || data[i + 2] > 191 || data[i + 3] < 128 || data[i + 3] > 191) {
          return false;
        }
        i += 3;
      } else {
        return false;
      }
    }
    return true;
  }
  encodingDetect.isUTF8 = isUTF8;
  function isUTF16(data) {
    var i = 0;
    var len = data && data.length;
    var pos = null;
    var b1, b2, next, prev;
    if (len < 2) {
      if (data[0] > 255) {
        return false;
      }
    } else {
      b1 = data[0];
      b2 = data[1];
      if (b1 === 255 && // BOM (little-endian)
      b2 === 254) {
        return true;
      }
      if (b1 === 254 && // BOM (big-endian)
      b2 === 255) {
        return true;
      }
      for (; i < len; i++) {
        if (data[i] === 0) {
          pos = i;
          break;
        } else if (data[i] > 255) {
          return false;
        }
      }
      if (pos === null) {
        return false;
      }
      next = data[pos + 1];
      if (next !== void 0 && next > 0 && next < 128) {
        return true;
      }
      prev = data[pos - 1];
      if (prev !== void 0 && prev > 0 && prev < 128) {
        return true;
      }
    }
    return false;
  }
  encodingDetect.isUTF16 = isUTF16;
  function isUTF16BE(data) {
    var i = 0;
    var len = data && data.length;
    var pos = null;
    var b1, b2;
    if (len < 2) {
      if (data[0] > 255) {
        return false;
      }
    } else {
      b1 = data[0];
      b2 = data[1];
      if (b1 === 254 && // BOM
      b2 === 255) {
        return true;
      }
      for (; i < len; i++) {
        if (data[i] === 0) {
          pos = i;
          break;
        } else if (data[i] > 255) {
          return false;
        }
      }
      if (pos === null) {
        return false;
      }
      if (pos % 2 === 0) {
        return true;
      }
    }
    return false;
  }
  encodingDetect.isUTF16BE = isUTF16BE;
  function isUTF16LE(data) {
    var i = 0;
    var len = data && data.length;
    var pos = null;
    var b1, b2;
    if (len < 2) {
      if (data[0] > 255) {
        return false;
      }
    } else {
      b1 = data[0];
      b2 = data[1];
      if (b1 === 255 && // BOM
      b2 === 254) {
        return true;
      }
      for (; i < len; i++) {
        if (data[i] === 0) {
          pos = i;
          break;
        } else if (data[i] > 255) {
          return false;
        }
      }
      if (pos === null) {
        return false;
      }
      if (pos % 2 !== 0) {
        return true;
      }
    }
    return false;
  }
  encodingDetect.isUTF16LE = isUTF16LE;
  function isUTF32(data) {
    var i = 0;
    var len = data && data.length;
    var pos = null;
    var b1, b2, b3, b4;
    var next, prev;
    if (len < 4) {
      for (; i < len; i++) {
        if (data[i] > 255) {
          return false;
        }
      }
    } else {
      b1 = data[0];
      b2 = data[1];
      b3 = data[2];
      b4 = data[3];
      if (b1 === 0 && b2 === 0 && // BOM (big-endian)
      b3 === 254 && b4 === 255) {
        return true;
      }
      if (b1 === 255 && b2 === 254 && // BOM (little-endian)
      b3 === 0 && b4 === 0) {
        return true;
      }
      for (; i < len; i++) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0) {
          pos = i;
          break;
        } else if (data[i] > 255) {
          return false;
        }
      }
      if (pos === null) {
        return false;
      }
      next = data[pos + 3];
      if (next !== void 0 && next > 0 && next <= 127) {
        return data[pos + 2] === 0 && data[pos + 1] === 0;
      }
      prev = data[pos - 1];
      if (prev !== void 0 && prev > 0 && prev <= 127) {
        return data[pos + 1] === 0 && data[pos + 2] === 0;
      }
    }
    return false;
  }
  encodingDetect.isUTF32 = isUTF32;
  function isUNICODE(data) {
    var i = 0;
    var len = data && data.length;
    var c;
    for (; i < len; i++) {
      c = data[i];
      if (c < 0 || c > 1114111) {
        return false;
      }
    }
    return true;
  }
  encodingDetect.isUNICODE = isUNICODE;
  var encodingConvert = {};
  var config$1 = requireConfig();
  var util$1 = requireUtil();
  var EncodingDetect$1 = encodingDetect;
  var EncodingTable = encodingTable;
  function JISToSJIS(data) {
    var results = [];
    var index2 = 0;
    var i = 0;
    var len = data && data.length;
    var b1, b2;
    for (; i < len; i++) {
      while (data[i] === 27) {
        if (data[i + 1] === 36 && data[i + 2] === 66 || data[i + 1] === 36 && data[i + 2] === 64) {
          index2 = 1;
        } else if (data[i + 1] === 40 && data[i + 2] === 73) {
          index2 = 2;
        } else if (data[i + 1] === 36 && data[i + 2] === 40 && data[i + 3] === 68) {
          index2 = 3;
          i++;
        } else {
          index2 = 0;
        }
        i += 3;
        if (data[i] === void 0) {
          return results;
        }
      }
      if (index2 === 1) {
        b1 = data[i];
        b2 = data[++i];
        if (b1 & 1) {
          b1 >>= 1;
          if (b1 < 47) {
            b1 += 113;
          } else {
            b1 -= 79;
          }
          if (b2 > 95) {
            b2 += 32;
          } else {
            b2 += 31;
          }
        } else {
          b1 >>= 1;
          if (b1 <= 47) {
            b1 += 112;
          } else {
            b1 -= 80;
          }
          b2 += 126;
        }
        results[results.length] = b1 & 255;
        results[results.length] = b2 & 255;
      } else if (index2 === 2) {
        results[results.length] = data[i] + 128 & 255;
      } else if (index2 === 3) {
        results[results.length] = config$1.FALLBACK_CHARACTER;
      } else {
        results[results.length] = data[i] & 255;
      }
    }
    return results;
  }
  encodingConvert.JISToSJIS = JISToSJIS;
  function JISToEUCJP(data) {
    var results = [];
    var index2 = 0;
    var len = data && data.length;
    var i = 0;
    for (; i < len; i++) {
      while (data[i] === 27) {
        if (data[i + 1] === 36 && data[i + 2] === 66 || data[i + 1] === 36 && data[i + 2] === 64) {
          index2 = 1;
        } else if (data[i + 1] === 40 && data[i + 2] === 73) {
          index2 = 2;
        } else if (data[i + 1] === 36 && data[i + 2] === 40 && data[i + 3] === 68) {
          index2 = 3;
          i++;
        } else {
          index2 = 0;
        }
        i += 3;
        if (data[i] === void 0) {
          return results;
        }
      }
      if (index2 === 1) {
        results[results.length] = data[i] + 128 & 255;
        results[results.length] = data[++i] + 128 & 255;
      } else if (index2 === 2) {
        results[results.length] = 142;
        results[results.length] = data[i] + 128 & 255;
      } else if (index2 === 3) {
        results[results.length] = 143;
        results[results.length] = data[i] + 128 & 255;
        results[results.length] = data[++i] + 128 & 255;
      } else {
        results[results.length] = data[i] & 255;
      }
    }
    return results;
  }
  encodingConvert.JISToEUCJP = JISToEUCJP;
  function SJISToJIS(data) {
    var results = [];
    var index2 = 0;
    var len = data && data.length;
    var i = 0;
    var b1, b2;
    var esc = [
      27,
      40,
      66,
      27,
      36,
      66,
      27,
      40,
      73
    ];
    for (; i < len; i++) {
      b1 = data[i];
      if (b1 >= 161 && b1 <= 223) {
        if (index2 !== 2) {
          index2 = 2;
          results[results.length] = esc[6];
          results[results.length] = esc[7];
          results[results.length] = esc[8];
        }
        results[results.length] = b1 - 128 & 255;
      } else if (b1 >= 128) {
        if (index2 !== 1) {
          index2 = 1;
          results[results.length] = esc[3];
          results[results.length] = esc[4];
          results[results.length] = esc[5];
        }
        b1 <<= 1;
        b2 = data[++i];
        if (b2 < 159) {
          if (b1 < 319) {
            b1 -= 225;
          } else {
            b1 -= 97;
          }
          if (b2 > 126) {
            b2 -= 32;
          } else {
            b2 -= 31;
          }
        } else {
          if (b1 < 319) {
            b1 -= 224;
          } else {
            b1 -= 96;
          }
          b2 -= 126;
        }
        results[results.length] = b1 & 255;
        results[results.length] = b2 & 255;
      } else {
        if (index2 !== 0) {
          index2 = 0;
          results[results.length] = esc[0];
          results[results.length] = esc[1];
          results[results.length] = esc[2];
        }
        results[results.length] = b1 & 255;
      }
    }
    if (index2 !== 0) {
      results[results.length] = esc[0];
      results[results.length] = esc[1];
      results[results.length] = esc[2];
    }
    return results;
  }
  encodingConvert.SJISToJIS = SJISToJIS;
  function SJISToEUCJP(data) {
    var results = [];
    var len = data && data.length;
    var i = 0;
    var b1, b2;
    for (; i < len; i++) {
      b1 = data[i];
      if (b1 >= 161 && b1 <= 223) {
        results[results.length] = 142;
        results[results.length] = b1;
      } else if (b1 >= 129) {
        b2 = data[++i];
        b1 <<= 1;
        if (b2 < 159) {
          if (b1 < 319) {
            b1 -= 97;
          } else {
            b1 -= 225;
          }
          if (b2 > 126) {
            b2 += 96;
          } else {
            b2 += 97;
          }
        } else {
          if (b1 < 319) {
            b1 -= 96;
          } else {
            b1 -= 224;
          }
          b2 += 2;
        }
        results[results.length] = b1 & 255;
        results[results.length] = b2 & 255;
      } else {
        results[results.length] = b1 & 255;
      }
    }
    return results;
  }
  encodingConvert.SJISToEUCJP = SJISToEUCJP;
  function EUCJPToJIS(data) {
    var results = [];
    var index2 = 0;
    var len = data && data.length;
    var i = 0;
    var b;
    var esc = [
      27,
      40,
      66,
      27,
      36,
      66,
      27,
      40,
      73,
      27,
      36,
      40,
      68
    ];
    for (; i < len; i++) {
      b = data[i];
      if (b === 142) {
        if (index2 !== 2) {
          index2 = 2;
          results[results.length] = esc[6];
          results[results.length] = esc[7];
          results[results.length] = esc[8];
        }
        results[results.length] = data[++i] - 128 & 255;
      } else if (b === 143) {
        if (index2 !== 3) {
          index2 = 3;
          results[results.length] = esc[9];
          results[results.length] = esc[10];
          results[results.length] = esc[11];
          results[results.length] = esc[12];
        }
        results[results.length] = data[++i] - 128 & 255;
        results[results.length] = data[++i] - 128 & 255;
      } else if (b > 142) {
        if (index2 !== 1) {
          index2 = 1;
          results[results.length] = esc[3];
          results[results.length] = esc[4];
          results[results.length] = esc[5];
        }
        results[results.length] = b - 128 & 255;
        results[results.length] = data[++i] - 128 & 255;
      } else {
        if (index2 !== 0) {
          index2 = 0;
          results[results.length] = esc[0];
          results[results.length] = esc[1];
          results[results.length] = esc[2];
        }
        results[results.length] = b & 255;
      }
    }
    if (index2 !== 0) {
      results[results.length] = esc[0];
      results[results.length] = esc[1];
      results[results.length] = esc[2];
    }
    return results;
  }
  encodingConvert.EUCJPToJIS = EUCJPToJIS;
  function EUCJPToSJIS(data) {
    var results = [];
    var len = data && data.length;
    var i = 0;
    var b1, b2;
    for (; i < len; i++) {
      b1 = data[i];
      if (b1 === 143) {
        results[results.length] = config$1.FALLBACK_CHARACTER;
        i += 2;
      } else if (b1 > 142) {
        b2 = data[++i];
        if (b1 & 1) {
          b1 >>= 1;
          if (b1 < 111) {
            b1 += 49;
          } else {
            b1 += 113;
          }
          if (b2 > 223) {
            b2 -= 96;
          } else {
            b2 -= 97;
          }
        } else {
          b1 >>= 1;
          if (b1 <= 111) {
            b1 += 48;
          } else {
            b1 += 112;
          }
          b2 -= 2;
        }
        results[results.length] = b1 & 255;
        results[results.length] = b2 & 255;
      } else if (b1 === 142) {
        results[results.length] = data[++i] & 255;
      } else {
        results[results.length] = b1 & 255;
      }
    }
    return results;
  }
  encodingConvert.EUCJPToSJIS = EUCJPToSJIS;
  function SJISToUTF8(data) {
    config$1.init_JIS_TO_UTF8_TABLE();
    var results = [];
    var i = 0;
    var len = data && data.length;
    var b, b1, b2, u2, u3, jis, utf8;
    for (; i < len; i++) {
      b = data[i];
      if (b >= 161 && b <= 223) {
        b2 = b - 64;
        u2 = 188 | b2 >> 6 & 3;
        u3 = 128 | b2 & 63;
        results[results.length] = 239;
        results[results.length] = u2 & 255;
        results[results.length] = u3 & 255;
      } else if (b >= 128) {
        b1 = b << 1;
        b2 = data[++i];
        if (b2 < 159) {
          if (b1 < 319) {
            b1 -= 225;
          } else {
            b1 -= 97;
          }
          if (b2 > 126) {
            b2 -= 32;
          } else {
            b2 -= 31;
          }
        } else {
          if (b1 < 319) {
            b1 -= 224;
          } else {
            b1 -= 96;
          }
          b2 -= 126;
        }
        b1 &= 255;
        jis = (b1 << 8) + b2;
        utf8 = EncodingTable.JIS_TO_UTF8_TABLE[jis];
        if (utf8 === void 0) {
          results[results.length] = config$1.FALLBACK_CHARACTER;
        } else {
          if (utf8 < 65535) {
            results[results.length] = utf8 >> 8 & 255;
            results[results.length] = utf8 & 255;
          } else {
            results[results.length] = utf8 >> 16 & 255;
            results[results.length] = utf8 >> 8 & 255;
            results[results.length] = utf8 & 255;
          }
        }
      } else {
        results[results.length] = data[i] & 255;
      }
    }
    return results;
  }
  encodingConvert.SJISToUTF8 = SJISToUTF8;
  function EUCJPToUTF8(data) {
    config$1.init_JIS_TO_UTF8_TABLE();
    var results = [];
    var i = 0;
    var len = data && data.length;
    var b, b2, u2, u3, j2, j3, jis, utf8;
    for (; i < len; i++) {
      b = data[i];
      if (b === 142) {
        b2 = data[++i] - 64;
        u2 = 188 | b2 >> 6 & 3;
        u3 = 128 | b2 & 63;
        results[results.length] = 239;
        results[results.length] = u2 & 255;
        results[results.length] = u3 & 255;
      } else if (b === 143) {
        j2 = data[++i] - 128;
        j3 = data[++i] - 128;
        jis = (j2 << 8) + j3;
        utf8 = EncodingTable.JISX0212_TO_UTF8_TABLE[jis];
        if (utf8 === void 0) {
          results[results.length] = config$1.FALLBACK_CHARACTER;
        } else {
          if (utf8 < 65535) {
            results[results.length] = utf8 >> 8 & 255;
            results[results.length] = utf8 & 255;
          } else {
            results[results.length] = utf8 >> 16 & 255;
            results[results.length] = utf8 >> 8 & 255;
            results[results.length] = utf8 & 255;
          }
        }
      } else if (b >= 128) {
        jis = (b - 128 << 8) + (data[++i] - 128);
        utf8 = EncodingTable.JIS_TO_UTF8_TABLE[jis];
        if (utf8 === void 0) {
          results[results.length] = config$1.FALLBACK_CHARACTER;
        } else {
          if (utf8 < 65535) {
            results[results.length] = utf8 >> 8 & 255;
            results[results.length] = utf8 & 255;
          } else {
            results[results.length] = utf8 >> 16 & 255;
            results[results.length] = utf8 >> 8 & 255;
            results[results.length] = utf8 & 255;
          }
        }
      } else {
        results[results.length] = data[i] & 255;
      }
    }
    return results;
  }
  encodingConvert.EUCJPToUTF8 = EUCJPToUTF8;
  function JISToUTF8(data) {
    config$1.init_JIS_TO_UTF8_TABLE();
    var results = [];
    var index2 = 0;
    var i = 0;
    var len = data && data.length;
    var b2, u2, u3, jis, utf8;
    for (; i < len; i++) {
      while (data[i] === 27) {
        if (data[i + 1] === 36 && data[i + 2] === 66 || data[i + 1] === 36 && data[i + 2] === 64) {
          index2 = 1;
        } else if (data[i + 1] === 40 && data[i + 2] === 73) {
          index2 = 2;
        } else if (data[i + 1] === 36 && data[i + 2] === 40 && data[i + 3] === 68) {
          index2 = 3;
          i++;
        } else {
          index2 = 0;
        }
        i += 3;
        if (data[i] === void 0) {
          return results;
        }
      }
      if (index2 === 1) {
        jis = (data[i] << 8) + data[++i];
        utf8 = EncodingTable.JIS_TO_UTF8_TABLE[jis];
        if (utf8 === void 0) {
          results[results.length] = config$1.FALLBACK_CHARACTER;
        } else {
          if (utf8 < 65535) {
            results[results.length] = utf8 >> 8 & 255;
            results[results.length] = utf8 & 255;
          } else {
            results[results.length] = utf8 >> 16 & 255;
            results[results.length] = utf8 >> 8 & 255;
            results[results.length] = utf8 & 255;
          }
        }
      } else if (index2 === 2) {
        b2 = data[i] + 64;
        u2 = 188 | b2 >> 6 & 3;
        u3 = 128 | b2 & 63;
        results[results.length] = 239;
        results[results.length] = u2 & 255;
        results[results.length] = u3 & 255;
      } else if (index2 === 3) {
        jis = (data[i] << 8) + data[++i];
        utf8 = EncodingTable.JISX0212_TO_UTF8_TABLE[jis];
        if (utf8 === void 0) {
          results[results.length] = config$1.FALLBACK_CHARACTER;
        } else {
          if (utf8 < 65535) {
            results[results.length] = utf8 >> 8 & 255;
            results[results.length] = utf8 & 255;
          } else {
            results[results.length] = utf8 >> 16 & 255;
            results[results.length] = utf8 >> 8 & 255;
            results[results.length] = utf8 & 255;
          }
        }
      } else {
        results[results.length] = data[i] & 255;
      }
    }
    return results;
  }
  encodingConvert.JISToUTF8 = JISToUTF8;
  function UTF8ToSJIS(data, options) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var b, b1, b2, bytes, utf8, jis;
    var fallbackOption = options && options.fallback;
    for (; i < len; i++) {
      b = data[i];
      if (b >= 128) {
        if (b <= 223) {
          bytes = [b, data[i + 1]];
          utf8 = (b << 8) + data[++i];
        } else if (b <= 239) {
          bytes = [b, data[i + 1], data[i + 2]];
          utf8 = (b << 16) + (data[++i] << 8) + (data[++i] & 255);
        } else {
          bytes = [b, data[i + 1], data[i + 2], data[i + 3]];
          utf8 = (b << 24) + (data[++i] << 16) + (data[++i] << 8) + (data[++i] & 255);
        }
        jis = EncodingTable.UTF8_TO_JIS_TABLE[utf8];
        if (jis == null) {
          if (fallbackOption) {
            handleFallback(results, bytes, fallbackOption);
          } else {
            results[results.length] = config$1.FALLBACK_CHARACTER;
          }
        } else {
          if (jis < 255) {
            results[results.length] = jis + 128;
          } else {
            if (jis > 65536) {
              jis -= 65536;
            }
            b1 = jis >> 8;
            b2 = jis & 255;
            if (b1 & 1) {
              b1 >>= 1;
              if (b1 < 47) {
                b1 += 113;
              } else {
                b1 -= 79;
              }
              if (b2 > 95) {
                b2 += 32;
              } else {
                b2 += 31;
              }
            } else {
              b1 >>= 1;
              if (b1 <= 47) {
                b1 += 112;
              } else {
                b1 -= 80;
              }
              b2 += 126;
            }
            results[results.length] = b1 & 255;
            results[results.length] = b2 & 255;
          }
        }
      } else {
        results[results.length] = data[i] & 255;
      }
    }
    return results;
  }
  encodingConvert.UTF8ToSJIS = UTF8ToSJIS;
  function UTF8ToEUCJP(data, options) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var b, bytes, utf8, jis;
    var fallbackOption = options && options.fallback;
    for (; i < len; i++) {
      b = data[i];
      if (b >= 128) {
        if (b <= 223) {
          bytes = [b, data[i + 1]];
          utf8 = (b << 8) + data[++i];
        } else if (b <= 239) {
          bytes = [b, data[i + 1], data[i + 2]];
          utf8 = (b << 16) + (data[++i] << 8) + (data[++i] & 255);
        } else {
          bytes = [b, data[i + 1], data[i + 2], data[i + 3]];
          utf8 = (b << 24) + (data[++i] << 16) + (data[++i] << 8) + (data[++i] & 255);
        }
        jis = EncodingTable.UTF8_TO_JIS_TABLE[utf8];
        if (jis == null) {
          jis = EncodingTable.UTF8_TO_JISX0212_TABLE[utf8];
          if (jis == null) {
            if (fallbackOption) {
              handleFallback(results, bytes, fallbackOption);
            } else {
              results[results.length] = config$1.FALLBACK_CHARACTER;
            }
          } else {
            results[results.length] = 143;
            results[results.length] = (jis >> 8) - 128 & 255;
            results[results.length] = (jis & 255) - 128 & 255;
          }
        } else {
          if (jis > 65536) {
            jis -= 65536;
          }
          if (jis < 255) {
            results[results.length] = 142;
            results[results.length] = jis - 128 & 255;
          } else {
            results[results.length] = (jis >> 8) - 128 & 255;
            results[results.length] = (jis & 255) - 128 & 255;
          }
        }
      } else {
        results[results.length] = data[i] & 255;
      }
    }
    return results;
  }
  encodingConvert.UTF8ToEUCJP = UTF8ToEUCJP;
  function UTF8ToJIS(data, options) {
    var results = [];
    var index2 = 0;
    var len = data && data.length;
    var i = 0;
    var b, bytes, utf8, jis;
    var fallbackOption = options && options.fallback;
    var esc = [
      27,
      40,
      66,
      27,
      36,
      66,
      27,
      40,
      73,
      27,
      36,
      40,
      68
    ];
    for (; i < len; i++) {
      b = data[i];
      if (b < 128) {
        if (index2 !== 0) {
          index2 = 0;
          results[results.length] = esc[0];
          results[results.length] = esc[1];
          results[results.length] = esc[2];
        }
        results[results.length] = b & 255;
      } else {
        if (b <= 223) {
          bytes = [b, data[i + 1]];
          utf8 = (b << 8) + data[++i];
        } else if (b <= 239) {
          bytes = [b, data[i + 1], data[i + 2]];
          utf8 = (b << 16) + (data[++i] << 8) + (data[++i] & 255);
        } else {
          bytes = [b, data[i + 1], data[i + 2], data[i + 3]];
          utf8 = (b << 24) + (data[++i] << 16) + (data[++i] << 8) + (data[++i] & 255);
        }
        jis = EncodingTable.UTF8_TO_JIS_TABLE[utf8];
        if (jis == null) {
          jis = EncodingTable.UTF8_TO_JISX0212_TABLE[utf8];
          if (jis == null) {
            if (index2 !== 0) {
              index2 = 0;
              results[results.length] = esc[0];
              results[results.length] = esc[1];
              results[results.length] = esc[2];
            }
            if (fallbackOption) {
              handleFallback(results, bytes, fallbackOption);
            } else {
              results[results.length] = config$1.FALLBACK_CHARACTER;
            }
          } else {
            if (index2 !== 3) {
              index2 = 3;
              results[results.length] = esc[9];
              results[results.length] = esc[10];
              results[results.length] = esc[11];
              results[results.length] = esc[12];
            }
            results[results.length] = jis >> 8 & 255;
            results[results.length] = jis & 255;
          }
        } else {
          if (jis > 65536) {
            jis -= 65536;
          }
          if (jis < 255) {
            if (index2 !== 2) {
              index2 = 2;
              results[results.length] = esc[6];
              results[results.length] = esc[7];
              results[results.length] = esc[8];
            }
            results[results.length] = jis & 255;
          } else {
            if (index2 !== 1) {
              index2 = 1;
              results[results.length] = esc[3];
              results[results.length] = esc[4];
              results[results.length] = esc[5];
            }
            results[results.length] = jis >> 8 & 255;
            results[results.length] = jis & 255;
          }
        }
      }
    }
    if (index2 !== 0) {
      results[results.length] = esc[0];
      results[results.length] = esc[1];
      results[results.length] = esc[2];
    }
    return results;
  }
  encodingConvert.UTF8ToJIS = UTF8ToJIS;
  function UNICODEToUTF8(data) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var c, second;
    for (; i < len; i++) {
      c = data[i];
      if (c >= 55296 && c <= 56319 && i + 1 < len) {
        second = data[i + 1];
        if (second >= 56320 && second <= 57343) {
          c = (c - 55296) * 1024 + second - 56320 + 65536;
          i++;
        }
      }
      if (c < 128) {
        results[results.length] = c;
      } else if (c < 2048) {
        results[results.length] = 192 | c >> 6 & 31;
        results[results.length] = 128 | c & 63;
      } else if (c < 65536) {
        results[results.length] = 224 | c >> 12 & 15;
        results[results.length] = 128 | c >> 6 & 63;
        results[results.length] = 128 | c & 63;
      } else if (c < 2097152) {
        results[results.length] = 240 | c >> 18 & 15;
        results[results.length] = 128 | c >> 12 & 63;
        results[results.length] = 128 | c >> 6 & 63;
        results[results.length] = 128 | c & 63;
      }
    }
    return results;
  }
  encodingConvert.UNICODEToUTF8 = UNICODEToUTF8;
  function UTF8ToUNICODE(data, options) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var n, c, c2, c3, c4, code;
    var ignoreSurrogatePair = options && options.ignoreSurrogatePair;
    while (i < len) {
      c = data[i++];
      n = c >> 4;
      if (n >= 0 && n <= 7) {
        code = c;
      } else if (n === 12 || n === 13) {
        c2 = data[i++];
        code = (c & 31) << 6 | c2 & 63;
      } else if (n === 14) {
        c2 = data[i++];
        c3 = data[i++];
        code = (c & 15) << 12 | (c2 & 63) << 6 | c3 & 63;
      } else if (n === 15) {
        c2 = data[i++];
        c3 = data[i++];
        c4 = data[i++];
        code = (c & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63;
      }
      if (code <= 65535 || ignoreSurrogatePair) {
        results[results.length] = code;
      } else {
        code -= 65536;
        results[results.length] = (code >> 10) + 55296;
        results[results.length] = code % 1024 + 56320;
      }
    }
    return results;
  }
  encodingConvert.UTF8ToUNICODE = UTF8ToUNICODE;
  function UNICODEToUTF16(data, options) {
    var results;
    if (options && options.bom) {
      var optBom = options.bom;
      if (!util$1.isString(optBom)) {
        optBom = "BE";
      }
      var bom, utf16;
      if (optBom.charAt(0).toUpperCase() === "B") {
        bom = [254, 255];
        utf16 = UNICODEToUTF16BE(data);
      } else {
        bom = [255, 254];
        utf16 = UNICODEToUTF16LE(data);
      }
      results = [];
      results[0] = bom[0];
      results[1] = bom[1];
      for (var i = 0, len = utf16.length; i < len; i++) {
        results[results.length] = utf16[i];
      }
    } else {
      results = UNICODEToUTF16BE(data);
    }
    return results;
  }
  encodingConvert.UNICODEToUTF16 = UNICODEToUTF16;
  function UNICODEToUTF16BE(data) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var c;
    while (i < len) {
      c = data[i++];
      if (c <= 255) {
        results[results.length] = 0;
        results[results.length] = c;
      } else if (c <= 65535) {
        results[results.length] = c >> 8 & 255;
        results[results.length] = c & 255;
      }
    }
    return results;
  }
  encodingConvert.UNICODEToUTF16BE = UNICODEToUTF16BE;
  function UNICODEToUTF16LE(data) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var c;
    while (i < len) {
      c = data[i++];
      if (c <= 255) {
        results[results.length] = c;
        results[results.length] = 0;
      } else if (c <= 65535) {
        results[results.length] = c & 255;
        results[results.length] = c >> 8 & 255;
      }
    }
    return results;
  }
  encodingConvert.UNICODEToUTF16LE = UNICODEToUTF16LE;
  function UTF16BEToUNICODE(data) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var c1, c2;
    if (len >= 2 && (data[0] === 254 && data[1] === 255 || data[0] === 255 && data[1] === 254)) {
      i = 2;
    }
    while (i < len) {
      c1 = data[i++];
      c2 = data[i++];
      if (c1 === 0) {
        results[results.length] = c2;
      } else {
        results[results.length] = (c1 & 255) << 8 | c2 & 255;
      }
    }
    return results;
  }
  encodingConvert.UTF16BEToUNICODE = UTF16BEToUNICODE;
  function UTF16LEToUNICODE(data) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var c1, c2;
    if (len >= 2 && (data[0] === 254 && data[1] === 255 || data[0] === 255 && data[1] === 254)) {
      i = 2;
    }
    while (i < len) {
      c1 = data[i++];
      c2 = data[i++];
      if (c2 === 0) {
        results[results.length] = c1;
      } else {
        results[results.length] = (c2 & 255) << 8 | c1 & 255;
      }
    }
    return results;
  }
  encodingConvert.UTF16LEToUNICODE = UTF16LEToUNICODE;
  function UTF16ToUNICODE(data) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var isLE = false;
    var first = true;
    var c1, c2;
    while (i < len) {
      c1 = data[i++];
      c2 = data[i++];
      if (first && i === 2) {
        first = false;
        if (c1 === 254 && c2 === 255) {
          isLE = false;
        } else if (c1 === 255 && c2 === 254) {
          isLE = true;
        } else {
          isLE = EncodingDetect$1.isUTF16LE(data);
          i = 0;
        }
        continue;
      }
      if (isLE) {
        if (c2 === 0) {
          results[results.length] = c1;
        } else {
          results[results.length] = (c2 & 255) << 8 | c1 & 255;
        }
      } else {
        if (c1 === 0) {
          results[results.length] = c2;
        } else {
          results[results.length] = (c1 & 255) << 8 | c2 & 255;
        }
      }
    }
    return results;
  }
  encodingConvert.UTF16ToUNICODE = UTF16ToUNICODE;
  function UTF16ToUTF16BE(data) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var isLE = false;
    var first = true;
    var c1, c2;
    while (i < len) {
      c1 = data[i++];
      c2 = data[i++];
      if (first && i === 2) {
        first = false;
        if (c1 === 254 && c2 === 255) {
          isLE = false;
        } else if (c1 === 255 && c2 === 254) {
          isLE = true;
        } else {
          isLE = EncodingDetect$1.isUTF16LE(data);
          i = 0;
        }
        continue;
      }
      if (isLE) {
        results[results.length] = c2;
        results[results.length] = c1;
      } else {
        results[results.length] = c1;
        results[results.length] = c2;
      }
    }
    return results;
  }
  encodingConvert.UTF16ToUTF16BE = UTF16ToUTF16BE;
  function UTF16BEToUTF16(data, options) {
    var isLE = false;
    var bom;
    if (options && options.bom) {
      var optBom = options.bom;
      if (!util$1.isString(optBom)) {
        optBom = "BE";
      }
      if (optBom.charAt(0).toUpperCase() === "B") {
        bom = [254, 255];
      } else {
        bom = [255, 254];
        isLE = true;
      }
    }
    var results = [];
    var len = data && data.length;
    var i = 0;
    if (len >= 2 && (data[0] === 254 && data[1] === 255 || data[0] === 255 && data[1] === 254)) {
      i = 2;
    }
    if (bom) {
      results[0] = bom[0];
      results[1] = bom[1];
    }
    var c1, c2;
    while (i < len) {
      c1 = data[i++];
      c2 = data[i++];
      if (isLE) {
        results[results.length] = c2;
        results[results.length] = c1;
      } else {
        results[results.length] = c1;
        results[results.length] = c2;
      }
    }
    return results;
  }
  encodingConvert.UTF16BEToUTF16 = UTF16BEToUTF16;
  function UTF16ToUTF16LE(data) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var isLE = false;
    var first = true;
    var c1, c2;
    while (i < len) {
      c1 = data[i++];
      c2 = data[i++];
      if (first && i === 2) {
        first = false;
        if (c1 === 254 && c2 === 255) {
          isLE = false;
        } else if (c1 === 255 && c2 === 254) {
          isLE = true;
        } else {
          isLE = EncodingDetect$1.isUTF16LE(data);
          i = 0;
        }
        continue;
      }
      if (isLE) {
        results[results.length] = c1;
        results[results.length] = c2;
      } else {
        results[results.length] = c2;
        results[results.length] = c1;
      }
    }
    return results;
  }
  encodingConvert.UTF16ToUTF16LE = UTF16ToUTF16LE;
  function UTF16LEToUTF16(data, options) {
    var isLE = false;
    var bom;
    if (options && options.bom) {
      var optBom = options.bom;
      if (!util$1.isString(optBom)) {
        optBom = "BE";
      }
      if (optBom.charAt(0).toUpperCase() === "B") {
        bom = [254, 255];
      } else {
        bom = [255, 254];
        isLE = true;
      }
    }
    var results = [];
    var len = data && data.length;
    var i = 0;
    if (len >= 2 && (data[0] === 254 && data[1] === 255 || data[0] === 255 && data[1] === 254)) {
      i = 2;
    }
    if (bom) {
      results[0] = bom[0];
      results[1] = bom[1];
    }
    var c1, c2;
    while (i < len) {
      c1 = data[i++];
      c2 = data[i++];
      if (isLE) {
        results[results.length] = c1;
        results[results.length] = c2;
      } else {
        results[results.length] = c2;
        results[results.length] = c1;
      }
    }
    return results;
  }
  encodingConvert.UTF16LEToUTF16 = UTF16LEToUTF16;
  function UTF16BEToUTF16LE(data) {
    var results = [];
    var i = 0;
    var len = data && data.length;
    var c1, c2;
    if (len >= 2 && (data[0] === 254 && data[1] === 255 || data[0] === 255 && data[1] === 254)) {
      i = 2;
    }
    while (i < len) {
      c1 = data[i++];
      c2 = data[i++];
      results[results.length] = c2;
      results[results.length] = c1;
    }
    return results;
  }
  encodingConvert.UTF16BEToUTF16LE = UTF16BEToUTF16LE;
  function UTF16LEToUTF16BE(data) {
    return UTF16BEToUTF16LE(data);
  }
  encodingConvert.UTF16LEToUTF16BE = UTF16LEToUTF16BE;
  function UNICODEToJIS(data, options) {
    return UTF8ToJIS(UNICODEToUTF8(data), options);
  }
  encodingConvert.UNICODEToJIS = UNICODEToJIS;
  function JISToUNICODE(data) {
    return UTF8ToUNICODE(JISToUTF8(data));
  }
  encodingConvert.JISToUNICODE = JISToUNICODE;
  function UNICODEToEUCJP(data, options) {
    return UTF8ToEUCJP(UNICODEToUTF8(data), options);
  }
  encodingConvert.UNICODEToEUCJP = UNICODEToEUCJP;
  function EUCJPToUNICODE(data) {
    return UTF8ToUNICODE(EUCJPToUTF8(data));
  }
  encodingConvert.EUCJPToUNICODE = EUCJPToUNICODE;
  function UNICODEToSJIS(data, options) {
    return UTF8ToSJIS(UNICODEToUTF8(data), options);
  }
  encodingConvert.UNICODEToSJIS = UNICODEToSJIS;
  function SJISToUNICODE(data) {
    return UTF8ToUNICODE(SJISToUTF8(data));
  }
  encodingConvert.SJISToUNICODE = SJISToUNICODE;
  function UTF8ToUTF16(data, options) {
    return UNICODEToUTF16(UTF8ToUNICODE(data), options);
  }
  encodingConvert.UTF8ToUTF16 = UTF8ToUTF16;
  function UTF16ToUTF8(data) {
    return UNICODEToUTF8(UTF16ToUNICODE(data));
  }
  encodingConvert.UTF16ToUTF8 = UTF16ToUTF8;
  function UTF8ToUTF16BE(data) {
    return UNICODEToUTF16BE(UTF8ToUNICODE(data));
  }
  encodingConvert.UTF8ToUTF16BE = UTF8ToUTF16BE;
  function UTF16BEToUTF8(data) {
    return UNICODEToUTF8(UTF16BEToUNICODE(data));
  }
  encodingConvert.UTF16BEToUTF8 = UTF16BEToUTF8;
  function UTF8ToUTF16LE(data) {
    return UNICODEToUTF16LE(UTF8ToUNICODE(data));
  }
  encodingConvert.UTF8ToUTF16LE = UTF8ToUTF16LE;
  function UTF16LEToUTF8(data) {
    return UNICODEToUTF8(UTF16LEToUNICODE(data));
  }
  encodingConvert.UTF16LEToUTF8 = UTF16LEToUTF8;
  function JISToUTF16(data, options) {
    return UTF8ToUTF16(JISToUTF8(data), options);
  }
  encodingConvert.JISToUTF16 = JISToUTF16;
  function UTF16ToJIS(data, options) {
    return UTF8ToJIS(UTF16ToUTF8(data), options);
  }
  encodingConvert.UTF16ToJIS = UTF16ToJIS;
  function JISToUTF16BE(data) {
    return UTF8ToUTF16BE(JISToUTF8(data));
  }
  encodingConvert.JISToUTF16BE = JISToUTF16BE;
  function UTF16BEToJIS(data, options) {
    return UTF8ToJIS(UTF16BEToUTF8(data), options);
  }
  encodingConvert.UTF16BEToJIS = UTF16BEToJIS;
  function JISToUTF16LE(data) {
    return UTF8ToUTF16LE(JISToUTF8(data));
  }
  encodingConvert.JISToUTF16LE = JISToUTF16LE;
  function UTF16LEToJIS(data, options) {
    return UTF8ToJIS(UTF16LEToUTF8(data), options);
  }
  encodingConvert.UTF16LEToJIS = UTF16LEToJIS;
  function EUCJPToUTF16(data, options) {
    return UTF8ToUTF16(EUCJPToUTF8(data), options);
  }
  encodingConvert.EUCJPToUTF16 = EUCJPToUTF16;
  function UTF16ToEUCJP(data, options) {
    return UTF8ToEUCJP(UTF16ToUTF8(data), options);
  }
  encodingConvert.UTF16ToEUCJP = UTF16ToEUCJP;
  function EUCJPToUTF16BE(data) {
    return UTF8ToUTF16BE(EUCJPToUTF8(data));
  }
  encodingConvert.EUCJPToUTF16BE = EUCJPToUTF16BE;
  function UTF16BEToEUCJP(data, options) {
    return UTF8ToEUCJP(UTF16BEToUTF8(data), options);
  }
  encodingConvert.UTF16BEToEUCJP = UTF16BEToEUCJP;
  function EUCJPToUTF16LE(data) {
    return UTF8ToUTF16LE(EUCJPToUTF8(data));
  }
  encodingConvert.EUCJPToUTF16LE = EUCJPToUTF16LE;
  function UTF16LEToEUCJP(data, options) {
    return UTF8ToEUCJP(UTF16LEToUTF8(data), options);
  }
  encodingConvert.UTF16LEToEUCJP = UTF16LEToEUCJP;
  function SJISToUTF16(data, options) {
    return UTF8ToUTF16(SJISToUTF8(data), options);
  }
  encodingConvert.SJISToUTF16 = SJISToUTF16;
  function UTF16ToSJIS(data, options) {
    return UTF8ToSJIS(UTF16ToUTF8(data), options);
  }
  encodingConvert.UTF16ToSJIS = UTF16ToSJIS;
  function SJISToUTF16BE(data) {
    return UTF8ToUTF16BE(SJISToUTF8(data));
  }
  encodingConvert.SJISToUTF16BE = SJISToUTF16BE;
  function UTF16BEToSJIS(data, options) {
    return UTF8ToSJIS(UTF16BEToUTF8(data), options);
  }
  encodingConvert.UTF16BEToSJIS = UTF16BEToSJIS;
  function SJISToUTF16LE(data) {
    return UTF8ToUTF16LE(SJISToUTF8(data));
  }
  encodingConvert.SJISToUTF16LE = SJISToUTF16LE;
  function UTF16LEToSJIS(data, options) {
    return UTF8ToSJIS(UTF16LEToUTF8(data), options);
  }
  encodingConvert.UTF16LEToSJIS = UTF16LEToSJIS;
  function handleFallback(results, bytes, fallbackOption) {
    switch (fallbackOption) {
      case "html-entity":
      case "html-entity-hex":
        var unicode = UTF8ToUNICODE(bytes, { ignoreSurrogatePair: true })[0];
        if (unicode) {
          results[results.length] = 38;
          results[results.length] = 35;
          var radix = fallbackOption.slice(-3) === "hex" ? 16 : 10;
          if (radix === 16) {
            results[results.length] = 120;
          }
          var entity = unicode.toString(radix);
          for (var i = 0, len = entity.length; i < len; i++) {
            results[results.length] = entity.charCodeAt(i);
          }
          results[results.length] = 59;
        }
    }
  }
  var kanaCaseTable = {};
  kanaCaseTable.HANKANA_TABLE = {
    12289: 65380,
    12290: 65377,
    12300: 65378,
    12301: 65379,
    12443: 65438,
    12444: 65439,
    12449: 65383,
    12450: 65393,
    12451: 65384,
    12452: 65394,
    12453: 65385,
    12454: 65395,
    12455: 65386,
    12456: 65396,
    12457: 65387,
    12458: 65397,
    12459: 65398,
    12461: 65399,
    12463: 65400,
    12465: 65401,
    12467: 65402,
    12469: 65403,
    12471: 65404,
    12473: 65405,
    12475: 65406,
    12477: 65407,
    12479: 65408,
    12481: 65409,
    12483: 65391,
    12484: 65410,
    12486: 65411,
    12488: 65412,
    12490: 65413,
    12491: 65414,
    12492: 65415,
    12493: 65416,
    12494: 65417,
    12495: 65418,
    12498: 65419,
    12501: 65420,
    12504: 65421,
    12507: 65422,
    12510: 65423,
    12511: 65424,
    12512: 65425,
    12513: 65426,
    12514: 65427,
    12515: 65388,
    12516: 65428,
    12517: 65389,
    12518: 65429,
    12519: 65390,
    12520: 65430,
    12521: 65431,
    12522: 65432,
    12523: 65433,
    12524: 65434,
    12525: 65435,
    12527: 65436,
    12530: 65382,
    12531: 65437,
    12539: 65381,
    12540: 65392
  };
  kanaCaseTable.HANKANA_SONANTS = {
    12532: 65395,
    12535: 65436,
    12538: 65382
  };
  kanaCaseTable.HANKANA_MARKS = [65438, 65439];
  kanaCaseTable.ZENKANA_TABLE = [
    12290,
    12300,
    12301,
    12289,
    12539,
    12530,
    12449,
    12451,
    12453,
    12455,
    12457,
    12515,
    12517,
    12519,
    12483,
    12540,
    12450,
    12452,
    12454,
    12456,
    12458,
    12459,
    12461,
    12463,
    12465,
    12467,
    12469,
    12471,
    12473,
    12475,
    12477,
    12479,
    12481,
    12484,
    12486,
    12488,
    12490,
    12491,
    12492,
    12493,
    12494,
    12495,
    12498,
    12501,
    12504,
    12507,
    12510,
    12511,
    12512,
    12513,
    12514,
    12516,
    12518,
    12520,
    12521,
    12522,
    12523,
    12524,
    12525,
    12527,
    12531,
    12443,
    12444
  ];
  const name = "encoding-japanese";
  const version$1 = "2.0.0";
  const description = "Convert or detect character encoding in JavaScript";
  const main = "src/index.js";
  const files = [
    "encoding.js",
    "encoding.min.js",
    "encoding.min.js.map",
    "src/*"
  ];
  const scripts = {
    build: "npm run compile && npm run minify",
    compile: "browserify src/index.js -o encoding.js -s Encoding -p [ bannerify --file src/banner.js ] --no-bundle-external --bare",
    minify: `uglifyjs encoding.js -o encoding.min.js --source-map "url='encoding.min.js.map'" --comments -c -m -b ascii_only=true,beautify=false`,
    test: "./node_modules/.bin/eslint . && npm run build && mocha tests/test",
    watch: "watchify src/index.js -o encoding.js -s Encoding -p [ bannerify --file src/banner.js ] --no-bundle-external --bare --poll=300 -v"
  };
  const engines = {
    node: ">=8.10.0"
  };
  const repository = {
    type: "git",
    url: "https://github.com/polygonplanet/encoding.js.git"
  };
  const author = "polygonplanet <polygon.planet.aqua@gmail.com>";
  const license = "MIT";
  const bugs = {
    url: "https://github.com/polygonplanet/encoding.js/issues"
  };
  const homepage = "https://github.com/polygonplanet/encoding.js";
  const keywords = [
    "base64",
    "charset",
    "convert",
    "detect",
    "encoding",
    "euc-jp",
    "eucjp",
    "iconv",
    "iso-2022-jp",
    "japanese",
    "jis",
    "shift_jis",
    "sjis",
    "unicode",
    "urldecode",
    "urlencode",
    "utf-16",
    "utf-32",
    "utf-8"
  ];
  const dependencies = {};
  const devDependencies = {
    bannerify: "^1.0.1",
    browserify: "^17.0.0",
    eslint: "^8.12.0",
    mocha: "^9.2.2",
    "package-json-versionify": "^1.0.4",
    "power-assert": "^1.6.1",
    "uglify-js": "^3.15.3",
    uglifyify: "^5.0.2",
    watchify: "^4.0.0"
  };
  const browserify = {
    transform: [
      "package-json-versionify"
    ]
  };
  const require$$5 = {
    name,
    version: version$1,
    description,
    main,
    files,
    scripts,
    engines,
    repository,
    author,
    license,
    bugs,
    homepage,
    keywords,
    dependencies,
    devDependencies,
    browserify
  };
  var config = requireConfig();
  var util = requireUtil();
  var EncodingDetect = encodingDetect;
  var EncodingConvert = encodingConvert;
  var KanaCaseTable = kanaCaseTable;
  var version = require$$5.version;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var Encoding = {
    version,
    /**
     * Encoding orders
     */
    orders: config.EncodingOrders,
    /**
     * Detects character encoding
     *
     * If encodings is "AUTO", or the encoding-list as an array, or
     *   comma separated list string it will be detected automatically
     *
     * @param {Array.<number>|TypedArray|string} data The data being detected
     * @param {(Object|string|Array.<string>)=} [encodings] The encoding-list of
     *   character encoding
     * @return {string|boolean} The detected character encoding, or false
     */
    detect: function(data, encodings) {
      if (data == null || data.length === 0) {
        return false;
      }
      if (util.isObject(encodings) && !util.isArray(encodings)) {
        encodings = encodings.encoding;
      }
      if (util.isString(data)) {
        data = util.stringToBuffer(data);
      }
      if (encodings == null) {
        encodings = Encoding.orders;
      } else {
        if (util.isString(encodings)) {
          encodings = encodings.toUpperCase();
          if (encodings === "AUTO") {
            encodings = Encoding.orders;
          } else if (~encodings.indexOf(",")) {
            encodings = encodings.split(/\s*,\s*/);
          } else {
            encodings = [encodings];
          }
        }
      }
      var len = encodings.length;
      var e, encoding2, method;
      for (var i = 0; i < len; i++) {
        e = encodings[i];
        encoding2 = util.canonicalizeEncodingName(e);
        if (!encoding2) {
          continue;
        }
        method = "is" + encoding2;
        if (!hasOwnProperty.call(EncodingDetect, method)) {
          throw new Error("Undefined encoding: " + e);
        }
        if (EncodingDetect[method](data)) {
          return encoding2;
        }
      }
      return false;
    },
    /**
     * Convert character encoding
     *
     * If `from` is "AUTO", or the encoding-list as an array, or
     *   comma separated list string it will be detected automatically
     *
     * @param {Array.<number>|TypedArray|string} data The data being converted
     * @param {(string|Object)} to The name of encoding to
     * @param {(string|Array.<string>)=} [from] The encoding-list of
     *   character encoding
     * @return {Array|TypedArray|string} The converted data
     */
    convert: function(data, to, from) {
      var result, type, options;
      if (!util.isObject(to)) {
        options = {};
      } else {
        options = to;
        from = options.from;
        to = options.to;
        if (options.type) {
          type = options.type;
        }
      }
      if (util.isString(data)) {
        type = type || "string";
        data = util.stringToBuffer(data);
      } else if (data == null || data.length === 0) {
        data = [];
      }
      var encodingFrom;
      if (from != null && util.isString(from) && from.toUpperCase() !== "AUTO" && !~from.indexOf(",")) {
        encodingFrom = util.canonicalizeEncodingName(from);
      } else {
        encodingFrom = Encoding.detect(data);
      }
      var encodingTo = util.canonicalizeEncodingName(to);
      var method = encodingFrom + "To" + encodingTo;
      if (hasOwnProperty.call(EncodingConvert, method)) {
        result = EncodingConvert[method](data, options);
      } else {
        result = data;
      }
      switch (("" + type).toLowerCase()) {
        case "string":
          return util.codeToString_fast(result);
        case "arraybuffer":
          return util.codeToBuffer(result);
        default:
          return util.bufferToCode(result);
      }
    },
    /**
     * Encode a character code array to URL string like encodeURIComponent
     *
     * @param {Array.<number>|TypedArray} data The data being encoded
     * @return {string} The percent encoded string
     */
    urlEncode: function(data) {
      if (util.isString(data)) {
        data = util.stringToBuffer(data);
      }
      var alpha = util.stringToCode("0123456789ABCDEF");
      var results = [];
      var i = 0;
      var len = data && data.length;
      var b;
      for (; i < len; i++) {
        b = data[i];
        if (b > 255) {
          return encodeURIComponent(util.codeToString_fast(data));
        }
        if (b >= 97 && b <= 122 || b >= 65 && b <= 90 || b >= 48 && b <= 57 || b === 33 || b >= 39 && b <= 42 || b === 45 || b === 46 || b === 95 || b === 126) {
          results[results.length] = b;
        } else {
          results[results.length] = 37;
          if (b < 16) {
            results[results.length] = 48;
            results[results.length] = alpha[b];
          } else {
            results[results.length] = alpha[b >> 4 & 15];
            results[results.length] = alpha[b & 15];
          }
        }
      }
      return util.codeToString_fast(results);
    },
    /**
     * Decode a percent encoded string to
     *  character code array like decodeURIComponent
     *
     * @param {string} string The data being decoded
     * @return {Array.<number>} The decoded array
     */
    urlDecode: function(string) {
      var results = [];
      var i = 0;
      var len = string && string.length;
      var c;
      while (i < len) {
        c = string.charCodeAt(i++);
        if (c === 37) {
          results[results.length] = parseInt(
            string.charAt(i++) + string.charAt(i++),
            16
          );
        } else {
          results[results.length] = c;
        }
      }
      return results;
    },
    /**
     * Encode a character code array to Base64 encoded string
     *
     * @param {Array.<number>|TypedArray} data The data being encoded
     * @return {string} The Base64 encoded string
     */
    base64Encode: function(data) {
      if (util.isString(data)) {
        data = util.stringToBuffer(data);
      }
      return util.base64encode(data);
    },
    /**
     * Decode a Base64 encoded string to character code array
     *
     * @param {string} string The data being decoded
     * @return {Array.<number>} The decoded array
     */
    base64Decode: function(string) {
      return util.base64decode(string);
    },
    /**
     * Joins a character code array to string
     *
     * @param {Array.<number>|TypedArray} data The data being joined
     * @return {String} The joined string
     */
    codeToString: util.codeToString_fast,
    /**
     * Splits string to an array of character codes
     *
     * @param {string} string The input string
     * @return {Array.<number>} The character code array
     */
    stringToCode: util.stringToCode,
    /**
     * 全角英数記号文字を半角英数記号文字に変換
     *
     * Convert the ascii symbols and alphanumeric characters to
     *   the zenkaku symbols and alphanumeric characters
     *
     * @example
     *   console.log(Encoding.toHankakuCase('Ｈｅｌｌｏ Ｗｏｒｌｄ！ １２３４５'));
     *   // 'Hello World! 12345'
     *
     * @param {Array.<number>|TypedArray|string} data The input unicode data
     * @return {Array.<number>|string} The conveted data
     */
    toHankakuCase: function(data) {
      var asString = false;
      if (util.isString(data)) {
        asString = true;
        data = util.stringToBuffer(data);
      }
      var results = [];
      var len = data && data.length;
      var i = 0;
      var c;
      while (i < len) {
        c = data[i++];
        if (c >= 65281 && c <= 65374) {
          c -= 65248;
        }
        results[results.length] = c;
      }
      return asString ? util.codeToString_fast(results) : results;
    },
    /**
     * 半角英数記号文字を全角英数記号文字に変換
     *
     * Convert to the zenkaku symbols and alphanumeric characters
     *  from the ascii symbols and alphanumeric characters
     *
     * @example
     *   console.log(Encoding.toZenkakuCase('Hello World! 12345'));
     *   // 'Ｈｅｌｌｏ Ｗｏｒｌｄ！ １２３４５'
     *
     * @param {Array.<number>|TypedArray|string} data The input unicode data
     * @return {Array.<number>|string} The conveted data
     */
    toZenkakuCase: function(data) {
      var asString = false;
      if (util.isString(data)) {
        asString = true;
        data = util.stringToBuffer(data);
      }
      var results = [];
      var len = data && data.length;
      var i = 0;
      var c;
      while (i < len) {
        c = data[i++];
        if (c >= 33 && c <= 126) {
          c += 65248;
        }
        results[results.length] = c;
      }
      return asString ? util.codeToString_fast(results) : results;
    },
    /**
     * 全角カタカナを全角ひらがなに変換
     *
     * Convert to the zenkaku hiragana from the zenkaku katakana
     *
     * @example
     *   console.log(Encoding.toHiraganaCase('ボポヴァアィイゥウェエォオ'));
     *   // 'ぼぽう゛ぁあぃいぅうぇえぉお'
     *
     * @param {Array.<number>|TypedArray|string} data The input unicode data
     * @return {Array.<number>|string} The conveted data
     */
    toHiraganaCase: function(data) {
      var asString = false;
      if (util.isString(data)) {
        asString = true;
        data = util.stringToBuffer(data);
      }
      var results = [];
      var len = data && data.length;
      var i = 0;
      var c;
      while (i < len) {
        c = data[i++];
        if (c >= 12449 && c <= 12534) {
          c -= 96;
        } else if (c === 12535) {
          results[results.length] = 12431;
          c = 12443;
        } else if (c === 12538) {
          results[results.length] = 12434;
          c = 12443;
        }
        results[results.length] = c;
      }
      return asString ? util.codeToString_fast(results) : results;
    },
    /**
     * 全角ひらがなを全角カタカナに変換
     *
     * Convert to the zenkaku katakana from the zenkaku hiragana
     *
     * @example
     *   console.log(Encoding.toKatakanaCase('ぼぽう゛ぁあぃいぅうぇえぉお'));
     *   // 'ボポヴァアィイゥウェエォオ'
     *
     * @param {Array.<number>|TypedArray|string} data The input unicode data
     * @return {Array.<number>|string} The conveted data
     */
    toKatakanaCase: function(data) {
      var asString = false;
      if (util.isString(data)) {
        asString = true;
        data = util.stringToBuffer(data);
      }
      var results = [];
      var len = data && data.length;
      var i = 0;
      var c;
      while (i < len) {
        c = data[i++];
        if (c >= 12353 && c <= 12438) {
          if ((c === 12431 || // 「わ」 + 「゛」 => 「ワ゛」
          c === 12434) && // 「を」 + 「゛」 => 「ヲ゛」
          i < len && data[i] === 12443) {
            c = c === 12431 ? 12535 : 12538;
            i++;
          } else {
            c += 96;
          }
        }
        results[results.length] = c;
      }
      return asString ? util.codeToString_fast(results) : results;
    },
    /**
     * 全角カタカナを半角ｶﾀｶﾅに変換
     *
     * Convert to the hankaku katakana from the zenkaku katakana
     *
     * @example
     *   console.log(Encoding.toHankanaCase('ボポヴァアィイゥウェエォオ'));
     *   // 'ﾎﾞﾎﾟｳﾞｧｱｨｲｩｳｪｴｫｵ'
     *
     * @param {Array.<number>|TypedArray|string} data The input unicode data
     * @return {Array.<number>|string} The conveted data
     */
    toHankanaCase: function(data) {
      var asString = false;
      if (util.isString(data)) {
        asString = true;
        data = util.stringToBuffer(data);
      }
      var results = [];
      var len = data && data.length;
      var i = 0;
      var c, d, t;
      while (i < len) {
        c = data[i++];
        if (c >= 12289 && c <= 12540) {
          t = KanaCaseTable.HANKANA_TABLE[c];
          if (t !== void 0) {
            results[results.length] = t;
            continue;
          }
        }
        if (c === 12532 || c === 12535 || c === 12538) {
          results[results.length] = KanaCaseTable.HANKANA_SONANTS[c];
          results[results.length] = 65438;
        } else if (c >= 12459 && c <= 12489) {
          results[results.length] = KanaCaseTable.HANKANA_TABLE[c - 1];
          results[results.length] = 65438;
        } else if (c >= 12495 && c <= 12509) {
          d = c % 3;
          results[results.length] = KanaCaseTable.HANKANA_TABLE[c - d];
          results[results.length] = KanaCaseTable.HANKANA_MARKS[d - 1];
        } else {
          results[results.length] = c;
        }
      }
      return asString ? util.codeToString_fast(results) : results;
    },
    /**
     * 半角ｶﾀｶﾅを全角カタカナに変換 (濁音含む)
     *
     * Convert to the zenkaku katakana from the hankaku katakana
     *
     * @example
     *   console.log(Encoding.toZenkanaCase('ﾎﾞﾎﾟｳﾞｧｱｨｲｩｳｪｴｫｵ'));
     *   // 'ボポヴァアィイゥウェエォオ'
     *
     * @param {Array.<number>|TypedArray|string} data The input unicode data
     * @return {Array.<number>|string} The conveted data
     */
    toZenkanaCase: function(data) {
      var asString = false;
      if (util.isString(data)) {
        asString = true;
        data = util.stringToBuffer(data);
      }
      var results = [];
      var len = data && data.length;
      var i = 0;
      var c, code, next;
      for (i = 0; i < len; i++) {
        c = data[i];
        if (c > 65376 && c < 65440) {
          code = KanaCaseTable.ZENKANA_TABLE[c - 65377];
          if (i + 1 < len) {
            next = data[i + 1];
            if (next === 65438 && c === 65395) {
              code = 12532;
              i++;
            } else if (next === 65438 && c === 65436) {
              code = 12535;
              i++;
            } else if (next === 65438 && c === 65382) {
              code = 12538;
              i++;
            } else if (next === 65438 && (c > 65397 && c < 65413 || c > 65417 && c < 65423)) {
              code++;
              i++;
            } else if (next === 65439 && (c > 65417 && c < 65423)) {
              code += 2;
              i++;
            }
          }
          c = code;
        }
        results[results.length] = c;
      }
      return asString ? util.codeToString_fast(results) : results;
    },
    /**
     * 全角スペースを半角スペースに変換
     *
     * Convert the em space(U+3000) to the single space(U+0020)
     *
     * @param {Array.<number>|TypedArray|string} data The input unicode data
     * @return {Array.<number>|string} The conveted data
     */
    toHankakuSpace: function(data) {
      if (util.isString(data)) {
        return data.replace(/\u3000/g, " ");
      }
      var results = [];
      var len = data && data.length;
      var i = 0;
      var c;
      while (i < len) {
        c = data[i++];
        if (c === 12288) {
          c = 32;
        }
        results[results.length] = c;
      }
      return results;
    },
    /**
     * 半角スペースを全角スペースに変換
     *
     * Convert the single space(U+0020) to the em space(U+3000)
     *
     * @param {Array.<number>|TypedArray|string} data The input unicode data
     * @return {Array.<number>|string} The conveted data
     */
    toZenkakuSpace: function(data) {
      if (util.isString(data)) {
        return data.replace(/\u0020/g, "　");
      }
      var results = [];
      var len = data && data.length;
      var i = 0;
      var c;
      while (i < len) {
        c = data[i++];
        if (c === 32) {
          c = 12288;
        }
        results[results.length] = c;
      }
      return results;
    }
  };
  var src = Encoding;
  const encoding = /* @__PURE__ */ getDefaultExportFromCjs(src);
  function extractAllReplyIds(text) {
    const replyIdRegex = /&gt;&gt;(\d+)/g;
    let match;
    const replyIds = [];
    while ((match = replyIdRegex.exec(text)) !== null) {
      replyIds.push(match[1]);
    }
    return replyIds;
  }
  function parseBody(text) {
    const pattern = /(.*?)<>(.*?)<>((?:\d{4}\/\d{2}\/\d{2}\(.\) \d{2}:\d{2}:\d{2}\.\d{2})) (.+?)<>((?:.|\n)+?)<>/;
    const matches = text.match(pattern);
    if (!matches) {
      alert("Invalid text format: " + text);
      return;
    }
    let username = matches[1];
    let trip = "";
    const tripMatch = username.match(/^(.*?)<\/b>(.*?)<b>$/);
    if (tripMatch) {
      username = tripMatch[1];
      trip = tripMatch[2];
    }
    const res = {
      username,
      trip,
      email: matches[2],
      timestamp: matches[3],
      id: matches[4],
      body: matches[5],
      replyNoList: extractAllReplyIds(matches[5])
    };
    return res;
  }
  function parseMessage(message) {
    const data = JSON.parse(message);
    if (data.body.includes("3001<><>Over 3000 Thread<>")) {
      return void 0;
    }
    return {
      bbsid: data.bbsid,
      threadkey: data.threadkey,
      no: data.no,
      ...parseBody(data.body)
    };
  }
  function convertToHTML(text) {
    const urlRegex = /(https?:\/\/[^<\s]+)/g;
    text = text.replace(urlRegex, (url) => {
      if (/\.(jpeg|jpg|gif|png)$/i.test(url)) {
        return `<img src="${url}" alt="" />`;
      } else {
        return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
      }
    });
    return text;
  }
  function getTopicFromUrl(url) {
    const match = url.match(/https:\/\/bbs.jpnkn.com\/(.+?)\//);
    if (!(match == null ? void 0 : match.at(1))) {
      alert("Invalid URL: " + url);
      return "";
    }
    return (match == null ? void 0 : match.at(1)) ?? "";
  }
  async function postMessage(text, messages) {
    var _a, _b;
    const encoded = encoding.urlEncode(encoding.convert(text(), {
      to: "SJIS",
      type: "array",
      fallback: "html-entity"
    }));
    const params = `FROM=&mail=&MESSAGE=${encoded}&key=${((_a = messages().at(-1)) == null ? void 0 : _a.threadkey) ?? ""}&bbs=${((_b = messages().at(-1)) == null ? void 0 : _b.bbsid) ?? ""}`;
    await fetch("https://bbs.jpnkn.com/test/bbs.cgi", {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: params
    });
  }
  const initialData = [];
  const _tmpl$ = /* @__PURE__ */ template(`<div>`), _tmpl$2 = /* @__PURE__ */ template(`<div><div>`), _tmpl$3 = /* @__PURE__ */ template(`<button>`), _tmpl$4 = /* @__PURE__ */ template(`<div><div><div></div></div><div><textarea></textarea><button>送信`), _tmpl$5 = /* @__PURE__ */ template(`<div><div><div><span></span></div><div></div><div></div><div></div></div><div></div><div>`);
  const App = () => {
    const [messageEndRef, setMessageEndRef] = createSignal(null);
    const [mainRef, setMainRef] = createSignal(null);
    const [textareaRef, setTextareaRef] = createSignal(null);
    const [text, setText] = createSignal("");
    const [messages, setMessages] = createSignal(initialData);
    const [client, setClient] = createSignal(void 0);
    const [isAtBottom, setIsAtBottom] = createSignal(true);
    const newMessage = createReaction(() => {
      var _a;
      if (isAtBottom()) {
        (_a = messageEndRef()) == null ? void 0 : _a.scrollIntoView({
          behavior: "smooth"
        });
      }
    });
    const scrollToBottom = () => {
      var _a;
      setIsAtBottom(true);
      (_a = messageEndRef()) == null ? void 0 : _a.scrollIntoView({
        behavior: "smooth"
      });
    };
    onMount(() => {
      var _a;
      const client2 = mqtt.connect("wss://a.mq.jpnkn.com:9091/mqtt", {
        username: "genkai",
        password: "7144"
      });
      setClient(client2);
      client2.subscribe("bbs/" + getTopicFromUrl(location.href), (...args) => {
        console.log("subscribed", ...args);
      });
      client2.on("connect", (...args) => {
        console.log("connected", ...args);
      });
      client2.on("message", (topic, message) => {
        const parsedMessage = parseMessage(message.toString());
        if (!parsedMessage) {
          return;
        }
        setMessages((messages2) => [...messages2.slice(-3e3), parsedMessage]);
        newMessage(() => messages());
      });
      client2.on("error", (...args) => {
        console.log("error", ...args);
      });
      client2.on("end", (...args) => {
        console.log("end", ...args);
      });
      (_a = mainRef()) == null ? void 0 : _a.addEventListener("wheel", () => {
        var _a2, _b, _c;
        const scrollHeight = ((_a2 = mainRef()) == null ? void 0 : _a2.scrollHeight) ?? 0;
        const scrollTop = ((_b = mainRef()) == null ? void 0 : _b.scrollTop) ?? 0;
        const clientHeight = ((_c = mainRef()) == null ? void 0 : _c.clientHeight) ?? 0;
        if (scrollTop + clientHeight + 10 >= scrollHeight) {
          setIsAtBottom(true);
        } else {
          setIsAtBottom(false);
        }
      });
      return client2;
    });
    onCleanup(() => {
      var _a;
      (_a = client()) == null ? void 0 : _a.end();
    });
    const onButtonClickHandler = async (e) => {
      var _a;
      if (!messages().at(-1)) {
        alert("最初のメッセージを取得しないと投稿できません");
        return;
      }
      await postMessage(text, messages);
      setText("");
      (_a = textareaRef()) == null ? void 0 : _a.focus();
    };
    const Reply = (props) => {
      const reply2 = messages().find((m) => m.no === props.replyNo && m.threadkey === props.message.threadkey);
      const [open, setOpen] = createSignal(false);
      return (() => {
        const _el$ = _tmpl$2(), _el$4 = _el$.firstChild;
        insert(_el$, createComponent(Show, {
          get when() {
            return open() && reply2 && ((reply2 == null ? void 0 : reply2.replyNoList.length) ?? 0) > 0;
          },
          get children() {
            const _el$2 = _tmpl$();
            insert(_el$2, createComponent(For, {
              get each() {
                return reply2 == null ? void 0 : reply2.replyNoList;
              },
              children: (replyNo2) => {
                return reply2 && createComponent(Reply, {
                  message: reply2,
                  replyNo: replyNo2
                });
              }
            }));
            createRenderEffect(() => className(_el$2, styles.nestedReplyList));
            return _el$2;
          }
        }), _el$4);
        insert(_el$, createComponent(Show, {
          get when() {
            return props.message.replyNoList.length > 1;
          },
          get children() {
            const _el$3 = _tmpl$();
            insert(_el$3, () => props.replyNo);
            createRenderEffect(() => className(_el$3, styles.replyNo));
            return _el$3;
          }
        }), _el$4);
        _el$4.$$click = () => setOpen((open2) => !open2);
        createRenderEffect((_p$) => {
          const _v$ = styles.reply, _v$2 = (reply2 == null ? void 0 : reply2.replyNoList.length) ? "pointer" : "default", _v$3 = styles.replyBody, _v$4 = convertToHTML((reply2 == null ? void 0 : reply2.body) ?? "レスが見つかりません");
          _v$ !== _p$._v$ && className(_el$, _p$._v$ = _v$);
          _v$2 !== _p$._v$2 && ((_p$._v$2 = _v$2) != null ? _el$4.style.setProperty("cursor", _v$2) : _el$4.style.removeProperty("cursor"));
          _v$3 !== _p$._v$3 && className(_el$4, _p$._v$3 = _v$3);
          _v$4 !== _p$._v$4 && (_el$4.innerHTML = _p$._v$4 = _v$4);
          return _p$;
        }, {
          _v$: void 0,
          _v$2: void 0,
          _v$3: void 0,
          _v$4: void 0
        });
        return _el$;
      })();
    };
    return (() => {
      const _el$5 = _tmpl$4(), _el$6 = _el$5.firstChild, _el$8 = _el$6.firstChild, _el$9 = _el$6.nextSibling, _el$10 = _el$9.firstChild, _el$11 = _el$10.nextSibling;
      use(setMainRef, _el$6);
      insert(_el$6, createComponent(For, {
        get each() {
          return messages();
        },
        children: (message, i) => {
          return (() => {
            const _el$12 = _tmpl$5(), _el$13 = _el$12.firstChild, _el$14 = _el$13.firstChild, _el$15 = _el$14.firstChild, _el$16 = _el$14.nextSibling, _el$17 = _el$16.nextSibling, _el$18 = _el$17.nextSibling, _el$19 = _el$13.nextSibling, _el$20 = _el$19.nextSibling;
            _el$15.$$click = () => {
              var _a;
              setText((text2) => `>>${message.no}
${text2}`);
              (_a = textareaRef()) == null ? void 0 : _a.focus();
            };
            insert(_el$15, () => message.no);
            insert(_el$14, () => message.username, null);
            insert(_el$16, () => message.trip);
            insert(_el$17, () => message.timestamp);
            insert(_el$18, () => message.id);
            insert(_el$19, createComponent(For, {
              get each() {
                return message.replyNoList;
              },
              children: (replyNo2) => createComponent(Reply, {
                message,
                replyNo: replyNo2
              })
            }));
            createRenderEffect((_p$) => {
              const _v$10 = styles.messageHeader, _v$11 = styles.headerUsername, _v$12 = styles.headerNo, _v$13 = styles.headerTrip, _v$14 = styles.headerTimestamp, _v$15 = styles.headerID, _v$16 = styles.replyList, _v$17 = styles.Body, _v$18 = convertToHTML(message.body);
              _v$10 !== _p$._v$10 && className(_el$13, _p$._v$10 = _v$10);
              _v$11 !== _p$._v$11 && className(_el$14, _p$._v$11 = _v$11);
              _v$12 !== _p$._v$12 && className(_el$15, _p$._v$12 = _v$12);
              _v$13 !== _p$._v$13 && className(_el$16, _p$._v$13 = _v$13);
              _v$14 !== _p$._v$14 && className(_el$17, _p$._v$14 = _v$14);
              _v$15 !== _p$._v$15 && className(_el$18, _p$._v$15 = _v$15);
              _v$16 !== _p$._v$16 && className(_el$19, _p$._v$16 = _v$16);
              _v$17 !== _p$._v$17 && className(_el$20, _p$._v$17 = _v$17);
              _v$18 !== _p$._v$18 && (_el$20.innerHTML = _p$._v$18 = _v$18);
              return _p$;
            }, {
              _v$10: void 0,
              _v$11: void 0,
              _v$12: void 0,
              _v$13: void 0,
              _v$14: void 0,
              _v$15: void 0,
              _v$16: void 0,
              _v$17: void 0,
              _v$18: void 0
            });
            return _el$12;
          })();
        }
      }), _el$8);
      insert(_el$6, createComponent(Show, {
        get when() {
          return !isAtBottom();
        },
        get children() {
          const _el$7 = _tmpl$3();
          _el$7.$$click = scrollToBottom;
          insert(_el$7, createComponent(FiArrowDown, {}));
          createRenderEffect(() => className(_el$7, styles.scrollToBottomButton));
          return _el$7;
        }
      }), _el$8);
      use(setMessageEndRef, _el$8);
      _el$10.$$input = (e) => setText(e.target.value);
      use(setTextareaRef, _el$10);
      _el$11.$$click = onButtonClickHandler;
      createRenderEffect((_p$) => {
        const _v$5 = styles.App, _v$6 = styles.main, _v$7 = styles.form, _v$8 = `calc(${text().split("\n").length * 1.5}em + 12px)`, _v$9 = text() == "";
        _v$5 !== _p$._v$5 && className(_el$5, _p$._v$5 = _v$5);
        _v$6 !== _p$._v$6 && className(_el$6, _p$._v$6 = _v$6);
        _v$7 !== _p$._v$7 && className(_el$9, _p$._v$7 = _v$7);
        _v$8 !== _p$._v$8 && ((_p$._v$8 = _v$8) != null ? _el$10.style.setProperty("height", _v$8) : _el$10.style.removeProperty("height"));
        _v$9 !== _p$._v$9 && (_el$11.disabled = _p$._v$9 = _v$9);
        return _p$;
      }, {
        _v$5: void 0,
        _v$6: void 0,
        _v$7: void 0,
        _v$8: void 0,
        _v$9: void 0
      });
      createRenderEffect(() => _el$10.value = text());
      return _el$5;
    })();
  };
  delegateEvents(["click", "input"]);
  if (location.pathname.endsWith("/stream-client")) {
    document.title = "Stream Client";
    render(() => createComponent(App, {}), (() => {
      const app = document.createElement("div");
      app.style.flex = "1";
      document.body.innerHTML = "";
      document.body.append(app);
      return app;
    })());
  } else {
    const sidemenu = document.querySelector("body > div.sidemenu > ul");
    if (sidemenu) {
      const li = document.createElement("li");
      li.innerHTML = `<a class="nav-link" href="${location.href}/stream-client">
        <span class="min">Stream Client</span>
    </a>`;
      li.classList.add("nav-item");
      sidemenu.append(li);
    }
  }

})();
