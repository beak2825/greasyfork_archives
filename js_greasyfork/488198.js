// ==UserScript==
// @name         聚水潭 Tools
// @namespace    npm/vite-plugin-monkey
// @version      0.0.4
// @author       BF-<2581807417@qq.com>
// @description  聚水潭(erp321.com) 快捷工具 包含快递单号录入 排除等
// @copyright    北风-JST
// @icon         http://q2.qlogo.cn/headimg_dl?dst_uin=2581807417&spec=100
// @match        *://www.erp321.com/epaas
// @require      https://unpkg.com/vue@3.4.14/dist/vue.global.prod.js
// @require      https://unpkg.com/vue-demi@latest/lib/index.iife.js
// @require      data:application/javascript,%3Bwindow.Vue%3DVue%3B
// @require      https://unpkg.com/pinia@2.1.7/dist/pinia.iife.prod.js
// @grant        GM_addStyle
// @downloadURL https://update.greasyfork.org/scripts/488198/%E8%81%9A%E6%B0%B4%E6%BD%AD%20Tools.user.js
// @updateURL https://update.greasyfork.org/scripts/488198/%E8%81%9A%E6%B0%B4%E6%BD%AD%20Tools.meta.js
// ==/UserScript==

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const r=document.createElement("style");r.textContent=e,document.head.append(r)})(` @charset "UTF-8";:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645, .045, .355, 1);--el-transition-function-fast-bezier:cubic-bezier(.23, 1, .32, 1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, .04),0px 8px 20px rgba(0, 0, 0, .08);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, .12);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, .12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, .08),0px 12px 32px rgba(0, 0, 0, .12),0px 8px 16px -8px rgba(0, 0, 0, .16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0, 0, 0, .8);--el-overlay-color-light:rgba(0, 0, 0, .7);--el-overlay-color-lighter:rgba(0, 0, 0, .5);--el-mask-color:rgba(255, 255, 255, .9);--el-mask-color-extra-light:rgba(255, 255, 255, .3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center top}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center bottom}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transition:var(--el-transition-md-fade);transform-origin:top left}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.el-icon{--color:inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{-webkit-animation:v-modal-in var(--el-transition-duration-fast) ease;animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{-webkit-animation:v-modal-out var(--el-transition-duration-fast) ease forwards;animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{to{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:var(--el-popup-modal-opacity);background:var(--el-popup-modal-bg-color)}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:20px;--el-dialog-border-radius:var(--el-border-radius-small);position:relative;margin:var(--el-dialog-margin-top,15vh) auto 50px;background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:0!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;margin-bottom:0;height:100%;overflow:auto}.el-dialog__wrapper{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto;margin:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-dialog__header{padding:var(--el-dialog-padding-primary);padding-bottom:10px;margin-right:16px}.el-dialog__headerbtn{position:absolute;top:6px;right:0;padding:0;width:54px;height:54px;background:0 0;border:none;outline:0;cursor:pointer;font-size:var(--el-message-close-size,16px)}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{line-height:var(--el-dialog-font-line-height);font-size:var(--el-dialog-title-font-size);color:var(--el-text-color-primary)}.el-dialog__body{padding:calc(var(--el-dialog-padding-primary) + 10px) var(--el-dialog-padding-primary);color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{padding:var(--el-dialog-padding-primary);padding-top:10px;text-align:right;box-sizing:border-box}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial;padding:25px calc(var(--el-dialog-padding-primary) + 5px) 30px}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto}.dialog-fade-enter-active{-webkit-animation:modal-fade-in var(--el-transition-duration);animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{-webkit-animation:dialog-fade-in var(--el-transition-duration);animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{-webkit-animation:modal-fade-out var(--el-transition-duration);animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{-webkit-animation:dialog-fade-out var(--el-transition-duration);animation:dialog-fade-out var(--el-transition-duration)}@-webkit-keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@-webkit-keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@-webkit-keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@-webkit-keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-overlay{position:fixed;top:0;right:0;bottom:0;left:0;z-index:2000;height:100%;background-color:var(--el-overlay-color-lighter);overflow:auto}.el-overlay .el-overlay-root{height:0}.express-order-item[data-v-36b4850e]{display:flex;align-items:center;justify-content:space-between;gap:.875rem;border-bottom-width:1px;--un-border-opacity:1;--un-border-bottom-opacity:var(--un-border-opacity);border-bottom-color:rgb(243 244 246 / var(--un-border-bottom-opacity));border-bottom-style:solid;padding-top:2px;padding-bottom:2px}.express-order-item .express-order-item__value[data-v-36b4850e]{max-width:70%;display:flex;flex-shrink:0;flex-direction:column;align-items:flex-end}.express-order{position:relative;z-index:0;margin-top:3px;margin-bottom:3px;display:flex;align-items:center;gap:.875rem;overflow:hidden;border-width:1px;--un-border-opacity:1;border-color:rgb(209 213 219 / var(--un-border-opacity));border-radius:.25rem;border-style:solid;padding:.875rem;font-size:1em}.express-order:hover{--un-bg-opacity:1;background-color:rgb(156 163 175 / var(--un-bg-opacity));--un-bg-opacity:.02;--un-shadow:var(--un-shadow-inset) 0 4px 6px -1px var(--un-shadow-color, rgb(0 0 0 / .1)),var(--un-shadow-inset) 0 2px 4px -2px var(--un-shadow-color, rgb(0 0 0 / .1));box-shadow:var(--un-ring-offset-shadow),var(--un-ring-shadow),var(--un-shadow)}.express-order[data-flag="1"]:after{background:#fd0d0d}.express-order[data-flag="2"]:after{background:#fcf700}.express-order[data-flag="3"]:after{background:#00fd28}.express-order[data-flag="4"]:after{background:#0051fd}.express-order[data-flag="5"]:after{background:#e000fc}.express-order:after{content:"";pointer-events:none;position:absolute;right:0;top:0;z-index:-1;min-width:7.5rem;min-height:7.5rem;--un-translate-x:50%;--un-translate-y:-50%;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-rotate:45deg;transform:translate(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotate(var(--un-rotate-z)) skew(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));border-radius:9999px}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius, 4px)}.el-popper{position:absolute;border-radius:var(--el-popper-border-radius);padding:5px 11px;z-index:2000;font-size:12px;line-height:20px;min-width:10px;overflow-wrap:break-word;visibility:visible}.el-popper.is-dark{color:var(--el-bg-color);background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark .el-popper__arrow:before{border:1px solid var(--el-text-color-primary);background:var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow:before{border:1px solid var(--el-border-color-light);background:var(--el-bg-color-overlay);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{position:absolute;width:10px;height:10px;z-index:-1}.el-popper__arrow:before{position:absolute;width:10px;height:10px;z-index:-1;content:" ";transform:rotate(45deg);background:var(--el-text-color-primary);box-sizing:border-box}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent!important;border-bottom-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-popover{--el-popover-bg-color:var(--el-bg-color-overlay);--el-popover-font-size:var(--el-font-size-base);--el-popover-border-color:var(--el-border-color-lighter);--el-popover-padding:12px;--el-popover-padding-large:18px 20px;--el-popover-title-font-size:16px;--el-popover-title-text-color:var(--el-text-color-primary);--el-popover-border-radius:4px}.el-popover.el-popper{background:var(--el-popover-bg-color);min-width:150px;border-radius:var(--el-popover-border-radius);border:1px solid var(--el-popover-border-color);padding:var(--el-popover-padding);z-index:var(--el-index-popper);color:var(--el-text-color-regular);line-height:1.4;font-size:var(--el-popover-font-size);box-shadow:var(--el-box-shadow-light);overflow-wrap:break-word;box-sizing:border-box}.el-popover.el-popper--plain{padding:var(--el-popover-padding-large)}.el-popover__title{color:var(--el-popover-title-text-color);font-size:var(--el-popover-title-font-size);line-height:1;margin-bottom:12px}.el-popover__reference:focus:hover,.el-popover__reference:focus:not(.focusing){outline-width:0}.el-popover.el-popper.is-dark{--el-popover-bg-color:var(--el-text-color-primary);--el-popover-border-color:var(--el-text-color-primary);--el-popover-title-text-color:var(--el-bg-color);color:var(--el-bg-color)}.el-popover.el-popper:focus,.el-popover.el-popper:focus:active{outline-width:0}.el-checkbox-group{font-size:0;line-height:0}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary)}.el-checkbox{color:var(--el-checkbox-text-color);font-weight:var(--el-checkbox-font-weight);font-size:var(--el-font-size-base);position:relative;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-right:30px;height:var(--el-checkbox-height,32px)}.el-checkbox.is-disabled{cursor:not-allowed}.el-checkbox.is-bordered{padding:0 15px 0 9px;border-radius:var(--el-border-radius-base);border:var(--el-border);box-sizing:border-box}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter)}.el-checkbox.is-bordered.el-checkbox--large{padding:0 19px 0 11px;border-radius:var(--el-border-radius-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{padding:0 11px 0 7px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px;border-radius:var(--el-checkbox-border-radius)}.el-checkbox__input{white-space:nowrap;cursor:pointer;outline:0;display:inline-flex;position:relative}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{cursor:not-allowed;border-color:var(--el-checkbox-disabled-icon-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{transform:rotate(45deg) scaleY(1);border-color:var(--el-checkbox-checked-icon-color)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{content:"";position:absolute;display:block;background-color:var(--el-checkbox-checked-icon-color);height:2px;transform:scale(.5);left:0;right:0;top:5px}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{display:inline-block;position:relative;border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;width:var(--el-checkbox-input-width);height:var(--el-checkbox-input-height);background-color:var(--el-checkbox-bg-color);z-index:var(--el-index-normal);transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{box-sizing:content-box;content:"";border:1px solid transparent;border-left:0;border-top:0;height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);width:3px;transition:transform .15s ease-in 50ms;transform-origin:center}.el-checkbox__original{opacity:0;outline:0;position:absolute;margin:0;width:0;height:0;z-index:-1}.el-checkbox__label{display:inline-block;padding-left:8px;line-height:1;font-size:var(--el-checkbox-font-size)}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{width:14px;height:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{width:12px;height:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{width:2px;height:6px}.el-checkbox:last-of-type{margin-right:0}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--label-left .el-form-item__label{justify-content:flex-start}.el-form--label-top .el-form-item{display:block}.el-form--label-top .el-form-item .el-form-item__label{display:block;height:auto;text-align:left;margin-bottom:8px;line-height:22px}.el-form--inline .el-form-item{display:inline-flex;vertical-align:middle;margin-right:32px}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form--large.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:12px;line-height:22px}.el-form--default.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:8px;line-height:22px}.el-form--small.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:4px;line-height:20px}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item__label-wrap{display:flex}.el-form-item__label{display:inline-flex;justify-content:flex-end;align-items:flex-start;flex:0 0 auto;font-size:var(--el-form-label-font-size);color:var(--el-text-color-regular);height:32px;line-height:32px;padding:0 12px 0 0;box-sizing:border-box}.el-form-item__content{display:flex;flex-wrap:wrap;align-items:center;flex:1;line-height:32px;position:relative;font-size:var(--font-size);min-width:0}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;line-height:1;padding-top:2px;position:absolute;top:100%;left:0}.el-form-item__error--inline{position:relative;top:auto;left:auto;display:inline-block;margin-left:10px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{content:"*";color:var(--el-color-danger);margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{content:"*";color:var(--el-color-danger);margin-left:4px}.el-form-item.is-error .el-input__wrapper,.el-form-item.is-error .el-input__wrapper.is-focus,.el-form-item.is-error .el-input__wrapper:focus,.el-form-item.is-error .el-input__wrapper:hover,.el-form-item.is-error .el-select__wrapper,.el-form-item.is-error .el-select__wrapper.is-focus,.el-form-item.is-error .el-select__wrapper:focus,.el-form-item.is-error .el-select__wrapper:hover,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner.is-focus,.el-form-item.is-error .el-textarea__inner:focus,.el-form-item.is-error .el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:0 0 0 1px transparent inset}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-textarea{position:relative;display:inline-block;width:100%;vertical-align:bottom;font-size:var(--el-font-size-base)}.el-textarea__inner{position:relative;display:block;resize:vertical;padding:5px 11px;line-height:1.5;box-sizing:border-box;width:100%;font-size:inherit;font-family:inherit;color:var(--el-input-text-color,var(--el-text-color-regular));background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;-webkit-appearance:none;box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);border:none}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{outline:0;box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-textarea .el-input__count{color:var(--el-color-info);background:var(--el-fill-color-blank);position:absolute;font-size:12px;line-height:14px;bottom:5px;right:10px}.el-textarea.is-disabled .el-textarea__inner{box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-input{--el-input-height:var(--el-component-size);position:relative;font-size:var(--el-font-size-base);display:inline-flex;width:var(--el-input-width);line-height:var(--el-input-height);box-sizing:border-box;vertical-align:middle}.el-input::-webkit-scrollbar{z-index:11;width:6px}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{border-radius:5px;width:6px;background:var(--el-text-color-disabled)}.el-input::-webkit-scrollbar-corner{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);font-size:14px;cursor:pointer}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{height:100%;display:inline-flex;align-items:center;color:var(--el-color-info);font-size:12px}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);line-height:initial;display:inline-block;padding-left:8px}.el-input__wrapper{display:inline-flex;flex-grow:1;align-items:center;justify-content:center;padding:1px 11px;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));cursor:text;transition:var(--el-transition-box-shadow);transform:translateZ(0);box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);width:100%;flex-grow:1;-webkit-appearance:none;color:var(--el-input-text-color,var(--el-text-color-regular));font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);padding:0;outline:0;border:none;background:0 0;box-sizing:border-box}.el-input__inner:focus{outline:0}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__prefix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__suffix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{height:inherit;line-height:inherit;display:flex;justify-content:center;align-items:center;transition:all var(--el-transition-duration);margin-left:8px}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color,) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{display:inline-flex;width:100%;align-items:stretch}.el-input-group__append,.el-input-group__prepend{background-color:var(--el-fill-color-light);color:var(--el-color-info);position:relative;display:inline-flex;align-items:center;justify-content:center;min-height:100%;border-radius:var(--el-input-border-radius);padding:0 20px;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:0}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{border-color:transparent;background-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-right:0;border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px}.el-tag{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);--el-tag-text-color:var(--el-color-primary);background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);color:var(--el-tag-text-color);display:inline-flex;justify-content:center;align-items:center;vertical-align:middle;height:24px;padding:0 9px;font-size:var(--el-tag-font-size);line-height:1;border-width:1px;border-style:solid;border-radius:var(--el-tag-border-radius);box-sizing:border-box;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{flex-shrink:0;color:var(--el-tag-text-color)}.el-tag .el-tag__close:hover{color:var(--el-color-white);background-color:var(--el-tag-hover-color)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning,.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{padding:0 11px;height:32px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{padding:0 7px;height:20px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary)}.el-scrollbar{overflow:hidden;position:relative;height:100%}.el-scrollbar__wrap{overflow:auto;height:100%}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{position:relative;display:block;width:0;height:0;cursor:pointer;border-radius:inherit;background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));transition:var(--el-transition-duration) background-color;opacity:var(--el-scrollbar-opacity,.3)}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px}.el-scrollbar__bar.is-vertical{width:6px;top:2px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-select-dropdown{z-index:calc(var(--el-index-top) + 1);border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__loading,.el-select-dropdown__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:var(--el-select-font-size)}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{list-style:none;padding:6px 0;margin:0;box-sizing:border-box}.el-select-dropdown__list.el-vl__window{margin:6px 0;padding:0}.el-select-dropdown__header{padding:10px;border-bottom:1px solid var(--el-border-color-light)}.el-select-dropdown__footer{padding:10px;border-top:1px solid var(--el-border-color-light)}.el-select-dropdown__item{font-size:var(--el-font-size-base);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__item.is-hovering{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.is-selected{color:var(--el-color-primary);font-weight:700}.el-select-dropdown__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed;background-color:unset}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-disabled:after{background-color:var(--el-text-color-placeholder)}.el-select-group{margin:0;padding:0}.el-select-group__wrap{position:relative;list-style:none;margin:0;padding:0}.el-select-group__wrap:not(:last-of-type){padding-bottom:24px}.el-select-group__wrap:not(:last-of-type):after{content:"";position:absolute;display:block;left:20px;right:20px;bottom:12px;height:1px;background:var(--el-border-color-light)}.el-select-group__split-dash{position:absolute;left:20px;right:20px;height:1px;background:var(--el-border-color-light)}.el-select-group__title{padding-left:20px;font-size:12px;color:var(--el-color-info);line-height:30px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px;--el-select-width:100%}.el-select{display:inline-block;position:relative;vertical-align:middle;width:var(--el-select-width)}.el-select__wrapper{display:flex;align-items:center;position:relative;box-sizing:border-box;cursor:pointer;text-align:left;font-size:14px;padding:4px 12px;gap:6px;min-height:32px;line-height:24px;border-radius:var(--el-border-radius-base);background-color:var(--el-fill-color-blank);transition:var(--el-transition-duration);box-shadow:0 0 0 1px var(--el-border-color) inset}.el-select__wrapper:hover{box-shadow:0 0 0 1px var(--el-text-color) inset}.el-select__wrapper.is-filterable{cursor:text}.el-select__wrapper.is-focused{box-shadow:0 0 0 1px var(--el-color-primary) inset}.el-select__wrapper.is-hovering:not(.is-focused){box-shadow:0 0 0 1px var(--el-border-color-hover) inset}.el-select__wrapper.is-disabled{cursor:not-allowed;background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-select__wrapper.is-disabled .el-select__caret,.el-select__wrapper.is-disabled .el-tag{cursor:not-allowed}.el-select__prefix,.el-select__suffix{display:flex;align-items:center;flex-shrink:0;gap:6px;color:var(--el-input-icon-color,var(--el-text-color-placeholder))}.el-select__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:var(--el-transition-duration);transform:rotate(0);cursor:pointer}.el-select__caret.is-reverse{transform:rotate(180deg)}.el-select__selection{position:relative;display:flex;flex-wrap:wrap;align-items:center;flex:1;min-width:0;gap:6px}.el-select__selection.is-near{margin-left:-8px}.el-select__selection .el-tag{cursor:pointer;border-color:transparent}.el-select__selection .el-tag .el-tag__content{min-width:0}.el-select__selected-item{display:flex;flex-wrap:wrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select__tags-text{display:block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select__placeholder{position:absolute;display:block;top:50%;transform:translateY(-50%);width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--el-input-text-color,var(--el-text-color-regular))}.el-select__placeholder.is-transparent{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:var(--el-text-color-placeholder)}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select__input-wrapper{max-width:100%}.el-select__input-wrapper.is-hidden{position:absolute;opacity:0}.el-select__input{border:none;outline:0;padding:0;color:var(--el-select-multiple-input-color);font-size:inherit;font-family:inherit;-webkit-appearance:none;-moz-appearance:none;appearance:none;height:24px;max-width:100%;background-color:transparent}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input-calculator{position:absolute;left:0;top:0;max-width:100%;visibility:hidden;white-space:pre;overflow:hidden}.el-select--large .el-select__wrapper{gap:6px;padding:8px 16px;min-height:40px;line-height:24px;font-size:14px}.el-select--large .el-select__selection{gap:6px}.el-select--large .el-select__selection.is-near{margin-left:-8px}.el-select--large .el-select__prefix,.el-select--large .el-select__suffix{gap:6px}.el-select--large .el-select__input{height:24px}.el-select--small .el-select__wrapper{gap:4px;padding:2px 8px;min-height:24px;line-height:20px;font-size:12px}.el-select--small .el-select__selection{gap:4px}.el-select--small .el-select__selection.is-near{margin-left:-6px}.el-select--small .el-select__prefix,.el-select--small .el-select__suffix{gap:4px}.el-select--small .el-select__input{height:20px}.el-notification{--el-notification-width:330px;--el-notification-padding:14px 26px 14px 13px;--el-notification-radius:8px;--el-notification-shadow:var(--el-box-shadow-light);--el-notification-border-color:var(--el-border-color-lighter);--el-notification-icon-size:24px;--el-notification-close-font-size:var(--el-message-close-size, 16px);--el-notification-group-margin-left:13px;--el-notification-group-margin-right:8px;--el-notification-content-font-size:var(--el-font-size-base);--el-notification-content-color:var(--el-text-color-regular);--el-notification-title-font-size:16px;--el-notification-title-color:var(--el-text-color-primary);--el-notification-close-color:var(--el-text-color-secondary);--el-notification-close-hover-color:var(--el-text-color-regular)}.el-notification{display:flex;width:var(--el-notification-width);padding:var(--el-notification-padding);border-radius:var(--el-notification-radius);box-sizing:border-box;border:1px solid var(--el-notification-border-color);position:fixed;background-color:var(--el-bg-color-overlay);box-shadow:var(--el-notification-shadow);transition:opacity var(--el-transition-duration),transform var(--el-transition-duration),left var(--el-transition-duration),right var(--el-transition-duration),top .4s,bottom var(--el-transition-duration);overflow-wrap:break-word;overflow:hidden;z-index:9999}.el-notification.right{right:16px}.el-notification.left{left:16px}.el-notification__group{margin-left:var(--el-notification-group-margin-left);margin-right:var(--el-notification-group-margin-right)}.el-notification__title{font-weight:700;font-size:var(--el-notification-title-font-size);line-height:var(--el-notification-icon-size);color:var(--el-notification-title-color);margin:0}.el-notification__content{font-size:var(--el-notification-content-font-size);line-height:24px;margin:6px 0 0;color:var(--el-notification-content-color)}.el-notification__content p{margin:0}.el-notification .el-notification__icon{height:var(--el-notification-icon-size);width:var(--el-notification-icon-size);font-size:var(--el-notification-icon-size)}.el-notification .el-notification__closeBtn{position:absolute;top:18px;right:15px;cursor:pointer;color:var(--el-notification-close-color);font-size:var(--el-notification-close-font-size)}.el-notification .el-notification__closeBtn:hover{color:var(--el-notification-close-hover-color)}.el-notification .el-notification--success{--el-notification-icon-color:var(--el-color-success);color:var(--el-notification-icon-color)}.el-notification .el-notification--info{--el-notification-icon-color:var(--el-color-info);color:var(--el-notification-icon-color)}.el-notification .el-notification--warning{--el-notification-icon-color:var(--el-color-warning);color:var(--el-notification-icon-color)}.el-notification .el-notification--error{--el-notification-icon-color:var(--el-color-error);color:var(--el-notification-icon-color)}.el-notification-fade-enter-from.right{right:0;transform:translate(100%)}.el-notification-fade-enter-from.left{left:0;transform:translate(-100%)}.el-notification-fade-leave-to{opacity:0}.bf-dailog .el-dialog__body{padding:unset;padding-left:var(--el-dialog-padding-primary);padding-right:var(--el-dialog-padding-primary);padding-bottom:var(--el-dialog-padding-primary)}.bf-setting__form.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:0;--un-bg-opacity:1;background-color:rgb(243 244 246 / var(--un-bg-opacity));padding-left:.875rem;padding-right:.875rem;padding-top:3px;padding-bottom:3px;--un-text-opacity:1;color:rgb(107 114 128 / var(--un-text-opacity))}.bf-setting__form.el-form--label-top .el-form-item .el-form-item__content{border-width:1px;--un-border-opacity:1;border-color:rgb(243 244 246 / var(--un-border-opacity));border-style:solid;padding-left:1.125rem}.bf-setting__form .el-checkbox-group{font-size:14px;line-height:initial}:where(html){line-height:1.15}:where(h1){font-size:2em;margin-block-end:.67em;margin-block-start:.67em}:where(dl,ol,ul) :where(dl,ol,ul){margin-block-end:0;margin-block-start:0}:where(hr){box-sizing:content-box;color:inherit;height:0}:where(pre){font-family:monospace,monospace;font-size:1em}:where(abbr[title]){text-decoration:underline;text-decoration:underline dotted}:where(b,strong){font-weight:bolder}:where(code,kbd,samp){font-family:monospace,monospace;font-size:1em}:where(small){font-size:80%}:where(table){border-color:currentColor;text-indent:0}:where(button,input,select){margin:0}:where(button){text-transform:none}:where(button,input:is([type=button i],[type=reset i],[type=submit i])){-webkit-appearance:button}:where(progress){vertical-align:baseline}:where(select){text-transform:none}:where(textarea){margin:0}:where(input[type=search i]){-webkit-appearance:textfield;outline-offset:-2px}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}:where(button,input:is([type=button i],[type=color i],[type=reset i],[type=submit i]))::-moz-focus-inner{border-style:none;padding:0}:where(button,input:is([type=button i],[type=color i],[type=reset i],[type=submit i]))::-moz-focusring{outline:1px dotted ButtonText}:where(:-moz-ui-invalid){box-shadow:none}:where(dialog){background-color:#fff;border:solid;color:#000;height:-moz-fit-content;height:fit-content;left:0;margin:auto;padding:1em;position:absolute;right:0;width:-moz-fit-content;width:fit-content}:where(dialog:not([open])){display:none}:where(summary){display:list-item}*,:before,:after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / .5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: }::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / .5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: }.i-carbon\\:center-to-fit,[i-carbon\\:center-to-fit=""]{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 32 32' display='inline-block' vertical-align='middle' width='1.2em' height='1.2em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M8 2H2v6h2V4h4zm16 0h6v6h-2V4h-4zM8 30H2v-6h2v4h4zm16 0h6v-6h-2v4h-4zm0-6H8a2.002 2.002 0 0 1-2-2V10a2.002 2.002 0 0 1 2-2h16a2.002 2.002 0 0 1 2 2v12a2.002 2.002 0 0 1-2 2M8 10v12h16V10z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1.2em;height:1.2em}.i-carbon\\:filter,[i-carbon\\:filter=""]{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 32 32' display='inline-block' vertical-align='middle' width='1.2em' height='1.2em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M18 28h-4a2 2 0 0 1-2-2v-7.59L4.59 11A2 2 0 0 1 4 9.59V6a2 2 0 0 1 2-2h20a2 2 0 0 1 2 2v3.59a2 2 0 0 1-.59 1.41L20 18.41V26a2 2 0 0 1-2 2M6 6v3.59l8 8V26h4v-8.41l8-8V6Z'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1.2em;height:1.2em}.i-carbon\\:search,[i-carbon\\:search=""]{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 32 32' display='inline-block' vertical-align='middle' width='1.2em' height='1.2em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='m29 27.586l-7.552-7.552a11.018 11.018 0 1 0-1.414 1.414L27.586 29ZM4 13a9 9 0 1 1 9 9a9.01 9.01 0 0 1-9-9'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1.2em;height:1.2em}.i-carbon\\:settings,[i-carbon\\:settings=""]{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 32 32' display='inline-block' vertical-align='middle' width='1.2em' height='1.2em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M27 16.76v-1.53l1.92-1.68A2 2 0 0 0 29.3 11l-2.36-4a2 2 0 0 0-1.73-1a2 2 0 0 0-.64.1l-2.43.82a11.35 11.35 0 0 0-1.31-.75l-.51-2.52a2 2 0 0 0-2-1.61h-4.68a2 2 0 0 0-2 1.61l-.51 2.52a11.48 11.48 0 0 0-1.32.75l-2.38-.86A2 2 0 0 0 6.79 6a2 2 0 0 0-1.73 1L2.7 11a2 2 0 0 0 .41 2.51L5 15.24v1.53l-1.89 1.68A2 2 0 0 0 2.7 21l2.36 4a2 2 0 0 0 1.73 1a2 2 0 0 0 .64-.1l2.43-.82a11.35 11.35 0 0 0 1.31.75l.51 2.52a2 2 0 0 0 2 1.61h4.72a2 2 0 0 0 2-1.61l.51-2.52a11.48 11.48 0 0 0 1.32-.75l2.42.82a2 2 0 0 0 .64.1a2 2 0 0 0 1.73-1l2.28-4a2 2 0 0 0-.41-2.51ZM25.21 24l-3.43-1.16a8.86 8.86 0 0 1-2.71 1.57L18.36 28h-4.72l-.71-3.55a9.36 9.36 0 0 1-2.7-1.57L6.79 24l-2.36-4l2.72-2.4a8.9 8.9 0 0 1 0-3.13L4.43 12l2.36-4l3.43 1.16a8.86 8.86 0 0 1 2.71-1.57L13.64 4h4.72l.71 3.55a9.36 9.36 0 0 1 2.7 1.57L25.21 8l2.36 4l-2.72 2.4a8.9 8.9 0 0 1 0 3.13L27.57 20Z'/%3E%3Cpath fill='currentColor' d='M16 22a6 6 0 1 1 6-6a5.94 5.94 0 0 1-6 6m0-10a3.91 3.91 0 0 0-4 4a3.91 3.91 0 0 0 4 4a3.91 3.91 0 0 0 4-4a3.91 3.91 0 0 0-4-4'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1.2em;height:1.2em}.i-carbon\\:shape-exclude{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 32 32' display='inline-block' vertical-align='middle' width='1.2em' height='1.2em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='M12 10h10V4a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h6V12a2 2 0 0 1 2-2'/%3E%3Cpath fill='currentColor' d='M28 10h-6v10a2 2 0 0 1-2 2H10v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V12a2 2 0 0 0-2-2'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1.2em;height:1.2em}.i-carbon\\:web-services-container,[i-carbon\\:web-services-container=""]{--un-icon:url("data:image/svg+xml;utf8,%3Csvg viewBox='0 0 32 32' display='inline-block' vertical-align='middle' width='1.2em' height='1.2em' xmlns='http://www.w3.org/2000/svg' %3E%3Cpath fill='currentColor' d='m22.505 11.637l-5.989-3.5a1 1 0 0 0-1.008-.001l-6.011 3.5A1 1 0 0 0 9 12.5v7a1 1 0 0 0 .497.864l6.011 3.5A.96.96 0 0 0 16 24c.174 0 .36-.045.516-.137l5.989-3.5A1 1 0 0 0 23 19.5v-7a1 1 0 0 0-.495-.863m-6.494-1.48l4.007 2.343l-4.007 2.342l-4.023-2.342zM11 14.24l4 2.33v4.685l-4-2.33zm6 7.025v-4.683l4-2.338v4.683z'/%3E%3Cpath fill='currentColor' d='M16 1a1 1 0 0 0-.504.136l-12 7A1 1 0 0 0 3 9v14a1 1 0 0 0 .496.864l12 7a1 1 0 0 0 1.008 0l11-6.417l-1.008-1.727L16 28.842L5 22.426V9.575l11-6.417l11 6.416V17h2V9a1 1 0 0 0-.496-.864l-12-7A1 1 0 0 0 16 1'/%3E%3C/svg%3E");-webkit-mask:var(--un-icon) no-repeat;mask:var(--un-icon) no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;background-color:currentColor;color:inherit;display:inline-block;vertical-align:middle;width:1.2em;height:1.2em}.prose :where(h1,h2,h3,h4,h5,h6):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-headings);font-weight:600;line-height:1.25}.prose :where(a):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links);text-decoration:underline;font-weight:500}.prose :where(a code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-links)}.prose :where(p,ul,ol,pre):not(:where(.not-prose,.not-prose *)){margin:1em 0;line-height:1.75}.prose :where(blockquote):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding-left:1em;font-style:italic;border-left:.25em solid var(--un-prose-borders)}.prose :where(h1):not(:where(.not-prose,.not-prose *)){margin:1rem 0;font-size:2.25em}.prose :where(h2):not(:where(.not-prose,.not-prose *)){margin:1.75em 0 .5em;font-size:1.75em}.prose :where(h3):not(:where(.not-prose,.not-prose *)){margin:1.5em 0 .5em;font-size:1.375em}.prose :where(h4):not(:where(.not-prose,.not-prose *)){margin:1em 0;font-size:1.125em}.prose :where(img,video):not(:where(.not-prose,.not-prose *)){max-width:100%}.prose :where(figure,picture):not(:where(.not-prose,.not-prose *)){margin:1em 0}.prose :where(figcaption):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-captions);font-size:.875em}.prose :where(code):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);font-size:.875em;font-weight:600;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.prose :where(:not(pre)>code):not(:where(.not-prose,.not-prose *)):before,.prose :where(:not(pre)>code):not(:where(.not-prose,.not-prose *)):after{content:"\`"}.prose :where(pre):not(:where(.not-prose,.not-prose *)){padding:1.25rem 1.5rem;overflow-x:auto;border-radius:.375rem}.prose :where(pre,code):not(:where(.not-prose,.not-prose *)){white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;hyphens:none;background:transparent}.prose :where(pre code):not(:where(.not-prose,.not-prose *)){font-weight:inherit}.prose :where(ol,ul):not(:where(.not-prose,.not-prose *)){padding-left:1.25em}.prose :where(ol):not(:where(.not-prose,.not-prose *)){list-style-type:decimal}.prose :where(ol[type=A]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha}.prose :where(ol[type=a]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha}.prose :where(ol[type=A s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-alpha}.prose :where(ol[type=a s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-alpha}.prose :where(ol[type=I]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman}.prose :where(ol[type=i]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman}.prose :where(ol[type=I s]):not(:where(.not-prose,.not-prose *)){list-style-type:upper-roman}.prose :where(ol[type=i s]):not(:where(.not-prose,.not-prose *)){list-style-type:lower-roman}.prose :where(ol[type="1"]):not(:where(.not-prose,.not-prose *)){list-style-type:decimal}.prose :where(ul):not(:where(.not-prose,.not-prose *)){list-style-type:disc}.prose :where(ol>li):not(:where(.not-prose,.not-prose *))::marker,.prose :where(ul>li):not(:where(.not-prose,.not-prose *))::marker,.prose :where(summary):not(:where(.not-prose,.not-prose *))::marker{color:var(--un-prose-lists)}.prose :where(hr):not(:where(.not-prose,.not-prose *)){margin:2em 0;border:1px solid var(--un-prose-hr)}.prose :where(table):not(:where(.not-prose,.not-prose *)){display:block;margin:1em 0;border-collapse:collapse;overflow-x:auto}.prose :where(tr):not(:where(.not-prose,.not-prose *)):nth-child(2n){background:var(--un-prose-bg-soft)}.prose :where(td,th):not(:where(.not-prose,.not-prose *)){border:1px solid var(--un-prose-borders);padding:.625em 1em}.prose :where(abbr):not(:where(.not-prose,.not-prose *)){cursor:help}.prose :where(kbd):not(:where(.not-prose,.not-prose *)){color:var(--un-prose-code);border:1px solid;padding:.25rem .5rem;font-size:.875em;border-radius:.25rem}.prose :where(details):not(:where(.not-prose,.not-prose *)){margin:1em 0;padding:1.25rem 1.5rem;background:var(--un-prose-bg-soft)}.prose :where(summary):not(:where(.not-prose,.not-prose *)){cursor:pointer;font-weight:600}.prose{color:var(--un-prose-body);max-width:65ch}.pointer-events-none{pointer-events:none}.absolute{position:absolute}.relative{position:relative}.right-0{right:0}.top-0{top:0}.z--1{z-index:-1}.z-0{z-index:0}.grid{display:grid}.grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.m-auto{margin:auto}.my-3px{margin-top:3px;margin-bottom:3px}.mb-0{margin-bottom:0}.mb-xs{margin-bottom:.75rem}.mr-auto,[mr-auto=""]{margin-right:auto}.size-min-30{min-width:7.5rem;min-height:7.5rem}.h-60vh{height:60vh}.max-w-7\\/10{max-width:70%}.w-full,[w-full=""]{width:100%}.w-lg,[w-lg=""]{width:32rem}.flex,[flex=""]{display:flex}.flex-1,[flex-1=""]{flex:1 1 0%}.shrink-0{flex-shrink:0}.flex-col{flex-direction:column}.translate-x-1\\/2{--un-translate-x:50%;transform:translate(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotate(var(--un-rotate-z)) skew(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z))}.translate-y--1\\/2{--un-translate-y:-50%;transform:translate(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotate(var(--un-rotate-z)) skew(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z))}.rotate-45{--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-rotate:45deg;transform:translate(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotate(var(--un-rotate-z)) skew(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z))}.items-end{align-items:flex-end}.items-center,[items-center=""]{align-items:center}.items-baseline,[items-baseline=""]{align-items:baseline}.justify-end{justify-content:flex-end}.justify-center,[justify-center=""]{justify-content:center}.justify-between{justify-content:space-between}.gap-sm,[gap-sm=""]{gap:.875rem}.of-hidden{overflow:hidden}.of-x-auto{overflow-x:auto}.border-1{border-width:1px}.border-b-1{border-bottom-width:1px}.border-gray-1{--un-border-opacity:1;border-color:rgb(243 244 246 / var(--un-border-opacity))}.border-gray-3{--un-border-opacity:1;border-color:rgb(209 213 219 / var(--un-border-opacity))}.border-b-gray-1{--un-border-opacity:1;--un-border-bottom-opacity:var(--un-border-opacity);border-bottom-color:rgb(243 244 246 / var(--un-border-bottom-opacity))}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.border-solid{border-style:solid}.border-b-solid{border-bottom-style:solid}.bg-gray-1,.hover\\:bg-gray-1:hover{--un-bg-opacity:1;background-color:rgb(243 244 246 / var(--un-bg-opacity))}.hover\\:bg-gray:hover{--un-bg-opacity:1;background-color:rgb(156 163 175 / var(--un-bg-opacity))}[hover\\:bg-gray-1=""]:hover{--un-bg-opacity:1;background-color:rgb(243 244 246 / var(--un-bg-opacity))}.hover\\:bg-opacity-2:hover{--un-bg-opacity:.02}.p-sm{padding:.875rem}.p-unset{padding:unset}.px-\\[var\\(--el-dialog-padding-primary\\)\\]{padding-left:var(--el-dialog-padding-primary);padding-right:var(--el-dialog-padding-primary)}.px-sm,[px-sm=""]{padding-left:.875rem;padding-right:.875rem}.py-2px{padding-top:2px;padding-bottom:2px}.py-3px,[py-3px=""]{padding-top:3px;padding-bottom:3px}.pb-\\[var\\(--el-dialog-padding-primary\\)\\]{padding-bottom:var(--el-dialog-padding-primary)}.pb-9px{padding-bottom:9px}.pl-lg{padding-left:1.125rem}.pr-18px{padding-right:18px}.text-center,[text-center=""]{text-align:center}.text-left{text-align:left}.text-\\.7em,[text-\\.7em=""]{font-size:.7em}.text-1em{font-size:1em}.font-size-14px{font-size:14px}.text-gray-500{--un-text-opacity:1;color:rgb(107 114 128 / var(--un-text-opacity))}.c-gray,[c-gray=""]{--un-text-opacity:1;color:rgb(156 163 175 / var(--un-text-opacity))}.font-bold,[font-bold=""]{font-weight:700}.lh-initial{line-height:initial}.hover\\:shadow-md:hover{--un-shadow:var(--un-shadow-inset) 0 4px 6px -1px var(--un-shadow-color, rgb(0 0 0 / .1)),var(--un-shadow-inset) 0 2px 4px -2px var(--un-shadow-color, rgb(0 0 0 / .1));box-shadow:var(--un-ring-offset-shadow),var(--un-ring-shadow),var(--un-shadow)}.filter{filter:var(--un-blur) var(--un-brightness) var(--un-contrast) var(--un-drop-shadow) var(--un-grayscale) var(--un-hue-rotate) var(--un-invert) var(--un-saturate) var(--un-sepia)}:root{--bf-sidebar-margin: 25px;--bf-icon-size: 20px }.BF-JST{position:fixed;top:0;right:0;height:100%}.BF-JST:after{content:"";position:fixed;top:0;right:0;height:100vh;width:8px}.sideMenu___3ph3_ .serviceMenu___2GzqY{all:unset}.input-with-select .el-input-group__prepend{background-color:var(--el-fill-color-blank)}.bf-icon{width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-width:1px;--un-border-opacity:1;border-color:rgb(209 213 219 / var(--un-border-opacity));border-radius:.25rem;border-style:solid;padding:3px} `);

(function (vue, pinia) {
  'use strict';

  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var require_main_001 = __commonJS({
    "main-DOJTMHxo.js"(exports, module) {
      function isObject$4(v2) {
        return typeof v2 === "object" && v2 !== null;
      }
      function normalizeOptions(options, factoryOptions) {
        options = isObject$4(options) ? options : /* @__PURE__ */ Object.create(null);
        return new Proxy(options, {
          get(target, key, receiver) {
            if (key === "key")
              return Reflect.get(target, key, receiver);
            return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);
          }
        });
      }
      function get$1(state, path) {
        return path.reduce((obj, p) => {
          return obj == null ? void 0 : obj[p];
        }, state);
      }
      function set$1(state, path, val) {
        return path.slice(0, -1).reduce((obj, p) => {
          if (/^(__proto__)$/.test(p))
            return {};
          else
            return obj[p] = obj[p] || {};
        }, state)[path[path.length - 1]] = val, state;
      }
      function pick$1(baseState, paths) {
        return paths.reduce((substate, path) => {
          const pathArray = path.split(".");
          return set$1(substate, pathArray, get$1(baseState, pathArray));
        }, {});
      }
      function parsePersistence(factoryOptions, store) {
        return (o2) => {
          var _a2;
          try {
            const {
              storage = localStorage,
              beforeRestore = void 0,
              afterRestore = void 0,
              serializer = {
                serialize: JSON.stringify,
                deserialize: JSON.parse
              },
              key = store.$id,
              paths = null,
              debug = false
            } = o2;
            return {
              storage,
              beforeRestore,
              afterRestore,
              serializer,
              key: ((_a2 = factoryOptions.key) != null ? _a2 : (k2) => k2)(typeof key == "string" ? key : key(store.$id)),
              paths,
              debug
            };
          } catch (e2) {
            if (o2.debug)
              console.error("[pinia-plugin-persistedstate]", e2);
            return null;
          }
        };
      }
      function hydrateStore(store, { storage, serializer, key, debug }) {
        try {
          const fromStorage = storage == null ? void 0 : storage.getItem(key);
          if (fromStorage)
            store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));
        } catch (e2) {
          if (debug)
            console.error("[pinia-plugin-persistedstate]", e2);
        }
      }
      function persistState(state, { storage, serializer, key, paths, debug }) {
        try {
          const toStore = Array.isArray(paths) ? pick$1(state, paths) : state;
          storage.setItem(key, serializer.serialize(toStore));
        } catch (e2) {
          if (debug)
            console.error("[pinia-plugin-persistedstate]", e2);
        }
      }
      function createPersistedState(factoryOptions = {}) {
        return (context) => {
          const { auto = false } = factoryOptions;
          const {
            options: { persist = auto },
            store,
            pinia: pinia2
          } = context;
          if (!persist)
            return;
          if (!(store.$id in pinia2.state.value)) {
            const original_store = pinia2._s.get(store.$id.replace("__hot:", ""));
            if (original_store)
              Promise.resolve().then(() => original_store.$persist());
            return;
          }
          const persistences = (Array.isArray(persist) ? persist.map((p) => normalizeOptions(p, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(parsePersistence(factoryOptions, store)).filter(Boolean);
          store.$persist = () => {
            persistences.forEach((persistence) => {
              persistState(store.$state, persistence);
            });
          };
          store.$hydrate = ({ runHooks = true } = {}) => {
            persistences.forEach((persistence) => {
              const { beforeRestore, afterRestore } = persistence;
              if (runHooks)
                beforeRestore == null ? void 0 : beforeRestore(context);
              hydrateStore(store, persistence);
              if (runHooks)
                afterRestore == null ? void 0 : afterRestore(context);
            });
          };
          persistences.forEach((persistence) => {
            const { beforeRestore, afterRestore } = persistence;
            beforeRestore == null ? void 0 : beforeRestore(context);
            hydrateStore(store, persistence);
            afterRestore == null ? void 0 : afterRestore(context);
            store.$subscribe(
              (_mutation, state) => {
                persistState(state, persistence);
              },
              {
                detached: true
              }
            );
          });
        };
      }
      var src_default = createPersistedState();
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      var _a;
      const isClient$1 = typeof window !== "undefined";
      const isString$3 = (val) => typeof val === "string";
      const noop$5 = () => {
      };
      const isIOS = isClient$1 && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
      function resolveUnref(r2) {
        return typeof r2 === "function" ? r2() : vue.unref(r2);
      }
      function createFilterWrapper$1(filter, fn2) {
        function wrapper(...args) {
          return new Promise((resolve, reject) => {
            Promise.resolve(filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve).catch(reject);
          });
        }
        return wrapper;
      }
      function debounceFilter$1(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop$5;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop$5;
        };
        const filter = (invoke) => {
          const duration = resolveUnref(ms);
          const maxDuration = resolveUnref(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke());
          }
          return new Promise((resolve, reject) => {
            lastRejector = options.rejectOnCancel ? reject : resolve;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve(invoke());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve(invoke());
            }, duration);
          });
        };
        return filter;
      }
      function identity$1(arg) {
        return arg;
      }
      function tryOnScopeDispose$1(fn2) {
        if (vue.getCurrentScope()) {
          vue.onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function useDebounceFn$1(fn2, ms = 200, options = {}) {
        return createFilterWrapper$1(debounceFilter$1(ms, options), fn2);
      }
      function refDebounced(value, ms = 200, options = {}) {
        const debounced = vue.ref(value.value);
        const updater = useDebounceFn$1(() => {
          debounced.value = value.value;
        }, ms, options);
        vue.watch(value, () => updater());
        return debounced;
      }
      function tryOnMounted$1(fn2, sync = true) {
        if (vue.getCurrentInstance())
          vue.onMounted(fn2);
        else if (sync)
          fn2();
        else
          vue.nextTick(fn2);
      }
      function useTimeoutFn$1(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = vue.ref(false);
        let timer = null;
        function clear() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear();
        }
        function start(...args) {
          clear();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, resolveUnref(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient$1)
            start();
        }
        tryOnScopeDispose$1(stop);
        return {
          isPending: vue.readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement$1(elRef) {
        var _a2;
        const plain = resolveUnref(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow$1 = isClient$1 ? window : void 0;
      function useEventListener$1(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (isString$3(args[0]) || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow$1;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop$5;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup2 = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = vue.watch(() => [unrefElement$1(target), resolveUnref(options)], ([el, options2]) => {
          cleanup2();
          if (!el)
            return;
          cleanups.push(...events.flatMap((event) => {
            return listeners.map((listener) => register(el, event, listener, options2));
          }));
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup2();
        };
        tryOnScopeDispose$1(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow$1, ignore = [], capture = true, detectIframe = false } = options;
        if (!window2)
          return;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$5));
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement$1(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement$1(target);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup2 = [
          useEventListener$1(window2, "click", listener, { passive: true, capture }),
          useEventListener$1(window2, "pointerdown", (e2) => {
            const el = unrefElement$1(target);
            if (el)
              shouldListen = !e2.composedPath().includes(el) && !shouldIgnore(e2);
          }, { passive: true }),
          detectIframe && useEventListener$1(window2, "blur", (event) => {
            var _a2;
            const el = unrefElement$1(target);
            if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event);
          })
        ].filter(Boolean);
        const stop = () => cleanup2.forEach((fn2) => fn2());
        return stop;
      }
      function useSupported$1(callback, sync = false) {
        const isSupported = vue.ref();
        const update = () => isSupported.value = Boolean(callback());
        update();
        tryOnMounted$1(update, sync);
        return isSupported;
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      _global[globalKey] = _global[globalKey] || {};
      var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
      var __hasOwnProp$g = Object.prototype.hasOwnProperty;
      var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
      var __objRest$2 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$g)
          for (var prop of __getOwnPropSymbols$g(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useResizeObserver$1(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow$1 } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
        let observer;
        const isSupported = useSupported$1(() => window2 && "ResizeObserver" in window2);
        const cleanup2 = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = vue.watch(() => unrefElement$1(target), (el) => {
          cleanup2();
          if (isSupported.value && window2 && el) {
            observer = new ResizeObserver(callback);
            observer.observe(el, observerOptions);
          }
        }, { immediate: true, flush: "post" });
        const stop = () => {
          cleanup2();
          stopWatch();
        };
        tryOnScopeDispose$1(stop);
        return {
          isSupported,
          stop
        };
      }
      var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
      var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
      var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
      var __objRest$1 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$8)
          for (var prop of __getOwnPropSymbols$8(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useMutationObserver$1(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow$1 } = _a2, mutationOptions = __objRest$1(_a2, ["window"]);
        let observer;
        const isSupported = useSupported$1(() => window2 && "MutationObserver" in window2);
        const cleanup2 = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = vue.watch(() => unrefElement$1(target), (el) => {
          cleanup2();
          if (isSupported.value && window2 && el) {
            observer = new MutationObserver(callback);
            observer.observe(el, mutationOptions);
          }
        }, { immediate: true });
        const stop = () => {
          cleanup2();
          stopWatch();
        };
        tryOnScopeDispose$1(stop);
        return {
          isSupported,
          stop
        };
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var __defProp = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp.call(b2, prop))
            __defNormalProp(a2, prop, b2[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b2)) {
            if (__propIsEnum.call(b2, prop))
              __defNormalProp(a2, prop, b2[prop]);
          }
        return a2;
      };
      const _TransitionPresets = {
        easeInSine: [0.12, 0, 0.39, 0],
        easeOutSine: [0.61, 1, 0.88, 1],
        easeInOutSine: [0.37, 0, 0.63, 1],
        easeInQuad: [0.11, 0, 0.5, 0],
        easeOutQuad: [0.5, 1, 0.89, 1],
        easeInOutQuad: [0.45, 0, 0.55, 1],
        easeInCubic: [0.32, 0, 0.67, 0],
        easeOutCubic: [0.33, 1, 0.68, 1],
        easeInOutCubic: [0.65, 0, 0.35, 1],
        easeInQuart: [0.5, 0, 0.75, 0],
        easeOutQuart: [0.25, 1, 0.5, 1],
        easeInOutQuart: [0.76, 0, 0.24, 1],
        easeInQuint: [0.64, 0, 0.78, 0],
        easeOutQuint: [0.22, 1, 0.36, 1],
        easeInOutQuint: [0.83, 0, 0.17, 1],
        easeInExpo: [0.7, 0, 0.84, 0],
        easeOutExpo: [0.16, 1, 0.3, 1],
        easeInOutExpo: [0.87, 0, 0.13, 1],
        easeInCirc: [0.55, 0, 1, 0.45],
        easeOutCirc: [0, 0.55, 0.45, 1],
        easeInOutCirc: [0.85, 0, 0.15, 1],
        easeInBack: [0.36, 0, 0.66, -0.56],
        easeOutBack: [0.34, 1.56, 0.64, 1],
        easeInOutBack: [0.68, -0.6, 0.32, 1.6]
      };
      __spreadValues({
        linear: identity$1
      }, _TransitionPresets);
      const isFirefox = () => isClient$1 && /firefox/i.test(window.navigator.userAgent);
      /**
      * @vue/shared v3.4.14
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      const NOOP = () => {
      };
      const hasOwnProperty$d = Object.prototype.hasOwnProperty;
      const hasOwn$3 = (val, key) => hasOwnProperty$d.call(val, key);
      const isArray$6 = Array.isArray;
      const isFunction$2 = (val) => typeof val === "function";
      const isString$2 = (val) => typeof val === "string";
      const isSymbol$2 = (val) => typeof val === "symbol";
      const isObject$3 = (val) => val !== null && typeof val === "object";
      const objectToString$2 = Object.prototype.toString;
      const toTypeString = (value) => objectToString$2.call(value);
      const toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      const cacheStringFunction$1 = (fn2) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn2(str));
        };
      };
      const camelizeRE$1 = /-(\w)/g;
      const camelize$1 = cacheStringFunction$1((str) => {
        return str.replace(camelizeRE$1, (_2, c2) => c2 ? c2.toUpperCase() : "");
      });
      const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var Symbol$1 = root.Symbol;
      var objectProto$e = Object.prototype;
      var hasOwnProperty$c = objectProto$e.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$e.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e2) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$d = Object.prototype;
      var nativeObjectToString = objectProto$d.toString;
      function objectToString$1(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$3 = "[object Symbol]";
      function isSymbol$1(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
      }
      function arrayMap(array, iteratee) {
        var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
        while (++index2 < length2) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      var isArray$5 = Array.isArray;
      var INFINITY$2 = 1 / 0;
      var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray$5(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol$1(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string2) {
        var index2 = string2.length;
        while (index2-- && reWhitespace.test(string2.charAt(index2))) {
        }
        return index2;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function isObject$2(value) {
        var type3 = typeof value;
        return value != null && (type3 == "object" || type3 == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol$1(value)) {
          return NAN;
        }
        if (isObject$2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject$2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY$1 || value === -INFINITY$1) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction$1(value) {
        if (!isObject$2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$1 = Function.prototype;
      var funcToString$1 = funcProto$1.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$1.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype, objectProto$c = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$b = objectProto$c.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject$2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function getValue$2(object, key) {
        return object == null ? void 0 : object[key];
      }
      function getNative(object, key) {
        var value = getValue$2(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap$1 = getNative(root, "WeakMap");
      var objectCreate = Object.create;
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject$2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function copyArray(source, array) {
        var index2 = -1, length2 = source.length;
        array || (array = Array(length2));
        while (++index2 < length2) {
          array[index2] = source[index2];
        }
        return array;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var baseSetToString = !defineProperty ? identity : function(func, string2) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      const baseSetToString$1 = baseSetToString;
      var setToString = shortOut(baseSetToString$1);
      function arrayEach(array, iteratee) {
        var index2 = -1, length2 = array == null ? 0 : array.length;
        while (++index2 < length2) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length2) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length2) {
        var type3 = typeof value;
        length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
        return !!length2 && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$b = Object.prototype;
      var hasOwnProperty$a = objectProto$b.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty$a.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length2 = props.length;
        while (++index2 < length2) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      var nativeMax$2 = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax$2(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length2 = nativeMax$2(args.length - start, 0), array = Array(length2);
          while (++index2 < length2) {
            array[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction$1(value);
      }
      var objectProto$a = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
        return value === proto;
      }
      function baseTimes(n2, iteratee) {
        var index2 = -1, result = Array(n2);
        while (++index2 < n2) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      var argsTag$3 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$3;
      }
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer$1 = nativeIsBuffer || stubFalse;
      var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
      var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
      typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray$5(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length2)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty$7.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject$2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray$5(value)) {
          return false;
        }
        var type3 = typeof value;
        if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value == null || isSymbol$1(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      var nativeCreate = getNative(Object, "create");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$5.call(data, key) ? data[key] : void 0;
      }
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty$4.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array, key) {
        var length2 = array.length;
        while (length2--) {
          if (eq(array[length2][0], key)) {
            return length2;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? void 0 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root, "Map");
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$1 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type3 = typeof value;
        return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar$1 = /\\(\\)?/g;
      var stringToPath$1 = memoizeCapped(function(string2) {
        var result = [];
        if (string2.charCodeAt(0) === 46) {
          result.push("");
        }
        string2.replace(rePropName$1, function(match, number, quote2, subString) {
          result.push(quote2 ? subString.replace(reEscapeChar$1, "$1") : number || match);
        });
        return result;
      });
      function toString$1(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object) {
        if (isArray$5(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath$1(toString$1(value));
      }
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol$1(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length2 = path.length;
        while (object != null && index2 < length2) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length2 ? object : void 0;
      }
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array, values) {
        var index2 = -1, length2 = values.length, offset = array.length;
        while (++index2 < length2) {
          array[offset + index2] = values[index2];
        }
        return array;
      }
      var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray$5(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index2 = -1, length2 = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index2 < length2) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      function flatten(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseFlatten(array, 1) : [];
      }
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten), func + "");
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      const getPrototype$1 = getPrototype;
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray$5(value) ? value : [value];
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
        buffer.copy(result);
        return result;
      }
      function arrayFilter(array, predicate) {
        var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length2) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$3 = Object.prototype;
      var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
      var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype$1(object);
        }
        return result;
      };
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray$5(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var DataView$1 = getNative(root, "DataView");
      var Promise$1 = getNative(root, "Promise");
      var Set$1 = getNative(root, "Set");
      var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
      var dataViewTag$3 = "[object DataView]";
      var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
      var getTag = baseGetTag;
      if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$3;
              case mapCtorString:
                return mapTag$4;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$4;
              case weakMapCtorString:
                return weakMapTag$1;
            }
          }
          return result;
        };
      }
      const getTag$1 = getTag;
      var objectProto$2 = Object.prototype;
      var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
      function initCloneArray(array) {
        var length2 = array.length, result = new array.constructor(length2);
        if (length2 && typeof array[0] == "string" && hasOwnProperty$3.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      var Uint8Array$1 = root.Uint8Array;
      const Uint8Array$2 = Uint8Array$1;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
      var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag$2:
            return cloneArrayBuffer(object);
          case boolTag$2:
          case dateTag$2:
            return new Ctor(+object);
          case dataViewTag$2:
            return cloneDataView(object, isDeep);
          case float32Tag$1:
          case float64Tag$1:
          case int8Tag$1:
          case int16Tag$1:
          case int32Tag$1:
          case uint8Tag$1:
          case uint8ClampedTag$1:
          case uint16Tag$1:
          case uint32Tag$1:
            return cloneTypedArray(object, isDeep);
          case mapTag$3:
            return new Ctor();
          case numberTag$2:
          case stringTag$2:
            return new Ctor(object);
          case regexpTag$2:
            return cloneRegExp(object);
          case setTag$3:
            return new Ctor();
          case symbolTag$2:
            return cloneSymbol(object);
        }
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
      }
      var mapTag$2 = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag$1(value) == mapTag$2;
      }
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap$1 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      var setTag$2 = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag$1(value) == setTag$2;
      }
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject$2(value)) {
          return value;
        }
        var isArr = isArray$5(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer$1(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet$1(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap$1(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      var CLONE_SYMBOLS_FLAG = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values) {
        var index2 = -1, length2 = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index2 < length2) {
          this.add(values[index2]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array, predicate) {
        var index2 = -1, length2 = array == null ? 0 : array.length;
        while (++index2 < length2) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function setToArray(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty$1 = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray$5(object), othIsArr = isArray$5(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer$1(object)) {
          if (!isBuffer$1(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
          var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length2;
        }
        object = Object(object);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index2 < length2) {
          data = matchData[index2];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function isStrictComparable(value) {
        return value === value && !isObject$2(value);
      }
      function getMatchData(object) {
        var result = keys(object), length2 = result.length;
        while (length2--) {
          var key = result[length2], value = object[key];
          result[length2] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length2 = path.length, result = false;
        while (++index2 < length2) {
          var key = toKey(path[index2]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index2 != length2) {
          return result;
        }
        length2 = object == null ? 0 : object.length;
        return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray$5(object) || isArguments(object));
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray$5(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      var now = function() {
        return root.Date.now();
      };
      var FUNC_ERROR_TEXT = "Expected a function";
      var nativeMax$1 = Math.max, nativeMin$1 = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject$2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var nativeMax = Math.max, nativeMin = Math.min;
      function findLastIndex(array, predicate, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index2 = length2 - 1;
        if (fromIndex !== void 0) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1);
        }
        return baseFindIndex(array, baseIteratee(predicate), index2, true);
      }
      function fromPairs(pairs) {
        var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result = {};
        while (++index2 < length2) {
          var pair = pairs[index2];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isNil(value) {
        return value == null;
      }
      function isUndefined$1(value) {
        return value === void 0;
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject$2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
        while (nested != null && ++index2 < length2) {
          var key = toKey(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject$2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length2 = paths.length, result = {};
        while (++index2 < length2) {
          var path = paths[index2], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }
        return result;
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      const isUndefined = (val) => val === void 0;
      const isBoolean$1 = (val) => typeof val === "boolean";
      const isNumber$1 = (val) => typeof val === "number";
      const isElement$1 = (e2) => {
        if (typeof Element === "undefined")
          return false;
        return e2 instanceof Element;
      };
      const isStringNumber = (val) => {
        if (!isString$2(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      const escapeStringRegexp = (string2 = "") => string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      const keysOf = (arr) => Object.keys(arr);
      const getProp = (obj, path, defaultValue) => {
        return {
          get value() {
            return get(obj, path, defaultValue);
          },
          set value(val) {
            set(obj, path, val);
          }
        };
      };
      class ElementPlusError extends Error {
        constructor(m2) {
          super(m2);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m2) {
        throw new ElementPlusError(`[${scope}] ${m2}`);
      }
      function debugWarn(scope, message) {
      }
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      };
      const addClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      };
      const removeClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      };
      const getStyle$1 = (element, styleName) => {
        var _a2;
        if (!isClient$1 || !element || !styleName)
          return "";
        let key = camelize$1(styleName);
        if (key === "float")
          key = "cssFloat";
        try {
          const style = element.style[key];
          if (style)
            return style;
          const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
          return computed2 ? computed2[key] : "";
        } catch (e2) {
          return element.style[key];
        }
      };
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber$1(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString$2(value)) {
          return value;
        }
      }
      let scrollBarWidth;
      const getScrollBarWidth = (namespace) => {
        var _a2;
        if (!isClient$1)
          return 0;
        if (scrollBarWidth !== void 0)
          return scrollBarWidth;
        const outer = document.createElement("div");
        outer.className = `${namespace}-scrollbar__wrap`;
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.position = "absolute";
        outer.style.top = "-9999px";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
        scrollBarWidth = widthNoScroll - widthWithScroll;
        return scrollBarWidth;
      };
      function scrollIntoView(container, selected) {
        if (!isClient$1)
          return;
        if (!selected) {
          container.scrollTop = 0;
          return;
        }
        const offsetParents = [];
        let pointer = selected.offsetParent;
        while (pointer !== null && container !== pointer && container.contains(pointer)) {
          offsetParents.push(pointer);
          pointer = pointer.offsetParent;
        }
        const top = selected.offsetTop + offsetParents.reduce((prev2, curr) => prev2 + curr.offsetTop, 0);
        const bottom = top + selected.offsetHeight;
        const viewRectTop = container.scrollTop;
        const viewRectBottom = viewRectTop + container.clientHeight;
        if (top < viewRectTop) {
          container.scrollTop = top;
        } else if (bottom > viewRectBottom) {
          container.scrollTop = bottom - container.clientHeight;
        }
      }
      /*! Element Plus Icons Vue v2.3.1 */
      var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "ArrowDown",
        __name: "arrow-down",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
            })
          ]));
        }
      });
      var arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default;
      var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "CircleCheck",
        __name: "circle-check",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
            })
          ]));
        }
      });
      var circle_check_default = circle_check_vue_vue_type_script_setup_true_lang_default;
      var circle_close_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "CircleCloseFilled",
        __name: "circle-close-filled",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
            })
          ]));
        }
      });
      var circle_close_filled_default = circle_close_filled_vue_vue_type_script_setup_true_lang_default;
      var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "CircleClose",
        __name: "circle-close",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
            }),
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      });
      var circle_close_default = circle_close_vue_vue_type_script_setup_true_lang_default;
      var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "Close",
        __name: "close",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
            })
          ]));
        }
      });
      var close_default = close_vue_vue_type_script_setup_true_lang_default;
      var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "Hide",
        __name: "hide",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
            }),
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
            })
          ]));
        }
      });
      var hide_default = hide_vue_vue_type_script_setup_true_lang_default;
      var info_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "InfoFilled",
        __name: "info-filled",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
            })
          ]));
        }
      });
      var info_filled_default = info_filled_vue_vue_type_script_setup_true_lang_default;
      var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "Loading",
        __name: "loading",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
            })
          ]));
        }
      });
      var loading_default = loading_vue_vue_type_script_setup_true_lang_default;
      var success_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "SuccessFilled",
        __name: "success-filled",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
            })
          ]));
        }
      });
      var success_filled_default = success_filled_vue_vue_type_script_setup_true_lang_default;
      var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "View",
        __name: "view",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
            })
          ]));
        }
      });
      var view_default = view_vue_vue_type_script_setup_true_lang_default;
      var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ vue.defineComponent({
        name: "WarningFilled",
        __name: "warning-filled",
        setup(__props) {
          return (_ctx, _cache) => (vue.openBlock(), vue.createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            vue.createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
            })
          ]));
        }
      });
      var warning_filled_default = warning_filled_vue_vue_type_script_setup_true_lang_default;
      const epPropKey = "__epPropKey";
      const definePropType = (val) => val;
      const isEpProp = (val) => isObject$3(val) && !!val[epPropKey];
      const buildProp = (prop, key) => {
        if (!isObject$3(prop) || isEpProp(prop))
          return prop;
        const { values, required, default: defaultValue, type: type3, validator } = prop;
        const _validator = values || validator ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values) {
            allowedValues = Array.from(values);
            if (hasOwn$3(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator)
            valid || (valid = validator(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            vue.warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type: type3,
          required: !!required,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn$3(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      };
      const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
        key,
        buildProp(option, key)
      ]));
      const iconPropType = definePropType([
        String,
        Object,
        Function
      ]);
      const CloseComponents = {
        Close: close_default
      };
      const TypeComponentsMap = {
        success: success_filled_default,
        warning: warning_filled_default,
        error: circle_close_filled_default,
        info: info_filled_default
      };
      const ValidateComponentsMap = {
        validating: loading_default,
        success: circle_check_default,
        error: circle_close_default
      };
      const withInstall$1 = (main, extra) => {
        main.install = (app) => {
          for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
            app.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main[key] = comp;
          }
        }
        return main;
      };
      const withInstallFunction = (fn2, name) => {
        fn2.install = (app) => {
          fn2._context = app._context;
          app.config.globalProperties[name] = fn2;
        };
        return fn2;
      };
      const withInstallDirective = (directive, name) => {
        directive.install = (app) => {
          app.directive(name, directive);
        };
        return directive;
      };
      const withNoopInstall = (component) => {
        component.install = NOOP;
        return component;
      };
      const composeRefs = (...refs) => {
        return (el) => {
          refs.forEach((ref2) => {
            if (isFunction$2(ref2)) {
              ref2(el);
            } else {
              ref2.value = el;
            }
          });
        };
      };
      const EVENT_CODE = {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        left: "ArrowLeft",
        up: "ArrowUp",
        right: "ArrowRight",
        down: "ArrowDown",
        esc: "Escape",
        delete: "Delete",
        backspace: "Backspace",
        numpadEnter: "NumpadEnter",
        pageUp: "PageUp",
        pageDown: "PageDown",
        home: "Home",
        end: "End"
      };
      const UPDATE_MODEL_EVENT = "update:modelValue";
      const CHANGE_EVENT = "change";
      const componentSizes = ["", "default", "small", "large"];
      var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
        PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
        PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
        PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
        PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
        PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
        PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
        PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
        PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
        PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
        PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
        PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
        return PatchFlags2;
      })(PatchFlags || {});
      const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
      const mutable = (val) => val;
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = vue.computed(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = vue.getCurrentInstance();
        if (!instance) {
          return vue.computed(() => ({}));
        }
        return vue.computed(() => {
          var _a2;
          return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      };
      const useDeprecated = ({ from: from2, replacement, scope, version: version2, ref: ref2, type: type3 = "API" }, condition) => {
        vue.watch(() => vue.unref(condition), (val) => {
        }, {
          immediate: true
        });
      };
      const useDraggable = (targetRef, dragRef, draggable) => {
        let transform = {
          offsetX: 0,
          offsetY: 0
        };
        const onMousedown = (e2) => {
          const downX = e2.clientX;
          const downY = e2.clientY;
          const { offsetX, offsetY } = transform;
          const targetRect = targetRef.value.getBoundingClientRect();
          const targetLeft = targetRect.left;
          const targetTop = targetRect.top;
          const targetWidth = targetRect.width;
          const targetHeight = targetRect.height;
          const clientWidth = document.documentElement.clientWidth;
          const clientHeight = document.documentElement.clientHeight;
          const minLeft = -targetLeft + offsetX;
          const minTop = -targetTop + offsetY;
          const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
          const maxTop = clientHeight - targetTop - targetHeight + offsetY;
          const onMousemove = (e22) => {
            const moveX = Math.min(Math.max(offsetX + e22.clientX - downX, minLeft), maxLeft);
            const moveY = Math.min(Math.max(offsetY + e22.clientY - downY, minTop), maxTop);
            transform = {
              offsetX: moveX,
              offsetY: moveY
            };
            if (targetRef.value) {
              targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
            }
          };
          const onMouseup = () => {
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
          };
          document.addEventListener("mousemove", onMousemove);
          document.addEventListener("mouseup", onMouseup);
        };
        const onDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.addEventListener("mousedown", onMousedown);
          }
        };
        const offDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.removeEventListener("mousedown", onMousedown);
          }
        };
        vue.onMounted(() => {
          vue.watchEffect(() => {
            if (draggable.value) {
              onDraggable();
            } else {
              offDraggable();
            }
          });
        });
        vue.onBeforeUnmount(() => {
          offDraggable();
        });
      };
      var English = {
        name: "en",
        el: {
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color."
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tour: {
            next: "Next",
            previous: "Previous",
            finish: "Finish"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          }
        }
      };
      const buildTranslator = (locale2) => (path, option) => translate(path, option, vue.unref(locale2));
      const translate = (path, option, locale2) => get(locale2, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
        var _a2;
        return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
      });
      const buildLocaleContext = (locale2) => {
        const lang = vue.computed(() => vue.unref(locale2).name);
        const localeRef = vue.isRef(locale2) ? locale2 : vue.ref(locale2);
        return {
          lang,
          locale: localeRef,
          t: buildTranslator(locale2)
        };
      };
      const localeContextKey = Symbol("localeContextKey");
      const useLocale = (localeOverrides) => {
        const locale2 = localeOverrides || vue.inject(localeContextKey, vue.ref());
        return buildLocaleContext(vue.computed(() => locale2.value || English));
      };
      /**
      * @vue/reactivity v3.4.14
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      let activeEffectScope;
      function recordEffectScope(effect2, scope = activeEffectScope) {
        if (scope && scope.active) {
          scope.effects.push(effect2);
        }
      }
      let activeEffect;
      class ReactiveEffect {
        constructor(fn2, trigger2, scheduler, scope) {
          this.fn = fn2;
          this.trigger = trigger2;
          this.scheduler = scheduler;
          this.active = true;
          this.deps = [];
          this._dirtyLevel = 2;
          this._trackId = 0;
          this._runnings = 0;
          this._shouldSchedule = false;
          this._depsLength = 0;
          recordEffectScope(this, scope);
        }
        get dirty() {
          if (this._dirtyLevel === 1) {
            pauseTracking();
            for (let i2 = 0; i2 < this._depsLength; i2++) {
              const dep = this.deps[i2];
              if (dep.computed) {
                triggerComputed(dep.computed);
                if (this._dirtyLevel >= 2) {
                  break;
                }
              }
            }
            if (this._dirtyLevel < 2) {
              this._dirtyLevel = 0;
            }
            resetTracking();
          }
          return this._dirtyLevel >= 2;
        }
        set dirty(v2) {
          this._dirtyLevel = v2 ? 2 : 0;
        }
        run() {
          this._dirtyLevel = 0;
          if (!this.active) {
            return this.fn();
          }
          let lastShouldTrack = shouldTrack;
          let lastEffect = activeEffect;
          try {
            shouldTrack = true;
            activeEffect = this;
            this._runnings++;
            preCleanupEffect(this);
            return this.fn();
          } finally {
            postCleanupEffect(this);
            this._runnings--;
            activeEffect = lastEffect;
            shouldTrack = lastShouldTrack;
          }
        }
        stop() {
          var _a2;
          if (this.active) {
            preCleanupEffect(this);
            postCleanupEffect(this);
            (_a2 = this.onStop) == null ? void 0 : _a2.call(this);
            this.active = false;
          }
        }
      }
      function triggerComputed(computed2) {
        return computed2.value;
      }
      function preCleanupEffect(effect2) {
        effect2._trackId++;
        effect2._depsLength = 0;
      }
      function postCleanupEffect(effect2) {
        if (effect2.deps && effect2.deps.length > effect2._depsLength) {
          for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) {
            cleanupDepEffect(effect2.deps[i2], effect2);
          }
          effect2.deps.length = effect2._depsLength;
        }
      }
      function cleanupDepEffect(dep, effect2) {
        const trackId = dep.get(effect2);
        if (trackId !== void 0 && effect2._trackId !== trackId) {
          dep.delete(effect2);
          if (dep.size === 0) {
            dep.cleanup();
          }
        }
      }
      let shouldTrack = true;
      let pauseScheduleStack = 0;
      const trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function resetTracking() {
        const last = trackStack.pop();
        shouldTrack = last === void 0 ? true : last;
      }
      function pauseScheduling() {
        pauseScheduleStack++;
      }
      function resetScheduling() {
        pauseScheduleStack--;
        while (!pauseScheduleStack && queueEffectSchedulers.length) {
          queueEffectSchedulers.shift()();
        }
      }
      function trackEffect(effect2, dep, debuggerEventExtraInfo) {
        if (dep.get(effect2) !== effect2._trackId) {
          dep.set(effect2, effect2._trackId);
          const oldDep = effect2.deps[effect2._depsLength];
          if (oldDep !== dep) {
            if (oldDep) {
              cleanupDepEffect(oldDep, effect2);
            }
            effect2.deps[effect2._depsLength++] = dep;
          } else {
            effect2._depsLength++;
          }
        }
      }
      const queueEffectSchedulers = [];
      function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
        pauseScheduling();
        for (const effect2 of dep.keys()) {
          if (dep.get(effect2) !== effect2._trackId) {
            continue;
          }
          if (effect2._dirtyLevel < dirtyLevel && !(effect2._runnings && !effect2.allowRecurse)) {
            const lastDirtyLevel = effect2._dirtyLevel;
            effect2._dirtyLevel = dirtyLevel;
            if (lastDirtyLevel === 0) {
              effect2._shouldSchedule = true;
              effect2.trigger();
            }
          }
          if (effect2.scheduler && effect2._shouldSchedule && (!effect2._runnings || effect2.allowRecurse)) {
            effect2._shouldSchedule = false;
            queueEffectSchedulers.push(effect2.scheduler);
          }
        }
        resetScheduling();
      }
      const createDep = (cleanup2, computed2) => {
        const dep = /* @__PURE__ */ new Map();
        dep.cleanup = cleanup2;
        dep.computed = computed2;
        return dep;
      };
      new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$2)
      );
      function toRaw(observed) {
        const raw = observed && observed["__v_raw"];
        return raw ? toRaw(raw) : observed;
      }
      class ComputedRefImpl {
        constructor(getter, _setter, isReadonly2, isSSR) {
          this._setter = _setter;
          this.dep = void 0;
          this.__v_isRef = true;
          this["__v_isReadonly"] = false;
          this.effect = new ReactiveEffect(
            () => getter(this._value),
            () => triggerRefValue(this, 1)
          );
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this["__v_isReadonly"] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          if (!self2._cacheable || self2.effect.dirty) {
            if (hasChanged(self2._value, self2._value = self2.effect.run())) {
              triggerRefValue(self2, 2);
            }
          }
          trackRefValue(self2);
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
        // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
        get _dirty() {
          return this.effect.dirty;
        }
        set _dirty(v2) {
          this.effect.dirty = v2;
        }
        // #endregion
      }
      function computed(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        const onlyGetter = isFunction$2(getterOrOptions);
        if (onlyGetter) {
          getter = getterOrOptions;
          setter = NOOP;
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
        return cRef;
      }
      function trackRefValue(ref2) {
        if (shouldTrack && activeEffect) {
          ref2 = toRaw(ref2);
          trackEffect(
            activeEffect,
            ref2.dep || (ref2.dep = createDep(
              () => ref2.dep = void 0,
              ref2 instanceof ComputedRefImpl ? ref2 : void 0
            ))
          );
        }
      }
      function triggerRefValue(ref2, dirtyLevel = 2, newVal) {
        ref2 = toRaw(ref2);
        const dep = ref2.dep;
        if (dep) {
          triggerEffects(
            dep,
            dirtyLevel
          );
        }
      }
      const defaultNamespace = "el";
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = Symbol("namespaceContextKey");
      const useGetDerivedNamespace = (namespaceOverrides) => {
        const derivedNamespace = namespaceOverrides || (vue.getCurrentInstance() ? vue.inject(namespaceContextKey, vue.ref(defaultNamespace)) : vue.ref(defaultNamespace));
        const namespace = vue.computed(() => {
          return vue.unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      };
      const useNamespace = (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace(namespaceOverrides);
        const b2 = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e2 = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m2 = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b: b2,
          e: e2,
          m: m2,
          be: be2,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      };
      const useLockscreen = (trigger, options = {}) => {
        if (!vue.isRef(trigger)) {
          throwError("[useLockscreen]", "You need to pass a ref param to this function");
        }
        const ns = options.ns || useNamespace("popup");
        const hiddenCls = computed(() => ns.bm("parent", "hidden"));
        if (!isClient$1 || hasClass(document.body, hiddenCls.value)) {
          return;
        }
        let scrollBarWidth2 = 0;
        let withoutHiddenClass = false;
        let bodyWidth = "0";
        const cleanup2 = () => {
          setTimeout(() => {
            removeClass(document == null ? void 0 : document.body, hiddenCls.value);
            if (withoutHiddenClass && document) {
              document.body.style.width = bodyWidth;
            }
          }, 200);
        };
        vue.watch(trigger, (val) => {
          if (!val) {
            cleanup2();
            return;
          }
          withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            bodyWidth = document.body.style.width;
          }
          scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle$1(document.body, "overflowY");
          if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
            document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
          }
          addClass(document.body, hiddenCls.value);
        });
        vue.onScopeDispose(() => cleanup2());
      };
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw2 = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw2]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = vue.getCurrentInstance();
          const { emit } = instance;
          const props = instance.props;
          const hasUpdateHandler = vue.computed(() => isFunction$2(props[updateEventKeyRaw2]));
          const isModelBindingAbsent = vue.computed(() => props[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$2(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$2(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props.disabled === true || isFunction$2(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient$1;
            if (shouldEmit) {
              emit(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props.disabled === true || !isClient$1)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient$1;
            if (shouldEmit) {
              emit(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean$1(val))
              return;
            if (props.disabled && val) {
              if (hasUpdateHandler.value) {
                emit(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          vue.watch(() => props[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            vue.watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          vue.onMounted(() => {
            onChange(props[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      };
      const useProp = (name) => {
        const vm = vue.getCurrentInstance();
        return vue.computed(() => {
          var _a2, _b;
          return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
        });
      };
      var E$1 = "top", R$1 = "bottom", W = "right", P$1 = "left", me = "auto", G = [E$1, R$1, W, P$1], U = "start", J$1 = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t2, e2) {
        return t2.concat([e2 + "-" + U, e2 + "-" + J$1]);
      }, []), Ee = [].concat(G, [me]).reduce(function(t2, e2) {
        return t2.concat([e2, e2 + "-" + U, e2 + "-" + J$1]);
      }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
      function C(t2) {
        return t2 ? (t2.nodeName || "").toLowerCase() : null;
      }
      function H(t2) {
        if (t2 == null)
          return window;
        if (t2.toString() !== "[object Window]") {
          var e2 = t2.ownerDocument;
          return e2 && e2.defaultView || window;
        }
        return t2;
      }
      function Q(t2) {
        var e2 = H(t2).Element;
        return t2 instanceof e2 || t2 instanceof Element;
      }
      function B$1(t2) {
        var e2 = H(t2).HTMLElement;
        return t2 instanceof e2 || t2 instanceof HTMLElement;
      }
      function Pe(t2) {
        if (typeof ShadowRoot == "undefined")
          return false;
        var e2 = H(t2).ShadowRoot;
        return t2 instanceof e2 || t2 instanceof ShadowRoot;
      }
      function Mt(t2) {
        var e2 = t2.state;
        Object.keys(e2.elements).forEach(function(n2) {
          var r2 = e2.styles[n2] || {}, o2 = e2.attributes[n2] || {}, i2 = e2.elements[n2];
          !B$1(i2) || !C(i2) || (Object.assign(i2.style, r2), Object.keys(o2).forEach(function(a2) {
            var s2 = o2[a2];
            s2 === false ? i2.removeAttribute(a2) : i2.setAttribute(a2, s2 === true ? "" : s2);
          }));
        });
      }
      function Rt(t2) {
        var e2 = t2.state, n2 = { popper: { position: e2.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e2.elements.popper.style, n2.popper), e2.styles = n2, e2.elements.arrow && Object.assign(e2.elements.arrow.style, n2.arrow), function() {
          Object.keys(e2.elements).forEach(function(r2) {
            var o2 = e2.elements[r2], i2 = e2.attributes[r2] || {}, a2 = Object.keys(e2.styles.hasOwnProperty(r2) ? e2.styles[r2] : n2[r2]), s2 = a2.reduce(function(f2, c2) {
              return f2[c2] = "", f2;
            }, {});
            !B$1(o2) || !C(o2) || (Object.assign(o2.style, s2), Object.keys(i2).forEach(function(f2) {
              o2.removeAttribute(f2);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
      function q$1(t2) {
        return t2.split("-")[0];
      }
      var X = Math.max, ve = Math.min, Z = Math.round;
      function ee(t2, e2) {
        e2 === void 0 && (e2 = false);
        var n2 = t2.getBoundingClientRect(), r2 = 1, o2 = 1;
        if (B$1(t2) && e2) {
          var i2 = t2.offsetHeight, a2 = t2.offsetWidth;
          a2 > 0 && (r2 = Z(n2.width) / a2 || 1), i2 > 0 && (o2 = Z(n2.height) / i2 || 1);
        }
        return { width: n2.width / r2, height: n2.height / o2, top: n2.top / o2, right: n2.right / r2, bottom: n2.bottom / o2, left: n2.left / r2, x: n2.left / r2, y: n2.top / o2 };
      }
      function ke(t2) {
        var e2 = ee(t2), n2 = t2.offsetWidth, r2 = t2.offsetHeight;
        return Math.abs(e2.width - n2) <= 1 && (n2 = e2.width), Math.abs(e2.height - r2) <= 1 && (r2 = e2.height), { x: t2.offsetLeft, y: t2.offsetTop, width: n2, height: r2 };
      }
      function it(t2, e2) {
        var n2 = e2.getRootNode && e2.getRootNode();
        if (t2.contains(e2))
          return true;
        if (n2 && Pe(n2)) {
          var r2 = e2;
          do {
            if (r2 && t2.isSameNode(r2))
              return true;
            r2 = r2.parentNode || r2.host;
          } while (r2);
        }
        return false;
      }
      function N$1(t2) {
        return H(t2).getComputedStyle(t2);
      }
      function Wt(t2) {
        return ["table", "td", "th"].indexOf(C(t2)) >= 0;
      }
      function I$1(t2) {
        return ((Q(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
      }
      function ge(t2) {
        return C(t2) === "html" ? t2 : t2.assignedSlot || t2.parentNode || (Pe(t2) ? t2.host : null) || I$1(t2);
      }
      function at(t2) {
        return !B$1(t2) || N$1(t2).position === "fixed" ? null : t2.offsetParent;
      }
      function Bt(t2) {
        var e2 = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n2 = navigator.userAgent.indexOf("Trident") !== -1;
        if (n2 && B$1(t2)) {
          var r2 = N$1(t2);
          if (r2.position === "fixed")
            return null;
        }
        var o2 = ge(t2);
        for (Pe(o2) && (o2 = o2.host); B$1(o2) && ["html", "body"].indexOf(C(o2)) < 0; ) {
          var i2 = N$1(o2);
          if (i2.transform !== "none" || i2.perspective !== "none" || i2.contain === "paint" || ["transform", "perspective"].indexOf(i2.willChange) !== -1 || e2 && i2.willChange === "filter" || e2 && i2.filter && i2.filter !== "none")
            return o2;
          o2 = o2.parentNode;
        }
        return null;
      }
      function se(t2) {
        for (var e2 = H(t2), n2 = at(t2); n2 && Wt(n2) && N$1(n2).position === "static"; )
          n2 = at(n2);
        return n2 && (C(n2) === "html" || C(n2) === "body" && N$1(n2).position === "static") ? e2 : n2 || Bt(t2) || e2;
      }
      function Le(t2) {
        return ["top", "bottom"].indexOf(t2) >= 0 ? "x" : "y";
      }
      function fe(t2, e2, n2) {
        return X(t2, ve(e2, n2));
      }
      function St(t2, e2, n2) {
        var r2 = fe(t2, e2, n2);
        return r2 > n2 ? n2 : r2;
      }
      function st() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft(t2) {
        return Object.assign({}, st(), t2);
      }
      function ct(t2, e2) {
        return e2.reduce(function(n2, r2) {
          return n2[r2] = t2, n2;
        }, {});
      }
      var Tt = function(t2, e2) {
        return t2 = typeof t2 == "function" ? t2(Object.assign({}, e2.rects, { placement: e2.placement })) : t2, ft(typeof t2 != "number" ? t2 : ct(t2, G));
      };
      function Ht(t2) {
        var e2, n2 = t2.state, r2 = t2.name, o2 = t2.options, i2 = n2.elements.arrow, a2 = n2.modifiersData.popperOffsets, s2 = q$1(n2.placement), f2 = Le(s2), c2 = [P$1, W].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
        if (!(!i2 || !a2)) {
          var m2 = Tt(o2.padding, n2), v2 = ke(i2), l2 = f2 === "y" ? E$1 : P$1, h2 = f2 === "y" ? R$1 : W, p = n2.rects.reference[u2] + n2.rects.reference[f2] - a2[f2] - n2.rects.popper[u2], g2 = a2[f2] - n2.rects.reference[f2], x2 = se(i2), y2 = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $2 = p / 2 - g2 / 2, d2 = m2[l2], b2 = y2 - v2[u2] - m2[h2], w2 = y2 / 2 - v2[u2] / 2 + $2, O2 = fe(d2, w2, b2), j2 = f2;
          n2.modifiersData[r2] = (e2 = {}, e2[j2] = O2, e2.centerOffset = O2 - w2, e2);
        }
      }
      function Ct(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = n2.element, o2 = r2 === void 0 ? "[data-popper-arrow]" : r2;
        o2 != null && (typeof o2 == "string" && (o2 = e2.elements.popper.querySelector(o2), !o2) || !it(e2.elements.popper, o2) || (e2.elements.arrow = o2));
      }
      var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t2) {
        return t2.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t2) {
        var e2 = t2.x, n2 = t2.y, r2 = window, o2 = r2.devicePixelRatio || 1;
        return { x: Z(e2 * o2) / o2 || 0, y: Z(n2 * o2) / o2 || 0 };
      }
      function ut(t2) {
        var e2, n2 = t2.popper, r2 = t2.popperRect, o2 = t2.placement, i2 = t2.variation, a2 = t2.offsets, s2 = t2.position, f2 = t2.gpuAcceleration, c2 = t2.adaptive, u2 = t2.roundOffsets, m2 = t2.isFixed, v2 = a2.x, l2 = v2 === void 0 ? 0 : v2, h2 = a2.y, p = h2 === void 0 ? 0 : h2, g2 = typeof u2 == "function" ? u2({ x: l2, y: p }) : { x: l2, y: p };
        l2 = g2.x, p = g2.y;
        var x2 = a2.hasOwnProperty("x"), y2 = a2.hasOwnProperty("y"), $2 = P$1, d2 = E$1, b2 = window;
        if (c2) {
          var w2 = se(n2), O2 = "clientHeight", j2 = "clientWidth";
          if (w2 === H(n2) && (w2 = I$1(n2), N$1(w2).position !== "static" && s2 === "absolute" && (O2 = "scrollHeight", j2 = "scrollWidth")), w2 = w2, o2 === E$1 || (o2 === P$1 || o2 === W) && i2 === J$1) {
            d2 = R$1;
            var A2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.height : w2[O2];
            p -= A2 - r2.height, p *= f2 ? 1 : -1;
          }
          if (o2 === P$1 || (o2 === E$1 || o2 === R$1) && i2 === J$1) {
            $2 = W;
            var k2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.width : w2[j2];
            l2 -= k2 - r2.width, l2 *= f2 ? 1 : -1;
          }
        }
        var D2 = Object.assign({ position: s2 }, c2 && qt), S2 = u2 === true ? Vt({ x: l2, y: p }) : { x: l2, y: p };
        if (l2 = S2.x, p = S2.y, f2) {
          var L2;
          return Object.assign({}, D2, (L2 = {}, L2[d2] = y2 ? "0" : "", L2[$2] = x2 ? "0" : "", L2.transform = (b2.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p + "px)" : "translate3d(" + l2 + "px, " + p + "px, 0)", L2));
        }
        return Object.assign({}, D2, (e2 = {}, e2[d2] = y2 ? p + "px" : "", e2[$2] = x2 ? l2 + "px" : "", e2.transform = "", e2));
      }
      function Nt(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = n2.gpuAcceleration, o2 = r2 === void 0 ? true : r2, i2 = n2.adaptive, a2 = i2 === void 0 ? true : i2, s2 = n2.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q$1(e2.placement), variation: te(e2.placement), popper: e2.elements.popper, popperRect: e2.rects.popper, gpuAcceleration: o2, isFixed: e2.options.strategy === "fixed" };
        e2.modifiersData.popperOffsets != null && (e2.styles.popper = Object.assign({}, e2.styles.popper, ut(Object.assign({}, c2, { offsets: e2.modifiersData.popperOffsets, position: e2.options.strategy, adaptive: a2, roundOffsets: f2 })))), e2.modifiersData.arrow != null && (e2.styles.arrow = Object.assign({}, e2.styles.arrow, ut(Object.assign({}, c2, { offsets: e2.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-placement": e2.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
      function It(t2) {
        var e2 = t2.state, n2 = t2.instance, r2 = t2.options, o2 = r2.scroll, i2 = o2 === void 0 ? true : o2, a2 = r2.resize, s2 = a2 === void 0 ? true : a2, f2 = H(e2.elements.popper), c2 = [].concat(e2.scrollParents.reference, e2.scrollParents.popper);
        return i2 && c2.forEach(function(u2) {
          u2.addEventListener("scroll", n2.update, ye);
        }), s2 && f2.addEventListener("resize", n2.update, ye), function() {
          i2 && c2.forEach(function(u2) {
            u2.removeEventListener("scroll", n2.update, ye);
          }), s2 && f2.removeEventListener("resize", n2.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t2) {
        return t2.replace(/left|right|bottom|top/g, function(e2) {
          return _t[e2];
        });
      }
      var zt = { start: "end", end: "start" };
      function lt(t2) {
        return t2.replace(/start|end/g, function(e2) {
          return zt[e2];
        });
      }
      function We(t2) {
        var e2 = H(t2), n2 = e2.pageXOffset, r2 = e2.pageYOffset;
        return { scrollLeft: n2, scrollTop: r2 };
      }
      function Be(t2) {
        return ee(I$1(t2)).left + We(t2).scrollLeft;
      }
      function Ft(t2) {
        var e2 = H(t2), n2 = I$1(t2), r2 = e2.visualViewport, o2 = n2.clientWidth, i2 = n2.clientHeight, a2 = 0, s2 = 0;
        return r2 && (o2 = r2.width, i2 = r2.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r2.offsetLeft, s2 = r2.offsetTop)), { width: o2, height: i2, x: a2 + Be(t2), y: s2 };
      }
      function Ut(t2) {
        var e2, n2 = I$1(t2), r2 = We(t2), o2 = (e2 = t2.ownerDocument) == null ? void 0 : e2.body, i2 = X(n2.scrollWidth, n2.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a2 = X(n2.scrollHeight, n2.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r2.scrollLeft + Be(t2), f2 = -r2.scrollTop;
        return N$1(o2 || n2).direction === "rtl" && (s2 += X(n2.clientWidth, o2 ? o2.clientWidth : 0) - i2), { width: i2, height: a2, x: s2, y: f2 };
      }
      function Se(t2) {
        var e2 = N$1(t2), n2 = e2.overflow, r2 = e2.overflowX, o2 = e2.overflowY;
        return /auto|scroll|overlay|hidden/.test(n2 + o2 + r2);
      }
      function dt(t2) {
        return ["html", "body", "#document"].indexOf(C(t2)) >= 0 ? t2.ownerDocument.body : B$1(t2) && Se(t2) ? t2 : dt(ge(t2));
      }
      function ce(t2, e2) {
        var n2;
        e2 === void 0 && (e2 = []);
        var r2 = dt(t2), o2 = r2 === ((n2 = t2.ownerDocument) == null ? void 0 : n2.body), i2 = H(r2), a2 = o2 ? [i2].concat(i2.visualViewport || [], Se(r2) ? r2 : []) : r2, s2 = e2.concat(a2);
        return o2 ? s2 : s2.concat(ce(ge(a2)));
      }
      function Te(t2) {
        return Object.assign({}, t2, { left: t2.x, top: t2.y, right: t2.x + t2.width, bottom: t2.y + t2.height });
      }
      function Xt(t2) {
        var e2 = ee(t2);
        return e2.top = e2.top + t2.clientTop, e2.left = e2.left + t2.clientLeft, e2.bottom = e2.top + t2.clientHeight, e2.right = e2.left + t2.clientWidth, e2.width = t2.clientWidth, e2.height = t2.clientHeight, e2.x = e2.left, e2.y = e2.top, e2;
      }
      function ht(t2, e2) {
        return e2 === je ? Te(Ft(t2)) : Q(e2) ? Xt(e2) : Te(Ut(I$1(t2)));
      }
      function Yt(t2) {
        var e2 = ce(ge(t2)), n2 = ["absolute", "fixed"].indexOf(N$1(t2).position) >= 0, r2 = n2 && B$1(t2) ? se(t2) : t2;
        return Q(r2) ? e2.filter(function(o2) {
          return Q(o2) && it(o2, r2) && C(o2) !== "body";
        }) : [];
      }
      function Gt(t2, e2, n2) {
        var r2 = e2 === "clippingParents" ? Yt(t2) : [].concat(e2), o2 = [].concat(r2, [n2]), i2 = o2[0], a2 = o2.reduce(function(s2, f2) {
          var c2 = ht(t2, f2);
          return s2.top = X(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X(c2.left, s2.left), s2;
        }, ht(t2, i2));
        return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
      }
      function mt(t2) {
        var e2 = t2.reference, n2 = t2.element, r2 = t2.placement, o2 = r2 ? q$1(r2) : null, i2 = r2 ? te(r2) : null, a2 = e2.x + e2.width / 2 - n2.width / 2, s2 = e2.y + e2.height / 2 - n2.height / 2, f2;
        switch (o2) {
          case E$1:
            f2 = { x: a2, y: e2.y - n2.height };
            break;
          case R$1:
            f2 = { x: a2, y: e2.y + e2.height };
            break;
          case W:
            f2 = { x: e2.x + e2.width, y: s2 };
            break;
          case P$1:
            f2 = { x: e2.x - n2.width, y: s2 };
            break;
          default:
            f2 = { x: e2.x, y: e2.y };
        }
        var c2 = o2 ? Le(o2) : null;
        if (c2 != null) {
          var u2 = c2 === "y" ? "height" : "width";
          switch (i2) {
            case U:
              f2[c2] = f2[c2] - (e2[u2] / 2 - n2[u2] / 2);
              break;
            case J$1:
              f2[c2] = f2[c2] + (e2[u2] / 2 - n2[u2] / 2);
              break;
          }
        }
        return f2;
      }
      function ne(t2, e2) {
        e2 === void 0 && (e2 = {});
        var n2 = e2, r2 = n2.placement, o2 = r2 === void 0 ? t2.placement : r2, i2 = n2.boundary, a2 = i2 === void 0 ? Xe : i2, s2 = n2.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n2.elementContext, u2 = c2 === void 0 ? K : c2, m2 = n2.altBoundary, v2 = m2 === void 0 ? false : m2, l2 = n2.padding, h2 = l2 === void 0 ? 0 : l2, p = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g2 = u2 === K ? Ye : K, x2 = t2.rects.popper, y2 = t2.elements[v2 ? g2 : u2], $2 = Gt(Q(y2) ? y2 : y2.contextElement || I$1(t2.elements.popper), a2, f2), d2 = ee(t2.elements.reference), b2 = mt({ reference: d2, element: x2, strategy: "absolute", placement: o2 }), w2 = Te(Object.assign({}, x2, b2)), O2 = u2 === K ? w2 : d2, j2 = { top: $2.top - O2.top + p.top, bottom: O2.bottom - $2.bottom + p.bottom, left: $2.left - O2.left + p.left, right: O2.right - $2.right + p.right }, A2 = t2.modifiersData.offset;
        if (u2 === K && A2) {
          var k2 = A2[o2];
          Object.keys(j2).forEach(function(D2) {
            var S2 = [W, R$1].indexOf(D2) >= 0 ? 1 : -1, L2 = [E$1, R$1].indexOf(D2) >= 0 ? "y" : "x";
            j2[D2] += k2[L2] * S2;
          });
        }
        return j2;
      }
      function Jt(t2, e2) {
        e2 === void 0 && (e2 = {});
        var n2 = e2, r2 = n2.placement, o2 = n2.boundary, i2 = n2.rootBoundary, a2 = n2.padding, s2 = n2.flipVariations, f2 = n2.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r2), m2 = u2 ? s2 ? De : De.filter(function(h2) {
          return te(h2) === u2;
        }) : G, v2 = m2.filter(function(h2) {
          return c2.indexOf(h2) >= 0;
        });
        v2.length === 0 && (v2 = m2);
        var l2 = v2.reduce(function(h2, p) {
          return h2[p] = ne(t2, { placement: p, boundary: o2, rootBoundary: i2, padding: a2 })[q$1(p)], h2;
        }, {});
        return Object.keys(l2).sort(function(h2, p) {
          return l2[h2] - l2[p];
        });
      }
      function Kt(t2) {
        if (q$1(t2) === me)
          return [];
        var e2 = be(t2);
        return [lt(t2), e2, lt(e2)];
      }
      function Qt(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name;
        if (!e2.modifiersData[r2]._skip) {
          for (var o2 = n2.mainAxis, i2 = o2 === void 0 ? true : o2, a2 = n2.altAxis, s2 = a2 === void 0 ? true : a2, f2 = n2.fallbackPlacements, c2 = n2.padding, u2 = n2.boundary, m2 = n2.rootBoundary, v2 = n2.altBoundary, l2 = n2.flipVariations, h2 = l2 === void 0 ? true : l2, p = n2.allowedAutoPlacements, g2 = e2.options.placement, x2 = q$1(g2), y2 = x2 === g2, $2 = f2 || (y2 || !h2 ? [be(g2)] : Kt(g2)), d2 = [g2].concat($2).reduce(function(z2, V2) {
            return z2.concat(q$1(V2) === me ? Jt(e2, { placement: V2, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p }) : V2);
          }, []), b2 = e2.rects.reference, w2 = e2.rects.popper, O2 = /* @__PURE__ */ new Map(), j2 = true, A2 = d2[0], k2 = 0; k2 < d2.length; k2++) {
            var D2 = d2[k2], S2 = q$1(D2), L2 = te(D2) === U, re = [E$1, R$1].indexOf(S2) >= 0, oe = re ? "width" : "height", M2 = ne(e2, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v2, padding: c2 }), T2 = re ? L2 ? W : P$1 : L2 ? R$1 : E$1;
            b2[oe] > w2[oe] && (T2 = be(T2));
            var pe = be(T2), _2 = [];
            if (i2 && _2.push(M2[S2] <= 0), s2 && _2.push(M2[T2] <= 0, M2[pe] <= 0), _2.every(function(z2) {
              return z2;
            })) {
              A2 = D2, j2 = false;
              break;
            }
            O2.set(D2, _2);
          }
          if (j2)
            for (var ue = h2 ? 3 : 1, xe = function(z2) {
              var V2 = d2.find(function(de) {
                var ae = O2.get(de);
                if (ae)
                  return ae.slice(0, z2).every(function(Y2) {
                    return Y2;
                  });
              });
              if (V2)
                return A2 = V2, "break";
            }, ie = ue; ie > 0; ie--) {
              var le = xe(ie);
              if (le === "break")
                break;
            }
          e2.placement !== A2 && (e2.modifiersData[r2]._skip = true, e2.placement = A2, e2.reset = true);
        }
      }
      var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt(t2, e2, n2) {
        return n2 === void 0 && (n2 = { x: 0, y: 0 }), { top: t2.top - e2.height - n2.y, right: t2.right - e2.width + n2.x, bottom: t2.bottom - e2.height + n2.y, left: t2.left - e2.width - n2.x };
      }
      function yt(t2) {
        return [E$1, W, R$1, P$1].some(function(e2) {
          return t2[e2] >= 0;
        });
      }
      function Zt(t2) {
        var e2 = t2.state, n2 = t2.name, r2 = e2.rects.reference, o2 = e2.rects.popper, i2 = e2.modifiersData.preventOverflow, a2 = ne(e2, { elementContext: "reference" }), s2 = ne(e2, { altBoundary: true }), f2 = gt(a2, r2), c2 = gt(s2, o2, i2), u2 = yt(f2), m2 = yt(c2);
        e2.modifiersData[n2] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
      }
      var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t2, e2, n2) {
        var r2 = q$1(t2), o2 = [P$1, E$1].indexOf(r2) >= 0 ? -1 : 1, i2 = typeof n2 == "function" ? n2(Object.assign({}, e2, { placement: t2 })) : n2, a2 = i2[0], s2 = i2[1];
        return a2 = a2 || 0, s2 = (s2 || 0) * o2, [P$1, W].indexOf(r2) >= 0 ? { x: s2, y: a2 } : { x: a2, y: s2 };
      }
      function tn(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name, o2 = n2.offset, i2 = o2 === void 0 ? [0, 0] : o2, a2 = Ee.reduce(function(u2, m2) {
          return u2[m2] = en(m2, e2.rects, i2), u2;
        }, {}), s2 = a2[e2.placement], f2 = s2.x, c2 = s2.y;
        e2.modifiersData.popperOffsets != null && (e2.modifiersData.popperOffsets.x += f2, e2.modifiersData.popperOffsets.y += c2), e2.modifiersData[r2] = a2;
      }
      var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t2) {
        var e2 = t2.state, n2 = t2.name;
        e2.modifiersData[n2] = mt({ reference: e2.rects.reference, element: e2.rects.popper, strategy: "absolute", placement: e2.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t2) {
        return t2 === "x" ? "y" : "x";
      }
      function on(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name, o2 = n2.mainAxis, i2 = o2 === void 0 ? true : o2, a2 = n2.altAxis, s2 = a2 === void 0 ? false : a2, f2 = n2.boundary, c2 = n2.rootBoundary, u2 = n2.altBoundary, m2 = n2.padding, v2 = n2.tether, l2 = v2 === void 0 ? true : v2, h2 = n2.tetherOffset, p = h2 === void 0 ? 0 : h2, g2 = ne(e2, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q$1(e2.placement), y2 = te(e2.placement), $2 = !y2, d2 = Le(x2), b2 = rn(d2), w2 = e2.modifiersData.popperOffsets, O2 = e2.rects.reference, j2 = e2.rects.popper, A2 = typeof p == "function" ? p(Object.assign({}, e2.rects, { placement: e2.placement })) : p, k2 = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e2.modifiersData.offset ? e2.modifiersData.offset[e2.placement] : null, S2 = { x: 0, y: 0 };
        if (w2) {
          if (i2) {
            var L2, re = d2 === "y" ? E$1 : P$1, oe = d2 === "y" ? R$1 : W, M2 = d2 === "y" ? "height" : "width", T2 = w2[d2], pe = T2 + g2[re], _2 = T2 - g2[oe], ue = l2 ? -j2[M2] / 2 : 0, xe = y2 === U ? O2[M2] : j2[M2], ie = y2 === U ? -j2[M2] : -O2[M2], le = e2.elements.arrow, z2 = l2 && le ? ke(le) : { width: 0, height: 0 }, V2 = e2.modifiersData["arrow#persistent"] ? e2.modifiersData["arrow#persistent"].padding : st(), de = V2[re], ae = V2[oe], Y2 = fe(0, O2[M2], z2[M2]), jt = $2 ? O2[M2] / 2 - ue - Y2 - de - k2.mainAxis : xe - Y2 - de - k2.mainAxis, Dt = $2 ? -O2[M2] / 2 + ue + Y2 + ae + k2.mainAxis : ie + Y2 + ae + k2.mainAxis, Oe = e2.elements.arrow && se(e2.elements.arrow), Et = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L2 = D2 == null ? void 0 : D2[d2]) != null ? L2 : 0, Pt = T2 + jt - Ce - Et, At = T2 + Dt - Ce, qe = fe(l2 ? ve(pe, Pt) : pe, T2, l2 ? X(_2, At) : _2);
            w2[d2] = qe, S2[d2] = qe - T2;
          }
          if (s2) {
            var Ve, kt = d2 === "x" ? E$1 : P$1, Lt = d2 === "x" ? R$1 : W, F2 = w2[b2], he = b2 === "y" ? "height" : "width", Ne = F2 + g2[kt], Ie = F2 - g2[Lt], $e = [E$1, P$1].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b2]) != null ? Ve : 0, ze = $e ? Ne : F2 - O2[he] - j2[he] - _e + k2.altAxis, Fe = $e ? F2 + O2[he] + j2[he] - _e - k2.altAxis : Ie, Ue = l2 && $e ? St(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
            w2[b2] = Ue, S2[b2] = Ue - F2;
          }
          e2.modifiersData[r2] = S2;
        }
      }
      var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t2) {
        return { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop };
      }
      function sn(t2) {
        return t2 === H(t2) || !B$1(t2) ? We(t2) : an(t2);
      }
      function fn(t2) {
        var e2 = t2.getBoundingClientRect(), n2 = Z(e2.width) / t2.offsetWidth || 1, r2 = Z(e2.height) / t2.offsetHeight || 1;
        return n2 !== 1 || r2 !== 1;
      }
      function cn(t2, e2, n2) {
        n2 === void 0 && (n2 = false);
        var r2 = B$1(e2), o2 = B$1(e2) && fn(e2), i2 = I$1(e2), a2 = ee(t2, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
        return (r2 || !r2 && !n2) && ((C(e2) !== "body" || Se(i2)) && (s2 = sn(e2)), B$1(e2) ? (f2 = ee(e2, true), f2.x += e2.clientLeft, f2.y += e2.clientTop) : i2 && (f2.x = Be(i2))), { x: a2.left + s2.scrollLeft - f2.x, y: a2.top + s2.scrollTop - f2.y, width: a2.width, height: a2.height };
      }
      function pn(t2) {
        var e2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set(), r2 = [];
        t2.forEach(function(i2) {
          e2.set(i2.name, i2);
        });
        function o2(i2) {
          n2.add(i2.name);
          var a2 = [].concat(i2.requires || [], i2.requiresIfExists || []);
          a2.forEach(function(s2) {
            if (!n2.has(s2)) {
              var f2 = e2.get(s2);
              f2 && o2(f2);
            }
          }), r2.push(i2);
        }
        return t2.forEach(function(i2) {
          n2.has(i2.name) || o2(i2);
        }), r2;
      }
      function un(t2) {
        var e2 = pn(t2);
        return ot.reduce(function(n2, r2) {
          return n2.concat(e2.filter(function(o2) {
            return o2.phase === r2;
          }));
        }, []);
      }
      function ln(t2) {
        var e2;
        return function() {
          return e2 || (e2 = new Promise(function(n2) {
            Promise.resolve().then(function() {
              e2 = void 0, n2(t2());
            });
          })), e2;
        };
      }
      function dn(t2) {
        var e2 = t2.reduce(function(n2, r2) {
          var o2 = n2[r2.name];
          return n2[r2.name] = o2 ? Object.assign({}, o2, r2, { options: Object.assign({}, o2.options, r2.options), data: Object.assign({}, o2.data, r2.data) }) : r2, n2;
        }, {});
        return Object.keys(e2).map(function(n2) {
          return e2[n2];
        });
      }
      var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
          e2[n2] = arguments[n2];
        return !e2.some(function(r2) {
          return !(r2 && typeof r2.getBoundingClientRect == "function");
        });
      }
      function we(t2) {
        t2 === void 0 && (t2 = {});
        var e2 = t2, n2 = e2.defaultModifiers, r2 = n2 === void 0 ? [] : n2, o2 = e2.defaultOptions, i2 = o2 === void 0 ? Ot : o2;
        return function(a2, s2, f2) {
          f2 === void 0 && (f2 = i2);
          var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i2), modifiersData: {}, elements: { reference: a2, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m2 = false, v2 = { state: c2, setOptions: function(p) {
            var g2 = typeof p == "function" ? p(c2.options) : p;
            h2(), c2.options = Object.assign({}, i2, c2.options, g2), c2.scrollParents = { reference: Q(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s2) };
            var x2 = un(dn([].concat(r2, c2.options.modifiers)));
            return c2.orderedModifiers = x2.filter(function(y2) {
              return y2.enabled;
            }), l2(), v2.update();
          }, forceUpdate: function() {
            if (!m2) {
              var p = c2.elements, g2 = p.reference, x2 = p.popper;
              if ($t(g2, x2)) {
                c2.rects = { reference: cn(g2, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j2) {
                  return c2.modifiersData[j2.name] = Object.assign({}, j2.data);
                });
                for (var y2 = 0; y2 < c2.orderedModifiers.length; y2++) {
                  if (c2.reset === true) {
                    c2.reset = false, y2 = -1;
                    continue;
                  }
                  var $2 = c2.orderedModifiers[y2], d2 = $2.fn, b2 = $2.options, w2 = b2 === void 0 ? {} : b2, O2 = $2.name;
                  typeof d2 == "function" && (c2 = d2({ state: c2, options: w2, name: O2, instance: v2 }) || c2);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p) {
              v2.forceUpdate(), p(c2);
            });
          }), destroy: function() {
            h2(), m2 = true;
          } };
          if (!$t(a2, s2))
            return v2;
          v2.setOptions(f2).then(function(p) {
            !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p);
          });
          function l2() {
            c2.orderedModifiers.forEach(function(p) {
              var g2 = p.name, x2 = p.options, y2 = x2 === void 0 ? {} : x2, $2 = p.effect;
              if (typeof $2 == "function") {
                var d2 = $2({ state: c2, name: g2, instance: v2, options: y2 }), b2 = function() {
                };
                u2.push(d2 || b2);
              }
            });
          }
          function h2() {
            u2.forEach(function(p) {
              return p();
            }), u2 = [];
          }
          return v2;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
      const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options = vue.computed(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = vue.unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = vue.shallowRef();
        const states = vue.ref({
          styles: {
            popper: {
              position: vue.unref(options).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        vue.watch(options, (newOptions) => {
          const instance = vue.unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        vue.watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, vue.unref(options));
        });
        vue.onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: vue.computed(() => {
            var _a2;
            return { ...((_a2 = vue.unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
          }),
          styles: vue.computed(() => vue.unref(states).styles),
          attributes: vue.computed(() => vue.unref(states).attributes),
          update: () => {
            var _a2;
            return (_a2 = vue.unref(instanceRef)) == null ? void 0 : _a2.update();
          },
          forceUpdate: () => {
            var _a2;
            return (_a2 = vue.unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
          },
          instanceRef: vue.computed(() => vue.unref(instanceRef))
        };
      };
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes
        };
      }
      const useSameTarget = (handleClick) => {
        if (!handleClick) {
          return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
        }
        let mousedownTarget = false;
        let mouseupTarget = false;
        const onClick = (e2) => {
          if (mousedownTarget && mouseupTarget) {
            handleClick(e2);
          }
          mousedownTarget = mouseupTarget = false;
        };
        const onMousedown = (e2) => {
          mousedownTarget = e2.target === e2.currentTarget;
        };
        const onMouseup = (e2) => {
          mouseupTarget = e2.target === e2.currentTarget;
        };
        return { onClick, onMousedown, onMouseup };
      };
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose$1(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = Symbol("elIdInjection");
      const useIdInjection = () => {
        return vue.getCurrentInstance() ? vue.inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      };
      const useId = (deterministicId) => {
        const idInjection = useIdInjection();
        const namespace = useGetDerivedNamespace();
        const idRef = vue.computed(() => vue.unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      };
      let registeredEscapeHandlers = [];
      const cachedHandler = (e2) => {
        const event = e2;
        if (event.key === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = (handler) => {
        vue.onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient$1)
            registeredEscapeHandlers.push(handler);
        });
        vue.onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient$1)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      };
      let cachedContainer;
      const usePopperContainerId = () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id = vue.computed(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = vue.computed(() => `#${id.value}`);
        return {
          id,
          selector
        };
      };
      const createContainer = (id) => {
        const container = document.createElement("div");
        container.id = id;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = () => {
        const { id, selector } = usePopperContainerId();
        vue.onBeforeMount(() => {
          if (!isClient$1)
            return;
          if (!cachedContainer && !document.body.querySelector(selector.value)) {
            cachedContainer = createContainer(id.value);
          }
        });
        return {
          id,
          selector
        };
      };
      const useDelayedToggleProps = buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      });
      const useDelayedToggle = ({
        showAfter,
        hideAfter,
        autoClose,
        open,
        close: close2
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open(event);
            const _autoClose = vue.unref(autoClose);
            if (isNumber$1(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close2(event);
              }, _autoClose);
            }
          }, vue.unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close2(event);
          }, vue.unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      };
      const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
      const useForwardRef = (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        vue.provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      };
      const useForwardRefDirective = (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      };
      const zIndex = vue.ref(0);
      const defaultInitialZIndex = 2e3;
      const zIndexContextKey = Symbol("zIndexContextKey");
      const useZIndex = (zIndexOverrides) => {
        const zIndexInjection = zIndexOverrides || (vue.getCurrentInstance() ? vue.inject(zIndexContextKey, void 0) : void 0);
        const initialZIndex = vue.computed(() => {
          const zIndexFromInjection = vue.unref(zIndexInjection);
          return isNumber$1(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = vue.computed(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          zIndex.value++;
          return currentZIndex.value;
        };
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      };
      function useCursor(input) {
        const selectionRef = vue.ref();
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionRef.value = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionRef.value == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      const useSizeProp = buildProp({
        type: String,
        values: componentSizes,
        required: false
      });
      const SIZE_INJECTION_KEY = Symbol("size");
      const useGlobalSize = () => {
        const injectedSize = vue.inject(SIZE_INJECTION_KEY, {});
        return vue.computed(() => {
          return vue.unref(injectedSize.size) || "";
        });
      };
      function useFocusController(target, { afterFocus, beforeBlur, afterBlur } = {}) {
        const instance = vue.getCurrentInstance();
        const { emit } = instance;
        const wrapperRef = vue.shallowRef();
        const isFocused = vue.ref(false);
        const handleFocus = (event) => {
          if (isFocused.value)
            return;
          isFocused.value = true;
          emit("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a2;
          const cancelBlur = isFunction$2(beforeBlur) ? beforeBlur(event) : false;
          if (cancelBlur || event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
            return;
          isFocused.value = false;
          emit("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = () => {
          var _a2;
          (_a2 = target.value) == null ? void 0 : _a2.focus();
        };
        vue.watch(wrapperRef, (el) => {
          if (el) {
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener$1(wrapperRef, "click", handleClick);
        return {
          wrapperRef,
          isFocused,
          handleFocus,
          handleBlur
        };
      }
      const configProviderContextKey = Symbol();
      const globalConfig = vue.ref();
      function useGlobalConfig(key, defaultValue = void 0) {
        const config = vue.getCurrentInstance() ? vue.inject(configProviderContextKey, globalConfig) : globalConfig;
        if (key) {
          return vue.computed(() => {
            var _a2, _b;
            return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
          });
        } else {
          return config;
        }
      }
      function useGlobalComponentSettings(block, sizeFallback) {
        const config = useGlobalConfig();
        const ns = useNamespace(block, vue.computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
        }));
        const locale2 = useLocale(vue.computed(() => {
          var _a2;
          return (_a2 = config.value) == null ? void 0 : _a2.locale;
        }));
        const zIndex2 = useZIndex(vue.computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
        }));
        const size = vue.computed(() => {
          var _a2;
          return vue.unref(sizeFallback) || ((_a2 = config.value) == null ? void 0 : _a2.size) || "";
        });
        provideGlobalConfig(vue.computed(() => vue.unref(config) || {}));
        return {
          ns,
          locale: locale2,
          zIndex: zIndex2,
          size
        };
      }
      const provideGlobalConfig = (config, app, global2 = false) => {
        var _a2;
        const inSetup = !!vue.getCurrentInstance();
        const oldConfig = inSetup ? useGlobalConfig() : void 0;
        const provideFn = (_a2 = app == null ? void 0 : app.provide) != null ? _a2 : inSetup ? vue.provide : void 0;
        if (!provideFn) {
          return;
        }
        const context = vue.computed(() => {
          const cfg = vue.unref(config);
          if (!(oldConfig == null ? void 0 : oldConfig.value))
            return cfg;
          return mergeConfig(oldConfig.value, cfg);
        });
        provideFn(configProviderContextKey, context);
        provideFn(localeContextKey, vue.computed(() => context.value.locale));
        provideFn(namespaceContextKey, vue.computed(() => context.value.namespace));
        provideFn(zIndexContextKey, vue.computed(() => context.value.zIndex));
        provideFn(SIZE_INJECTION_KEY, {
          size: vue.computed(() => context.value.size || "")
        });
        if (global2 || !globalConfig.value) {
          globalConfig.value = context.value;
        }
        return context;
      };
      const mergeConfig = (a2, b2) => {
        var _a2;
        const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a2), ...keysOf(b2)])];
        const obj = {};
        for (const key of keys2) {
          obj[key] = (_a2 = b2[key]) != null ? _a2 : a2[key];
        }
        return obj;
      };
      var _export_sfc$1 = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const iconProps = buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      });
      const __default__$j = vue.defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$w = /* @__PURE__ */ vue.defineComponent({
        ...__default__$j,
        props: iconProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("icon");
          const style = vue.computed(() => {
            const { size, color } = props;
            if (!size && !color)
              return {};
            return {
              fontSize: isUndefined(size) ? void 0 : addUnit(size),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("i", vue.mergeProps({
              class: vue.unref(ns).b(),
              style: vue.unref(style)
            }, _ctx.$attrs), [
              vue.renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["__file", "icon.vue"]]);
      const ElIcon = withInstall$1(Icon$1);
      const formContextKey = Symbol("formContextKey");
      const formItemContextKey = Symbol("formItemContextKey");
      const useFormSize = (fallback, ignore = {}) => {
        const emptyRef = vue.ref(void 0);
        const size = ignore.prop ? emptyRef : useProp("size");
        const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : vue.inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : vue.inject(formItemContextKey, void 0);
        return vue.computed(() => size.value || vue.unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
      };
      const useFormDisabled = (fallback) => {
        const disabled = useProp("disabled");
        const form = vue.inject(formContextKey, void 0);
        return vue.computed(() => disabled.value || vue.unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      };
      const useFormItem = () => {
        const form = vue.inject(formContextKey, void 0);
        const formItem = vue.inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      };
      const useFormItemInputId = (props, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = vue.ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = vue.ref(false);
        }
        const inputId = vue.ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = vue.computed(() => {
          var _a2;
          return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
        });
        vue.onMounted(() => {
          idUnwatch = vue.watch([vue.toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
            const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        vue.onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      };
      const formMetaProps = buildProps({
        size: {
          type: String,
          values: componentSizes
        },
        disabled: Boolean
      });
      const formProps = buildProps({
        ...formMetaProps,
        model: Object,
        rules: {
          type: definePropType(Object)
        },
        labelPosition: {
          type: String,
          values: ["left", "right", "top"],
          default: "right"
        },
        requireAsteriskPosition: {
          type: String,
          values: ["left", "right"],
          default: "left"
        },
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        labelSuffix: {
          type: String,
          default: ""
        },
        inline: Boolean,
        inlineMessage: Boolean,
        statusIcon: Boolean,
        showMessage: {
          type: Boolean,
          default: true
        },
        validateOnRuleChange: {
          type: Boolean,
          default: true
        },
        hideRequiredAsterisk: Boolean,
        scrollToError: Boolean,
        scrollIntoViewOptions: {
          type: [Object, Boolean]
        }
      });
      const formEmits = {
        validate: (prop, isValid2, message) => (isArray$6(prop) || isString$2(prop)) && isBoolean$1(isValid2) && isString$2(message)
      };
      function useFormLabelWidth() {
        const potentialLabelWidthArr = vue.ref([]);
        const autoLabelWidth = vue.computed(() => {
          if (!potentialLabelWidthArr.value.length)
            return "0";
          const max2 = Math.max(...potentialLabelWidthArr.value);
          return max2 ? `${max2}px` : "";
        });
        function getLabelWidthIndex(width) {
          const index2 = potentialLabelWidthArr.value.indexOf(width);
          if (index2 === -1 && autoLabelWidth.value === "0")
            ;
          return index2;
        }
        function registerLabelWidth(val, oldVal) {
          if (val && oldVal) {
            const index2 = getLabelWidthIndex(oldVal);
            potentialLabelWidthArr.value.splice(index2, 1, val);
          } else if (val) {
            potentialLabelWidthArr.value.push(val);
          }
        }
        function deregisterLabelWidth(val) {
          const index2 = getLabelWidthIndex(val);
          if (index2 > -1) {
            potentialLabelWidthArr.value.splice(index2, 1);
          }
        }
        return {
          autoLabelWidth,
          registerLabelWidth,
          deregisterLabelWidth
        };
      }
      const filterFields = (fields, props) => {
        const normalized = castArray(props);
        return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
      };
      const COMPONENT_NAME$4 = "ElForm";
      const __default__$i = vue.defineComponent({
        name: COMPONENT_NAME$4
      });
      const _sfc_main$v = /* @__PURE__ */ vue.defineComponent({
        ...__default__$i,
        props: formProps,
        emits: formEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const fields = [];
          const formSize = useFormSize();
          const ns = useNamespace("form");
          const formClasses = vue.computed(() => {
            const { labelPosition, inline } = props;
            return [
              ns.b(),
              ns.m(formSize.value || "default"),
              {
                [ns.m(`label-${labelPosition}`)]: labelPosition,
                [ns.m("inline")]: inline
              }
            ];
          });
          const getField = (prop) => {
            return fields.find((field) => field.prop === prop);
          };
          const addField = (field) => {
            fields.push(field);
          };
          const removeField = (field) => {
            if (field.prop) {
              fields.splice(fields.indexOf(field), 1);
            }
          };
          const resetFields = (properties = []) => {
            if (!props.model) {
              return;
            }
            filterFields(fields, properties).forEach((field) => field.resetField());
          };
          const clearValidate = (props2 = []) => {
            filterFields(fields, props2).forEach((field) => field.clearValidate());
          };
          const isValidatable = vue.computed(() => {
            const hasModel = !!props.model;
            return hasModel;
          });
          const obtainValidateFields = (props2) => {
            if (fields.length === 0)
              return [];
            const filteredFields = filterFields(fields, props2);
            if (!filteredFields.length) {
              return [];
            }
            return filteredFields;
          };
          const validate = async (callback) => validateField(void 0, callback);
          const doValidateField = async (props2 = []) => {
            if (!isValidatable.value)
              return false;
            const fields2 = obtainValidateFields(props2);
            if (fields2.length === 0)
              return true;
            let validationErrors = {};
            for (const field of fields2) {
              try {
                await field.validate("");
              } catch (fields3) {
                validationErrors = {
                  ...validationErrors,
                  ...fields3
                };
              }
            }
            if (Object.keys(validationErrors).length === 0)
              return true;
            return Promise.reject(validationErrors);
          };
          const validateField = async (modelProps = [], callback) => {
            const shouldThrow = !isFunction$2(callback);
            try {
              const result = await doValidateField(modelProps);
              if (result === true) {
                callback == null ? void 0 : callback(result);
              }
              return result;
            } catch (e2) {
              if (e2 instanceof Error)
                throw e2;
              const invalidFields = e2;
              if (props.scrollToError) {
                scrollToField(Object.keys(invalidFields)[0]);
              }
              callback == null ? void 0 : callback(false, invalidFields);
              return shouldThrow && Promise.reject(invalidFields);
            }
          };
          const scrollToField = (prop) => {
            var _a2;
            const field = filterFields(fields, prop)[0];
            if (field) {
              (_a2 = field.$el) == null ? void 0 : _a2.scrollIntoView(props.scrollIntoViewOptions);
            }
          };
          vue.watch(() => props.rules, () => {
            if (props.validateOnRuleChange) {
              validate().catch((err) => debugWarn());
            }
          }, { deep: true });
          vue.provide(formContextKey, vue.reactive({
            ...vue.toRefs(props),
            emit,
            resetFields,
            clearValidate,
            validateField,
            getField,
            addField,
            removeField,
            ...useFormLabelWidth()
          }));
          expose({
            validate,
            validateField,
            resetFields,
            clearValidate,
            scrollToField
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("form", {
              class: vue.normalizeClass(vue.unref(formClasses))
            }, [
              vue.renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Form = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["__file", "form.vue"]]);
      var define_process_env_default = {};
      function _extends$1() {
        _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends$1.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o2) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
          return o22.__proto__ || Object.getPrototypeOf(o22);
        };
        return _getPrototypeOf(o2);
      }
      function _setPrototypeOf(o2, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p2) {
          o22.__proto__ = p2;
          return o22;
        };
        return _setPrototypeOf(o2, p);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor = Function.bind.apply(Parent2, a2);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn2) {
        return Function.toString.call(fn2).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning$2 = function warning2() {
      };
      if (typeof process !== "undefined" && define_process_env_default && false) {
        warning$2 = function warning3(type4, errors) {
          if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
            if (errors.every(function(e2) {
              return typeof e2 === "string";
            })) {
              console.warn(type4, errors);
            }
          }
        };
      }
      function convertFieldsError(errors) {
        if (!errors || !errors.length)
          return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format(template) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i2 = 0;
        var len = args.length;
        if (typeof template === "function") {
          return template.apply(null, args);
        }
        if (typeof template === "string") {
          var str = template.replace(formatRegExp, function(x2) {
            if (x2 === "%%") {
              return "%";
            }
            if (i2 >= len) {
              return x2;
            }
            switch (x2) {
              case "%s":
                return String(args[i2++]);
              case "%d":
                return Number(args[i2++]);
              case "%j":
                try {
                  return JSON.stringify(args[i2++]);
                } catch (_2) {
                  return "[Circular]";
                }
                break;
              default:
                return x2;
            }
          });
          return str;
        }
        return template;
      }
      function isNativeStringType(type4) {
        return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
      }
      function isEmptyValue(value, type4) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type4 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type4) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func, callback) {
        var results = [];
        var total = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total++;
          if (total === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a2) {
          func(a2, count);
        });
      }
      function asyncSerialArray(arr, func, callback) {
        var index2 = 0;
        var arrLength = arr.length;
        function next2(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index2;
          index2 = index2 + 1;
          if (original < arrLength) {
            func(arr[original], next2);
          } else {
            callback([]);
          }
        }
        next2([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k2) {
          ret.push.apply(ret, objArr[k2] || []);
        });
        return ret;
      }
      var AsyncValidationError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve, reject) {
            var next2 = function next22(errors) {
              callback(errors);
              return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next2);
          });
          _pending["catch"](function(e2) {
            return e2;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total = 0;
        var results = [];
        var pending = new Promise(function(resolve, reject) {
          var next2 = function next22(errors) {
            results.push.apply(results, errors);
            total++;
            if (total === objArrLength) {
              callback(results);
              return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve(source);
          }
          objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) {
              asyncSerialArray(arr, func, next2);
            } else {
              asyncParallelArray(arr, func, next2);
            }
          });
        });
        pending["catch"](function(e2) {
          return e2;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue$1(value, path) {
        var v2 = value;
        for (var i2 = 0; i2 < path.length; i2++) {
          if (v2 == void 0) {
            return v2;
          }
          v2 = v2[path[i2]];
        }
        return v2;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue$1(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target, source) {
        if (source) {
          for (var s2 in source) {
            if (source.hasOwnProperty(s2)) {
              var value = source[s2];
              if (typeof value === "object" && typeof target[s2] === "object") {
                target[s2] = _extends$1({}, target[s2], value);
              } else {
                target[s2] = value;
              }
            }
          }
        }
        return target;
      }
      var required$1 = function required(rule, value, source, errors, options, type4) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
          errors.push(format(options.messages.required, rule.fullField));
        }
      };
      var whitespace$1 = function whitespace2(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format(options.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b2 = function b22(options) {
          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v4 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options) {
          return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
        };
        ip.v4 = function(options) {
          return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
        };
        ip.v6 = function(options) {
          return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
        };
        var protocol = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex + "$)", "i");
        return urlReg;
      };
      var pattern$2 = {
        // http://emailregex.com/
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        // url: new RegExp(
        //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
        //   'i',
        // ),
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array(value) {
          return Array.isArray(value);
        },
        regexp: function regexp(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e2) {
            return false;
          }
        },
        date: function date(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1 = function type3(rule, value, source, errors, options) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range$1 = function range2(rule, value, source, errors, options) {
        var len = typeof rule.len === "number";
        var min = typeof rule.min === "number";
        var max2 = typeof rule.max === "number";
        var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var val = value;
        var key = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key = "number";
        } else if (str) {
          key = "string";
        } else if (arr) {
          key = "array";
        }
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.replace(spRegexp, "_").length;
        }
        if (len) {
          if (val !== rule.len) {
            errors.push(format(options.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min && !max2 && val < rule.min) {
          errors.push(format(options.messages[key].min, rule.fullField, rule.min));
        } else if (max2 && !min && val > rule.max) {
          errors.push(format(options.messages[key].max, rule.fullField, rule.max));
        } else if (min && max2 && (val < rule.min || val > rule.max)) {
          errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable(rule, value, source, errors, options) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace: whitespace$1,
        type: type$1,
        range: range$1,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var method2 = function method3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var number2 = function number3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var regexp2 = function regexp3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var integer2 = function integer3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var array2 = function array3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var object2 = function object3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable2 = function enumerable3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var pattern2 = function pattern3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var date2 = function date3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var required2 = function required3(rule, value, callback, source, options) {
        var errors = [];
        var type4 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options, type4);
        callback(errors);
      };
      var type2 = function type3(rule, value, callback, source, options) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
        }
        callback(errors);
      };
      var validators = {
        string,
        method: method2,
        number: number2,
        "boolean": _boolean,
        regexp: regexp2,
        integer: integer2,
        "float": floatFn,
        array: array2,
        object: object2,
        "enum": enumerable2,
        pattern: pattern2,
        date: date2,
        url: type2,
        hex: type2,
        email: type2,
        required: required2,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone2() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = /* @__PURE__ */ function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define2(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o2, oc) {
          var _this2 = this;
          if (o2 === void 0) {
            o2 = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options = o2;
          var callback = oc;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add(e2) {
              if (Array.isArray(e2)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e2);
              } else {
                errors.push(e2);
              }
            }
            for (var i2 = 0; i2 < results.length; i2++) {
              add(results[i2]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys2 = options.keys || Object.keys(this.rules);
          keys2.forEach(function(z2) {
            var arr = _this2.rules[z2];
            var value = source[z2];
            arr.forEach(function(r2) {
              var rule = r2;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends$1({}, source);
                }
                value = source[z2] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends$1({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z2;
              rule.fullField = rule.fullField || z2;
              rule.type = _this2.getType(rule);
              series[z2] = series[z2] || [];
              series[z2].push({
                rule,
                value,
                source,
                field: z2
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _extends$1({}, schema, {
                fullField: rule.fullField + "." + key,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
              });
            }
            function cb(e2) {
              if (e2 === void 0) {
                e2 = [];
              }
              var errorList = Array.isArray(e2) ? e2 : [e2];
              if (!options.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends$1({}, fieldsSchema, data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e2) {
                return cb(e2);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        };
        return Schema2;
      }();
      Schema.register = function register(type4, validator) {
        if (typeof validator !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators[type4] = validator;
      };
      Schema.warning = warning$2;
      Schema.messages = messages;
      Schema.validators = validators;
      const formItemValidateStates = [
        "",
        "error",
        "validating",
        "success"
      ];
      const formItemProps = buildProps({
        label: String,
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        prop: {
          type: definePropType([String, Array])
        },
        required: {
          type: Boolean,
          default: void 0
        },
        rules: {
          type: definePropType([Object, Array])
        },
        error: String,
        validateStatus: {
          type: String,
          values: formItemValidateStates
        },
        for: String,
        inlineMessage: {
          type: [String, Boolean],
          default: ""
        },
        showMessage: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          values: componentSizes
        }
      });
      const COMPONENT_NAME$3 = "ElLabelWrap";
      var FormLabelWrap = vue.defineComponent({
        name: COMPONENT_NAME$3,
        props: {
          isAutoWidth: Boolean,
          updateAll: Boolean
        },
        setup(props, {
          slots
        }) {
          const formContext = vue.inject(formContextKey, void 0);
          const formItemContext = vue.inject(formItemContextKey);
          if (!formItemContext)
            throwError(COMPONENT_NAME$3, "usage: <el-form-item><label-wrap /></el-form-item>");
          const ns = useNamespace("form");
          const el = vue.ref();
          const computedWidth = vue.ref(0);
          const getLabelWidth = () => {
            var _a2;
            if ((_a2 = el.value) == null ? void 0 : _a2.firstElementChild) {
              const width = window.getComputedStyle(el.value.firstElementChild).width;
              return Math.ceil(Number.parseFloat(width));
            } else {
              return 0;
            }
          };
          const updateLabelWidth = (action = "update") => {
            vue.nextTick(() => {
              if (slots.default && props.isAutoWidth) {
                if (action === "update") {
                  computedWidth.value = getLabelWidth();
                } else if (action === "remove") {
                  formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
                }
              }
            });
          };
          const updateLabelWidthFn = () => updateLabelWidth("update");
          vue.onMounted(() => {
            updateLabelWidthFn();
          });
          vue.onBeforeUnmount(() => {
            updateLabelWidth("remove");
          });
          vue.onUpdated(() => updateLabelWidthFn());
          vue.watch(computedWidth, (val, oldVal) => {
            if (props.updateAll) {
              formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
            }
          });
          useResizeObserver$1(vue.computed(() => {
            var _a2, _b;
            return (_b = (_a2 = el.value) == null ? void 0 : _a2.firstElementChild) != null ? _b : null;
          }), updateLabelWidthFn);
          return () => {
            var _a2, _b;
            if (!slots)
              return null;
            const {
              isAutoWidth
            } = props;
            if (isAutoWidth) {
              const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
              const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
              const style = {};
              if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
                const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
                const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";
                if (marginWidth) {
                  style[marginPosition] = `${marginWidth}px`;
                }
              }
              return vue.createVNode("div", {
                "ref": el,
                "class": [ns.be("item", "label-wrap")],
                "style": style
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
            } else {
              return vue.createVNode(vue.Fragment, {
                "ref": el
              }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
            }
          };
        }
      });
      const _hoisted_1$d = ["role", "aria-labelledby"];
      const __default__$h = vue.defineComponent({
        name: "ElFormItem"
      });
      const _sfc_main$u = /* @__PURE__ */ vue.defineComponent({
        ...__default__$h,
        props: formItemProps,
        setup(__props, { expose }) {
          const props = __props;
          const slots = vue.useSlots();
          const formContext = vue.inject(formContextKey, void 0);
          const parentFormItemContext = vue.inject(formItemContextKey, void 0);
          const _size = useFormSize(void 0, { formItem: false });
          const ns = useNamespace("form-item");
          const labelId = useId().value;
          const inputIds = vue.ref([]);
          const validateState = vue.ref("");
          const validateStateDebounced = refDebounced(validateState, 100);
          const validateMessage = vue.ref("");
          const formItemRef = vue.ref();
          let initialValue = void 0;
          let isResettingField = false;
          const labelStyle = vue.computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (labelWidth)
              return { width: labelWidth };
            return {};
          });
          const contentStyle = vue.computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
              return {};
            }
            if (!props.label && !props.labelWidth && isNested) {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (!props.label && !slots.label) {
              return { marginLeft: labelWidth };
            }
            return {};
          });
          const formItemClasses = vue.computed(() => [
            ns.b(),
            ns.m(_size.value),
            ns.is("error", validateState.value === "error"),
            ns.is("validating", validateState.value === "validating"),
            ns.is("success", validateState.value === "success"),
            ns.is("required", isRequired.value || props.required),
            ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
            (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
            { [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon }
          ]);
          const _inlineMessage = vue.computed(() => isBoolean$1(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
          const validateClasses = vue.computed(() => [
            ns.e("error"),
            { [ns.em("error", "inline")]: _inlineMessage.value }
          ]);
          const propString = vue.computed(() => {
            if (!props.prop)
              return "";
            return isString$2(props.prop) ? props.prop : props.prop.join(".");
          });
          const hasLabel = vue.computed(() => {
            return !!(props.label || slots.label);
          });
          const labelFor = vue.computed(() => {
            return props.for || (inputIds.value.length === 1 ? inputIds.value[0] : void 0);
          });
          const isGroup = vue.computed(() => {
            return !labelFor.value && hasLabel.value;
          });
          const isNested = !!parentFormItemContext;
          const fieldValue = vue.computed(() => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop) {
              return;
            }
            return getProp(model, props.prop).value;
          });
          const normalizedRules = vue.computed(() => {
            const { required } = props;
            const rules2 = [];
            if (props.rules) {
              rules2.push(...castArray(props.rules));
            }
            const formRules = formContext == null ? void 0 : formContext.rules;
            if (formRules && props.prop) {
              const _rules = getProp(formRules, props.prop).value;
              if (_rules) {
                rules2.push(...castArray(_rules));
              }
            }
            if (required !== void 0) {
              const requiredRules = rules2.map((rule, i2) => [rule, i2]).filter(([rule]) => Object.keys(rule).includes("required"));
              if (requiredRules.length > 0) {
                for (const [rule, i2] of requiredRules) {
                  if (rule.required === required)
                    continue;
                  rules2[i2] = { ...rule, required };
                }
              } else {
                rules2.push({ required });
              }
            }
            return rules2;
          });
          const validateEnabled = vue.computed(() => normalizedRules.value.length > 0);
          const getFilteredRule = (trigger) => {
            const rules2 = normalizedRules.value;
            return rules2.filter((rule) => {
              if (!rule.trigger || !trigger)
                return true;
              if (Array.isArray(rule.trigger)) {
                return rule.trigger.includes(trigger);
              } else {
                return rule.trigger === trigger;
              }
            }).map(({ trigger: trigger2, ...rule }) => rule);
          };
          const isRequired = vue.computed(() => normalizedRules.value.some((rule) => rule.required));
          const shouldShowError = vue.computed(() => {
            var _a2;
            return validateStateDebounced.value === "error" && props.showMessage && ((_a2 = formContext == null ? void 0 : formContext.showMessage) != null ? _a2 : true);
          });
          const currentLabel = vue.computed(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
          const setValidationState = (state) => {
            validateState.value = state;
          };
          const onValidationFailed = (error) => {
            var _a2, _b;
            const { errors, fields } = error;
            if (!errors || !fields) {
              console.error(error);
            }
            setValidationState("error");
            validateMessage.value = errors ? (_b = (_a2 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a2.message) != null ? _b : `${props.prop} is required` : "";
            formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
          };
          const onValidationSucceeded = () => {
            setValidationState("success");
            formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
          };
          const doValidate = async (rules2) => {
            const modelName = propString.value;
            const validator = new Schema({
              [modelName]: rules2
            });
            return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
              onValidationSucceeded();
              return true;
            }).catch((err) => {
              onValidationFailed(err);
              return Promise.reject(err);
            });
          };
          const validate = async (trigger, callback) => {
            if (isResettingField || !props.prop) {
              return false;
            }
            const hasCallback = isFunction$2(callback);
            if (!validateEnabled.value) {
              callback == null ? void 0 : callback(false);
              return false;
            }
            const rules2 = getFilteredRule(trigger);
            if (rules2.length === 0) {
              callback == null ? void 0 : callback(true);
              return true;
            }
            setValidationState("validating");
            return doValidate(rules2).then(() => {
              callback == null ? void 0 : callback(true);
              return true;
            }).catch((err) => {
              const { fields } = err;
              callback == null ? void 0 : callback(false, fields);
              return hasCallback ? false : Promise.reject(fields);
            });
          };
          const clearValidate = () => {
            setValidationState("");
            validateMessage.value = "";
            isResettingField = false;
          };
          const resetField = async () => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop)
              return;
            const computedValue = getProp(model, props.prop);
            isResettingField = true;
            computedValue.value = clone(initialValue);
            await vue.nextTick();
            clearValidate();
            isResettingField = false;
          };
          const addInputId = (id) => {
            if (!inputIds.value.includes(id)) {
              inputIds.value.push(id);
            }
          };
          const removeInputId = (id) => {
            inputIds.value = inputIds.value.filter((listId) => listId !== id);
          };
          vue.watch(() => props.error, (val) => {
            validateMessage.value = val || "";
            setValidationState(val ? "error" : "");
          }, { immediate: true });
          vue.watch(() => props.validateStatus, (val) => setValidationState(val || ""));
          const context = vue.reactive({
            ...vue.toRefs(props),
            $el: formItemRef,
            size: _size,
            validateState,
            labelId,
            inputIds,
            isGroup,
            hasLabel,
            fieldValue,
            addInputId,
            removeInputId,
            resetField,
            clearValidate,
            validate
          });
          vue.provide(formItemContextKey, context);
          vue.onMounted(() => {
            if (props.prop) {
              formContext == null ? void 0 : formContext.addField(context);
              initialValue = clone(fieldValue.value);
            }
          });
          vue.onBeforeUnmount(() => {
            formContext == null ? void 0 : formContext.removeField(context);
          });
          expose({
            size: _size,
            validateMessage,
            validateState,
            validate,
            clearValidate,
            resetField
          });
          return (_ctx, _cache) => {
            var _a2;
            return vue.openBlock(), vue.createElementBlock("div", {
              ref_key: "formItemRef",
              ref: formItemRef,
              class: vue.normalizeClass(vue.unref(formItemClasses)),
              role: vue.unref(isGroup) ? "group" : void 0,
              "aria-labelledby": vue.unref(isGroup) ? vue.unref(labelId) : void 0
            }, [
              vue.createVNode(vue.unref(FormLabelWrap), {
                "is-auto-width": vue.unref(labelStyle).width === "auto",
                "update-all": ((_a2 = vue.unref(formContext)) == null ? void 0 : _a2.labelWidth) === "auto"
              }, {
                default: vue.withCtx(() => [
                  vue.unref(hasLabel) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(labelFor) ? "label" : "div"), {
                    key: 0,
                    id: vue.unref(labelId),
                    for: vue.unref(labelFor),
                    class: vue.normalizeClass(vue.unref(ns).e("label")),
                    style: vue.normalizeStyle(vue.unref(labelStyle))
                  }, {
                    default: vue.withCtx(() => [
                      vue.renderSlot(_ctx.$slots, "label", { label: vue.unref(currentLabel) }, () => [
                        vue.createTextVNode(vue.toDisplayString(vue.unref(currentLabel)), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["id", "for", "class", "style"])) : vue.createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["is-auto-width", "update-all"]),
              vue.createElementVNode("div", {
                class: vue.normalizeClass(vue.unref(ns).e("content")),
                style: vue.normalizeStyle(vue.unref(contentStyle))
              }, [
                vue.renderSlot(_ctx.$slots, "default"),
                vue.createVNode(vue.TransitionGroup, {
                  name: `${vue.unref(ns).namespace.value}-zoom-in-top`
                }, {
                  default: vue.withCtx(() => [
                    vue.unref(shouldShowError) ? vue.renderSlot(_ctx.$slots, "error", {
                      key: 0,
                      error: validateMessage.value
                    }, () => [
                      vue.createElementVNode("div", {
                        class: vue.normalizeClass(vue.unref(validateClasses))
                      }, vue.toDisplayString(validateMessage.value), 3)
                    ]) : vue.createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ], 6)
            ], 10, _hoisted_1$d);
          };
        }
      });
      var FormItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["__file", "form-item.vue"]]);
      const ElForm = withInstall$1(Form, {
        FormItem
      });
      const ElFormItem = withNoopInstall(FormItem);
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style = window.getComputedStyle(targetElement);
        const boxSizing = style.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a2;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          document.body.appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber$1(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result.minHeight = `${minHeight}px`;
        }
        if (isNumber$1(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result.height = `${height}px`;
        (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result;
      }
      const inputProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        maxlength: {
          type: [String, Number]
        },
        minlength: {
          type: [String, Number]
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: {
          type: Boolean,
          default: false
        },
        clearable: {
          type: Boolean,
          default: false
        },
        showPassword: {
          type: Boolean,
          default: false
        },
        showWordLimit: {
          type: Boolean,
          default: false
        },
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        },
        autofocus: {
          type: Boolean,
          default: false
        }
      });
      const inputEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isString$2(value),
        input: (value) => isString$2(value),
        change: (value) => isString$2(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      };
      const _hoisted_1$c = ["role"];
      const _hoisted_2$a = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"];
      const _hoisted_3$6 = ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"];
      const __default__$g = vue.defineComponent({
        name: "ElInput",
        inheritAttrs: false
      });
      const _sfc_main$t = /* @__PURE__ */ vue.defineComponent({
        ...__default__$g,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const rawAttrs = vue.useAttrs();
          const slots = vue.useSlots();
          const containerAttrs = vue.computed(() => {
            const comboBoxAttrs = {};
            if (props.containerRole === "combobox") {
              comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
              comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
              comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
            }
            return comboBoxAttrs;
          });
          const containerKls = vue.computed(() => [
            props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.bm("group", "append")]: slots.append,
              [nsInput.bm("group", "prepend")]: slots.prepend,
              [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value
            },
            rawAttrs.class
          ]);
          const wrapperKls = vue.computed(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const attrs = useAttrs({
            excludeKeys: vue.computed(() => {
              return Object.keys(containerAttrs.value);
            })
          });
          const { form: elForm, formItem: elFormItem } = useFormItem();
          const { inputId } = useFormItemInputId(props, {
            formItemContext: elFormItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = vue.shallowRef();
          const textarea = vue.shallowRef();
          const hovering = vue.ref(false);
          const isComposing = vue.ref(false);
          const passwordVisible = vue.ref(false);
          const countStyle = vue.ref();
          const textareaCalcStyle = vue.shallowRef(props.inputStyle);
          const _ref = vue.computed(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            afterBlur() {
              var _a2;
              if (props.validateEvent) {
                (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "blur").catch((err) => debugWarn());
              }
            }
          });
          const needStatusIcon = vue.computed(() => {
            var _a2;
            return (_a2 = elForm == null ? void 0 : elForm.statusIcon) != null ? _a2 : false;
          });
          const validateState = vue.computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
          const validateIcon = vue.computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = vue.computed(() => passwordVisible.value ? view_default : hide_default);
          const containerStyle = vue.computed(() => [
            rawAttrs.style
          ]);
          const textareaStyle = vue.computed(() => [
            props.inputStyle,
            textareaCalcStyle.value,
            { resize: props.resize }
          ]);
          const nativeInputValue = vue.computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
          const showClear = vue.computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = vue.computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
          const isWordLimitVisible = vue.computed(() => props.showWordLimit && !!props.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
          const textLength = vue.computed(() => nativeInputValue.value.length);
          const inputExceed = vue.computed(() => !!isWordLimitVisible.value && textLength.value > Number(props.maxlength));
          const suffixVisible = vue.computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver$1(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type: type3, autosize } = props;
            if (!isClient$1 || type3 !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$3(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$3(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              vue.nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a2;
              if (isInit || !props.autosize)
                return;
              const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props.formatter) {
              value = props.parser ? props.parser(value) : value;
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit(UPDATE_MODEL_EVENT, value);
            emit("input", value);
            await vue.nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            emit("change", event.target.value);
          };
          const handleCompositionStart = (event) => {
            emit("compositionstart", event);
            isComposing.value = true;
          };
          const handleCompositionUpdate = (event) => {
            var _a2;
            emit("compositionupdate", event);
            const text = (_a2 = event.target) == null ? void 0 : _a2.value;
            const lastCharacter = text[text.length - 1] || "";
            isComposing.value = !isKorean(lastCharacter);
          };
          const handleCompositionEnd = (event) => {
            emit("compositionend", event);
            if (isComposing.value) {
              isComposing.value = false;
              handleInput(event);
            }
          };
          const handlePasswordVisible = () => {
            passwordVisible.value = !passwordVisible.value;
            focus();
          };
          const focus = async () => {
            var _a2;
            await vue.nextTick();
            (_a2 = _ref.value) == null ? void 0 : _a2.focus();
          };
          const blur = () => {
            var _a2;
            return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit("keydown", evt);
          };
          const select = () => {
            var _a2;
            (_a2 = _ref.value) == null ? void 0 : _a2.select();
          };
          const clear = () => {
            emit(UPDATE_MODEL_EVENT, "");
            emit("change", "");
            emit("clear");
            emit("input", "");
          };
          vue.watch(() => props.modelValue, () => {
            var _a2;
            vue.nextTick(() => resizeTextarea());
            if (props.validateEvent) {
              (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
            }
          });
          vue.watch(nativeInputValue, () => setNativeInputValue());
          vue.watch(() => props.type, async () => {
            await vue.nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          vue.onMounted(() => {
            if (!props.formatter && props.parser)
              ;
            setNativeInputValue();
            vue.nextTick(resizeTextarea);
          });
          expose({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: vue.toRef(props, "autosize"),
            focus,
            blur,
            select,
            clear,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", vue.mergeProps(vue.unref(containerAttrs), {
              class: vue.unref(containerKls),
              style: vue.unref(containerStyle),
              role: _ctx.containerRole,
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }), [
              vue.createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                vue.createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (vue.openBlock(), vue.createElementBlock("div", {
                  key: 0,
                  class: vue.normalizeClass(vue.unref(nsInput).be("group", "prepend"))
                }, [
                  vue.renderSlot(_ctx.$slots, "prepend")
                ], 2)) : vue.createCommentVNode("v-if", true),
                vue.createElementVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: vue.normalizeClass(vue.unref(wrapperKls))
                }, [
                  vue.createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (vue.openBlock(), vue.createElementBlock("span", {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(nsInput).e("prefix"))
                  }, [
                    vue.createElementVNode("span", {
                      class: vue.normalizeClass(vue.unref(nsInput).e("prefix-inner"))
                    }, [
                      vue.renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                        key: 0,
                        class: vue.normalizeClass(vue.unref(nsInput).e("icon"))
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : vue.createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("input", vue.mergeProps({
                    id: vue.unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: vue.unref(nsInput).e("inner")
                  }, vue.unref(attrs), {
                    minlength: _ctx.minlength,
                    maxlength: _ctx.maxlength,
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: vue.unref(inputDisabled),
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.label,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: _ctx.form,
                    autofocus: _ctx.autofocus,
                    onCompositionstart: handleCompositionStart,
                    onCompositionupdate: handleCompositionUpdate,
                    onCompositionend: handleCompositionEnd,
                    onInput: handleInput,
                    onFocus: _cache[0] || (_cache[0] = (...args) => vue.unref(handleFocus) && vue.unref(handleFocus)(...args)),
                    onBlur: _cache[1] || (_cache[1] = (...args) => vue.unref(handleBlur) && vue.unref(handleBlur)(...args)),
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, _hoisted_2$a),
                  vue.createCommentVNode(" suffix slot "),
                  vue.unref(suffixVisible) ? (vue.openBlock(), vue.createElementBlock("span", {
                    key: 1,
                    class: vue.normalizeClass(vue.unref(nsInput).e("suffix"))
                  }, [
                    vue.createElementVNode("span", {
                      class: vue.normalizeClass(vue.unref(nsInput).e("suffix-inner"))
                    }, [
                      !vue.unref(showClear) || !vue.unref(showPwdVisible) || !vue.unref(isWordLimitVisible) ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                        vue.renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                          key: 0,
                          class: vue.normalizeClass(vue.unref(nsInput).e("icon"))
                        }, {
                          default: vue.withCtx(() => [
                            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : vue.createCommentVNode("v-if", true)
                      ], 64)) : vue.createCommentVNode("v-if", true),
                      vue.unref(showClear) ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                        key: 1,
                        class: vue.normalizeClass([vue.unref(nsInput).e("icon"), vue.unref(nsInput).e("clear")]),
                        onMousedown: vue.withModifiers(vue.unref(NOOP), ["prevent"]),
                        onClick: clear
                      }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(vue.unref(circle_close_default))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : vue.createCommentVNode("v-if", true),
                      vue.unref(showPwdVisible) ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                        key: 2,
                        class: vue.normalizeClass([vue.unref(nsInput).e("icon"), vue.unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : vue.createCommentVNode("v-if", true),
                      vue.unref(isWordLimitVisible) ? (vue.openBlock(), vue.createElementBlock("span", {
                        key: 3,
                        class: vue.normalizeClass(vue.unref(nsInput).e("count"))
                      }, [
                        vue.createElementVNode("span", {
                          class: vue.normalizeClass(vue.unref(nsInput).e("count-inner"))
                        }, vue.toDisplayString(vue.unref(textLength)) + " / " + vue.toDisplayString(_ctx.maxlength), 3)
                      ], 2)) : vue.createCommentVNode("v-if", true),
                      vue.unref(validateState) && vue.unref(validateIcon) && vue.unref(needStatusIcon) ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                        key: 4,
                        class: vue.normalizeClass([
                          vue.unref(nsInput).e("icon"),
                          vue.unref(nsInput).e("validateIcon"),
                          vue.unref(nsInput).is("loading", vue.unref(validateState) === "validating")
                        ])
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : vue.createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : vue.createCommentVNode("v-if", true)
                ], 2),
                vue.createCommentVNode(" append slot "),
                _ctx.$slots.append ? (vue.openBlock(), vue.createElementBlock("div", {
                  key: 1,
                  class: vue.normalizeClass(vue.unref(nsInput).be("group", "append"))
                }, [
                  vue.renderSlot(_ctx.$slots, "append")
                ], 2)) : vue.createCommentVNode("v-if", true)
              ], 64)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                vue.createCommentVNode(" textarea "),
                vue.createElementVNode("textarea", vue.mergeProps({
                  id: vue.unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: vue.unref(nsTextarea).e("inner")
                }, vue.unref(attrs), {
                  minlength: _ctx.minlength,
                  maxlength: _ctx.maxlength,
                  tabindex: _ctx.tabindex,
                  disabled: vue.unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: vue.unref(textareaStyle),
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[2] || (_cache[2] = (...args) => vue.unref(handleFocus) && vue.unref(handleFocus)(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => vue.unref(handleBlur) && vue.unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_3$6),
                vue.unref(isWordLimitVisible) ? (vue.openBlock(), vue.createElementBlock("span", {
                  key: 0,
                  style: vue.normalizeStyle(countStyle.value),
                  class: vue.normalizeClass(vue.unref(nsInput).e("count"))
                }, vue.toDisplayString(vue.unref(textLength)) + " / " + vue.toDisplayString(_ctx.maxlength), 7)) : vue.createCommentVNode("v-if", true)
              ], 64))
            ], 16, _hoisted_1$c)), [
              [vue.vShow, _ctx.type !== "hidden"]
            ]);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["__file", "input.vue"]]);
      const ElInput = withInstall$1(Input);
      const GAP = 4;
      const BAR_MAP = {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      };
      const renderThumbStyle = ({
        move,
        size,
        bar
      }) => ({
        [bar.size]: size,
        transform: `translate${bar.axis}(${move}%)`
      });
      const scrollbarContextKey = Symbol("scrollbarContextKey");
      const thumbProps = buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      });
      const COMPONENT_NAME$2 = "Thumb";
      const _sfc_main$s = /* @__PURE__ */ vue.defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props = __props;
          const scrollbar = vue.inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$2, "can not inject scrollbar context");
          const instance = vue.ref();
          const thumb = vue.ref();
          const thumbState = vue.ref({});
          const visible = vue.ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let originalOnSelectStart = isClient$1 ? document.onselectstart : null;
          const bar = vue.computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = vue.computed(() => renderThumbStyle({
            size: props.size,
            move: props.move,
            bar: bar.value
          }));
          const offsetRatio = vue.computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e2) => {
            var _a2;
            e2.stopPropagation();
            if (e2.ctrlKey || [1, 2].includes(e2.button))
              return;
            (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
            startDrag(e2);
            const el = e2.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e2[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e2) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset = Math.abs(e2.target.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e2) => {
            e2.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e2) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          vue.onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener$1(vue.toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener$1(vue.toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.Transition, {
              name: vue.unref(ns).b("fade"),
              persisted: ""
            }, {
              default: vue.withCtx(() => [
                vue.withDirectives(vue.createElementVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: vue.normalizeClass([vue.unref(ns).e("bar"), vue.unref(ns).is(vue.unref(bar).key)]),
                  onMousedown: clickTrackHandler
                }, [
                  vue.createElementVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: vue.normalizeClass(vue.unref(ns).e("thumb")),
                    style: vue.normalizeStyle(vue.unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 34), [
                  [vue.vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["__file", "thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        width: String,
        height: String,
        ratioX: {
          type: Number,
          default: 1
        },
        ratioY: {
          type: Number,
          default: 1
        }
      });
      const _sfc_main$r = /* @__PURE__ */ vue.defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose }) {
          const props = __props;
          const moveX = vue.ref(0);
          const moveY = vue.ref(0);
          const handleScroll = (wrap) => {
            if (wrap) {
              const offsetHeight = wrap.offsetHeight - GAP;
              const offsetWidth = wrap.offsetWidth - GAP;
              moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
              moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
            }
          };
          expose({
            handleScroll
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
              vue.createVNode(Thumb, {
                move: moveX.value,
                ratio: _ctx.ratioX,
                size: _ctx.width,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              vue.createVNode(Thumb, {
                move: moveY.value,
                ratio: _ctx.ratioY,
                size: _ctx.height,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["__file", "bar.vue"]]);
      const scrollbarProps = buildProps({
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: {
          type: Boolean,
          default: false
        },
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        },
        id: String,
        role: String,
        ariaLabel: String,
        ariaOrientation: {
          type: String,
          values: ["horizontal", "vertical"]
        }
      });
      const scrollbarEmits = {
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber$1)
      };
      const COMPONENT_NAME$1 = "ElScrollbar";
      const __default__$f = vue.defineComponent({
        name: COMPONENT_NAME$1
      });
      const _sfc_main$q = /* @__PURE__ */ vue.defineComponent({
        ...__default__$f,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopResizeListener = void 0;
          const scrollbarRef = vue.ref();
          const wrapRef = vue.ref();
          const resizeRef = vue.ref();
          const sizeWidth = vue.ref("0");
          const sizeHeight = vue.ref("0");
          const barRef = vue.ref();
          const ratioY = vue.ref(1);
          const ratioX = vue.ref(1);
          const wrapStyle = vue.computed(() => {
            const style = {};
            if (props.height)
              style.height = addUnit(props.height);
            if (props.maxHeight)
              style.maxHeight = addUnit(props.maxHeight);
            return [props.wrapStyle, style];
          });
          const wrapKls = vue.computed(() => {
            return [
              props.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props.native }
            ];
          });
          const resizeKls = vue.computed(() => {
            return [ns.e("view"), props.viewClass];
          });
          const handleScroll = () => {
            var _a2;
            if (wrapRef.value) {
              (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              emit("scroll", {
                scrollTop: wrapRef.value.scrollTop,
                scrollLeft: wrapRef.value.scrollLeft
              });
            }
          };
          function scrollTo2(arg1, arg2) {
            if (isObject$3(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber$1(arg1) && isNumber$1(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber$1(value)) {
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber$1(value)) {
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update = () => {
            if (!wrapRef.value)
              return;
            const offsetHeight = wrapRef.value.offsetHeight - GAP;
            const offsetWidth = wrapRef.value.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrapRef.value.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrapRef.value.scrollWidth;
            const height = Math.max(originalHeight, props.minSize);
            const width = Math.max(originalWidth, props.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          vue.watch(() => props.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver$1(resizeRef, update));
              stopResizeListener = useEventListener$1("resize", update);
            }
          }, { immediate: true });
          vue.watch(() => [props.maxHeight, props.height], () => {
            if (!props.native)
              vue.nextTick(() => {
                var _a2;
                update();
                if (wrapRef.value) {
                  (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
                }
              });
          });
          vue.provide(scrollbarContextKey, vue.reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          vue.onMounted(() => {
            if (!props.native)
              vue.nextTick(() => {
                update();
              });
          });
          vue.onUpdated(() => update());
          expose({
            wrapRef,
            update,
            scrollTo: scrollTo2,
            setScrollTop,
            setScrollLeft,
            handleScroll
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: vue.normalizeClass(vue.unref(ns).b())
            }, [
              vue.createElementVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: vue.normalizeClass(vue.unref(wrapKls)),
                style: vue.normalizeStyle(vue.unref(wrapStyle)),
                onScroll: handleScroll
              }, [
                (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.tag), {
                  id: _ctx.id,
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: vue.normalizeClass(vue.unref(resizeKls)),
                  style: vue.normalizeStyle(_ctx.viewStyle),
                  role: _ctx.role,
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": _ctx.ariaOrientation
                }, {
                  default: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
              ], 38),
              !_ctx.native ? (vue.openBlock(), vue.createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                height: sizeHeight.value,
                width: sizeWidth.value,
                always: _ctx.always,
                "ratio-x": ratioX.value,
                "ratio-y": ratioY.value
              }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : vue.createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["__file", "scrollbar.vue"]]);
      const ElScrollbar = withInstall$1(Scrollbar);
      const POPPER_INJECTION_KEY = Symbol("popper");
      const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
      const roleTypes = [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ];
      const popperProps = buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      });
      const __default__$e = vue.defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$p = /* @__PURE__ */ vue.defineComponent({
        ...__default__$e,
        props: popperProps,
        setup(__props, { expose }) {
          const props = __props;
          const triggerRef2 = vue.ref();
          const popperInstanceRef = vue.ref();
          const contentRef = vue.ref();
          const referenceRef = vue.ref();
          const role = vue.computed(() => props.role);
          const popperProvides = {
            triggerRef: triggerRef2,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose(popperProvides);
          vue.provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return vue.renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["__file", "popper.vue"]]);
      const popperArrowProps = buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      });
      const __default__$d = vue.defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$o = /* @__PURE__ */ vue.defineComponent({
        ...__default__$d,
        props: popperArrowProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("popper");
          const { arrowOffset, arrowRef, arrowStyle } = vue.inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          vue.watch(() => props.arrowOffset, (val) => {
            arrowOffset.value = val;
          });
          vue.onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose({
            arrowRef
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: vue.normalizeClass(vue.unref(ns).e("arrow")),
              style: vue.normalizeStyle(vue.unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["__file", "arrow.vue"]]);
      const NAME = "ElOnlyChild";
      const OnlyChild = vue.defineComponent({
        name: NAME,
        setup(_2, {
          slots,
          attrs
        }) {
          var _a2;
          const forwardRefInjection = vue.inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
          return () => {
            var _a22;
            const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              return null;
            }
            return vue.withDirectives(vue.cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node2) {
        if (!node2)
          return null;
        const children = node2;
        for (const child of children) {
          if (isObject$3(child)) {
            switch (child.type) {
              case vue.Comment:
                continue;
              case vue.Text:
              case "svg":
                return wrapTextContent(child);
              case vue.Fragment:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s2) {
        const ns = useNamespace("only-child");
        return vue.createVNode("span", {
          "class": ns.e("content")
        }, [s2]);
      }
      const popperTriggerProps = buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      });
      const __default__$c = vue.defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$n = /* @__PURE__ */ vue.defineComponent({
        ...__default__$c,
        props: popperTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const { role, triggerRef: triggerRef2 } = vue.inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef2);
          const ariaControls = vue.computed(() => {
            return ariaHaspopup.value ? props.id : void 0;
          });
          const ariaDescribedby = vue.computed(() => {
            if (role && role.value === "tooltip") {
              return props.open && props.id ? props.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = vue.computed(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = vue.computed(() => {
            return ariaHaspopup.value ? `${props.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          vue.onMounted(() => {
            vue.watch(() => props.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef2.value = unrefElement$1(virtualEl);
              }
            }, {
              immediate: true
            });
            vue.watch(triggerRef2, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement$1(el)) {
                [
                  "onMouseenter",
                  "onMouseleave",
                  "onClick",
                  "onKeydown",
                  "onFocus",
                  "onBlur",
                  "onContextmenu"
                ].forEach((eventName) => {
                  var _a2;
                  const handler = props[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                virtualTriggerAriaStopWatch = vue.watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                  [
                    "aria-controls",
                    "aria-describedby",
                    "aria-haspopup",
                    "aria-expanded"
                  ].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (isElement$1(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          vue.onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
          });
          expose({
            triggerRef: triggerRef2
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (vue.openBlock(), vue.createBlock(vue.unref(OnlyChild), vue.mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": vue.unref(ariaControls),
              "aria-describedby": vue.unref(ariaDescribedby),
              "aria-expanded": vue.unref(ariaExpanded),
              "aria-haspopup": vue.unref(ariaHaspopup)
            }), {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : vue.createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__file", "trigger.vue"]]);
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = vue.ref();
      const lastUserFocusTimestamp = vue.ref(0);
      const lastAutomatedFocusTimestamp = vue.ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node2) => {
            const isHiddenInput = node2.tagName === "INPUT" && node2.type === "hidden";
            if (node2.disabled || node2.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node2.tabIndex >= 0 || node2 === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first = getVisibleElement(focusable, container);
        const last = getVisibleElement(focusable.reverse(), container);
        return [first, last];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack = [];
        const push2 = (layer) => {
          const currentLayer = stack[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack = removeFromStack(stack, layer);
          stack.unshift(layer);
        };
        const remove = (layer) => {
          var _a2, _b;
          stack = removeFromStack(stack, layer);
          (_b = (_a2 = stack[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
        };
        return {
          push: push2,
          remove
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        vue.onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        vue.onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const _sfc_main$m = vue.defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props, { emit }) {
          const forwardRef = vue.ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props.trapped && !focusLayer.paused) {
              emit("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e2) => {
            if (!props.loop && !props.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e2;
            const { loop } = props;
            const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first, last] = getEdges(container);
              const isTabbable = first && last;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                    if (loop)
                      tryFocus(first, true);
                  }
                } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                    if (loop)
                      tryFocus(last, true);
                  }
                }
              }
            }
          };
          vue.provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          vue.watch(() => props.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          vue.watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e2) => {
            emit(ON_TRAP_FOCUS_EVT, e2);
          };
          const releaseOnFocus = (e2) => emit(ON_RELEASE_FOCUS_EVT, e2);
          const onFocusIn = (e2) => {
            const trapContainer = vue.unref(forwardRef);
            if (!trapContainer)
              return;
            const target = e2.target;
            const relatedTarget = e2.relatedTarget;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!props.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit("focusin", e2);
            if (focusLayer.paused)
              return;
            if (props.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e2) => {
            const trapContainer = vue.unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props.trapped) {
              const relatedTarget = e2.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target = e2.target;
              const isFocusedInTrap = target && trapContainer.contains(target);
              if (!isFocusedInTrap)
                emit("focusout", e2);
            }
          };
          async function startTrap() {
            await vue.nextTick();
            const trapContainer = vue.unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  vue.nextTick(() => {
                    let focusStartEl = props.focusStartEl;
                    if (!isString$2(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = vue.unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          vue.onMounted(() => {
            if (props.trapped) {
              startTrap();
            }
            vue.watch(() => props.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          vue.onBeforeUnmount(() => {
            if (props.trapped) {
              stopTrap();
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["render", _sfc_render$6], ["__file", "focus-trap.vue"]]);
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      });
      const popperContentProps = buildProps({
        ...popperCoreConfigProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: String,
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: {
          type: Boolean,
          default: false
        },
        trapping: {
          type: Boolean,
          default: false
        },
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        ariaLabel: {
          type: String,
          default: void 0
        },
        virtualTriggering: Boolean,
        zIndex: Number
      });
      const popperContentEmits = {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      };
      const buildPopperOptions = (props, modifiers = []) => {
        const { placement, strategy, popperOptions } = props;
        const options = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props), ...modifiers]
        };
        deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient$1)
          return;
        return unrefElement$1($el);
      };
      function genModifiers(options) {
        const { offset, gpuAcceleration, fallbackPlacements } = options;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset != null ? offset : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options, modifiers) {
        if (modifiers) {
          options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props) => {
        const { popperInstanceRef, contentRef, triggerRef: triggerRef2, role } = vue.inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = vue.ref();
        const arrowOffset = vue.ref();
        const eventListenerModifier = vue.computed(() => {
          return {
            name: "eventListeners",
            enabled: !!props.visible
          };
        });
        const arrowModifier = vue.computed(() => {
          var _a2;
          const arrowEl = vue.unref(arrowRef);
          const offset = (_a2 = vue.unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined$1(arrowEl),
            options: {
              element: arrowEl,
              padding: offset
            }
          };
        });
        const options = vue.computed(() => {
          return {
            onFirstUpdate: () => {
              update();
            },
            ...buildPopperOptions(props, [
              vue.unref(arrowModifier),
              vue.unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = vue.computed(() => unwrapMeasurableEl(props.referenceEl) || vue.unref(triggerRef2));
        const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
        vue.watch(instanceRef, (instance) => popperInstanceRef.value = instance);
        vue.onMounted(() => {
          vue.watch(() => {
            var _a2;
            return (_a2 = vue.unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
          }, () => {
            update();
          });
        });
        return {
          attributes,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update
        };
      };
      const usePopperContentDOM = (props, {
        attributes,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = vue.computed(() => vue.unref(attributes).popper);
        const contentZIndex = vue.ref(isNumber$1(props.zIndex) ? props.zIndex : nextZIndex());
        const contentClass = vue.computed(() => [
          ns.b(),
          ns.is("pure", props.pure),
          ns.is(props.effect),
          props.popperClass
        ]);
        const contentStyle = vue.computed(() => {
          return [
            { zIndex: vue.unref(contentZIndex) },
            vue.unref(styles).popper,
            props.popperStyle || {}
          ];
        });
        const ariaModal = vue.computed(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = vue.computed(() => vue.unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = isNumber$1(props.zIndex) ? props.zIndex : nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const usePopperContentFocusTrap = (props, emit) => {
        const trapped = vue.ref(false);
        const focusStartRef = vue.ref();
        const onFocusAfterTrapped = () => {
          emit("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const __default__$b = vue.defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$l = /* @__PURE__ */ vue.defineComponent({
        ...__default__$b,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props, emit);
          const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props, {
            styles,
            attributes,
            role
          });
          const formItemContext = vue.inject(formItemContextKey, void 0);
          const arrowOffset = vue.ref();
          vue.provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef,
            arrowOffset
          });
          if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
            vue.provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props.visible && props.focusOnShow) {
              trapped.value = true;
            } else if (props.visible === false) {
              trapped.value = false;
            }
          };
          vue.onMounted(() => {
            vue.watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = vue.unref(triggerTargetEl || contentRef.value);
              const prevEl = vue.unref(prevTriggerTargetEl || contentRef.value);
              if (isElement$1(el)) {
                triggerTargetAriaStopWatch = vue.watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement$1(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            vue.watch(() => props.visible, togglePopperAlive, { immediate: true });
          });
          vue.onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", vue.mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, vue.unref(contentAttrs), {
              style: vue.unref(contentStyle),
              class: vue.unref(contentClass),
              tabindex: "-1",
              onMouseenter: _cache[0] || (_cache[0] = (e2) => _ctx.$emit("mouseenter", e2)),
              onMouseleave: _cache[1] || (_cache[1] = (e2) => _ctx.$emit("mouseleave", e2))
            }), [
              vue.createVNode(vue.unref(ElFocusTrap), {
                trapped: vue.unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": vue.unref(contentRef),
                "focus-start-el": vue.unref(focusStartRef),
                onFocusAfterTrapped: vue.unref(onFocusAfterTrapped),
                onFocusAfterReleased: vue.unref(onFocusAfterReleased),
                onFocusin: vue.unref(onFocusInTrap),
                onFocusoutPrevented: vue.unref(onFocusoutPrevented),
                onReleaseRequested: vue.unref(onReleaseRequested)
              }, {
                default: vue.withCtx(() => [
                  vue.renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16);
          };
        }
      });
      var ElPopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__file", "content.vue"]]);
      const ElPopper = withInstall$1(Popper);
      const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
      const useTooltipContentProps = buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: definePropType([String, Object])
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: {
          type: Boolean,
          default: false
        },
        persistent: Boolean,
        ariaLabel: String,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean
      });
      const useTooltipTriggerProps = buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.space]
        }
      });
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      const useTooltipProps = buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      });
      const tooltipEmits = [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ];
      const isTriggerType = (trigger, type3) => {
        if (isArray$6(trigger)) {
          return trigger.includes(type3);
        }
        return trigger === type3;
      };
      const whenTrigger = (trigger, type3, handler) => {
        return (e2) => {
          isTriggerType(vue.unref(trigger), type3) && handler(e2);
        };
      };
      const __default__$a = vue.defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$k = /* @__PURE__ */ vue.defineComponent({
        ...__default__$a,
        props: useTooltipTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id, open, onOpen, onClose, onToggle } = vue.inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef2 = vue.ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (vue.unref(controlled) || props.disabled) {
              return true;
            }
          };
          const trigger = vue.toRef(props, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "click", (e2) => {
            if (e2.button === 0) {
              onToggle(e2);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "contextmenu", (e2) => {
            e2.preventDefault();
            onToggle(e2);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e2) => {
            const { code } = e2;
            if (props.triggerKeys.includes(code)) {
              e2.preventDefault();
              onToggle(e2);
            }
          });
          expose({
            triggerRef: triggerRef2
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.unref(ElPopperTrigger), {
              id: vue.unref(id),
              "virtual-ref": _ctx.virtualRef,
              open: vue.unref(open),
              "virtual-triggering": _ctx.virtualTriggering,
              class: vue.normalizeClass(vue.unref(ns).e("trigger")),
              onBlur: vue.unref(onBlur),
              onClick: vue.unref(onClick),
              onContextmenu: vue.unref(onContextMenu),
              onFocus: vue.unref(onFocus),
              onMouseenter: vue.unref(onMouseenter),
              onMouseleave: vue.unref(onMouseleave),
              onKeydown: vue.unref(onKeydown)
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__file", "trigger.vue"]]);
      const __default__$9 = vue.defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$j = /* @__PURE__ */ vue.defineComponent({
        ...__default__$9,
        props: useTooltipContentProps,
        setup(__props, { expose }) {
          const props = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = vue.ref(null);
          const destroyed = vue.ref(false);
          const {
            controlled,
            id,
            open,
            trigger,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = vue.inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = vue.computed(() => {
            return props.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = vue.computed(() => {
            return props.persistent;
          });
          vue.onBeforeUnmount(() => {
            destroyed.value = true;
          });
          const shouldRender = vue.computed(() => {
            return vue.unref(persistentRef) ? true : vue.unref(open);
          });
          const shouldShow = vue.computed(() => {
            return props.disabled ? false : vue.unref(open);
          });
          const appendTo = vue.computed(() => {
            return props.appendTo || selector.value;
          });
          const contentStyle = vue.computed(() => {
            var _a2;
            return (_a2 = props.style) != null ? _a2 : {};
          });
          const ariaHidden = vue.computed(() => !vue.unref(open));
          const onTransitionLeave = () => {
            onHide();
          };
          const stopWhenControlled = () => {
            if (vue.unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props.enterable && vue.unref(trigger) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (vue.unref(trigger) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
            stopHandle = onClickOutside(vue.computed(() => {
              var _a2;
              return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
            }), () => {
              if (vue.unref(controlled))
                return;
              const $trigger = vue.unref(trigger);
              if ($trigger !== "hover") {
                onClose();
              }
            });
          };
          const onBlur = () => {
            if (!props.virtualTriggering) {
              onClose();
            }
          };
          let stopHandle;
          vue.watch(() => vue.unref(open), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            }
          }, {
            flush: "post"
          });
          vue.watch(() => props.content, () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          expose({
            contentRef
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.Teleport, {
              disabled: !_ctx.teleported,
              to: vue.unref(appendTo)
            }, [
              vue.createVNode(vue.Transition, {
                name: vue.unref(transitionClass),
                onAfterLeave: onTransitionLeave,
                onBeforeEnter,
                onAfterEnter: onAfterShow,
                onBeforeLeave
              }, {
                default: vue.withCtx(() => [
                  vue.unref(shouldRender) ? vue.withDirectives((vue.openBlock(), vue.createBlock(vue.unref(ElPopperContent), vue.mergeProps({
                    key: 0,
                    id: vue.unref(id),
                    ref_key: "contentRef",
                    ref: contentRef
                  }, _ctx.$attrs, {
                    "aria-label": _ctx.ariaLabel,
                    "aria-hidden": vue.unref(ariaHidden),
                    "boundaries-padding": _ctx.boundariesPadding,
                    "fallback-placements": _ctx.fallbackPlacements,
                    "gpu-acceleration": _ctx.gpuAcceleration,
                    offset: _ctx.offset,
                    placement: _ctx.placement,
                    "popper-options": _ctx.popperOptions,
                    strategy: _ctx.strategy,
                    effect: _ctx.effect,
                    enterable: _ctx.enterable,
                    pure: _ctx.pure,
                    "popper-class": _ctx.popperClass,
                    "popper-style": [_ctx.popperStyle, vue.unref(contentStyle)],
                    "reference-el": _ctx.referenceEl,
                    "trigger-target-el": _ctx.triggerTargetEl,
                    visible: vue.unref(shouldShow),
                    "z-index": _ctx.zIndex,
                    onMouseenter: vue.unref(onContentEnter),
                    onMouseleave: vue.unref(onContentLeave),
                    onBlur,
                    onClose: vue.unref(onClose)
                  }), {
                    default: vue.withCtx(() => [
                      !destroyed.value ? vue.renderSlot(_ctx.$slots, "default", { key: 0 }) : vue.createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                    [vue.vShow, vue.unref(shouldShow)]
                  ]) : vue.createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["name"])
            ], 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__file", "content.vue"]]);
      const _hoisted_1$b = ["innerHTML"];
      const _hoisted_2$9 = { key: 1 };
      const __default__$8 = vue.defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$i = /* @__PURE__ */ vue.defineComponent({
        ...__default__$8,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          usePopperContainer();
          const id = useId();
          const popperRef = vue.ref();
          const contentRef = vue.ref();
          const updatePopper = () => {
            var _a2;
            const popperComponent = vue.unref(popperRef);
            if (popperComponent) {
              (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
            }
          };
          const open = vue.ref(false);
          const toggleReason = vue.ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: vue.toRef(props, "showAfter"),
            hideAfter: vue.toRef(props, "hideAfter"),
            autoClose: vue.toRef(props, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = vue.computed(() => isBoolean$1(props.visible) && !hasUpdateHandler.value);
          vue.provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id,
            open: vue.readonly(open),
            trigger: vue.toRef(props, "trigger"),
            onOpen: (event) => {
              onOpen(event);
            },
            onClose: (event) => {
              onClose(event);
            },
            onToggle: (event) => {
              if (vue.unref(open)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit("show", toggleReason.value);
            },
            onHide: () => {
              emit("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit("before-hide", toggleReason.value);
            },
            updatePopper
          });
          vue.watch(() => props.disabled, (disabled) => {
            if (disabled && open.value) {
              open.value = false;
            }
          });
          const isFocusInsideContent = (event) => {
            var _a2, _b;
            const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
            const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
            return popperContent && popperContent.contains(activeElement);
          };
          vue.onDeactivated(() => open.value && hide());
          expose({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: vue.withCtx(() => [
                    _ctx.$slots.default ? vue.renderSlot(_ctx.$slots, "default", { key: 0 }) : vue.createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                vue.createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": _ctx.popperClass,
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: vue.withCtx(() => [
                    vue.renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (vue.openBlock(), vue.createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, _hoisted_1$b)) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$9, vue.toDisplayString(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (vue.openBlock(), vue.createBlock(vue.unref(ElPopperArrow), {
                      key: 0,
                      "arrow-offset": _ctx.arrowOffset
                    }, null, 8, ["arrow-offset"])) : vue.createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip$2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "tooltip.vue"]]);
      const ElTooltip = withInstall$1(Tooltip$2);
      function bound01(n2, max2) {
        if (isOnePointZero(n2)) {
          n2 = "100%";
        }
        var isPercent = isPercentage(n2);
        n2 = max2 === 360 ? n2 : Math.min(max2, Math.max(0, parseFloat(n2)));
        if (isPercent) {
          n2 = parseInt(String(n2 * max2), 10) / 100;
        }
        if (Math.abs(n2 - max2) < 1e-6) {
          return 1;
        }
        if (max2 === 360) {
          n2 = (n2 < 0 ? n2 % max2 + max2 : n2 % max2) / parseFloat(String(max2));
        } else {
          n2 = n2 % max2 / parseFloat(String(max2));
        }
        return n2;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero(n2) {
        return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
      }
      function isPercentage(n2) {
        return typeof n2 === "string" && n2.indexOf("%") !== -1;
      }
      function boundAlpha(a2) {
        a2 = parseFloat(a2);
        if (isNaN(a2) || a2 < 0 || a2 > 1) {
          a2 = 1;
        }
        return a2;
      }
      function convertToPercentage(n2) {
        if (n2 <= 1) {
          return "".concat(Number(n2) * 100, "%");
        }
        return n2;
      }
      function pad2(c2) {
        return c2.length === 1 ? "0" + c2 : String(c2);
      }
      function rgbToRgb(r2, g2, b2) {
        return {
          r: bound01(r2, 255) * 255,
          g: bound01(g2, 255) * 255,
          b: bound01(b2, 255) * 255
        };
      }
      function rgbToHsl(r2, g2, b2) {
        r2 = bound01(r2, 255);
        g2 = bound01(g2, 255);
        b2 = bound01(b2, 255);
        var max2 = Math.max(r2, g2, b2);
        var min = Math.min(r2, g2, b2);
        var h2 = 0;
        var s2 = 0;
        var l2 = (max2 + min) / 2;
        if (max2 === min) {
          s2 = 0;
          h2 = 0;
        } else {
          var d2 = max2 - min;
          s2 = l2 > 0.5 ? d2 / (2 - max2 - min) : d2 / (max2 + min);
          switch (max2) {
            case r2:
              h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              h2 = (b2 - r2) / d2 + 2;
              break;
            case b2:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, l: l2 };
      }
      function hue2rgb(p, q2, t2) {
        if (t2 < 0) {
          t2 += 1;
        }
        if (t2 > 1) {
          t2 -= 1;
        }
        if (t2 < 1 / 6) {
          return p + (q2 - p) * (6 * t2);
        }
        if (t2 < 1 / 2) {
          return q2;
        }
        if (t2 < 2 / 3) {
          return p + (q2 - p) * (2 / 3 - t2) * 6;
        }
        return p;
      }
      function hslToRgb(h2, s2, l2) {
        var r2;
        var g2;
        var b2;
        h2 = bound01(h2, 360);
        s2 = bound01(s2, 100);
        l2 = bound01(l2, 100);
        if (s2 === 0) {
          g2 = l2;
          b2 = l2;
          r2 = l2;
        } else {
          var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
          var p = 2 * l2 - q2;
          r2 = hue2rgb(p, q2, h2 + 1 / 3);
          g2 = hue2rgb(p, q2, h2);
          b2 = hue2rgb(p, q2, h2 - 1 / 3);
        }
        return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
      }
      function rgbToHsv(r2, g2, b2) {
        r2 = bound01(r2, 255);
        g2 = bound01(g2, 255);
        b2 = bound01(b2, 255);
        var max2 = Math.max(r2, g2, b2);
        var min = Math.min(r2, g2, b2);
        var h2 = 0;
        var v2 = max2;
        var d2 = max2 - min;
        var s2 = max2 === 0 ? 0 : d2 / max2;
        if (max2 === min) {
          h2 = 0;
        } else {
          switch (max2) {
            case r2:
              h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              h2 = (b2 - r2) / d2 + 2;
              break;
            case b2:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, v: v2 };
      }
      function hsvToRgb(h2, s2, v2) {
        h2 = bound01(h2, 360) * 6;
        s2 = bound01(s2, 100);
        v2 = bound01(v2, 100);
        var i2 = Math.floor(h2);
        var f2 = h2 - i2;
        var p = v2 * (1 - s2);
        var q2 = v2 * (1 - f2 * s2);
        var t2 = v2 * (1 - (1 - f2) * s2);
        var mod = i2 % 6;
        var r2 = [v2, q2, p, p, t2, v2][mod];
        var g2 = [t2, v2, v2, q2, p, p][mod];
        var b2 = [p, p, t2, v2, v2, q2][mod];
        return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
      }
      function rgbToHex(r2, g2, b2, allow3Char) {
        var hex = [
          pad2(Math.round(r2).toString(16)),
          pad2(Math.round(g2).toString(16)),
          pad2(Math.round(b2).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r2, g2, b2, a2, allow4Char) {
        var hex = [
          pad2(Math.round(r2).toString(16)),
          pad2(Math.round(g2).toString(16)),
          pad2(Math.round(b2).toString(16)),
          pad2(convertDecimalToHex(a2))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d2) {
        return Math.round(parseFloat(d2) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a2 = 1;
        var s2 = null;
        var v2 = null;
        var l2 = null;
        var ok = false;
        var format2 = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s2 = convertToPercentage(color.s);
            v2 = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s2, v2);
            ok = true;
            format2 = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s2 = convertToPercentage(color.s);
            l2 = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s2, l2);
            ok = true;
            format2 = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a2 = color.a;
          }
        }
        a2 = boundAlpha(a2);
        return {
          ok,
          format: color.format || format2,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a: a2
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match = matchers.rgb.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        match = matchers.rgba.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        match = matchers.hsl.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        match = matchers.hsla.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        match = matchers.hsv.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        match = matchers.hsva.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        match = matchers.hex8.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex6.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        match = matchers.hex4.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            a: convertHexToDecimal(match[4] + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex3.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = (
        /** @class */
        function() {
          function TinyColor2(color, opts) {
            if (color === void 0) {
              color = "";
            }
            if (opts === void 0) {
              opts = {};
            }
            var _a2;
            if (color instanceof TinyColor2) {
              return color;
            }
            if (typeof color === "number") {
              color = numberInputToObject(color);
            }
            this.originalInput = color;
            var rgb = inputToRGB(color);
            this.originalInput = color;
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
            this.a = rgb.a;
            this.roundA = Math.round(100 * this.a) / 100;
            this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
            this.gradientType = opts.gradientType;
            if (this.r < 1) {
              this.r = Math.round(this.r);
            }
            if (this.g < 1) {
              this.g = Math.round(this.g);
            }
            if (this.b < 1) {
              this.b = Math.round(this.b);
            }
            this.isValid = rgb.ok;
          }
          TinyColor2.prototype.isDark = function() {
            return this.getBrightness() < 128;
          };
          TinyColor2.prototype.isLight = function() {
            return !this.isDark();
          };
          TinyColor2.prototype.getBrightness = function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          };
          TinyColor2.prototype.getLuminance = function() {
            var rgb = this.toRgb();
            var R2;
            var G2;
            var B2;
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R2 = RsRGB / 12.92;
            } else {
              R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G2 = GsRGB / 12.92;
            } else {
              G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B2 = BsRGB / 12.92;
            } else {
              B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
          };
          TinyColor2.prototype.getAlpha = function() {
            return this.a;
          };
          TinyColor2.prototype.setAlpha = function(alpha) {
            this.a = boundAlpha(alpha);
            this.roundA = Math.round(100 * this.a) / 100;
            return this;
          };
          TinyColor2.prototype.isMonochrome = function() {
            var s2 = this.toHsl().s;
            return s2 === 0;
          };
          TinyColor2.prototype.toHsv = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
          };
          TinyColor2.prototype.toHsvString = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            var h2 = Math.round(hsv.h * 360);
            var s2 = Math.round(hsv.s * 100);
            var v2 = Math.round(hsv.v * 100);
            return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHsl = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
          };
          TinyColor2.prototype.toHslString = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            var h2 = Math.round(hsl.h * 360);
            var s2 = Math.round(hsl.s * 100);
            var l2 = Math.round(hsl.l * 100);
            return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHex = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return rgbToHex(this.r, this.g, this.b, allow3Char);
          };
          TinyColor2.prototype.toHexString = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return "#" + this.toHex(allow3Char);
          };
          TinyColor2.prototype.toHex8 = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
          };
          TinyColor2.prototype.toHex8String = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return "#" + this.toHex8(allow4Char);
          };
          TinyColor2.prototype.toHexShortString = function(allowShortChar) {
            if (allowShortChar === void 0) {
              allowShortChar = false;
            }
            return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
          };
          TinyColor2.prototype.toRgb = function() {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toRgbString = function() {
            var r2 = Math.round(this.r);
            var g2 = Math.round(this.g);
            var b2 = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toPercentageRgb = function() {
            var fmt = function(x2) {
              return "".concat(Math.round(bound01(x2, 255) * 100), "%");
            };
            return {
              r: fmt(this.r),
              g: fmt(this.g),
              b: fmt(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toPercentageRgbString = function() {
            var rnd = function(x2) {
              return Math.round(bound01(x2, 255) * 100);
            };
            return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toName = function() {
            if (this.a === 0) {
              return "transparent";
            }
            if (this.a < 1) {
              return false;
            }
            var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
            for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
              var _b = _a2[_i], key = _b[0], value = _b[1];
              if (hex === value) {
                return key;
              }
            }
            return false;
          };
          TinyColor2.prototype.toString = function(format2) {
            var formatSet = Boolean(format2);
            format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
            var formattedString = false;
            var hasAlpha = this.a < 1 && this.a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
            if (needsAlphaFormat) {
              if (format2 === "name" && this.a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format2 === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format2 === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format2 === "hex" || format2 === "hex6") {
              formattedString = this.toHexString();
            }
            if (format2 === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format2 === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format2 === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format2 === "name") {
              formattedString = this.toName();
            }
            if (format2 === "hsl") {
              formattedString = this.toHslString();
            }
            if (format2 === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          };
          TinyColor2.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          };
          TinyColor2.prototype.clone = function() {
            return new TinyColor2(this.toString());
          };
          TinyColor2.prototype.lighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.brighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var rgb = this.toRgb();
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
            return new TinyColor2(rgb);
          };
          TinyColor2.prototype.darken = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.tint = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("white", amount);
          };
          TinyColor2.prototype.shade = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("black", amount);
          };
          TinyColor2.prototype.desaturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.saturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.greyscale = function() {
            return this.desaturate(100);
          };
          TinyColor2.prototype.spin = function(amount) {
            var hsl = this.toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.mix = function(color, amount) {
            if (amount === void 0) {
              amount = 50;
            }
            var rgb1 = this.toRgb();
            var rgb2 = new TinyColor2(color).toRgb();
            var p = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p + rgb1.r,
              g: (rgb2.g - rgb1.g) * p + rgb1.g,
              b: (rgb2.b - rgb1.b) * p + rgb1.b,
              a: (rgb2.a - rgb1.a) * p + rgb1.a
            };
            return new TinyColor2(rgba);
          };
          TinyColor2.prototype.analogous = function(results, slices) {
            if (results === void 0) {
              results = 6;
            }
            if (slices === void 0) {
              slices = 30;
            }
            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(new TinyColor2(hsl));
            }
            return ret;
          };
          TinyColor2.prototype.complement = function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.monochromatic = function(results) {
            if (results === void 0) {
              results = 6;
            }
            var hsv = this.toHsv();
            var h2 = hsv.h;
            var s2 = hsv.s;
            var v2 = hsv.v;
            var res = [];
            var modification = 1 / results;
            while (results--) {
              res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
              v2 = (v2 + modification) % 1;
            }
            return res;
          };
          TinyColor2.prototype.splitcomplement = function() {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            return [
              this,
              new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
              new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          };
          TinyColor2.prototype.onBackground = function(background) {
            var fg = this.toRgb();
            var bg = new TinyColor2(background).toRgb();
            var alpha = fg.a + bg.a * (1 - fg.a);
            return new TinyColor2({
              r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
              g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
              b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
              a: alpha
            });
          };
          TinyColor2.prototype.triad = function() {
            return this.polyad(3);
          };
          TinyColor2.prototype.tetrad = function() {
            return this.polyad(4);
          };
          TinyColor2.prototype.polyad = function(n2) {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            var result = [this];
            var increment = 360 / n2;
            for (var i2 = 1; i2 < n2; i2++) {
              result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
            }
            return result;
          };
          TinyColor2.prototype.equals = function(color) {
            return this.toRgbString() === new TinyColor2(color).toRgbString();
          };
          return TinyColor2;
        }()
      );
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getDefaultExportFromCjs(x2) {
        return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
      }
      function getAugmentedNamespace(n2) {
        if (n2.__esModule)
          return n2;
        var f2 = n2.default;
        if (typeof f2 == "function") {
          var a2 = function a3() {
            if (this instanceof a3) {
              return Reflect.construct(f2, arguments, this.constructor);
            }
            return f2.apply(this, arguments);
          };
          a2.prototype = f2.prototype;
        } else
          a2 = {};
        Object.defineProperty(a2, "__esModule", { value: true });
        Object.keys(n2).forEach(function(k2) {
          var d2 = Object.getOwnPropertyDescriptor(n2, k2);
          Object.defineProperty(a2, k2, d2.get ? d2 : {
            enumerable: true,
            get: function() {
              return n2[k2];
            }
          });
        });
        return a2;
      }
      const nodeList = /* @__PURE__ */ new Map();
      let startClick;
      if (isClient$1) {
        document.addEventListener("mousedown", (e2) => startClick = e2);
        document.addEventListener("mouseup", (e2) => {
          for (const handlers of nodeList.values()) {
            for (const { documentHandler } of handlers) {
              documentHandler(e2, startClick);
            }
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (Array.isArray(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement$1(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers = nodeList.get(el);
          const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      };
      const checkboxProps = {
        modelValue: {
          type: [Number, String, Boolean],
          default: void 0
        },
        label: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
          type: String,
          default: void 0
        },
        trueLabel: {
          type: [String, Number],
          default: void 0
        },
        falseLabel: {
          type: [String, Number],
          default: void 0
        },
        id: {
          type: String,
          default: void 0
        },
        controls: {
          type: String,
          default: void 0
        },
        border: Boolean,
        size: useSizeProp,
        tabindex: [String, Number],
        validateEvent: {
          type: Boolean,
          default: true
        }
      };
      const checkboxEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString$2(val) || isNumber$1(val) || isBoolean$1(val),
        change: (val) => isString$2(val) || isNumber$1(val) || isBoolean$1(val)
      };
      const checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
      const useCheckboxDisabled = ({
        model,
        isChecked
      }) => {
        const checkboxGroup = vue.inject(checkboxGroupContextKey, void 0);
        const isLimitDisabled = vue.computed(() => {
          var _a2, _b;
          const max2 = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value;
          const min = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
          return !isUndefined(max2) && model.value.length >= max2 && !isChecked.value || !isUndefined(min) && model.value.length <= min && isChecked.value;
        });
        const isDisabled = useFormDisabled(vue.computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
        return {
          isDisabled,
          isLimitDisabled
        };
      };
      const useCheckboxEvent = (props, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      }) => {
        const checkboxGroup = vue.inject(checkboxGroupContextKey, void 0);
        const { formItem } = useFormItem();
        const { emit } = vue.getCurrentInstance();
        function getLabeledValue(value) {
          var _a2, _b;
          return value === props.trueLabel || value === true ? (_a2 = props.trueLabel) != null ? _a2 : true : (_b = props.falseLabel) != null ? _b : false;
        }
        function emitChangeEvent(checked, e2) {
          emit("change", getLabeledValue(checked), e2);
        }
        function handleChange(e2) {
          if (isLimitExceeded.value)
            return;
          const target = e2.target;
          emit("change", getLabeledValue(target.checked), e2);
        }
        async function onClickRoot(e2) {
          if (isLimitExceeded.value)
            return;
          if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
            const eventTargets = e2.composedPath();
            const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
            if (!hasLabel) {
              model.value = getLabeledValue([false, props.falseLabel].includes(model.value));
              await vue.nextTick();
              emitChangeEvent(model.value, e2);
            }
          }
        }
        const validateEvent = vue.computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent);
        vue.watch(() => props.modelValue, () => {
          if (validateEvent.value) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return {
          handleChange,
          onClickRoot
        };
      };
      const useCheckboxModel = (props) => {
        const selfModel = vue.ref(false);
        const { emit } = vue.getCurrentInstance();
        const checkboxGroup = vue.inject(checkboxGroupContextKey, void 0);
        const isGroup = vue.computed(() => isUndefined(checkboxGroup) === false);
        const isLimitExceeded = vue.ref(false);
        const model = vue.computed({
          get() {
            var _a2, _b;
            return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props.modelValue) != null ? _b : selfModel.value;
          },
          set(val) {
            var _a2, _b;
            if (isGroup.value && isArray$6(val)) {
              isLimitExceeded.value = ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value) && val.length > model.value.length;
              isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
            } else {
              emit(UPDATE_MODEL_EVENT, val);
              selfModel.value = val;
            }
          }
        });
        return {
          model,
          isGroup,
          isLimitExceeded
        };
      };
      const useCheckboxStatus = (props, slots, { model }) => {
        const checkboxGroup = vue.inject(checkboxGroupContextKey, void 0);
        const isFocused = vue.ref(false);
        const isChecked = vue.computed(() => {
          const value = model.value;
          if (isBoolean$1(value)) {
            return value;
          } else if (isArray$6(value)) {
            if (isObject$3(props.label)) {
              return value.map(vue.toRaw).some((o2) => isEqual(o2, props.label));
            } else {
              return value.map(vue.toRaw).includes(props.label);
            }
          } else if (value !== null && value !== void 0) {
            return value === props.trueLabel;
          } else {
            return !!value;
          }
        });
        const checkboxButtonSize = useFormSize(vue.computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }), {
          prop: true
        });
        const checkboxSize = useFormSize(vue.computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }));
        const hasOwnLabel = vue.computed(() => {
          return !!slots.default || !isNil(props.label);
        });
        return {
          checkboxButtonSize,
          isChecked,
          isFocused,
          checkboxSize,
          hasOwnLabel
        };
      };
      const setStoreValue = (props, { model }) => {
        function addToStore() {
          if (isArray$6(model.value) && !model.value.includes(props.label)) {
            model.value.push(props.label);
          } else {
            model.value = props.trueLabel || true;
          }
        }
        props.checked && addToStore();
      };
      const useCheckbox = (props, slots) => {
        const { formItem: elFormItem } = useFormItem();
        const { model, isGroup, isLimitExceeded } = useCheckboxModel(props);
        const {
          isFocused,
          isChecked,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel
        } = useCheckboxStatus(props, slots, { model });
        const { isDisabled } = useCheckboxDisabled({ model, isChecked });
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: elFormItem,
          disableIdGeneration: hasOwnLabel,
          disableIdManagement: isGroup
        });
        const { handleChange, onClickRoot } = useCheckboxEvent(props, {
          model,
          isLimitExceeded,
          hasOwnLabel,
          isDisabled,
          isLabeledByFormItem
        });
        setStoreValue(props, { model });
        return {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          model,
          handleChange,
          onClickRoot
        };
      };
      const _hoisted_1$a = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_2$8 = ["id", "indeterminate", "disabled", "value", "name", "tabindex"];
      const __default__$7 = vue.defineComponent({
        name: "ElCheckbox"
      });
      const _sfc_main$h = /* @__PURE__ */ vue.defineComponent({
        ...__default__$7,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = vue.useSlots();
          const {
            inputId,
            isLabeledByFormItem,
            isChecked,
            isDisabled,
            isFocused,
            checkboxSize,
            hasOwnLabel,
            model,
            handleChange,
            onClickRoot
          } = useCheckbox(props, slots);
          const ns = useNamespace("checkbox");
          const compKls = vue.computed(() => {
            return [
              ns.b(),
              ns.m(checkboxSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("bordered", props.border),
              ns.is("checked", isChecked.value)
            ];
          });
          const spanKls = vue.computed(() => {
            return [
              ns.e("input"),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("indeterminate", props.indeterminate),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(!vue.unref(hasOwnLabel) && vue.unref(isLabeledByFormItem) ? "span" : "label"), {
              class: vue.normalizeClass(vue.unref(compKls)),
              "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
              onClick: vue.unref(onClickRoot)
            }, {
              default: vue.withCtx(() => [
                vue.createElementVNode("span", {
                  class: vue.normalizeClass(vue.unref(spanKls))
                }, [
                  _ctx.trueLabel || _ctx.falseLabel ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
                    key: 0,
                    id: vue.unref(inputId),
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(model) ? model.value = $event : null),
                    class: vue.normalizeClass(vue.unref(ns).e("original")),
                    type: "checkbox",
                    indeterminate: _ctx.indeterminate,
                    name: _ctx.name,
                    tabindex: _ctx.tabindex,
                    disabled: vue.unref(isDisabled),
                    "true-value": _ctx.trueLabel,
                    "false-value": _ctx.falseLabel,
                    onChange: _cache[1] || (_cache[1] = (...args) => vue.unref(handleChange) && vue.unref(handleChange)(...args)),
                    onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                    onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
                    onClick: _cache[4] || (_cache[4] = vue.withModifiers(() => {
                    }, ["stop"]))
                  }, null, 42, _hoisted_1$a)), [
                    [vue.vModelCheckbox, vue.unref(model)]
                  ]) : vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
                    key: 1,
                    id: vue.unref(inputId),
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => vue.isRef(model) ? model.value = $event : null),
                    class: vue.normalizeClass(vue.unref(ns).e("original")),
                    type: "checkbox",
                    indeterminate: _ctx.indeterminate,
                    disabled: vue.unref(isDisabled),
                    value: _ctx.label,
                    name: _ctx.name,
                    tabindex: _ctx.tabindex,
                    onChange: _cache[6] || (_cache[6] = (...args) => vue.unref(handleChange) && vue.unref(handleChange)(...args)),
                    onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
                    onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
                    onClick: _cache[9] || (_cache[9] = vue.withModifiers(() => {
                    }, ["stop"]))
                  }, null, 42, _hoisted_2$8)), [
                    [vue.vModelCheckbox, vue.unref(model)]
                  ]),
                  vue.createElementVNode("span", {
                    class: vue.normalizeClass(vue.unref(ns).e("inner"))
                  }, null, 2)
                ], 2),
                vue.unref(hasOwnLabel) ? (vue.openBlock(), vue.createElementBlock("span", {
                  key: 0,
                  class: vue.normalizeClass(vue.unref(ns).e("label"))
                }, [
                  vue.renderSlot(_ctx.$slots, "default"),
                  !_ctx.$slots.default ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                    vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)
                  ], 64)) : vue.createCommentVNode("v-if", true)
                ], 2)) : vue.createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["class", "aria-controls", "onClick"]);
          };
        }
      });
      var Checkbox = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "checkbox.vue"]]);
      const _hoisted_1$9 = ["name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_2$7 = ["name", "tabindex", "disabled", "value"];
      const __default__$6 = vue.defineComponent({
        name: "ElCheckboxButton"
      });
      const _sfc_main$g = /* @__PURE__ */ vue.defineComponent({
        ...__default__$6,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = vue.useSlots();
          const {
            isFocused,
            isChecked,
            isDisabled,
            checkboxButtonSize,
            model,
            handleChange
          } = useCheckbox(props, slots);
          const checkboxGroup = vue.inject(checkboxGroupContextKey, void 0);
          const ns = useNamespace("checkbox");
          const activeStyle = vue.computed(() => {
            var _a2, _b, _c, _d;
            const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
            return {
              backgroundColor: fillValue,
              borderColor: fillValue,
              color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
              boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
            };
          });
          const labelKls = vue.computed(() => {
            return [
              ns.b("button"),
              ns.bm("button", checkboxButtonSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("label", {
              class: vue.normalizeClass(vue.unref(labelKls))
            }, [
              _ctx.trueLabel || _ctx.falseLabel ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.isRef(model) ? model.value = $event : null),
                class: vue.normalizeClass(vue.unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: vue.unref(isDisabled),
                "true-value": _ctx.trueLabel,
                "false-value": _ctx.falseLabel,
                onChange: _cache[1] || (_cache[1] = (...args) => vue.unref(handleChange) && vue.unref(handleChange)(...args)),
                onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
                onClick: _cache[4] || (_cache[4] = vue.withModifiers(() => {
                }, ["stop"]))
              }, null, 42, _hoisted_1$9)), [
                [vue.vModelCheckbox, vue.unref(model)]
              ]) : vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => vue.isRef(model) ? model.value = $event : null),
                class: vue.normalizeClass(vue.unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: vue.unref(isDisabled),
                value: _ctx.label,
                onChange: _cache[6] || (_cache[6] = (...args) => vue.unref(handleChange) && vue.unref(handleChange)(...args)),
                onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
                onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
                onClick: _cache[9] || (_cache[9] = vue.withModifiers(() => {
                }, ["stop"]))
              }, null, 42, _hoisted_2$7)), [
                [vue.vModelCheckbox, vue.unref(model)]
              ]),
              _ctx.$slots.default || _ctx.label ? (vue.openBlock(), vue.createElementBlock("span", {
                key: 2,
                class: vue.normalizeClass(vue.unref(ns).be("button", "inner")),
                style: vue.normalizeStyle(vue.unref(isChecked) ? vue.unref(activeStyle) : void 0)
              }, [
                vue.renderSlot(_ctx.$slots, "default", {}, () => [
                  vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)
                ])
              ], 6)) : vue.createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var CheckboxButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "checkbox-button.vue"]]);
      const checkboxGroupProps = buildProps({
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        disabled: Boolean,
        min: Number,
        max: Number,
        size: useSizeProp,
        label: String,
        fill: String,
        textColor: String,
        tag: {
          type: String,
          default: "div"
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const checkboxGroupEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isArray$6(val),
        change: (val) => isArray$6(val)
      };
      const __default__$5 = vue.defineComponent({
        name: "ElCheckboxGroup"
      });
      const _sfc_main$f = /* @__PURE__ */ vue.defineComponent({
        ...__default__$5,
        props: checkboxGroupProps,
        emits: checkboxGroupEmits,
        setup(__props, { emit }) {
          const props = __props;
          const ns = useNamespace("checkbox");
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const changeEvent = async (value) => {
            emit(UPDATE_MODEL_EVENT, value);
            await vue.nextTick();
            emit("change", value);
          };
          const modelValue = vue.computed({
            get() {
              return props.modelValue;
            },
            set(val) {
              changeEvent(val);
            }
          });
          vue.provide(checkboxGroupContextKey, {
            ...pick(vue.toRefs(props), [
              "size",
              "min",
              "max",
              "disabled",
              "validateEvent",
              "fill",
              "textColor"
            ]),
            modelValue,
            changeEvent
          });
          vue.watch(() => props.modelValue, () => {
            if (props.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            var _a2;
            return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.tag), {
              id: vue.unref(groupId),
              class: vue.normalizeClass(vue.unref(ns).b("group")),
              role: "group",
              "aria-label": !vue.unref(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
              "aria-labelledby": vue.unref(isLabeledByFormItem) ? (_a2 = vue.unref(formItem)) == null ? void 0 : _a2.labelId : void 0
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var CheckboxGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__file", "checkbox-group.vue"]]);
      const ElCheckbox = withInstall$1(Checkbox, {
        CheckboxButton,
        CheckboxGroup
      });
      withNoopInstall(CheckboxButton);
      const ElCheckboxGroup = withNoopInstall(CheckboxGroup);
      const tagProps = buildProps({
        type: {
          type: String,
          values: ["success", "info", "warning", "danger", ""],
          default: ""
        },
        closable: Boolean,
        disableTransitions: Boolean,
        hit: Boolean,
        color: {
          type: String,
          default: ""
        },
        size: {
          type: String,
          values: componentSizes,
          default: ""
        },
        effect: {
          type: String,
          values: ["dark", "light", "plain"],
          default: "light"
        },
        round: Boolean
      });
      const tagEmits = {
        close: (evt) => evt instanceof MouseEvent,
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$4 = vue.defineComponent({
        name: "ElTag"
      });
      const _sfc_main$e = /* @__PURE__ */ vue.defineComponent({
        ...__default__$4,
        props: tagProps,
        emits: tagEmits,
        setup(__props, { emit }) {
          const props = __props;
          const tagSize = useFormSize();
          const ns = useNamespace("tag");
          const containerKls = vue.computed(() => {
            const { type: type3, hit, effect, closable, round } = props;
            return [
              ns.b(),
              ns.is("closable", closable),
              ns.m(type3),
              ns.m(tagSize.value),
              ns.m(effect),
              ns.is("hit", hit),
              ns.is("round", round)
            ];
          });
          const handleClose = (event) => {
            emit("close", event);
          };
          const handleClick = (event) => {
            emit("click", event);
          };
          return (_ctx, _cache) => {
            return _ctx.disableTransitions ? (vue.openBlock(), vue.createElementBlock("span", {
              key: 0,
              class: vue.normalizeClass(vue.unref(containerKls)),
              style: vue.normalizeStyle({ backgroundColor: _ctx.color }),
              onClick: handleClick
            }, [
              vue.createElementVNode("span", {
                class: vue.normalizeClass(vue.unref(ns).e("content"))
              }, [
                vue.renderSlot(_ctx.$slots, "default")
              ], 2),
              _ctx.closable ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).e("close")),
                onClick: vue.withModifiers(handleClose, ["stop"])
              }, {
                default: vue.withCtx(() => [
                  vue.createVNode(vue.unref(close_default))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : vue.createCommentVNode("v-if", true)
            ], 6)) : (vue.openBlock(), vue.createBlock(vue.Transition, {
              key: 1,
              name: `${vue.unref(ns).namespace.value}-zoom-in-center`,
              appear: ""
            }, {
              default: vue.withCtx(() => [
                vue.createElementVNode("span", {
                  class: vue.normalizeClass(vue.unref(containerKls)),
                  style: vue.normalizeStyle({ backgroundColor: _ctx.color }),
                  onClick: handleClick
                }, [
                  vue.createElementVNode("span", {
                    class: vue.normalizeClass(vue.unref(ns).e("content"))
                  }, [
                    vue.renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.closable ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                    key: 0,
                    class: vue.normalizeClass(vue.unref(ns).e("close")),
                    onClick: vue.withModifiers(handleClose, ["stop"])
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(close_default))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : vue.createCommentVNode("v-if", true)
                ], 6)
              ]),
              _: 3
            }, 8, ["name"]));
          };
        }
      });
      var Tag = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__file", "tag.vue"]]);
      const ElTag = withInstall$1(Tag);
      const overlayProps = buildProps({
        mask: {
          type: Boolean,
          default: true
        },
        customMaskEvent: {
          type: Boolean,
          default: false
        },
        overlayClass: {
          type: definePropType([
            String,
            Array,
            Object
          ])
        },
        zIndex: {
          type: definePropType([String, Number])
        }
      });
      const overlayEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const BLOCK = "overlay";
      var Overlay = vue.defineComponent({
        name: "ElOverlay",
        props: overlayProps,
        emits: overlayEmits,
        setup(props, { slots, emit }) {
          const ns = useNamespace(BLOCK);
          const onMaskClick = (e2) => {
            emit("click", e2);
          };
          const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
          return () => {
            return props.mask ? vue.createVNode("div", {
              class: [ns.b(), props.overlayClass],
              style: {
                zIndex: props.zIndex
              },
              onClick,
              onMousedown,
              onMouseup
            }, [vue.renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : vue.h("div", {
              class: props.overlayClass,
              style: {
                zIndex: props.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
              }
            }, [vue.renderSlot(slots, "default")]);
          };
        }
      });
      const ElOverlay = Overlay;
      const dialogInjectionKey = Symbol("dialogInjectionKey");
      const dialogContentProps = buildProps({
        center: Boolean,
        alignCenter: Boolean,
        closeIcon: {
          type: iconPropType
        },
        customClass: {
          type: String,
          default: ""
        },
        draggable: Boolean,
        fullscreen: Boolean,
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        ariaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogContentEmits = {
        close: () => true
      };
      const _hoisted_1$8 = ["aria-level"];
      const _hoisted_2$6 = ["aria-label"];
      const _hoisted_3$5 = ["id"];
      const __default__$3 = vue.defineComponent({ name: "ElDialogContent" });
      const _sfc_main$d = /* @__PURE__ */ vue.defineComponent({
        ...__default__$3,
        props: dialogContentProps,
        emits: dialogContentEmits,
        setup(__props) {
          const props = __props;
          const { t: t2 } = useLocale();
          const { Close } = CloseComponents;
          const { dialogRef, headerRef, bodyId, ns, style } = vue.inject(dialogInjectionKey);
          const { focusTrapRef } = vue.inject(FOCUS_TRAP_INJECTION_KEY);
          const dialogKls = vue.computed(() => [
            ns.b(),
            ns.is("fullscreen", props.fullscreen),
            ns.is("draggable", props.draggable),
            ns.is("align-center", props.alignCenter),
            { [ns.m("center")]: props.center },
            props.customClass
          ]);
          const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
          const draggable = vue.computed(() => props.draggable);
          useDraggable(dialogRef, headerRef, draggable);
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              ref: vue.unref(composedDialogRef),
              class: vue.normalizeClass(vue.unref(dialogKls)),
              style: vue.normalizeStyle(vue.unref(style)),
              tabindex: "-1"
            }, [
              vue.createElementVNode("header", {
                ref_key: "headerRef",
                ref: headerRef,
                class: vue.normalizeClass(vue.unref(ns).e("header"))
              }, [
                vue.renderSlot(_ctx.$slots, "header", {}, () => [
                  vue.createElementVNode("span", {
                    role: "heading",
                    "aria-level": _ctx.ariaLevel,
                    class: vue.normalizeClass(vue.unref(ns).e("title"))
                  }, vue.toDisplayString(_ctx.title), 11, _hoisted_1$8)
                ]),
                _ctx.showClose ? (vue.openBlock(), vue.createElementBlock("button", {
                  key: 0,
                  "aria-label": vue.unref(t2)("el.dialog.close"),
                  class: vue.normalizeClass(vue.unref(ns).e("headerbtn")),
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
                }, [
                  vue.createVNode(vue.unref(ElIcon), {
                    class: vue.normalizeClass(vue.unref(ns).e("close"))
                  }, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.closeIcon || vue.unref(Close))))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, _hoisted_2$6)) : vue.createCommentVNode("v-if", true)
              ], 2),
              vue.createElementVNode("div", {
                id: vue.unref(bodyId),
                class: vue.normalizeClass(vue.unref(ns).e("body"))
              }, [
                vue.renderSlot(_ctx.$slots, "default")
              ], 10, _hoisted_3$5),
              _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock("footer", {
                key: 0,
                class: vue.normalizeClass(vue.unref(ns).e("footer"))
              }, [
                vue.renderSlot(_ctx.$slots, "footer")
              ], 2)) : vue.createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var ElDialogContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__file", "dialog-content.vue"]]);
      const dialogProps = buildProps({
        ...dialogContentProps,
        appendToBody: Boolean,
        appendTo: {
          type: definePropType(String),
          default: "body"
        },
        beforeClose: {
          type: definePropType(Function)
        },
        destroyOnClose: Boolean,
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        modal: {
          type: Boolean,
          default: true
        },
        openDelay: {
          type: Number,
          default: 0
        },
        closeDelay: {
          type: Number,
          default: 0
        },
        top: {
          type: String
        },
        modelValue: Boolean,
        modalClass: String,
        width: {
          type: [String, Number]
        },
        zIndex: {
          type: Number
        },
        trapFocus: {
          type: Boolean,
          default: false
        },
        headerAriaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogEmits = {
        open: () => true,
        opened: () => true,
        close: () => true,
        closed: () => true,
        [UPDATE_MODEL_EVENT]: (value) => isBoolean$1(value),
        openAutoFocus: () => true,
        closeAutoFocus: () => true
      };
      const useDialog = (props, targetRef) => {
        var _a2;
        const instance = vue.getCurrentInstance();
        const emit = instance.emit;
        const { nextZIndex } = useZIndex();
        let lastPosition = "";
        const titleId = useId();
        const bodyId = useId();
        const visible = vue.ref(false);
        const closed = vue.ref(false);
        const rendered = vue.ref(false);
        const zIndex2 = vue.ref((_a2 = props.zIndex) != null ? _a2 : nextZIndex());
        let openTimer = void 0;
        let closeTimer = void 0;
        const namespace = useGlobalConfig("namespace", defaultNamespace);
        const style = vue.computed(() => {
          const style2 = {};
          const varPrefix = `--${namespace.value}-dialog`;
          if (!props.fullscreen) {
            if (props.top) {
              style2[`${varPrefix}-margin-top`] = props.top;
            }
            if (props.width) {
              style2[`${varPrefix}-width`] = addUnit(props.width);
            }
          }
          return style2;
        });
        const overlayDialogStyle = vue.computed(() => {
          if (props.alignCenter) {
            return { display: "flex" };
          }
          return {};
        });
        function afterEnter() {
          emit("opened");
        }
        function afterLeave() {
          emit("closed");
          emit(UPDATE_MODEL_EVENT, false);
          if (props.destroyOnClose) {
            rendered.value = false;
          }
        }
        function beforeLeave() {
          emit("close");
        }
        function open() {
          closeTimer == null ? void 0 : closeTimer();
          openTimer == null ? void 0 : openTimer();
          if (props.openDelay && props.openDelay > 0) {
            ({ stop: openTimer } = useTimeoutFn$1(() => doOpen(), props.openDelay));
          } else {
            doOpen();
          }
        }
        function close2() {
          openTimer == null ? void 0 : openTimer();
          closeTimer == null ? void 0 : closeTimer();
          if (props.closeDelay && props.closeDelay > 0) {
            ({ stop: closeTimer } = useTimeoutFn$1(() => doClose(), props.closeDelay));
          } else {
            doClose();
          }
        }
        function handleClose() {
          function hide(shouldCancel) {
            if (shouldCancel)
              return;
            closed.value = true;
            visible.value = false;
          }
          if (props.beforeClose) {
            props.beforeClose(hide);
          } else {
            close2();
          }
        }
        function onModalClick() {
          if (props.closeOnClickModal) {
            handleClose();
          }
        }
        function doOpen() {
          if (!isClient$1)
            return;
          visible.value = true;
        }
        function doClose() {
          visible.value = false;
        }
        function onOpenAutoFocus() {
          emit("openAutoFocus");
        }
        function onCloseAutoFocus() {
          emit("closeAutoFocus");
        }
        function onFocusoutPrevented(event) {
          var _a22;
          if (((_a22 = event.detail) == null ? void 0 : _a22.focusReason) === "pointer") {
            event.preventDefault();
          }
        }
        if (props.lockScroll) {
          useLockscreen(visible);
        }
        function onCloseRequested() {
          if (props.closeOnPressEscape) {
            handleClose();
          }
        }
        vue.watch(() => props.modelValue, (val) => {
          if (val) {
            closed.value = false;
            open();
            rendered.value = true;
            zIndex2.value = isUndefined$1(props.zIndex) ? nextZIndex() : zIndex2.value++;
            vue.nextTick(() => {
              emit("open");
              if (targetRef.value) {
                targetRef.value.scrollTop = 0;
              }
            });
          } else {
            if (visible.value) {
              close2();
            }
          }
        });
        vue.watch(() => props.fullscreen, (val) => {
          if (!targetRef.value)
            return;
          if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
          } else {
            targetRef.value.style.transform = lastPosition;
          }
        });
        vue.onMounted(() => {
          if (props.modelValue) {
            visible.value = true;
            rendered.value = true;
            open();
          }
        });
        return {
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          close: close2,
          doClose,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented,
          titleId,
          bodyId,
          closed,
          style,
          overlayDialogStyle,
          rendered,
          visible,
          zIndex: zIndex2
        };
      };
      const _hoisted_1$7 = ["aria-label", "aria-labelledby", "aria-describedby"];
      const __default__$2 = vue.defineComponent({
        name: "ElDialog",
        inheritAttrs: false
      });
      const _sfc_main$c = /* @__PURE__ */ vue.defineComponent({
        ...__default__$2,
        props: dialogProps,
        emits: dialogEmits,
        setup(__props, { expose }) {
          const props = __props;
          const slots = vue.useSlots();
          useDeprecated({
            scope: "el-dialog",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#slots"
          }, vue.computed(() => !!slots.title));
          useDeprecated({
            scope: "el-dialog",
            from: "custom-class",
            replacement: "class",
            version: "2.3.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#attributes",
            type: "Attribute"
          }, vue.computed(() => !!props.customClass));
          const ns = useNamespace("dialog");
          const dialogRef = vue.ref();
          const headerRef = vue.ref();
          const dialogContentRef = vue.ref();
          const {
            visible,
            titleId,
            bodyId,
            style,
            overlayDialogStyle,
            rendered,
            zIndex: zIndex2,
            afterEnter,
            afterLeave,
            beforeLeave,
            handleClose,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onCloseRequested,
            onFocusoutPrevented
          } = useDialog(props, dialogRef);
          vue.provide(dialogInjectionKey, {
            dialogRef,
            headerRef,
            bodyId,
            ns,
            rendered,
            style
          });
          const overlayEvent = useSameTarget(onModalClick);
          const draggable = vue.computed(() => props.draggable && !props.fullscreen);
          expose({
            visible,
            dialogContentRef
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.Teleport, {
              to: _ctx.appendTo,
              disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
            }, [
              vue.createVNode(vue.Transition, {
                name: "dialog-fade",
                onAfterEnter: vue.unref(afterEnter),
                onAfterLeave: vue.unref(afterLeave),
                onBeforeLeave: vue.unref(beforeLeave),
                persisted: ""
              }, {
                default: vue.withCtx(() => [
                  vue.withDirectives(vue.createVNode(vue.unref(ElOverlay), {
                    "custom-mask-event": "",
                    mask: _ctx.modal,
                    "overlay-class": _ctx.modalClass,
                    "z-index": vue.unref(zIndex2)
                  }, {
                    default: vue.withCtx(() => [
                      vue.createElementVNode("div", {
                        role: "dialog",
                        "aria-modal": "true",
                        "aria-label": _ctx.title || void 0,
                        "aria-labelledby": !_ctx.title ? vue.unref(titleId) : void 0,
                        "aria-describedby": vue.unref(bodyId),
                        class: vue.normalizeClass(`${vue.unref(ns).namespace.value}-overlay-dialog`),
                        style: vue.normalizeStyle(vue.unref(overlayDialogStyle)),
                        onClick: _cache[0] || (_cache[0] = (...args) => vue.unref(overlayEvent).onClick && vue.unref(overlayEvent).onClick(...args)),
                        onMousedown: _cache[1] || (_cache[1] = (...args) => vue.unref(overlayEvent).onMousedown && vue.unref(overlayEvent).onMousedown(...args)),
                        onMouseup: _cache[2] || (_cache[2] = (...args) => vue.unref(overlayEvent).onMouseup && vue.unref(overlayEvent).onMouseup(...args))
                      }, [
                        vue.createVNode(vue.unref(ElFocusTrap), {
                          loop: "",
                          trapped: vue.unref(visible),
                          "focus-start-el": "container",
                          onFocusAfterTrapped: vue.unref(onOpenAutoFocus),
                          onFocusAfterReleased: vue.unref(onCloseAutoFocus),
                          onFocusoutPrevented: vue.unref(onFocusoutPrevented),
                          onReleaseRequested: vue.unref(onCloseRequested)
                        }, {
                          default: vue.withCtx(() => [
                            vue.unref(rendered) ? (vue.openBlock(), vue.createBlock(ElDialogContent, vue.mergeProps({
                              key: 0,
                              ref_key: "dialogContentRef",
                              ref: dialogContentRef
                            }, _ctx.$attrs, {
                              "custom-class": _ctx.customClass,
                              center: _ctx.center,
                              "align-center": _ctx.alignCenter,
                              "close-icon": _ctx.closeIcon,
                              draggable: vue.unref(draggable),
                              fullscreen: _ctx.fullscreen,
                              "show-close": _ctx.showClose,
                              title: _ctx.title,
                              "aria-level": _ctx.headerAriaLevel,
                              onClose: vue.unref(handleClose)
                            }), vue.createSlots({
                              header: vue.withCtx(() => [
                                !_ctx.$slots.title ? vue.renderSlot(_ctx.$slots, "header", {
                                  key: 0,
                                  close: vue.unref(handleClose),
                                  titleId: vue.unref(titleId),
                                  titleClass: vue.unref(ns).e("title")
                                }) : vue.renderSlot(_ctx.$slots, "title", { key: 1 })
                              ]),
                              default: vue.withCtx(() => [
                                vue.renderSlot(_ctx.$slots, "default")
                              ]),
                              _: 2
                            }, [
                              _ctx.$slots.footer ? {
                                name: "footer",
                                fn: vue.withCtx(() => [
                                  vue.renderSlot(_ctx.$slots, "footer")
                                ])
                              } : void 0
                            ]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : vue.createCommentVNode("v-if", true)
                          ]),
                          _: 3
                        }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                      ], 46, _hoisted_1$7)
                    ]),
                    _: 3
                  }, 8, ["mask", "overlay-class", "z-index"]), [
                    [vue.vShow, vue.unref(visible)]
                  ])
                ]),
                _: 3
              }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
            ], 8, ["to", "disabled"]);
          };
        }
      });
      var Dialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__file", "dialog.vue"]]);
      const ElDialog = withInstall$1(Dialog);
      const _sfc_main$b = /* @__PURE__ */ vue.defineComponent({
        inheritAttrs: false
      });
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.renderSlot(_ctx.$slots, "default");
      }
      var Collection = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["render", _sfc_render$5], ["__file", "collection.vue"]]);
      const _sfc_main$a = /* @__PURE__ */ vue.defineComponent({
        name: "ElCollectionItem",
        inheritAttrs: false
      });
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.renderSlot(_ctx.$slots, "default");
      }
      var CollectionItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render$4], ["__file", "collection-item.vue"]]);
      const COLLECTION_ITEM_SIGN = `data-el-collection-item`;
      const createCollectionWithScope = (name) => {
        const COLLECTION_NAME = `El${name}Collection`;
        const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
        const COLLECTION_INJECTION_KEY = Symbol(COLLECTION_NAME);
        const COLLECTION_ITEM_INJECTION_KEY = Symbol(COLLECTION_ITEM_NAME);
        const ElCollection = {
          ...Collection,
          name: COLLECTION_NAME,
          setup() {
            const collectionRef = vue.ref(null);
            const itemMap = /* @__PURE__ */ new Map();
            const getItems = () => {
              const collectionEl = vue.unref(collectionRef);
              if (!collectionEl)
                return [];
              const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
              const items = [...itemMap.values()];
              return items.sort((a2, b2) => orderedNodes.indexOf(a2.ref) - orderedNodes.indexOf(b2.ref));
            };
            vue.provide(COLLECTION_INJECTION_KEY, {
              itemMap,
              getItems,
              collectionRef
            });
          }
        };
        const ElCollectionItem = {
          ...CollectionItem,
          name: COLLECTION_ITEM_NAME,
          setup(_2, { attrs }) {
            const collectionItemRef = vue.ref(null);
            const collectionInjection = vue.inject(COLLECTION_INJECTION_KEY, void 0);
            vue.provide(COLLECTION_ITEM_INJECTION_KEY, {
              collectionItemRef
            });
            vue.onMounted(() => {
              const collectionItemEl = vue.unref(collectionItemRef);
              if (collectionItemEl) {
                collectionInjection.itemMap.set(collectionItemEl, {
                  ref: collectionItemEl,
                  ...attrs
                });
              }
            });
            vue.onBeforeUnmount(() => {
              const collectionItemEl = vue.unref(collectionItemRef);
              collectionInjection.itemMap.delete(collectionItemEl);
            });
          }
        };
        return {
          COLLECTION_INJECTION_KEY,
          COLLECTION_ITEM_INJECTION_KEY,
          ElCollection,
          ElCollectionItem
        };
      };
      const dropdownProps = buildProps({
        trigger: useTooltipTriggerProps.trigger,
        effect: {
          ...useTooltipContentProps.effect,
          default: "light"
        },
        type: {
          type: definePropType(String)
        },
        placement: {
          type: definePropType(String),
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        id: String,
        size: {
          type: String,
          default: ""
        },
        splitButton: Boolean,
        hideOnClick: {
          type: Boolean,
          default: true
        },
        loop: {
          type: Boolean,
          default: true
        },
        showTimeout: {
          type: Number,
          default: 150
        },
        hideTimeout: {
          type: Number,
          default: 150
        },
        tabindex: {
          type: definePropType([Number, String]),
          default: 0
        },
        maxHeight: {
          type: definePropType([Number, String]),
          default: ""
        },
        popperClass: {
          type: String,
          default: ""
        },
        disabled: {
          type: Boolean,
          default: false
        },
        role: {
          type: String,
          default: "menu"
        },
        buttonProps: {
          type: definePropType(Object)
        },
        teleported: useTooltipContentProps.teleported
      });
      buildProps({
        command: {
          type: [Object, String, Number],
          default: () => ({})
        },
        disabled: Boolean,
        divided: Boolean,
        textValue: String,
        icon: {
          type: iconPropType
        }
      });
      buildProps({
        onKeydown: { type: definePropType(Function) }
      });
      createCollectionWithScope("Dropdown");
      const selectGroupKey = Symbol("ElSelectGroup");
      const selectKey = Symbol("ElSelect");
      function useOption(props, states) {
        const select = vue.inject(selectKey);
        const selectGroup = vue.inject(selectGroupKey, { disabled: false });
        const itemSelected = vue.computed(() => {
          if (!select.props.multiple) {
            return isEqual(props.value, select.props.modelValue);
          } else {
            return contains2(select.props.modelValue, props.value);
          }
        });
        const limitReached = vue.computed(() => {
          if (select.props.multiple) {
            const modelValue = select.props.modelValue || [];
            return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
          } else {
            return false;
          }
        });
        const currentLabel = vue.computed(() => {
          return props.label || (isObject$3(props.value) ? "" : props.value);
        });
        const currentValue = vue.computed(() => {
          return props.value || props.label || "";
        });
        const isDisabled = vue.computed(() => {
          return props.disabled || states.groupDisabled || limitReached.value;
        });
        const instance = vue.getCurrentInstance();
        const contains2 = (arr = [], target) => {
          if (!isObject$3(props.value)) {
            return arr && arr.includes(target);
          } else {
            const valueKey = select.props.valueKey;
            return arr && arr.some((item) => {
              return vue.toRaw(get(item, valueKey)) === get(target, valueKey);
            });
          }
        };
        const hoverItem = () => {
          if (!props.disabled && !selectGroup.disabled) {
            select.states.hoveringIndex = select.optionsArray.indexOf(instance.proxy);
          }
        };
        const updateOption = (query) => {
          const regexp = new RegExp(escapeStringRegexp(query), "i");
          states.visible = regexp.test(currentLabel.value) || props.created;
        };
        vue.watch(() => currentLabel.value, () => {
          if (!props.created && !select.props.remote)
            select.setSelected();
        });
        vue.watch(() => props.value, (val, oldVal) => {
          const { remote, valueKey } = select.props;
          if (!isEqual(val, oldVal)) {
            select.onOptionDestroy(oldVal, instance.proxy);
            select.onOptionCreate(instance.proxy);
          }
          if (!props.created && !remote) {
            if (valueKey && isObject$3(val) && isObject$3(oldVal) && val[valueKey] === oldVal[valueKey]) {
              return;
            }
            select.setSelected();
          }
        });
        vue.watch(() => selectGroup.disabled, () => {
          states.groupDisabled = selectGroup.disabled;
        }, { immediate: true });
        return {
          select,
          currentLabel,
          currentValue,
          itemSelected,
          isDisabled,
          hoverItem,
          updateOption
        };
      }
      const _sfc_main$9 = vue.defineComponent({
        name: "ElOption",
        componentName: "ElOption",
        props: {
          value: {
            required: true,
            type: [String, Number, Boolean, Object]
          },
          label: [String, Number],
          created: Boolean,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const id = useId();
          const containerKls = vue.computed(() => [
            ns.be("dropdown", "item"),
            ns.is("disabled", vue.unref(isDisabled)),
            ns.is("selected", vue.unref(itemSelected)),
            ns.is("hovering", vue.unref(hover))
          ]);
          const states = vue.reactive({
            index: -1,
            groupDisabled: false,
            visible: true,
            hover: false
          });
          const {
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption
          } = useOption(props, states);
          const { visible, hover } = vue.toRefs(states);
          const vm = vue.getCurrentInstance().proxy;
          select.onOptionCreate(vm);
          vue.onBeforeUnmount(() => {
            const key = vm.value;
            const { selected } = select.states;
            const selectedOptions = select.props.multiple ? selected : [selected];
            const doesSelected = selectedOptions.some((item) => {
              return item.value === vm.value;
            });
            vue.nextTick(() => {
              if (select.states.cachedOptions.get(key) === vm && !doesSelected) {
                select.states.cachedOptions.delete(key);
              }
            });
            select.onOptionDestroy(key, vm);
          });
          function selectOptionClick() {
            if (props.disabled !== true && states.groupDisabled !== true) {
              select.handleOptionSelect(vm);
            }
          }
          return {
            ns,
            id,
            containerKls,
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption,
            visible,
            hover,
            selectOptionClick,
            states
          };
        }
      });
      const _hoisted_1$6 = ["id", "aria-disabled", "aria-selected"];
      function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.withDirectives((vue.openBlock(), vue.createElementBlock("li", {
          id: _ctx.id,
          class: vue.normalizeClass(_ctx.containerKls),
          role: "option",
          "aria-disabled": _ctx.isDisabled || void 0,
          "aria-selected": _ctx.itemSelected,
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
          onClick: _cache[1] || (_cache[1] = vue.withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, () => [
            vue.createElementVNode("span", null, vue.toDisplayString(_ctx.currentLabel), 1)
          ])
        ], 42, _hoisted_1$6)), [
          [vue.vShow, _ctx.visible]
        ]);
      }
      var Option = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["render", _sfc_render$3], ["__file", "option.vue"]]);
      const _sfc_main$8 = vue.defineComponent({
        name: "ElSelectDropdown",
        componentName: "ElSelectDropdown",
        setup() {
          const select = vue.inject(selectKey);
          const ns = useNamespace("select");
          const popperClass = vue.computed(() => select.props.popperClass);
          const isMultiple = vue.computed(() => select.props.multiple);
          const isFitInputWidth = vue.computed(() => select.props.fitInputWidth);
          const minWidth = vue.ref("");
          function updateMinWidth() {
            var _a2;
            minWidth.value = `${(_a2 = select.selectRef) == null ? void 0 : _a2.offsetWidth}px`;
          }
          vue.onMounted(() => {
            updateMinWidth();
            useResizeObserver$1(select.selectRef, updateMinWidth);
          });
          return {
            ns,
            minWidth,
            popperClass,
            isMultiple,
            isFitInputWidth
          };
        }
      });
      function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.openBlock(), vue.createElementBlock("div", {
          class: vue.normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
          style: vue.normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
        }, [
          _ctx.$slots.header ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: vue.normalizeClass(_ctx.ns.be("dropdown", "header"))
          }, [
            vue.renderSlot(_ctx.$slots, "header")
          ], 2)) : vue.createCommentVNode("v-if", true),
          vue.renderSlot(_ctx.$slots, "default"),
          _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 1,
            class: vue.normalizeClass(_ctx.ns.be("dropdown", "footer"))
          }, [
            vue.renderSlot(_ctx.$slots, "footer")
          ], 2)) : vue.createCommentVNode("v-if", true)
        ], 6);
      }
      var ElSelectMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["render", _sfc_render$2], ["__file", "select-dropdown.vue"]]);
      function useInput(handleInput) {
        const isComposing = vue.ref(false);
        const handleCompositionStart = () => {
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          const text = event.target.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          if (isComposing.value) {
            isComposing.value = false;
            if (isFunction$2(handleInput)) {
              handleInput(event);
            }
          }
        };
        return {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      const MINIMUM_INPUT_WIDTH = 11;
      const useSelect = (props, emit) => {
        const { t: t2 } = useLocale();
        const contentId = useId();
        const nsSelect = useNamespace("select");
        const nsInput = useNamespace("input");
        const states = vue.reactive({
          inputValue: "",
          options: /* @__PURE__ */ new Map(),
          cachedOptions: /* @__PURE__ */ new Map(),
          disabledOptions: /* @__PURE__ */ new Map(),
          optionValues: [],
          selected: props.multiple ? [] : {},
          selectionWidth: 0,
          calculatorWidth: 0,
          collapseItemWidth: 0,
          selectedLabel: "",
          hoveringIndex: -1,
          previousQuery: null,
          inputHovering: false,
          menuVisibleOnFocus: false,
          isBeforeHide: false
        });
        useDeprecated({
          from: "suffixTransition",
          replacement: "override style scheme",
          version: "2.3.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
        }, vue.computed(() => props.suffixTransition === false));
        const selectRef = vue.ref(null);
        const selectionRef = vue.ref(null);
        const tooltipRef = vue.ref(null);
        const tagTooltipRef = vue.ref(null);
        const inputRef = vue.ref(null);
        const calculatorRef = vue.ref(null);
        const prefixRef = vue.ref(null);
        const suffixRef = vue.ref(null);
        const menuRef = vue.ref(null);
        const tagMenuRef = vue.ref(null);
        const collapseItemRef = vue.ref(null);
        const scrollbarRef = vue.ref(null);
        const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(inputRef, {
          afterFocus() {
            if (props.automaticDropdown && !expanded.value) {
              expanded.value = true;
              states.menuVisibleOnFocus = true;
            }
          },
          beforeBlur(event) {
            var _a2, _b;
            return ((_a2 = tooltipRef.value) == null ? void 0 : _a2.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event));
          },
          afterBlur() {
            expanded.value = false;
            states.menuVisibleOnFocus = false;
          }
        });
        const expanded = vue.ref(false);
        const hoverOption = vue.ref();
        const { form, formItem } = useFormItem();
        const { inputId } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const selectDisabled = vue.computed(() => props.disabled || (form == null ? void 0 : form.disabled));
        const hasModelValue = vue.computed(() => {
          return props.multiple ? isArray$6(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
        });
        const showClose = vue.computed(() => {
          const criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasModelValue.value;
          return criteria;
        });
        const iconComponent = vue.computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
        const iconReverse = vue.computed(() => nsSelect.is("reverse", iconComponent.value && expanded.value && props.suffixTransition));
        const validateState = vue.computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
        const validateIcon = vue.computed(() => ValidateComponentsMap[validateState.value]);
        const debounce$1 = vue.computed(() => props.remote ? 300 : 0);
        const emptyText = vue.computed(() => {
          if (props.loading) {
            return props.loadingText || t2("el.select.loading");
          } else {
            if (props.remote && !states.inputValue && states.options.size === 0)
              return false;
            if (props.filterable && states.inputValue && states.options.size > 0 && filteredOptionsCount.value === 0) {
              return props.noMatchText || t2("el.select.noMatch");
            }
            if (states.options.size === 0) {
              return props.noDataText || t2("el.select.noData");
            }
          }
          return null;
        });
        const filteredOptionsCount = vue.computed(() => optionsArray.value.filter((option) => option.visible).length);
        const optionsArray = vue.computed(() => {
          const list = Array.from(states.options.values());
          const newList = [];
          states.optionValues.forEach((item) => {
            const index2 = list.findIndex((i2) => i2.value === item);
            if (index2 > -1) {
              newList.push(list[index2]);
            }
          });
          return newList.length >= list.length ? newList : list;
        });
        const cachedOptionsArray = vue.computed(() => Array.from(states.cachedOptions.values()));
        const showNewOption = vue.computed(() => {
          const hasExistingOption = optionsArray.value.filter((option) => {
            return !option.created;
          }).some((option) => {
            return option.currentLabel === states.inputValue;
          });
          return props.filterable && props.allowCreate && states.inputValue !== "" && !hasExistingOption;
        });
        const updateOptions = () => {
          if (props.filterable && isFunction$2(props.filterMethod))
            return;
          if (props.filterable && props.remote && isFunction$2(props.remoteMethod))
            return;
          optionsArray.value.forEach((option) => {
            option.updateOption(states.inputValue);
          });
        };
        const selectSize = useFormSize();
        const collapseTagSize = vue.computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
        const dropdownMenuVisible = vue.computed({
          get() {
            return expanded.value && emptyText.value !== false;
          },
          set(val) {
            expanded.value = val;
          }
        });
        const shouldShowPlaceholder = vue.computed(() => {
          if (isArray$6(props.modelValue)) {
            return props.modelValue.length === 0 && !states.inputValue;
          }
          return props.filterable ? !states.inputValue : true;
        });
        const currentPlaceholder = vue.computed(() => {
          var _a2;
          const _placeholder = (_a2 = props.placeholder) != null ? _a2 : t2("el.select.placeholder");
          return props.multiple || !hasModelValue.value ? _placeholder : states.selectedLabel;
        });
        vue.watch(() => props.modelValue, (val, oldVal) => {
          if (props.multiple) {
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
              handleQueryChange("");
            }
          }
          setSelected();
          if (!isEqual(val, oldVal) && props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        }, {
          flush: "post",
          deep: true
        });
        vue.watch(() => expanded.value, (val) => {
          if (val) {
            handleQueryChange(states.inputValue);
          } else {
            states.inputValue = "";
            states.previousQuery = null;
            states.isBeforeHide = true;
          }
          emit("visible-change", val);
        });
        vue.watch(() => states.options.entries(), () => {
          var _a2;
          if (!isClient$1)
            return;
          const inputs = ((_a2 = selectRef.value) == null ? void 0 : _a2.querySelectorAll("input")) || [];
          if (!props.filterable && !props.defaultFirstOption && !isUndefined(props.modelValue) || !Array.from(inputs).includes(document.activeElement)) {
            setSelected();
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            checkDefaultFirstOption();
          }
        }, {
          flush: "post"
        });
        vue.watch(() => states.hoveringIndex, (val) => {
          if (isNumber$1(val) && val > -1) {
            hoverOption.value = optionsArray.value[val] || {};
          } else {
            hoverOption.value = {};
          }
          optionsArray.value.forEach((option) => {
            option.hover = hoverOption.value === option;
          });
        });
        vue.watchEffect(() => {
          if (states.isBeforeHide)
            return;
          updateOptions();
        });
        const handleQueryChange = (val) => {
          if (states.previousQuery === val) {
            return;
          }
          states.previousQuery = val;
          if (props.filterable && isFunction$2(props.filterMethod)) {
            props.filterMethod(val);
          } else if (props.filterable && props.remote && isFunction$2(props.remoteMethod)) {
            props.remoteMethod(val);
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            vue.nextTick(checkDefaultFirstOption);
          } else {
            vue.nextTick(updateHoveringIndex);
          }
        };
        const checkDefaultFirstOption = () => {
          const optionsInDropdown = optionsArray.value.filter((n2) => n2.visible && !n2.disabled && !n2.states.groupDisabled);
          const userCreatedOption = optionsInDropdown.find((n2) => n2.created);
          const firstOriginOption = optionsInDropdown[0];
          states.hoveringIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
        };
        const setSelected = () => {
          if (!props.multiple) {
            const option = getOption(props.modelValue);
            states.selectedLabel = option.currentLabel;
            states.selected = option;
            return;
          } else {
            states.selectedLabel = "";
          }
          const result = [];
          if (isArray$6(props.modelValue)) {
            props.modelValue.forEach((value) => {
              result.push(getOption(value));
            });
          }
          states.selected = result;
        };
        const getOption = (value) => {
          let option;
          const isObjectValue = toRawType(value).toLowerCase() === "object";
          const isNull = toRawType(value).toLowerCase() === "null";
          const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
          for (let i2 = states.cachedOptions.size - 1; i2 >= 0; i2--) {
            const cachedOption = cachedOptionsArray.value[i2];
            const isEqualValue = isObjectValue ? get(cachedOption.value, props.valueKey) === get(value, props.valueKey) : cachedOption.value === value;
            if (isEqualValue) {
              option = {
                value,
                currentLabel: cachedOption.currentLabel,
                isDisabled: cachedOption.isDisabled
              };
              break;
            }
          }
          if (option)
            return option;
          const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
          const newOption = {
            value,
            currentLabel: label
          };
          return newOption;
        };
        const updateHoveringIndex = () => {
          if (!props.multiple) {
            states.hoveringIndex = optionsArray.value.findIndex((item) => {
              return getValueKey(item) === getValueKey(states.selected);
            });
          } else {
            if (states.selected.length > 0) {
              states.hoveringIndex = Math.min(...states.selected.map((selected) => {
                return optionsArray.value.findIndex((item) => {
                  return getValueKey(item) === getValueKey(selected);
                });
              }));
            } else {
              states.hoveringIndex = -1;
            }
          }
        };
        const resetSelectionWidth = () => {
          states.selectionWidth = selectionRef.value.getBoundingClientRect().width;
        };
        const resetCalculatorWidth = () => {
          states.calculatorWidth = calculatorRef.value.getBoundingClientRect().width;
        };
        const resetCollapseItemWidth = () => {
          states.collapseItemWidth = collapseItemRef.value.getBoundingClientRect().width;
        };
        const updateTooltip = () => {
          var _a2, _b;
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        };
        const updateTagTooltip = () => {
          var _a2, _b;
          (_b = (_a2 = tagTooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        };
        const onInputChange = () => {
          if (states.inputValue.length > 0 && !expanded.value) {
            expanded.value = true;
          }
          handleQueryChange(states.inputValue);
        };
        const onInput = (event) => {
          states.inputValue = event.target.value;
          if (props.remote) {
            debouncedOnInputChange();
          } else {
            return onInputChange();
          }
        };
        const debouncedOnInputChange = debounce(() => {
          onInputChange();
        }, debounce$1.value);
        const emitChange = (val) => {
          if (!isEqual(props.modelValue, val)) {
            emit(CHANGE_EVENT, val);
          }
        };
        const getLastNotDisabledIndex = (value) => findLastIndex(value, (it2) => !states.disabledOptions.has(it2));
        const deletePrevTag = (e2) => {
          if (!props.multiple)
            return;
          if (e2.code === EVENT_CODE.delete)
            return;
          if (e2.target.value.length <= 0) {
            const value = props.modelValue.slice();
            const lastNotDisabledIndex = getLastNotDisabledIndex(value);
            if (lastNotDisabledIndex < 0)
              return;
            value.splice(lastNotDisabledIndex, 1);
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
          }
        };
        const deleteTag = (event, tag) => {
          const index2 = states.selected.indexOf(tag);
          if (index2 > -1 && !selectDisabled.value) {
            const value = props.modelValue.slice();
            value.splice(index2, 1);
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            emit("remove-tag", tag.value);
          }
          event.stopPropagation();
          focus();
        };
        const deleteSelected = (event) => {
          event.stopPropagation();
          const value = props.multiple ? [] : "";
          if (!isString$2(value)) {
            for (const item of states.selected) {
              if (item.isDisabled)
                value.push(item.value);
            }
          }
          emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          states.hoveringIndex = -1;
          expanded.value = false;
          emit("clear");
          focus();
        };
        const handleOptionSelect = (option) => {
          if (props.multiple) {
            const value = (props.modelValue || []).slice();
            const optionIndex = getValueIndex(value, option.value);
            if (optionIndex > -1) {
              value.splice(optionIndex, 1);
            } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
              value.push(option.value);
            }
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            if (option.created) {
              handleQueryChange("");
            }
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
            }
          } else {
            emit(UPDATE_MODEL_EVENT, option.value);
            emitChange(option.value);
            expanded.value = false;
          }
          focus();
          if (expanded.value)
            return;
          vue.nextTick(() => {
            scrollToOption(option);
          });
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$3(value))
            return arr.indexOf(value);
          const valueKey = props.valueKey;
          let index2 = -1;
          arr.some((item, i2) => {
            if (vue.toRaw(get(item, valueKey)) === get(value, valueKey)) {
              index2 = i2;
              return true;
            }
            return false;
          });
          return index2;
        };
        const scrollToOption = (option) => {
          var _a2, _b, _c, _d, _e;
          const targetOption = isArray$6(option) ? option[0] : option;
          let target = null;
          if (targetOption == null ? void 0 : targetOption.value) {
            const options = optionsArray.value.filter((item) => item.value === targetOption.value);
            if (options.length > 0) {
              target = options[0].$el;
            }
          }
          if (tooltipRef.value && target) {
            const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${nsSelect.be("dropdown", "wrap")}`);
            if (menu) {
              scrollIntoView(menu, target);
            }
          }
          (_e = scrollbarRef.value) == null ? void 0 : _e.handleScroll();
        };
        const onOptionCreate = (vm) => {
          states.options.set(vm.value, vm);
          states.cachedOptions.set(vm.value, vm);
          vm.disabled && states.disabledOptions.set(vm.value, vm);
        };
        const onOptionDestroy = (key, vm) => {
          if (states.options.get(key) === vm) {
            states.options.delete(key);
          }
        };
        const {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        } = useInput((e2) => onInput(e2));
        const popperRef = vue.computed(() => {
          var _a2, _b;
          return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        const handleMenuEnter = () => {
          vue.nextTick(() => scrollToOption(states.selected));
        };
        const focus = () => {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        };
        const blur = () => {
          handleClickOutside();
        };
        const handleClearClick = (event) => {
          deleteSelected(event);
        };
        const handleClickOutside = (event) => {
          expanded.value = false;
          if (isFocused.value) {
            const _event2 = new FocusEvent("focus", event);
            vue.nextTick(() => handleBlur(_event2));
          }
        };
        const handleEsc = () => {
          if (states.inputValue.length > 0) {
            states.inputValue = "";
          } else {
            expanded.value = false;
          }
        };
        const toggleMenu = () => {
          if (selectDisabled.value)
            return;
          if (props.filterable && props.remote && isFunction$2(props.remoteMethod))
            return;
          if (states.menuVisibleOnFocus) {
            states.menuVisibleOnFocus = false;
          } else {
            expanded.value = !expanded.value;
          }
        };
        const selectOption = () => {
          if (!expanded.value) {
            toggleMenu();
          } else {
            if (optionsArray.value[states.hoveringIndex]) {
              handleOptionSelect(optionsArray.value[states.hoveringIndex]);
            }
          }
        };
        const getValueKey = (item) => {
          return isObject$3(item.value) ? get(item.value, props.valueKey) : item.value;
        };
        const optionsAllDisabled = vue.computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
        const showTagList = vue.computed(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(0, props.maxCollapseTags) : states.selected;
        });
        const collapseTagList = vue.computed(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(props.maxCollapseTags) : [];
        });
        const navigateOptions = (direction) => {
          if (!expanded.value) {
            expanded.value = true;
            return;
          }
          if (states.options.size === 0 || filteredOptionsCount.value === 0)
            return;
          if (!optionsAllDisabled.value) {
            if (direction === "next") {
              states.hoveringIndex++;
              if (states.hoveringIndex === states.options.size) {
                states.hoveringIndex = 0;
              }
            } else if (direction === "prev") {
              states.hoveringIndex--;
              if (states.hoveringIndex < 0) {
                states.hoveringIndex = states.options.size - 1;
              }
            }
            const option = optionsArray.value[states.hoveringIndex];
            if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
              navigateOptions(direction);
            }
            vue.nextTick(() => scrollToOption(hoverOption.value));
          }
        };
        const getGapWidth = () => {
          if (!selectionRef.value)
            return 0;
          const style = window.getComputedStyle(selectionRef.value);
          return Number.parseFloat(style.gap || "6px");
        };
        const tagStyle = vue.computed(() => {
          const gapWidth = getGapWidth();
          const maxWidth = collapseItemRef.value && props.maxCollapseTags === 1 ? states.selectionWidth - states.collapseItemWidth - gapWidth : states.selectionWidth;
          return { maxWidth: `${maxWidth}px` };
        });
        const collapseTagStyle = vue.computed(() => {
          return { maxWidth: `${states.selectionWidth}px` };
        });
        const inputStyle = vue.computed(() => ({
          width: `${Math.max(states.calculatorWidth, MINIMUM_INPUT_WIDTH)}px`
        }));
        if (props.multiple && !isArray$6(props.modelValue)) {
          emit(UPDATE_MODEL_EVENT, []);
        }
        if (!props.multiple && isArray$6(props.modelValue)) {
          emit(UPDATE_MODEL_EVENT, "");
        }
        useResizeObserver$1(selectionRef, resetSelectionWidth);
        useResizeObserver$1(calculatorRef, resetCalculatorWidth);
        useResizeObserver$1(menuRef, updateTooltip);
        useResizeObserver$1(wrapperRef, updateTooltip);
        useResizeObserver$1(tagMenuRef, updateTagTooltip);
        useResizeObserver$1(collapseItemRef, resetCollapseItemWidth);
        vue.onMounted(() => {
          setSelected();
        });
        return {
          inputId,
          contentId,
          nsSelect,
          nsInput,
          states,
          isFocused,
          expanded,
          optionsArray,
          hoverOption,
          selectSize,
          filteredOptionsCount,
          resetCalculatorWidth,
          updateTooltip,
          updateTagTooltip,
          debouncedOnInputChange,
          onInput,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          hasModelValue,
          shouldShowPlaceholder,
          currentPlaceholder,
          showClose,
          iconComponent,
          iconReverse,
          validateState,
          validateIcon,
          showNewOption,
          updateOptions,
          collapseTagSize,
          setSelected,
          selectDisabled,
          emptyText,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          handleFocus,
          focus,
          blur,
          handleBlur,
          handleClearClick,
          handleClickOutside,
          handleEsc,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          dropdownMenuVisible,
          showTagList,
          collapseTagList,
          tagStyle,
          collapseTagStyle,
          inputStyle,
          popperRef,
          inputRef,
          tooltipRef,
          tagTooltipRef,
          calculatorRef,
          prefixRef,
          suffixRef,
          selectRef,
          wrapperRef,
          selectionRef,
          scrollbarRef,
          menuRef,
          tagMenuRef,
          collapseItemRef
        };
      };
      var ElOptions = vue.defineComponent({
        name: "ElOptions",
        setup(_2, { slots }) {
          const select = vue.inject(selectKey);
          let cachedValueList = [];
          return () => {
            var _a2, _b;
            const children = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
            const valueList = [];
            function filterOptions(children2) {
              if (!isArray$6(children2))
                return;
              children2.forEach((item) => {
                var _a22, _b2, _c, _d;
                const name = (_a22 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a22.name;
                if (name === "ElOptionGroup") {
                  filterOptions(!isString$2(item.children) && !isArray$6(item.children) && isFunction$2((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
                } else if (name === "ElOption") {
                  valueList.push((_d = item.props) == null ? void 0 : _d.value);
                } else if (isArray$6(item.children)) {
                  filterOptions(item.children);
                }
              });
            }
            if (children.length) {
              filterOptions((_b = children[0]) == null ? void 0 : _b.children);
            }
            if (!isEqual(valueList, cachedValueList)) {
              cachedValueList = valueList;
              if (select) {
                select.states.optionValues = valueList;
              }
            }
            return children;
          };
        }
      });
      const SelectProps = buildProps({
        name: String,
        id: String,
        modelValue: {
          type: [Array, String, Number, Boolean, Object],
          default: void 0
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        automaticDropdown: Boolean,
        size: useSizeProp,
        effect: {
          type: definePropType(String),
          default: "light"
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        allowCreate: Boolean,
        loading: Boolean,
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        remote: Boolean,
        loadingText: String,
        noMatchText: String,
        noDataText: String,
        remoteMethod: Function,
        filterMethod: Function,
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        placeholder: {
          type: String
        },
        defaultFirstOption: Boolean,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        valueKey: {
          type: String,
          default: "value"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: Boolean,
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: iconPropType,
          default: circle_close_default
        },
        fitInputWidth: Boolean,
        suffixIcon: {
          type: iconPropType,
          default: arrow_down_default
        },
        tagType: { ...tagProps.type, default: "info" },
        validateEvent: {
          type: Boolean,
          default: true
        },
        remoteShowSuffix: Boolean,
        suffixTransition: {
          type: Boolean,
          default: true
        },
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        },
        ariaLabel: {
          type: String,
          default: void 0
        }
      });
      const COMPONENT_NAME = "ElSelect";
      const _sfc_main$7 = vue.defineComponent({
        name: COMPONENT_NAME,
        componentName: COMPONENT_NAME,
        components: {
          ElInput,
          ElSelectMenu,
          ElOption: Option,
          ElOptions,
          ElTag,
          ElScrollbar,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside },
        props: SelectProps,
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props, { emit }) {
          const API = useSelect(props, emit);
          vue.provide(selectKey, vue.reactive({
            props,
            states: API.states,
            optionsArray: API.optionsArray,
            handleOptionSelect: API.handleOptionSelect,
            onOptionCreate: API.onOptionCreate,
            onOptionDestroy: API.onOptionDestroy,
            selectRef: API.selectRef,
            setSelected: API.setSelected
          }));
          return {
            ...API
          };
        }
      });
      const _hoisted_1$5 = ["id", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"];
      const _hoisted_2$5 = ["textContent"];
      function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = vue.resolveComponent("el-tag");
        const _component_el_tooltip = vue.resolveComponent("el-tooltip");
        const _component_el_icon = vue.resolveComponent("el-icon");
        const _component_el_option = vue.resolveComponent("el-option");
        const _component_el_options = vue.resolveComponent("el-options");
        const _component_el_scrollbar = vue.resolveComponent("el-scrollbar");
        const _component_el_select_menu = vue.resolveComponent("el-select-menu");
        const _directive_click_outside = vue.resolveDirective("click-outside");
        return vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
          ref: "selectRef",
          class: vue.normalizeClass([_ctx.nsSelect.b(), _ctx.nsSelect.m(_ctx.selectSize)]),
          onMouseenter: _cache[14] || (_cache[14] = ($event) => _ctx.states.inputHovering = true),
          onMouseleave: _cache[15] || (_cache[15] = ($event) => _ctx.states.inputHovering = false),
          onClick: _cache[16] || (_cache[16] = vue.withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
        }, [
          vue.createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropdownMenuVisible,
            placement: _ctx.placement,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
            "popper-options": _ctx.popperOptions,
            "fallback-placements": ["bottom-start", "top-start", "right", "left"],
            effect: _ctx.effect,
            pure: "",
            trigger: "click",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            persistent: _ctx.persistent,
            onBeforeShow: _ctx.handleMenuEnter,
            onHide: _cache[13] || (_cache[13] = ($event) => _ctx.states.isBeforeHide = false)
          }, {
            default: vue.withCtx(() => {
              var _a2;
              return [
                vue.createElementVNode("div", {
                  ref: "wrapperRef",
                  class: vue.normalizeClass([
                    _ctx.nsSelect.e("wrapper"),
                    _ctx.nsSelect.is("focused", _ctx.isFocused),
                    _ctx.nsSelect.is("hovering", _ctx.states.inputHovering),
                    _ctx.nsSelect.is("filterable", _ctx.filterable),
                    _ctx.nsSelect.is("disabled", _ctx.selectDisabled)
                  ])
                }, [
                  _ctx.$slots.prefix ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 0,
                    ref: "prefixRef",
                    class: vue.normalizeClass(_ctx.nsSelect.e("prefix"))
                  }, [
                    vue.renderSlot(_ctx.$slots, "prefix")
                  ], 2)) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("div", {
                    ref: "selectionRef",
                    class: vue.normalizeClass([
                      _ctx.nsSelect.e("selection"),
                      _ctx.nsSelect.is("near", _ctx.multiple && !_ctx.$slots.prefix && !!_ctx.states.selected.length)
                    ])
                  }, [
                    _ctx.multiple ? vue.renderSlot(_ctx.$slots, "tag", { key: 0 }, () => [
                      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.showTagList, (item) => {
                        return vue.openBlock(), vue.createElementBlock("div", {
                          key: _ctx.getValueKey(item),
                          class: vue.normalizeClass(_ctx.nsSelect.e("selected-item"))
                        }, [
                          vue.createVNode(_component_el_tag, {
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            style: vue.normalizeStyle(_ctx.tagStyle),
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: vue.withCtx(() => [
                              vue.createElementVNode("span", {
                                class: vue.normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, vue.toDisplayString(item.currentLabel), 3)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "type", "style", "onClose"])
                        ], 2);
                      }), 128)),
                      _ctx.collapseTags && _ctx.states.selected.length > _ctx.maxCollapseTags ? (vue.openBlock(), vue.createBlock(_component_el_tooltip, {
                        key: 0,
                        ref: "tagTooltipRef",
                        disabled: _ctx.dropdownMenuVisible || !_ctx.collapseTagsTooltip,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        effect: _ctx.effect,
                        placement: "bottom",
                        teleported: _ctx.teleported
                      }, {
                        default: vue.withCtx(() => [
                          vue.createElementVNode("div", {
                            ref: "collapseItemRef",
                            class: vue.normalizeClass(_ctx.nsSelect.e("selected-item"))
                          }, [
                            vue.createVNode(_component_el_tag, {
                              closable: false,
                              size: _ctx.collapseTagSize,
                              type: _ctx.tagType,
                              "disable-transitions": "",
                              style: vue.normalizeStyle(_ctx.collapseTagStyle)
                            }, {
                              default: vue.withCtx(() => [
                                vue.createElementVNode("span", {
                                  class: vue.normalizeClass(_ctx.nsSelect.e("tags-text"))
                                }, " + " + vue.toDisplayString(_ctx.states.selected.length - _ctx.maxCollapseTags), 3)
                              ]),
                              _: 1
                            }, 8, ["size", "type", "style"])
                          ], 2)
                        ]),
                        content: vue.withCtx(() => [
                          vue.createElementVNode("div", {
                            ref: "tagMenuRef",
                            class: vue.normalizeClass(_ctx.nsSelect.e("selection"))
                          }, [
                            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.collapseTagList, (item) => {
                              return vue.openBlock(), vue.createElementBlock("div", {
                                key: _ctx.getValueKey(item),
                                class: vue.normalizeClass(_ctx.nsSelect.e("selected-item"))
                              }, [
                                vue.createVNode(_component_el_tag, {
                                  class: "in-tooltip",
                                  closable: !_ctx.selectDisabled && !item.isDisabled,
                                  size: _ctx.collapseTagSize,
                                  type: _ctx.tagType,
                                  "disable-transitions": "",
                                  onClose: ($event) => _ctx.deleteTag($event, item)
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.createElementVNode("span", {
                                      class: vue.normalizeClass(_ctx.nsSelect.e("tags-text"))
                                    }, vue.toDisplayString(item.currentLabel), 3)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "type", "onClose"])
                              ], 2);
                            }), 128))
                          ], 2)
                        ]),
                        _: 1
                      }, 8, ["disabled", "effect", "teleported"])) : vue.createCommentVNode("v-if", true)
                    ]) : vue.createCommentVNode("v-if", true),
                    !_ctx.selectDisabled ? (vue.openBlock(), vue.createElementBlock("div", {
                      key: 1,
                      class: vue.normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("input-wrapper"),
                        _ctx.nsSelect.is("hidden", !_ctx.filterable)
                      ])
                    }, [
                      vue.withDirectives(vue.createElementVNode("input", {
                        id: _ctx.inputId,
                        ref: "inputRef",
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.states.inputValue = $event),
                        type: "text",
                        class: vue.normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                        disabled: _ctx.selectDisabled,
                        autocomplete: _ctx.autocomplete,
                        style: vue.normalizeStyle(_ctx.inputStyle),
                        role: "combobox",
                        readonly: !_ctx.filterable,
                        spellcheck: "false",
                        "aria-activedescendant": ((_a2 = _ctx.hoverOption) == null ? void 0 : _a2.id) || "",
                        "aria-controls": _ctx.contentId,
                        "aria-expanded": _ctx.dropdownMenuVisible,
                        "aria-label": _ctx.ariaLabel,
                        "aria-autocomplete": "none",
                        "aria-haspopup": "listbox",
                        onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                        onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                        onKeydown: [
                          _cache[3] || (_cache[3] = vue.withKeys(vue.withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                          _cache[4] || (_cache[4] = vue.withKeys(vue.withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                          _cache[5] || (_cache[5] = vue.withKeys(vue.withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                          _cache[6] || (_cache[6] = vue.withKeys(vue.withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                          _cache[7] || (_cache[7] = vue.withKeys(vue.withModifiers((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["stop"]), ["delete"]))
                        ],
                        onCompositionstart: _cache[8] || (_cache[8] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                        onCompositionupdate: _cache[9] || (_cache[9] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                        onCompositionend: _cache[10] || (_cache[10] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                        onInput: _cache[11] || (_cache[11] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                        onClick: _cache[12] || (_cache[12] = vue.withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
                      }, null, 46, _hoisted_1$5), [
                        [vue.vModelText, _ctx.states.inputValue]
                      ]),
                      _ctx.filterable ? (vue.openBlock(), vue.createElementBlock("span", {
                        key: 0,
                        ref: "calculatorRef",
                        "aria-hidden": "true",
                        class: vue.normalizeClass(_ctx.nsSelect.e("input-calculator")),
                        textContent: vue.toDisplayString(_ctx.states.inputValue)
                      }, null, 10, _hoisted_2$5)) : vue.createCommentVNode("v-if", true)
                    ], 2)) : vue.createCommentVNode("v-if", true),
                    _ctx.shouldShowPlaceholder ? (vue.openBlock(), vue.createElementBlock("div", {
                      key: 2,
                      class: vue.normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("placeholder"),
                        _ctx.nsSelect.is("transparent", !_ctx.hasModelValue || _ctx.expanded && !_ctx.states.inputValue)
                      ])
                    }, [
                      vue.createElementVNode("span", null, vue.toDisplayString(_ctx.currentPlaceholder), 1)
                    ], 2)) : vue.createCommentVNode("v-if", true)
                  ], 2),
                  vue.createElementVNode("div", {
                    ref: "suffixRef",
                    class: vue.normalizeClass(_ctx.nsSelect.e("suffix"))
                  }, [
                    _ctx.iconComponent && !_ctx.showClose ? (vue.openBlock(), vue.createBlock(_component_el_icon, {
                      key: 0,
                      class: vue.normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                    }, {
                      default: vue.withCtx(() => [
                        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : vue.createCommentVNode("v-if", true),
                    _ctx.showClose && _ctx.clearIcon ? (vue.openBlock(), vue.createBlock(_component_el_icon, {
                      key: 1,
                      class: vue.normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                      onClick: _ctx.handleClearClick
                    }, {
                      default: vue.withCtx(() => [
                        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : vue.createCommentVNode("v-if", true),
                    _ctx.validateState && _ctx.validateIcon ? (vue.openBlock(), vue.createBlock(_component_el_icon, {
                      key: 2,
                      class: vue.normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                    }, {
                      default: vue.withCtx(() => [
                        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.validateIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : vue.createCommentVNode("v-if", true)
                  ], 2)
                ], 2)
              ];
            }),
            content: vue.withCtx(() => [
              vue.createVNode(_component_el_select_menu, { ref: "menuRef" }, {
                default: vue.withCtx(() => [
                  _ctx.$slots.header ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 0,
                    class: vue.normalizeClass(_ctx.nsSelect.be("dropdown", "header"))
                  }, [
                    vue.renderSlot(_ctx.$slots, "header")
                  ], 2)) : vue.createCommentVNode("v-if", true),
                  vue.withDirectives(vue.createVNode(_component_el_scrollbar, {
                    id: _ctx.contentId,
                    ref: "scrollbarRef",
                    tag: "ul",
                    "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                    "view-class": _ctx.nsSelect.be("dropdown", "list"),
                    class: vue.normalizeClass([_ctx.nsSelect.is("empty", _ctx.filteredOptionsCount === 0)]),
                    role: "listbox",
                    "aria-label": _ctx.ariaLabel,
                    "aria-orientation": "vertical"
                  }, {
                    default: vue.withCtx(() => [
                      _ctx.showNewOption ? (vue.openBlock(), vue.createBlock(_component_el_option, {
                        key: 0,
                        value: _ctx.states.inputValue,
                        created: true
                      }, null, 8, ["value"])) : vue.createCommentVNode("v-if", true),
                      vue.createVNode(_component_el_options, null, {
                        default: vue.withCtx(() => [
                          vue.renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
                    [vue.vShow, _ctx.states.options.size > 0 && !_ctx.loading]
                  ]),
                  _ctx.$slots.loading && _ctx.loading ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 1,
                    class: vue.normalizeClass(_ctx.nsSelect.be("dropdown", "loading"))
                  }, [
                    vue.renderSlot(_ctx.$slots, "loading")
                  ], 2)) : _ctx.loading || _ctx.filteredOptionsCount === 0 ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 2,
                    class: vue.normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                  }, [
                    vue.renderSlot(_ctx.$slots, "empty", {}, () => [
                      vue.createElementVNode("span", null, vue.toDisplayString(_ctx.emptyText), 1)
                    ])
                  ], 2)) : vue.createCommentVNode("v-if", true),
                  _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 3,
                    class: vue.normalizeClass(_ctx.nsSelect.be("dropdown", "footer"))
                  }, [
                    vue.renderSlot(_ctx.$slots, "footer")
                  ], 2)) : vue.createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 512)
            ]),
            _: 3
          }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onBeforeShow"])
        ], 34)), [
          [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
        ]);
      }
      var Select = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["render", _sfc_render$1], ["__file", "select.vue"]]);
      const _sfc_main$6 = vue.defineComponent({
        name: "ElOptionGroup",
        componentName: "ElOptionGroup",
        props: {
          label: String,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const groupRef = vue.ref(null);
          const instance = vue.getCurrentInstance();
          const children = vue.ref([]);
          vue.provide(selectGroupKey, vue.reactive({
            ...vue.toRefs(props)
          }));
          const visible = vue.computed(() => children.value.some((option) => option.visible === true));
          const flattedChildren = (node2) => {
            const children2 = [];
            if (isArray$6(node2.children)) {
              node2.children.forEach((child) => {
                var _a2;
                if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                  children2.push(child.component.proxy);
                } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
                  children2.push(...flattedChildren(child));
                }
              });
            }
            return children2;
          };
          const updateChildren = () => {
            children.value = flattedChildren(instance.subTree);
          };
          vue.onMounted(() => {
            updateChildren();
          });
          useMutationObserver$1(groupRef, updateChildren, {
            attributes: true,
            subtree: true,
            childList: true
          });
          return {
            groupRef,
            visible,
            ns
          };
        }
      });
      function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
        return vue.withDirectives((vue.openBlock(), vue.createElementBlock("ul", {
          ref: "groupRef",
          class: vue.normalizeClass(_ctx.ns.be("group", "wrap"))
        }, [
          vue.createElementVNode("li", {
            class: vue.normalizeClass(_ctx.ns.be("group", "title"))
          }, vue.toDisplayString(_ctx.label), 3),
          vue.createElementVNode("li", null, [
            vue.createElementVNode("ul", {
              class: vue.normalizeClass(_ctx.ns.b("group"))
            }, [
              vue.renderSlot(_ctx.$slots, "default")
            ], 2)
          ])
        ], 2)), [
          [vue.vShow, _ctx.visible]
        ]);
      }
      var OptionGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["render", _sfc_render], ["__file", "option-group.vue"]]);
      const ElSelect = withInstall$1(Select, {
        Option,
        OptionGroup
      });
      const ElOption = withNoopInstall(Option);
      withNoopInstall(OptionGroup);
      const popoverProps = buildProps({
        trigger: useTooltipTriggerProps.trigger,
        placement: dropdownProps.placement,
        disabled: useTooltipTriggerProps.disabled,
        visible: useTooltipContentProps.visible,
        transition: useTooltipContentProps.transition,
        popperOptions: dropdownProps.popperOptions,
        tabindex: dropdownProps.tabindex,
        content: useTooltipContentProps.content,
        popperStyle: useTooltipContentProps.popperStyle,
        popperClass: useTooltipContentProps.popperClass,
        enterable: {
          ...useTooltipContentProps.enterable,
          default: true
        },
        effect: {
          ...useTooltipContentProps.effect,
          default: "light"
        },
        teleported: useTooltipContentProps.teleported,
        title: String,
        width: {
          type: [String, Number],
          default: 150
        },
        offset: {
          type: Number,
          default: void 0
        },
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        },
        showArrow: {
          type: Boolean,
          default: true
        },
        persistent: {
          type: Boolean,
          default: true
        },
        "onUpdate:visible": {
          type: Function
        }
      });
      const popoverEmits = {
        "update:visible": (value) => isBoolean$1(value),
        "before-enter": () => true,
        "before-leave": () => true,
        "after-enter": () => true,
        "after-leave": () => true
      };
      const updateEventKeyRaw = `onUpdate:visible`;
      const __default__$1 = vue.defineComponent({
        name: "ElPopover"
      });
      const _sfc_main$5 = /* @__PURE__ */ vue.defineComponent({
        ...__default__$1,
        props: popoverProps,
        emits: popoverEmits,
        setup(__props, { expose, emit }) {
          const props = __props;
          const onUpdateVisible = vue.computed(() => {
            return props[updateEventKeyRaw];
          });
          const ns = useNamespace("popover");
          const tooltipRef = vue.ref();
          const popperRef = vue.computed(() => {
            var _a2;
            return (_a2 = vue.unref(tooltipRef)) == null ? void 0 : _a2.popperRef;
          });
          const style = vue.computed(() => {
            return [
              {
                width: addUnit(props.width)
              },
              props.popperStyle
            ];
          });
          const kls = vue.computed(() => {
            return [ns.b(), props.popperClass, { [ns.m("plain")]: !!props.content }];
          });
          const gpuAcceleration = vue.computed(() => {
            return props.transition === `${ns.namespace.value}-fade-in-linear`;
          });
          const hide = () => {
            var _a2;
            (_a2 = tooltipRef.value) == null ? void 0 : _a2.hide();
          };
          const beforeEnter = () => {
            emit("before-enter");
          };
          const beforeLeave = () => {
            emit("before-leave");
          };
          const afterEnter = () => {
            emit("after-enter");
          };
          const afterLeave = () => {
            emit("update:visible", false);
            emit("after-leave");
          };
          expose({
            popperRef,
            hide
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.unref(ElTooltip), vue.mergeProps({
              ref_key: "tooltipRef",
              ref: tooltipRef
            }, _ctx.$attrs, {
              trigger: _ctx.trigger,
              placement: _ctx.placement,
              disabled: _ctx.disabled,
              visible: _ctx.visible,
              transition: _ctx.transition,
              "popper-options": _ctx.popperOptions,
              tabindex: _ctx.tabindex,
              content: _ctx.content,
              offset: _ctx.offset,
              "show-after": _ctx.showAfter,
              "hide-after": _ctx.hideAfter,
              "auto-close": _ctx.autoClose,
              "show-arrow": _ctx.showArrow,
              "aria-label": _ctx.title,
              effect: _ctx.effect,
              enterable: _ctx.enterable,
              "popper-class": vue.unref(kls),
              "popper-style": vue.unref(style),
              teleported: _ctx.teleported,
              persistent: _ctx.persistent,
              "gpu-acceleration": vue.unref(gpuAcceleration),
              "onUpdate:visible": vue.unref(onUpdateVisible),
              onBeforeShow: beforeEnter,
              onBeforeHide: beforeLeave,
              onShow: afterEnter,
              onHide: afterLeave
            }), {
              content: vue.withCtx(() => [
                _ctx.title ? (vue.openBlock(), vue.createElementBlock("div", {
                  key: 0,
                  class: vue.normalizeClass(vue.unref(ns).e("title")),
                  role: "title"
                }, vue.toDisplayString(_ctx.title), 3)) : vue.createCommentVNode("v-if", true),
                vue.renderSlot(_ctx.$slots, "default", {}, () => [
                  vue.createTextVNode(vue.toDisplayString(_ctx.content), 1)
                ])
              ]),
              default: vue.withCtx(() => [
                _ctx.$slots.reference ? vue.renderSlot(_ctx.$slots, "reference", { key: 0 }) : vue.createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]);
          };
        }
      });
      var Popover = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["__file", "popover.vue"]]);
      const attachEvents = (el, binding) => {
        const popperComponent = binding.arg || binding.value;
        const popover = popperComponent == null ? void 0 : popperComponent.popperRef;
        if (popover) {
          popover.triggerRef = el;
        }
      };
      var PopoverDirective = {
        mounted(el, binding) {
          attachEvents(el, binding);
        },
        updated(el, binding) {
          attachEvents(el, binding);
        }
      };
      const VPopover = "popover";
      const ElPopoverDirective = withInstallDirective(PopoverDirective, VPopover);
      const ElPopover = withInstall$1(Popover, {
        directive: ElPopoverDirective
      });
      const notificationTypes = [
        "success",
        "info",
        "warning",
        "error"
      ];
      const notificationProps = buildProps({
        customClass: {
          type: String,
          default: ""
        },
        dangerouslyUseHTMLString: {
          type: Boolean,
          default: false
        },
        duration: {
          type: Number,
          default: 4500
        },
        icon: {
          type: iconPropType
        },
        id: {
          type: String,
          default: ""
        },
        message: {
          type: definePropType([String, Object]),
          default: ""
        },
        offset: {
          type: Number,
          default: 0
        },
        onClick: {
          type: definePropType(Function),
          default: () => void 0
        },
        onClose: {
          type: definePropType(Function),
          required: true
        },
        position: {
          type: String,
          values: ["top-right", "top-left", "bottom-right", "bottom-left"],
          default: "top-right"
        },
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          values: [...notificationTypes, ""],
          default: ""
        },
        zIndex: Number
      });
      const notificationEmits = {
        destroy: () => true
      };
      const _hoisted_1$4 = ["id"];
      const _hoisted_2$4 = ["textContent"];
      const _hoisted_3$4 = { key: 0 };
      const _hoisted_4$1 = ["innerHTML"];
      const __default__ = vue.defineComponent({
        name: "ElNotification"
      });
      const _sfc_main$4 = /* @__PURE__ */ vue.defineComponent({
        ...__default__,
        props: notificationProps,
        emits: notificationEmits,
        setup(__props, { expose }) {
          const props = __props;
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("notification");
          const { nextZIndex, currentZIndex } = zIndex2;
          const { Close } = CloseComponents;
          const visible = vue.ref(false);
          let timer = void 0;
          const typeClass = vue.computed(() => {
            const type3 = props.type;
            return type3 && TypeComponentsMap[props.type] ? ns.m(type3) : "";
          });
          const iconComponent = vue.computed(() => {
            if (!props.type)
              return props.icon;
            return TypeComponentsMap[props.type] || props.icon;
          });
          const horizontalClass = vue.computed(() => props.position.endsWith("right") ? "right" : "left");
          const verticalProperty = vue.computed(() => props.position.startsWith("top") ? "top" : "bottom");
          const positionStyle = vue.computed(() => {
            var _a2;
            return {
              [verticalProperty.value]: `${props.offset}px`,
              zIndex: (_a2 = props.zIndex) != null ? _a2 : currentZIndex.value
            };
          });
          function startTimer() {
            if (props.duration > 0) {
              ({ stop: timer } = useTimeoutFn$1(() => {
                if (visible.value)
                  close2();
              }, props.duration));
            }
          }
          function clearTimer() {
            timer == null ? void 0 : timer();
          }
          function close2() {
            visible.value = false;
          }
          function onKeydown({ code }) {
            if (code === EVENT_CODE.delete || code === EVENT_CODE.backspace) {
              clearTimer();
            } else if (code === EVENT_CODE.esc) {
              if (visible.value) {
                close2();
              }
            } else {
              startTimer();
            }
          }
          vue.onMounted(() => {
            startTimer();
            nextZIndex();
            visible.value = true;
          });
          useEventListener$1(document, "keydown", onKeydown);
          expose({
            visible,
            close: close2
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.Transition, {
              name: vue.unref(ns).b("fade"),
              onBeforeLeave: _ctx.onClose,
              onAfterLeave: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("destroy")),
              persisted: ""
            }, {
              default: vue.withCtx(() => [
                vue.withDirectives(vue.createElementVNode("div", {
                  id: _ctx.id,
                  class: vue.normalizeClass([vue.unref(ns).b(), _ctx.customClass, vue.unref(horizontalClass)]),
                  style: vue.normalizeStyle(vue.unref(positionStyle)),
                  role: "alert",
                  onMouseenter: clearTimer,
                  onMouseleave: startTimer,
                  onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
                }, [
                  vue.unref(iconComponent) ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                    key: 0,
                    class: vue.normalizeClass([vue.unref(ns).e("icon"), vue.unref(typeClass)])
                  }, {
                    default: vue.withCtx(() => [
                      (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : vue.createCommentVNode("v-if", true),
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass(vue.unref(ns).e("group"))
                  }, [
                    vue.createElementVNode("h2", {
                      class: vue.normalizeClass(vue.unref(ns).e("title")),
                      textContent: vue.toDisplayString(_ctx.title)
                    }, null, 10, _hoisted_2$4),
                    vue.withDirectives(vue.createElementVNode("div", {
                      class: vue.normalizeClass(vue.unref(ns).e("content")),
                      style: vue.normalizeStyle(!!_ctx.title ? void 0 : { margin: 0 })
                    }, [
                      vue.renderSlot(_ctx.$slots, "default", {}, () => [
                        !_ctx.dangerouslyUseHTMLString ? (vue.openBlock(), vue.createElementBlock("p", _hoisted_3$4, vue.toDisplayString(_ctx.message), 1)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                          vue.createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                          vue.createElementVNode("p", { innerHTML: _ctx.message }, null, 8, _hoisted_4$1)
                        ], 2112))
                      ])
                    ], 6), [
                      [vue.vShow, _ctx.message]
                    ]),
                    _ctx.showClose ? (vue.openBlock(), vue.createBlock(vue.unref(ElIcon), {
                      key: 0,
                      class: vue.normalizeClass(vue.unref(ns).e("closeBtn")),
                      onClick: vue.withModifiers(close2, ["stop"])
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(Close))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : vue.createCommentVNode("v-if", true)
                  ], 2)
                ], 46, _hoisted_1$4), [
                  [vue.vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name", "onBeforeLeave"]);
          };
        }
      });
      var NotificationConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["__file", "notification.vue"]]);
      const notifications = {
        "top-left": [],
        "top-right": [],
        "bottom-left": [],
        "bottom-right": []
      };
      const GAP_SIZE = 16;
      let seed = 1;
      const notify = function(options = {}, context = null) {
        if (!isClient$1)
          return { close: () => void 0 };
        if (typeof options === "string" || vue.isVNode(options)) {
          options = { message: options };
        }
        const position2 = options.position || "top-right";
        let verticalOffset = options.offset || 0;
        notifications[position2].forEach(({ vm: vm2 }) => {
          var _a2;
          verticalOffset += (((_a2 = vm2.el) == null ? void 0 : _a2.offsetHeight) || 0) + GAP_SIZE;
        });
        verticalOffset += GAP_SIZE;
        const id = `notification_${seed++}`;
        const userOnClose = options.onClose;
        const props = {
          ...options,
          offset: verticalOffset,
          id,
          onClose: () => {
            close(id, position2, userOnClose);
          }
        };
        let appendTo = document.body;
        if (isElement$1(options.appendTo)) {
          appendTo = options.appendTo;
        } else if (isString$2(options.appendTo)) {
          appendTo = document.querySelector(options.appendTo);
        }
        if (!isElement$1(appendTo)) {
          appendTo = document.body;
        }
        const container = document.createElement("div");
        const vm = vue.createVNode(NotificationConstructor, props, vue.isVNode(props.message) ? {
          default: () => props.message
        } : null);
        vm.appContext = context != null ? context : notify._context;
        vm.props.onDestroy = () => {
          vue.render(null, container);
        };
        vue.render(vm, container);
        notifications[position2].push({ vm });
        appendTo.appendChild(container.firstElementChild);
        return {
          close: () => {
            vm.component.exposed.visible.value = false;
          }
        };
      };
      notificationTypes.forEach((type3) => {
        notify[type3] = (options = {}) => {
          if (typeof options === "string" || vue.isVNode(options)) {
            options = {
              message: options
            };
          }
          return notify({
            ...options,
            type: type3
          });
        };
      });
      function close(id, position2, userOnClose) {
        const orientedNotifications = notifications[position2];
        const idx = orientedNotifications.findIndex(({ vm: vm2 }) => {
          var _a2;
          return ((_a2 = vm2.component) == null ? void 0 : _a2.props.id) === id;
        });
        if (idx === -1)
          return;
        const { vm } = orientedNotifications[idx];
        if (!vm)
          return;
        userOnClose == null ? void 0 : userOnClose(vm);
        const removedHeight = vm.el.offsetHeight;
        const verticalPos = position2.split("-")[0];
        orientedNotifications.splice(idx, 1);
        const len = orientedNotifications.length;
        if (len < 1)
          return;
        for (let i2 = idx; i2 < len; i2++) {
          const { el, component } = orientedNotifications[i2].vm;
          const pos = Number.parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;
          component.props.offset = pos;
        }
      }
      function closeAll() {
        for (const orientedNotifications of Object.values(notifications)) {
          orientedNotifications.forEach(({ vm }) => {
            vm.component.exposed.visible.value = false;
          });
        }
      }
      notify.closeAll = closeAll;
      notify._context = null;
      const ElNotification = withInstallFunction(notify, "$notify");
      const _hoisted_1$3 = { class: "express-order-item" };
      const _hoisted_2$3 = { "font-bold": "" };
      const _hoisted_3$3 = { class: "express-order-item__value" };
      const _sfc_main$3 = /* @__PURE__ */ vue.defineComponent({
        __name: "expressOrderItem",
        props: {
          value: {},
          label: {}
        },
        setup(__props) {
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$3, [
              vue.createElementVNode("div", _hoisted_2$3, vue.toDisplayString(_ctx.label), 1),
              vue.createElementVNode("div", _hoisted_3$3, [
                Array.isArray(_ctx.value) ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, { key: 0 }, vue.renderList(_ctx.value, (item, index2) => {
                  return vue.openBlock(), vue.createElementBlock("span", { key: index2 }, vue.toDisplayString(item), 1);
                }), 128)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                  vue.createTextVNode(vue.toDisplayString(_ctx.value), 1)
                ], 64))
              ])
            ]);
          };
        }
      });
      const _export_sfc = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const __unplugin_components_0 = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-36b4850e"]]);
      function tryOnScopeDispose(fn2) {
        if (vue.getCurrentScope()) {
          vue.onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function createEventHook() {
        const fns = /* @__PURE__ */ new Set();
        const off = (fn2) => {
          fns.delete(fn2);
        };
        const on2 = (fn2) => {
          fns.add(fn2);
          const offFn = () => off(fn2);
          tryOnScopeDispose(offFn);
          return {
            off: offFn
          };
        };
        const trigger = (...args) => {
          return Promise.all(Array.from(fns).map((fn2) => fn2(...args)));
        };
        return {
          on: on2,
          off,
          trigger
        };
      }
      function toValue(r2) {
        return typeof r2 === "function" ? r2() : vue.unref(r2);
      }
      const isClient = typeof window !== "undefined" && typeof document !== "undefined";
      typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
      const toString = Object.prototype.toString;
      const isObject$1 = (val) => toString.call(val) === "[object Object]";
      const noop$4 = () => {
      };
      function createFilterWrapper(filter, fn2) {
        function wrapper(...args) {
          return new Promise((resolve, reject) => {
            Promise.resolve(filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve).catch(reject);
          });
        }
        return wrapper;
      }
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop$4;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop$4;
        };
        const filter = (invoke2) => {
          const duration = toValue(ms);
          const maxDuration = toValue(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke2());
          }
          return new Promise((resolve, reject) => {
            lastRejector = options.rejectOnCancel ? reject : resolve;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve(invoke2());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve(invoke2());
            }, duration);
          });
        };
        return filter;
      }
      function throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {
        let lastExec = 0;
        let timer;
        let isLeading = true;
        let lastRejector = noop$4;
        let lastValue;
        const clear = () => {
          if (timer) {
            clearTimeout(timer);
            timer = void 0;
            lastRejector();
            lastRejector = noop$4;
          }
        };
        const filter = (_invoke) => {
          const duration = toValue(ms);
          const elapsed = Date.now() - lastExec;
          const invoke2 = () => {
            return lastValue = _invoke();
          };
          clear();
          if (duration <= 0) {
            lastExec = Date.now();
            return invoke2();
          }
          if (elapsed > duration && (leading || !isLeading)) {
            lastExec = Date.now();
            invoke2();
          } else if (trailing) {
            lastValue = new Promise((resolve, reject) => {
              lastRejector = rejectOnCancel ? reject : resolve;
              timer = setTimeout(() => {
                lastExec = Date.now();
                isLeading = true;
                resolve(invoke2());
                clear();
              }, Math.max(0, duration - elapsed));
            });
          }
          if (!leading && !timer)
            timer = setTimeout(() => isLeading = true, duration);
          isLeading = false;
          return lastValue;
        };
        return filter;
      }
      function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
        return new Promise((resolve, reject) => {
          if (throwOnTimeout)
            setTimeout(() => reject(reason), ms);
          else
            setTimeout(resolve, ms);
        });
      }
      function containsProp(obj, ...props) {
        return props.some((k2) => k2 in obj);
      }
      function getLifeCycleTarget(target) {
        return target || vue.getCurrentInstance();
      }
      function toRef(...args) {
        if (args.length !== 1)
          return vue.toRef(...args);
        const r2 = args[0];
        return typeof r2 === "function" ? vue.readonly(vue.customRef(() => ({ get: r2, set: noop$4 }))) : vue.ref(r2);
      }
      function useDebounceFn(fn2, ms = 200, options = {}) {
        return createFilterWrapper(
          debounceFilter(ms, options),
          fn2
        );
      }
      function useThrottleFn(fn2, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
        return createFilterWrapper(
          throttleFilter(ms, trailing, leading, rejectOnCancel),
          fn2
        );
      }
      function tryOnMounted(fn2, sync = true, target) {
        const instance = getLifeCycleTarget();
        if (instance)
          vue.onMounted(fn2, target);
        else if (sync)
          fn2();
        else
          vue.nextTick(fn2);
      }
      function createUntil(r2, isNot = false) {
        function toMatch(condition, { flush = "sync", deep = false, timeout, throwOnTimeout } = {}) {
          let stop = null;
          const watcher = new Promise((resolve) => {
            stop = vue.watch(
              r2,
              (v2) => {
                if (condition(v2) !== isNot) {
                  stop == null ? void 0 : stop();
                  resolve(v2);
                }
              },
              {
                flush,
                deep,
                immediate: true
              }
            );
          });
          const promises = [watcher];
          if (timeout != null) {
            promises.push(
              promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r2)).finally(() => stop == null ? void 0 : stop())
            );
          }
          return Promise.race(promises);
        }
        function toBe(value, options) {
          if (!vue.isRef(value))
            return toMatch((v2) => v2 === value, options);
          const { flush = "sync", deep = false, timeout, throwOnTimeout } = options != null ? options : {};
          let stop = null;
          const watcher = new Promise((resolve) => {
            stop = vue.watch(
              [r2, value],
              ([v1, v2]) => {
                if (isNot !== (v1 === v2)) {
                  stop == null ? void 0 : stop();
                  resolve(v1);
                }
              },
              {
                flush,
                deep,
                immediate: true
              }
            );
          });
          const promises = [watcher];
          if (timeout != null) {
            promises.push(
              promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r2)).finally(() => {
                stop == null ? void 0 : stop();
                return toValue(r2);
              })
            );
          }
          return Promise.race(promises);
        }
        function toBeTruthy(options) {
          return toMatch((v2) => Boolean(v2), options);
        }
        function toBeNull(options) {
          return toBe(null, options);
        }
        function toBeUndefined(options) {
          return toBe(void 0, options);
        }
        function toBeNaN(options) {
          return toMatch(Number.isNaN, options);
        }
        function toContains(value, options) {
          return toMatch((v2) => {
            const array = Array.from(v2);
            return array.includes(value) || array.includes(toValue(value));
          }, options);
        }
        function changed(options) {
          return changedTimes(1, options);
        }
        function changedTimes(n2 = 1, options) {
          let count = -1;
          return toMatch(() => {
            count += 1;
            return count >= n2;
          }, options);
        }
        if (Array.isArray(toValue(r2))) {
          const instance = {
            toMatch,
            toContains,
            changed,
            changedTimes,
            get not() {
              return createUntil(r2, !isNot);
            }
          };
          return instance;
        } else {
          const instance = {
            toMatch,
            toBe,
            toBeTruthy,
            toBeNull,
            toBeNaN,
            toBeUndefined,
            changed,
            changedTimes,
            get not() {
              return createUntil(r2, !isNot);
            }
          };
          return instance;
        }
      }
      function until(r2) {
        return createUntil(r2);
      }
      function useTimeoutFn(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = vue.ref(false);
        let timer = null;
        function clear() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear();
        }
        function start(...args) {
          clear();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, toValue(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient)
            start();
        }
        tryOnScopeDispose(stop);
        return {
          isPending: vue.readonly(isPending),
          start,
          stop
        };
      }
      function useToggle(initialValue = false, options = {}) {
        const {
          truthyValue = true,
          falsyValue = false
        } = options;
        const valueIsRef = vue.isRef(initialValue);
        const _value = vue.ref(initialValue);
        function toggle(value) {
          if (arguments.length) {
            _value.value = value;
            return _value.value;
          } else {
            const truthy = toValue(truthyValue);
            _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;
            return _value.value;
          }
        }
        if (valueIsRef)
          return toggle;
        else
          return [_value, toggle];
      }
      function unrefElement(elRef) {
        var _a2;
        const plain = toValue(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      function useEventListener(...args) {
        let target;
        let events2;
        let listeners;
        let options;
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
          [events2, listeners, options] = args;
          target = defaultWindow;
        } else {
          [target, events2, listeners, options] = args;
        }
        if (!target)
          return noop$4;
        if (!Array.isArray(events2))
          events2 = [events2];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup2 = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = vue.watch(
          () => [unrefElement(target), toValue(options)],
          ([el, options2]) => {
            cleanup2();
            if (!el)
              return;
            const optionsClone = isObject$1(options2) ? { ...options2 } : options2;
            cleanups.push(
              ...events2.flatMap((event) => {
                return listeners.map((listener) => register(el, event, listener, optionsClone));
              })
            );
          },
          { immediate: true, flush: "post" }
        );
        const stop = () => {
          stopWatch();
          cleanup2();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      function useMounted() {
        const isMounted = vue.ref(false);
        if (vue.getCurrentInstance()) {
          vue.onMounted(() => {
            isMounted.value = true;
          });
        }
        return isMounted;
      }
      function useSupported(callback) {
        const isMounted = useMounted();
        return vue.computed(() => {
          isMounted.value;
          return Boolean(callback());
        });
      }
      function useMutationObserver(target, callback, options = {}) {
        const { window: window2 = defaultWindow, ...mutationOptions } = options;
        let observer;
        const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
        const cleanup2 = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = vue.watch(
          () => unrefElement(target),
          (el) => {
            cleanup2();
            if (isSupported.value && window2 && el) {
              observer = new MutationObserver(callback);
              observer.observe(el, mutationOptions);
            }
          },
          { immediate: true }
        );
        const takeRecords = () => {
          return observer == null ? void 0 : observer.takeRecords();
        };
        const stop = () => {
          cleanup2();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop,
          takeRecords
        };
      }
      function useResizeObserver(target, callback, options = {}) {
        const { window: window2 = defaultWindow, ...observerOptions } = options;
        let observer;
        const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
        const cleanup2 = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const targets = vue.computed(() => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]);
        const stopWatch = vue.watch(
          targets,
          (els) => {
            cleanup2();
            if (isSupported.value && window2) {
              observer = new ResizeObserver(callback);
              for (const _el of els)
                _el && observer.observe(_el, observerOptions);
            }
          },
          { immediate: true, flush: "post", deep: true }
        );
        const stop = () => {
          cleanup2();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      function useElementBounding(target, options = {}) {
        const {
          reset = true,
          windowResize = true,
          windowScroll = true,
          immediate = true
        } = options;
        const height = vue.ref(0);
        const bottom = vue.ref(0);
        const left = vue.ref(0);
        const right = vue.ref(0);
        const top = vue.ref(0);
        const width = vue.ref(0);
        const x2 = vue.ref(0);
        const y2 = vue.ref(0);
        function update() {
          const el = unrefElement(target);
          if (!el) {
            if (reset) {
              height.value = 0;
              bottom.value = 0;
              left.value = 0;
              right.value = 0;
              top.value = 0;
              width.value = 0;
              x2.value = 0;
              y2.value = 0;
            }
            return;
          }
          const rect = el.getBoundingClientRect();
          height.value = rect.height;
          bottom.value = rect.bottom;
          left.value = rect.left;
          right.value = rect.right;
          top.value = rect.top;
          width.value = rect.width;
          x2.value = rect.x;
          y2.value = rect.y;
        }
        useResizeObserver(target, update);
        vue.watch(() => unrefElement(target), (ele) => !ele && update());
        useMutationObserver(target, update, {
          attributeFilter: ["style", "class"]
        });
        if (windowScroll)
          useEventListener("scroll", update, { capture: true, passive: true });
        if (windowResize)
          useEventListener("resize", update, { passive: true });
        tryOnMounted(() => {
          if (immediate)
            update();
        });
        return {
          height,
          bottom,
          left,
          right,
          top,
          width,
          x: x2,
          y: y2,
          update
        };
      }
      const payloadMapping = {
        json: "application/json",
        text: "text/plain"
      };
      function isFetchOptions(obj) {
        return obj && containsProp(obj, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError", "fetch", "updateDataOnError");
      }
      function isAbsoluteURL(url) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      }
      function headersToObject(headers) {
        if (typeof Headers !== "undefined" && headers instanceof Headers)
          return Object.fromEntries([...headers.entries()]);
        return headers;
      }
      function combineCallbacks(combination, ...callbacks) {
        if (combination === "overwrite") {
          return async (ctx) => {
            const callback = callbacks[callbacks.length - 1];
            if (callback)
              return { ...ctx, ...await callback(ctx) };
            return ctx;
          };
        } else {
          return async (ctx) => {
            for (const callback of callbacks) {
              if (callback)
                ctx = { ...ctx, ...await callback(ctx) };
            }
            return ctx;
          };
        }
      }
      function createFetch(config = {}) {
        const _combination = config.combination || "chain";
        const _options = config.options || {};
        const _fetchOptions = config.fetchOptions || {};
        function useFactoryFetch(url, ...args) {
          const computedUrl = vue.computed(() => {
            const baseUrl = toValue(config.baseUrl);
            const targetUrl = toValue(url);
            return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;
          });
          let options = _options;
          let fetchOptions = _fetchOptions;
          if (args.length > 0) {
            if (isFetchOptions(args[0])) {
              options = {
                ...options,
                ...args[0],
                beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),
                afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),
                onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)
              };
            } else {
              fetchOptions = {
                ...fetchOptions,
                ...args[0],
                headers: {
                  ...headersToObject(fetchOptions.headers) || {},
                  ...headersToObject(args[0].headers) || {}
                }
              };
            }
          }
          if (args.length > 1 && isFetchOptions(args[1])) {
            options = {
              ...options,
              ...args[1],
              beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),
              afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),
              onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)
            };
          }
          return useFetch(computedUrl, fetchOptions, options);
        }
        return useFactoryFetch;
      }
      function useFetch(url, ...args) {
        var _a2;
        const supportsAbort = typeof AbortController === "function";
        let fetchOptions = {};
        let options = {
          immediate: true,
          refetch: false,
          timeout: 0,
          updateDataOnError: false
        };
        const config = {
          method: "GET",
          type: "text",
          payload: void 0
        };
        if (args.length > 0) {
          if (isFetchOptions(args[0]))
            options = { ...options, ...args[0] };
          else
            fetchOptions = args[0];
        }
        if (args.length > 1) {
          if (isFetchOptions(args[1]))
            options = { ...options, ...args[1] };
        }
        const {
          fetch = (_a2 = defaultWindow) == null ? void 0 : _a2.fetch,
          initialData,
          timeout
        } = options;
        const responseEvent = createEventHook();
        const errorEvent = createEventHook();
        const finallyEvent = createEventHook();
        const isFinished = vue.ref(false);
        const isFetching = vue.ref(false);
        const aborted = vue.ref(false);
        const statusCode = vue.ref(null);
        const response = vue.shallowRef(null);
        const error = vue.shallowRef(null);
        const data = vue.shallowRef(initialData || null);
        const canAbort = vue.computed(() => supportsAbort && isFetching.value);
        let controller;
        let timer;
        const abort = () => {
          if (supportsAbort) {
            controller == null ? void 0 : controller.abort();
            controller = new AbortController();
            controller.signal.onabort = () => aborted.value = true;
            fetchOptions = {
              ...fetchOptions,
              signal: controller.signal
            };
          }
        };
        const loading = (isLoading) => {
          isFetching.value = isLoading;
          isFinished.value = !isLoading;
        };
        if (timeout)
          timer = useTimeoutFn(abort, timeout, { immediate: false });
        let executeCounter = 0;
        const execute = async (throwOnFailed = false) => {
          var _a22, _b;
          abort();
          loading(true);
          error.value = null;
          statusCode.value = null;
          aborted.value = false;
          executeCounter += 1;
          const currentExecuteCounter = executeCounter;
          const defaultFetchOptions = {
            method: config.method,
            headers: {}
          };
          if (config.payload) {
            const headers = headersToObject(defaultFetchOptions.headers);
            const payload = toValue(config.payload);
            if (!config.payloadType && payload && Object.getPrototypeOf(payload) === Object.prototype && !(payload instanceof FormData))
              config.payloadType = "json";
            if (config.payloadType)
              headers["Content-Type"] = (_a22 = payloadMapping[config.payloadType]) != null ? _a22 : config.payloadType;
            defaultFetchOptions.body = config.payloadType === "json" ? JSON.stringify(payload) : payload;
          }
          let isCanceled = false;
          const context = {
            url: toValue(url),
            options: {
              ...defaultFetchOptions,
              ...fetchOptions
            },
            cancel: () => {
              isCanceled = true;
            }
          };
          if (options.beforeFetch)
            Object.assign(context, await options.beforeFetch(context));
          if (isCanceled || !fetch) {
            loading(false);
            return Promise.resolve(null);
          }
          let responseData = null;
          if (timer)
            timer.start();
          return fetch(
            context.url,
            {
              ...defaultFetchOptions,
              ...context.options,
              headers: {
                ...headersToObject(defaultFetchOptions.headers),
                ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)
              }
            }
          ).then(async (fetchResponse) => {
            response.value = fetchResponse;
            statusCode.value = fetchResponse.status;
            responseData = await fetchResponse.clone()[config.type]();
            if (!fetchResponse.ok) {
              data.value = initialData || null;
              throw new Error(fetchResponse.statusText);
            }
            if (options.afterFetch) {
              ({ data: responseData } = await options.afterFetch({
                data: responseData,
                response: fetchResponse
              }));
            }
            data.value = responseData;
            responseEvent.trigger(fetchResponse);
            return fetchResponse;
          }).catch(async (fetchError) => {
            let errorData = fetchError.message || fetchError.name;
            if (options.onFetchError) {
              ({ error: errorData, data: responseData } = await options.onFetchError({
                data: responseData,
                error: fetchError,
                response: response.value
              }));
            }
            error.value = errorData;
            if (options.updateDataOnError)
              data.value = responseData;
            errorEvent.trigger(fetchError);
            if (throwOnFailed)
              throw fetchError;
            return null;
          }).finally(() => {
            if (currentExecuteCounter === executeCounter)
              loading(false);
            if (timer)
              timer.stop();
            finallyEvent.trigger(null);
          });
        };
        const refetch = toRef(options.refetch);
        vue.watch(
          [
            refetch,
            toRef(url)
          ],
          ([refetch2]) => refetch2 && execute(),
          { deep: true }
        );
        const shell = {
          isFinished,
          statusCode,
          response,
          error,
          data,
          isFetching,
          canAbort,
          aborted,
          abort,
          execute,
          onFetchResponse: responseEvent.on,
          onFetchError: errorEvent.on,
          onFetchFinally: finallyEvent.on,
          // method
          get: setMethod("GET"),
          put: setMethod("PUT"),
          post: setMethod("POST"),
          delete: setMethod("DELETE"),
          patch: setMethod("PATCH"),
          head: setMethod("HEAD"),
          options: setMethod("OPTIONS"),
          // type
          json: setType("json"),
          text: setType("text"),
          blob: setType("blob"),
          arrayBuffer: setType("arrayBuffer"),
          formData: setType("formData")
        };
        function setMethod(method) {
          return (payload, payloadType) => {
            if (!isFetching.value) {
              config.method = method;
              config.payload = payload;
              config.payloadType = payloadType;
              if (vue.isRef(config.payload)) {
                vue.watch(
                  [
                    refetch,
                    toRef(config.payload)
                  ],
                  ([refetch2]) => refetch2 && execute(),
                  { deep: true }
                );
              }
              return {
                ...shell,
                then(onFulfilled, onRejected) {
                  return waitUntilFinished().then(onFulfilled, onRejected);
                }
              };
            }
            return void 0;
          };
        }
        function waitUntilFinished() {
          return new Promise((resolve, reject) => {
            until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));
          });
        }
        function setType(type3) {
          return () => {
            if (!isFetching.value) {
              config.type = type3;
              return {
                ...shell,
                then(onFulfilled, onRejected) {
                  return waitUntilFinished().then(onFulfilled, onRejected);
                }
              };
            }
            return void 0;
          };
        }
        if (options.immediate)
          Promise.resolve().then(() => execute());
        return {
          ...shell,
          then(onFulfilled, onRejected) {
            return waitUntilFinished().then(onFulfilled, onRejected);
          }
        };
      }
      function joinPaths(start, end) {
        if (!start.endsWith("/") && !end.startsWith("/"))
          return `${start}/${end}`;
        return `${start}${end}`;
      }
      const ARRIVED_STATE_THRESHOLD_PIXELS = 1;
      function useScroll(element, options = {}) {
        const {
          throttle: throttle2 = 0,
          idle = 200,
          onStop = noop$4,
          onScroll = noop$4,
          offset = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          },
          eventListenerOptions = {
            capture: false,
            passive: true
          },
          behavior = "auto",
          window: window2 = defaultWindow
        } = options;
        const internalX = vue.ref(0);
        const internalY = vue.ref(0);
        const x2 = vue.computed({
          get() {
            return internalX.value;
          },
          set(x22) {
            scrollTo2(x22, void 0);
          }
        });
        const y2 = vue.computed({
          get() {
            return internalY.value;
          },
          set(y22) {
            scrollTo2(void 0, y22);
          }
        });
        function scrollTo2(_x, _y) {
          var _a2, _b, _c;
          if (!window2)
            return;
          const _element = toValue(element);
          if (!_element)
            return;
          (_c = _element instanceof Document ? window2.document.body : _element) == null ? void 0 : _c.scrollTo({
            top: (_a2 = toValue(_y)) != null ? _a2 : y2.value,
            left: (_b = toValue(_x)) != null ? _b : x2.value,
            behavior: toValue(behavior)
          });
        }
        const isScrolling = vue.ref(false);
        const arrivedState = vue.reactive({
          left: true,
          right: false,
          top: true,
          bottom: false
        });
        const directions = vue.reactive({
          left: false,
          right: false,
          top: false,
          bottom: false
        });
        const onScrollEnd = (e2) => {
          if (!isScrolling.value)
            return;
          isScrolling.value = false;
          directions.left = false;
          directions.right = false;
          directions.top = false;
          directions.bottom = false;
          onStop(e2);
        };
        const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle2 + idle);
        const setArrivedState = (target) => {
          var _a2;
          if (!window2)
            return;
          const el = target.document ? target.document.documentElement : (_a2 = target.documentElement) != null ? _a2 : target;
          const { display, flexDirection } = getComputedStyle(el);
          const scrollLeft = el.scrollLeft;
          directions.left = scrollLeft < internalX.value;
          directions.right = scrollLeft > internalX.value;
          const left = Math.abs(scrollLeft) <= 0 + (offset.left || 0);
          const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
          if (display === "flex" && flexDirection === "row-reverse") {
            arrivedState.left = right;
            arrivedState.right = left;
          } else {
            arrivedState.left = left;
            arrivedState.right = right;
          }
          internalX.value = scrollLeft;
          let scrollTop = el.scrollTop;
          if (target === window2.document && !scrollTop)
            scrollTop = window2.document.body.scrollTop;
          directions.top = scrollTop < internalY.value;
          directions.bottom = scrollTop > internalY.value;
          const top = Math.abs(scrollTop) <= 0 + (offset.top || 0);
          const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
          if (display === "flex" && flexDirection === "column-reverse") {
            arrivedState.top = bottom;
            arrivedState.bottom = top;
          } else {
            arrivedState.top = top;
            arrivedState.bottom = bottom;
          }
          internalY.value = scrollTop;
        };
        const onScrollHandler = (e2) => {
          var _a2;
          if (!window2)
            return;
          const eventTarget = (_a2 = e2.target.documentElement) != null ? _a2 : e2.target;
          setArrivedState(eventTarget);
          isScrolling.value = true;
          onScrollEndDebounced(e2);
          onScroll(e2);
        };
        useEventListener(
          element,
          "scroll",
          throttle2 ? useThrottleFn(onScrollHandler, throttle2, true, false) : onScrollHandler,
          eventListenerOptions
        );
        tryOnMounted(() => {
          const _element = toValue(element);
          if (!_element)
            return;
          setArrivedState(_element);
        });
        useEventListener(
          element,
          "scrollend",
          onScrollEnd,
          eventListenerOptions
        );
        return {
          x: x2,
          y: y2,
          isScrolling,
          arrivedState,
          directions,
          measure() {
            const _element = toValue(element);
            if (window2 && _element)
              setArrivedState(_element);
          }
        };
      }
      function useSpeechSynthesis(text, options = {}) {
        const {
          pitch = 1,
          rate = 1,
          volume = 1,
          window: window2 = defaultWindow
        } = options;
        const synth = window2 && window2.speechSynthesis;
        const isSupported = useSupported(() => synth);
        const isPlaying = vue.ref(false);
        const status = vue.ref("init");
        const spokenText = toRef(text || "");
        const lang = toRef(options.lang || "en-US");
        const error = vue.shallowRef(void 0);
        const toggle = (value = !isPlaying.value) => {
          isPlaying.value = value;
        };
        const bindEventsForUtterance = (utterance2) => {
          utterance2.lang = toValue(lang);
          utterance2.voice = toValue(options.voice) || null;
          utterance2.pitch = toValue(pitch);
          utterance2.rate = toValue(rate);
          utterance2.volume = volume;
          utterance2.onstart = () => {
            isPlaying.value = true;
            status.value = "play";
          };
          utterance2.onpause = () => {
            isPlaying.value = false;
            status.value = "pause";
          };
          utterance2.onresume = () => {
            isPlaying.value = true;
            status.value = "play";
          };
          utterance2.onend = () => {
            isPlaying.value = false;
            status.value = "end";
          };
          utterance2.onerror = (event) => {
            error.value = event;
          };
        };
        const utterance = vue.computed(() => {
          isPlaying.value = false;
          status.value = "init";
          const newUtterance = new SpeechSynthesisUtterance(spokenText.value);
          bindEventsForUtterance(newUtterance);
          return newUtterance;
        });
        const speak2 = () => {
          synth.cancel();
          utterance && synth.speak(utterance.value);
        };
        const stop = () => {
          synth.cancel();
          isPlaying.value = false;
        };
        if (isSupported.value) {
          bindEventsForUtterance(utterance.value);
          vue.watch(lang, (lang2) => {
            if (utterance.value && !isPlaying.value)
              utterance.value.lang = lang2;
          });
          if (options.voice) {
            vue.watch(options.voice, () => {
              synth.cancel();
            });
          }
          vue.watch(isPlaying, () => {
            if (isPlaying.value)
              synth.resume();
            else
              synth.pause();
          });
        }
        tryOnScopeDispose(() => {
          isPlaying.value = false;
        });
        return {
          isSupported,
          isPlaying,
          status,
          utterance,
          error,
          stop,
          toggle,
          speak: speak2
        };
      }
      /*!
       * cookie
       * Copyright(c) 2012-2014 Roman Shtylman
       * Copyright(c) 2015 Douglas Christopher Wilson
       * MIT Licensed
       */
      var parse_1 = parse$3;
      var serialize_1 = serialize$1;
      var __toString = Object.prototype.toString;
      var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
      function parse$3(str, options) {
        if (typeof str !== "string") {
          throw new TypeError("argument str must be a string");
        }
        var obj = {};
        var opt = options || {};
        var dec = opt.decode || decode$1;
        var index2 = 0;
        while (index2 < str.length) {
          var eqIdx = str.indexOf("=", index2);
          if (eqIdx === -1) {
            break;
          }
          var endIdx = str.indexOf(";", index2);
          if (endIdx === -1) {
            endIdx = str.length;
          } else if (endIdx < eqIdx) {
            index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
          }
          var key = str.slice(index2, eqIdx).trim();
          if (void 0 === obj[key]) {
            var val = str.slice(eqIdx + 1, endIdx).trim();
            if (val.charCodeAt(0) === 34) {
              val = val.slice(1, -1);
            }
            obj[key] = tryDecode(val, dec);
          }
          index2 = endIdx + 1;
        }
        return obj;
      }
      function serialize$1(name, val, options) {
        var opt = options || {};
        var enc = opt.encode || encode$1;
        if (typeof enc !== "function") {
          throw new TypeError("option encode is invalid");
        }
        if (!fieldContentRegExp.test(name)) {
          throw new TypeError("argument name is invalid");
        }
        var value = enc(val);
        if (value && !fieldContentRegExp.test(value)) {
          throw new TypeError("argument val is invalid");
        }
        var str = name + "=" + value;
        if (null != opt.maxAge) {
          var maxAge = opt.maxAge - 0;
          if (isNaN(maxAge) || !isFinite(maxAge)) {
            throw new TypeError("option maxAge is invalid");
          }
          str += "; Max-Age=" + Math.floor(maxAge);
        }
        if (opt.domain) {
          if (!fieldContentRegExp.test(opt.domain)) {
            throw new TypeError("option domain is invalid");
          }
          str += "; Domain=" + opt.domain;
        }
        if (opt.path) {
          if (!fieldContentRegExp.test(opt.path)) {
            throw new TypeError("option path is invalid");
          }
          str += "; Path=" + opt.path;
        }
        if (opt.expires) {
          var expires = opt.expires;
          if (!isDate$1(expires) || isNaN(expires.valueOf())) {
            throw new TypeError("option expires is invalid");
          }
          str += "; Expires=" + expires.toUTCString();
        }
        if (opt.httpOnly) {
          str += "; HttpOnly";
        }
        if (opt.secure) {
          str += "; Secure";
        }
        if (opt.partitioned) {
          str += "; Partitioned";
        }
        if (opt.priority) {
          var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
          switch (priority) {
            case "low":
              str += "; Priority=Low";
              break;
            case "medium":
              str += "; Priority=Medium";
              break;
            case "high":
              str += "; Priority=High";
              break;
            default:
              throw new TypeError("option priority is invalid");
          }
        }
        if (opt.sameSite) {
          var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
          switch (sameSite) {
            case true:
              str += "; SameSite=Strict";
              break;
            case "lax":
              str += "; SameSite=Lax";
              break;
            case "strict":
              str += "; SameSite=Strict";
              break;
            case "none":
              str += "; SameSite=None";
              break;
            default:
              throw new TypeError("option sameSite is invalid");
          }
        }
        return str;
      }
      function decode$1(str) {
        return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
      }
      function encode$1(val) {
        return encodeURIComponent(val);
      }
      function isDate$1(val) {
        return __toString.call(val) === "[object Date]" || val instanceof Date;
      }
      function tryDecode(str, decode2) {
        try {
          return decode2(str);
        } catch (e2) {
          return str;
        }
      }
      function hasDocumentCookie() {
        const testingValue = typeof global === "undefined" ? void 0 : global.TEST_HAS_DOCUMENT_COOKIE;
        if (typeof testingValue === "boolean") {
          return testingValue;
        }
        return typeof document === "object" && typeof document.cookie === "string";
      }
      function parseCookies(cookies) {
        if (typeof cookies === "string") {
          return parse_1(cookies);
        } else if (typeof cookies === "object" && cookies !== null) {
          return cookies;
        } else {
          return {};
        }
      }
      function readCookie(value, options = {}) {
        const cleanValue = cleanupCookieValue(value);
        if (!options.doNotParse) {
          try {
            return JSON.parse(cleanValue);
          } catch (e2) {
          }
        }
        return value;
      }
      function cleanupCookieValue(value) {
        if (value && value[0] === "j" && value[1] === ":") {
          return value.substr(2);
        }
        return value;
      }
      class Cookies {
        constructor(cookies, defaultSetOptions = {}) {
          this.changeListeners = [];
          this.HAS_DOCUMENT_COOKIE = false;
          this.update = () => {
            if (!this.HAS_DOCUMENT_COOKIE) {
              return;
            }
            const previousCookies = this.cookies;
            this.cookies = parse_1(document.cookie);
            this._checkChanges(previousCookies);
          };
          const domCookies = typeof document === "undefined" ? "" : document.cookie;
          this.cookies = parseCookies(cookies || domCookies);
          this.defaultSetOptions = defaultSetOptions;
          this.HAS_DOCUMENT_COOKIE = hasDocumentCookie();
        }
        _emitChange(params) {
          for (let i2 = 0; i2 < this.changeListeners.length; ++i2) {
            this.changeListeners[i2](params);
          }
        }
        _checkChanges(previousCookies) {
          const names2 = new Set(Object.keys(previousCookies).concat(Object.keys(this.cookies)));
          names2.forEach((name) => {
            if (previousCookies[name] !== this.cookies[name]) {
              this._emitChange({
                name,
                value: readCookie(this.cookies[name])
              });
            }
          });
        }
        _startPolling() {
          this.pollingInterval = setInterval(this.update, 300);
        }
        _stopPolling() {
          if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
          }
        }
        get(name, options = {}) {
          if (!options.doNotUpdate) {
            this.update();
          }
          return readCookie(this.cookies[name], options);
        }
        getAll(options = {}) {
          if (!options.doNotUpdate) {
            this.update();
          }
          const result = {};
          for (let name in this.cookies) {
            result[name] = readCookie(this.cookies[name], options);
          }
          return result;
        }
        set(name, value, options) {
          if (options) {
            options = Object.assign(Object.assign({}, this.defaultSetOptions), options);
          } else {
            options = this.defaultSetOptions;
          }
          const stringValue = typeof value === "string" ? value : JSON.stringify(value);
          this.cookies = Object.assign(Object.assign({}, this.cookies), { [name]: stringValue });
          if (this.HAS_DOCUMENT_COOKIE) {
            document.cookie = serialize_1(name, stringValue, options);
          }
          this._emitChange({ name, value, options });
        }
        remove(name, options) {
          const finalOptions = options = Object.assign(Object.assign(Object.assign({}, this.defaultSetOptions), options), { expires: new Date(1970, 1, 1, 0, 0, 1), maxAge: 0 });
          this.cookies = Object.assign({}, this.cookies);
          delete this.cookies[name];
          if (this.HAS_DOCUMENT_COOKIE) {
            document.cookie = serialize_1(name, "", finalOptions);
          }
          this._emitChange({ name, value: void 0, options });
        }
        addChangeListener(callback) {
          this.changeListeners.push(callback);
          if (this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 1) {
            if (typeof window === "object" && "cookieStore" in window) {
              window.cookieStore.addEventListener("change", this.update);
            } else {
              this._startPolling();
            }
          }
        }
        removeChangeListener(callback) {
          const idx = this.changeListeners.indexOf(callback);
          if (idx >= 0) {
            this.changeListeners.splice(idx, 1);
          }
          if (this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 0) {
            if (typeof window === "object" && "cookieStore" in window) {
              window.cookieStore.removeEventListener("change", this.update);
            } else {
              this._stopPolling();
            }
          }
        }
      }
      function useCookies(dependencies, { doNotParse = false, autoUpdateDependencies = false } = {}, cookies = new Cookies()) {
        const watchingDependencies = autoUpdateDependencies ? [...dependencies || []] : dependencies;
        let previousCookies = cookies.getAll({ doNotParse: true });
        const touches = vue.ref(0);
        const onChange = () => {
          const newCookies = cookies.getAll({ doNotParse: true });
          if (shouldUpdate(
            watchingDependencies || null,
            newCookies,
            previousCookies
          ))
            touches.value++;
          previousCookies = newCookies;
        };
        cookies.addChangeListener(onChange);
        tryOnScopeDispose(() => {
          cookies.removeChangeListener(onChange);
        });
        return {
          /**
           * Reactive get cookie by name. If **autoUpdateDependencies = true** then it will update watching dependencies
           */
          get: (...args) => {
            if (autoUpdateDependencies && watchingDependencies && !watchingDependencies.includes(args[0]))
              watchingDependencies.push(args[0]);
            touches.value;
            return cookies.get(args[0], { doNotParse, ...args[1] });
          },
          /**
           * Reactive get all cookies
           */
          getAll: (...args) => {
            touches.value;
            return cookies.getAll({ doNotParse, ...args[0] });
          },
          set: (...args) => cookies.set(...args),
          remove: (...args) => cookies.remove(...args),
          addChangeListener: (...args) => cookies.addChangeListener(...args),
          removeChangeListener: (...args) => cookies.removeChangeListener(...args)
        };
      }
      function shouldUpdate(dependencies, newCookies, oldCookies) {
        if (!dependencies)
          return true;
        for (const dependency of dependencies) {
          if (newCookies[dependency] !== oldCookies[dependency])
            return true;
        }
        return false;
      }
      const AllExpress = [
        {
          code: "SF",
          id: 505,
          name: "顺丰快递",
          reg_mail_no: "^SF[A-Za-z0-9][0-9]{12}$"
        },
        {
          code: "STO",
          id: 100,
          name: "申通快递",
          reg_mail_no: "^77[0-9]{13}$|^66[0-9]{11}$"
        },
        {
          code: "YUNDA",
          id: 102,
          name: "韵达快递",
          reg_mail_no: "^(312|432|433|318|463|462|319)[0-9]{12}$|^(530|579|800)[0-9]{10}$"
        },
        {
          code: "YTO",
          id: 101,
          name: "圆通快递",
          reg_mail_no: "^YT[A-Za-z0-9][0-9]{12}$"
        },
        {
          code: "DBKD",
          id: 5000000110730,
          name: "德邦快递",
          reg_mail_no: "^DP[A-Za-z0-9]{2}[0-9]{11}$"
        },
        {
          code: "JD",
          id: 5000000110740,
          name: "京东快递",
          reg_mail_no: "^JD[a-zA-Z0-9]{2}[0-9]{11}$"
        },
        {
          code: "JT",
          id: 5000000110750,
          name: "极兔快递",
          reg_mail_no: "^(JT)[0-9]{13}$"
        },
        {
          code: "ZTO",
          id: 500,
          name: "中通快递",
          reg_mail_no: "^(73|74|75|78)[0-9]{12}$"
        },
        {
          code: "CN",
          id: 501,
          name: "菜鸟快递",
          reg_mail_no: "^621[0-9]{12}$"
        },
        {
          code: "BS",
          id: 5000000110760,
          name: "百世快递",
          reg_mail_no: "^55[0-9]{13}$"
        },
        {
          code: "EMS",
          id: 502,
          name: "邮政快递",
          reg_mail_no: "^(1|8|9)[0-9]{12}$|P[A-Za-z0-9]{3}[0-9]{9}$"
        }
      ];
      const useUserStore = pinia.defineStore("user", () => {
        const cookies = useCookies();
        const uid = cookies.get("u_id") || "0";
        const coid = cookies.get("u_co_id") || "0";
        const intercept2 = vue.reactive({
          oIds: [],
          soIds: [],
          lIds: []
        });
        const orderList = vue.ref([]);
        const orderExpressNameList = vue.computed(() => [...new Set(orderList.value.flatMap((a2) => a2[0].afterSale.lcName))]);
        const OrderByExpressNameSelected = vue.ref([]);
        const orderListByFilter = vue.computed(() => orderList.value.filter((v2) => OrderByExpressNameSelected.value.includes(v2[0].afterSale.lcName)));
        const expressRule = vue.ref(AllExpress);
        function getExpress(order) {
          return expressRule.value.find((a2) => new RegExp(a2.reg_mail_no).test(order)) || {
            code: "WZ",
            id: 9999999,
            name: "未知快递",
            reg_mail_no: ""
          };
        }
        const settings = vue.reactive({
          display: {
            filter: {},
            select: []
          },
          prompt: {
            filter: {},
            select: []
          }
        });
        const currentIndex = vue.ref(0);
        const owner_co_id = vue.ref("BF_JST");
        const authorize_co_id = vue.ref("BF_JST");
        function setOwnerCoId(id) {
          owner_co_id.value = id;
        }
        function addOrderItem(item, index2) {
          orderList.value[index2] = item;
        }
        function setAuthorizeCoId(id) {
          authorize_co_id.value = id;
        }
        function setInterceptoIds(oIds) {
          intercept2.oIds = oIds;
        }
        function setInterceptlId(lIds) {
          intercept2.lIds = lIds;
        }
        function setInterceptsoIds(soIds) {
          intercept2.soIds = soIds;
        }
        function increment() {
          currentIndex.value++;
        }
        const expressIsExist = (order) => orderList.value.some((item) => item[0].afterSale.lId === order);
        function isSelect(key, value) {
          if (!settings[key] && !Array.isArray(settings[key]))
            return false;
          return settings[key].select.includes(value);
        }
        function initStore() {
          orderList.value = [];
        }
        return {
          coid,
          uid,
          owner_co_id,
          authorize_co_id,
          setOwnerCoId,
          setAuthorizeCoId,
          currentIndex,
          increment,
          orderList,
          expressRule,
          expressIsExist,
          addOrderItem,
          settings,
          isSelect,
          getExpress,
          OrderByExpressNameSelected,
          orderExpressNameList,
          orderListByFilter,
          intercept: intercept2,
          setInterceptoIds,
          setInterceptlId,
          setInterceptsoIds,
          initStore
        };
      }, {
        persist: {
          storage: localStorage,
          key: "__bf_user_store__",
          paths: ["owner_co_id", "authorize_co_id", "settings"]
        }
      });
      const _hoisted_1$2 = ["data-flag"];
      const _hoisted_2$2 = { "text-center": "" };
      const _hoisted_3$2 = { "flex-1": "" };
      const _sfc_main$2 = /* @__PURE__ */ vue.defineComponent({
        __name: "expressOrder",
        props: {
          orders: {},
          config: {}
        },
        setup(__props) {
          const props = __props;
          const scrollContainer = vue.ref(null);
          const scrollContent = vue.ref(null);
          const { y: y2 } = useScroll(scrollContainer, { behavior: "smooth" });
          function F2(f2, v2) {
            return typeof f2 === "function" ? f2(v2) : "-";
          }
          const { isSelect } = useUserStore();
          vue.watch(() => props.orders, () => {
            vue.nextTick(() => {
              const { height } = useElementBounding(scrollContent.value);
              y2.value = height.value;
            });
          }, {
            deep: true
          });
          return (_ctx, _cache) => {
            const _component_bf_express_order_item = __unplugin_components_0;
            return vue.openBlock(), vue.createElementBlock("div", {
              ref_key: "scrollContainer",
              ref: scrollContainer,
              class: "h-60vh of-x-auto rounded"
            }, [
              vue.createElementVNode("div", {
                ref_key: "scrollContent",
                ref: scrollContent
              }, [
                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.orders, (order, i2) => {
                  return vue.openBlock(), vue.createElementBlock("div", {
                    key: i2,
                    class: "express-order",
                    "data-flag": Math.max(...order.map((v2) => {
                      var _a2;
                      return ((_a2 = v2.order) == null ? void 0 : _a2.sellerFlag) || 0;
                    }))
                  }, [
                    vue.createElementVNode("span", _hoisted_2$2, vue.toDisplayString(i2 + 1), 1),
                    vue.createElementVNode("div", _hoisted_3$2, [
                      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList([..._ctx.config].sort((a2, b2) => (b2.sort || 0) - (a2.sort || 0)), (item, key) => {
                        return vue.openBlock(), vue.createElementBlock(vue.Fragment, { key }, [
                          item.disabled || vue.unref(isSelect)("display", item.key) ? (vue.openBlock(), vue.createBlock(_component_bf_express_order_item, {
                            key: 0,
                            label: item.label,
                            value: F2(item.value, order)
                          }, null, 8, ["label", "value"])) : vue.createCommentVNode("", true)
                        ], 64);
                      }), 128))
                    ])
                  ], 8, _hoisted_1$2);
                }), 128))
              ], 512)
            ], 512);
          };
        }
      });
      var esErrors = Error;
      var _eval = EvalError;
      var range = RangeError;
      var ref = ReferenceError;
      var syntax = SyntaxError;
      var type = TypeError;
      var uri = URIError;
      var shams = function hasSymbols2() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = shams;
      var hasSymbols$1 = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
      var test = {
        __proto__: null,
        foo: {}
      };
      var $Object = Object;
      var hasProto$1 = function hasProto2() {
        return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
      };
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var toStr$1 = Object.prototype.toString;
      var max = Math.max;
      var funcType = "[object Function]";
      var concatty = function concatty2(a2, b2) {
        var arr = [];
        for (var i2 = 0; i2 < a2.length; i2 += 1) {
          arr[i2] = a2[i2];
        }
        for (var j2 = 0; j2 < b2.length; j2 += 1) {
          arr[j2 + a2.length] = b2[j2];
        }
        return arr;
      };
      var slicy = function slicy2(arrLike, offset) {
        var arr = [];
        for (var i2 = offset || 0, j2 = 0; i2 < arrLike.length; i2 += 1, j2 += 1) {
          arr[j2] = arrLike[i2];
        }
        return arr;
      };
      var joiny = function(arr, joiner) {
        var str = "";
        for (var i2 = 0; i2 < arr.length; i2 += 1) {
          str += arr[i2];
          if (i2 + 1 < arr.length) {
            str += joiner;
          }
        }
        return str;
      };
      var implementation$1 = function bind2(that) {
        var target = this;
        if (typeof target !== "function" || toStr$1.apply(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slicy(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              concatty(args, arguments)
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          }
          return target.apply(
            that,
            concatty(args, arguments)
          );
        };
        var boundLength = max(0, target.length - args.length);
        var boundArgs = [];
        for (var i2 = 0; i2 < boundLength; i2++) {
          boundArgs[i2] = "$" + i2;
        }
        bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty2 = function Empty3() {
          };
          Empty2.prototype = target.prototype;
          bound.prototype = new Empty2();
          Empty2.prototype = null;
        }
        return bound;
      };
      var implementation = implementation$1;
      var functionBind = Function.prototype.bind || implementation;
      var call = Function.prototype.call;
      var $hasOwn = Object.prototype.hasOwnProperty;
      var bind$1 = functionBind;
      var hasown = bind$1.call(call, $hasOwn);
      var undefined$1;
      var $Error = esErrors;
      var $EvalError = _eval;
      var $RangeError = range;
      var $ReferenceError = ref;
      var $SyntaxError$1 = syntax;
      var $TypeError$3 = type;
      var $URIError = uri;
      var $Function = Function;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e2) {
        }
      };
      var $gOPD$1 = Object.getOwnPropertyDescriptor;
      if ($gOPD$1) {
        try {
          $gOPD$1({}, "");
        } catch (e2) {
          $gOPD$1 = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError$3();
      };
      var ThrowTypeError = $gOPD$1 ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD$1(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = hasSymbols$1();
      var hasProto = hasProto$1();
      var getProto = Object.getPrototypeOf || (hasProto ? function(x2) {
        return x2.__proto__;
      } : null);
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
      var INTRINSICS = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
        "%AsyncFromSyncIteratorPrototype%": undefined$1,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": $Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": $EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
        "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
        "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
        "%RangeError%": $RangeError,
        "%ReferenceError%": $ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
        "%Symbol%": hasSymbols ? Symbol : undefined$1,
        "%SyntaxError%": $SyntaxError$1,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError$3,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
        "%URIError%": $URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
      };
      if (getProto) {
        try {
          null.error;
        } catch (e2) {
          var errorProto = getProto(getProto(e2));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn2 = doEval2("%AsyncGeneratorFunction%");
          if (fn2) {
            value = fn2.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen && getProto) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = functionBind;
      var hasOwn$2 = hasown;
      var $concat$1 = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace$1 = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string2) {
        var first = $strSlice(string2, 0, 1);
        var last = $strSlice(string2, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace$1(string2, rePropName, function(match, number, quote2, subString) {
          result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn$2(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn$2(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError$3("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError$1("intrinsic " + name + " does not exist!");
      };
      var getIntrinsic = function GetIntrinsic2(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError$3("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError$3('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat$1([0, 1], alias));
        }
        for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
          var part = parts[i2];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError$1("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn$2(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError$3("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD$1 && i2 + 1 >= parts.length) {
              var desc = $gOPD$1(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn$2(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
      var callBind$1 = { exports: {} };
      var esDefineProperty;
      var hasRequiredEsDefineProperty;
      function requireEsDefineProperty() {
        if (hasRequiredEsDefineProperty)
          return esDefineProperty;
        hasRequiredEsDefineProperty = 1;
        var GetIntrinsic2 = getIntrinsic;
        var $defineProperty2 = GetIntrinsic2("%Object.defineProperty%", true) || false;
        if ($defineProperty2) {
          try {
            $defineProperty2({}, "a", { value: 1 });
          } catch (e2) {
            $defineProperty2 = false;
          }
        }
        esDefineProperty = $defineProperty2;
        return esDefineProperty;
      }
      var GetIntrinsic$3 = getIntrinsic;
      var $gOPD = GetIntrinsic$3("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e2) {
          $gOPD = null;
        }
      }
      var gopd$1 = $gOPD;
      var $defineProperty$1 = requireEsDefineProperty();
      var $SyntaxError = syntax;
      var $TypeError$2 = type;
      var gopd = gopd$1;
      var defineDataProperty = function defineDataProperty2(obj, property2, value) {
        if (!obj || typeof obj !== "object" && typeof obj !== "function") {
          throw new $TypeError$2("`obj` must be an object or a function`");
        }
        if (typeof property2 !== "string" && typeof property2 !== "symbol") {
          throw new $TypeError$2("`property` must be a string or a symbol`");
        }
        if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
          throw new $TypeError$2("`nonEnumerable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
          throw new $TypeError$2("`nonWritable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
          throw new $TypeError$2("`nonConfigurable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
          throw new $TypeError$2("`loose`, if provided, must be a boolean");
        }
        var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
        var nonWritable = arguments.length > 4 ? arguments[4] : null;
        var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
        var loose = arguments.length > 6 ? arguments[6] : false;
        var desc = !!gopd && gopd(obj, property2);
        if ($defineProperty$1) {
          $defineProperty$1(obj, property2, {
            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
            value,
            writable: nonWritable === null && desc ? desc.writable : !nonWritable
          });
        } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
          obj[property2] = value;
        } else {
          throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
        }
      };
      var $defineProperty = requireEsDefineProperty();
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        return !!$defineProperty;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!$defineProperty) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e2) {
          return true;
        }
      };
      var hasPropertyDescriptors_1 = hasPropertyDescriptors;
      var GetIntrinsic$2 = getIntrinsic;
      var define = defineDataProperty;
      var hasDescriptors = hasPropertyDescriptors_1();
      var gOPD = gopd$1;
      var $TypeError$1 = type;
      var $floor$1 = GetIntrinsic$2("%Math.floor%");
      var setFunctionLength = function setFunctionLength2(fn2, length2) {
        if (typeof fn2 !== "function") {
          throw new $TypeError$1("`fn` is not a function");
        }
        if (typeof length2 !== "number" || length2 < 0 || length2 > 4294967295 || $floor$1(length2) !== length2) {
          throw new $TypeError$1("`length` must be a positive 32-bit integer");
        }
        var loose = arguments.length > 2 && !!arguments[2];
        var functionLengthIsConfigurable = true;
        var functionLengthIsWritable = true;
        if ("length" in fn2 && gOPD) {
          var desc = gOPD(fn2, "length");
          if (desc && !desc.configurable) {
            functionLengthIsConfigurable = false;
          }
          if (desc && !desc.writable) {
            functionLengthIsWritable = false;
          }
        }
        if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
          if (hasDescriptors) {
            define(
              /** @type {Parameters<define>[0]} */
              fn2,
              "length",
              length2,
              true,
              true
            );
          } else {
            define(
              /** @type {Parameters<define>[0]} */
              fn2,
              "length",
              length2
            );
          }
        }
        return fn2;
      };
      (function(module2) {
        var bind2 = functionBind;
        var GetIntrinsic2 = getIntrinsic;
        var setFunctionLength$1 = setFunctionLength;
        var $TypeError2 = type;
        var $apply = GetIntrinsic2("%Function.prototype.apply%");
        var $call = GetIntrinsic2("%Function.prototype.call%");
        var $reflectApply = GetIntrinsic2("%Reflect.apply%", true) || bind2.call($call, $apply);
        var $defineProperty2 = requireEsDefineProperty();
        var $max = GetIntrinsic2("%Math.max%");
        module2.exports = function callBind2(originalFunction) {
          if (typeof originalFunction !== "function") {
            throw new $TypeError2("a function is required");
          }
          var func = $reflectApply(bind2, $call, arguments);
          return setFunctionLength$1(
            func,
            1 + $max(0, originalFunction.length - (arguments.length - 1)),
            true
          );
        };
        var applyBind = function applyBind2() {
          return $reflectApply(bind2, $apply, arguments);
        };
        if ($defineProperty2) {
          $defineProperty2(module2.exports, "apply", { value: applyBind });
        } else {
          module2.exports.apply = applyBind;
        }
      })(callBind$1);
      var callBindExports = callBind$1.exports;
      var GetIntrinsic$1 = getIntrinsic;
      var callBind = callBindExports;
      var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
      var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic$1(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
      const __viteBrowserExternal = {};
      const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        default: __viteBrowserExternal
      }, Symbol.toStringTag, { value: "Module" }));
      const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
      var hasMap = typeof Map === "function" && Map.prototype;
      var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
      var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
      var mapForEach = hasMap && Map.prototype.forEach;
      var hasSet = typeof Set === "function" && Set.prototype;
      var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
      var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
      var setForEach = hasSet && Set.prototype.forEach;
      var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
      var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
      var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
      var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
      var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
      var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
      var booleanValueOf = Boolean.prototype.valueOf;
      var objectToString = Object.prototype.toString;
      var functionToString = Function.prototype.toString;
      var $match = String.prototype.match;
      var $slice = String.prototype.slice;
      var $replace = String.prototype.replace;
      var $toUpperCase = String.prototype.toUpperCase;
      var $toLowerCase = String.prototype.toLowerCase;
      var $test = RegExp.prototype.test;
      var $concat = Array.prototype.concat;
      var $join = Array.prototype.join;
      var $arrSlice = Array.prototype.slice;
      var $floor = Math.floor;
      var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
      var gOPS = Object.getOwnPropertySymbols;
      var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
      var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
      var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
      var isEnumerable = Object.prototype.propertyIsEnumerable;
      var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
        return O2.__proto__;
      } : null);
      function addNumericSeparator(num, str) {
        if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
          return str;
        }
        var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof num === "number") {
          var int = num < 0 ? -$floor(-num) : $floor(num);
          if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
          }
        }
        return $replace.call(str, sepRegex, "$&_");
      }
      var utilInspect = require$$0;
      var inspectCustom = utilInspect.custom;
      var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
      var objectInspect = function inspect_(obj, options, depth, seen) {
        var opts = options || {};
        if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
          throw new TypeError('option "quoteStyle" must be "single" or "double"');
        }
        if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
          throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        }
        var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
        if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
          throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        }
        if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
          throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        }
        if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
          throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        }
        var numericSeparator = opts.numericSeparator;
        if (typeof obj === "undefined") {
          return "undefined";
        }
        if (obj === null) {
          return "null";
        }
        if (typeof obj === "boolean") {
          return obj ? "true" : "false";
        }
        if (typeof obj === "string") {
          return inspectString(obj, opts);
        }
        if (typeof obj === "number") {
          if (obj === 0) {
            return Infinity / obj > 0 ? "0" : "-0";
          }
          var str = String(obj);
          return numericSeparator ? addNumericSeparator(obj, str) : str;
        }
        if (typeof obj === "bigint") {
          var bigIntStr = String(obj) + "n";
          return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
        }
        var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
        if (typeof depth === "undefined") {
          depth = 0;
        }
        if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
          return isArray$4(obj) ? "[Array]" : "[Object]";
        }
        var indent = getIndent(opts, depth);
        if (typeof seen === "undefined") {
          seen = [];
        } else if (indexOf(seen, obj) >= 0) {
          return "[Circular]";
        }
        function inspect2(value, from2, noIndent) {
          if (from2) {
            seen = $arrSlice.call(seen);
            seen.push(from2);
          }
          if (noIndent) {
            var newOpts = {
              depth: opts.depth
            };
            if (has$3(opts, "quoteStyle")) {
              newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
          }
          return inspect_(value, opts, depth + 1, seen);
        }
        if (typeof obj === "function" && !isRegExp$1(obj)) {
          var name = nameOf(obj);
          var keys2 = arrObjKeys(obj, inspect2);
          return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
        }
        if (isSymbol(obj)) {
          var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
          return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
        }
        if (isElement(obj)) {
          var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
          var attrs = obj.attributes || [];
          for (var i2 = 0; i2 < attrs.length; i2++) {
            s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
          }
          s2 += ">";
          if (obj.childNodes && obj.childNodes.length) {
            s2 += "...";
          }
          s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
          return s2;
        }
        if (isArray$4(obj)) {
          if (obj.length === 0) {
            return "[]";
          }
          var xs = arrObjKeys(obj, inspect2);
          if (indent && !singleLineValues(xs)) {
            return "[" + indentedJoin(xs, indent) + "]";
          }
          return "[ " + $join.call(xs, ", ") + " ]";
        }
        if (isError(obj)) {
          var parts = arrObjKeys(obj, inspect2);
          if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
            return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
          }
          if (parts.length === 0) {
            return "[" + String(obj) + "]";
          }
          return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
        }
        if (typeof obj === "object" && customInspect) {
          if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
          } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
            return obj.inspect();
          }
        }
        if (isMap(obj)) {
          var mapParts = [];
          if (mapForEach) {
            mapForEach.call(obj, function(value, key) {
              mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
            });
          }
          return collectionOf("Map", mapSize.call(obj), mapParts, indent);
        }
        if (isSet(obj)) {
          var setParts = [];
          if (setForEach) {
            setForEach.call(obj, function(value) {
              setParts.push(inspect2(value, obj));
            });
          }
          return collectionOf("Set", setSize.call(obj), setParts, indent);
        }
        if (isWeakMap(obj)) {
          return weakCollectionOf("WeakMap");
        }
        if (isWeakSet(obj)) {
          return weakCollectionOf("WeakSet");
        }
        if (isWeakRef(obj)) {
          return weakCollectionOf("WeakRef");
        }
        if (isNumber(obj)) {
          return markBoxed(inspect2(Number(obj)));
        }
        if (isBigInt(obj)) {
          return markBoxed(inspect2(bigIntValueOf.call(obj)));
        }
        if (isBoolean(obj)) {
          return markBoxed(booleanValueOf.call(obj));
        }
        if (isString$1(obj)) {
          return markBoxed(inspect2(String(obj)));
        }
        if (typeof window !== "undefined" && obj === window) {
          return "{ [object Window] }";
        }
        if (obj === commonjsGlobal) {
          return "{ [object globalThis] }";
        }
        if (!isDate(obj) && !isRegExp$1(obj)) {
          var ys = arrObjKeys(obj, inspect2);
          var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
          var protoTag = obj instanceof Object ? "" : "null prototype";
          var stringTag2 = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
          var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
          var tag = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
          if (ys.length === 0) {
            return tag + "{}";
          }
          if (indent) {
            return tag + "{" + indentedJoin(ys, indent) + "}";
          }
          return tag + "{ " + $join.call(ys, ", ") + " }";
        }
        return String(obj);
      };
      function wrapQuotes(s2, defaultStyle, opts) {
        var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
        return quoteChar + s2 + quoteChar;
      }
      function quote(s2) {
        return $replace.call(String(s2), /"/g, "&quot;");
      }
      function isArray$4(obj) {
        return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isDate(obj) {
        return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isRegExp$1(obj) {
        return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isError(obj) {
        return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isString$1(obj) {
        return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isNumber(obj) {
        return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isBoolean(obj) {
        return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isSymbol(obj) {
        if (hasShammedSymbols) {
          return obj && typeof obj === "object" && obj instanceof Symbol;
        }
        if (typeof obj === "symbol") {
          return true;
        }
        if (!obj || typeof obj !== "object" || !symToString) {
          return false;
        }
        try {
          symToString.call(obj);
          return true;
        } catch (e2) {
        }
        return false;
      }
      function isBigInt(obj) {
        if (!obj || typeof obj !== "object" || !bigIntValueOf) {
          return false;
        }
        try {
          bigIntValueOf.call(obj);
          return true;
        } catch (e2) {
        }
        return false;
      }
      var hasOwn$1 = Object.prototype.hasOwnProperty || function(key) {
        return key in this;
      };
      function has$3(obj, key) {
        return hasOwn$1.call(obj, key);
      }
      function toStr(obj) {
        return objectToString.call(obj);
      }
      function nameOf(f2) {
        if (f2.name) {
          return f2.name;
        }
        var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
        if (m2) {
          return m2[1];
        }
        return null;
      }
      function indexOf(xs, x2) {
        if (xs.indexOf) {
          return xs.indexOf(x2);
        }
        for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
          if (xs[i2] === x2) {
            return i2;
          }
        }
        return -1;
      }
      function isMap(x2) {
        if (!mapSize || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          mapSize.call(x2);
          try {
            setSize.call(x2);
          } catch (s2) {
            return true;
          }
          return x2 instanceof Map;
        } catch (e2) {
        }
        return false;
      }
      function isWeakMap(x2) {
        if (!weakMapHas || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakMapHas.call(x2, weakMapHas);
          try {
            weakSetHas.call(x2, weakSetHas);
          } catch (s2) {
            return true;
          }
          return x2 instanceof WeakMap;
        } catch (e2) {
        }
        return false;
      }
      function isWeakRef(x2) {
        if (!weakRefDeref || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakRefDeref.call(x2);
          return true;
        } catch (e2) {
        }
        return false;
      }
      function isSet(x2) {
        if (!setSize || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          setSize.call(x2);
          try {
            mapSize.call(x2);
          } catch (m2) {
            return true;
          }
          return x2 instanceof Set;
        } catch (e2) {
        }
        return false;
      }
      function isWeakSet(x2) {
        if (!weakSetHas || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakSetHas.call(x2, weakSetHas);
          try {
            weakMapHas.call(x2, weakMapHas);
          } catch (s2) {
            return true;
          }
          return x2 instanceof WeakSet;
        } catch (e2) {
        }
        return false;
      }
      function isElement(x2) {
        if (!x2 || typeof x2 !== "object") {
          return false;
        }
        if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
          return true;
        }
        return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
      }
      function inspectString(str, opts) {
        if (str.length > opts.maxStringLength) {
          var remaining = str.length - opts.maxStringLength;
          var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
          return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
        }
        var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
        return wrapQuotes(s2, "single", opts);
      }
      function lowbyte(c2) {
        var n2 = c2.charCodeAt(0);
        var x2 = {
          8: "b",
          9: "t",
          10: "n",
          12: "f",
          13: "r"
        }[n2];
        if (x2) {
          return "\\" + x2;
        }
        return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
      }
      function markBoxed(str) {
        return "Object(" + str + ")";
      }
      function weakCollectionOf(type3) {
        return type3 + " { ? }";
      }
      function collectionOf(type3, size, entries, indent) {
        var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
        return type3 + " (" + size + ") {" + joinedEntries + "}";
      }
      function singleLineValues(xs) {
        for (var i2 = 0; i2 < xs.length; i2++) {
          if (indexOf(xs[i2], "\n") >= 0) {
            return false;
          }
        }
        return true;
      }
      function getIndent(opts, depth) {
        var baseIndent;
        if (opts.indent === "	") {
          baseIndent = "	";
        } else if (typeof opts.indent === "number" && opts.indent > 0) {
          baseIndent = $join.call(Array(opts.indent + 1), " ");
        } else {
          return null;
        }
        return {
          base: baseIndent,
          prev: $join.call(Array(depth + 1), baseIndent)
        };
      }
      function indentedJoin(xs, indent) {
        if (xs.length === 0) {
          return "";
        }
        var lineJoiner = "\n" + indent.prev + indent.base;
        return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
      }
      function arrObjKeys(obj, inspect2) {
        var isArr = isArray$4(obj);
        var xs = [];
        if (isArr) {
          xs.length = obj.length;
          for (var i2 = 0; i2 < obj.length; i2++) {
            xs[i2] = has$3(obj, i2) ? inspect2(obj[i2], obj) : "";
          }
        }
        var syms = typeof gOPS === "function" ? gOPS(obj) : [];
        var symMap;
        if (hasShammedSymbols) {
          symMap = {};
          for (var k2 = 0; k2 < syms.length; k2++) {
            symMap["$" + syms[k2]] = syms[k2];
          }
        }
        for (var key in obj) {
          if (!has$3(obj, key)) {
            continue;
          }
          if (isArr && String(Number(key)) === key && key < obj.length) {
            continue;
          }
          if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
            continue;
          } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
          } else {
            xs.push(key + ": " + inspect2(obj[key], obj));
          }
        }
        if (typeof gOPS === "function") {
          for (var j2 = 0; j2 < syms.length; j2++) {
            if (isEnumerable.call(obj, syms[j2])) {
              xs.push("[" + inspect2(syms[j2]) + "]: " + inspect2(obj[syms[j2]], obj));
            }
          }
        }
        return xs;
      }
      var GetIntrinsic = getIntrinsic;
      var callBound = callBound$1;
      var inspect = objectInspect;
      var $TypeError = type;
      var $WeakMap = GetIntrinsic("%WeakMap%", true);
      var $Map = GetIntrinsic("%Map%", true);
      var $weakMapGet = callBound("WeakMap.prototype.get", true);
      var $weakMapSet = callBound("WeakMap.prototype.set", true);
      var $weakMapHas = callBound("WeakMap.prototype.has", true);
      var $mapGet = callBound("Map.prototype.get", true);
      var $mapSet = callBound("Map.prototype.set", true);
      var $mapHas = callBound("Map.prototype.has", true);
      var listGetNode = function(list, key) {
        for (var prev2 = list, curr; (curr = prev2.next) !== null; prev2 = curr) {
          if (curr.key === key) {
            prev2.next = curr.next;
            curr.next = list.next;
            list.next = curr;
            return curr;
          }
        }
      };
      var listGet = function(objects, key) {
        var node2 = listGetNode(objects, key);
        return node2 && node2.value;
      };
      var listSet = function(objects, key, value) {
        var node2 = listGetNode(objects, key);
        if (node2) {
          node2.value = value;
        } else {
          objects.next = {
            // eslint-disable-line no-param-reassign
            key,
            next: objects.next,
            value
          };
        }
      };
      var listHas = function(objects, key) {
        return !!listGetNode(objects, key);
      };
      var sideChannel = function getSideChannel2() {
        var $wm;
        var $m;
        var $o;
        var channel = {
          assert: function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          },
          get: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            } else if ($Map) {
              if ($m) {
                return $mapGet($m, key);
              }
            } else {
              if ($o) {
                return listGet($o, key);
              }
            }
          },
          has: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            } else if ($Map) {
              if ($m) {
                return $mapHas($m, key);
              }
            } else {
              if ($o) {
                return listHas($o, key);
              }
            }
            return false;
          },
          set: function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if ($Map) {
              if (!$m) {
                $m = new $Map();
              }
              $mapSet($m, key, value);
            } else {
              if (!$o) {
                $o = { key: {}, next: null };
              }
              listSet($o, key, value);
            }
          }
        };
        return channel;
      };
      var replace$1 = String.prototype.replace;
      var percentTwenties = /%20/g;
      var Format = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
      };
      var formats$3 = {
        "default": Format.RFC3986,
        formatters: {
          RFC1738: function(value) {
            return replace$1.call(value, percentTwenties, "+");
          },
          RFC3986: function(value) {
            return String(value);
          }
        },
        RFC1738: Format.RFC1738,
        RFC3986: Format.RFC3986
      };
      var formats$2 = formats$3;
      var has$2 = Object.prototype.hasOwnProperty;
      var isArray$3 = Array.isArray;
      var hexTable = function() {
        var array = [];
        for (var i2 = 0; i2 < 256; ++i2) {
          array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
        }
        return array;
      }();
      var compactQueue = function compactQueue2(queue) {
        while (queue.length > 1) {
          var item = queue.pop();
          var obj = item.obj[item.prop];
          if (isArray$3(obj)) {
            var compacted = [];
            for (var j2 = 0; j2 < obj.length; ++j2) {
              if (typeof obj[j2] !== "undefined") {
                compacted.push(obj[j2]);
              }
            }
            item.obj[item.prop] = compacted;
          }
        }
      };
      var arrayToObject = function arrayToObject2(source, options) {
        var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        for (var i2 = 0; i2 < source.length; ++i2) {
          if (typeof source[i2] !== "undefined") {
            obj[i2] = source[i2];
          }
        }
        return obj;
      };
      var merge$1 = function merge2(target, source, options) {
        if (!source) {
          return target;
        }
        if (typeof source !== "object") {
          if (isArray$3(target)) {
            target.push(source);
          } else if (target && typeof target === "object") {
            if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
              target[source] = true;
            }
          } else {
            return [target, source];
          }
          return target;
        }
        if (!target || typeof target !== "object") {
          return [target].concat(source);
        }
        var mergeTarget = target;
        if (isArray$3(target) && !isArray$3(source)) {
          mergeTarget = arrayToObject(target, options);
        }
        if (isArray$3(target) && isArray$3(source)) {
          source.forEach(function(item, i2) {
            if (has$2.call(target, i2)) {
              var targetItem = target[i2];
              if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
                target[i2] = merge2(targetItem, item, options);
              } else {
                target.push(item);
              }
            } else {
              target[i2] = item;
            }
          });
          return target;
        }
        return Object.keys(source).reduce(function(acc, key) {
          var value = source[key];
          if (has$2.call(acc, key)) {
            acc[key] = merge2(acc[key], value, options);
          } else {
            acc[key] = value;
          }
          return acc;
        }, mergeTarget);
      };
      var assign = function assignSingleSource(target, source) {
        return Object.keys(source).reduce(function(acc, key) {
          acc[key] = source[key];
          return acc;
        }, target);
      };
      var decode = function(str, decoder, charset) {
        var strWithoutPlus = str.replace(/\+/g, " ");
        if (charset === "iso-8859-1") {
          return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
        }
        try {
          return decodeURIComponent(strWithoutPlus);
        } catch (e2) {
          return strWithoutPlus;
        }
      };
      var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
        if (str.length === 0) {
          return str;
        }
        var string2 = str;
        if (typeof str === "symbol") {
          string2 = Symbol.prototype.toString.call(str);
        } else if (typeof str !== "string") {
          string2 = String(str);
        }
        if (charset === "iso-8859-1") {
          return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
            return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
          });
        }
        var out = "";
        for (var i2 = 0; i2 < string2.length; ++i2) {
          var c2 = string2.charCodeAt(i2);
          if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats$2.RFC1738 && (c2 === 40 || c2 === 41)) {
            out += string2.charAt(i2);
            continue;
          }
          if (c2 < 128) {
            out = out + hexTable[c2];
            continue;
          }
          if (c2 < 2048) {
            out = out + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
            continue;
          }
          if (c2 < 55296 || c2 >= 57344) {
            out = out + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
            continue;
          }
          i2 += 1;
          c2 = 65536 + ((c2 & 1023) << 10 | string2.charCodeAt(i2) & 1023);
          out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
        }
        return out;
      };
      var compact = function compact2(value) {
        var queue = [{ obj: { o: value }, prop: "o" }];
        var refs = [];
        for (var i2 = 0; i2 < queue.length; ++i2) {
          var item = queue[i2];
          var obj = item.obj[item.prop];
          var keys2 = Object.keys(obj);
          for (var j2 = 0; j2 < keys2.length; ++j2) {
            var key = keys2[j2];
            var val = obj[key];
            if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
              queue.push({ obj, prop: key });
              refs.push(val);
            }
          }
        }
        compactQueue(queue);
        return value;
      };
      var isRegExp = function isRegExp2(obj) {
        return Object.prototype.toString.call(obj) === "[object RegExp]";
      };
      var isBuffer = function isBuffer2(obj) {
        if (!obj || typeof obj !== "object") {
          return false;
        }
        return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
      };
      var combine = function combine2(a2, b2) {
        return [].concat(a2, b2);
      };
      var maybeMap = function maybeMap2(val, fn2) {
        if (isArray$3(val)) {
          var mapped = [];
          for (var i2 = 0; i2 < val.length; i2 += 1) {
            mapped.push(fn2(val[i2]));
          }
          return mapped;
        }
        return fn2(val);
      };
      var utils$3 = {
        arrayToObject,
        assign,
        combine,
        compact,
        decode,
        encode,
        isBuffer,
        isRegExp,
        maybeMap,
        merge: merge$1
      };
      var getSideChannel = sideChannel;
      var utils$2 = utils$3;
      var formats$1 = formats$3;
      var has$1 = Object.prototype.hasOwnProperty;
      var arrayPrefixGenerators = {
        brackets: function brackets(prefix) {
          return prefix + "[]";
        },
        comma: "comma",
        indices: function indices(prefix, key) {
          return prefix + "[" + key + "]";
        },
        repeat: function repeat(prefix) {
          return prefix;
        }
      };
      var isArray$2 = Array.isArray;
      var push = Array.prototype.push;
      var pushToArray = function(arr, valueOrArray) {
        push.apply(arr, isArray$2(valueOrArray) ? valueOrArray : [valueOrArray]);
      };
      var toISO = Date.prototype.toISOString;
      var defaultFormat = formats$1["default"];
      var defaults$1 = {
        addQueryPrefix: false,
        allowDots: false,
        charset: "utf-8",
        charsetSentinel: false,
        delimiter: "&",
        encode: true,
        encoder: utils$2.encode,
        encodeValuesOnly: false,
        format: defaultFormat,
        formatter: formats$1.formatters[defaultFormat],
        // deprecated
        indices: false,
        serializeDate: function serializeDate(date) {
          return toISO.call(date);
        },
        skipNulls: false,
        strictNullHandling: false
      };
      var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
        return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
      };
      var sentinel = {};
      var stringify$2 = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
        var obj = object;
        var tmpSc = sideChannel2;
        var step = 0;
        var findFlag = false;
        while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
          var pos = tmpSc.get(object);
          step += 1;
          if (typeof pos !== "undefined") {
            if (pos === step) {
              throw new RangeError("Cyclic object value");
            } else {
              findFlag = true;
            }
          }
          if (typeof tmpSc.get(sentinel) === "undefined") {
            step = 0;
          }
        }
        if (typeof filter === "function") {
          obj = filter(prefix, obj);
        } else if (obj instanceof Date) {
          obj = serializeDate(obj);
        } else if (generateArrayPrefix === "comma" && isArray$2(obj)) {
          obj = utils$2.maybeMap(obj, function(value2) {
            if (value2 instanceof Date) {
              return serializeDate(value2);
            }
            return value2;
          });
        }
        if (obj === null) {
          if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format2) : prefix;
          }
          obj = "";
        }
        if (isNonNullishPrimitive(obj) || utils$2.isBuffer(obj)) {
          if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format2);
            return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format2))];
          }
          return [formatter(prefix) + "=" + formatter(String(obj))];
        }
        var values = [];
        if (typeof obj === "undefined") {
          return values;
        }
        var objKeys;
        if (generateArrayPrefix === "comma" && isArray$2(obj)) {
          if (encodeValuesOnly && encoder) {
            obj = utils$2.maybeMap(obj, encoder);
          }
          objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
        } else if (isArray$2(filter)) {
          objKeys = filter;
        } else {
          var keys2 = Object.keys(obj);
          objKeys = sort ? keys2.sort(sort) : keys2;
        }
        var adjustedPrefix = commaRoundTrip && isArray$2(obj) && obj.length === 1 ? prefix + "[]" : prefix;
        for (var j2 = 0; j2 < objKeys.length; ++j2) {
          var key = objKeys[j2];
          var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
          if (skipNulls && value === null) {
            continue;
          }
          var keyPrefix = isArray$2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
          sideChannel2.set(object, step);
          var valueSideChannel = getSideChannel();
          valueSideChannel.set(sentinel, sideChannel2);
          pushToArray(values, stringify2(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            strictNullHandling,
            skipNulls,
            generateArrayPrefix === "comma" && encodeValuesOnly && isArray$2(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format2,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
          ));
        }
        return values;
      };
      var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
        if (!opts) {
          return defaults$1;
        }
        if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
          throw new TypeError("Encoder has to be a function.");
        }
        var charset = opts.charset || defaults$1.charset;
        if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        }
        var format2 = formats$1["default"];
        if (typeof opts.format !== "undefined") {
          if (!has$1.call(formats$1.formatters, opts.format)) {
            throw new TypeError("Unknown format option provided.");
          }
          format2 = opts.format;
        }
        var formatter = formats$1.formatters[format2];
        var filter = defaults$1.filter;
        if (typeof opts.filter === "function" || isArray$2(opts.filter)) {
          filter = opts.filter;
        }
        return {
          addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
          allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
          charset,
          charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
          delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
          encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
          encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
          encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
          filter,
          format: format2,
          formatter,
          serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
          skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
          sort: typeof opts.sort === "function" ? opts.sort : null,
          strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
        };
      };
      var stringify_1 = function(object, opts) {
        var obj = object;
        var options = normalizeStringifyOptions(opts);
        var objKeys;
        var filter;
        if (typeof options.filter === "function") {
          filter = options.filter;
          obj = filter("", obj);
        } else if (isArray$2(options.filter)) {
          filter = options.filter;
          objKeys = filter;
        }
        var keys2 = [];
        if (typeof obj !== "object" || obj === null) {
          return "";
        }
        var arrayFormat;
        if (opts && opts.arrayFormat in arrayPrefixGenerators) {
          arrayFormat = opts.arrayFormat;
        } else if (opts && "indices" in opts) {
          arrayFormat = opts.indices ? "indices" : "repeat";
        } else {
          arrayFormat = "indices";
        }
        var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
        if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
          throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        }
        var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
        if (!objKeys) {
          objKeys = Object.keys(obj);
        }
        if (options.sort) {
          objKeys.sort(options.sort);
        }
        var sideChannel2 = getSideChannel();
        for (var i2 = 0; i2 < objKeys.length; ++i2) {
          var key = objKeys[i2];
          if (options.skipNulls && obj[key] === null) {
            continue;
          }
          pushToArray(keys2, stringify$2(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel2
          ));
        }
        var joined = keys2.join(options.delimiter);
        var prefix = options.addQueryPrefix === true ? "?" : "";
        if (options.charsetSentinel) {
          if (options.charset === "iso-8859-1") {
            prefix += "utf8=%26%2310003%3B&";
          } else {
            prefix += "utf8=%E2%9C%93&";
          }
        }
        return joined.length > 0 ? prefix + joined : "";
      };
      var utils$1 = utils$3;
      var has = Object.prototype.hasOwnProperty;
      var isArray$1 = Array.isArray;
      var defaults = {
        allowDots: false,
        allowPrototypes: false,
        allowSparse: false,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: false,
        comma: false,
        decoder: utils$1.decode,
        delimiter: "&",
        depth: 5,
        ignoreQueryPrefix: false,
        interpretNumericEntities: false,
        parameterLimit: 1e3,
        parseArrays: true,
        plainObjects: false,
        strictNullHandling: false
      };
      var interpretNumericEntities = function(str) {
        return str.replace(/&#(\d+);/g, function($0, numberStr) {
          return String.fromCharCode(parseInt(numberStr, 10));
        });
      };
      var parseArrayValue = function(val, options) {
        if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
          return val.split(",");
        }
        return val;
      };
      var isoSentinel = "utf8=%26%2310003%3B";
      var charsetSentinel = "utf8=%E2%9C%93";
      var parseValues = function parseQueryStringValues(str, options) {
        var obj = { __proto__: null };
        var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
        var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
        var parts = cleanStr.split(options.delimiter, limit);
        var skipIndex = -1;
        var i2;
        var charset = options.charset;
        if (options.charsetSentinel) {
          for (i2 = 0; i2 < parts.length; ++i2) {
            if (parts[i2].indexOf("utf8=") === 0) {
              if (parts[i2] === charsetSentinel) {
                charset = "utf-8";
              } else if (parts[i2] === isoSentinel) {
                charset = "iso-8859-1";
              }
              skipIndex = i2;
              i2 = parts.length;
            }
          }
        }
        for (i2 = 0; i2 < parts.length; ++i2) {
          if (i2 === skipIndex) {
            continue;
          }
          var part = parts[i2];
          var bracketEqualsPos = part.indexOf("]=");
          var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
          var key, val;
          if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, "key");
            val = options.strictNullHandling ? null : "";
          } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
            val = utils$1.maybeMap(
              parseArrayValue(part.slice(pos + 1), options),
              function(encodedVal) {
                return options.decoder(encodedVal, defaults.decoder, charset, "value");
              }
            );
          }
          if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
            val = interpretNumericEntities(val);
          }
          if (part.indexOf("[]=") > -1) {
            val = isArray$1(val) ? [val] : val;
          }
          if (has.call(obj, key)) {
            obj[key] = utils$1.combine(obj[key], val);
          } else {
            obj[key] = val;
          }
        }
        return obj;
      };
      var parseObject = function(chain, val, options, valuesParsed) {
        var leaf = valuesParsed ? val : parseArrayValue(val, options);
        for (var i2 = chain.length - 1; i2 >= 0; --i2) {
          var obj;
          var root2 = chain[i2];
          if (root2 === "[]" && options.parseArrays) {
            obj = [].concat(leaf);
          } else {
            obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
            var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
            var index2 = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === "") {
              obj = { 0: leaf };
            } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
              obj = [];
              obj[index2] = leaf;
            } else if (cleanRoot !== "__proto__") {
              obj[cleanRoot] = leaf;
            }
          }
          leaf = obj;
        }
        return leaf;
      };
      var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
        if (!givenKey) {
          return;
        }
        var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
        var brackets = /(\[[^[\]]*])/;
        var child = /(\[[^[\]]*])/g;
        var segment = options.depth > 0 && brackets.exec(key);
        var parent = segment ? key.slice(0, segment.index) : key;
        var keys2 = [];
        if (parent) {
          if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
              return;
            }
          }
          keys2.push(parent);
        }
        var i2 = 0;
        while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
          i2 += 1;
          if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
              return;
            }
          }
          keys2.push(segment[1]);
        }
        if (segment) {
          keys2.push("[" + key.slice(segment.index) + "]");
        }
        return parseObject(keys2, val, options, valuesParsed);
      };
      var normalizeParseOptions = function normalizeParseOptions2(opts) {
        if (!opts) {
          return defaults;
        }
        if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
          throw new TypeError("Decoder has to be a function.");
        }
        if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        }
        var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
        return {
          allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
          allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
          allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
          arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
          charset,
          charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
          comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
          decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
          delimiter: typeof opts.delimiter === "string" || utils$1.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
          // eslint-disable-next-line no-implicit-coercion, no-extra-parens
          depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
          ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
          interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
          parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
          parseArrays: opts.parseArrays !== false,
          plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
          strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
        };
      };
      var parse$2 = function(str, opts) {
        var options = normalizeParseOptions(opts);
        if (str === "" || str === null || typeof str === "undefined") {
          return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        }
        var tempObj = typeof str === "string" ? parseValues(str, options) : str;
        var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var keys2 = Object.keys(tempObj);
        for (var i2 = 0; i2 < keys2.length; ++i2) {
          var key = keys2[i2];
          var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
          obj = utils$1.merge(obj, newObj, options);
        }
        if (options.allowSparse === true) {
          return obj;
        }
        return utils$1.compact(obj);
      };
      var stringify$1 = stringify_1;
      var parse$1 = parse$2;
      var formats = formats$3;
      var lib = {
        formats,
        parse: parse$1,
        stringify: stringify$1
      };
      const qs = /* @__PURE__ */ getDefaultExportFromCjs(lib);
      function AddNumber(lc_name, l_id) {
        const { authorize_co_id, owner_co_id } = useUserStore();
        const url = `https://www.erp321.com/app/wms/aftersale/expressScan.aspx?w=700&h=480&t=${Date.now()}&owner_co_id=${owner_co_id}&authorize_co_id=${authorize_co_id}&_t=${Date.now()}&_h=480px&_float=true&ts___=${Date.now()}&am___=AddExpressNo`;
        return useFetch(url, {
          method: "POST",
          body: qs.stringify({
            __VIEWSTATE: "/wEPDwULLTE3MzI1MzIwMzBkZOl5HlMC+GseyHEZtDnl0duvsRi9",
            __VIEWSTATEGENERATOR: "698C3E0E",
            return_lc_name: "",
            express: lc_name,
            return_lc_id: l_id,
            __CALLBACKID: "ACall1",
            __CALLBACKPARAM: JSON.stringify({ Method: "AddExpressNumber", Args: [lc_name, l_id, null], CallControl: "{page}" })
          }),
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          referrer: url
        });
      }
      function useFormatShowValue(value) {
        if (!value)
          return "-";
        if (Array.isArray(value))
          return value.map((v2) => v2 || "-");
        return `${value}`;
      }
      function useFormatRes(items, order) {
        return items.map((item) => {
          var _a2;
          const AfterSale = item.afterSale;
          const { getExpress } = useUserStore();
          const lcName = AfterSale.lId ? `${AfterSale.lcName.slice(0, 2)}快递` : (_a2 = getExpress(order)) == null ? void 0 : _a2.name;
          return {
            ...item,
            afterSale: {
              ...AfterSale,
              status: "未入库",
              lId: order,
              lcName
            }
          };
        });
      }
      function useFormatOrderCount(data) {
        if (!(data == null ? void 0 : data.length)) {
          return {
            goodsCount: 0,
            giftCount: 0,
            format: "-"
          };
        }
        const goodsCount = data.flatMap((o2) => o2.items).reduce((pre, cur) => {
          if (!cur)
            return pre;
          return pre + (!cur.isGift && cur.type !== "换货" ? cur.qty : 0);
        }, 0);
        const giftCount = data.flatMap((o2) => o2.items).reduce((pre, cur) => {
          if (!cur)
            return pre;
          return pre + (cur.isGift ? cur.qty || 1 : 0);
        }, 0);
        return {
          goodsCount,
          giftCount,
          format: `买	${goodsCount}	赠	${giftCount}	共(${goodsCount + giftCount})`
        };
      }
      function useFormatOrderStatus(msg, code) {
        if (!msg || !code)
          return false;
        if (code === 100 && (msg == null ? void 0 : msg.includes("售后单")))
          return true;
        return false;
      }
      function useFormatLcName(order) {
        const { orderList } = useUserStore();
        const lcName = orderList.filter((item) => item[0].afterSale.lcName === order[0].afterSale.lcName);
        const index2 = lcName.findIndex((item) => item[0].afterSale.lId === order[0].afterSale.lId) + 1;
        return `${order[0].afterSale.lcName}-${index2} 共(${lcName.length})`;
      }
      function speak(keywords) {
        useSpeechSynthesis(keywords, {
          lang: "zh-cn",
          rate: 1.5,
          pitch: 2,
          volume: 1
        }).speak();
      }
      function useSpeech(data, code, msg) {
        var _a2, _b;
        function showMsg(title, message) {
          return ElNotification({
            title,
            type: "warning",
            message: message || "错误",
            duration: 0
          });
        }
        function hasKeyword(key, targetFn) {
          const { settings } = useUserStore();
          const { prompt } = settings;
          if (Array.isArray(data))
            return data.some((v2) => prompt.filter[key] && prompt.filter[key].split("|").some((f2) => {
              var _a3;
              return (_a3 = targetFn(v2)) == null ? void 0 : _a3.includes(f2);
            }));
          return false;
        }
        if (data === null) {
          showMsg("错误", msg);
          return speak("错误");
        }
        if (typeof data === "string")
          return speak(data);
        const lId = data[0].afterSale.lId;
        const { isSelect } = useUserStore();
        if (useFormatOrderStatus(msg, code)) {
          showMsg("已入库", `[${lId}]${msg}`);
          return speak(`已入库`);
        }
        if (isSelect("prompt", "noUpload") && !((_b = (_a2 = data[0]) == null ? void 0 : _a2.items) == null ? void 0 : _b.length)) {
          showMsg("未上传单号", `[${lId}]未上传快递单号`);
          return speak(`未上传单号`);
        }
        const speakArr = [];
        if (isSelect("prompt", "omsRemark") && hasKeyword("omsRemark", (a2) => {
          var _a3;
          return (_a3 = a2.afterSale) == null ? void 0 : _a3.remark;
        }))
          speakArr.push("用户备注");
        if (isSelect("prompt", "remark") && hasKeyword("remark", (a2) => {
          var _a3;
          return (_a3 = a2.order) == null ? void 0 : _a3.remark;
        }))
          speakArr.push("订单备注");
        const { goodsCount } = useFormatOrderCount(data);
        if (isSelect("prompt", "isMore") && goodsCount > 1) {
          showMsg("多件商品", `[${lId}]共${goodsCount}件商品`);
          speakArr.push(`共${goodsCount}件商品`);
        }
        const speakStr = speakArr.join("、");
        return speakStr && speak(`注意${speakStr}`);
      }
      const useRequest = createFetch({
        baseUrl: "https://api.erp321.com/erp/webapi/",
        combination: "chain",
        fetchOptions: {
          headers: {
            "accept": "application/json, text/javascript, */*; q=0.01",
            "content-type": "application/json;charset=UTF-8"
          },
          credentials: "include",
          mode: "cors"
        }
      });
      function QueryState(order) {
        const { authorize_co_id, owner_co_id, currentIndex, getExpress, expressIsExist, addOrderItem, increment } = useUserStore();
        order = order.replace(/(-\d?)*/g, "");
        if (expressIsExist(order))
          return useSpeech("重复");
        increment();
        const { onFetchResponse, ..._data } = useRequest(`afterSaleApi/scanning/search?owner_co_id=${owner_co_id}&authorize_co_id=${authorize_co_id}`, {
          method: "POST",
          body: JSON.stringify({
            data: {
              value: order,
              type: "l_id",
              isPromptMessage: true
            }
          })
        });
        onFetchResponse((ctx) => {
          ctx.json().then((responce) => {
            const { data = [], code, msg } = responce;
            let orderItem = null;
            if (code === 100) {
              const express = getExpress(order);
              if (msg.includes("售后单")) {
                orderItem = [{
                  afterSale: {
                    lId: order,
                    lcName: express.name,
                    timestamp: Date.now(),
                    status: "已入库"
                  }
                }];
              } else if (msg.includes("不正确")) {
                orderItem = null;
              }
            } else if (!data.length) {
              const express = getExpress(order);
              orderItem = [{
                afterSale: {
                  lId: order,
                  lcName: express.name,
                  status: "未上传单号",
                  timestamp: Date.now()
                }
              }];
            } else {
              orderItem = useFormatRes(data, order);
            }
            if (orderItem) {
              const { lcName, lId } = orderItem[0].afterSale;
              AddNumber(lcName, lId);
              addOrderItem(orderItem, currentIndex);
              useSpeech(orderItem, code, msg);
            }
            return responce;
          });
        });
        return _data;
      }
      const _hoisted_1$1 = { class: "mb-xs flex items-center justify-end gap-sm rounded text-gray-500" };
      const _hoisted_2$1 = { "mr-auto": "" };
      const _hoisted_3$1 = { class: "bf-icon" };
      const _hoisted_4 = /* @__PURE__ */ vue.createElementVNode("i", { "i-carbon:filter": "" }, null, -1);
      const _hoisted_5 = [
        _hoisted_4
      ];
      const _hoisted_6 = /* @__PURE__ */ vue.createElementVNode("span", { class: "bf-icon" }, [
        /* @__PURE__ */ vue.createElementVNode("div", { class: "i-carbon:shape-exclude" })
      ], -1);
      const _hoisted_7 = /* @__PURE__ */ vue.createElementVNode("span", { class: "bf-icon" }, [
        /* @__PURE__ */ vue.createElementVNode("i", { "i-carbon:settings": "" })
      ], -1);
      const _hoisted_8 = { class: "grid grid-cols-3 pr-18px" };
      const _hoisted_9 = {
        key: 0,
        class: "pb-9px pr-18px"
      };
      const _hoisted_10 = {
        flex: "",
        "items-baseline": "",
        "gap-sm": "",
        "py-3px": ""
      };
      const _hoisted_11 = /* @__PURE__ */ vue.createElementVNode("span", {
        "text-.7em": "",
        "c-gray": ""
      }, "多个使用 | 分割", -1);
      const _sfc_main$1 = /* @__PURE__ */ vue.defineComponent({
        __name: "expressDialog",
        props: {
          "modelValue": { type: Boolean },
          "modelModifiers": {}
        },
        emits: ["update:modelValue"],
        setup(__props) {
          const { isSelect, initStore } = useUserStore();
          const { orderListByFilter, orderList, settings, OrderByExpressNameSelected, orderExpressNameList } = vue.toRefs(useUserStore());
          const modelValue = vue.useModel(__props, "modelValue");
          const F2 = useFormatShowValue;
          const formData = vue.reactive({
            order: "",
            select: "scan"
          });
          function handleSubmit() {
            const order = formData.order;
            if (!order)
              return;
            QueryState(order);
            formData.order = "";
          }
          const settingConfig = {
            display: {
              label: "展示设置",
              items: [
                {
                  label: "快递公司",
                  key: "lcName",
                  value: (o2) => useFormatLcName(o2),
                  disabled: true,
                  sort: 999
                },
                {
                  label: "快递单号",
                  key: "lId",
                  value: (o2) => o2[0].afterSale.lId,
                  disabled: true,
                  sort: 998
                },
                {
                  label: "发货仓库",
                  key: "wareHouse",
                  multiline: true,
                  value: (o2) => F2(o2.flatMap((v2) => {
                    var _a2;
                    return (_a2 = v2.order) == null ? void 0 : _a2.wareHouse;
                  }))
                },
                {
                  label: "购买店铺",
                  key: "shopName",
                  value: (o2) => F2(o2.flatMap((v2) => {
                    var _a2;
                    return (_a2 = v2.order) == null ? void 0 : _a2.shopName;
                  }))
                },
                {
                  label: "发货时间",
                  key: "deliveryTime",
                  value: (o2) => F2(o2.flatMap((v2) => {
                    var _a2;
                    return (_a2 = v2.order) == null ? void 0 : _a2.deliveryTime;
                  }))
                },
                {
                  label: "商品数量",
                  value: (o2) => useFormatOrderCount(o2).format,
                  key: "product-count"
                },
                {
                  label: "商品规格",
                  key: "product-specification",
                  value: (o2) => F2([...new Set(o2.flatMap((v2) => {
                    var _a2;
                    return (_a2 = v2.items) == null ? void 0 : _a2.flatMap((v22) => v22.iId);
                  }))])
                },
                {
                  label: "用户备注",
                  value: (o2) => F2(o2.flatMap((v2) => v2.afterSale.remark)),
                  key: "omsRemark"
                },
                {
                  label: "订单备注",
                  value: (o2) => F2(o2.flatMap((v2) => {
                    var _a2;
                    return (_a2 = v2.order) == null ? void 0 : _a2.remark;
                  })),
                  key: "remark"
                }
              ]
            },
            prompt: {
              label: "提示设置",
              items: [{
                label: "用户备注",
                filter: true,
                key: "omsRemark"
              }, {
                label: "订单备注",
                filter: true,
                key: "remark"
              }, {
                label: "购买店铺",
                key: "shopName",
                filter: true
              }, {
                label: "多件商品",
                key: "isMore"
              }, {
                label: "发货仓",
                key: "wareHouse",
                filter: true
              }, {
                label: "未上传单号",
                key: "noUpload"
              }]
            }
          };
          const checkAll = vue.ref(true);
          const isIndeterminate = vue.ref(true);
          function handleCheckAllChange(val) {
            OrderByExpressNameSelected.value = val ? orderExpressNameList.value : [];
            isIndeterminate.value = false;
          }
          function handleCheckedCitiesChange(value) {
            const checkedCount = value.length;
            const listLen = orderExpressNameList.value.length;
            checkAll.value = checkedCount === listLen;
            isIndeterminate.value = checkedCount > 0 && checkedCount < listLen;
          }
          vue.watchEffect(() => {
            if (checkAll.value)
              OrderByExpressNameSelected.value = orderExpressNameList.value;
          });
          return (_ctx, _cache) => {
            const _component_el_option = ElOption;
            const _component_el_select = ElSelect;
            const _component_el_input = ElInput;
            const _component_el_form_item = ElFormItem;
            const _component_el_form = ElForm;
            const _component_el_checkbox = ElCheckbox;
            const _component_el_checkbox_group = ElCheckboxGroup;
            const _component_el_popover = ElPopover;
            const _component_bf_express_order = _sfc_main$2;
            const _component_el_dialog = ElDialog;
            return vue.openBlock(), vue.createBlock(_component_el_dialog, vue.mergeProps({
              modelValue: modelValue.value,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => modelValue.value = $event),
              "close-on-press-escape": false,
              "close-on-click-modal": false
            }, _ctx.$attrs, {
              class: "bf-dailog",
              onOpen: vue.unref(initStore)
            }), {
              default: vue.withCtx(() => [
                vue.createVNode(_component_el_form, { model: vue.unref(formData) }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_el_form_item, { prop: "order" }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(_component_el_input, {
                          modelValue: vue.unref(formData).order,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => vue.unref(formData).order = $event),
                          modelModifiers: { trim: true },
                          clearable: "",
                          placeholder: "请输入快递单号后，回车添加",
                          spellcheck: "false",
                          label: "用户名",
                          class: "input-with-select",
                          onKeydown: vue.withKeys(handleSubmit, ["enter"])
                        }, {
                          prepend: vue.withCtx(() => [
                            vue.createVNode(_component_el_select, {
                              modelValue: vue.unref(formData).select,
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vue.unref(formData).select = $event),
                              placeholder: "请选择录入方式",
                              style: { "width": "115px" }
                            }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(_component_el_option, {
                                  label: "手动录入",
                                  value: "input"
                                }),
                                vue.createVNode(_component_el_option, {
                                  label: "扫描录入",
                                  select: "",
                                  value: "scan"
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        }, 8, ["modelValue"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["model"]),
                vue.createElementVNode("div", _hoisted_1$1, [
                  vue.createElementVNode("span", _hoisted_2$1, "共(" + vue.toDisplayString(vue.unref(orderList).length) + ")", 1),
                  vue.createVNode(_component_el_popover, {
                    width: "200",
                    placement: "bottom-start",
                    trigger: "click"
                  }, {
                    reference: vue.withCtx(() => [
                      vue.withDirectives(vue.createElementVNode("span", _hoisted_3$1, _hoisted_5, 512), [
                        [vue.vShow, vue.unref(orderExpressNameList).length]
                      ])
                    ]),
                    default: vue.withCtx(() => [
                      vue.createVNode(_component_el_form, { "label-position": "top" }, {
                        default: vue.withCtx(() => [
                          vue.createVNode(_component_el_form_item, { label: "快递公司过滤" }, {
                            default: vue.withCtx(() => [
                              vue.createVNode(_component_el_checkbox, {
                                modelValue: vue.unref(checkAll),
                                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => vue.isRef(checkAll) ? checkAll.value = $event : null),
                                "w-full": "",
                                "px-sm": "",
                                "hover:bg-gray-1": "",
                                indeterminate: vue.unref(isIndeterminate),
                                onChange: handleCheckAllChange
                              }, {
                                default: vue.withCtx(() => [
                                  vue.createTextVNode(" 全选 ")
                                ]),
                                _: 1
                              }, 8, ["modelValue", "indeterminate"]),
                              vue.createVNode(_component_el_checkbox_group, {
                                modelValue: vue.unref(OrderByExpressNameSelected),
                                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => vue.isRef(OrderByExpressNameSelected) ? OrderByExpressNameSelected.value = $event : null),
                                onChange: handleCheckedCitiesChange
                              }, {
                                default: vue.withCtx(() => [
                                  (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(orderExpressNameList), (name) => {
                                    return vue.openBlock(), vue.createBlock(_component_el_checkbox, {
                                      key: name,
                                      "w-full": "",
                                      "px-sm": "",
                                      "hover:bg-gray-1": "",
                                      label: name
                                    }, {
                                      default: vue.withCtx(() => [
                                        vue.createTextVNode(vue.toDisplayString(name), 1)
                                      ]),
                                      _: 2
                                    }, 1032, ["label"]);
                                  }), 128))
                                ]),
                                _: 1
                              }, 8, ["modelValue"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  vue.createVNode(_component_el_popover, {
                    placement: "bottom-start",
                    width: "320",
                    trigger: "click"
                  }, {
                    reference: vue.withCtx(() => [
                      _hoisted_6
                    ]),
                    default: vue.withCtx(() => [
                      vue.createTextVNode(" 单号排除 暂时还没有实现 ")
                    ]),
                    _: 1
                  }),
                  vue.createVNode(_component_el_popover, {
                    placement: "bottom-start",
                    width: "320",
                    trigger: "click"
                  }, {
                    reference: vue.withCtx(() => [
                      _hoisted_7
                    ]),
                    default: vue.withCtx(() => [
                      vue.createVNode(_component_el_form, {
                        "label-position": "top",
                        class: "bf-setting__form"
                      }, {
                        default: vue.withCtx(() => [
                          (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, vue.renderList(settingConfig, (item, k2) => {
                            return vue.createVNode(_component_el_form_item, {
                              key: k2,
                              label: item.label
                            }, {
                              default: vue.withCtx(() => [
                                vue.createVNode(_component_el_checkbox_group, {
                                  modelValue: vue.unref(settings)[k2].select,
                                  "onUpdate:modelValue": ($event) => vue.unref(settings)[k2].select = $event
                                }, {
                                  default: vue.withCtx(() => [
                                    vue.createElementVNode("div", _hoisted_8, [
                                      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(item.items, ({ label, key, disabled }) => {
                                        return vue.openBlock(), vue.createElementBlock(vue.Fragment, { key }, [
                                          !disabled ? (vue.openBlock(), vue.createBlock(_component_el_checkbox, {
                                            key: 0,
                                            label: key
                                          }, {
                                            default: vue.withCtx(() => [
                                              vue.createTextVNode(vue.toDisplayString(label), 1)
                                            ]),
                                            _: 2
                                          }, 1032, ["label"])) : vue.createCommentVNode("", true)
                                        ], 64);
                                      }), 128))
                                    ]),
                                    (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(item.items.filter((v2) => v2.filter), ({ key, label }, i2) => {
                                      return vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: i2 }, [
                                        vue.unref(isSelect)("prompt", key) ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_9, [
                                          vue.createElementVNode("div", _hoisted_10, [
                                            vue.createElementVNode("span", null, vue.toDisplayString(`${label}包含关键字`), 1),
                                            _hoisted_11
                                          ]),
                                          vue.createVNode(_component_el_input, {
                                            modelValue: vue.unref(settings)[k2].filter[key],
                                            "onUpdate:modelValue": ($event) => vue.unref(settings)[k2].filter[key] = $event,
                                            size: "small",
                                            placeholder: "关键字，多个使用 | 分割"
                                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                        ])) : vue.createCommentVNode("", true)
                                      ], 64);
                                    }), 128))
                                  ]),
                                  _: 2
                                }, 1032, ["modelValue", "onUpdate:modelValue"])
                              ]),
                              _: 2
                            }, 1032, ["label"]);
                          }), 64))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                vue.createVNode(_component_bf_express_order, {
                  orders: vue.unref(orderListByFilter),
                  config: settingConfig.display.items
                }, null, 8, ["orders", "config"])
              ]),
              _: 1
            }, 16, ["modelValue", "onOpen"]);
          };
        }
      });
      function _typeof$1(o2) {
        "@babel/helpers - typeof";
        return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
          return typeof o3;
        } : function(o3) {
          return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
        }, _typeof$1(o2);
      }
      function toPrimitive(t2, r2) {
        if ("object" != _typeof$1(t2) || !t2)
          return t2;
        var e2 = t2[Symbol.toPrimitive];
        if (void 0 !== e2) {
          var i2 = e2.call(t2, r2 || "default");
          if ("object" != _typeof$1(i2))
            return i2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r2 ? String : Number)(t2);
      }
      function toPropertyKey(t2) {
        var i2 = toPrimitive(t2, "string");
        return "symbol" == _typeof$1(i2) ? i2 : String(i2);
      }
      function _defineProperty$7(obj, key, value) {
        key = toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function ownKeys$1(e2, r2) {
        var t2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          r2 && (o2 = o2.filter(function(r3) {
            return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
          })), t2.push.apply(t2, o2);
        }
        return t2;
      }
      function _objectSpread2$1(e2) {
        for (var r2 = 1; r2 < arguments.length; r2++) {
          var t2 = null != arguments[r2] ? arguments[r2] : {};
          r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
            _defineProperty$7(e2, r3, t2[r3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
            Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
          });
        }
        return e2;
      }
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      const isFunction = (val) => typeof val === "function";
      const isArray = Array.isArray;
      const isString = (val) => typeof val === "string";
      const isObject = (val) => val !== null && typeof val === "object";
      const onRE = /^on[^a-z]/;
      const isOn = (key) => onRE.test(key);
      const cacheStringFunction = (fn2) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn2(str));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
      });
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cacheStringFunction((str) => {
        return str.replace(hyphenateRE, "-$1").toLowerCase();
      });
      const hasOwnProperty = Object.prototype.hasOwnProperty;
      const hasOwn = (val, key) => hasOwnProperty.call(val, key);
      function resolvePropValue(options, props, key, value) {
        const opt = options[key];
        if (opt != null) {
          const hasDefault = hasOwn(opt, "default");
          if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            value = opt.type !== Function && isFunction(defaultValue) ? defaultValue() : defaultValue;
          }
          if (opt.type === Boolean) {
            if (!hasOwn(props, key) && !hasDefault) {
              value = false;
            } else if (value === "") {
              value = true;
            }
          }
        }
        return value;
      }
      function classNames() {
        const classes = [];
        for (let i2 = 0; i2 < arguments.length; i2++) {
          const value = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
          if (!value)
            continue;
          if (isString(value)) {
            classes.push(value);
          } else if (isArray(value)) {
            for (let i3 = 0; i3 < value.length; i3++) {
              const inner = classNames(value[i3]);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (isObject(value)) {
            for (const name in value) {
              if (value[name]) {
                classes.push(name);
              }
            }
          }
        }
        return classes.join(" ");
      }
      var MapShim = function() {
        if (typeof Map !== "undefined") {
          return Map;
        }
        function getIndex(arr, key) {
          var result = -1;
          arr.some(function(entry, index2) {
            if (entry[0] === key) {
              result = index2;
              return true;
            }
            return false;
          });
          return result;
        }
        return (
          /** @class */
          function() {
            function class_1() {
              this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
              /**
               * @returns {boolean}
               */
              get: function() {
                return this.__entries__.length;
              },
              enumerable: true,
              configurable: true
            });
            class_1.prototype.get = function(key) {
              var index2 = getIndex(this.__entries__, key);
              var entry = this.__entries__[index2];
              return entry && entry[1];
            };
            class_1.prototype.set = function(key, value) {
              var index2 = getIndex(this.__entries__, key);
              if (~index2) {
                this.__entries__[index2][1] = value;
              } else {
                this.__entries__.push([key, value]);
              }
            };
            class_1.prototype.delete = function(key) {
              var entries = this.__entries__;
              var index2 = getIndex(entries, key);
              if (~index2) {
                entries.splice(index2, 1);
              }
            };
            class_1.prototype.has = function(key) {
              return !!~getIndex(this.__entries__, key);
            };
            class_1.prototype.clear = function() {
              this.__entries__.splice(0);
            };
            class_1.prototype.forEach = function(callback, ctx) {
              if (ctx === void 0) {
                ctx = null;
              }
              for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
                var entry = _a2[_i];
                callback.call(ctx, entry[1], entry[0]);
              }
            };
            return class_1;
          }()
        );
      }();
      var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
      var global$1 = function() {
        if (typeof global !== "undefined" && global.Math === Math) {
          return global;
        }
        if (typeof self !== "undefined" && self.Math === Math) {
          return self;
        }
        if (typeof window !== "undefined" && window.Math === Math) {
          return window;
        }
        return Function("return this")();
      }();
      var requestAnimationFrame$1 = function() {
        if (typeof requestAnimationFrame === "function") {
          return requestAnimationFrame.bind(global$1);
        }
        return function(callback) {
          return setTimeout(function() {
            return callback(Date.now());
          }, 1e3 / 60);
        };
      }();
      var trailingTimeout = 2;
      function throttle(callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        function resolvePending() {
          if (leadingCall) {
            leadingCall = false;
            callback();
          }
          if (trailingCall) {
            proxy();
          }
        }
        function timeoutCallback() {
          requestAnimationFrame$1(resolvePending);
        }
        function proxy() {
          var timeStamp = Date.now();
          if (leadingCall) {
            if (timeStamp - lastCallTime < trailingTimeout) {
              return;
            }
            trailingCall = true;
          } else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
          }
          lastCallTime = timeStamp;
        }
        return proxy;
      }
      var REFRESH_DELAY = 20;
      var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
      var mutationObserverSupported = typeof MutationObserver !== "undefined";
      var ResizeObserverController = (
        /** @class */
        function() {
          function ResizeObserverController2() {
            this.connected_ = false;
            this.mutationEventsAdded_ = false;
            this.mutationsObserver_ = null;
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
          }
          ResizeObserverController2.prototype.addObserver = function(observer) {
            if (!~this.observers_.indexOf(observer)) {
              this.observers_.push(observer);
            }
            if (!this.connected_) {
              this.connect_();
            }
          };
          ResizeObserverController2.prototype.removeObserver = function(observer) {
            var observers2 = this.observers_;
            var index2 = observers2.indexOf(observer);
            if (~index2) {
              observers2.splice(index2, 1);
            }
            if (!observers2.length && this.connected_) {
              this.disconnect_();
            }
          };
          ResizeObserverController2.prototype.refresh = function() {
            var changesDetected = this.updateObservers_();
            if (changesDetected) {
              this.refresh();
            }
          };
          ResizeObserverController2.prototype.updateObservers_ = function() {
            var activeObservers = this.observers_.filter(function(observer) {
              return observer.gatherActive(), observer.hasActive();
            });
            activeObservers.forEach(function(observer) {
              return observer.broadcastActive();
            });
            return activeObservers.length > 0;
          };
          ResizeObserverController2.prototype.connect_ = function() {
            if (!isBrowser || this.connected_) {
              return;
            }
            document.addEventListener("transitionend", this.onTransitionEnd_);
            window.addEventListener("resize", this.refresh);
            if (mutationObserverSupported) {
              this.mutationsObserver_ = new MutationObserver(this.refresh);
              this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
              });
            } else {
              document.addEventListener("DOMSubtreeModified", this.refresh);
              this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
          };
          ResizeObserverController2.prototype.disconnect_ = function() {
            if (!isBrowser || !this.connected_) {
              return;
            }
            document.removeEventListener("transitionend", this.onTransitionEnd_);
            window.removeEventListener("resize", this.refresh);
            if (this.mutationsObserver_) {
              this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
              document.removeEventListener("DOMSubtreeModified", this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
          };
          ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
            var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
            var isReflowProperty = transitionKeys.some(function(key) {
              return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
              this.refresh();
            }
          };
          ResizeObserverController2.getInstance = function() {
            if (!this.instance_) {
              this.instance_ = new ResizeObserverController2();
            }
            return this.instance_;
          };
          ResizeObserverController2.instance_ = null;
          return ResizeObserverController2;
        }()
      );
      var defineConfigurable = function(target, props) {
        for (var _i = 0, _a2 = Object.keys(props); _i < _a2.length; _i++) {
          var key = _a2[_i];
          Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
          });
        }
        return target;
      };
      var getWindowOf = function(target) {
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        return ownerGlobal || global$1;
      };
      var emptyRect = createRectInit(0, 0, 0, 0);
      function toFloat(value) {
        return parseFloat(value) || 0;
      }
      function getBordersSize(styles) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function(size, position2) {
          var value = styles["border-" + position2 + "-width"];
          return size + toFloat(value);
        }, 0);
      }
      function getPaddings(styles) {
        var positions = ["top", "right", "bottom", "left"];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position2 = positions_1[_i];
          var value = styles["padding-" + position2];
          paddings[position2] = toFloat(value);
        }
        return paddings;
      }
      function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
      }
      function getHTMLElementContentRect(target) {
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        if (!clientWidth && !clientHeight) {
          return emptyRect;
        }
        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        var width = toFloat(styles.width), height = toFloat(styles.height);
        if (styles.boxSizing === "border-box") {
          if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, "left", "right") + horizPad;
          }
          if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, "top", "bottom") + vertPad;
          }
        }
        if (!isDocumentElement(target)) {
          var vertScrollbar = Math.round(width + horizPad) - clientWidth;
          var horizScrollbar = Math.round(height + vertPad) - clientHeight;
          if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
          }
          if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
          }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
      }
      var isSVGGraphicsElement = function() {
        if (typeof SVGGraphicsElement !== "undefined") {
          return function(target) {
            return target instanceof getWindowOf(target).SVGGraphicsElement;
          };
        }
        return function(target) {
          return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
        };
      }();
      function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
      }
      function getContentRect(target) {
        if (!isBrowser) {
          return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
          return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
      }
      function createReadOnlyRect(_a2) {
        var x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
        var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        defineConfigurable(rect, {
          x: x2,
          y: y2,
          width,
          height,
          top: y2,
          right: x2 + width,
          bottom: height + y2,
          left: x2
        });
        return rect;
      }
      function createRectInit(x2, y2, width, height) {
        return { x: x2, y: y2, width, height };
      }
      var ResizeObservation = (
        /** @class */
        function() {
          function ResizeObservation2(target) {
            this.broadcastWidth = 0;
            this.broadcastHeight = 0;
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
          }
          ResizeObservation2.prototype.isActive = function() {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
          };
          ResizeObservation2.prototype.broadcastRect = function() {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
          };
          return ResizeObservation2;
        }()
      );
      var ResizeObserverEntry = (
        /** @class */
        /* @__PURE__ */ function() {
          function ResizeObserverEntry2(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            defineConfigurable(this, { target, contentRect });
          }
          return ResizeObserverEntry2;
        }()
      );
      var ResizeObserverSPI = (
        /** @class */
        function() {
          function ResizeObserverSPI2(callback, controller, callbackCtx) {
            this.activeObservations_ = [];
            this.observations_ = new MapShim();
            if (typeof callback !== "function") {
              throw new TypeError("The callback provided as parameter 1 is not a function.");
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
          }
          ResizeObserverSPI2.prototype.observe = function(target) {
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            if (typeof Element === "undefined" || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            if (observations.has(target)) {
              return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            this.controller_.refresh();
          };
          ResizeObserverSPI2.prototype.unobserve = function(target) {
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            if (typeof Element === "undefined" || !(Element instanceof Object)) {
              return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            if (!observations.has(target)) {
              return;
            }
            observations.delete(target);
            if (!observations.size) {
              this.controller_.removeObserver(this);
            }
          };
          ResizeObserverSPI2.prototype.disconnect = function() {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
          };
          ResizeObserverSPI2.prototype.gatherActive = function() {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function(observation) {
              if (observation.isActive()) {
                _this.activeObservations_.push(observation);
              }
            });
          };
          ResizeObserverSPI2.prototype.broadcastActive = function() {
            if (!this.hasActive()) {
              return;
            }
            var ctx = this.callbackCtx_;
            var entries = this.activeObservations_.map(function(observation) {
              return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
          };
          ResizeObserverSPI2.prototype.clearActive = function() {
            this.activeObservations_.splice(0);
          };
          ResizeObserverSPI2.prototype.hasActive = function() {
            return this.activeObservations_.length > 0;
          };
          return ResizeObserverSPI2;
        }()
      );
      var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
      var ResizeObserver$1 = (
        /** @class */
        /* @__PURE__ */ function() {
          function ResizeObserver2(callback) {
            if (!(this instanceof ResizeObserver2)) {
              throw new TypeError("Cannot call a class as a function.");
            }
            if (!arguments.length) {
              throw new TypeError("1 argument required, but only 0 present.");
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
          }
          return ResizeObserver2;
        }()
      );
      [
        "observe",
        "unobserve",
        "disconnect"
      ].forEach(function(method) {
        ResizeObserver$1.prototype[method] = function() {
          var _a2;
          return (_a2 = observers.get(this))[method].apply(_a2, arguments);
        };
      });
      var index = function() {
        if (typeof global$1.ResizeObserver !== "undefined") {
          return global$1.ResizeObserver;
        }
        return ResizeObserver$1;
      }();
      const isValid = (value) => {
        return value !== void 0 && value !== null && value !== "";
      };
      const initDefaultProps = (types2, defaultProps) => {
        const propTypes = _extends({}, types2);
        Object.keys(defaultProps).forEach((k2) => {
          const prop = propTypes[k2];
          if (prop) {
            if (prop.type || prop.default) {
              prop.default = defaultProps[k2];
            } else if (prop.def) {
              prop.def(defaultProps[k2]);
            } else {
              propTypes[k2] = {
                type: prop,
                default: defaultProps[k2]
              };
            }
          } else {
            throw new Error(`not have ${k2} prop`);
          }
        });
        return propTypes;
      };
      const splitAttrs = (attrs) => {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = {};
        const onEvents = {};
        const extraAttrs = {};
        for (let i2 = 0, l2 = allAttrs.length; i2 < l2; i2++) {
          const key = allAttrs[i2];
          if (isOn(key)) {
            eventAttrs[key[2].toLowerCase() + key.slice(3)] = attrs[key];
            onEvents[key] = attrs[key];
          } else {
            extraAttrs[key] = attrs[key];
          }
        }
        return {
          onEvents,
          events: eventAttrs,
          extraAttrs
        };
      };
      const parseStyleText = function() {
        let cssText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        let camel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        const res = {};
        const listDelimiter = /;(?![^(]*\))/g;
        const propertyDelimiter = /:(.+)/;
        if (typeof cssText === "object")
          return cssText;
        cssText.split(listDelimiter).forEach(function(item) {
          if (item) {
            const tmp = item.split(propertyDelimiter);
            if (tmp.length > 1) {
              const k2 = camel ? camelize(tmp[0].trim()) : tmp[0].trim();
              res[k2] = tmp[1].trim();
            }
          }
        });
        return res;
      };
      const hasProp = (instance, prop) => {
        return instance[prop] !== void 0;
      };
      const skipFlattenKey = Symbol("skipFlatten");
      const flattenChildren = function() {
        let children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        let filterEmpty2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        const temp = Array.isArray(children) ? children : [children];
        const res = [];
        temp.forEach((child) => {
          if (Array.isArray(child)) {
            res.push(...flattenChildren(child, filterEmpty2));
          } else if (child && child.type === vue.Fragment) {
            if (child.key === skipFlattenKey) {
              res.push(child);
            } else {
              res.push(...flattenChildren(child.children, filterEmpty2));
            }
          } else if (child && vue.isVNode(child)) {
            if (filterEmpty2 && !isEmptyElement(child)) {
              res.push(child);
            } else if (!filterEmpty2) {
              res.push(child);
            }
          } else if (isValid(child)) {
            res.push(child);
          }
        });
        return res;
      };
      const getSlot = function(self2) {
        let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (vue.isVNode(self2)) {
          if (self2.type === vue.Fragment) {
            return name === "default" ? flattenChildren(self2.children) : [];
          } else if (self2.children && self2.children[name]) {
            return flattenChildren(self2.children[name](options));
          } else {
            return [];
          }
        } else {
          const res = self2.$slots[name] && self2.$slots[name](options);
          return flattenChildren(res);
        }
      };
      const findDOMNode = (instance) => {
        var _a2;
        let node2 = ((_a2 = instance === null || instance === void 0 ? void 0 : instance.vnode) === null || _a2 === void 0 ? void 0 : _a2.el) || instance && (instance.$el || instance);
        while (node2 && !node2.tagName) {
          node2 = node2.nextSibling;
        }
        return node2;
      };
      const getOptionProps = (instance) => {
        const res = {};
        if (instance.$ && instance.$.vnode) {
          const props = instance.$.vnode.props || {};
          Object.keys(instance.$props).forEach((k2) => {
            const v2 = instance.$props[k2];
            const hyphenateKey = hyphenate(k2);
            if (v2 !== void 0 || hyphenateKey in props) {
              res[k2] = v2;
            }
          });
        } else if (vue.isVNode(instance) && typeof instance.type === "object") {
          const originProps = instance.props || {};
          const props = {};
          Object.keys(originProps).forEach((key) => {
            props[camelize(key)] = originProps[key];
          });
          const options = instance.type.props || {};
          Object.keys(options).forEach((k2) => {
            const v2 = resolvePropValue(options, props, k2, props[k2]);
            if (v2 !== void 0 || k2 in props) {
              res[k2] = v2;
            }
          });
        }
        return res;
      };
      const getComponent = function(instance) {
        let prop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : instance;
        let execute = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
        let com = void 0;
        if (instance.$) {
          const temp = instance[prop];
          if (temp !== void 0) {
            return typeof temp === "function" && execute ? temp(options) : temp;
          } else {
            com = instance.$slots[prop];
            com = execute && com ? com(options) : com;
          }
        } else if (vue.isVNode(instance)) {
          const temp = instance.props && instance.props[prop];
          if (temp !== void 0 && instance.props !== null) {
            return typeof temp === "function" && execute ? temp(options) : temp;
          } else if (instance.type === vue.Fragment) {
            com = instance.children;
          } else if (instance.children && instance.children[prop]) {
            com = instance.children[prop];
            com = execute && com ? com(options) : com;
          }
        }
        if (Array.isArray(com)) {
          com = flattenChildren(com);
          com = com.length === 1 ? com[0] : com;
          com = com.length === 0 ? void 0 : com;
        }
        return com;
      };
      function getEvents() {
        let ele = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let on2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        let props = {};
        if (ele.$) {
          props = _extends(_extends({}, props), ele.$attrs);
        } else {
          props = _extends(_extends({}, props), ele.props);
        }
        return splitAttrs(props)[on2 ? "onEvents" : "events"];
      }
      function getStyle(ele, camel) {
        const props = (vue.isVNode(ele) ? ele.props : ele.$attrs) || {};
        let style = props.style || {};
        if (typeof style === "string") {
          style = parseStyleText(style, camel);
        } else if (camel && style) {
          const res = {};
          Object.keys(style).forEach((k2) => res[camelize(k2)] = style[k2]);
          return res;
        }
        return style;
      }
      function isFragment(c2) {
        return c2.length === 1 && c2[0].type === vue.Fragment;
      }
      function isEmptyElement(c2) {
        return c2 && (c2.type === vue.Comment || c2.type === vue.Fragment && c2.children.length === 0 || c2.type === vue.Text && c2.children.trim() === "");
      }
      function filterEmpty() {
        let children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        const res = [];
        children.forEach((child) => {
          if (Array.isArray(child)) {
            res.push(...child);
          } else if ((child === null || child === void 0 ? void 0 : child.type) === vue.Fragment) {
            res.push(...filterEmpty(child.children));
          } else {
            res.push(child);
          }
        });
        return res.filter((c2) => !isEmptyElement(c2));
      }
      function isValidElement(element) {
        if (Array.isArray(element) && element.length === 1) {
          element = element[0];
        }
        return element && element.__v_isVNode && typeof element.type !== "symbol";
      }
      function getPropsSlot(slots, props) {
        let prop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
        var _a2, _b;
        return (_a2 = props[prop]) !== null && _a2 !== void 0 ? _a2 : (_b = slots[prop]) === null || _b === void 0 ? void 0 : _b.call(slots);
      }
      let raf = (callback) => setTimeout(callback, 16);
      let caf = (num) => clearTimeout(num);
      if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
        raf = (callback) => window.requestAnimationFrame(callback);
        caf = (handle) => window.cancelAnimationFrame(handle);
      }
      let rafUUID = 0;
      const rafIds = /* @__PURE__ */ new Map();
      function cleanup(id) {
        rafIds.delete(id);
      }
      function wrapperRaf(callback) {
        let times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        rafUUID += 1;
        const id = rafUUID;
        function callRef(leftTimes) {
          if (leftTimes === 0) {
            cleanup(id);
            callback();
          } else {
            const realId = raf(() => {
              callRef(leftTimes - 1);
            });
            rafIds.set(id, realId);
          }
        }
        callRef(times);
        return id;
      }
      wrapperRaf.cancel = (id) => {
        const realId = rafIds.get(id);
        cleanup(realId);
        return caf(realId);
      };
      function throttleByAnimationFrame(fn2) {
        let requestId;
        const later = (args) => () => {
          requestId = null;
          fn2(...args);
        };
        const throttled = function() {
          if (requestId == null) {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            requestId = wrapperRaf(later(args));
          }
        };
        throttled.cancel = () => {
          wrapperRaf.cancel(requestId);
          requestId = null;
        };
        return throttled;
      }
      const tuple = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return args;
      };
      const withInstall = (comp) => {
        const c2 = comp;
        c2.install = function(app) {
          app.component(c2.displayName || c2.name, comp);
        };
        return comp;
      };
      function objectType(defaultVal) {
        return {
          type: Object,
          default: defaultVal
        };
      }
      function booleanType(defaultVal) {
        return {
          type: Boolean,
          default: defaultVal
        };
      }
      function functionType(defaultVal) {
        return {
          type: Function,
          default: defaultVal
        };
      }
      function anyType(defaultVal, required) {
        const type3 = {
          validator: () => true,
          default: defaultVal
        };
        return required ? type3 : type3;
      }
      function arrayType(defaultVal) {
        return {
          type: Array,
          default: defaultVal
        };
      }
      function stringType(defaultVal) {
        return {
          type: String,
          default: defaultVal
        };
      }
      function someType(types2, defaultVal) {
        return types2 ? {
          type: types2,
          default: defaultVal
        } : anyType(defaultVal);
      }
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, "passive", {
          get() {
            supportsPassive = true;
          }
        });
        window.addEventListener("testPassive", null, opts);
        window.removeEventListener("testPassive", null, opts);
      } catch (e2) {
      }
      const supportsPassive$1 = supportsPassive;
      function addEventListenerWrap(target, eventType, cb, option) {
        if (target && target.addEventListener) {
          let opt = option;
          if (opt === void 0 && supportsPassive$1 && (eventType === "touchstart" || eventType === "touchmove" || eventType === "wheel")) {
            opt = {
              passive: false
            };
          }
          target.addEventListener(eventType, cb, opt);
        }
        return {
          remove: () => {
            if (target && target.removeEventListener) {
              target.removeEventListener(eventType, cb);
            }
          }
        };
      }
      const defaultIconPrefixCls = "anticon";
      const configProviderKey = Symbol("configProvider");
      const defaultConfigProvider = {
        getPrefixCls: (suffixCls, customizePrefixCls) => {
          if (customizePrefixCls)
            return customizePrefixCls;
          return suffixCls ? `ant-${suffixCls}` : "ant";
        },
        iconPrefixCls: vue.computed(() => defaultIconPrefixCls),
        getPopupContainer: vue.computed(() => () => document.body),
        direction: vue.computed(() => "ltr")
      };
      const useConfigContextInject = () => {
        return vue.inject(configProviderKey, defaultConfigProvider);
      };
      const DisabledContextKey = Symbol("DisabledContextKey");
      const useInjectDisabled = () => {
        return vue.inject(DisabledContextKey, vue.ref(void 0));
      };
      const enUS$1 = {
        // Options.jsx
        items_per_page: "/ page",
        jump_to: "Go to",
        jump_to_confirm: "confirm",
        page: "",
        // Pagination.jsx
        prev_page: "Previous Page",
        next_page: "Next Page",
        prev_5: "Previous 5 Pages",
        next_5: "Next 5 Pages",
        prev_3: "Previous 3 Pages",
        next_3: "Next 3 Pages"
      };
      const locale$2 = {
        locale: "en_US",
        today: "Today",
        now: "Now",
        backToToday: "Back to today",
        ok: "Ok",
        clear: "Clear",
        month: "Month",
        year: "Year",
        timeSelect: "select time",
        dateSelect: "select date",
        weekSelect: "Choose a week",
        monthSelect: "Choose a month",
        yearSelect: "Choose a year",
        decadeSelect: "Choose a decade",
        yearFormat: "YYYY",
        dateFormat: "M/D/YYYY",
        dayFormat: "D",
        dateTimeFormat: "M/D/YYYY HH:mm:ss",
        monthBeforeYear: true,
        previousMonth: "Previous month (PageUp)",
        nextMonth: "Next month (PageDown)",
        previousYear: "Last year (Control + left)",
        nextYear: "Next year (Control + right)",
        previousDecade: "Last decade",
        nextDecade: "Next decade",
        previousCentury: "Last century",
        nextCentury: "Next century"
      };
      const CalendarLocale = locale$2;
      const locale$1 = {
        placeholder: "Select time",
        rangePlaceholder: ["Start time", "End time"]
      };
      const TimePicker = locale$1;
      const locale = {
        lang: _extends({
          placeholder: "Select date",
          yearPlaceholder: "Select year",
          quarterPlaceholder: "Select quarter",
          monthPlaceholder: "Select month",
          weekPlaceholder: "Select week",
          rangePlaceholder: ["Start date", "End date"],
          rangeYearPlaceholder: ["Start year", "End year"],
          rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
          rangeMonthPlaceholder: ["Start month", "End month"],
          rangeWeekPlaceholder: ["Start week", "End week"]
        }, CalendarLocale),
        timePickerLocale: _extends({}, TimePicker)
      };
      const enUS = locale;
      const typeTemplate = "${label} is not a valid ${type}";
      const localeValues = {
        locale: "en",
        Pagination: enUS$1,
        DatePicker: enUS,
        TimePicker,
        Calendar: enUS,
        global: {
          placeholder: "Please select"
        },
        Table: {
          filterTitle: "Filter menu",
          filterConfirm: "OK",
          filterReset: "Reset",
          filterEmptyText: "No filters",
          filterCheckall: "Select all items",
          filterSearchPlaceholder: "Search in filters",
          emptyText: "No data",
          selectAll: "Select current page",
          selectInvert: "Invert current page",
          selectNone: "Clear all data",
          selectionAll: "Select all data",
          sortTitle: "Sort",
          expand: "Expand row",
          collapse: "Collapse row",
          triggerDesc: "Click to sort descending",
          triggerAsc: "Click to sort ascending",
          cancelSort: "Click to cancel sorting"
        },
        Tour: {
          Next: "Next",
          Previous: "Previous",
          Finish: "Finish"
        },
        Modal: {
          okText: "OK",
          cancelText: "Cancel",
          justOkText: "OK"
        },
        Popconfirm: {
          okText: "OK",
          cancelText: "Cancel"
        },
        Transfer: {
          titles: ["", ""],
          searchPlaceholder: "Search here",
          itemUnit: "item",
          itemsUnit: "items",
          remove: "Remove",
          selectCurrent: "Select current page",
          removeCurrent: "Remove current page",
          selectAll: "Select all data",
          removeAll: "Remove all data",
          selectInvert: "Invert current page"
        },
        Upload: {
          uploading: "Uploading...",
          removeFile: "Remove file",
          uploadError: "Upload error",
          previewFile: "Preview file",
          downloadFile: "Download file"
        },
        Empty: {
          description: "No data"
        },
        Icon: {
          icon: "icon"
        },
        Text: {
          edit: "Edit",
          copy: "Copy",
          copied: "Copied",
          expand: "Expand"
        },
        PageHeader: {
          back: "Back"
        },
        Form: {
          optional: "(optional)",
          defaultValidateMessages: {
            default: "Field validation error for ${label}",
            required: "Please enter ${label}",
            enum: "${label} must be one of [${enum}]",
            whitespace: "${label} cannot be a blank character",
            date: {
              format: "${label} date format is invalid",
              parse: "${label} cannot be converted to a date",
              invalid: "${label} is an invalid date"
            },
            types: {
              string: typeTemplate,
              method: typeTemplate,
              array: typeTemplate,
              object: typeTemplate,
              number: typeTemplate,
              date: typeTemplate,
              boolean: typeTemplate,
              integer: typeTemplate,
              float: typeTemplate,
              regexp: typeTemplate,
              email: typeTemplate,
              url: typeTemplate,
              hex: typeTemplate
            },
            string: {
              len: "${label} must be ${len} characters",
              min: "${label} must be at least ${min} characters",
              max: "${label} must be up to ${max} characters",
              range: "${label} must be between ${min}-${max} characters"
            },
            number: {
              len: "${label} must be equal to ${len}",
              min: "${label} must be minimum ${min}",
              max: "${label} must be maximum ${max}",
              range: "${label} must be between ${min}-${max}"
            },
            array: {
              len: "Must be ${len} ${label}",
              min: "At least ${min} ${label}",
              max: "At most ${max} ${label}",
              range: "The amount of ${label} must be between ${min}-${max}"
            },
            pattern: {
              mismatch: "${label} does not match the pattern ${pattern}"
            }
          }
        },
        Image: {
          preview: "Preview"
        },
        QRCode: {
          expired: "QR code expired",
          refresh: "Refresh",
          scanned: "Scanned"
        }
      };
      const LocaleReceiver = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "LocaleReceiver",
        props: {
          componentName: String,
          defaultLocale: {
            type: [Object, Function]
          },
          children: {
            type: Function
          }
        },
        setup(props, _ref) {
          let {
            slots
          } = _ref;
          const localeData = vue.inject("localeData", {});
          const locale2 = vue.computed(() => {
            const {
              componentName = "global",
              defaultLocale
            } = props;
            const locale3 = defaultLocale || localeValues[componentName || "global"];
            const {
              antLocale
            } = localeData;
            const localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
            return _extends(_extends({}, typeof locale3 === "function" ? locale3() : locale3), localeFromContext || {});
          });
          const localeCode = vue.computed(() => {
            const {
              antLocale
            } = localeData;
            const localeCode2 = antLocale && antLocale.locale;
            if (antLocale && antLocale.exist && !localeCode2) {
              return localeValues.locale;
            }
            return localeCode2;
          });
          return () => {
            const children = props.children || slots.default;
            const {
              antLocale
            } = localeData;
            return children === null || children === void 0 ? void 0 : children(locale2.value, localeCode.value, antLocale);
          };
        }
      });
      function murmur2(str) {
        var h2 = 0;
        var k2, i2 = 0, len = str.length;
        for (; len >= 4; ++i2, len -= 4) {
          k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
          k2 = /* Math.imul(k, m): */
          (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
          k2 ^= /* k >>> r: */
          k2 >>> 24;
          h2 = /* Math.imul(k, m): */
          (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        }
        switch (len) {
          case 3:
            h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
          case 2:
            h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
          case 1:
            h2 ^= str.charCodeAt(i2) & 255;
            h2 = /* Math.imul(h, m): */
            (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        }
        h2 ^= h2 >>> 13;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
      }
      const SPLIT = "%";
      class Entity {
        constructor(instanceId) {
          this.cache = /* @__PURE__ */ new Map();
          this.instanceId = instanceId;
        }
        get(keys2) {
          return this.cache.get(Array.isArray(keys2) ? keys2.join(SPLIT) : keys2) || null;
        }
        update(keys2, valueFn) {
          const path = Array.isArray(keys2) ? keys2.join(SPLIT) : keys2;
          const prevValue = this.cache.get(path);
          const nextValue = valueFn(prevValue);
          if (nextValue === null) {
            this.cache.delete(path);
          } else {
            this.cache.set(path, nextValue);
          }
        }
      }
      const CacheEntity = Entity;
      const ATTR_TOKEN = "data-token-hash";
      const ATTR_MARK = "data-css-hash";
      const CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
      function createCache() {
        const cssinjsInstanceId = Math.random().toString(12).slice(2);
        if (typeof document !== "undefined" && document.head && document.body) {
          const styles = document.body.querySelectorAll(`style[${ATTR_MARK}]`) || [];
          const {
            firstChild
          } = document.head;
          Array.from(styles).forEach((style) => {
            style[CSS_IN_JS_INSTANCE] = style[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
            if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
              document.head.insertBefore(style, firstChild);
            }
          });
          const styleHash = {};
          Array.from(document.querySelectorAll(`style[${ATTR_MARK}]`)).forEach((style) => {
            var _a2;
            const hash = style.getAttribute(ATTR_MARK);
            if (styleHash[hash]) {
              if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
                (_a2 = style.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(style);
              }
            } else {
              styleHash[hash] = true;
            }
          });
        }
        return new CacheEntity(cssinjsInstanceId);
      }
      const StyleContextKey = Symbol("StyleContextKey");
      const getCache = () => {
        var _a2, _b, _c;
        const instance = vue.getCurrentInstance();
        let cache;
        if (instance && instance.appContext) {
          const globalCache = (_c = (_b = (_a2 = instance.appContext) === null || _a2 === void 0 ? void 0 : _a2.config) === null || _b === void 0 ? void 0 : _b.globalProperties) === null || _c === void 0 ? void 0 : _c.__ANTDV_CSSINJS_CACHE__;
          if (globalCache) {
            cache = globalCache;
          } else {
            cache = createCache();
            if (instance.appContext.config.globalProperties) {
              instance.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = cache;
            }
          }
        } else {
          cache = createCache();
        }
        return cache;
      };
      const defaultStyleContext = {
        cache: createCache(),
        defaultCache: true,
        hashPriority: "low"
      };
      const useStyleInject = () => {
        const cache = getCache();
        return vue.inject(StyleContextKey, vue.shallowRef(_extends(_extends({}, defaultStyleContext), {
          cache
        })));
      };
      const useStyleProvider = (props) => {
        const parentContext = useStyleInject();
        const context = vue.shallowRef(_extends(_extends({}, defaultStyleContext), {
          cache: createCache()
        }));
        vue.watch([() => vue.unref(props), parentContext], () => {
          const mergedContext = _extends({}, parentContext.value);
          const propsValue = vue.unref(props);
          Object.keys(propsValue).forEach((key) => {
            const value = propsValue[key];
            if (propsValue[key] !== void 0) {
              mergedContext[key] = value;
            }
          });
          const {
            cache
          } = propsValue;
          mergedContext.cache = mergedContext.cache || createCache();
          mergedContext.defaultCache = !cache && parentContext.value.defaultCache;
          context.value = mergedContext;
        }, {
          immediate: true
        });
        vue.provide(StyleContextKey, context);
        return context;
      };
      const styleProviderProps = () => ({
        autoClear: booleanType(),
        /** @private Test only. Not work in production. */
        mock: stringType(),
        /**
         * Only set when you need ssr to extract style on you own.
         * If not provided, it will auto create <style /> on the end of Provider in server side.
         */
        cache: objectType(),
        /** Tell children that this context is default generated context */
        defaultCache: booleanType(),
        /** Use `:where` selector to reduce hashId css selector priority */
        hashPriority: stringType(),
        /** Tell cssinjs where to inject style in */
        container: someType(),
        /** Component wil render inline  `<style />` for fallback in SSR. Not recommend. */
        ssrInline: booleanType(),
        /** Transform css before inject in document. Please note that `transformers` do not support dynamic update */
        transformers: arrayType(),
        /**
         * Linters to lint css before inject in document.
         * Styles will be linted after transforming.
         * Please note that `linters` do not support dynamic update.
         */
        linters: arrayType()
      });
      withInstall(vue.defineComponent({
        name: "AStyleProvider",
        inheritAttrs: false,
        props: styleProviderProps(),
        setup(props, _ref) {
          let {
            slots
          } = _ref;
          useStyleProvider(props);
          return () => {
            var _a2;
            return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
          };
        }
      }));
      function useClientCache(prefix, keyPath, cacheFn, onCacheRemove) {
        const styleContext = useStyleInject();
        const fullPathStr = vue.shallowRef("");
        const res = vue.shallowRef();
        vue.watchEffect(() => {
          fullPathStr.value = [prefix, ...keyPath.value].join("%");
        });
        const clearCache = (pathStr) => {
          styleContext.value.cache.update(pathStr, (prevCache) => {
            const [times = 0, cache] = prevCache || [];
            const nextCount = times - 1;
            if (nextCount === 0) {
              onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(cache, false);
              return null;
            }
            return [times - 1, cache];
          });
        };
        vue.watch(fullPathStr, (newStr, oldStr) => {
          if (oldStr)
            clearCache(oldStr);
          styleContext.value.cache.update(newStr, (prevCache) => {
            const [times = 0, cache] = prevCache || [];
            let tmpCache = cache;
            const mergedCache = tmpCache || cacheFn();
            return [times + 1, mergedCache];
          });
          res.value = styleContext.value.cache.get(fullPathStr.value)[1];
        }, {
          immediate: true
        });
        vue.onBeforeUnmount(() => {
          clearCache(fullPathStr.value);
        });
        return res;
      }
      function canUseDom$1() {
        return !!(typeof window !== "undefined" && window.document && window.document.createElement);
      }
      function contains$1(root2, n2) {
        if (!root2) {
          return false;
        }
        if (root2.contains) {
          return root2.contains(n2);
        }
        return false;
      }
      const APPEND_ORDER$1 = "data-vc-order";
      const MARK_KEY$1 = `vc-util-key`;
      const containerCache$1 = /* @__PURE__ */ new Map();
      function getMark$1() {
        let {
          mark
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (mark) {
          return mark.startsWith("data-") ? mark : `data-${mark}`;
        }
        return MARK_KEY$1;
      }
      function getContainer$1(option) {
        if (option.attachTo) {
          return option.attachTo;
        }
        const head = document.querySelector("head");
        return head || document.body;
      }
      function getOrder$1(prepend) {
        if (prepend === "queue") {
          return "prependQueue";
        }
        return prepend ? "prepend" : "append";
      }
      function findStyles$1(container) {
        return Array.from((containerCache$1.get(container) || container).children).filter((node2) => node2.tagName === "STYLE");
      }
      function injectCSS$1(css2) {
        let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!canUseDom$1()) {
          return null;
        }
        const {
          csp,
          prepend
        } = option;
        const styleNode = document.createElement("style");
        styleNode.setAttribute(APPEND_ORDER$1, getOrder$1(prepend));
        if (csp === null || csp === void 0 ? void 0 : csp.nonce) {
          styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
        }
        styleNode.innerHTML = css2;
        const container = getContainer$1(option);
        const {
          firstChild
        } = container;
        if (prepend) {
          if (prepend === "queue") {
            const existStyle = findStyles$1(container).filter((node2) => ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$1)));
            if (existStyle.length) {
              container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
              return styleNode;
            }
          }
          container.insertBefore(styleNode, firstChild);
        } else {
          container.appendChild(styleNode);
        }
        return styleNode;
      }
      function findExistNode$1(key) {
        let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const container = getContainer$1(option);
        return findStyles$1(container).find((node2) => node2.getAttribute(getMark$1(option)) === key);
      }
      function removeCSS(key) {
        let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const existNode = findExistNode$1(key, option);
        if (existNode) {
          const container = getContainer$1(option);
          container.removeChild(existNode);
        }
      }
      function syncRealContainer$1(container, option) {
        const cachedRealContainer = containerCache$1.get(container);
        if (!cachedRealContainer || !contains$1(document, cachedRealContainer)) {
          const placeholderStyle = injectCSS$1("", option);
          const {
            parentNode
          } = placeholderStyle;
          containerCache$1.set(container, parentNode);
          container.removeChild(placeholderStyle);
        }
      }
      function updateCSS$1(css2, key) {
        let option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var _a2, _b, _c;
        const container = getContainer$1(option);
        syncRealContainer$1(container, option);
        const existNode = findExistNode$1(key, option);
        if (existNode) {
          if (((_a2 = option.csp) === null || _a2 === void 0 ? void 0 : _a2.nonce) && existNode.nonce !== ((_b = option.csp) === null || _b === void 0 ? void 0 : _b.nonce)) {
            existNode.nonce = (_c = option.csp) === null || _c === void 0 ? void 0 : _c.nonce;
          }
          if (existNode.innerHTML !== css2) {
            existNode.innerHTML = css2;
          }
          return existNode;
        }
        const newNode = injectCSS$1(css2, option);
        newNode.setAttribute(getMark$1(option), key);
        return newNode;
      }
      function sameDerivativeOption(left, right) {
        if (left.length !== right.length) {
          return false;
        }
        for (let i2 = 0; i2 < left.length; i2++) {
          if (left[i2] !== right[i2]) {
            return false;
          }
        }
        return true;
      }
      class ThemeCache {
        constructor() {
          this.cache = /* @__PURE__ */ new Map();
          this.keys = [];
          this.cacheCallTimes = 0;
        }
        size() {
          return this.keys.length;
        }
        internalGet(derivativeOption) {
          let updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          let cache = {
            map: this.cache
          };
          derivativeOption.forEach((derivative2) => {
            var _a2;
            if (!cache) {
              cache = void 0;
            } else {
              cache = (_a2 = cache === null || cache === void 0 ? void 0 : cache.map) === null || _a2 === void 0 ? void 0 : _a2.get(derivative2);
            }
          });
          if ((cache === null || cache === void 0 ? void 0 : cache.value) && updateCallTimes) {
            cache.value[1] = this.cacheCallTimes++;
          }
          return cache === null || cache === void 0 ? void 0 : cache.value;
        }
        get(derivativeOption) {
          var _a2;
          return (_a2 = this.internalGet(derivativeOption, true)) === null || _a2 === void 0 ? void 0 : _a2[0];
        }
        has(derivativeOption) {
          return !!this.internalGet(derivativeOption);
        }
        set(derivativeOption, value) {
          if (!this.has(derivativeOption)) {
            if (this.size() + 1 > ThemeCache.MAX_CACHE_SIZE + ThemeCache.MAX_CACHE_OFFSET) {
              const [targetKey] = this.keys.reduce((result, key) => {
                const [, callTimes] = result;
                if (this.internalGet(key)[1] < callTimes) {
                  return [key, this.internalGet(key)[1]];
                }
                return result;
              }, [this.keys[0], this.cacheCallTimes]);
              this.delete(targetKey);
            }
            this.keys.push(derivativeOption);
          }
          let cache = this.cache;
          derivativeOption.forEach((derivative2, index2) => {
            if (index2 === derivativeOption.length - 1) {
              cache.set(derivative2, {
                value: [value, this.cacheCallTimes++]
              });
            } else {
              const cacheValue = cache.get(derivative2);
              if (!cacheValue) {
                cache.set(derivative2, {
                  map: /* @__PURE__ */ new Map()
                });
              } else if (!cacheValue.map) {
                cacheValue.map = /* @__PURE__ */ new Map();
              }
              cache = cache.get(derivative2).map;
            }
          });
        }
        deleteByPath(currentCache, derivatives) {
          var _a2;
          const cache = currentCache.get(derivatives[0]);
          if (derivatives.length === 1) {
            if (!cache.map) {
              currentCache.delete(derivatives[0]);
            } else {
              currentCache.set(derivatives[0], {
                map: cache.map
              });
            }
            return (_a2 = cache.value) === null || _a2 === void 0 ? void 0 : _a2[0];
          }
          const result = this.deleteByPath(cache.map, derivatives.slice(1));
          if ((!cache.map || cache.map.size === 0) && !cache.value) {
            currentCache.delete(derivatives[0]);
          }
          return result;
        }
        delete(derivativeOption) {
          if (this.has(derivativeOption)) {
            this.keys = this.keys.filter((item) => !sameDerivativeOption(item, derivativeOption));
            return this.deleteByPath(this.cache, derivativeOption);
          }
          return void 0;
        }
      }
      ThemeCache.MAX_CACHE_SIZE = 20;
      ThemeCache.MAX_CACHE_OFFSET = 5;
      function noop$3() {
      }
      let warning$1 = noop$3;
      let uuid$1 = 0;
      class Theme {
        constructor(derivatives) {
          this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
          this.id = uuid$1;
          if (derivatives.length === 0) {
            warning$1(derivatives.length > 0);
          }
          uuid$1 += 1;
        }
        getDerivativeToken(token2) {
          return this.derivatives.reduce((result, derivative2) => derivative2(token2, result), void 0);
        }
      }
      const cacheThemes = new ThemeCache();
      function createTheme(derivatives) {
        const derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
        if (!cacheThemes.has(derivativeArr)) {
          cacheThemes.set(derivativeArr, new Theme(derivativeArr));
        }
        return cacheThemes.get(derivativeArr);
      }
      const flattenTokenCache = /* @__PURE__ */ new WeakMap();
      function flattenToken(token2) {
        let str = flattenTokenCache.get(token2) || "";
        if (!str) {
          Object.keys(token2).forEach((key) => {
            const value = token2[key];
            str += key;
            if (value instanceof Theme) {
              str += value.id;
            } else if (value && typeof value === "object") {
              str += flattenToken(value);
            } else {
              str += value;
            }
          });
          flattenTokenCache.set(token2, str);
        }
        return str;
      }
      function token2key(token2, salt) {
        return murmur2(`${salt}_${flattenToken(token2)}`);
      }
      const randomSelectorKey = `random-${Date.now()}-${Math.random()}`.replace(/\./g, "");
      const checkContent = "_bAmBoO_";
      function supportSelector(styleStr, handleElement, supportCheck) {
        var _a2, _b;
        if (canUseDom$1()) {
          updateCSS$1(styleStr, randomSelectorKey);
          const ele = document.createElement("div");
          ele.style.position = "fixed";
          ele.style.left = "0";
          ele.style.top = "0";
          handleElement === null || handleElement === void 0 ? void 0 : handleElement(ele);
          document.body.appendChild(ele);
          const support = supportCheck ? supportCheck(ele) : (_a2 = getComputedStyle(ele).content) === null || _a2 === void 0 ? void 0 : _a2.includes(checkContent);
          (_b = ele.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(ele);
          removeCSS(randomSelectorKey);
          return support;
        }
        return false;
      }
      let canLayer = void 0;
      function supportLayer() {
        if (canLayer === void 0) {
          canLayer = supportSelector(`@layer ${randomSelectorKey} { .${randomSelectorKey} { content: "${checkContent}"!important; } }`, (ele) => {
            ele.className = randomSelectorKey;
          });
        }
        return canLayer;
      }
      const EMPTY_OVERRIDE = {};
      const hashPrefix = "css";
      const tokenKeys = /* @__PURE__ */ new Map();
      function recordCleanToken(tokenKey) {
        tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
      }
      function removeStyleTags(key, instanceId) {
        if (typeof document !== "undefined") {
          const styles = document.querySelectorAll(`style[${ATTR_TOKEN}="${key}"]`);
          styles.forEach((style) => {
            var _a2;
            if (style[CSS_IN_JS_INSTANCE] === instanceId) {
              (_a2 = style.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(style);
            }
          });
        }
      }
      const TOKEN_THRESHOLD = 0;
      function cleanTokenStyle(tokenKey, instanceId) {
        tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
        const tokenKeyList = Array.from(tokenKeys.keys());
        const cleanableKeyList = tokenKeyList.filter((key) => {
          const count = tokenKeys.get(key) || 0;
          return count <= 0;
        });
        if (tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD) {
          cleanableKeyList.forEach((key) => {
            removeStyleTags(key, instanceId);
            tokenKeys.delete(key);
          });
        }
      }
      const getComputedToken = (originToken, overrideToken, theme, format2) => {
        const derivativeToken = theme.getDerivativeToken(originToken);
        let mergedDerivativeToken = _extends(_extends({}, derivativeToken), overrideToken);
        if (format2) {
          mergedDerivativeToken = format2(mergedDerivativeToken);
        }
        return mergedDerivativeToken;
      };
      function useCacheToken(theme, tokens) {
        let option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : vue.ref({});
        const style = useStyleInject();
        const mergedToken = vue.computed(() => _extends({}, ...tokens.value));
        const tokenStr = vue.computed(() => flattenToken(mergedToken.value));
        const overrideTokenStr = vue.computed(() => flattenToken(option.value.override || EMPTY_OVERRIDE));
        const cachedToken = useClientCache("token", vue.computed(() => [option.value.salt || "", theme.value.id, tokenStr.value, overrideTokenStr.value]), () => {
          const {
            salt = "",
            override = EMPTY_OVERRIDE,
            formatToken: formatToken2,
            getComputedToken: compute
          } = option.value;
          const mergedDerivativeToken = compute ? compute(mergedToken.value, override, theme.value) : getComputedToken(mergedToken.value, override, theme.value, formatToken2);
          const tokenKey = token2key(mergedDerivativeToken, salt);
          mergedDerivativeToken._tokenKey = tokenKey;
          recordCleanToken(tokenKey);
          const hashId = `${hashPrefix}-${murmur2(tokenKey)}`;
          mergedDerivativeToken._hashId = hashId;
          return [mergedDerivativeToken, hashId];
        }, (cache) => {
          var _a2;
          cleanTokenStyle(cache[0]._tokenKey, (_a2 = style.value) === null || _a2 === void 0 ? void 0 : _a2.cache.instanceId);
        });
        return cachedToken;
      }
      var unitlessKeys = {
        animationIterationCount: 1,
        aspectRatio: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        // SVG-related properties
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
      };
      var COMMENT = "comm";
      var RULESET = "rule";
      var DECLARATION = "decl";
      var IMPORT = "@import";
      var KEYFRAMES = "@keyframes";
      var LAYER = "@layer";
      var abs = Math.abs;
      var from = String.fromCharCode;
      function trim(value) {
        return value.trim();
      }
      function replace(value, pattern, replacement) {
        return value.replace(pattern, replacement);
      }
      function indexof(value, search, position2) {
        return value.indexOf(search, position2);
      }
      function charat(value, index2) {
        return value.charCodeAt(index2) | 0;
      }
      function substr(value, begin, end) {
        return value.slice(begin, end);
      }
      function strlen(value) {
        return value.length;
      }
      function sizeof(value) {
        return value.length;
      }
      function append(value, array) {
        return array.push(value), value;
      }
      var line = 1;
      var column = 1;
      var length = 0;
      var position = 0;
      var character = 0;
      var characters = "";
      function node(value, root2, parent, type3, props, children, length2, siblings) {
        return { value, root: root2, parent, type: type3, props, children, line, column, length: length2, return: "", siblings };
      }
      function char() {
        return character;
      }
      function prev() {
        character = position > 0 ? charat(characters, --position) : 0;
        if (column--, character === 10)
          column = 1, line--;
        return character;
      }
      function next() {
        character = position < length ? charat(characters, position++) : 0;
        if (column++, character === 10)
          column = 1, line++;
        return character;
      }
      function peek() {
        return charat(characters, position);
      }
      function caret() {
        return position;
      }
      function slice(begin, end) {
        return substr(characters, begin, end);
      }
      function token(type3) {
        switch (type3) {
          case 0:
          case 9:
          case 10:
          case 13:
          case 32:
            return 5;
          case 33:
          case 43:
          case 44:
          case 47:
          case 62:
          case 64:
          case 126:
          case 59:
          case 123:
          case 125:
            return 4;
          case 58:
            return 3;
          case 34:
          case 39:
          case 40:
          case 91:
            return 2;
          case 41:
          case 93:
            return 1;
        }
        return 0;
      }
      function alloc(value) {
        return line = column = 1, length = strlen(characters = value), position = 0, [];
      }
      function dealloc(value) {
        return characters = "", value;
      }
      function delimit(type3) {
        return trim(slice(position - 1, delimiter(type3 === 91 ? type3 + 2 : type3 === 40 ? type3 + 1 : type3)));
      }
      function whitespace(type3) {
        while (character = peek())
          if (character < 33)
            next();
          else
            break;
        return token(type3) > 2 || token(character) > 3 ? "" : " ";
      }
      function escaping(index2, count) {
        while (--count && next())
          if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
            break;
        return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
      }
      function delimiter(type3) {
        while (next())
          switch (character) {
            case type3:
              return position;
            case 34:
            case 39:
              if (type3 !== 34 && type3 !== 39)
                delimiter(character);
              break;
            case 40:
              if (type3 === 41)
                delimiter(type3);
              break;
            case 92:
              next();
              break;
          }
        return position;
      }
      function commenter(type3, index2) {
        while (next())
          if (type3 + character === 47 + 10)
            break;
          else if (type3 + character === 42 + 42 && peek() === 47)
            break;
        return "/*" + slice(index2, position - 1) + "*" + from(type3 === 47 ? type3 : next());
      }
      function identifier(index2) {
        while (!token(peek()))
          next();
        return slice(index2, position);
      }
      function compile(value) {
        return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
      }
      function parse(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
        var index2 = 0;
        var offset = 0;
        var length2 = pseudo;
        var atrule = 0;
        var property2 = 0;
        var previous = 0;
        var variable = 1;
        var scanning = 1;
        var ampersand = 1;
        var character2 = 0;
        var type3 = "";
        var props = rules2;
        var children = rulesets;
        var reference = rule;
        var characters2 = type3;
        while (scanning)
          switch (previous = character2, character2 = next()) {
            case 40:
              if (previous != 108 && charat(characters2, length2 - 1) == 58) {
                if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index2 ? points[index2 - 1] : 0)) != -1)
                  ampersand = -1;
                break;
              }
            case 34:
            case 39:
            case 91:
              characters2 += delimit(character2);
              break;
            case 9:
            case 10:
            case 13:
            case 32:
              characters2 += whitespace(previous);
              break;
            case 92:
              characters2 += escaping(caret() - 1, 7);
              continue;
            case 47:
              switch (peek()) {
                case 42:
                case 47:
                  append(comment(commenter(next(), caret()), root2, parent, declarations), declarations);
                  break;
                default:
                  characters2 += "/";
              }
              break;
            case 123 * variable:
              points[index2++] = strlen(characters2) * ampersand;
            case 125 * variable:
            case 59:
            case 0:
              switch (character2) {
                case 0:
                case 125:
                  scanning = 0;
                case 59 + offset:
                  if (ampersand == -1)
                    characters2 = replace(characters2, /\f/g, "");
                  if (property2 > 0 && strlen(characters2) - length2)
                    append(property2 > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
                  break;
                case 59:
                  characters2 += ";";
                default:
                  append(reference = ruleset(characters2, root2, parent, index2, offset, rules2, points, type3, props = [], children = [], length2, rulesets), rulesets);
                  if (character2 === 123)
                    if (offset === 0)
                      parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                    else
                      switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                          parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type3, rules2, props = [], length2, children), children), rules2, children, length2, points, rule ? props : children);
                          break;
                        default:
                          parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                      }
              }
              index2 = offset = property2 = 0, variable = ampersand = 1, type3 = characters2 = "", length2 = pseudo;
              break;
            case 58:
              length2 = 1 + strlen(characters2), property2 = previous;
            default:
              if (variable < 1) {
                if (character2 == 123)
                  --variable;
                else if (character2 == 125 && variable++ == 0 && prev() == 125)
                  continue;
              }
              switch (characters2 += from(character2), character2 * variable) {
                case 38:
                  ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
                  break;
                case 44:
                  points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                  break;
                case 64:
                  if (peek() === 45)
                    characters2 += delimit(next());
                  atrule = peek(), offset = length2 = strlen(type3 = characters2 += identifier(caret())), character2++;
                  break;
                case 45:
                  if (previous === 45 && strlen(characters2) == 2)
                    variable = 0;
              }
          }
        return rulesets;
      }
      function ruleset(value, root2, parent, index2, offset, rules2, points, type3, props, children, length2, siblings) {
        var post = offset - 1;
        var rule = offset === 0 ? rules2 : [""];
        var size = sizeof(rule);
        for (var i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2)
          for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
            if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
              props[k2++] = z2;
        return node(value, root2, parent, offset === 0 ? RULESET : type3, props, children, length2, siblings);
      }
      function comment(value, root2, parent, siblings) {
        return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
      }
      function declaration(value, root2, parent, length2, siblings) {
        return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
      }
      function serialize(children, callback) {
        var output = "";
        for (var i2 = 0; i2 < children.length; i2++)
          output += callback(children[i2], i2, children, callback) || "";
        return output;
      }
      function stringify(element, index2, children, callback) {
        switch (element.type) {
          case LAYER:
            if (element.children.length)
              break;
          case IMPORT:
          case DECLARATION:
            return element.return = element.return || element.value;
          case COMMENT:
            return "";
          case KEYFRAMES:
            return element.return = element.value + "{" + serialize(element.children, callback) + "}";
          case RULESET:
            if (!strlen(element.value = element.props.join(",")))
              return "";
        }
        return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
      }
      const ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
      const CSS_FILE_STYLE = "_FILE_STYLE__";
      let cachePathMap;
      let fromCSSFile = true;
      function prepare() {
        var _a2;
        if (!cachePathMap) {
          cachePathMap = {};
          if (canUseDom$1()) {
            const div = document.createElement("div");
            div.className = ATTR_CACHE_MAP;
            div.style.position = "fixed";
            div.style.visibility = "hidden";
            div.style.top = "-9999px";
            document.body.appendChild(div);
            let content = getComputedStyle(div).content || "";
            content = content.replace(/^"/, "").replace(/"$/, "");
            content.split(";").forEach((item) => {
              const [path, hash] = item.split(":");
              cachePathMap[path] = hash;
            });
            const inlineMapStyle = document.querySelector(`style[${ATTR_CACHE_MAP}]`);
            if (inlineMapStyle) {
              fromCSSFile = false;
              (_a2 = inlineMapStyle.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(inlineMapStyle);
            }
            document.body.removeChild(div);
          }
        }
      }
      function existPath(path) {
        prepare();
        return !!cachePathMap[path];
      }
      function getStyleAndHash(path) {
        const hash = cachePathMap[path];
        let styleStr = null;
        if (hash && canUseDom$1()) {
          if (fromCSSFile) {
            styleStr = CSS_FILE_STYLE;
          } else {
            const style = document.querySelector(`style[${ATTR_MARK}="${cachePathMap[path]}"]`);
            if (style) {
              styleStr = style.innerHTML;
            } else {
              delete cachePathMap[path];
            }
          }
        }
        return [styleStr, hash];
      }
      const isClientSide = canUseDom$1();
      const SKIP_CHECK = "_skip_check_";
      const MULTI_VALUE = "_multi_value_";
      function normalizeStyle(styleStr) {
        const serialized = serialize(compile(styleStr), stringify);
        return serialized.replace(/\{%%%\:[^;];}/g, ";");
      }
      function isCompoundCSSProperty(value) {
        return typeof value === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
      }
      function injectSelectorHash(key, hashId, hashPriority) {
        if (!hashId) {
          return key;
        }
        const hashClassName = `.${hashId}`;
        const hashSelector = hashPriority === "low" ? `:where(${hashClassName})` : hashClassName;
        const keys2 = key.split(",").map((k2) => {
          var _a2;
          const fullPath = k2.trim().split(/\s+/);
          let firstPath = fullPath[0] || "";
          const htmlElement = ((_a2 = firstPath.match(/^\w+/)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "";
          firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;
          return [firstPath, ...fullPath.slice(1)].join(" ");
        });
        return keys2.join(",");
      }
      const globalEffectStyleKeys = /* @__PURE__ */ new Set();
      const parseStyle = function(interpolation) {
        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let {
          root: root2,
          injectHash,
          parentSelectors
        } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
          root: true,
          parentSelectors: []
        };
        const {
          hashId,
          layer,
          path,
          hashPriority,
          transformers = [],
          linters = []
        } = config;
        let styleStr = "";
        let effectStyle = {};
        function parseKeyframes(keyframes) {
          const animationName = keyframes.getName(hashId);
          if (!effectStyle[animationName]) {
            const [parsedStr] = parseStyle(keyframes.style, config, {
              root: false,
              parentSelectors
            });
            effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;
          }
        }
        function flattenList(list) {
          let fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          list.forEach((item) => {
            if (Array.isArray(item)) {
              flattenList(item, fullList);
            } else if (item) {
              fullList.push(item);
            }
          });
          return fullList;
        }
        const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
        flattenStyleList.forEach((originStyle) => {
          const style = typeof originStyle === "string" && !root2 ? {} : originStyle;
          if (typeof style === "string") {
            styleStr += `${style}
`;
          } else if (style._keyframe) {
            parseKeyframes(style);
          } else {
            const mergedStyle = transformers.reduce((prev2, trans) => {
              var _a2;
              return ((_a2 = trans === null || trans === void 0 ? void 0 : trans.visit) === null || _a2 === void 0 ? void 0 : _a2.call(trans, prev2)) || prev2;
            }, style);
            Object.keys(mergedStyle).forEach((key) => {
              var _a2;
              const value = mergedStyle[key];
              if (typeof value === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
                let subInjectHash = false;
                let mergedKey = key.trim();
                let nextRoot = false;
                if ((root2 || injectHash) && hashId) {
                  if (mergedKey.startsWith("@")) {
                    subInjectHash = true;
                  } else {
                    mergedKey = injectSelectorHash(key, hashId, hashPriority);
                  }
                } else if (root2 && !hashId && (mergedKey === "&" || mergedKey === "")) {
                  mergedKey = "";
                  nextRoot = true;
                }
                const [parsedStr, childEffectStyle] = parseStyle(value, config, {
                  root: nextRoot,
                  injectHash: subInjectHash,
                  parentSelectors: [...parentSelectors, mergedKey]
                });
                effectStyle = _extends(_extends({}, effectStyle), childEffectStyle);
                styleStr += `${mergedKey}${parsedStr}`;
              } else {
                let appendStyle = function(cssKey, cssValue) {
                  const styleName = cssKey.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);
                  let formatValue = cssValue;
                  if (!unitlessKeys[cssKey] && typeof formatValue === "number" && formatValue !== 0) {
                    formatValue = `${formatValue}px`;
                  }
                  if (cssKey === "animationName" && (cssValue === null || cssValue === void 0 ? void 0 : cssValue._keyframe)) {
                    parseKeyframes(cssValue);
                    formatValue = cssValue.getName(hashId);
                  }
                  styleStr += `${styleName}:${formatValue};`;
                };
                const actualValue = (_a2 = value === null || value === void 0 ? void 0 : value.value) !== null && _a2 !== void 0 ? _a2 : value;
                if (typeof value === "object" && (value === null || value === void 0 ? void 0 : value[MULTI_VALUE]) && Array.isArray(actualValue)) {
                  actualValue.forEach((item) => {
                    appendStyle(key, item);
                  });
                } else {
                  appendStyle(key, actualValue);
                }
              }
            });
          }
        });
        if (!root2) {
          styleStr = `{${styleStr}}`;
        } else if (layer && supportLayer()) {
          const layerCells = layer.split(",");
          const layerName = layerCells[layerCells.length - 1].trim();
          styleStr = `@layer ${layerName} {${styleStr}}`;
          if (layerCells.length > 1) {
            styleStr = `@layer ${layer}{%%%:%}${styleStr}`;
          }
        }
        return [styleStr, effectStyle];
      };
      function uniqueHash(path, styleStr) {
        return murmur2(`${path.join("%")}${styleStr}`);
      }
      function useStyleRegister(info, styleFn) {
        const styleContext = useStyleInject();
        const tokenKey = vue.computed(() => info.value.token._tokenKey);
        const fullPath = vue.computed(() => [tokenKey.value, ...info.value.path]);
        let isMergedClientSide = isClientSide;
        useClientCache(
          "style",
          fullPath,
          // Create cache if needed
          () => {
            const {
              path,
              hashId,
              layer,
              nonce,
              clientOnly,
              order = 0
            } = info.value;
            const cachePath = fullPath.value.join("|");
            if (existPath(cachePath)) {
              const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);
              if (inlineCacheStyleStr) {
                return [inlineCacheStyleStr, tokenKey.value, styleHash, {}, clientOnly, order];
              }
            }
            const styleObj = styleFn();
            const {
              hashPriority,
              container,
              transformers,
              linters,
              cache
            } = styleContext.value;
            const [parsedStyle, effectStyle] = parseStyle(styleObj, {
              hashId,
              hashPriority,
              layer,
              path: path.join("-"),
              transformers,
              linters
            });
            const styleStr = normalizeStyle(parsedStyle);
            const styleId = uniqueHash(fullPath.value, styleStr);
            if (isMergedClientSide) {
              const mergedCSSConfig = {
                mark: ATTR_MARK,
                prepend: "queue",
                attachTo: container,
                priority: order
              };
              const nonceStr = typeof nonce === "function" ? nonce() : nonce;
              if (nonceStr) {
                mergedCSSConfig.csp = {
                  nonce: nonceStr
                };
              }
              const style = updateCSS$1(styleStr, styleId, mergedCSSConfig);
              style[CSS_IN_JS_INSTANCE] = cache.instanceId;
              style.setAttribute(ATTR_TOKEN, tokenKey.value);
              Object.keys(effectStyle).forEach((effectKey) => {
                if (!globalEffectStyleKeys.has(effectKey)) {
                  globalEffectStyleKeys.add(effectKey);
                  updateCSS$1(normalizeStyle(effectStyle[effectKey]), `_effect-${effectKey}`, {
                    mark: ATTR_MARK,
                    prepend: "queue",
                    attachTo: container
                  });
                }
              });
            }
            return [styleStr, tokenKey.value, styleId, effectStyle, clientOnly, order];
          },
          // Remove cache if no need
          (_ref, fromHMR) => {
            let [, , styleId] = _ref;
            if ((fromHMR || styleContext.value.autoClear) && isClientSide) {
              removeCSS(styleId, {
                mark: ATTR_MARK
              });
            }
          }
        );
        return (node2) => {
          return node2;
        };
      }
      class Keyframe {
        constructor(name, style) {
          this._keyframe = true;
          this.name = name;
          this.style = style;
        }
        getName() {
          let hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return hashId ? `${hashId}-${this.name}` : this.name;
        }
      }
      const version = "4.1.1";
      const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
      var hueStep = 2;
      var saturationStep = 0.16;
      var saturationStep2 = 0.05;
      var brightnessStep1 = 0.05;
      var brightnessStep2 = 0.15;
      var lightColorCount = 5;
      var darkColorCount = 4;
      var darkColorMap = [{
        index: 7,
        opacity: 0.15
      }, {
        index: 6,
        opacity: 0.25
      }, {
        index: 5,
        opacity: 0.3
      }, {
        index: 5,
        opacity: 0.45
      }, {
        index: 5,
        opacity: 0.65
      }, {
        index: 5,
        opacity: 0.85
      }, {
        index: 4,
        opacity: 0.9
      }, {
        index: 3,
        opacity: 0.95
      }, {
        index: 2,
        opacity: 0.97
      }, {
        index: 1,
        opacity: 0.98
      }];
      function toHsv(_ref) {
        var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
        var hsv = rgbToHsv(r2, g2, b2);
        return {
          h: hsv.h * 360,
          s: hsv.s,
          v: hsv.v
        };
      }
      function toHex(_ref2) {
        var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
        return "#".concat(rgbToHex(r2, g2, b2, false));
      }
      function mix$1(rgb1, rgb2, amount) {
        var p = amount / 100;
        var rgb = {
          r: (rgb2.r - rgb1.r) * p + rgb1.r,
          g: (rgb2.g - rgb1.g) * p + rgb1.g,
          b: (rgb2.b - rgb1.b) * p + rgb1.b
        };
        return rgb;
      }
      function getHue(hsv, i2, light) {
        var hue;
        if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
          hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
        } else {
          hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
        }
        if (hue < 0) {
          hue += 360;
        } else if (hue >= 360) {
          hue -= 360;
        }
        return hue;
      }
      function getSaturation(hsv, i2, light) {
        if (hsv.h === 0 && hsv.s === 0) {
          return hsv.s;
        }
        var saturation;
        if (light) {
          saturation = hsv.s - saturationStep * i2;
        } else if (i2 === darkColorCount) {
          saturation = hsv.s + saturationStep;
        } else {
          saturation = hsv.s + saturationStep2 * i2;
        }
        if (saturation > 1) {
          saturation = 1;
        }
        if (light && i2 === lightColorCount && saturation > 0.1) {
          saturation = 0.1;
        }
        if (saturation < 0.06) {
          saturation = 0.06;
        }
        return Number(saturation.toFixed(2));
      }
      function getValue(hsv, i2, light) {
        var value;
        if (light) {
          value = hsv.v + brightnessStep1 * i2;
        } else {
          value = hsv.v - brightnessStep2 * i2;
        }
        if (value > 1) {
          value = 1;
        }
        return Number(value.toFixed(2));
      }
      function generate$1(color) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var patterns = [];
        var pColor = inputToRGB(color);
        for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
          var hsv = toHsv(pColor);
          var colorString = toHex(inputToRGB({
            h: getHue(hsv, i2, true),
            s: getSaturation(hsv, i2, true),
            v: getValue(hsv, i2, true)
          }));
          patterns.push(colorString);
        }
        patterns.push(toHex(pColor));
        for (var _i = 1; _i <= darkColorCount; _i += 1) {
          var _hsv = toHsv(pColor);
          var _colorString = toHex(inputToRGB({
            h: getHue(_hsv, _i),
            s: getSaturation(_hsv, _i),
            v: getValue(_hsv, _i)
          }));
          patterns.push(_colorString);
        }
        if (opts.theme === "dark") {
          return darkColorMap.map(function(_ref3) {
            var index2 = _ref3.index, opacity = _ref3.opacity;
            var darkColorString = toHex(mix$1(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
            return darkColorString;
          });
        }
        return patterns;
      }
      var presetPrimaryColors = {
        red: "#F5222D",
        volcano: "#FA541C",
        orange: "#FA8C16",
        gold: "#FAAD14",
        yellow: "#FADB14",
        lime: "#A0D911",
        green: "#52C41A",
        cyan: "#13C2C2",
        blue: "#1890FF",
        geekblue: "#2F54EB",
        purple: "#722ED1",
        magenta: "#EB2F96",
        grey: "#666666"
      };
      var presetPalettes = {};
      var presetDarkPalettes = {};
      Object.keys(presetPrimaryColors).forEach(function(key) {
        presetPalettes[key] = generate$1(presetPrimaryColors[key]);
        presetPalettes[key].primary = presetPalettes[key][5];
        presetDarkPalettes[key] = generate$1(presetPrimaryColors[key], {
          theme: "dark",
          backgroundColor: "#141414"
        });
        presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
      });
      var blue = presetPalettes.blue;
      const genControlHeight = (token2) => {
        const {
          controlHeight
        } = token2;
        return {
          controlHeightSM: controlHeight * 0.75,
          controlHeightXS: controlHeight * 0.5,
          controlHeightLG: controlHeight * 1.25
        };
      };
      function genSizeMapToken(token2) {
        const {
          sizeUnit,
          sizeStep
        } = token2;
        return {
          sizeXXL: sizeUnit * (sizeStep + 8),
          sizeXL: sizeUnit * (sizeStep + 4),
          sizeLG: sizeUnit * (sizeStep + 2),
          sizeMD: sizeUnit * (sizeStep + 1),
          sizeMS: sizeUnit * sizeStep,
          size: sizeUnit * sizeStep,
          sizeSM: sizeUnit * (sizeStep - 1),
          sizeXS: sizeUnit * (sizeStep - 2),
          sizeXXS: sizeUnit * (sizeStep - 3)
          // 4
        };
      }
      const defaultPresetColors = {
        blue: "#1677ff",
        purple: "#722ED1",
        cyan: "#13C2C2",
        green: "#52C41A",
        magenta: "#EB2F96",
        pink: "#eb2f96",
        red: "#F5222D",
        orange: "#FA8C16",
        yellow: "#FADB14",
        volcano: "#FA541C",
        geekblue: "#2F54EB",
        gold: "#FAAD14",
        lime: "#A0D911"
      };
      const seedToken = _extends(_extends({}, defaultPresetColors), {
        // Color
        colorPrimary: "#1677ff",
        colorSuccess: "#52c41a",
        colorWarning: "#faad14",
        colorError: "#ff4d4f",
        colorInfo: "#1677ff",
        colorTextBase: "",
        colorBgBase: "",
        // Font
        fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
        fontSize: 14,
        // Line
        lineWidth: 1,
        lineType: "solid",
        // Motion
        motionUnit: 0.1,
        motionBase: 0,
        motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
        motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
        motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
        motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
        motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
        motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
        motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
        motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
        // Radius
        borderRadius: 6,
        // Size
        sizeUnit: 4,
        sizeStep: 4,
        sizePopupArrow: 16,
        // Control Base
        controlHeight: 32,
        // zIndex
        zIndexBase: 0,
        zIndexPopupBase: 1e3,
        // Image
        opacityImage: 1,
        // Wireframe
        wireframe: false
      });
      const defaultSeedToken = seedToken;
      function genColorMapToken(seed2, _ref) {
        let {
          generateColorPalettes: generateColorPalettes2,
          generateNeutralColorPalettes: generateNeutralColorPalettes2
        } = _ref;
        const {
          colorSuccess: colorSuccessBase,
          colorWarning: colorWarningBase,
          colorError: colorErrorBase,
          colorInfo: colorInfoBase,
          colorPrimary: colorPrimaryBase,
          colorBgBase,
          colorTextBase
        } = seed2;
        const primaryColors = generateColorPalettes2(colorPrimaryBase);
        const successColors = generateColorPalettes2(colorSuccessBase);
        const warningColors = generateColorPalettes2(colorWarningBase);
        const errorColors = generateColorPalettes2(colorErrorBase);
        const infoColors = generateColorPalettes2(colorInfoBase);
        const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
        return _extends(_extends({}, neutralColors), {
          colorPrimaryBg: primaryColors[1],
          colorPrimaryBgHover: primaryColors[2],
          colorPrimaryBorder: primaryColors[3],
          colorPrimaryBorderHover: primaryColors[4],
          colorPrimaryHover: primaryColors[5],
          colorPrimary: primaryColors[6],
          colorPrimaryActive: primaryColors[7],
          colorPrimaryTextHover: primaryColors[8],
          colorPrimaryText: primaryColors[9],
          colorPrimaryTextActive: primaryColors[10],
          colorSuccessBg: successColors[1],
          colorSuccessBgHover: successColors[2],
          colorSuccessBorder: successColors[3],
          colorSuccessBorderHover: successColors[4],
          colorSuccessHover: successColors[4],
          colorSuccess: successColors[6],
          colorSuccessActive: successColors[7],
          colorSuccessTextHover: successColors[8],
          colorSuccessText: successColors[9],
          colorSuccessTextActive: successColors[10],
          colorErrorBg: errorColors[1],
          colorErrorBgHover: errorColors[2],
          colorErrorBorder: errorColors[3],
          colorErrorBorderHover: errorColors[4],
          colorErrorHover: errorColors[5],
          colorError: errorColors[6],
          colorErrorActive: errorColors[7],
          colorErrorTextHover: errorColors[8],
          colorErrorText: errorColors[9],
          colorErrorTextActive: errorColors[10],
          colorWarningBg: warningColors[1],
          colorWarningBgHover: warningColors[2],
          colorWarningBorder: warningColors[3],
          colorWarningBorderHover: warningColors[4],
          colorWarningHover: warningColors[4],
          colorWarning: warningColors[6],
          colorWarningActive: warningColors[7],
          colorWarningTextHover: warningColors[8],
          colorWarningText: warningColors[9],
          colorWarningTextActive: warningColors[10],
          colorInfoBg: infoColors[1],
          colorInfoBgHover: infoColors[2],
          colorInfoBorder: infoColors[3],
          colorInfoBorderHover: infoColors[4],
          colorInfoHover: infoColors[4],
          colorInfo: infoColors[6],
          colorInfoActive: infoColors[7],
          colorInfoTextHover: infoColors[8],
          colorInfoText: infoColors[9],
          colorInfoTextActive: infoColors[10],
          colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
          colorWhite: "#fff"
        });
      }
      const genRadius = (radiusBase) => {
        let radiusLG = radiusBase;
        let radiusSM = radiusBase;
        let radiusXS = radiusBase;
        let radiusOuter = radiusBase;
        if (radiusBase < 6 && radiusBase >= 5) {
          radiusLG = radiusBase + 1;
        } else if (radiusBase < 16 && radiusBase >= 6) {
          radiusLG = radiusBase + 2;
        } else if (radiusBase >= 16) {
          radiusLG = 16;
        }
        if (radiusBase < 7 && radiusBase >= 5) {
          radiusSM = 4;
        } else if (radiusBase < 8 && radiusBase >= 7) {
          radiusSM = 5;
        } else if (radiusBase < 14 && radiusBase >= 8) {
          radiusSM = 6;
        } else if (radiusBase < 16 && radiusBase >= 14) {
          radiusSM = 7;
        } else if (radiusBase >= 16) {
          radiusSM = 8;
        }
        if (radiusBase < 6 && radiusBase >= 2) {
          radiusXS = 1;
        } else if (radiusBase >= 6) {
          radiusXS = 2;
        }
        if (radiusBase > 4 && radiusBase < 8) {
          radiusOuter = 4;
        } else if (radiusBase >= 8) {
          radiusOuter = 6;
        }
        return {
          borderRadius: radiusBase > 16 ? 16 : radiusBase,
          borderRadiusXS: radiusXS,
          borderRadiusSM: radiusSM,
          borderRadiusLG: radiusLG,
          borderRadiusOuter: radiusOuter
        };
      };
      function genCommonMapToken(token2) {
        const {
          motionUnit,
          motionBase,
          borderRadius,
          lineWidth
        } = token2;
        return _extends({
          // motion
          motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
          motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
          motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
          // line
          lineWidthBold: lineWidth + 1
        }, genRadius(borderRadius));
      }
      const getAlphaColor$1 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
      const getSolidColor = (baseColor, brightness) => {
        const instance = new TinyColor(baseColor);
        return instance.darken(brightness).toHexString();
      };
      const generateColorPalettes = (baseColor) => {
        const colors = generate$1(baseColor);
        return {
          1: colors[0],
          2: colors[1],
          3: colors[2],
          4: colors[3],
          5: colors[4],
          6: colors[5],
          7: colors[6],
          8: colors[4],
          9: colors[5],
          10: colors[6]
          // 8: colors[7],
          // 9: colors[8],
          // 10: colors[9],
        };
      };
      const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
        const colorBgBase = bgBaseColor || "#fff";
        const colorTextBase = textBaseColor || "#000";
        return {
          colorBgBase,
          colorTextBase,
          colorText: getAlphaColor$1(colorTextBase, 0.88),
          colorTextSecondary: getAlphaColor$1(colorTextBase, 0.65),
          colorTextTertiary: getAlphaColor$1(colorTextBase, 0.45),
          colorTextQuaternary: getAlphaColor$1(colorTextBase, 0.25),
          colorFill: getAlphaColor$1(colorTextBase, 0.15),
          colorFillSecondary: getAlphaColor$1(colorTextBase, 0.06),
          colorFillTertiary: getAlphaColor$1(colorTextBase, 0.04),
          colorFillQuaternary: getAlphaColor$1(colorTextBase, 0.02),
          colorBgLayout: getSolidColor(colorBgBase, 4),
          colorBgContainer: getSolidColor(colorBgBase, 0),
          colorBgElevated: getSolidColor(colorBgBase, 0),
          colorBgSpotlight: getAlphaColor$1(colorTextBase, 0.85),
          colorBorder: getSolidColor(colorBgBase, 15),
          colorBorderSecondary: getSolidColor(colorBgBase, 6)
        };
      };
      function getFontSizes(base) {
        const fontSizes = new Array(10).fill(null).map((_2, index2) => {
          const i2 = index2 - 1;
          const baseSize = base * Math.pow(2.71828, i2 / 5);
          const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
          return Math.floor(intSize / 2) * 2;
        });
        fontSizes[1] = base;
        return fontSizes.map((size) => {
          const height = size + 8;
          return {
            size,
            lineHeight: height / size
          };
        });
      }
      const genFontMapToken = (fontSize) => {
        const fontSizePairs = getFontSizes(fontSize);
        const fontSizes = fontSizePairs.map((pair) => pair.size);
        const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
        return {
          fontSizeSM: fontSizes[0],
          fontSize: fontSizes[1],
          fontSizeLG: fontSizes[2],
          fontSizeXL: fontSizes[3],
          fontSizeHeading1: fontSizes[6],
          fontSizeHeading2: fontSizes[5],
          fontSizeHeading3: fontSizes[4],
          fontSizeHeading4: fontSizes[3],
          fontSizeHeading5: fontSizes[2],
          lineHeight: lineHeights[1],
          lineHeightLG: lineHeights[2],
          lineHeightSM: lineHeights[0],
          lineHeightHeading1: lineHeights[6],
          lineHeightHeading2: lineHeights[5],
          lineHeightHeading3: lineHeights[4],
          lineHeightHeading4: lineHeights[3],
          lineHeightHeading5: lineHeights[2]
        };
      };
      function derivative(token2) {
        const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
          const colors = generate$1(token2[colorKey]);
          return new Array(10).fill(1).reduce((prev2, _2, i2) => {
            prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
            return prev2;
          }, {});
        }).reduce((prev2, cur) => {
          prev2 = _extends(_extends({}, prev2), cur);
          return prev2;
        }, {});
        return _extends(_extends(_extends(_extends(_extends(_extends(_extends({}, token2), colorPalettes), genColorMapToken(token2, {
          generateColorPalettes,
          generateNeutralColorPalettes
        })), genFontMapToken(token2.fontSize)), genSizeMapToken(token2)), genControlHeight(token2)), genCommonMapToken(token2));
      }
      function isStableColor(color) {
        return color >= 0 && color <= 255;
      }
      function getAlphaColor(frontColor, backgroundColor) {
        const {
          r: fR,
          g: fG,
          b: fB,
          a: originAlpha
        } = new TinyColor(frontColor).toRgb();
        if (originAlpha < 1) {
          return frontColor;
        }
        const {
          r: bR,
          g: bG,
          b: bB
        } = new TinyColor(backgroundColor).toRgb();
        for (let fA = 0.01; fA <= 1; fA += 0.01) {
          const r2 = Math.round((fR - bR * (1 - fA)) / fA);
          const g2 = Math.round((fG - bG * (1 - fA)) / fA);
          const b2 = Math.round((fB - bB * (1 - fA)) / fA);
          if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
            return new TinyColor({
              r: r2,
              g: g2,
              b: b2,
              a: Math.round(fA * 100) / 100
            }).toRgbString();
          }
        }
        return new TinyColor({
          r: fR,
          g: fG,
          b: fB,
          a: 1
        }).toRgbString();
      }
      var __rest$5 = function(s2, e2) {
        var t2 = {};
        for (var p in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
            t2[p] = s2[p];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
              t2[p[i2]] = s2[p[i2]];
          }
        return t2;
      };
      function formatToken(derivativeToken) {
        const {
          override
        } = derivativeToken, restToken = __rest$5(derivativeToken, ["override"]);
        const overrideTokens = _extends({}, override);
        Object.keys(defaultSeedToken).forEach((token2) => {
          delete overrideTokens[token2];
        });
        const mergedToken = _extends(_extends({}, restToken), overrideTokens);
        const screenXS = 480;
        const screenSM = 576;
        const screenMD = 768;
        const screenLG = 992;
        const screenXL = 1200;
        const screenXXL = 1600;
        const screenXXXL = 2e3;
        const aliasToken = _extends(_extends(_extends({}, mergedToken), {
          colorLink: mergedToken.colorInfoText,
          colorLinkHover: mergedToken.colorInfoHover,
          colorLinkActive: mergedToken.colorInfoActive,
          // ============== Background ============== //
          colorFillContent: mergedToken.colorFillSecondary,
          colorFillContentHover: mergedToken.colorFill,
          colorFillAlter: mergedToken.colorFillQuaternary,
          colorBgContainerDisabled: mergedToken.colorFillTertiary,
          // ============== Split ============== //
          colorBorderBg: mergedToken.colorBgContainer,
          colorSplit: getAlphaColor(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
          // ============== Text ============== //
          colorTextPlaceholder: mergedToken.colorTextQuaternary,
          colorTextDisabled: mergedToken.colorTextQuaternary,
          colorTextHeading: mergedToken.colorText,
          colorTextLabel: mergedToken.colorTextSecondary,
          colorTextDescription: mergedToken.colorTextTertiary,
          colorTextLightSolid: mergedToken.colorWhite,
          colorHighlight: mergedToken.colorError,
          colorBgTextHover: mergedToken.colorFillSecondary,
          colorBgTextActive: mergedToken.colorFill,
          colorIcon: mergedToken.colorTextTertiary,
          colorIconHover: mergedToken.colorText,
          colorErrorOutline: getAlphaColor(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
          colorWarningOutline: getAlphaColor(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
          // Font
          fontSizeIcon: mergedToken.fontSizeSM,
          // Control
          lineWidth: mergedToken.lineWidth,
          controlOutlineWidth: mergedToken.lineWidth * 2,
          // Checkbox size and expand icon size
          controlInteractiveSize: mergedToken.controlHeight / 2,
          controlItemBgHover: mergedToken.colorFillTertiary,
          controlItemBgActive: mergedToken.colorPrimaryBg,
          controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
          controlItemBgActiveDisabled: mergedToken.colorFill,
          controlTmpOutline: mergedToken.colorFillQuaternary,
          controlOutline: getAlphaColor(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
          lineType: mergedToken.lineType,
          borderRadius: mergedToken.borderRadius,
          borderRadiusXS: mergedToken.borderRadiusXS,
          borderRadiusSM: mergedToken.borderRadiusSM,
          borderRadiusLG: mergedToken.borderRadiusLG,
          fontWeightStrong: 600,
          opacityLoading: 0.65,
          linkDecoration: "none",
          linkHoverDecoration: "none",
          linkFocusDecoration: "none",
          controlPaddingHorizontal: 12,
          controlPaddingHorizontalSM: 8,
          paddingXXS: mergedToken.sizeXXS,
          paddingXS: mergedToken.sizeXS,
          paddingSM: mergedToken.sizeSM,
          padding: mergedToken.size,
          paddingMD: mergedToken.sizeMD,
          paddingLG: mergedToken.sizeLG,
          paddingXL: mergedToken.sizeXL,
          paddingContentHorizontalLG: mergedToken.sizeLG,
          paddingContentVerticalLG: mergedToken.sizeMS,
          paddingContentHorizontal: mergedToken.sizeMS,
          paddingContentVertical: mergedToken.sizeSM,
          paddingContentHorizontalSM: mergedToken.size,
          paddingContentVerticalSM: mergedToken.sizeXS,
          marginXXS: mergedToken.sizeXXS,
          marginXS: mergedToken.sizeXS,
          marginSM: mergedToken.sizeSM,
          margin: mergedToken.size,
          marginMD: mergedToken.sizeMD,
          marginLG: mergedToken.sizeLG,
          marginXL: mergedToken.sizeXL,
          marginXXL: mergedToken.sizeXXL,
          boxShadow: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
          boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
          boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
          screenXS,
          screenXSMin: screenXS,
          screenXSMax: screenSM - 1,
          screenSM,
          screenSMMin: screenSM,
          screenSMMax: screenMD - 1,
          screenMD,
          screenMDMin: screenMD,
          screenMDMax: screenLG - 1,
          screenLG,
          screenLGMin: screenLG,
          screenLGMax: screenXL - 1,
          screenXL,
          screenXLMin: screenXL,
          screenXLMax: screenXXL - 1,
          screenXXL,
          screenXXLMin: screenXXL,
          screenXXLMax: screenXXXL - 1,
          screenXXXL,
          screenXXXLMin: screenXXXL,
          // FIXME: component box-shadow, should be removed
          boxShadowPopoverArrow: "3px 3px 7px rgba(0, 0, 0, 0.1)",
          boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
          boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
          boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
          boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
          boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
          boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
          boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
          boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
          boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
        }), overrideTokens);
        return aliasToken;
      }
      const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
        const unitWidth = width / 2;
        const ax = 0;
        const ay = unitWidth;
        const bx = outerRadius * 1 / Math.sqrt(2);
        const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
        const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
        const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
        const dx = 2 * unitWidth - cx;
        const dy = cy;
        const ex = 2 * unitWidth - bx;
        const ey = by;
        const fx = 2 * unitWidth - ax;
        const fy = ay;
        const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
        const polygonOffset = outerRadius * (Math.sqrt(2) - 1);
        return {
          pointerEvents: "none",
          width,
          height: width,
          overflow: "hidden",
          "&::after": {
            content: '""',
            position: "absolute",
            width: shadowWidth,
            height: shadowWidth,
            bottom: 0,
            insetInline: 0,
            margin: "auto",
            borderRadius: {
              _skip_check_: true,
              value: `0 0 ${innerRadius}px 0`
            },
            transform: "translateY(50%) rotate(-135deg)",
            boxShadow,
            zIndex: 0,
            background: "transparent"
          },
          "&::before": {
            position: "absolute",
            bottom: 0,
            insetInlineStart: 0,
            width,
            height: width / 2,
            background: bgColor,
            clipPath: {
              _multi_value_: true,
              value: [`polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`, `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`]
            },
            content: '""'
          }
        };
      };
      function genPresetColor(token2, genCss) {
        return PresetColors.reduce((prev2, colorKey) => {
          const lightColor = token2[`${colorKey}-1`];
          const lightBorderColor = token2[`${colorKey}-3`];
          const darkColor = token2[`${colorKey}-6`];
          const textColor = token2[`${colorKey}-7`];
          return _extends(_extends({}, prev2), genCss(colorKey, {
            lightColor,
            lightBorderColor,
            darkColor,
            textColor
          }));
        }, {});
      }
      const resetComponent = (token2) => ({
        boxSizing: "border-box",
        margin: 0,
        padding: 0,
        color: token2.colorText,
        fontSize: token2.fontSize,
        // font-variant: @font-variant-base;
        lineHeight: token2.lineHeight,
        listStyle: "none",
        // font-feature-settings: @font-feature-settings-base;
        fontFamily: token2.fontFamily
      });
      const genLinkStyle = (token2) => ({
        a: {
          color: token2.colorLink,
          textDecoration: token2.linkDecoration,
          backgroundColor: "transparent",
          outline: "none",
          cursor: "pointer",
          transition: `color ${token2.motionDurationSlow}`,
          "-webkit-text-decoration-skip": "objects",
          "&:hover": {
            color: token2.colorLinkHover
          },
          "&:active": {
            color: token2.colorLinkActive
          },
          [`&:active,
  &:hover`]: {
            textDecoration: token2.linkHoverDecoration,
            outline: 0
          },
          // https://github.com/ant-design/ant-design/issues/22503
          "&:focus": {
            textDecoration: token2.linkFocusDecoration,
            outline: 0
          },
          "&[disabled]": {
            color: token2.colorTextDisabled,
            cursor: "not-allowed"
          }
        }
      });
      const genCommonStyle = (token2, componentPrefixCls) => {
        const {
          fontFamily,
          fontSize
        } = token2;
        const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
        return {
          [rootPrefixSelector]: {
            fontFamily,
            fontSize,
            boxSizing: "border-box",
            "&::before, &::after": {
              boxSizing: "border-box"
            },
            [rootPrefixSelector]: {
              boxSizing: "border-box",
              "&::before, &::after": {
                boxSizing: "border-box"
              }
            }
          }
        };
      };
      function genComponentStyleHook(component, styleFn, getDefaultToken) {
        return (_prefixCls) => {
          const prefixCls = vue.computed(() => _prefixCls === null || _prefixCls === void 0 ? void 0 : _prefixCls.value);
          const [theme, token2, hashId] = useToken();
          const {
            getPrefixCls,
            iconPrefixCls
          } = useConfigContextInject();
          const rootPrefixCls = vue.computed(() => getPrefixCls());
          const sharedInfo = vue.computed(() => {
            return {
              theme: theme.value,
              token: token2.value,
              hashId: hashId.value,
              path: ["Shared", rootPrefixCls.value]
            };
          });
          useStyleRegister(sharedInfo, () => [{
            // Link
            "&": genLinkStyle(token2.value)
          }]);
          const componentInfo = vue.computed(() => {
            return {
              theme: theme.value,
              token: token2.value,
              hashId: hashId.value,
              path: [component, prefixCls.value, iconPrefixCls.value]
            };
          });
          return [useStyleRegister(componentInfo, () => {
            const {
              token: proxyToken,
              flush
            } = statisticToken(token2.value);
            const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(proxyToken) : getDefaultToken;
            const mergedComponentToken = _extends(_extends({}, defaultComponentToken), token2.value[component]);
            const componentCls = `.${prefixCls.value}`;
            const mergedToken = merge(proxyToken, {
              componentCls,
              prefixCls: prefixCls.value,
              iconCls: `.${iconPrefixCls.value}`,
              antCls: `.${rootPrefixCls.value}`
            }, mergedComponentToken);
            const styleInterpolation = styleFn(mergedToken, {
              hashId: hashId.value,
              prefixCls: prefixCls.value,
              rootPrefixCls: rootPrefixCls.value,
              iconPrefixCls: iconPrefixCls.value,
              overrideComponentToken: token2.value[component]
            });
            flush(component, mergedComponentToken);
            return [genCommonStyle(token2.value, prefixCls.value), styleInterpolation];
          }), hashId];
        };
      }
      const enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
      let recording = true;
      function merge() {
        for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
          objs[_key] = arguments[_key];
        }
        if (!enableStatistic) {
          return _extends({}, ...objs);
        }
        recording = false;
        const ret = {};
        objs.forEach((obj) => {
          const keys2 = Object.keys(obj);
          keys2.forEach((key) => {
            Object.defineProperty(ret, key, {
              configurable: true,
              enumerable: true,
              get: () => obj[key]
            });
          });
        });
        recording = true;
        return ret;
      }
      function noop$2() {
      }
      function statisticToken(token2) {
        let tokenKeys2;
        let proxy = token2;
        let flush = noop$2;
        if (enableStatistic) {
          tokenKeys2 = /* @__PURE__ */ new Set();
          proxy = new Proxy(token2, {
            get(obj, prop) {
              if (recording) {
                tokenKeys2.add(prop);
              }
              return obj[prop];
            }
          });
          flush = (componentName, componentToken) => {
            ({
              global: Array.from(tokenKeys2),
              component: componentToken
            });
          };
        }
        return {
          token: proxy,
          keys: tokenKeys2,
          flush
        };
      }
      const defaultTheme = createTheme(derivative);
      const defaultConfig = {
        token: defaultSeedToken,
        hashed: true
      };
      const DesignTokenContextKey = Symbol("DesignTokenContext");
      const globalDesignTokenApi = vue.shallowRef();
      const useDesignTokenProvider = (value) => {
        vue.provide(DesignTokenContextKey, value);
        vue.watch(value, () => {
          globalDesignTokenApi.value = vue.unref(value);
          vue.triggerRef(globalDesignTokenApi);
        }, {
          immediate: true,
          deep: true
        });
      };
      vue.defineComponent({
        props: {
          value: objectType()
        },
        setup(props, _ref) {
          let {
            slots
          } = _ref;
          useDesignTokenProvider(vue.computed(() => props.value));
          return () => {
            var _a2;
            return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
          };
        }
      });
      function useToken() {
        const designTokenContext = vue.inject(DesignTokenContextKey, vue.computed(() => globalDesignTokenApi.value || defaultConfig));
        const salt = vue.computed(() => `${version}-${designTokenContext.value.hashed || ""}`);
        const mergedTheme = vue.computed(() => designTokenContext.value.theme || defaultTheme);
        const cacheToken = useCacheToken(mergedTheme, vue.computed(() => [defaultSeedToken, designTokenContext.value.token]), vue.computed(() => ({
          salt: salt.value,
          override: _extends({
            override: designTokenContext.value.token
          }, designTokenContext.value.components),
          formatToken
        })));
        return [mergedTheme, vue.computed(() => cacheToken.value[0]), vue.computed(() => designTokenContext.value.hashed ? cacheToken.value[1] : "")];
      }
      const Empty$2 = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        setup() {
          const [, token2] = useToken();
          const themeStyle = vue.computed(() => {
            const bgColor = new TinyColor(token2.value.colorBgBase);
            if (bgColor.toHsl().l < 0.5) {
              return {
                opacity: 0.65
              };
            }
            return {};
          });
          return () => vue.createVNode("svg", {
            "style": themeStyle.value,
            "width": "184",
            "height": "152",
            "viewBox": "0 0 184 152",
            "xmlns": "http://www.w3.org/2000/svg"
          }, [vue.createVNode("g", {
            "fill": "none",
            "fill-rule": "evenodd"
          }, [vue.createVNode("g", {
            "transform": "translate(24 31.67)"
          }, [vue.createVNode("ellipse", {
            "fill-opacity": ".8",
            "fill": "#F5F5F7",
            "cx": "67.797",
            "cy": "106.89",
            "rx": "67.797",
            "ry": "12.668"
          }, null), vue.createVNode("path", {
            "d": "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
            "fill": "#AEB8C2"
          }, null), vue.createVNode("path", {
            "d": "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
            "fill": "url(#linearGradient-1)",
            "transform": "translate(13.56)"
          }, null), vue.createVNode("path", {
            "d": "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
            "fill": "#F5F5F7"
          }, null), vue.createVNode("path", {
            "d": "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
            "fill": "#DCE0E6"
          }, null)]), vue.createVNode("path", {
            "d": "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
            "fill": "#DCE0E6"
          }, null), vue.createVNode("g", {
            "transform": "translate(149.65 15.383)",
            "fill": "#FFF"
          }, [vue.createVNode("ellipse", {
            "cx": "20.654",
            "cy": "3.167",
            "rx": "2.849",
            "ry": "2.815"
          }, null), vue.createVNode("path", {
            "d": "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
          }, null)])])]);
        }
      });
      Empty$2.PRESENTED_IMAGE_DEFAULT = true;
      const DefaultEmptyImg = Empty$2;
      const Simple = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        setup() {
          const [, token2] = useToken();
          const color = vue.computed(() => {
            const {
              colorFill,
              colorFillTertiary,
              colorFillQuaternary,
              colorBgContainer
            } = token2.value;
            return {
              borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexString(),
              shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
              contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
            };
          });
          return () => vue.createVNode("svg", {
            "width": "64",
            "height": "41",
            "viewBox": "0 0 64 41",
            "xmlns": "http://www.w3.org/2000/svg"
          }, [vue.createVNode("g", {
            "transform": "translate(0 1)",
            "fill": "none",
            "fill-rule": "evenodd"
          }, [vue.createVNode("ellipse", {
            "fill": color.value.shadowColor,
            "cx": "32",
            "cy": "33",
            "rx": "32",
            "ry": "7"
          }, null), vue.createVNode("g", {
            "fill-rule": "nonzero",
            "stroke": color.value.borderColor
          }, [vue.createVNode("path", {
            "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
          }, null), vue.createVNode("path", {
            "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
            "fill": color.value.contentColor
          }, null)])])]);
        }
      });
      Simple.PRESENTED_IMAGE_SIMPLE = true;
      const SimpleEmptyImg = Simple;
      const genSharedEmptyStyle = (token2) => {
        const {
          componentCls,
          margin,
          marginXS,
          marginXL,
          fontSize,
          lineHeight
        } = token2;
        return {
          [componentCls]: {
            marginInline: marginXS,
            fontSize,
            lineHeight,
            textAlign: "center",
            // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
            [`${componentCls}-image`]: {
              height: token2.emptyImgHeight,
              marginBottom: marginXS,
              opacity: token2.opacityImage,
              img: {
                height: "100%"
              },
              svg: {
                height: "100%",
                margin: "auto"
              }
            },
            // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
            [`${componentCls}-footer`]: {
              marginTop: margin
            },
            "&-normal": {
              marginBlock: marginXL,
              color: token2.colorTextDisabled,
              [`${componentCls}-image`]: {
                height: token2.emptyImgHeightMD
              }
            },
            "&-small": {
              marginBlock: marginXS,
              color: token2.colorTextDisabled,
              [`${componentCls}-image`]: {
                height: token2.emptyImgHeightSM
              }
            }
          }
        };
      };
      const useStyle$3 = genComponentStyleHook("Empty", (token2) => {
        const {
          componentCls,
          controlHeightLG
        } = token2;
        const emptyToken = merge(token2, {
          emptyImgCls: `${componentCls}-img`,
          emptyImgHeight: controlHeightLG * 2.5,
          emptyImgHeightMD: controlHeightLG,
          emptyImgHeightSM: controlHeightLG * 0.875
        });
        return [genSharedEmptyStyle(emptyToken)];
      });
      var __rest$4 = function(s2, e2) {
        var t2 = {};
        for (var p in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
            t2[p] = s2[p];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
              t2[p[i2]] = s2[p[i2]];
          }
        return t2;
      };
      const defaultEmptyImg = vue.createVNode(DefaultEmptyImg, null, null);
      const simpleEmptyImg = vue.createVNode(SimpleEmptyImg, null, null);
      const emptyProps = () => ({
        prefixCls: String,
        imageStyle: objectType(),
        image: anyType(),
        description: anyType()
      });
      const Empty = vue.defineComponent({
        name: "AEmpty",
        compatConfig: {
          MODE: 3
        },
        inheritAttrs: false,
        props: emptyProps(),
        setup(props, _ref) {
          let {
            slots = {},
            attrs
          } = _ref;
          const {
            direction,
            prefixCls: prefixClsRef
          } = useConfigInject("empty", props);
          const [wrapSSR, hashId] = useStyle$3(prefixClsRef);
          return () => {
            var _a2, _b;
            const prefixCls = prefixClsRef.value;
            const _c = _extends(_extends({}, props), attrs), {
              image = ((_a2 = slots.image) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || defaultEmptyImg,
              description = ((_b = slots.description) === null || _b === void 0 ? void 0 : _b.call(slots)) || void 0,
              imageStyle,
              class: className = ""
            } = _c, restProps = __rest$4(_c, ["image", "description", "imageStyle", "class"]);
            return wrapSSR(vue.createVNode(LocaleReceiver, {
              "componentName": "Empty",
              "children": (locale2) => {
                const des = typeof description !== "undefined" ? description : locale2.description;
                const alt = typeof des === "string" ? des : "empty";
                let imageNode = null;
                if (typeof image === "string") {
                  imageNode = vue.createVNode("img", {
                    "alt": alt,
                    "src": image
                  }, null);
                } else {
                  imageNode = image;
                }
                return vue.createVNode("div", _objectSpread2$1({
                  "class": classNames(prefixCls, className, hashId.value, {
                    [`${prefixCls}-normal`]: image === simpleEmptyImg,
                    [`${prefixCls}-rtl`]: direction.value === "rtl"
                  })
                }, restProps), [vue.createVNode("div", {
                  "class": `${prefixCls}-image`,
                  "style": imageStyle
                }, [imageNode]), des && vue.createVNode("p", {
                  "class": `${prefixCls}-description`
                }, [des]), slots.default && vue.createVNode("div", {
                  "class": `${prefixCls}-footer`
                }, [filterEmpty(slots.default())])]);
              }
            }, null));
          };
        }
      });
      Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
      Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
      const Empty$1 = withInstall(Empty);
      const DefaultRenderEmpty = (props) => {
        const {
          prefixCls
        } = useConfigInject("empty", props);
        const renderHtml = (componentName) => {
          switch (componentName) {
            case "Table":
            case "List":
              return vue.createVNode(Empty$1, {
                "image": Empty$1.PRESENTED_IMAGE_SIMPLE
              }, null);
            case "Select":
            case "TreeSelect":
            case "Cascader":
            case "Transfer":
            case "Mentions":
              return vue.createVNode(Empty$1, {
                "image": Empty$1.PRESENTED_IMAGE_SIMPLE,
                "class": `${prefixCls.value}-small`
              }, null);
            default:
              return vue.createVNode(Empty$1, null, null);
          }
        };
        return renderHtml(props.componentName);
      };
      const SizeContextKey = Symbol("SizeContextKey");
      const useInjectSize = () => {
        return vue.inject(SizeContextKey, vue.ref(void 0));
      };
      const useConfigInject = (name, props) => {
        const sizeContext = useInjectSize();
        const disabledContext = useInjectDisabled();
        const configProvider = vue.inject(configProviderKey, _extends(_extends({}, defaultConfigProvider), {
          renderEmpty: (name2) => vue.h(DefaultRenderEmpty, {
            componentName: name2
          })
        }));
        const prefixCls = vue.computed(() => configProvider.getPrefixCls(name, props.prefixCls));
        const direction = vue.computed(() => {
          var _a2, _b;
          return (_a2 = props.direction) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.direction) === null || _b === void 0 ? void 0 : _b.value;
        });
        const iconPrefixCls = vue.computed(() => {
          var _a2;
          return (_a2 = props.iconPrefixCls) !== null && _a2 !== void 0 ? _a2 : configProvider.iconPrefixCls.value;
        });
        const rootPrefixCls = vue.computed(() => configProvider.getPrefixCls());
        const autoInsertSpaceInButton = vue.computed(() => {
          var _a2;
          return (_a2 = configProvider.autoInsertSpaceInButton) === null || _a2 === void 0 ? void 0 : _a2.value;
        });
        const renderEmpty = configProvider.renderEmpty;
        const space = configProvider.space;
        const pageHeader = configProvider.pageHeader;
        const form = configProvider.form;
        const getTargetContainer = vue.computed(() => {
          var _a2, _b;
          return (_a2 = props.getTargetContainer) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.getTargetContainer) === null || _b === void 0 ? void 0 : _b.value;
        });
        const getPopupContainer = vue.computed(() => {
          var _a2, _b, _c;
          return (_b = (_a2 = props.getContainer) !== null && _a2 !== void 0 ? _a2 : props.getPopupContainer) !== null && _b !== void 0 ? _b : (_c = configProvider.getPopupContainer) === null || _c === void 0 ? void 0 : _c.value;
        });
        const dropdownMatchSelectWidth = vue.computed(() => {
          var _a2, _b;
          return (_a2 = props.dropdownMatchSelectWidth) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.dropdownMatchSelectWidth) === null || _b === void 0 ? void 0 : _b.value;
        });
        const virtual = vue.computed(() => {
          var _a2;
          return (props.virtual === void 0 ? ((_a2 = configProvider.virtual) === null || _a2 === void 0 ? void 0 : _a2.value) !== false : props.virtual !== false) && dropdownMatchSelectWidth.value !== false;
        });
        const size = vue.computed(() => props.size || sizeContext.value);
        const autocomplete = vue.computed(() => {
          var _a2, _b, _c;
          return (_a2 = props.autocomplete) !== null && _a2 !== void 0 ? _a2 : (_c = (_b = configProvider.input) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.autocomplete;
        });
        const disabled = vue.computed(() => {
          var _a2;
          return (_a2 = props.disabled) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
        });
        const csp = vue.computed(() => {
          var _a2;
          return (_a2 = props.csp) !== null && _a2 !== void 0 ? _a2 : configProvider.csp;
        });
        const wave = vue.computed(() => {
          var _a2, _b;
          return (_a2 = props.wave) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.wave) === null || _b === void 0 ? void 0 : _b.value;
        });
        return {
          configProvider,
          prefixCls,
          direction,
          size,
          getTargetContainer,
          getPopupContainer,
          space,
          pageHeader,
          form,
          autoInsertSpaceInButton,
          renderEmpty,
          virtual,
          dropdownMatchSelectWidth,
          rootPrefixCls,
          getPrefixCls: configProvider.getPrefixCls,
          autocomplete,
          csp,
          iconPrefixCls,
          disabled,
          select: configProvider.select,
          wave
        };
      };
      function easeInOutCubic(t2, b2, c2, d2) {
        const cc = c2 - b2;
        t2 /= d2 / 2;
        if (t2 < 1) {
          return cc / 2 * t2 * t2 * t2 + b2;
        }
        return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
      }
      function isWindow$1(obj) {
        return obj !== null && obj !== void 0 && obj === obj.window;
      }
      function getScroll$1(target, top) {
        var _a2, _b;
        if (typeof window === "undefined") {
          return 0;
        }
        const method = top ? "scrollTop" : "scrollLeft";
        let result = 0;
        if (isWindow$1(target)) {
          result = target[top ? "pageYOffset" : "pageXOffset"];
        } else if (target instanceof Document) {
          result = target.documentElement[method];
        } else if (target instanceof HTMLElement) {
          result = target[method];
        } else if (target) {
          result = target[method];
        }
        if (target && !isWindow$1(target) && typeof result !== "number") {
          result = (_b = ((_a2 = target.ownerDocument) !== null && _a2 !== void 0 ? _a2 : target).documentElement) === null || _b === void 0 ? void 0 : _b[method];
        }
        return result;
      }
      function scrollTo(y2) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          getContainer: getContainer2 = () => window,
          callback,
          duration = 450
        } = options;
        const container = getContainer2();
        const scrollTop = getScroll$1(container, true);
        const startTime = Date.now();
        const frameFunc = () => {
          const timestamp = Date.now();
          const time = timestamp - startTime;
          const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y2, duration);
          if (isWindow$1(container)) {
            container.scrollTo(window.pageXOffset, nextScrollTop);
          } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
            container.documentElement.scrollTop = nextScrollTop;
          } else {
            container.scrollTop = nextScrollTop;
          }
          if (time < duration) {
            wrapperRaf(frameFunc);
          } else if (typeof callback === "function") {
            callback();
          }
        };
        wrapperRaf(frameFunc);
      }
      function e(e2, t2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var r2 = t2[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);
        }
      }
      function t(t2, n2, r2) {
        return n2 && e(t2.prototype, n2), r2 && e(t2, r2), t2;
      }
      function n() {
        return (n = Object.assign || function(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var n2 = arguments[t2];
            for (var r2 in n2)
              Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
          }
          return e2;
        }).apply(this, arguments);
      }
      function r(e2, t2) {
        e2.prototype = Object.create(t2.prototype), e2.prototype.constructor = e2, e2.__proto__ = t2;
      }
      function i(e2, t2) {
        if (null == e2)
          return {};
        var n2, r2, i2 = {}, o2 = Object.keys(e2);
        for (r2 = 0; r2 < o2.length; r2++)
          t2.indexOf(n2 = o2[r2]) >= 0 || (i2[n2] = e2[n2]);
        return i2;
      }
      function o(e2) {
        return 1 == (null != (t2 = e2) && "object" == typeof t2 && false === Array.isArray(t2)) && "[object Object]" === Object.prototype.toString.call(e2);
        var t2;
      }
      var u = Object.prototype, a = u.toString, f = u.hasOwnProperty, c = /^\s*function (\w+)/;
      function l(e2) {
        var t2, n2 = null !== (t2 = null == e2 ? void 0 : e2.type) && void 0 !== t2 ? t2 : e2;
        if (n2) {
          var r2 = n2.toString().match(c);
          return r2 ? r2[1] : "";
        }
        return "";
      }
      var s = function(e2) {
        var t2, n2;
        return false !== o(e2) && "function" == typeof (t2 = e2.constructor) && false !== o(n2 = t2.prototype) && false !== n2.hasOwnProperty("isPrototypeOf");
      }, v = function(e2) {
        return e2;
      }, y = v;
      var d = function(e2, t2) {
        return f.call(e2, t2);
      }, h = Number.isInteger || function(e2) {
        return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
      }, b = Array.isArray || function(e2) {
        return "[object Array]" === a.call(e2);
      }, O = function(e2) {
        return "[object Function]" === a.call(e2);
      }, g = function(e2) {
        return s(e2) && d(e2, "_vueTypes_name");
      }, m = function(e2) {
        return s(e2) && (d(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function(t2) {
          return d(e2, t2);
        }));
      };
      function j(e2, t2) {
        return Object.defineProperty(e2.bind(t2), "__original", { value: e2 });
      }
      function _(e2, t2, n2) {
        var r2;
        void 0 === n2 && (n2 = false);
        var i2 = true, o2 = "";
        r2 = s(e2) ? e2 : { type: e2 };
        var u2 = g(r2) ? r2._vueTypes_name + " - " : "";
        if (m(r2) && null !== r2.type) {
          if (void 0 === r2.type || true === r2.type)
            return i2;
          if (!r2.required && void 0 === t2)
            return i2;
          b(r2.type) ? (i2 = r2.type.some(function(e3) {
            return true === _(e3, t2, true);
          }), o2 = r2.type.map(function(e3) {
            return l(e3);
          }).join(" or ")) : i2 = "Array" === (o2 = l(r2)) ? b(t2) : "Object" === o2 ? s(t2) : "String" === o2 || "Number" === o2 || "Boolean" === o2 || "Function" === o2 ? function(e3) {
            if (null == e3)
              return "";
            var t3 = e3.constructor.toString().match(c);
            return t3 ? t3[1] : "";
          }(t2) === o2 : t2 instanceof r2.type;
        }
        if (!i2) {
          var a2 = u2 + 'value "' + t2 + '" should be of type "' + o2 + '"';
          return false === n2 ? (y(a2), false) : a2;
        }
        if (d(r2, "validator") && O(r2.validator)) {
          var f2 = y, v2 = [];
          if (y = function(e3) {
            v2.push(e3);
          }, i2 = r2.validator(t2), y = f2, !i2) {
            var p = (v2.length > 1 ? "* " : "") + v2.join("\n* ");
            return v2.length = 0, false === n2 ? (y(p), i2) : p;
          }
        }
        return i2;
      }
      function T(e2, t2) {
        var n2 = Object.defineProperties(t2, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get: function() {
          return this.required = true, this;
        } }, def: { value: function(e3) {
          return void 0 !== e3 || this.default ? O(e3) || true === _(this, e3, true) ? (this.default = b(e3) ? function() {
            return [].concat(e3);
          } : s(e3) ? function() {
            return Object.assign({}, e3);
          } : e3, this) : (y(this._vueTypes_name + ' - invalid default value: "' + e3 + '"'), this) : this;
        } } }), r2 = n2.validator;
        return O(r2) && (n2.validator = j(r2, n2)), n2;
      }
      function w(e2, t2) {
        var n2 = T(e2, t2);
        return Object.defineProperty(n2, "validate", { value: function(e3) {
          return O(this.validator) && y(this._vueTypes_name + " - calling .validate() will overwrite the current custom validator function. Validator info:\n" + JSON.stringify(this)), this.validator = j(e3, this), this;
        } });
      }
      function k(e2, t2, n2) {
        var r2, o2, u2 = (r2 = t2, o2 = {}, Object.getOwnPropertyNames(r2).forEach(function(e3) {
          o2[e3] = Object.getOwnPropertyDescriptor(r2, e3);
        }), Object.defineProperties({}, o2));
        if (u2._vueTypes_name = e2, !s(n2))
          return u2;
        var a2, f2, c2 = n2.validator, l2 = i(n2, ["validator"]);
        if (O(c2)) {
          var v2 = u2.validator;
          v2 && (v2 = null !== (f2 = (a2 = v2).__original) && void 0 !== f2 ? f2 : a2), u2.validator = j(v2 ? function(e3) {
            return v2.call(this, e3) && c2.call(this, e3);
          } : c2, u2);
        }
        return Object.assign(u2, l2);
      }
      function P(e2) {
        return e2.replace(/^(?!\s*$)/gm, "  ");
      }
      var x = function() {
        return w("any", {});
      }, A = function() {
        return w("function", { type: Function });
      }, E = function() {
        return w("boolean", { type: Boolean });
      }, N = function() {
        return w("string", { type: String });
      }, q = function() {
        return w("number", { type: Number });
      }, S = function() {
        return w("array", { type: Array });
      }, V = function() {
        return w("object", { type: Object });
      }, F = function() {
        return T("integer", { type: Number, validator: function(e2) {
          return h(e2);
        } });
      }, D = function() {
        return T("symbol", { validator: function(e2) {
          return "symbol" == typeof e2;
        } });
      };
      function L(e2, t2) {
        if (void 0 === t2 && (t2 = "custom validation failed"), "function" != typeof e2)
          throw new TypeError("[VueTypes error]: You must provide a function as argument");
        return T(e2.name || "<<anonymous function>>", { validator: function(n2) {
          var r2 = e2(n2);
          return r2 || y(this._vueTypes_name + " - " + t2), r2;
        } });
      }
      function Y(e2) {
        if (!b(e2))
          throw new TypeError("[VueTypes error]: You must provide an array as argument.");
        var t2 = 'oneOf - value should be one of "' + e2.join('", "') + '".', n2 = e2.reduce(function(e3, t3) {
          if (null != t3) {
            var n3 = t3.constructor;
            -1 === e3.indexOf(n3) && e3.push(n3);
          }
          return e3;
        }, []);
        return T("oneOf", { type: n2.length > 0 ? n2 : void 0, validator: function(n3) {
          var r2 = -1 !== e2.indexOf(n3);
          return r2 || y(t2), r2;
        } });
      }
      function B(e2) {
        if (!b(e2))
          throw new TypeError("[VueTypes error]: You must provide an array as argument");
        for (var t2 = false, n2 = [], r2 = 0; r2 < e2.length; r2 += 1) {
          var i2 = e2[r2];
          if (m(i2)) {
            if (g(i2) && "oneOf" === i2._vueTypes_name) {
              n2 = n2.concat(i2.type);
              continue;
            }
            if (O(i2.validator) && (t2 = true), true !== i2.type && i2.type) {
              n2 = n2.concat(i2.type);
              continue;
            }
          }
          n2.push(i2);
        }
        return n2 = n2.filter(function(e3, t3) {
          return n2.indexOf(e3) === t3;
        }), T("oneOfType", t2 ? { type: n2, validator: function(t3) {
          var n3 = [], r3 = e2.some(function(e3) {
            var r4 = _(g(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t3, true);
            return "string" == typeof r4 && n3.push(r4), true === r4;
          });
          return r3 || y("oneOfType - provided value does not match any of the " + n3.length + " passed-in validators:\n" + P(n3.join("\n"))), r3;
        } } : { type: n2 });
      }
      function I(e2) {
        return T("arrayOf", { type: Array, validator: function(t2) {
          var n2, r2 = t2.every(function(t3) {
            return true === (n2 = _(e2, t3, true));
          });
          return r2 || y("arrayOf - value validation error:\n" + P(n2)), r2;
        } });
      }
      function J(e2) {
        return T("instanceOf", { type: e2 });
      }
      function M(e2) {
        return T("objectOf", { type: Object, validator: function(t2) {
          var n2, r2 = Object.keys(t2).every(function(r3) {
            return true === (n2 = _(e2, t2[r3], true));
          });
          return r2 || y("objectOf - value validation error:\n" + P(n2)), r2;
        } });
      }
      function R(e2) {
        var t2 = Object.keys(e2), n2 = t2.filter(function(t3) {
          var n3;
          return !!(null === (n3 = e2[t3]) || void 0 === n3 ? void 0 : n3.required);
        }), r2 = T("shape", { type: Object, validator: function(r3) {
          var i2 = this;
          if (!s(r3))
            return false;
          var o2 = Object.keys(r3);
          if (n2.length > 0 && n2.some(function(e3) {
            return -1 === o2.indexOf(e3);
          })) {
            var u2 = n2.filter(function(e3) {
              return -1 === o2.indexOf(e3);
            });
            return y(1 === u2.length ? 'shape - required property "' + u2[0] + '" is not defined.' : 'shape - required properties "' + u2.join('", "') + '" are not defined.'), false;
          }
          return o2.every(function(n3) {
            if (-1 === t2.indexOf(n3))
              return true === i2._vueTypes_isLoose || (y('shape - shape definition does not include a "' + n3 + '" property. Allowed keys: "' + t2.join('", "') + '".'), false);
            var o3 = _(e2[n3], r3[n3], true);
            return "string" == typeof o3 && y('shape - "' + n3 + '" property validation error:\n ' + P(o3)), true === o3;
          });
        } });
        return Object.defineProperty(r2, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(r2, "loose", { get: function() {
          return this._vueTypes_isLoose = true, this;
        } }), r2;
      }
      var $ = function() {
        function e2() {
        }
        return e2.extend = function(e3) {
          var t2 = this;
          if (b(e3))
            return e3.forEach(function(e4) {
              return t2.extend(e4);
            }), this;
          var n2 = e3.name, r2 = e3.validate, o2 = void 0 !== r2 && r2, u2 = e3.getter, a2 = void 0 !== u2 && u2, f2 = i(e3, ["name", "validate", "getter"]);
          if (d(this, n2))
            throw new TypeError('[VueTypes error]: Type "' + n2 + '" already defined');
          var c2, l2 = f2.type;
          return g(l2) ? (delete f2.type, Object.defineProperty(this, n2, a2 ? { get: function() {
            return k(n2, l2, f2);
          } } : { value: function() {
            var e4, t3 = k(n2, l2, f2);
            return t3.validator && (t3.validator = (e4 = t3.validator).bind.apply(e4, [t3].concat([].slice.call(arguments)))), t3;
          } })) : (c2 = a2 ? { get: function() {
            var e4 = Object.assign({}, f2);
            return o2 ? w(n2, e4) : T(n2, e4);
          }, enumerable: true } : { value: function() {
            var e4, t3, r3 = Object.assign({}, f2);
            return e4 = o2 ? w(n2, r3) : T(n2, r3), r3.validator && (e4.validator = (t3 = r3.validator).bind.apply(t3, [e4].concat([].slice.call(arguments)))), e4;
          }, enumerable: true }, Object.defineProperty(this, n2, c2));
        }, t(e2, null, [{ key: "any", get: function() {
          return x();
        } }, { key: "func", get: function() {
          return A().def(this.defaults.func);
        } }, { key: "bool", get: function() {
          return E().def(this.defaults.bool);
        } }, { key: "string", get: function() {
          return N().def(this.defaults.string);
        } }, { key: "number", get: function() {
          return q().def(this.defaults.number);
        } }, { key: "array", get: function() {
          return S().def(this.defaults.array);
        } }, { key: "object", get: function() {
          return V().def(this.defaults.object);
        } }, { key: "integer", get: function() {
          return F().def(this.defaults.integer);
        } }, { key: "symbol", get: function() {
          return D();
        } }]), e2;
      }();
      function z(e2) {
        var i2;
        return void 0 === e2 && (e2 = { func: function() {
        }, bool: true, string: "", number: 0, array: function() {
          return [];
        }, object: function() {
          return {};
        }, integer: 0 }), (i2 = function(i3) {
          function o2() {
            return i3.apply(this, arguments) || this;
          }
          return r(o2, i3), t(o2, null, [{ key: "sensibleDefaults", get: function() {
            return n({}, this.defaults);
          }, set: function(t2) {
            this.defaults = false !== t2 ? n({}, true !== t2 ? t2 : e2) : {};
          } }]), o2;
        }($)).defaults = n({}, e2), i2;
      }
      $.defaults = {}, $.custom = L, $.oneOf = Y, $.instanceOf = J, $.oneOfType = B, $.arrayOf = I, $.objectOf = M, $.shape = R, $.utils = { validate: function(e2, t2) {
        return true === _(t2, e2, true);
      }, toType: function(e2, t2, n2) {
        return void 0 === n2 && (n2 = false), n2 ? w(e2, t2) : T(e2, t2);
      } };
      (function(e2) {
        function t2() {
          return e2.apply(this, arguments) || this;
        }
        return r(t2, e2), t2;
      })(z());
      const PropTypes = z({
        func: void 0,
        bool: void 0,
        string: void 0,
        number: void 0,
        array: void 0,
        object: void 0,
        integer: void 0
      });
      PropTypes.extend([{
        name: "looseBool",
        getter: true,
        type: Boolean,
        default: void 0
      }, {
        name: "style",
        getter: true,
        type: [String, Object],
        default: void 0
      }, {
        name: "VueNode",
        getter: true,
        type: null
      }]);
      function returnEmptyString() {
        return "";
      }
      function returnDocument(element) {
        if (element) {
          return element.ownerDocument;
        }
        return window.document;
      }
      function noop$1() {
      }
      const triggerProps = () => ({
        action: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).def([]),
        showAction: PropTypes.any.def([]),
        hideAction: PropTypes.any.def([]),
        getPopupClassNameFromAlign: PropTypes.any.def(returnEmptyString),
        onPopupVisibleChange: Function,
        afterPopupVisibleChange: PropTypes.func.def(noop$1),
        popup: PropTypes.any,
        popupStyle: {
          type: Object,
          default: void 0
        },
        prefixCls: PropTypes.string.def("rc-trigger-popup"),
        popupClassName: PropTypes.string.def(""),
        popupPlacement: String,
        builtinPlacements: PropTypes.object,
        popupTransitionName: String,
        popupAnimation: PropTypes.any,
        mouseEnterDelay: PropTypes.number.def(0),
        mouseLeaveDelay: PropTypes.number.def(0.1),
        zIndex: Number,
        focusDelay: PropTypes.number.def(0),
        blurDelay: PropTypes.number.def(0.15),
        getPopupContainer: Function,
        getDocument: PropTypes.func.def(returnDocument),
        forceRender: {
          type: Boolean,
          default: void 0
        },
        destroyPopupOnHide: {
          type: Boolean,
          default: false
        },
        mask: {
          type: Boolean,
          default: false
        },
        maskClosable: {
          type: Boolean,
          default: true
        },
        // onPopupAlign: PropTypes.func.def(noop),
        popupAlign: PropTypes.object.def(() => ({})),
        popupVisible: {
          type: Boolean,
          default: void 0
        },
        defaultPopupVisible: {
          type: Boolean,
          default: false
        },
        maskTransitionName: String,
        maskAnimation: String,
        stretch: String,
        alignPoint: {
          type: Boolean,
          default: void 0
        },
        autoDestroy: {
          type: Boolean,
          default: false
        },
        mobile: Object,
        getTriggerDOMNode: Function
      });
      const innerProps = {
        visible: Boolean,
        prefixCls: String,
        zIndex: Number,
        destroyPopupOnHide: Boolean,
        forceRender: Boolean,
        // Legacy Motion
        animation: [String, Object],
        transitionName: String,
        // Measure
        stretch: {
          type: String
        },
        // Align
        align: {
          type: Object
        },
        point: {
          type: Object
        },
        getRootDomNode: {
          type: Function
        },
        getClassNameFromAlign: {
          type: Function
        },
        onAlign: {
          type: Function
        },
        onMouseenter: {
          type: Function
        },
        onMouseleave: {
          type: Function
        },
        onMousedown: {
          type: Function
        },
        onTouchstart: {
          type: Function
        }
      };
      const mobileProps = _extends(_extends({}, innerProps), {
        mobile: {
          type: Object
        }
      });
      const popupProps = _extends(_extends({}, innerProps), {
        mask: Boolean,
        mobile: {
          type: Object
        },
        maskAnimation: String,
        maskTransitionName: String
      });
      function getMotion(_ref) {
        let {
          prefixCls,
          animation,
          transitionName
        } = _ref;
        if (animation) {
          return {
            name: `${prefixCls}-${animation}`
          };
        }
        if (transitionName) {
          return {
            name: transitionName
          };
        }
        return {};
      }
      function Mask(props) {
        const {
          prefixCls,
          visible,
          zIndex: zIndex2,
          mask,
          maskAnimation,
          maskTransitionName
        } = props;
        if (!mask) {
          return null;
        }
        let motion = {};
        if (maskTransitionName || maskAnimation) {
          motion = getMotion({
            prefixCls,
            transitionName: maskTransitionName,
            animation: maskAnimation
          });
        }
        return vue.createVNode(vue.Transition, _objectSpread2$1({
          "appear": true
        }, motion), {
          default: () => [vue.withDirectives(vue.createVNode("div", {
            "style": {
              zIndex: zIndex2
            },
            "class": `${prefixCls}-mask`
          }, null), [[vue.resolveDirective("if"), visible]])]
        });
      }
      Mask.displayName = "Mask";
      const MobilePopupInner = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "MobilePopupInner",
        inheritAttrs: false,
        props: mobileProps,
        emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
        setup(props, _ref) {
          let {
            expose,
            slots
          } = _ref;
          const elementRef = vue.ref();
          expose({
            forceAlign: () => {
            },
            getElement: () => elementRef.value
          });
          return () => {
            var _a2;
            const {
              zIndex: zIndex2,
              visible,
              prefixCls,
              mobile: {
                popupClassName,
                popupStyle,
                popupMotion = {},
                popupRender
              } = {}
            } = props;
            const mergedStyle = _extends({
              zIndex: zIndex2
            }, popupStyle);
            let childNode = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
            if (childNode.length > 1) {
              childNode = vue.createVNode("div", {
                "class": `${prefixCls}-content`
              }, [childNode]);
            }
            if (popupRender) {
              childNode = popupRender(childNode);
            }
            const mergedClassName = classNames(prefixCls, popupClassName);
            return vue.createVNode(vue.Transition, _objectSpread2$1({
              "ref": elementRef
            }, popupMotion), {
              default: () => [visible ? vue.createVNode("div", {
                "class": mergedClassName,
                "style": mergedStyle
              }, [childNode]) : null]
            });
          };
        }
      });
      var __awaiter = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      const StatusQueue = ["measure", "align", null, "motion"];
      const useVisibleStatus = (visible, doMeasure) => {
        const status = vue.shallowRef(null);
        const rafRef = vue.shallowRef();
        const destroyRef = vue.shallowRef(false);
        function setStatus(nextStatus) {
          if (!destroyRef.value) {
            status.value = nextStatus;
          }
        }
        function cancelRaf() {
          wrapperRaf.cancel(rafRef.value);
        }
        function goNextStatus(callback) {
          cancelRaf();
          rafRef.value = wrapperRaf(() => {
            let newStatus = status.value;
            switch (status.value) {
              case "align":
                newStatus = "motion";
                break;
              case "motion":
                newStatus = "stable";
                break;
            }
            setStatus(newStatus);
            callback === null || callback === void 0 ? void 0 : callback();
          });
        }
        vue.watch(visible, () => {
          setStatus("measure");
        }, {
          immediate: true,
          flush: "post"
        });
        vue.onMounted(() => {
          vue.watch(status, () => {
            switch (status.value) {
              case "measure":
                doMeasure();
                break;
            }
            if (status.value) {
              rafRef.value = wrapperRaf(() => __awaiter(void 0, void 0, void 0, function* () {
                const index2 = StatusQueue.indexOf(status.value);
                const nextStatus = StatusQueue[index2 + 1];
                if (nextStatus && index2 !== -1) {
                  setStatus(nextStatus);
                }
              }));
            }
          }, {
            immediate: true,
            flush: "post"
          });
        });
        vue.onBeforeUnmount(() => {
          destroyRef.value = true;
          cancelRaf();
        });
        return [status, goNextStatus];
      };
      const useStretchStyle = (stretch) => {
        const targetSize = vue.shallowRef({
          width: 0,
          height: 0
        });
        function measureStretch(element) {
          targetSize.value = {
            width: element.offsetWidth,
            height: element.offsetHeight
          };
        }
        const style = vue.computed(() => {
          const sizeStyle = {};
          if (stretch.value) {
            const {
              width,
              height
            } = targetSize.value;
            if (stretch.value.indexOf("height") !== -1 && height) {
              sizeStyle.height = `${height}px`;
            } else if (stretch.value.indexOf("minHeight") !== -1 && height) {
              sizeStyle.minHeight = `${height}px`;
            }
            if (stretch.value.indexOf("width") !== -1 && width) {
              sizeStyle.width = `${width}px`;
            } else if (stretch.value.indexOf("minWidth") !== -1 && width) {
              sizeStyle.minWidth = `${width}px`;
            }
          }
          return sizeStyle;
        });
        return [style, measureStretch];
      };
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          })), keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread2(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = null != arguments[i2] ? arguments[i2] : {};
          i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty$6(target, key, source[key]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
        return target;
      }
      function _typeof(obj) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof(obj);
      }
      function _defineProperty$6(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var vendorPrefix;
      var jsCssMap = {
        Webkit: "-webkit-",
        Moz: "-moz-",
        // IE did it wrong again ...
        ms: "-ms-",
        O: "-o-"
      };
      function getVendorPrefix() {
        if (vendorPrefix !== void 0) {
          return vendorPrefix;
        }
        vendorPrefix = "";
        var style = document.createElement("p").style;
        var testProp = "Transform";
        for (var key in jsCssMap) {
          if (key + testProp in style) {
            vendorPrefix = key;
          }
        }
        return vendorPrefix;
      }
      function getTransitionName$1() {
        return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
      }
      function getTransformName() {
        return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
      }
      function setTransitionProperty(node2, value) {
        var name = getTransitionName$1();
        if (name) {
          node2.style[name] = value;
          if (name !== "transitionProperty") {
            node2.style.transitionProperty = value;
          }
        }
      }
      function setTransform(node2, value) {
        var name = getTransformName();
        if (name) {
          node2.style[name] = value;
          if (name !== "transform") {
            node2.style.transform = value;
          }
        }
      }
      function getTransitionProperty(node2) {
        return node2.style.transitionProperty || node2.style[getTransitionName$1()];
      }
      function getTransformXY(node2) {
        var style = window.getComputedStyle(node2, null);
        var transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
        if (transform && transform !== "none") {
          var matrix = transform.replace(/[^0-9\-.,]/g, "").split(",");
          return {
            x: parseFloat(matrix[12] || matrix[4], 0),
            y: parseFloat(matrix[13] || matrix[5], 0)
          };
        }
        return {
          x: 0,
          y: 0
        };
      }
      var matrix2d = /matrix\((.*)\)/;
      var matrix3d = /matrix3d\((.*)\)/;
      function setTransformXY(node2, xy) {
        var style = window.getComputedStyle(node2, null);
        var transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
        if (transform && transform !== "none") {
          var arr;
          var match2d = transform.match(matrix2d);
          if (match2d) {
            match2d = match2d[1];
            arr = match2d.split(",").map(function(item) {
              return parseFloat(item, 10);
            });
            arr[4] = xy.x;
            arr[5] = xy.y;
            setTransform(node2, "matrix(".concat(arr.join(","), ")"));
          } else {
            var match3d = transform.match(matrix3d)[1];
            arr = match3d.split(",").map(function(item) {
              return parseFloat(item, 10);
            });
            arr[12] = xy.x;
            arr[13] = xy.y;
            setTransform(node2, "matrix3d(".concat(arr.join(","), ")"));
          }
        } else {
          setTransform(node2, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
        }
      }
      var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
      var getComputedStyleX;
      function forceRelayout(elem) {
        var originalStyle = elem.style.display;
        elem.style.display = "none";
        elem.offsetHeight;
        elem.style.display = originalStyle;
      }
      function css(el, name, v2) {
        var value = v2;
        if (_typeof(name) === "object") {
          for (var i2 in name) {
            if (name.hasOwnProperty(i2)) {
              css(el, i2, name[i2]);
            }
          }
          return void 0;
        }
        if (typeof value !== "undefined") {
          if (typeof value === "number") {
            value = "".concat(value, "px");
          }
          el.style[name] = value;
          return void 0;
        }
        return getComputedStyleX(el, name);
      }
      function getClientPosition(elem) {
        var box;
        var x2;
        var y2;
        var doc = elem.ownerDocument;
        var body = doc.body;
        var docElem = doc && doc.documentElement;
        box = elem.getBoundingClientRect();
        x2 = Math.floor(box.left);
        y2 = Math.floor(box.top);
        x2 -= docElem.clientLeft || body.clientLeft || 0;
        y2 -= docElem.clientTop || body.clientTop || 0;
        return {
          left: x2,
          top: y2
        };
      }
      function getScroll(w2, top) {
        var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
        var method = "scroll".concat(top ? "Top" : "Left");
        if (typeof ret !== "number") {
          var d2 = w2.document;
          ret = d2.documentElement[method];
          if (typeof ret !== "number") {
            ret = d2.body[method];
          }
        }
        return ret;
      }
      function getScrollLeft(w2) {
        return getScroll(w2);
      }
      function getScrollTop(w2) {
        return getScroll(w2, true);
      }
      function getOffset$2(el) {
        var pos = getClientPosition(el);
        var doc = el.ownerDocument;
        var w2 = doc.defaultView || doc.parentWindow;
        pos.left += getScrollLeft(w2);
        pos.top += getScrollTop(w2);
        return pos;
      }
      function isWindow(obj) {
        return obj !== null && obj !== void 0 && obj == obj.window;
      }
      function getDocument(node2) {
        if (isWindow(node2)) {
          return node2.document;
        }
        if (node2.nodeType === 9) {
          return node2;
        }
        return node2.ownerDocument;
      }
      function _getComputedStyle(elem, name, cs) {
        var computedStyle = cs;
        var val = "";
        var d2 = getDocument(elem);
        computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);
        if (computedStyle) {
          val = computedStyle.getPropertyValue(name) || computedStyle[name];
        }
        return val;
      }
      var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
      var RE_POS = /^(top|right|bottom|left)$/;
      var CURRENT_STYLE = "currentStyle";
      var RUNTIME_STYLE = "runtimeStyle";
      var LEFT = "left";
      var PX = "px";
      function _getComputedStyleIE(elem, name) {
        var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];
        if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
          var style = elem.style;
          var left = style[LEFT];
          var rsLeft = elem[RUNTIME_STYLE][LEFT];
          elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];
          style[LEFT] = name === "fontSize" ? "1em" : ret || 0;
          ret = style.pixelLeft + PX;
          style[LEFT] = left;
          elem[RUNTIME_STYLE][LEFT] = rsLeft;
        }
        return ret === "" ? "auto" : ret;
      }
      if (typeof window !== "undefined") {
        getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
      }
      function getOffsetDirection(dir, option) {
        if (dir === "left") {
          return option.useCssRight ? "right" : dir;
        }
        return option.useCssBottom ? "bottom" : dir;
      }
      function oppositeOffsetDirection(dir) {
        if (dir === "left") {
          return "right";
        } else if (dir === "right") {
          return "left";
        } else if (dir === "top") {
          return "bottom";
        } else if (dir === "bottom") {
          return "top";
        }
      }
      function setLeftTop(elem, offset, option) {
        if (css(elem, "position") === "static") {
          elem.style.position = "relative";
        }
        var presetH = -999;
        var presetV = -999;
        var horizontalProperty = getOffsetDirection("left", option);
        var verticalProperty = getOffsetDirection("top", option);
        var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
        var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
        if (horizontalProperty !== "left") {
          presetH = 999;
        }
        if (verticalProperty !== "top") {
          presetV = 999;
        }
        var originalTransition = "";
        var originalOffset = getOffset$2(elem);
        if ("left" in offset || "top" in offset) {
          originalTransition = getTransitionProperty(elem) || "";
          setTransitionProperty(elem, "none");
        }
        if ("left" in offset) {
          elem.style[oppositeHorizontalProperty] = "";
          elem.style[horizontalProperty] = "".concat(presetH, "px");
        }
        if ("top" in offset) {
          elem.style[oppositeVerticalProperty] = "";
          elem.style[verticalProperty] = "".concat(presetV, "px");
        }
        forceRelayout(elem);
        var old = getOffset$2(elem);
        var originalStyle = {};
        for (var key in offset) {
          if (offset.hasOwnProperty(key)) {
            var dir = getOffsetDirection(key, option);
            var preset = key === "left" ? presetH : presetV;
            var off = originalOffset[key] - old[key];
            if (dir === key) {
              originalStyle[dir] = preset + off;
            } else {
              originalStyle[dir] = preset - off;
            }
          }
        }
        css(elem, originalStyle);
        forceRelayout(elem);
        if ("left" in offset || "top" in offset) {
          setTransitionProperty(elem, originalTransition);
        }
        var ret = {};
        for (var _key in offset) {
          if (offset.hasOwnProperty(_key)) {
            var _dir = getOffsetDirection(_key, option);
            var _off = offset[_key] - originalOffset[_key];
            if (_key === _dir) {
              ret[_dir] = originalStyle[_dir] + _off;
            } else {
              ret[_dir] = originalStyle[_dir] - _off;
            }
          }
        }
        css(elem, ret);
      }
      function setTransform$1(elem, offset) {
        var originalOffset = getOffset$2(elem);
        var originalXY = getTransformXY(elem);
        var resultXY = {
          x: originalXY.x,
          y: originalXY.y
        };
        if ("left" in offset) {
          resultXY.x = originalXY.x + offset.left - originalOffset.left;
        }
        if ("top" in offset) {
          resultXY.y = originalXY.y + offset.top - originalOffset.top;
        }
        setTransformXY(elem, resultXY);
      }
      function setOffset(elem, offset, option) {
        if (option.ignoreShake) {
          var oriOffset = getOffset$2(elem);
          var oLeft = oriOffset.left.toFixed(0);
          var oTop = oriOffset.top.toFixed(0);
          var tLeft = offset.left.toFixed(0);
          var tTop = offset.top.toFixed(0);
          if (oLeft === tLeft && oTop === tTop) {
            return;
          }
        }
        if (option.useCssRight || option.useCssBottom) {
          setLeftTop(elem, offset, option);
        } else if (option.useCssTransform && getTransformName() in document.body.style) {
          setTransform$1(elem, offset);
        } else {
          setLeftTop(elem, offset, option);
        }
      }
      function each(arr, fn2) {
        for (var i2 = 0; i2 < arr.length; i2++) {
          fn2(arr[i2]);
        }
      }
      function isBorderBoxFn(elem) {
        return getComputedStyleX(elem, "boxSizing") === "border-box";
      }
      var BOX_MODELS = ["margin", "border", "padding"];
      var CONTENT_INDEX = -1;
      var PADDING_INDEX = 2;
      var BORDER_INDEX = 1;
      var MARGIN_INDEX = 0;
      function swap(elem, options, callback) {
        var old = {};
        var style = elem.style;
        var name;
        for (name in options) {
          if (options.hasOwnProperty(name)) {
            old[name] = style[name];
            style[name] = options[name];
          }
        }
        callback.call(elem);
        for (name in options) {
          if (options.hasOwnProperty(name)) {
            style[name] = old[name];
          }
        }
      }
      function getPBMWidth(elem, props, which) {
        var value = 0;
        var prop;
        var j2;
        var i2;
        for (j2 = 0; j2 < props.length; j2++) {
          prop = props[j2];
          if (prop) {
            for (i2 = 0; i2 < which.length; i2++) {
              var cssProp = void 0;
              if (prop === "border") {
                cssProp = "".concat(prop).concat(which[i2], "Width");
              } else {
                cssProp = prop + which[i2];
              }
              value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
            }
          }
        }
        return value;
      }
      var domUtils = {
        getParent: function getParent2(element) {
          var parent = element;
          do {
            if (parent.nodeType === 11 && parent.host) {
              parent = parent.host;
            } else {
              parent = parent.parentNode;
            }
          } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);
          return parent;
        }
      };
      each(["Width", "Height"], function(name) {
        domUtils["doc".concat(name)] = function(refWin) {
          var d2 = refWin.document;
          return Math.max(
            // firefox chrome documentElement.scrollHeight< body.scrollHeight
            // ie standard mode : documentElement.scrollHeight> body.scrollHeight
            d2.documentElement["scroll".concat(name)],
            // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
            d2.body["scroll".concat(name)],
            domUtils["viewport".concat(name)](d2)
          );
        };
        domUtils["viewport".concat(name)] = function(win) {
          var prop = "client".concat(name);
          var doc = win.document;
          var body = doc.body;
          var documentElement = doc.documentElement;
          var documentElementProp = documentElement[prop];
          return doc.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
        };
      });
      function getWH(elem, name, ex) {
        var extra = ex;
        if (isWindow(elem)) {
          return name === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
        } else if (elem.nodeType === 9) {
          return name === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
        }
        var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
        var borderBoxValue = name === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
        var isBorderBox = isBorderBoxFn(elem);
        var cssBoxValue = 0;
        if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
          borderBoxValue = void 0;
          cssBoxValue = getComputedStyleX(elem, name);
          if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {
            cssBoxValue = elem.style[name] || 0;
          }
          cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0;
        }
        if (extra === void 0) {
          extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
        }
        var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
        var val = borderBoxValue || cssBoxValue;
        if (extra === CONTENT_INDEX) {
          if (borderBoxValueOrIsBorderBox) {
            return val - getPBMWidth(elem, ["border", "padding"], which);
          }
          return cssBoxValue;
        } else if (borderBoxValueOrIsBorderBox) {
          if (extra === BORDER_INDEX) {
            return val;
          }
          return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
        }
        return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
      }
      var cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      };
      function getWHIgnoreDisplay() {
        for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
          args[_key2] = arguments[_key2];
        }
        var val;
        var elem = args[0];
        if (elem.offsetWidth !== 0) {
          val = getWH.apply(void 0, args);
        } else {
          swap(elem, cssShow, function() {
            val = getWH.apply(void 0, args);
          });
        }
        return val;
      }
      each(["width", "height"], function(name) {
        var first = name.charAt(0).toUpperCase() + name.slice(1);
        domUtils["outer".concat(first)] = function(el, includeMargin) {
          return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
        };
        var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
        domUtils[name] = function(elem, v2) {
          var val = v2;
          if (val !== void 0) {
            if (elem) {
              var isBorderBox = isBorderBoxFn(elem);
              if (isBorderBox) {
                val += getPBMWidth(elem, ["padding", "border"], which);
              }
              return css(elem, name, val);
            }
            return void 0;
          }
          return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
        };
      });
      function mix(to, from2) {
        for (var i2 in from2) {
          if (from2.hasOwnProperty(i2)) {
            to[i2] = from2[i2];
          }
        }
        return to;
      }
      var utils = {
        getWindow: function getWindow(node2) {
          if (node2 && node2.document && node2.setTimeout) {
            return node2;
          }
          var doc = node2.ownerDocument || node2;
          return doc.defaultView || doc.parentWindow;
        },
        getDocument,
        offset: function offset(el, value, option) {
          if (typeof value !== "undefined") {
            setOffset(el, value, option || {});
          } else {
            return getOffset$2(el);
          }
        },
        isWindow,
        each,
        css,
        clone: function clone2(obj) {
          var i2;
          var ret = {};
          for (i2 in obj) {
            if (obj.hasOwnProperty(i2)) {
              ret[i2] = obj[i2];
            }
          }
          var overflow = obj.overflow;
          if (overflow) {
            for (i2 in obj) {
              if (obj.hasOwnProperty(i2)) {
                ret.overflow[i2] = obj.overflow[i2];
              }
            }
          }
          return ret;
        },
        mix,
        getWindowScrollLeft: function getWindowScrollLeft(w2) {
          return getScrollLeft(w2);
        },
        getWindowScrollTop: function getWindowScrollTop(w2) {
          return getScrollTop(w2);
        },
        merge: function merge2() {
          var ret = {};
          for (var i2 = 0; i2 < arguments.length; i2++) {
            utils.mix(ret, i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]);
          }
          return ret;
        },
        viewportWidth: 0,
        viewportHeight: 0
      };
      mix(utils, domUtils);
      var getParent$1 = utils.getParent;
      function getOffsetParent(element) {
        if (utils.isWindow(element) || element.nodeType === 9) {
          return null;
        }
        var doc = utils.getDocument(element);
        var body = doc.body;
        var parent;
        var positionStyle = utils.css(element, "position");
        var skipStatic = positionStyle === "fixed" || positionStyle === "absolute";
        if (!skipStatic) {
          return element.nodeName.toLowerCase() === "html" ? null : getParent$1(element);
        }
        for (parent = getParent$1(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent$1(parent)) {
          positionStyle = utils.css(parent, "position");
          if (positionStyle !== "static") {
            return parent;
          }
        }
        return null;
      }
      var getParent$1$1 = utils.getParent;
      function isAncestorFixed(element) {
        if (utils.isWindow(element) || element.nodeType === 9) {
          return false;
        }
        var doc = utils.getDocument(element);
        var body = doc.body;
        var parent = null;
        for (
          parent = getParent$1$1(element);
          // 修复元素位于 document.documentElement 下导致崩溃问题
          parent && parent !== body && parent !== doc;
          parent = getParent$1$1(parent)
        ) {
          var positionStyle = utils.css(parent, "position");
          if (positionStyle === "fixed") {
            return true;
          }
        }
        return false;
      }
      function getVisibleRectForElement(element, alwaysByViewport) {
        var visibleRect = {
          left: 0,
          right: Infinity,
          top: 0,
          bottom: Infinity
        };
        var el = getOffsetParent(element);
        var doc = utils.getDocument(element);
        var win = doc.defaultView || doc.parentWindow;
        var body = doc.body;
        var documentElement = doc.documentElement;
        while (el) {
          if ((navigator.userAgent.indexOf("MSIE") === -1 || el.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
          // viewport. In some browsers, el.offsetParent may be
          // document.documentElement, so check for that too.
          el !== body && el !== documentElement && utils.css(el, "overflow") !== "visible") {
            var pos = utils.offset(el);
            pos.left += el.clientLeft;
            pos.top += el.clientTop;
            visibleRect.top = Math.max(visibleRect.top, pos.top);
            visibleRect.right = Math.min(
              visibleRect.right,
              // consider area without scrollBar
              pos.left + el.clientWidth
            );
            visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
            visibleRect.left = Math.max(visibleRect.left, pos.left);
          } else if (el === body || el === documentElement) {
            break;
          }
          el = getOffsetParent(el);
        }
        var originalPosition = null;
        if (!utils.isWindow(element) && element.nodeType !== 9) {
          originalPosition = element.style.position;
          var position2 = utils.css(element, "position");
          if (position2 === "absolute") {
            element.style.position = "fixed";
          }
        }
        var scrollX = utils.getWindowScrollLeft(win);
        var scrollY = utils.getWindowScrollTop(win);
        var viewportWidth = utils.viewportWidth(win);
        var viewportHeight = utils.viewportHeight(win);
        var documentWidth = documentElement.scrollWidth;
        var documentHeight = documentElement.scrollHeight;
        var bodyStyle = window.getComputedStyle(body);
        if (bodyStyle.overflowX === "hidden") {
          documentWidth = win.innerWidth;
        }
        if (bodyStyle.overflowY === "hidden") {
          documentHeight = win.innerHeight;
        }
        if (element.style) {
          element.style.position = originalPosition;
        }
        if (alwaysByViewport || isAncestorFixed(element)) {
          visibleRect.left = Math.max(visibleRect.left, scrollX);
          visibleRect.top = Math.max(visibleRect.top, scrollY);
          visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
          visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
        } else {
          var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
          visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
          var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
          visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
        }
        return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
      }
      function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
        var pos = utils.clone(elFuturePos);
        var size = {
          width: elRegion.width,
          height: elRegion.height
        };
        if (overflow.adjustX && pos.left < visibleRect.left) {
          pos.left = visibleRect.left;
        }
        if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
          size.width -= pos.left + size.width - visibleRect.right;
        }
        if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
          pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
        }
        if (overflow.adjustY && pos.top < visibleRect.top) {
          pos.top = visibleRect.top;
        }
        if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
          size.height -= pos.top + size.height - visibleRect.bottom;
        }
        if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
          pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
        }
        return utils.mix(pos, size);
      }
      function getRegion(node2) {
        var offset;
        var w2;
        var h2;
        if (!utils.isWindow(node2) && node2.nodeType !== 9) {
          offset = utils.offset(node2);
          w2 = utils.outerWidth(node2);
          h2 = utils.outerHeight(node2);
        } else {
          var win = utils.getWindow(node2);
          offset = {
            left: utils.getWindowScrollLeft(win),
            top: utils.getWindowScrollTop(win)
          };
          w2 = utils.viewportWidth(win);
          h2 = utils.viewportHeight(win);
        }
        offset.width = w2;
        offset.height = h2;
        return offset;
      }
      function getAlignOffset(region, align) {
        var V2 = align.charAt(0);
        var H2 = align.charAt(1);
        var w2 = region.width;
        var h2 = region.height;
        var x2 = region.left;
        var y2 = region.top;
        if (V2 === "c") {
          y2 += h2 / 2;
        } else if (V2 === "b") {
          y2 += h2;
        }
        if (H2 === "c") {
          x2 += w2 / 2;
        } else if (H2 === "r") {
          x2 += w2;
        }
        return {
          left: x2,
          top: y2
        };
      }
      function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset2) {
        var p1 = getAlignOffset(refNodeRegion, points[1]);
        var p2 = getAlignOffset(elRegion, points[0]);
        var diff = [p2.left - p1.left, p2.top - p1.top];
        return {
          left: Math.round(elRegion.left - diff[0] + offset[0] - targetOffset2[0]),
          top: Math.round(elRegion.top - diff[1] + offset[1] - targetOffset2[1])
        };
      }
      function isFailX(elFuturePos, elRegion, visibleRect) {
        return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
      }
      function isFailY(elFuturePos, elRegion, visibleRect) {
        return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
      }
      function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
        return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
      }
      function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
        return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
      }
      function flip(points, reg, map) {
        var ret = [];
        utils.each(points, function(p) {
          ret.push(p.replace(reg, function(m2) {
            return map[m2];
          }));
        });
        return ret;
      }
      function flipOffset(offset, index2) {
        offset[index2] = -offset[index2];
        return offset;
      }
      function convertOffset(str, offsetLen) {
        var n2;
        if (/%$/.test(str)) {
          n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
        } else {
          n2 = parseInt(str, 10);
        }
        return n2 || 0;
      }
      function normalizeOffset(offset, el) {
        offset[0] = convertOffset(offset[0], el.width);
        offset[1] = convertOffset(offset[1], el.height);
      }
      function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
        var points = align.points;
        var offset = align.offset || [0, 0];
        var targetOffset2 = align.targetOffset || [0, 0];
        var overflow = align.overflow;
        var source = align.source || el;
        offset = [].concat(offset);
        targetOffset2 = [].concat(targetOffset2);
        overflow = overflow || {};
        var newOverflowCfg = {};
        var fail = 0;
        var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
        var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
        var elRegion = getRegion(source);
        normalizeOffset(offset, elRegion);
        normalizeOffset(targetOffset2, tgtRegion);
        var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset2);
        var newElRegion = utils.merge(elRegion, elFuturePos);
        if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
          if (overflow.adjustX) {
            if (isFailX(elFuturePos, elRegion, visibleRect)) {
              var newPoints = flip(points, /[lr]/gi, {
                l: "r",
                r: "l"
              });
              var newOffset = flipOffset(offset, 0);
              var newTargetOffset = flipOffset(targetOffset2, 0);
              var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
              if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
                fail = 1;
                points = newPoints;
                offset = newOffset;
                targetOffset2 = newTargetOffset;
              }
            }
          }
          if (overflow.adjustY) {
            if (isFailY(elFuturePos, elRegion, visibleRect)) {
              var _newPoints = flip(points, /[tb]/gi, {
                t: "b",
                b: "t"
              });
              var _newOffset = flipOffset(offset, 1);
              var _newTargetOffset = flipOffset(targetOffset2, 1);
              var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
              if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
                fail = 1;
                points = _newPoints;
                offset = _newOffset;
                targetOffset2 = _newTargetOffset;
              }
            }
          }
          if (fail) {
            elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset2);
            utils.mix(newElRegion, elFuturePos);
          }
          var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
          var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
          if (isStillFailX || isStillFailY) {
            var _newPoints2 = points;
            if (isStillFailX) {
              _newPoints2 = flip(points, /[lr]/gi, {
                l: "r",
                r: "l"
              });
            }
            if (isStillFailY) {
              _newPoints2 = flip(points, /[tb]/gi, {
                t: "b",
                b: "t"
              });
            }
            points = _newPoints2;
            offset = align.offset || [0, 0];
            targetOffset2 = align.targetOffset || [0, 0];
          }
          newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
          newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
          if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
            newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
          }
        }
        if (newElRegion.width !== elRegion.width) {
          utils.css(source, "width", utils.width(source) + newElRegion.width - elRegion.width);
        }
        if (newElRegion.height !== elRegion.height) {
          utils.css(source, "height", utils.height(source) + newElRegion.height - elRegion.height);
        }
        utils.offset(source, {
          left: newElRegion.left,
          top: newElRegion.top
        }, {
          useCssRight: align.useCssRight,
          useCssBottom: align.useCssBottom,
          useCssTransform: align.useCssTransform,
          ignoreShake: align.ignoreShake
        });
        return {
          points,
          offset,
          targetOffset: targetOffset2,
          overflow: newOverflowCfg
        };
      }
      function isOutOfVisibleRect(target, alwaysByViewport) {
        var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
        var targetRegion = getRegion(target);
        return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
      }
      function alignElement(el, refNode, align) {
        var target = align.target || refNode;
        var refNodeRegion = getRegion(target);
        var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
        return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
      }
      alignElement.__getOffsetParent = getOffsetParent;
      alignElement.__getVisibleRectForElement = getVisibleRectForElement;
      function alignPoint(el, tgtPoint, align) {
        var pageX;
        var pageY;
        var doc = utils.getDocument(el);
        var win = doc.defaultView || doc.parentWindow;
        var scrollX = utils.getWindowScrollLeft(win);
        var scrollY = utils.getWindowScrollTop(win);
        var viewportWidth = utils.viewportWidth(win);
        var viewportHeight = utils.viewportHeight(win);
        if ("pageX" in tgtPoint) {
          pageX = tgtPoint.pageX;
        } else {
          pageX = scrollX + tgtPoint.clientX;
        }
        if ("pageY" in tgtPoint) {
          pageY = tgtPoint.pageY;
        } else {
          pageY = scrollY + tgtPoint.clientY;
        }
        var tgtRegion = {
          left: pageX,
          top: pageY,
          width: 0,
          height: 0
        };
        var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
        var points = [align.points[0], "cc"];
        return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
          points
        }), pointInView);
      }
      function cloneElement(vnode) {
        let nodeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
        let mergeRef = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        let ele = vnode;
        if (Array.isArray(vnode)) {
          ele = filterEmpty(vnode)[0];
        }
        if (!ele) {
          return null;
        }
        const node2 = vue.cloneVNode(ele, nodeProps, mergeRef);
        node2.props = override ? _extends(_extends({}, node2.props), nodeProps) : node2.props;
        warning$1(typeof node2.props.class !== "object");
        return node2;
      }
      const isVisible = (element) => {
        if (!element) {
          return false;
        }
        if (element.offsetParent) {
          return true;
        }
        if (element.getBBox) {
          const box = element.getBBox();
          if (box.width || box.height) {
            return true;
          }
        }
        if (element.getBoundingClientRect) {
          const box = element.getBoundingClientRect();
          if (box.width || box.height) {
            return true;
          }
        }
        return false;
      };
      function isSamePoint(prev2, next2) {
        if (prev2 === next2)
          return true;
        if (!prev2 || !next2)
          return false;
        if ("pageX" in next2 && "pageY" in next2) {
          return prev2.pageX === next2.pageX && prev2.pageY === next2.pageY;
        }
        if ("clientX" in next2 && "clientY" in next2) {
          return prev2.clientX === next2.clientX && prev2.clientY === next2.clientY;
        }
        return false;
      }
      function restoreFocus(activeElement, container) {
        if (activeElement !== document.activeElement && contains$1(container, activeElement) && typeof activeElement.focus === "function") {
          activeElement.focus();
        }
      }
      function monitorResize(element, callback) {
        let prevWidth = null;
        let prevHeight = null;
        function onResize(_ref) {
          let [{
            target
          }] = _ref;
          if (!document.documentElement.contains(target))
            return;
          const {
            width,
            height
          } = target.getBoundingClientRect();
          const fixedWidth = Math.floor(width);
          const fixedHeight = Math.floor(height);
          if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
            Promise.resolve().then(() => {
              callback({
                width: fixedWidth,
                height: fixedHeight
              });
            });
          }
          prevWidth = fixedWidth;
          prevHeight = fixedHeight;
        }
        const resizeObserver = new index(onResize);
        if (element) {
          resizeObserver.observe(element);
        }
        return () => {
          resizeObserver.disconnect();
        };
      }
      const useBuffer = (callback, buffer) => {
        let called = false;
        let timeout = null;
        function cancelTrigger() {
          clearTimeout(timeout);
        }
        function trigger(force) {
          if (!called || force === true) {
            if (callback() === false) {
              return;
            }
            called = true;
            cancelTrigger();
            timeout = setTimeout(() => {
              called = false;
            }, buffer.value);
          } else {
            cancelTrigger();
            timeout = setTimeout(() => {
              called = false;
              trigger();
            }, buffer.value);
          }
        }
        return [trigger, () => {
          called = false;
          cancelTrigger();
        }];
      };
      const alignProps = {
        align: Object,
        target: [Object, Function],
        onAlign: Function,
        monitorBufferTime: Number,
        monitorWindowResize: Boolean,
        disabled: Boolean
      };
      function getElement(func) {
        if (typeof func !== "function")
          return null;
        return func();
      }
      function getPoint(point) {
        if (typeof point !== "object" || !point)
          return null;
        return point;
      }
      const Align = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "Align",
        props: alignProps,
        emits: ["align"],
        setup(props, _ref) {
          let {
            expose,
            slots
          } = _ref;
          const cacheRef = vue.ref({});
          const nodeRef = vue.ref();
          const [forceAlign, cancelForceAlign] = useBuffer(() => {
            const {
              disabled: latestDisabled,
              target: latestTarget,
              align: latestAlign,
              onAlign: latestOnAlign
            } = props;
            if (!latestDisabled && latestTarget && nodeRef.value) {
              const source = nodeRef.value;
              let result;
              const element = getElement(latestTarget);
              const point = getPoint(latestTarget);
              cacheRef.value.element = element;
              cacheRef.value.point = point;
              cacheRef.value.align = latestAlign;
              const {
                activeElement
              } = document;
              if (element && isVisible(element)) {
                result = alignElement(source, element, latestAlign);
              } else if (point) {
                result = alignPoint(source, point, latestAlign);
              }
              restoreFocus(activeElement, source);
              if (latestOnAlign && result) {
                latestOnAlign(source, result);
              }
              return true;
            }
            return false;
          }, vue.computed(() => props.monitorBufferTime));
          const resizeMonitor = vue.ref({
            cancel: () => {
            }
          });
          const sourceResizeMonitor = vue.ref({
            cancel: () => {
            }
          });
          const goAlign = () => {
            const target = props.target;
            const element = getElement(target);
            const point = getPoint(target);
            if (nodeRef.value !== sourceResizeMonitor.value.element) {
              sourceResizeMonitor.value.cancel();
              sourceResizeMonitor.value.element = nodeRef.value;
              sourceResizeMonitor.value.cancel = monitorResize(nodeRef.value, forceAlign);
            }
            if (cacheRef.value.element !== element || !isSamePoint(cacheRef.value.point, point) || !isEqual(cacheRef.value.align, props.align)) {
              forceAlign();
              if (resizeMonitor.value.element !== element) {
                resizeMonitor.value.cancel();
                resizeMonitor.value.element = element;
                resizeMonitor.value.cancel = monitorResize(element, forceAlign);
              }
            }
          };
          vue.onMounted(() => {
            vue.nextTick(() => {
              goAlign();
            });
          });
          vue.onUpdated(() => {
            vue.nextTick(() => {
              goAlign();
            });
          });
          vue.watch(() => props.disabled, (disabled) => {
            if (!disabled) {
              forceAlign();
            } else {
              cancelForceAlign();
            }
          }, {
            immediate: true,
            flush: "post"
          });
          const winResizeRef = vue.ref(null);
          vue.watch(() => props.monitorWindowResize, (monitorWindowResize) => {
            if (monitorWindowResize) {
              if (!winResizeRef.value) {
                winResizeRef.value = addEventListenerWrap(window, "resize", forceAlign);
              }
            } else if (winResizeRef.value) {
              winResizeRef.value.remove();
              winResizeRef.value = null;
            }
          }, {
            flush: "post"
          });
          vue.onUnmounted(() => {
            resizeMonitor.value.cancel();
            sourceResizeMonitor.value.cancel();
            if (winResizeRef.value)
              winResizeRef.value.remove();
            cancelForceAlign();
          });
          expose({
            forceAlign: () => forceAlign(true)
          });
          return () => {
            const child = slots === null || slots === void 0 ? void 0 : slots.default();
            if (child) {
              return cloneElement(child[0], {
                ref: nodeRef
              }, true, true);
            }
            return null;
          };
        }
      });
      tuple("bottomLeft", "bottomRight", "topLeft", "topRight");
      const getTransitionProps = function(transitionName) {
        let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const transitionProps = transitionName ? _extends({
          name: transitionName,
          appear: true,
          // type: 'animation',
          // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
          // appearActiveClass: `antdv-base-transtion`,
          // appearToClass: `${transitionName}-appear ${transitionName}-appear-active`,
          enterFromClass: `${transitionName}-enter ${transitionName}-enter-prepare ${transitionName}-enter-start`,
          enterActiveClass: `${transitionName}-enter ${transitionName}-enter-prepare`,
          enterToClass: `${transitionName}-enter ${transitionName}-enter-active`,
          leaveFromClass: ` ${transitionName}-leave`,
          leaveActiveClass: `${transitionName}-leave ${transitionName}-leave-active`,
          leaveToClass: `${transitionName}-leave ${transitionName}-leave-active`
        }, opt) : _extends({
          css: false
        }, opt);
        return transitionProps;
      };
      const getTransitionName = (rootPrefixCls, motion, transitionName) => {
        if (transitionName !== void 0) {
          return transitionName;
        }
        return `${rootPrefixCls}-${motion}`;
      };
      const PopupInner = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "PopupInner",
        inheritAttrs: false,
        props: innerProps,
        emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
        setup(props, _ref) {
          let {
            expose,
            attrs,
            slots
          } = _ref;
          const alignRef = vue.shallowRef();
          const elementRef = vue.shallowRef();
          const alignedClassName = vue.shallowRef();
          const [stretchStyle, measureStretchStyle] = useStretchStyle(vue.toRef(props, "stretch"));
          const doMeasure = () => {
            if (props.stretch) {
              measureStretchStyle(props.getRootDomNode());
            }
          };
          const visible = vue.shallowRef(false);
          let timeoutId;
          vue.watch(() => props.visible, (val) => {
            clearTimeout(timeoutId);
            if (val) {
              timeoutId = setTimeout(() => {
                visible.value = props.visible;
              });
            } else {
              visible.value = false;
            }
          }, {
            immediate: true
          });
          const [status, goNextStatus] = useVisibleStatus(visible, doMeasure);
          const prepareResolveRef = vue.shallowRef();
          const getAlignTarget = () => {
            if (props.point) {
              return props.point;
            }
            return props.getRootDomNode;
          };
          const forceAlign = () => {
            var _a2;
            (_a2 = alignRef.value) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
          };
          const onInternalAlign = (popupDomNode, matchAlign) => {
            var _a2;
            const nextAlignedClassName = props.getClassNameFromAlign(matchAlign);
            const preAlignedClassName = alignedClassName.value;
            if (alignedClassName.value !== nextAlignedClassName) {
              alignedClassName.value = nextAlignedClassName;
            }
            if (status.value === "align") {
              if (preAlignedClassName !== nextAlignedClassName) {
                Promise.resolve().then(() => {
                  forceAlign();
                });
              } else {
                goNextStatus(() => {
                  var _a3;
                  (_a3 = prepareResolveRef.value) === null || _a3 === void 0 ? void 0 : _a3.call(prepareResolveRef);
                });
              }
              (_a2 = props.onAlign) === null || _a2 === void 0 ? void 0 : _a2.call(props, popupDomNode, matchAlign);
            }
          };
          const motion = vue.computed(() => {
            const m2 = typeof props.animation === "object" ? props.animation : getMotion(props);
            ["onAfterEnter", "onAfterLeave"].forEach((eventName) => {
              const originFn = m2[eventName];
              m2[eventName] = (node2) => {
                goNextStatus();
                status.value = "stable";
                originFn === null || originFn === void 0 ? void 0 : originFn(node2);
              };
            });
            return m2;
          });
          const onShowPrepare = () => {
            return new Promise((resolve) => {
              prepareResolveRef.value = resolve;
            });
          };
          vue.watch([motion, status], () => {
            if (!motion.value && status.value === "motion") {
              goNextStatus();
            }
          }, {
            immediate: true
          });
          expose({
            forceAlign,
            getElement: () => {
              return elementRef.value.$el || elementRef.value;
            }
          });
          const alignDisabled = vue.computed(() => {
            var _a2;
            if (((_a2 = props.align) === null || _a2 === void 0 ? void 0 : _a2.points) && (status.value === "align" || status.value === "stable")) {
              return false;
            }
            return true;
          });
          return () => {
            var _a2;
            const {
              zIndex: zIndex2,
              align,
              prefixCls,
              destroyPopupOnHide,
              onMouseenter,
              onMouseleave,
              onTouchstart = () => {
              },
              onMousedown
            } = props;
            const statusValue = status.value;
            const mergedStyle = [_extends(_extends({}, stretchStyle.value), {
              zIndex: zIndex2,
              opacity: statusValue === "motion" || statusValue === "stable" || !visible.value ? null : 0,
              // pointerEvents: statusValue === 'stable' ? null : 'none',
              pointerEvents: !visible.value && statusValue !== "stable" ? "none" : null
            }), attrs.style];
            let childNode = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
              visible: props.visible
            }));
            if (childNode.length > 1) {
              childNode = vue.createVNode("div", {
                "class": `${prefixCls}-content`
              }, [childNode]);
            }
            const mergedClassName = classNames(prefixCls, attrs.class, alignedClassName.value);
            const hasAnimate = visible.value || !props.visible;
            const transitionProps = hasAnimate ? getTransitionProps(motion.value.name, motion.value) : {};
            return vue.createVNode(vue.Transition, _objectSpread2$1(_objectSpread2$1({
              "ref": elementRef
            }, transitionProps), {}, {
              "onBeforeEnter": onShowPrepare
            }), {
              default: () => {
                return !destroyPopupOnHide || props.visible ? vue.withDirectives(vue.createVNode(Align, {
                  "target": getAlignTarget(),
                  "key": "popup",
                  "ref": alignRef,
                  "monitorWindowResize": true,
                  "disabled": alignDisabled.value,
                  "align": align,
                  "onAlign": onInternalAlign
                }, {
                  default: () => vue.createVNode("div", {
                    "class": mergedClassName,
                    "onMouseenter": onMouseenter,
                    "onMouseleave": onMouseleave,
                    "onMousedown": vue.withModifiers(onMousedown, ["capture"]),
                    [supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"]: vue.withModifiers(onTouchstart, ["capture"]),
                    "style": mergedStyle
                  }, [childNode])
                }), [[vue.vShow, visible.value]]) : null;
              }
            });
          };
        }
      });
      const Popup = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "Popup",
        inheritAttrs: false,
        props: popupProps,
        setup(props, _ref) {
          let {
            attrs,
            slots,
            expose
          } = _ref;
          const innerVisible = vue.shallowRef(false);
          const inMobile = vue.shallowRef(false);
          const popupRef = vue.shallowRef();
          const rootRef = vue.shallowRef();
          vue.watch([() => props.visible, () => props.mobile], () => {
            innerVisible.value = props.visible;
            if (props.visible && props.mobile) {
              inMobile.value = true;
            }
          }, {
            immediate: true,
            flush: "post"
          });
          expose({
            forceAlign: () => {
              var _a2;
              (_a2 = popupRef.value) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
            },
            getElement: () => {
              var _a2;
              return (_a2 = popupRef.value) === null || _a2 === void 0 ? void 0 : _a2.getElement();
            }
          });
          return () => {
            const cloneProps = _extends(_extends(_extends({}, props), attrs), {
              visible: innerVisible.value
            });
            const popupNode = inMobile.value ? vue.createVNode(MobilePopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
              "mobile": props.mobile,
              "ref": popupRef
            }), {
              default: slots.default
            }) : vue.createVNode(PopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
              "ref": popupRef
            }), {
              default: slots.default
            });
            return vue.createVNode("div", {
              "ref": rootRef
            }, [vue.createVNode(Mask, cloneProps, null), popupNode]);
          };
        }
      });
      function isPointsEq(a1, a2, isAlignPoint) {
        if (isAlignPoint) {
          return a1[0] === a2[0];
        }
        return a1[0] === a2[0] && a1[1] === a2[1];
      }
      function getAlignFromPlacement(builtinPlacements, placementStr, align) {
        const baseAlign = builtinPlacements[placementStr] || {};
        return _extends(_extends({}, baseAlign), align);
      }
      function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
        const {
          points
        } = align;
        const placements2 = Object.keys(builtinPlacements);
        for (let i2 = 0; i2 < placements2.length; i2 += 1) {
          const placement = placements2[i2];
          if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
            return `${prefixCls}-placement-${placement}`;
          }
        }
        return "";
      }
      const BaseMixin = {
        methods: {
          setState() {
            let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            let callback = arguments.length > 1 ? arguments[1] : void 0;
            let newState = typeof state === "function" ? state(this.$data, this.$props) : state;
            if (this.getDerivedStateFromProps) {
              const s2 = this.getDerivedStateFromProps(getOptionProps(this), _extends(_extends({}, this.$data), newState));
              if (s2 === null) {
                return;
              } else {
                newState = _extends(_extends({}, newState), s2 || {});
              }
            }
            _extends(this.$data, newState);
            if (this._.isMounted) {
              this.$forceUpdate();
            }
            vue.nextTick(() => {
              callback && callback();
            });
          },
          __emit() {
            const args = [].slice.call(arguments, 0);
            let eventName = args[0];
            eventName = `on${eventName[0].toUpperCase()}${eventName.substring(1)}`;
            const event = this.$props[eventName] || this.$attrs[eventName];
            if (args.length && event) {
              if (Array.isArray(event)) {
                for (let i2 = 0, l2 = event.length; i2 < l2; i2++) {
                  event[i2](...args.slice(1));
                }
              } else {
                event(...args.slice(1));
              }
            }
          }
        }
      };
      const PortalContextKey = Symbol("PortalContextKey");
      const useProvidePortal = function(instance) {
        let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          inTriggerContext: true
        };
        vue.provide(PortalContextKey, {
          inTriggerContext: config.inTriggerContext,
          shouldRender: vue.computed(() => {
            const {
              sPopupVisible,
              popupRef,
              forceRender,
              autoDestroy
            } = instance || {};
            let shouldRender = false;
            if (sPopupVisible || popupRef || forceRender) {
              shouldRender = true;
            }
            if (!sPopupVisible && autoDestroy) {
              shouldRender = false;
            }
            return shouldRender;
          })
        });
      };
      const useInjectPortal = () => {
        useProvidePortal({}, {
          inTriggerContext: false
        });
        const portalContext = vue.inject(PortalContextKey, {
          shouldRender: vue.computed(() => false),
          inTriggerContext: false
        });
        return {
          shouldRender: vue.computed(() => portalContext.shouldRender.value || portalContext.inTriggerContext === false)
        };
      };
      const Portal$1 = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "Portal",
        inheritAttrs: false,
        props: {
          getContainer: PropTypes.func.isRequired,
          didUpdate: Function
        },
        setup(props, _ref) {
          let {
            slots
          } = _ref;
          let isSSR = true;
          let container;
          const {
            shouldRender
          } = useInjectPortal();
          function setContainer() {
            if (shouldRender.value) {
              container = props.getContainer();
            }
          }
          vue.onBeforeMount(() => {
            isSSR = false;
            setContainer();
          });
          vue.onMounted(() => {
            if (container)
              return;
            setContainer();
          });
          const stopWatch = vue.watch(shouldRender, () => {
            if (shouldRender.value && !container) {
              container = props.getContainer();
            }
            if (container) {
              stopWatch();
            }
          });
          vue.onUpdated(() => {
            vue.nextTick(() => {
              var _a2;
              if (shouldRender.value) {
                (_a2 = props.didUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(props, props);
              }
            });
          });
          return () => {
            var _a2;
            if (!shouldRender.value)
              return null;
            if (isSSR) {
              return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
            }
            return container ? vue.createVNode(vue.Teleport, {
              "to": container
            }, slots) : null;
          };
        }
      });
      let cached;
      function getScrollBarSize(fresh) {
        if (typeof document === "undefined") {
          return 0;
        }
        if (fresh || cached === void 0) {
          const inner = document.createElement("div");
          inner.style.width = "100%";
          inner.style.height = "200px";
          const outer = document.createElement("div");
          const outerStyle = outer.style;
          outerStyle.position = "absolute";
          outerStyle.top = "0";
          outerStyle.left = "0";
          outerStyle.pointerEvents = "none";
          outerStyle.visibility = "hidden";
          outerStyle.width = "200px";
          outerStyle.height = "150px";
          outerStyle.overflow = "hidden";
          outer.appendChild(inner);
          document.body.appendChild(outer);
          const widthContained = inner.offsetWidth;
          outer.style.overflow = "scroll";
          let widthScroll = inner.offsetWidth;
          if (widthContained === widthScroll) {
            widthScroll = outer.clientWidth;
          }
          document.body.removeChild(outer);
          cached = widthContained - widthScroll;
        }
        return cached;
      }
      const UNIQUE_ID = `vc-util-locker-${Date.now()}`;
      let uuid = 0;
      function isBodyOverflowing() {
        return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
      }
      function useScrollLocker(lock) {
        const mergedLock = vue.computed(() => !!lock && !!lock.value);
        uuid += 1;
        const id = `${UNIQUE_ID}_${uuid}`;
        vue.watchEffect((onClear) => {
          if (!canUseDom$1()) {
            return;
          }
          if (mergedLock.value) {
            const scrollbarSize = getScrollBarSize();
            const isOverflow = isBodyOverflowing();
            updateCSS$1(`
html body {
  overflow-y: hidden;
  ${isOverflow ? `width: calc(100% - ${scrollbarSize}px);` : ""}
}`, id);
          } else {
            removeCSS(id);
          }
          onClear(() => {
            removeCSS(id);
          });
        }, {
          flush: "post"
        });
      }
      let openCount = 0;
      const supportDom = canUseDom$1();
      const getParent = (getContainer2) => {
        if (!supportDom) {
          return null;
        }
        if (getContainer2) {
          if (typeof getContainer2 === "string") {
            return document.querySelectorAll(getContainer2)[0];
          }
          if (typeof getContainer2 === "function") {
            return getContainer2();
          }
          if (typeof getContainer2 === "object" && getContainer2 instanceof window.HTMLElement) {
            return getContainer2;
          }
        }
        return document.body;
      };
      const Portal = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "PortalWrapper",
        inheritAttrs: false,
        props: {
          wrapperClassName: String,
          forceRender: {
            type: Boolean,
            default: void 0
          },
          getContainer: PropTypes.any,
          visible: {
            type: Boolean,
            default: void 0
          },
          autoLock: booleanType(),
          didUpdate: Function
        },
        setup(props, _ref) {
          let {
            slots
          } = _ref;
          const container = vue.shallowRef();
          const componentRef = vue.shallowRef();
          const rafId = vue.shallowRef();
          const triggerUpdate = vue.shallowRef(1);
          const defaultContainer = canUseDom$1() && document.createElement("div");
          const removeCurrentContainer = () => {
            var _a2, _b;
            if (container.value === defaultContainer) {
              (_b = (_a2 = container.value) === null || _a2 === void 0 ? void 0 : _a2.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(container.value);
            }
            container.value = null;
          };
          let parent = null;
          const attachToParent = function() {
            let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
            if (force || container.value && !container.value.parentNode) {
              parent = getParent(props.getContainer);
              if (parent) {
                parent.appendChild(container.value);
                return true;
              }
              return false;
            }
            return true;
          };
          const getContainer2 = () => {
            if (!supportDom) {
              return null;
            }
            if (!container.value) {
              container.value = defaultContainer;
              attachToParent(true);
            }
            setWrapperClassName();
            return container.value;
          };
          const setWrapperClassName = () => {
            const {
              wrapperClassName
            } = props;
            if (container.value && wrapperClassName && wrapperClassName !== container.value.className) {
              container.value.className = wrapperClassName;
            }
          };
          vue.onUpdated(() => {
            setWrapperClassName();
            attachToParent();
          });
          useScrollLocker(vue.computed(() => {
            return props.autoLock && props.visible && canUseDom$1() && (container.value === document.body || container.value === defaultContainer);
          }));
          vue.onMounted(() => {
            let init = false;
            vue.watch([() => props.visible, () => props.getContainer], (_ref2, _ref3) => {
              let [visible, getContainer22] = _ref2;
              let [prevVisible, prevGetContainer] = _ref3;
              if (supportDom) {
                parent = getParent(props.getContainer);
                if (parent === document.body) {
                  if (visible && !prevVisible) {
                    openCount += 1;
                  } else if (init) {
                    openCount -= 1;
                  }
                }
              }
              if (init) {
                const getContainerIsFunc = typeof getContainer22 === "function" && typeof prevGetContainer === "function";
                if (getContainerIsFunc ? getContainer22.toString() !== prevGetContainer.toString() : getContainer22 !== prevGetContainer) {
                  removeCurrentContainer();
                }
              }
              init = true;
            }, {
              immediate: true,
              flush: "post"
            });
            vue.nextTick(() => {
              if (!attachToParent()) {
                rafId.value = wrapperRaf(() => {
                  triggerUpdate.value += 1;
                });
              }
            });
          });
          vue.onBeforeUnmount(() => {
            const {
              visible
            } = props;
            if (supportDom && parent === document.body) {
              openCount = visible && openCount ? openCount - 1 : openCount;
            }
            removeCurrentContainer();
            wrapperRaf.cancel(rafId.value);
          });
          return () => {
            const {
              forceRender,
              visible
            } = props;
            let portal = null;
            const childProps = {
              getOpenCount: () => openCount,
              getContainer: getContainer2
            };
            if (triggerUpdate.value && (forceRender || visible || componentRef.value)) {
              portal = vue.createVNode(Portal$1, {
                "getContainer": getContainer2,
                "ref": componentRef,
                "didUpdate": props.didUpdate
              }, {
                default: () => {
                  var _a2;
                  return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots, childProps);
                }
              });
            }
            return portal;
          };
        }
      });
      const ALL_HANDLERS = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"];
      const Trigger = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "Trigger",
        mixins: [BaseMixin],
        inheritAttrs: false,
        props: triggerProps(),
        setup(props) {
          const align = vue.computed(() => {
            const {
              popupPlacement,
              popupAlign,
              builtinPlacements
            } = props;
            if (popupPlacement && builtinPlacements) {
              return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
            }
            return popupAlign;
          });
          const popupRef = vue.shallowRef(null);
          const setPopupRef = (val) => {
            popupRef.value = val;
          };
          return {
            vcTriggerContext: vue.inject("vcTriggerContext", {}),
            popupRef,
            setPopupRef,
            triggerRef: vue.shallowRef(null),
            align,
            focusTime: null,
            clickOutsideHandler: null,
            contextmenuOutsideHandler1: null,
            contextmenuOutsideHandler2: null,
            touchOutsideHandler: null,
            attachId: null,
            delayTimer: null,
            hasPopupMouseDown: false,
            preClickTime: null,
            preTouchTime: null,
            mouseDownTimeout: null,
            childOriginEvents: {}
          };
        },
        data() {
          const props = this.$props;
          let popupVisible;
          if (this.popupVisible !== void 0) {
            popupVisible = !!props.popupVisible;
          } else {
            popupVisible = !!props.defaultPopupVisible;
          }
          ALL_HANDLERS.forEach((h2) => {
            this[`fire${h2}`] = (e2) => {
              this.fireEvents(h2, e2);
            };
          });
          return {
            prevPopupVisible: popupVisible,
            sPopupVisible: popupVisible,
            point: null
          };
        },
        watch: {
          popupVisible(val) {
            if (val !== void 0) {
              this.prevPopupVisible = this.sPopupVisible;
              this.sPopupVisible = val;
            }
          }
        },
        created() {
          vue.provide("vcTriggerContext", {
            onPopupMouseDown: this.onPopupMouseDown,
            onPopupMouseenter: this.onPopupMouseenter,
            onPopupMouseleave: this.onPopupMouseleave
          });
          useProvidePortal(this);
        },
        deactivated() {
          this.setPopupVisible(false);
        },
        mounted() {
          this.$nextTick(() => {
            this.updatedCal();
          });
        },
        updated() {
          this.$nextTick(() => {
            this.updatedCal();
          });
        },
        beforeUnmount() {
          this.clearDelayTimer();
          this.clearOutsideHandler();
          clearTimeout(this.mouseDownTimeout);
          wrapperRaf.cancel(this.attachId);
        },
        methods: {
          updatedCal() {
            const props = this.$props;
            const state = this.$data;
            if (state.sPopupVisible) {
              let currentDocument;
              if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow())) {
                currentDocument = props.getDocument(this.getRootDomNode());
                this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
              }
              if (!this.touchOutsideHandler) {
                currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
                this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick, supportsPassive$1 ? {
                  passive: false
                } : false);
              }
              if (!this.contextmenuOutsideHandler1 && this.isContextmenuToShow()) {
                currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
                this.contextmenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextmenuClose);
              }
              if (!this.contextmenuOutsideHandler2 && this.isContextmenuToShow()) {
                this.contextmenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextmenuClose);
              }
            } else {
              this.clearOutsideHandler();
            }
          },
          onMouseenter(e2) {
            const {
              mouseEnterDelay
            } = this.$props;
            this.fireEvents("onMouseenter", e2);
            this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);
          },
          onMouseMove(e2) {
            this.fireEvents("onMousemove", e2);
            this.setPoint(e2);
          },
          onMouseleave(e2) {
            this.fireEvents("onMouseleave", e2);
            this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
          },
          onPopupMouseenter() {
            const {
              vcTriggerContext = {}
            } = this;
            if (vcTriggerContext.onPopupMouseenter) {
              vcTriggerContext.onPopupMouseenter();
            }
            this.clearDelayTimer();
          },
          onPopupMouseleave(e2) {
            var _a2;
            if (e2 && e2.relatedTarget && !e2.relatedTarget.setTimeout && contains$1((_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.getElement(), e2.relatedTarget)) {
              return;
            }
            if (this.isMouseLeaveToHide()) {
              this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
            }
            const {
              vcTriggerContext = {}
            } = this;
            if (vcTriggerContext.onPopupMouseleave) {
              vcTriggerContext.onPopupMouseleave(e2);
            }
          },
          onFocus(e2) {
            this.fireEvents("onFocus", e2);
            this.clearDelayTimer();
            if (this.isFocusToShow()) {
              this.focusTime = Date.now();
              this.delaySetPopupVisible(true, this.$props.focusDelay);
            }
          },
          onMousedown(e2) {
            this.fireEvents("onMousedown", e2);
            this.preClickTime = Date.now();
          },
          onTouchstart(e2) {
            this.fireEvents("onTouchstart", e2);
            this.preTouchTime = Date.now();
          },
          onBlur(e2) {
            if (!contains$1(e2.target, e2.relatedTarget || document.activeElement)) {
              this.fireEvents("onBlur", e2);
              this.clearDelayTimer();
              if (this.isBlurToHide()) {
                this.delaySetPopupVisible(false, this.$props.blurDelay);
              }
            }
          },
          onContextmenu(e2) {
            e2.preventDefault();
            this.fireEvents("onContextmenu", e2);
            this.setPopupVisible(true, e2);
          },
          onContextmenuClose() {
            if (this.isContextmenuToShow()) {
              this.close();
            }
          },
          onClick(event) {
            this.fireEvents("onClick", event);
            if (this.focusTime) {
              let preTime;
              if (this.preClickTime && this.preTouchTime) {
                preTime = Math.min(this.preClickTime, this.preTouchTime);
              } else if (this.preClickTime) {
                preTime = this.preClickTime;
              } else if (this.preTouchTime) {
                preTime = this.preTouchTime;
              }
              if (Math.abs(preTime - this.focusTime) < 20) {
                return;
              }
              this.focusTime = 0;
            }
            this.preClickTime = 0;
            this.preTouchTime = 0;
            if (this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && event && event.preventDefault) {
              event.preventDefault();
            }
            if (event && event.domEvent) {
              event.domEvent.preventDefault();
            }
            const nextVisible = !this.$data.sPopupVisible;
            if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
              this.setPopupVisible(!this.$data.sPopupVisible, event);
            }
          },
          onPopupMouseDown() {
            const {
              vcTriggerContext = {}
            } = this;
            this.hasPopupMouseDown = true;
            clearTimeout(this.mouseDownTimeout);
            this.mouseDownTimeout = setTimeout(() => {
              this.hasPopupMouseDown = false;
            }, 0);
            if (vcTriggerContext.onPopupMouseDown) {
              vcTriggerContext.onPopupMouseDown(...arguments);
            }
          },
          onDocumentClick(event) {
            if (this.$props.mask && !this.$props.maskClosable) {
              return;
            }
            const target = event.target;
            const root2 = this.getRootDomNode();
            const popupNode = this.getPopupDomNode();
            if (
              // mousedown on the target should also close popup when action is contextMenu.
              // https://github.com/ant-design/ant-design/issues/29853
              (!contains$1(root2, target) || this.isContextMenuOnly()) && !contains$1(popupNode, target) && !this.hasPopupMouseDown
            ) {
              this.delaySetPopupVisible(false, 0.1);
            }
          },
          getPopupDomNode() {
            var _a2;
            return ((_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.getElement()) || null;
          },
          getRootDomNode() {
            var _a2, _b, _c, _d;
            const {
              getTriggerDOMNode
            } = this.$props;
            if (getTriggerDOMNode) {
              const domNode = ((_b = (_a2 = this.triggerRef) === null || _a2 === void 0 ? void 0 : _a2.$el) === null || _b === void 0 ? void 0 : _b.nodeName) === "#comment" ? null : findDOMNode(this.triggerRef);
              return findDOMNode(getTriggerDOMNode(domNode));
            }
            try {
              const domNode = ((_d = (_c = this.triggerRef) === null || _c === void 0 ? void 0 : _c.$el) === null || _d === void 0 ? void 0 : _d.nodeName) === "#comment" ? null : findDOMNode(this.triggerRef);
              if (domNode) {
                return domNode;
              }
            } catch (err) {
            }
            return findDOMNode(this);
          },
          handleGetPopupClassFromAlign(align) {
            const className = [];
            const props = this.$props;
            const {
              popupPlacement,
              builtinPlacements,
              prefixCls,
              alignPoint: alignPoint2,
              getPopupClassNameFromAlign
            } = props;
            if (popupPlacement && builtinPlacements) {
              className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));
            }
            if (getPopupClassNameFromAlign) {
              className.push(getPopupClassNameFromAlign(align));
            }
            return className.join(" ");
          },
          getPopupAlign() {
            const props = this.$props;
            const {
              popupPlacement,
              popupAlign,
              builtinPlacements
            } = props;
            if (popupPlacement && builtinPlacements) {
              return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
            }
            return popupAlign;
          },
          getComponent() {
            const mouseProps = {};
            if (this.isMouseEnterToShow()) {
              mouseProps.onMouseenter = this.onPopupMouseenter;
            }
            if (this.isMouseLeaveToHide()) {
              mouseProps.onMouseleave = this.onPopupMouseleave;
            }
            mouseProps.onMousedown = this.onPopupMouseDown;
            mouseProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
            const {
              handleGetPopupClassFromAlign,
              getRootDomNode,
              $attrs
            } = this;
            const {
              prefixCls,
              destroyPopupOnHide,
              popupClassName,
              popupAnimation,
              popupTransitionName,
              popupStyle,
              mask,
              maskAnimation,
              maskTransitionName,
              zIndex: zIndex2,
              stretch,
              alignPoint: alignPoint2,
              mobile,
              forceRender
            } = this.$props;
            const {
              sPopupVisible,
              point
            } = this.$data;
            const popupProps2 = _extends(_extends({
              prefixCls,
              destroyPopupOnHide,
              visible: sPopupVisible,
              point: alignPoint2 ? point : null,
              align: this.align,
              animation: popupAnimation,
              getClassNameFromAlign: handleGetPopupClassFromAlign,
              stretch,
              getRootDomNode,
              mask,
              zIndex: zIndex2,
              transitionName: popupTransitionName,
              maskAnimation,
              maskTransitionName,
              class: popupClassName,
              style: popupStyle,
              onAlign: $attrs.onPopupAlign || noop$1
            }, mouseProps), {
              ref: this.setPopupRef,
              mobile,
              forceRender
            });
            return vue.createVNode(Popup, popupProps2, {
              default: this.$slots.popup || (() => getComponent(this, "popup"))
            });
          },
          attachParent(popupContainer) {
            wrapperRaf.cancel(this.attachId);
            const {
              getPopupContainer,
              getDocument: getDocument2
            } = this.$props;
            const domNode = this.getRootDomNode();
            let mountNode;
            if (!getPopupContainer) {
              mountNode = getDocument2(this.getRootDomNode()).body;
            } else if (domNode || getPopupContainer.length === 0) {
              mountNode = getPopupContainer(domNode);
            }
            if (mountNode) {
              mountNode.appendChild(popupContainer);
            } else {
              this.attachId = wrapperRaf(() => {
                this.attachParent(popupContainer);
              });
            }
          },
          getContainer() {
            const {
              $props: props
            } = this;
            const {
              getDocument: getDocument2
            } = props;
            const popupContainer = getDocument2(this.getRootDomNode()).createElement("div");
            popupContainer.style.position = "absolute";
            popupContainer.style.top = "0";
            popupContainer.style.left = "0";
            popupContainer.style.width = "100%";
            this.attachParent(popupContainer);
            return popupContainer;
          },
          setPopupVisible(sPopupVisible, event) {
            const {
              alignPoint: alignPoint2,
              sPopupVisible: prevPopupVisible,
              onPopupVisibleChange
            } = this;
            this.clearDelayTimer();
            if (prevPopupVisible !== sPopupVisible) {
              if (!hasProp(this, "popupVisible")) {
                this.setState({
                  sPopupVisible,
                  prevPopupVisible
                });
              }
              onPopupVisibleChange && onPopupVisibleChange(sPopupVisible);
            }
            if (alignPoint2 && event && sPopupVisible) {
              this.setPoint(event);
            }
          },
          setPoint(point) {
            const {
              alignPoint: alignPoint2
            } = this.$props;
            if (!alignPoint2 || !point)
              return;
            this.setState({
              point: {
                pageX: point.pageX,
                pageY: point.pageY
              }
            });
          },
          handlePortalUpdate() {
            if (this.prevPopupVisible !== this.sPopupVisible) {
              this.afterPopupVisibleChange(this.sPopupVisible);
            }
          },
          delaySetPopupVisible(visible, delayS, event) {
            const delay = delayS * 1e3;
            this.clearDelayTimer();
            if (delay) {
              const point = event ? {
                pageX: event.pageX,
                pageY: event.pageY
              } : null;
              this.delayTimer = setTimeout(() => {
                this.setPopupVisible(visible, point);
                this.clearDelayTimer();
              }, delay);
            } else {
              this.setPopupVisible(visible, event);
            }
          },
          clearDelayTimer() {
            if (this.delayTimer) {
              clearTimeout(this.delayTimer);
              this.delayTimer = null;
            }
          },
          clearOutsideHandler() {
            if (this.clickOutsideHandler) {
              this.clickOutsideHandler.remove();
              this.clickOutsideHandler = null;
            }
            if (this.contextmenuOutsideHandler1) {
              this.contextmenuOutsideHandler1.remove();
              this.contextmenuOutsideHandler1 = null;
            }
            if (this.contextmenuOutsideHandler2) {
              this.contextmenuOutsideHandler2.remove();
              this.contextmenuOutsideHandler2 = null;
            }
            if (this.touchOutsideHandler) {
              this.touchOutsideHandler.remove();
              this.touchOutsideHandler = null;
            }
          },
          createTwoChains(event) {
            let fn2 = () => {
            };
            const events = getEvents(this);
            if (this.childOriginEvents[event] && events[event]) {
              return this[`fire${event}`];
            }
            fn2 = this.childOriginEvents[event] || events[event] || fn2;
            return fn2;
          },
          isClickToShow() {
            const {
              action,
              showAction
            } = this.$props;
            return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
          },
          isContextMenuOnly() {
            const {
              action
            } = this.$props;
            return action === "contextmenu" || action.length === 1 && action[0] === "contextmenu";
          },
          isContextmenuToShow() {
            const {
              action,
              showAction
            } = this.$props;
            return action.indexOf("contextmenu") !== -1 || showAction.indexOf("contextmenu") !== -1;
          },
          isClickToHide() {
            const {
              action,
              hideAction
            } = this.$props;
            return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
          },
          isMouseEnterToShow() {
            const {
              action,
              showAction
            } = this.$props;
            return action.indexOf("hover") !== -1 || showAction.indexOf("mouseenter") !== -1;
          },
          isMouseLeaveToHide() {
            const {
              action,
              hideAction
            } = this.$props;
            return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseleave") !== -1;
          },
          isFocusToShow() {
            const {
              action,
              showAction
            } = this.$props;
            return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
          },
          isBlurToHide() {
            const {
              action,
              hideAction
            } = this.$props;
            return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
          },
          forcePopupAlign() {
            var _a2;
            if (this.$data.sPopupVisible) {
              (_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
            }
          },
          fireEvents(type3, e2) {
            if (this.childOriginEvents[type3]) {
              this.childOriginEvents[type3](e2);
            }
            const event = this.$props[type3] || this.$attrs[type3];
            if (event) {
              event(e2);
            }
          },
          close() {
            this.setPopupVisible(false);
          }
        },
        render() {
          const {
            $attrs
          } = this;
          const children = filterEmpty(getSlot(this));
          const {
            alignPoint: alignPoint2,
            getPopupContainer
          } = this.$props;
          const child = children[0];
          this.childOriginEvents = getEvents(child);
          const newChildProps = {
            key: "trigger"
          };
          if (this.isContextmenuToShow()) {
            newChildProps.onContextmenu = this.onContextmenu;
          } else {
            newChildProps.onContextmenu = this.createTwoChains("onContextmenu");
          }
          if (this.isClickToHide() || this.isClickToShow()) {
            newChildProps.onClick = this.onClick;
            newChildProps.onMousedown = this.onMousedown;
            newChildProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart;
          } else {
            newChildProps.onClick = this.createTwoChains("onClick");
            newChildProps.onMousedown = this.createTwoChains("onMousedown");
            newChildProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart");
          }
          if (this.isMouseEnterToShow()) {
            newChildProps.onMouseenter = this.onMouseenter;
            if (alignPoint2) {
              newChildProps.onMousemove = this.onMouseMove;
            }
          } else {
            newChildProps.onMouseenter = this.createTwoChains("onMouseenter");
          }
          if (this.isMouseLeaveToHide()) {
            newChildProps.onMouseleave = this.onMouseleave;
          } else {
            newChildProps.onMouseleave = this.createTwoChains("onMouseleave");
          }
          if (this.isFocusToShow() || this.isBlurToHide()) {
            newChildProps.onFocus = this.onFocus;
            newChildProps.onBlur = this.onBlur;
          } else {
            newChildProps.onFocus = this.createTwoChains("onFocus");
            newChildProps.onBlur = (e2) => {
              if (e2 && (!e2.relatedTarget || !contains$1(e2.target, e2.relatedTarget))) {
                this.createTwoChains("onBlur")(e2);
              }
            };
          }
          const childrenClassName = classNames(child && child.props && child.props.class, $attrs.class);
          if (childrenClassName) {
            newChildProps.class = childrenClassName;
          }
          const trigger = cloneElement(child, _extends(_extends({}, newChildProps), {
            ref: "triggerRef"
          }), true, true);
          const portal = vue.createVNode(Portal, {
            "key": "portal",
            "getContainer": getPopupContainer && (() => getPopupContainer(this.getRootDomNode())),
            "didUpdate": this.handlePortalUpdate,
            "visible": this.$data.sPopupVisible
          }, {
            default: this.getComponent
          });
          return vue.createVNode(vue.Fragment, null, [trigger, portal]);
        }
      });
      function useMergedState(defaultStateValue, option) {
        const {
          defaultValue,
          value = vue.ref()
        } = option || {};
        let initValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
        if (value.value !== void 0) {
          initValue = vue.unref(value);
        }
        if (defaultValue !== void 0) {
          initValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
        }
        const innerValue = vue.ref(initValue);
        const mergedValue = vue.ref(initValue);
        vue.watchEffect(() => {
          let val = value.value !== void 0 ? value.value : innerValue.value;
          if (option.postState) {
            val = option.postState(val);
          }
          mergedValue.value = val;
        });
        function triggerChange(newValue) {
          const preVal = mergedValue.value;
          innerValue.value = newValue;
          if (vue.toRaw(mergedValue.value) !== newValue && option.onChange) {
            option.onChange(newValue, preVal);
          }
        }
        vue.watch(value, () => {
          innerValue.value = value.value;
        });
        return [mergedValue, triggerChange];
      }
      var contextKey$1 = Symbol("iconContext");
      var useInjectIconContext = function useInjectIconContext2() {
        return vue.inject(contextKey$1, {
          prefixCls: vue.ref("anticon"),
          rootClassName: vue.ref(""),
          csp: vue.ref()
        });
      };
      function canUseDom() {
        return !!(typeof window !== "undefined" && window.document && window.document.createElement);
      }
      function contains(root2, n2) {
        if (!root2) {
          return false;
        }
        if (root2.contains) {
          return root2.contains(n2);
        }
        return false;
      }
      var APPEND_ORDER = "data-vc-order";
      var MARK_KEY = "vc-icon-key";
      var containerCache = /* @__PURE__ */ new Map();
      function getMark() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
        if (mark) {
          return mark.startsWith("data-") ? mark : "data-".concat(mark);
        }
        return MARK_KEY;
      }
      function getContainer(option) {
        if (option.attachTo) {
          return option.attachTo;
        }
        var head = document.querySelector("head");
        return head || document.body;
      }
      function getOrder(prepend) {
        if (prepend === "queue") {
          return "prependQueue";
        }
        return prepend ? "prepend" : "append";
      }
      function findStyles(container) {
        return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
          return node2.tagName === "STYLE";
        });
      }
      function injectCSS(css2) {
        var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!canUseDom()) {
          return null;
        }
        var csp = option.csp, prepend = option.prepend;
        var styleNode = document.createElement("style");
        styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
        if (csp && csp.nonce) {
          styleNode.nonce = csp.nonce;
        }
        styleNode.innerHTML = css2;
        var container = getContainer(option);
        var firstChild = container.firstChild;
        if (prepend) {
          if (prepend === "queue") {
            var existStyle = findStyles(container).filter(function(node2) {
              return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER));
            });
            if (existStyle.length) {
              container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
              return styleNode;
            }
          }
          container.insertBefore(styleNode, firstChild);
        } else {
          container.appendChild(styleNode);
        }
        return styleNode;
      }
      function findExistNode(key) {
        var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var container = getContainer(option);
        return findStyles(container).find(function(node2) {
          return node2.getAttribute(getMark(option)) === key;
        });
      }
      function syncRealContainer(container, option) {
        var cachedRealContainer = containerCache.get(container);
        if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
          var placeholderStyle = injectCSS("", option);
          var parentNode = placeholderStyle.parentNode;
          containerCache.set(container, parentNode);
          container.removeChild(placeholderStyle);
        }
      }
      function updateCSS(css2, key) {
        var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var container = getContainer(option);
        syncRealContainer(container, option);
        var existNode = findExistNode(key, option);
        if (existNode) {
          if (option.csp && option.csp.nonce && existNode.nonce !== option.csp.nonce) {
            existNode.nonce = option.csp.nonce;
          }
          if (existNode.innerHTML !== css2) {
            existNode.innerHTML = css2;
          }
          return existNode;
        }
        var newNode = injectCSS(css2, option);
        newNode.setAttribute(getMark(option), key);
        return newNode;
      }
      function _objectSpread$5(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2] != null ? Object(arguments[i2]) : {};
          var ownKeys2 = Object.keys(source);
          if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
          }
          ownKeys2.forEach(function(key) {
            _defineProperty$5(target, key, source[key]);
          });
        }
        return target;
      }
      function _defineProperty$5(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function warning(valid, message) {
      }
      function isIconDefinition(target) {
        return typeof target === "object" && typeof target.name === "string" && typeof target.theme === "string" && (typeof target.icon === "object" || typeof target.icon === "function");
      }
      function generate(node2, key, rootProps) {
        if (!rootProps) {
          return vue.h(node2.tag, _objectSpread$5({
            key
          }, node2.attrs), (node2.children || []).map(function(child, index2) {
            return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
          }));
        }
        return vue.h(node2.tag, _objectSpread$5({
          key
        }, rootProps, node2.attrs), (node2.children || []).map(function(child, index2) {
          return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
        }));
      }
      function getSecondaryColor(primaryColor) {
        return generate$1(primaryColor)[0];
      }
      function normalizeTwoToneColors(twoToneColor) {
        if (!twoToneColor) {
          return [];
        }
        return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
      }
      var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
      function getRoot(ele) {
        return ele && ele.getRootNode && ele.getRootNode();
      }
      function inShadow(ele) {
        if (!canUseDom()) {
          return false;
        }
        return getRoot(ele) instanceof ShadowRoot;
      }
      function getShadowRoot(ele) {
        return inShadow(ele) ? getRoot(ele) : null;
      }
      var useInsertStyles = function useInsertStyles2() {
        var _useInjectIconContext = useInjectIconContext(), prefixCls = _useInjectIconContext.prefixCls, csp = _useInjectIconContext.csp;
        var instance = vue.getCurrentInstance();
        var mergedStyleStr = iconStyles;
        if (prefixCls) {
          mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls.value);
        }
        vue.nextTick(function() {
          if (!canUseDom()) {
            return;
          }
          var ele = instance.vnode.el;
          var shadowRoot = getShadowRoot(ele);
          updateCSS(mergedStyleStr, "@ant-design-vue-icons", {
            prepend: true,
            csp: csp.value,
            attachTo: shadowRoot
          });
        });
      };
      var _excluded$1 = ["icon", "primaryColor", "secondaryColor"];
      function _objectWithoutProperties$1(source, excluded) {
        if (source == null)
          return {};
        var target = _objectWithoutPropertiesLoose$1(source, excluded);
        var key, i2;
        if (Object.getOwnPropertySymbols) {
          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
          for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
            key = sourceSymbolKeys[i2];
            if (excluded.indexOf(key) >= 0)
              continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key))
              continue;
            target[key] = source[key];
          }
        }
        return target;
      }
      function _objectWithoutPropertiesLoose$1(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i2;
        for (i2 = 0; i2 < sourceKeys.length; i2++) {
          key = sourceKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      function _objectSpread$4(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2] != null ? Object(arguments[i2]) : {};
          var ownKeys2 = Object.keys(source);
          if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
          }
          ownKeys2.forEach(function(key) {
            _defineProperty$4(target, key, source[key]);
          });
        }
        return target;
      }
      function _defineProperty$4(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var twoToneColorPalette = vue.reactive({
        primaryColor: "#333",
        secondaryColor: "#E6E6E6",
        calculated: false
      });
      function setTwoToneColors(_ref) {
        var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
        twoToneColorPalette.primaryColor = primaryColor;
        twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
        twoToneColorPalette.calculated = !!secondaryColor;
      }
      function getTwoToneColors() {
        return _objectSpread$4({}, twoToneColorPalette);
      }
      var IconBase = function IconBase2(props, context) {
        var _props$context$attrs = _objectSpread$4({}, props, context.attrs), icon = _props$context$attrs.icon, primaryColor = _props$context$attrs.primaryColor, secondaryColor = _props$context$attrs.secondaryColor, restProps = _objectWithoutProperties$1(_props$context$attrs, _excluded$1);
        var colors = twoToneColorPalette;
        if (primaryColor) {
          colors = {
            primaryColor,
            secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
          };
        }
        warning(isIconDefinition(icon));
        if (!isIconDefinition(icon)) {
          return null;
        }
        var target = icon;
        if (target && typeof target.icon === "function") {
          target = _objectSpread$4({}, target, {
            icon: target.icon(colors.primaryColor, colors.secondaryColor)
          });
        }
        return generate(target.icon, "svg-".concat(target.name), _objectSpread$4({}, restProps, {
          "data-icon": target.name,
          width: "1em",
          height: "1em",
          fill: "currentColor",
          "aria-hidden": "true"
        }));
      };
      IconBase.props = {
        icon: Object,
        primaryColor: String,
        secondaryColor: String,
        focusable: String
      };
      IconBase.inheritAttrs = false;
      IconBase.displayName = "IconBase";
      IconBase.getTwoToneColors = getTwoToneColors;
      IconBase.setTwoToneColors = setTwoToneColors;
      const VueIcon = IconBase;
      function _slicedToArray$1(arr, i2) {
        return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
      }
      function _nonIterableRest$1() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray$1(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray$1(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray$1(o2, minLen);
      }
      function _arrayLikeToArray$1(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      function _iterableToArrayLimit$1(arr, i2) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null)
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles$1(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function setTwoToneColor(twoToneColor) {
        var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$1(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
        return VueIcon.setTwoToneColors({
          primaryColor,
          secondaryColor
        });
      }
      function getTwoToneColor() {
        var colors = VueIcon.getTwoToneColors();
        if (!colors.calculated) {
          return colors.primaryColor;
        }
        return [colors.primaryColor, colors.secondaryColor];
      }
      var InsertStyles = vue.defineComponent({
        name: "InsertStyles",
        setup: function setup() {
          useInsertStyles();
          return function() {
            return null;
          };
        }
      });
      var _excluded = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
      function _slicedToArray(arr, i2) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray(o2, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      function _iterableToArrayLimit(arr, i2) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null)
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
          for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _objectSpread$3(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2] != null ? Object(arguments[i2]) : {};
          var ownKeys2 = Object.keys(source);
          if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
          }
          ownKeys2.forEach(function(key) {
            _defineProperty$3(target, key, source[key]);
          });
        }
        return target;
      }
      function _defineProperty$3(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _objectWithoutProperties(source, excluded) {
        if (source == null)
          return {};
        var target = _objectWithoutPropertiesLoose(source, excluded);
        var key, i2;
        if (Object.getOwnPropertySymbols) {
          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
          for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
            key = sourceSymbolKeys[i2];
            if (excluded.indexOf(key) >= 0)
              continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key))
              continue;
            target[key] = source[key];
          }
        }
        return target;
      }
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i2;
        for (i2 = 0; i2 < sourceKeys.length; i2++) {
          key = sourceKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      setTwoToneColor(blue.primary);
      var Icon = function Icon2(props, context) {
        var _classObj;
        var _props$context$attrs = _objectSpread$3({}, props, context.attrs), cls = _props$context$attrs["class"], icon = _props$context$attrs.icon, spin = _props$context$attrs.spin, rotate = _props$context$attrs.rotate, tabindex = _props$context$attrs.tabindex, twoToneColor = _props$context$attrs.twoToneColor, onClick = _props$context$attrs.onClick, restProps = _objectWithoutProperties(_props$context$attrs, _excluded);
        var _useInjectIconContext = useInjectIconContext(), prefixCls = _useInjectIconContext.prefixCls, rootClassName = _useInjectIconContext.rootClassName;
        var classObj = (_classObj = {}, _defineProperty$3(_classObj, rootClassName.value, !!rootClassName.value), _defineProperty$3(_classObj, prefixCls.value, true), _defineProperty$3(_classObj, "".concat(prefixCls.value, "-").concat(icon.name), Boolean(icon.name)), _defineProperty$3(_classObj, "".concat(prefixCls.value, "-spin"), !!spin || icon.name === "loading"), _classObj);
        var iconTabIndex = tabindex;
        if (iconTabIndex === void 0 && onClick) {
          iconTabIndex = -1;
        }
        var svgStyle = rotate ? {
          msTransform: "rotate(".concat(rotate, "deg)"),
          transform: "rotate(".concat(rotate, "deg)")
        } : void 0;
        var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
        return vue.createVNode("span", _objectSpread$3({
          "role": "img",
          "aria-label": icon.name
        }, restProps, {
          "onClick": onClick,
          "class": [classObj, cls],
          "tabindex": iconTabIndex
        }), [vue.createVNode(VueIcon, {
          "icon": icon,
          "primaryColor": primaryColor,
          "secondaryColor": secondaryColor,
          "style": svgStyle
        }, null), vue.createVNode(InsertStyles, null, null)]);
      };
      Icon.props = {
        spin: Boolean,
        rotate: Number,
        icon: Object,
        twoToneColor: [String, Array]
      };
      Icon.displayName = "AntdIcon";
      Icon.inheritAttrs = false;
      Icon.getTwoToneColor = getTwoToneColor;
      Icon.setTwoToneColor = setTwoToneColor;
      const AntdIcon = Icon;
      var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };
      const CloseOutlinedSvg = CloseOutlined$2;
      function _objectSpread$2(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2] != null ? Object(arguments[i2]) : {};
          var ownKeys2 = Object.keys(source);
          if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
          }
          ownKeys2.forEach(function(key) {
            _defineProperty$2(target, key, source[key]);
          });
        }
        return target;
      }
      function _defineProperty$2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var CloseOutlined = function CloseOutlined2(props, context) {
        var p = _objectSpread$2({}, props, context.attrs);
        return vue.createVNode(AntdIcon, _objectSpread$2({}, p, {
          "icon": CloseOutlinedSvg
        }), null);
      };
      CloseOutlined.displayName = "CloseOutlined";
      CloseOutlined.inheritAttrs = false;
      const CloseOutlined$1 = CloseOutlined;
      const initMotionCommon = (duration) => ({
        animationDuration: duration,
        animationFillMode: "both"
      });
      const initMotionCommonLeave = (duration) => ({
        animationDuration: duration,
        animationFillMode: "both"
      });
      const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
        let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
        const sameLevelPrefix = sameLevel ? "&" : "";
        return {
          [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: _extends(_extends({}, initMotionCommon(duration)), {
            animationPlayState: "paused"
          }),
          [`${sameLevelPrefix}${motionCls}-leave`]: _extends(_extends({}, initMotionCommonLeave(duration)), {
            animationPlayState: "paused"
          }),
          [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
            animationName: inKeyframes,
            animationPlayState: "running"
          },
          [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
            animationName: outKeyframes,
            animationPlayState: "running",
            pointerEvents: "none"
          }
        };
      };
      const fadeIn = new Keyframe("antFadeIn", {
        "0%": {
          opacity: 0
        },
        "100%": {
          opacity: 1
        }
      });
      const fadeOut = new Keyframe("antFadeOut", {
        "0%": {
          opacity: 1
        },
        "100%": {
          opacity: 0
        }
      });
      const initFadeMotion = function(token2) {
        let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        const {
          antCls
        } = token2;
        const motionCls = `${antCls}-fade`;
        const sameLevelPrefix = sameLevel ? "&" : "";
        return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
          [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
            opacity: 0,
            animationTimingFunction: "linear"
          },
          [`${sameLevelPrefix}${motionCls}-leave`]: {
            animationTimingFunction: "linear"
          }
        }];
      };
      const zoomIn = new Keyframe("antZoomIn", {
        "0%": {
          transform: "scale(0.2)",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          opacity: 1
        }
      });
      const zoomOut = new Keyframe("antZoomOut", {
        "0%": {
          transform: "scale(1)"
        },
        "100%": {
          transform: "scale(0.2)",
          opacity: 0
        }
      });
      const zoomBigIn = new Keyframe("antZoomBigIn", {
        "0%": {
          transform: "scale(0.8)",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          opacity: 1
        }
      });
      const zoomBigOut = new Keyframe("antZoomBigOut", {
        "0%": {
          transform: "scale(1)"
        },
        "100%": {
          transform: "scale(0.8)",
          opacity: 0
        }
      });
      const zoomUpIn = new Keyframe("antZoomUpIn", {
        "0%": {
          transform: "scale(0.8)",
          transformOrigin: "50% 0%",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          transformOrigin: "50% 0%"
        }
      });
      const zoomUpOut = new Keyframe("antZoomUpOut", {
        "0%": {
          transform: "scale(1)",
          transformOrigin: "50% 0%"
        },
        "100%": {
          transform: "scale(0.8)",
          transformOrigin: "50% 0%",
          opacity: 0
        }
      });
      const zoomLeftIn = new Keyframe("antZoomLeftIn", {
        "0%": {
          transform: "scale(0.8)",
          transformOrigin: "0% 50%",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          transformOrigin: "0% 50%"
        }
      });
      const zoomLeftOut = new Keyframe("antZoomLeftOut", {
        "0%": {
          transform: "scale(1)",
          transformOrigin: "0% 50%"
        },
        "100%": {
          transform: "scale(0.8)",
          transformOrigin: "0% 50%",
          opacity: 0
        }
      });
      const zoomRightIn = new Keyframe("antZoomRightIn", {
        "0%": {
          transform: "scale(0.8)",
          transformOrigin: "100% 50%",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          transformOrigin: "100% 50%"
        }
      });
      const zoomRightOut = new Keyframe("antZoomRightOut", {
        "0%": {
          transform: "scale(1)",
          transformOrigin: "100% 50%"
        },
        "100%": {
          transform: "scale(0.8)",
          transformOrigin: "100% 50%",
          opacity: 0
        }
      });
      const zoomDownIn = new Keyframe("antZoomDownIn", {
        "0%": {
          transform: "scale(0.8)",
          transformOrigin: "50% 100%",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)",
          transformOrigin: "50% 100%"
        }
      });
      const zoomDownOut = new Keyframe("antZoomDownOut", {
        "0%": {
          transform: "scale(1)",
          transformOrigin: "50% 100%"
        },
        "100%": {
          transform: "scale(0.8)",
          transformOrigin: "50% 100%",
          opacity: 0
        }
      });
      const zoomMotion = {
        zoom: {
          inKeyframes: zoomIn,
          outKeyframes: zoomOut
        },
        "zoom-big": {
          inKeyframes: zoomBigIn,
          outKeyframes: zoomBigOut
        },
        "zoom-big-fast": {
          inKeyframes: zoomBigIn,
          outKeyframes: zoomBigOut
        },
        "zoom-left": {
          inKeyframes: zoomLeftIn,
          outKeyframes: zoomLeftOut
        },
        "zoom-right": {
          inKeyframes: zoomRightIn,
          outKeyframes: zoomRightOut
        },
        "zoom-up": {
          inKeyframes: zoomUpIn,
          outKeyframes: zoomUpOut
        },
        "zoom-down": {
          inKeyframes: zoomDownIn,
          outKeyframes: zoomDownOut
        }
      };
      const initZoomMotion = (token2, motionName) => {
        const {
          antCls
        } = token2;
        const motionCls = `${antCls}-${motionName}`;
        const {
          inKeyframes,
          outKeyframes
        } = zoomMotion[motionName];
        return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
          [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
            transform: "scale(0)",
            opacity: 0,
            animationTimingFunction: token2.motionEaseOutCirc,
            "&-prepare": {
              transform: "none"
            }
          },
          [`${motionCls}-leave`]: {
            animationTimingFunction: token2.motionEaseInOutCirc
          }
        }];
      };
      const autoAdjustOverflow = {
        adjustX: 1,
        adjustY: 1
      };
      const targetOffset$1 = [0, 0];
      const placements = {
        left: {
          points: ["cr", "cl"],
          overflow: autoAdjustOverflow,
          offset: [-4, 0],
          targetOffset: targetOffset$1
        },
        right: {
          points: ["cl", "cr"],
          overflow: autoAdjustOverflow,
          offset: [4, 0],
          targetOffset: targetOffset$1
        },
        top: {
          points: ["bc", "tc"],
          overflow: autoAdjustOverflow,
          offset: [0, -4],
          targetOffset: targetOffset$1
        },
        bottom: {
          points: ["tc", "bc"],
          overflow: autoAdjustOverflow,
          offset: [0, 4],
          targetOffset: targetOffset$1
        },
        topLeft: {
          points: ["bl", "tl"],
          overflow: autoAdjustOverflow,
          offset: [0, -4],
          targetOffset: targetOffset$1
        },
        leftTop: {
          points: ["tr", "tl"],
          overflow: autoAdjustOverflow,
          offset: [-4, 0],
          targetOffset: targetOffset$1
        },
        topRight: {
          points: ["br", "tr"],
          overflow: autoAdjustOverflow,
          offset: [0, -4],
          targetOffset: targetOffset$1
        },
        rightTop: {
          points: ["tl", "tr"],
          overflow: autoAdjustOverflow,
          offset: [4, 0],
          targetOffset: targetOffset$1
        },
        bottomRight: {
          points: ["tr", "br"],
          overflow: autoAdjustOverflow,
          offset: [0, 4],
          targetOffset: targetOffset$1
        },
        rightBottom: {
          points: ["bl", "br"],
          overflow: autoAdjustOverflow,
          offset: [4, 0],
          targetOffset: targetOffset$1
        },
        bottomLeft: {
          points: ["tl", "bl"],
          overflow: autoAdjustOverflow,
          offset: [0, 4],
          targetOffset: targetOffset$1
        },
        leftBottom: {
          points: ["br", "bl"],
          overflow: autoAdjustOverflow,
          offset: [-4, 0],
          targetOffset: targetOffset$1
        }
      };
      const tooltipContentProps = {
        prefixCls: String,
        id: String,
        overlayInnerStyle: PropTypes.any
      };
      const Content$1 = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "TooltipContent",
        props: tooltipContentProps,
        setup(props, _ref) {
          let {
            slots
          } = _ref;
          return () => {
            var _a2;
            return vue.createVNode("div", {
              "class": `${props.prefixCls}-inner`,
              "id": props.id,
              "role": "tooltip",
              "style": props.overlayInnerStyle
            }, [(_a2 = slots.overlay) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
          };
        }
      });
      var __rest$3 = function(s2, e2) {
        var t2 = {};
        for (var p in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
            t2[p] = s2[p];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
              t2[p[i2]] = s2[p[i2]];
          }
        return t2;
      };
      function noop() {
      }
      const Tooltip$1 = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "Tooltip",
        inheritAttrs: false,
        props: {
          trigger: PropTypes.any.def(["hover"]),
          defaultVisible: {
            type: Boolean,
            default: void 0
          },
          visible: {
            type: Boolean,
            default: void 0
          },
          placement: PropTypes.string.def("right"),
          transitionName: String,
          animation: PropTypes.any,
          afterVisibleChange: PropTypes.func.def(() => {
          }),
          overlayStyle: {
            type: Object,
            default: void 0
          },
          overlayClassName: String,
          prefixCls: PropTypes.string.def("rc-tooltip"),
          mouseEnterDelay: PropTypes.number.def(0.1),
          mouseLeaveDelay: PropTypes.number.def(0.1),
          getPopupContainer: Function,
          destroyTooltipOnHide: {
            type: Boolean,
            default: false
          },
          align: PropTypes.object.def(() => ({})),
          arrowContent: PropTypes.any.def(null),
          tipId: String,
          builtinPlacements: PropTypes.object,
          overlayInnerStyle: {
            type: Object,
            default: void 0
          },
          popupVisible: {
            type: Boolean,
            default: void 0
          },
          onVisibleChange: Function,
          onPopupAlign: Function
        },
        setup(props, _ref) {
          let {
            slots,
            attrs,
            expose
          } = _ref;
          const triggerDOM = vue.shallowRef();
          const getPopupElement = () => {
            const {
              prefixCls,
              tipId,
              overlayInnerStyle
            } = props;
            return [vue.createVNode("div", {
              "class": `${prefixCls}-arrow`,
              "key": "arrow"
            }, [getPropsSlot(slots, props, "arrowContent")]), vue.createVNode(Content$1, {
              "key": "content",
              "prefixCls": prefixCls,
              "id": tipId,
              "overlayInnerStyle": overlayInnerStyle
            }, {
              overlay: slots.overlay
            })];
          };
          const getPopupDomNode = () => {
            return triggerDOM.value.getPopupDomNode();
          };
          expose({
            getPopupDomNode,
            triggerDOM,
            forcePopupAlign: () => {
              var _a2;
              return (_a2 = triggerDOM.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
            }
          });
          const destroyTooltip = vue.shallowRef(false);
          const autoDestroy = vue.shallowRef(false);
          vue.watchEffect(() => {
            const {
              destroyTooltipOnHide
            } = props;
            if (typeof destroyTooltipOnHide === "boolean") {
              destroyTooltip.value = destroyTooltipOnHide;
            } else if (destroyTooltipOnHide && typeof destroyTooltipOnHide === "object") {
              const {
                keepParent
              } = destroyTooltipOnHide;
              destroyTooltip.value = keepParent === true;
              autoDestroy.value = keepParent === false;
            }
          });
          return () => {
            const {
              overlayClassName,
              trigger,
              mouseEnterDelay,
              mouseLeaveDelay,
              overlayStyle,
              prefixCls,
              afterVisibleChange,
              transitionName,
              animation,
              placement,
              align,
              destroyTooltipOnHide,
              defaultVisible
            } = props, restProps = __rest$3(props, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible"]);
            const extraProps = _extends({}, restProps);
            if (props.visible !== void 0) {
              extraProps.popupVisible = props.visible;
            }
            const triggerProps2 = _extends(_extends(_extends({
              popupClassName: overlayClassName,
              prefixCls,
              action: trigger,
              builtinPlacements: placements,
              popupPlacement: placement,
              popupAlign: align,
              afterPopupVisibleChange: afterVisibleChange,
              popupTransitionName: transitionName,
              popupAnimation: animation,
              defaultPopupVisible: defaultVisible,
              destroyPopupOnHide: destroyTooltip.value,
              autoDestroy: autoDestroy.value,
              mouseLeaveDelay,
              popupStyle: overlayStyle,
              mouseEnterDelay
            }, extraProps), attrs), {
              onPopupVisibleChange: props.onVisibleChange || noop,
              onPopupAlign: props.onPopupAlign || noop,
              ref: triggerDOM,
              popup: getPopupElement()
            });
            return vue.createVNode(Trigger, triggerProps2, {
              default: slots.default
            });
          };
        }
      });
      const abstractTooltipProps = () => ({
        trigger: [String, Array],
        open: {
          type: Boolean,
          default: void 0
        },
        /** @deprecated Please use `open` instead. */
        visible: {
          type: Boolean,
          default: void 0
        },
        placement: String,
        color: String,
        transitionName: String,
        overlayStyle: objectType(),
        overlayInnerStyle: objectType(),
        overlayClassName: String,
        openClassName: String,
        prefixCls: String,
        mouseEnterDelay: Number,
        mouseLeaveDelay: Number,
        getPopupContainer: Function,
        arrowPointAtCenter: {
          type: Boolean,
          default: void 0
        },
        autoAdjustOverflow: {
          type: [Boolean, Object],
          default: void 0
        },
        destroyTooltipOnHide: {
          type: Boolean,
          default: void 0
        },
        align: objectType(),
        builtinPlacements: objectType(),
        children: Array,
        /** @deprecated Please use `onOpenChange` instead. */
        onVisibleChange: Function,
        /** @deprecated Please use `onUpdate:open` instead. */
        "onUpdate:visible": Function,
        onOpenChange: Function,
        "onUpdate:open": Function
      });
      const autoAdjustOverflowEnabled = {
        adjustX: 1,
        adjustY: 1
      };
      const autoAdjustOverflowDisabled = {
        adjustX: 0,
        adjustY: 0
      };
      const targetOffset = [0, 0];
      function getOverflowOptions(autoAdjustOverflow2) {
        if (typeof autoAdjustOverflow2 === "boolean") {
          return autoAdjustOverflow2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
        }
        return _extends(_extends({}, autoAdjustOverflowDisabled), autoAdjustOverflow2);
      }
      function getPlacements(config) {
        const {
          arrowWidth = 4,
          horizontalArrowShift = 16,
          verticalArrowShift = 8,
          autoAdjustOverflow: autoAdjustOverflow2,
          arrowPointAtCenter
        } = config;
        const placementMap = {
          left: {
            points: ["cr", "cl"],
            offset: [-4, 0]
          },
          right: {
            points: ["cl", "cr"],
            offset: [4, 0]
          },
          top: {
            points: ["bc", "tc"],
            offset: [0, -4]
          },
          bottom: {
            points: ["tc", "bc"],
            offset: [0, 4]
          },
          topLeft: {
            points: ["bl", "tc"],
            offset: [-(horizontalArrowShift + arrowWidth), -4]
          },
          leftTop: {
            points: ["tr", "cl"],
            offset: [-4, -(verticalArrowShift + arrowWidth)]
          },
          topRight: {
            points: ["br", "tc"],
            offset: [horizontalArrowShift + arrowWidth, -4]
          },
          rightTop: {
            points: ["tl", "cr"],
            offset: [4, -(verticalArrowShift + arrowWidth)]
          },
          bottomRight: {
            points: ["tr", "bc"],
            offset: [horizontalArrowShift + arrowWidth, 4]
          },
          rightBottom: {
            points: ["bl", "cr"],
            offset: [4, verticalArrowShift + arrowWidth]
          },
          bottomLeft: {
            points: ["tl", "bc"],
            offset: [-(horizontalArrowShift + arrowWidth), 4]
          },
          leftBottom: {
            points: ["br", "cl"],
            offset: [-4, verticalArrowShift + arrowWidth]
          }
        };
        Object.keys(placementMap).forEach((key) => {
          placementMap[key] = arrowPointAtCenter ? _extends(_extends({}, placementMap[key]), {
            overflow: getOverflowOptions(autoAdjustOverflow2),
            targetOffset
          }) : _extends(_extends({}, placements[key]), {
            overflow: getOverflowOptions(autoAdjustOverflow2)
          });
          placementMap[key].ignoreShake = true;
        });
        return placementMap;
      }
      function firstNotUndefined() {
        let arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        for (let i2 = 0, len = arr.length; i2 < len; i2++) {
          if (arr[i2] !== void 0) {
            return arr[i2];
          }
        }
        return void 0;
      }
      const inverseColors = PresetColors.map((color) => `${color}-inverse`);
      function isPresetColor(color) {
        let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        if (includeInverse) {
          return [...inverseColors, ...PresetColors].includes(color);
        }
        return PresetColors.includes(color);
      }
      function parseColor(prefixCls, color) {
        const isInternalColor = isPresetColor(color);
        const className = classNames({
          [`${prefixCls}-${color}`]: color && isInternalColor
        });
        const overlayStyle = {};
        const arrowStyle = {};
        if (color && !isInternalColor) {
          overlayStyle.background = color;
          arrowStyle["--antd-arrow-background-color"] = color;
        }
        return {
          className,
          overlayStyle,
          arrowStyle
        };
      }
      function connectArrowCls(classList) {
        let showArrowCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        return classList.map((cls) => `${showArrowCls}${cls}`).join(",");
      }
      const MAX_VERTICAL_CONTENT_RADIUS = 8;
      function getArrowOffset(options) {
        const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
        const {
          sizePopupArrow,
          contentRadius,
          borderRadiusOuter,
          limitVerticalRadius
        } = options;
        const arrowInnerOffset = sizePopupArrow / 2 - Math.ceil(borderRadiusOuter * (Math.sqrt(2) - 1));
        const dropdownArrowOffset = (contentRadius > 12 ? contentRadius + 2 : 12) - arrowInnerOffset;
        const dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius - arrowInnerOffset : dropdownArrowOffset;
        return {
          dropdownArrowOffset,
          dropdownArrowOffsetVertical
        };
      }
      function getArrowStyle(token2, options) {
        const {
          componentCls,
          sizePopupArrow,
          marginXXS,
          borderRadiusXS,
          borderRadiusOuter,
          boxShadowPopoverArrow
        } = token2;
        const {
          colorBg,
          showArrowCls,
          contentRadius = token2.borderRadiusLG,
          limitVerticalRadius
        } = options;
        const {
          dropdownArrowOffsetVertical,
          dropdownArrowOffset
        } = getArrowOffset({
          sizePopupArrow,
          contentRadius,
          borderRadiusOuter,
          limitVerticalRadius
        });
        const dropdownArrowDistance = sizePopupArrow / 2 + marginXXS;
        return {
          [componentCls]: {
            // ============================ Basic ============================
            [`${componentCls}-arrow`]: [_extends(_extends({
              position: "absolute",
              zIndex: 1,
              display: "block"
            }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
              "&:before": {
                background: colorBg
              }
            })],
            // ========================== Placement ==========================
            // Here handle the arrow position and rotate stuff
            // >>>>> Top
            [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
              bottom: 0,
              transform: "translateY(100%) rotate(180deg)"
            },
            [`&-placement-top ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: "50%"
              },
              transform: "translateX(-50%) translateY(100%) rotate(180deg)"
            },
            [`&-placement-topLeft ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: dropdownArrowOffset
              }
            },
            [`&-placement-topRight ${componentCls}-arrow`]: {
              right: {
                _skip_check_: true,
                value: dropdownArrowOffset
              }
            },
            // >>>>> Bottom
            [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
              top: 0,
              transform: `translateY(-100%)`
            },
            [`&-placement-bottom ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: "50%"
              },
              transform: `translateX(-50%) translateY(-100%)`
            },
            [`&-placement-bottomLeft ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: dropdownArrowOffset
              }
            },
            [`&-placement-bottomRight ${componentCls}-arrow`]: {
              right: {
                _skip_check_: true,
                value: dropdownArrowOffset
              }
            },
            // >>>>> Left
            [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
              right: {
                _skip_check_: true,
                value: 0
              },
              transform: "translateX(100%) rotate(90deg)"
            },
            [`&-placement-left ${componentCls}-arrow`]: {
              top: {
                _skip_check_: true,
                value: "50%"
              },
              transform: "translateY(-50%) translateX(100%) rotate(90deg)"
            },
            [`&-placement-leftTop ${componentCls}-arrow`]: {
              top: dropdownArrowOffsetVertical
            },
            [`&-placement-leftBottom ${componentCls}-arrow`]: {
              bottom: dropdownArrowOffsetVertical
            },
            // >>>>> Right
            [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
              left: {
                _skip_check_: true,
                value: 0
              },
              transform: "translateX(-100%) rotate(-90deg)"
            },
            [`&-placement-right ${componentCls}-arrow`]: {
              top: {
                _skip_check_: true,
                value: "50%"
              },
              transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
            },
            [`&-placement-rightTop ${componentCls}-arrow`]: {
              top: dropdownArrowOffsetVertical
            },
            [`&-placement-rightBottom ${componentCls}-arrow`]: {
              bottom: dropdownArrowOffsetVertical
            },
            // =========================== Offset ============================
            // Offset the popover to account for the dropdown arrow
            // >>>>> Top
            [connectArrowCls([`&-placement-topLeft`, `&-placement-top`, `&-placement-topRight`], showArrowCls)]: {
              paddingBottom: dropdownArrowDistance
            },
            // >>>>> Bottom
            [connectArrowCls([`&-placement-bottomLeft`, `&-placement-bottom`, `&-placement-bottomRight`], showArrowCls)]: {
              paddingTop: dropdownArrowDistance
            },
            // >>>>> Left
            [connectArrowCls([`&-placement-leftTop`, `&-placement-left`, `&-placement-leftBottom`], showArrowCls)]: {
              paddingRight: {
                _skip_check_: true,
                value: dropdownArrowDistance
              }
            },
            // >>>>> Right
            [connectArrowCls([`&-placement-rightTop`, `&-placement-right`, `&-placement-rightBottom`], showArrowCls)]: {
              paddingLeft: {
                _skip_check_: true,
                value: dropdownArrowDistance
              }
            }
          }
        };
      }
      const genTooltipStyle = (token2) => {
        const {
          componentCls,
          // ant-tooltip
          tooltipMaxWidth,
          tooltipColor,
          tooltipBg,
          tooltipBorderRadius,
          zIndexPopup,
          controlHeight,
          boxShadowSecondary,
          paddingSM,
          paddingXS,
          tooltipRadiusOuter
        } = token2;
        return [
          {
            [componentCls]: _extends(_extends(_extends(_extends({}, resetComponent(token2)), {
              position: "absolute",
              zIndex: zIndexPopup,
              display: "block",
              "&": [{
                width: "max-content"
              }, {
                width: "intrinsic"
              }],
              maxWidth: tooltipMaxWidth,
              visibility: "visible",
              "&-hidden": {
                display: "none"
              },
              "--antd-arrow-background-color": tooltipBg,
              // Wrapper for the tooltip content
              [`${componentCls}-inner`]: {
                minWidth: controlHeight,
                minHeight: controlHeight,
                padding: `${paddingSM / 2}px ${paddingXS}px`,
                color: tooltipColor,
                textAlign: "start",
                textDecoration: "none",
                wordWrap: "break-word",
                backgroundColor: tooltipBg,
                borderRadius: tooltipBorderRadius,
                boxShadow: boxShadowSecondary
              },
              // Limit left and right placement radius
              [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
                [`${componentCls}-inner`]: {
                  borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
                }
              },
              [`${componentCls}-content`]: {
                position: "relative"
              }
            }), genPresetColor(token2, (colorKey, _ref) => {
              let {
                darkColor
              } = _ref;
              return {
                [`&${componentCls}-${colorKey}`]: {
                  [`${componentCls}-inner`]: {
                    backgroundColor: darkColor
                  },
                  [`${componentCls}-arrow`]: {
                    "--antd-arrow-background-color": darkColor
                  }
                }
              };
            })), {
              // RTL
              "&-rtl": {
                direction: "rtl"
              }
            })
          },
          // Arrow Style
          getArrowStyle(merge(token2, {
            borderRadiusOuter: tooltipRadiusOuter
          }), {
            colorBg: "var(--antd-arrow-background-color)",
            showArrowCls: "",
            contentRadius: tooltipBorderRadius,
            limitVerticalRadius: true
          }),
          // Pure Render
          {
            [`${componentCls}-pure`]: {
              position: "relative",
              maxWidth: "none"
            }
          }
        ];
      };
      const useStyle$2 = (prefixCls, injectStyle) => {
        const useOriginHook = genComponentStyleHook("Tooltip", (token2) => {
          if ((injectStyle === null || injectStyle === void 0 ? void 0 : injectStyle.value) === false) {
            return [];
          }
          const {
            borderRadius,
            colorTextLightSolid,
            colorBgDefault,
            borderRadiusOuter
          } = token2;
          const TooltipToken = merge(token2, {
            // default variables
            tooltipMaxWidth: 250,
            tooltipColor: colorTextLightSolid,
            tooltipBorderRadius: borderRadius,
            tooltipBg: colorBgDefault,
            tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
          });
          return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
        }, (_ref2) => {
          let {
            zIndexPopupBase,
            colorBgSpotlight
          } = _ref2;
          return {
            zIndexPopup: zIndexPopupBase + 70,
            colorBgDefault: colorBgSpotlight
          };
        });
        return useOriginHook(prefixCls);
      };
      const splitObject = (obj, keys2) => {
        const picked = {};
        const omitted = _extends({}, obj);
        keys2.forEach((key) => {
          if (obj && key in obj) {
            picked[key] = obj[key];
            delete omitted[key];
          }
        });
        return {
          picked,
          omitted
        };
      };
      const tooltipProps = () => _extends(_extends({}, abstractTooltipProps()), {
        title: PropTypes.any
      });
      const ToolTip = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "ATooltip",
        inheritAttrs: false,
        props: initDefaultProps(tooltipProps(), {
          trigger: "hover",
          align: {},
          placement: "top",
          mouseEnterDelay: 0.1,
          mouseLeaveDelay: 0.1,
          arrowPointAtCenter: false,
          autoAdjustOverflow: true
        }),
        slots: Object,
        // emits: ['update:visible', 'visibleChange'],
        setup(props, _ref) {
          let {
            slots,
            emit,
            attrs,
            expose
          } = _ref;
          const {
            prefixCls,
            getPopupContainer,
            direction,
            rootPrefixCls
          } = useConfigInject("tooltip", props);
          const mergedOpen = vue.computed(() => {
            var _a2;
            return (_a2 = props.open) !== null && _a2 !== void 0 ? _a2 : props.visible;
          });
          const innerOpen = vue.ref(firstNotUndefined([props.open, props.visible]));
          const tooltip = vue.ref();
          let rafId;
          vue.watch(mergedOpen, (val) => {
            wrapperRaf.cancel(rafId);
            rafId = wrapperRaf(() => {
              innerOpen.value = !!val;
            });
          });
          const isNoTitle = () => {
            var _a2;
            const title = (_a2 = props.title) !== null && _a2 !== void 0 ? _a2 : slots.title;
            return !title && title !== 0;
          };
          const handleVisibleChange = (val) => {
            const noTitle = isNoTitle();
            if (mergedOpen.value === void 0) {
              innerOpen.value = noTitle ? false : val;
            }
            if (!noTitle) {
              emit("update:visible", val);
              emit("visibleChange", val);
              emit("update:open", val);
              emit("openChange", val);
            }
          };
          const getPopupDomNode = () => {
            return tooltip.value.getPopupDomNode();
          };
          expose({
            getPopupDomNode,
            open: innerOpen,
            forcePopupAlign: () => {
              var _a2;
              return (_a2 = tooltip.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
            }
          });
          const tooltipPlacements = vue.computed(() => {
            const {
              builtinPlacements,
              arrowPointAtCenter,
              autoAdjustOverflow: autoAdjustOverflow2
            } = props;
            return builtinPlacements || getPlacements({
              arrowPointAtCenter,
              autoAdjustOverflow: autoAdjustOverflow2
            });
          });
          const isTrueProps = (val) => {
            return val || val === "";
          };
          const getDisabledCompatibleChildren = (ele) => {
            const elementType = ele.type;
            if (typeof elementType === "object" && ele.props) {
              if ((elementType.__ANT_BUTTON === true || elementType === "button") && isTrueProps(ele.props.disabled) || elementType.__ANT_SWITCH === true && (isTrueProps(ele.props.disabled) || isTrueProps(ele.props.loading)) || elementType.__ANT_RADIO === true && isTrueProps(ele.props.disabled)) {
                const {
                  picked,
                  omitted
                } = splitObject(getStyle(ele), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]);
                const spanStyle = _extends(_extends({
                  display: "inline-block"
                }, picked), {
                  cursor: "not-allowed",
                  lineHeight: 1,
                  width: ele.props && ele.props.block ? "100%" : void 0
                });
                const buttonStyle = _extends(_extends({}, omitted), {
                  pointerEvents: "none"
                });
                const child = cloneElement(ele, {
                  style: buttonStyle
                }, true);
                return vue.createVNode("span", {
                  "style": spanStyle,
                  "class": `${prefixCls.value}-disabled-compatible-wrapper`
                }, [child]);
              }
            }
            return ele;
          };
          const getOverlay = () => {
            var _a2, _b;
            return (_a2 = props.title) !== null && _a2 !== void 0 ? _a2 : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
          };
          const onPopupAlign = (domNode, align) => {
            const placements2 = tooltipPlacements.value;
            const placement = Object.keys(placements2).find((key) => {
              var _a2, _b;
              return placements2[key].points[0] === ((_a2 = align.points) === null || _a2 === void 0 ? void 0 : _a2[0]) && placements2[key].points[1] === ((_b = align.points) === null || _b === void 0 ? void 0 : _b[1]);
            });
            if (placement) {
              const rect = domNode.getBoundingClientRect();
              const transformOrigin = {
                top: "50%",
                left: "50%"
              };
              if (placement.indexOf("top") >= 0 || placement.indexOf("Bottom") >= 0) {
                transformOrigin.top = `${rect.height - align.offset[1]}px`;
              } else if (placement.indexOf("Top") >= 0 || placement.indexOf("bottom") >= 0) {
                transformOrigin.top = `${-align.offset[1]}px`;
              }
              if (placement.indexOf("left") >= 0 || placement.indexOf("Right") >= 0) {
                transformOrigin.left = `${rect.width - align.offset[0]}px`;
              } else if (placement.indexOf("right") >= 0 || placement.indexOf("Left") >= 0) {
                transformOrigin.left = `${-align.offset[0]}px`;
              }
              domNode.style.transformOrigin = `${transformOrigin.left} ${transformOrigin.top}`;
            }
          };
          const colorInfo = vue.computed(() => parseColor(prefixCls.value, props.color));
          const injectFromPopover = vue.computed(() => attrs["data-popover-inject"]);
          const [wrapSSR, hashId] = useStyle$2(prefixCls, vue.computed(() => !injectFromPopover.value));
          return () => {
            var _a2, _b;
            const {
              openClassName,
              overlayClassName,
              overlayStyle,
              overlayInnerStyle
            } = props;
            let children = (_b = filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))) !== null && _b !== void 0 ? _b : null;
            children = children.length === 1 ? children[0] : children;
            let tempVisible = innerOpen.value;
            if (mergedOpen.value === void 0 && isNoTitle()) {
              tempVisible = false;
            }
            if (!children) {
              return null;
            }
            const child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : vue.createVNode("span", null, [children]));
            const childCls = classNames({
              [openClassName || `${prefixCls.value}-open`]: true,
              [child.props && child.props.class]: child.props && child.props.class
            });
            const customOverlayClassName = classNames(overlayClassName, {
              [`${prefixCls.value}-rtl`]: direction.value === "rtl"
            }, colorInfo.value.className, hashId.value);
            const formattedOverlayInnerStyle = _extends(_extends({}, colorInfo.value.overlayStyle), overlayInnerStyle);
            const arrowContentStyle = colorInfo.value.arrowStyle;
            const vcTooltipProps = _extends(_extends(_extends({}, attrs), props), {
              prefixCls: prefixCls.value,
              getPopupContainer: getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
              builtinPlacements: tooltipPlacements.value,
              visible: tempVisible,
              ref: tooltip,
              overlayClassName: customOverlayClassName,
              overlayStyle: _extends(_extends({}, arrowContentStyle), overlayStyle),
              overlayInnerStyle: formattedOverlayInnerStyle,
              onVisibleChange: handleVisibleChange,
              onPopupAlign,
              transitionName: getTransitionName(rootPrefixCls.value, "zoom-big-fast", props.transitionName)
            });
            return wrapSSR(vue.createVNode(Tooltip$1, vcTooltipProps, {
              default: () => [innerOpen.value ? cloneElement(child, {
                class: childCls
              }) : child],
              arrowContent: () => vue.createVNode("span", {
                "class": `${prefixCls.value}-arrow-content`
              }, null),
              overlay: getOverlay
            }));
          };
        }
      });
      const Tooltip = withInstall(ToolTip);
      function UnitNumber(_ref) {
        let {
          prefixCls,
          value,
          current,
          offset = 0
        } = _ref;
        let style;
        if (offset) {
          style = {
            position: "absolute",
            top: `${offset}00%`,
            left: 0
          };
        }
        return vue.createVNode("p", {
          "style": style,
          "class": classNames(`${prefixCls}-only-unit`, {
            current
          })
        }, [value]);
      }
      function getOffset$1(start, end, unit) {
        let index2 = start;
        let offset = 0;
        while ((index2 + 10) % 10 !== end) {
          index2 += unit;
          offset += unit;
        }
        return offset;
      }
      const SingleNumber = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "SingleNumber",
        props: {
          prefixCls: String,
          value: String,
          count: Number
        },
        setup(props) {
          const originValue = vue.computed(() => Number(props.value));
          const originCount = vue.computed(() => Math.abs(props.count));
          const state = vue.reactive({
            prevValue: originValue.value,
            prevCount: originCount.value
          });
          const onTransitionEnd = () => {
            state.prevValue = originValue.value;
            state.prevCount = originCount.value;
          };
          const timeout = vue.ref();
          vue.watch(originValue, () => {
            clearTimeout(timeout.value);
            timeout.value = setTimeout(() => {
              onTransitionEnd();
            }, 1e3);
          }, {
            flush: "post"
          });
          vue.onUnmounted(() => {
            clearTimeout(timeout.value);
          });
          return () => {
            let unitNodes;
            let offsetStyle = {};
            const value = originValue.value;
            if (state.prevValue === value || Number.isNaN(value) || Number.isNaN(state.prevValue)) {
              unitNodes = [UnitNumber(_extends(_extends({}, props), {
                current: true
              }))];
              offsetStyle = {
                transition: "none"
              };
            } else {
              unitNodes = [];
              const end = value + 10;
              const unitNumberList = [];
              for (let index2 = value; index2 <= end; index2 += 1) {
                unitNumberList.push(index2);
              }
              const prevIndex = unitNumberList.findIndex((n2) => n2 % 10 === state.prevValue);
              unitNodes = unitNumberList.map((n2, index2) => {
                const singleUnit = n2 % 10;
                return UnitNumber(_extends(_extends({}, props), {
                  value: singleUnit,
                  offset: index2 - prevIndex,
                  current: index2 === prevIndex
                }));
              });
              const unit = state.prevCount < originCount.value ? 1 : -1;
              offsetStyle = {
                transform: `translateY(${-getOffset$1(state.prevValue, value, unit)}00%)`
              };
            }
            return vue.createVNode("span", {
              "class": `${props.prefixCls}-only`,
              "style": offsetStyle,
              "onTransitionend": () => onTransitionEnd()
            }, [unitNodes]);
          };
        }
      });
      var __rest$2 = function(s2, e2) {
        var t2 = {};
        for (var p in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
            t2[p] = s2[p];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
              t2[p[i2]] = s2[p[i2]];
          }
        return t2;
      };
      const scrollNumberProps = {
        prefixCls: String,
        count: PropTypes.any,
        component: String,
        title: PropTypes.any,
        show: Boolean
      };
      const ScrollNumber = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "ScrollNumber",
        inheritAttrs: false,
        props: scrollNumberProps,
        setup(props, _ref) {
          let {
            attrs,
            slots
          } = _ref;
          const {
            prefixCls
          } = useConfigInject("scroll-number", props);
          return () => {
            var _a2;
            const _b = _extends(_extends({}, props), attrs), {
              prefixCls: customizePrefixCls,
              count,
              title,
              show,
              component: Tag2 = "sup",
              class: className,
              style
            } = _b, restProps = __rest$2(_b, ["prefixCls", "count", "title", "show", "component", "class", "style"]);
            const newProps = _extends(_extends({}, restProps), {
              style,
              "data-show": props.show,
              class: classNames(prefixCls.value, className),
              title
            });
            let numberNodes = count;
            if (count && Number(count) % 1 === 0) {
              const numberList = String(count).split("");
              numberNodes = numberList.map((num, i2) => vue.createVNode(SingleNumber, {
                "prefixCls": prefixCls.value,
                "count": Number(count),
                "value": num,
                "key": numberList.length - i2
              }, null));
            }
            if (style && style.borderColor) {
              newProps.style = _extends(_extends({}, style), {
                boxShadow: `0 0 0 1px ${style.borderColor} inset`
              });
            }
            const children = filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
            if (children && children.length) {
              return cloneElement(children, {
                class: classNames(`${prefixCls.value}-custom-component`)
              }, false);
            }
            return vue.createVNode(Tag2, newProps, {
              default: () => [numberNodes]
            });
          };
        }
      });
      const antStatusProcessing = new Keyframe("antStatusProcessing", {
        "0%": {
          transform: "scale(0.8)",
          opacity: 0.5
        },
        "100%": {
          transform: "scale(2.4)",
          opacity: 0
        }
      });
      const antZoomBadgeIn = new Keyframe("antZoomBadgeIn", {
        "0%": {
          transform: "scale(0) translate(50%, -50%)",
          opacity: 0
        },
        "100%": {
          transform: "scale(1) translate(50%, -50%)"
        }
      });
      const antZoomBadgeOut = new Keyframe("antZoomBadgeOut", {
        "0%": {
          transform: "scale(1) translate(50%, -50%)"
        },
        "100%": {
          transform: "scale(0) translate(50%, -50%)",
          opacity: 0
        }
      });
      const antNoWrapperZoomBadgeIn = new Keyframe("antNoWrapperZoomBadgeIn", {
        "0%": {
          transform: "scale(0)",
          opacity: 0
        },
        "100%": {
          transform: "scale(1)"
        }
      });
      const antNoWrapperZoomBadgeOut = new Keyframe("antNoWrapperZoomBadgeOut", {
        "0%": {
          transform: "scale(1)"
        },
        "100%": {
          transform: "scale(0)",
          opacity: 0
        }
      });
      const antBadgeLoadingCircle = new Keyframe("antBadgeLoadingCircle", {
        "0%": {
          transformOrigin: "50%"
        },
        "100%": {
          transform: "translate(50%, -50%) rotate(360deg)",
          transformOrigin: "50%"
        }
      });
      const genSharedBadgeStyle = (token2) => {
        const {
          componentCls,
          iconCls,
          antCls,
          badgeFontHeight,
          badgeShadowSize,
          badgeHeightSm,
          motionDurationSlow,
          badgeStatusSize,
          marginXS,
          badgeRibbonOffset
        } = token2;
        const numberPrefixCls = `${antCls}-scroll-number`;
        const ribbonPrefixCls = `${antCls}-ribbon`;
        const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
        const colorPreset = genPresetColor(token2, (colorKey, _ref) => {
          let {
            darkColor
          } = _ref;
          return {
            [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
              background: darkColor,
              [`&:not(${componentCls}-count)`]: {
                color: darkColor
              }
            }
          };
        });
        const statusRibbonPreset = genPresetColor(token2, (colorKey, _ref2) => {
          let {
            darkColor
          } = _ref2;
          return {
            [`&${ribbonPrefixCls}-color-${colorKey}`]: {
              background: darkColor,
              color: darkColor
            }
          };
        });
        return {
          [componentCls]: _extends(_extends(_extends(_extends({}, resetComponent(token2)), {
            position: "relative",
            display: "inline-block",
            width: "fit-content",
            lineHeight: 1,
            [`${componentCls}-count`]: {
              zIndex: token2.badgeZIndex,
              minWidth: token2.badgeHeight,
              height: token2.badgeHeight,
              color: token2.badgeTextColor,
              fontWeight: token2.badgeFontWeight,
              fontSize: token2.badgeFontSize,
              lineHeight: `${token2.badgeHeight}px`,
              whiteSpace: "nowrap",
              textAlign: "center",
              background: token2.badgeColor,
              borderRadius: token2.badgeHeight / 2,
              boxShadow: `0 0 0 ${badgeShadowSize}px ${token2.badgeShadowColor}`,
              transition: `background ${token2.motionDurationMid}`,
              a: {
                color: token2.badgeTextColor
              },
              "a:hover": {
                color: token2.badgeTextColor
              },
              "a:hover &": {
                background: token2.badgeColorHover
              }
            },
            [`${componentCls}-count-sm`]: {
              minWidth: badgeHeightSm,
              height: badgeHeightSm,
              fontSize: token2.badgeFontSizeSm,
              lineHeight: `${badgeHeightSm}px`,
              borderRadius: badgeHeightSm / 2
            },
            [`${componentCls}-multiple-words`]: {
              padding: `0 ${token2.paddingXS}px`
            },
            [`${componentCls}-dot`]: {
              zIndex: token2.badgeZIndex,
              width: token2.badgeDotSize,
              minWidth: token2.badgeDotSize,
              height: token2.badgeDotSize,
              background: token2.badgeColor,
              borderRadius: "100%",
              boxShadow: `0 0 0 ${badgeShadowSize}px ${token2.badgeShadowColor}`
            },
            [`${componentCls}-dot${numberPrefixCls}`]: {
              transition: `background ${motionDurationSlow}`
            },
            [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              transform: "translate(50%, -50%)",
              transformOrigin: "100% 0%",
              [`&${iconCls}-spin`]: {
                animationName: antBadgeLoadingCircle,
                animationDuration: "1s",
                animationIterationCount: "infinite",
                animationTimingFunction: "linear"
              }
            },
            [`&${componentCls}-status`]: {
              lineHeight: "inherit",
              verticalAlign: "baseline",
              [`${componentCls}-status-dot`]: {
                position: "relative",
                top: -1,
                display: "inline-block",
                width: badgeStatusSize,
                height: badgeStatusSize,
                verticalAlign: "middle",
                borderRadius: "50%"
              },
              [`${componentCls}-status-success`]: {
                backgroundColor: token2.colorSuccess
              },
              [`${componentCls}-status-processing`]: {
                overflow: "visible",
                color: token2.colorPrimary,
                backgroundColor: token2.colorPrimary,
                "&::after": {
                  position: "absolute",
                  top: 0,
                  insetInlineStart: 0,
                  width: "100%",
                  height: "100%",
                  borderWidth: badgeShadowSize,
                  borderStyle: "solid",
                  borderColor: "inherit",
                  borderRadius: "50%",
                  animationName: antStatusProcessing,
                  animationDuration: token2.badgeProcessingDuration,
                  animationIterationCount: "infinite",
                  animationTimingFunction: "ease-in-out",
                  content: '""'
                }
              },
              [`${componentCls}-status-default`]: {
                backgroundColor: token2.colorTextPlaceholder
              },
              [`${componentCls}-status-error`]: {
                backgroundColor: token2.colorError
              },
              [`${componentCls}-status-warning`]: {
                backgroundColor: token2.colorWarning
              },
              [`${componentCls}-status-text`]: {
                marginInlineStart: marginXS,
                color: token2.colorText,
                fontSize: token2.fontSize
              }
            }
          }), colorPreset), {
            [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
              animationName: antZoomBadgeIn,
              animationDuration: token2.motionDurationSlow,
              animationTimingFunction: token2.motionEaseOutBack,
              animationFillMode: "both"
            },
            [`${componentCls}-zoom-leave`]: {
              animationName: antZoomBadgeOut,
              animationDuration: token2.motionDurationSlow,
              animationTimingFunction: token2.motionEaseOutBack,
              animationFillMode: "both"
            },
            [`&${componentCls}-not-a-wrapper`]: {
              [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
                animationName: antNoWrapperZoomBadgeIn,
                animationDuration: token2.motionDurationSlow,
                animationTimingFunction: token2.motionEaseOutBack
              },
              [`${componentCls}-zoom-leave`]: {
                animationName: antNoWrapperZoomBadgeOut,
                animationDuration: token2.motionDurationSlow,
                animationTimingFunction: token2.motionEaseOutBack
              },
              [`&:not(${componentCls}-status)`]: {
                verticalAlign: "middle"
              },
              [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
                transform: "none"
              },
              [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
                position: "relative",
                top: "auto",
                display: "block",
                transformOrigin: "50% 50%"
              }
            },
            [`${numberPrefixCls}`]: {
              overflow: "hidden",
              [`${numberPrefixCls}-only`]: {
                position: "relative",
                display: "inline-block",
                height: token2.badgeHeight,
                transition: `all ${token2.motionDurationSlow} ${token2.motionEaseOutBack}`,
                WebkitTransformStyle: "preserve-3d",
                WebkitBackfaceVisibility: "hidden",
                [`> p${numberPrefixCls}-only-unit`]: {
                  height: token2.badgeHeight,
                  margin: 0,
                  WebkitTransformStyle: "preserve-3d",
                  WebkitBackfaceVisibility: "hidden"
                }
              },
              [`${numberPrefixCls}-symbol`]: {
                verticalAlign: "top"
              }
            },
            // ====================== RTL =======================
            "&-rtl": {
              direction: "rtl",
              [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
                transform: "translate(-50%, -50%)"
              }
            }
          }),
          [`${ribbonWrapperPrefixCls}`]: {
            position: "relative"
          },
          [`${ribbonPrefixCls}`]: _extends(_extends(_extends(_extends({}, resetComponent(token2)), {
            position: "absolute",
            top: marginXS,
            padding: `0 ${token2.paddingXS}px`,
            color: token2.colorPrimary,
            lineHeight: `${badgeFontHeight}px`,
            whiteSpace: "nowrap",
            backgroundColor: token2.colorPrimary,
            borderRadius: token2.borderRadiusSM,
            [`${ribbonPrefixCls}-text`]: {
              color: token2.colorTextLightSolid
            },
            [`${ribbonPrefixCls}-corner`]: {
              position: "absolute",
              top: "100%",
              width: badgeRibbonOffset,
              height: badgeRibbonOffset,
              color: "currentcolor",
              border: `${badgeRibbonOffset / 2}px solid`,
              transform: token2.badgeRibbonCornerTransform,
              transformOrigin: "top",
              filter: token2.badgeRibbonCornerFilter
            }
          }), statusRibbonPreset), {
            [`&${ribbonPrefixCls}-placement-end`]: {
              insetInlineEnd: -badgeRibbonOffset,
              borderEndEndRadius: 0,
              [`${ribbonPrefixCls}-corner`]: {
                insetInlineEnd: 0,
                borderInlineEndColor: "transparent",
                borderBlockEndColor: "transparent"
              }
            },
            [`&${ribbonPrefixCls}-placement-start`]: {
              insetInlineStart: -badgeRibbonOffset,
              borderEndStartRadius: 0,
              [`${ribbonPrefixCls}-corner`]: {
                insetInlineStart: 0,
                borderBlockEndColor: "transparent",
                borderInlineStartColor: "transparent"
              }
            },
            // ====================== RTL =======================
            "&-rtl": {
              direction: "rtl"
            }
          })
        };
      };
      const useStyle$1 = genComponentStyleHook("Badge", (token2) => {
        const {
          fontSize,
          lineHeight,
          fontSizeSM,
          lineWidth,
          marginXS,
          colorBorderBg
        } = token2;
        const badgeFontHeight = Math.round(fontSize * lineHeight);
        const badgeShadowSize = lineWidth;
        const badgeZIndex = "auto";
        const badgeHeight = badgeFontHeight - 2 * badgeShadowSize;
        const badgeTextColor = token2.colorBgContainer;
        const badgeFontWeight = "normal";
        const badgeFontSize = fontSizeSM;
        const badgeColor = token2.colorError;
        const badgeColorHover = token2.colorErrorHover;
        const badgeHeightSm = fontSize;
        const badgeDotSize = fontSizeSM / 2;
        const badgeFontSizeSm = fontSizeSM;
        const badgeStatusSize = fontSizeSM / 2;
        const badgeToken = merge(token2, {
          badgeFontHeight,
          badgeShadowSize,
          badgeZIndex,
          badgeHeight,
          badgeTextColor,
          badgeFontWeight,
          badgeFontSize,
          badgeColor,
          badgeColorHover,
          badgeShadowColor: colorBorderBg,
          badgeHeightSm,
          badgeDotSize,
          badgeFontSizeSm,
          badgeStatusSize,
          badgeProcessingDuration: "1.2s",
          badgeRibbonOffset: marginXS,
          // Follow token just by Design. Not related with token
          badgeRibbonCornerTransform: "scaleY(0.75)",
          badgeRibbonCornerFilter: `brightness(75%)`
        });
        return [genSharedBadgeStyle(badgeToken)];
      });
      var __rest$1 = function(s2, e2) {
        var t2 = {};
        for (var p in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
            t2[p] = s2[p];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
              t2[p[i2]] = s2[p[i2]];
          }
        return t2;
      };
      const ribbonProps = () => ({
        prefix: String,
        color: {
          type: String
        },
        text: PropTypes.any,
        placement: {
          type: String,
          default: "end"
        }
      });
      const Ribbon = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "ABadgeRibbon",
        inheritAttrs: false,
        props: ribbonProps(),
        slots: Object,
        setup(props, _ref) {
          let {
            attrs,
            slots
          } = _ref;
          const {
            prefixCls,
            direction
          } = useConfigInject("ribbon", props);
          const [wrapSSR, hashId] = useStyle$1(prefixCls);
          const colorInPreset = vue.computed(() => isPresetColor(props.color, false));
          const ribbonCls = vue.computed(() => [prefixCls.value, `${prefixCls.value}-placement-${props.placement}`, {
            [`${prefixCls.value}-rtl`]: direction.value === "rtl",
            [`${prefixCls.value}-color-${props.color}`]: colorInPreset.value
          }]);
          return () => {
            var _a2, _b;
            const {
              class: className,
              style
            } = attrs, restAttrs = __rest$1(attrs, ["class", "style"]);
            const colorStyle = {};
            const cornerColorStyle = {};
            if (props.color && !colorInPreset.value) {
              colorStyle.background = props.color;
              cornerColorStyle.color = props.color;
            }
            return wrapSSR(vue.createVNode("div", _objectSpread2$1({
              "class": `${prefixCls.value}-wrapper ${hashId.value}`
            }, restAttrs), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots), vue.createVNode("div", {
              "class": [ribbonCls.value, className, hashId.value],
              "style": _extends(_extends({}, colorStyle), style)
            }, [vue.createVNode("span", {
              "class": `${prefixCls.value}-text`
            }, [props.text || ((_b = slots.text) === null || _b === void 0 ? void 0 : _b.call(slots))]), vue.createVNode("div", {
              "class": `${prefixCls.value}-corner`,
              "style": cornerColorStyle
            }, null)])]));
          };
        }
      });
      const isNumeric = (value) => {
        return !isNaN(parseFloat(value)) && isFinite(value);
      };
      const badgeProps = () => ({
        /** Number to show in badge */
        count: PropTypes.any.def(null),
        showZero: {
          type: Boolean,
          default: void 0
        },
        /** Max count to show */
        overflowCount: {
          type: Number,
          default: 99
        },
        /** whether to show red dot without number */
        dot: {
          type: Boolean,
          default: void 0
        },
        prefixCls: String,
        scrollNumberPrefixCls: String,
        status: {
          type: String
        },
        size: {
          type: String,
          default: "default"
        },
        color: String,
        text: PropTypes.any,
        offset: Array,
        numberStyle: {
          type: Object,
          default: void 0
        },
        title: String
      });
      const Badge = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "ABadge",
        Ribbon,
        inheritAttrs: false,
        props: badgeProps(),
        slots: Object,
        setup(props, _ref) {
          let {
            slots,
            attrs
          } = _ref;
          const {
            prefixCls,
            direction
          } = useConfigInject("badge", props);
          const [wrapSSR, hashId] = useStyle$1(prefixCls);
          const numberedDisplayCount = vue.computed(() => {
            return props.count > props.overflowCount ? `${props.overflowCount}+` : props.count;
          });
          const isZero = vue.computed(() => numberedDisplayCount.value === "0" || numberedDisplayCount.value === 0);
          const ignoreCount = vue.computed(() => props.count === null || isZero.value && !props.showZero);
          const hasStatus = vue.computed(() => (props.status !== null && props.status !== void 0 || props.color !== null && props.color !== void 0) && ignoreCount.value);
          const showAsDot = vue.computed(() => props.dot && !isZero.value);
          const mergedCount = vue.computed(() => showAsDot.value ? "" : numberedDisplayCount.value);
          const isHidden2 = vue.computed(() => {
            const isEmpty = mergedCount.value === null || mergedCount.value === void 0 || mergedCount.value === "";
            return (isEmpty || isZero.value && !props.showZero) && !showAsDot.value;
          });
          const livingCount = vue.ref(props.count);
          const displayCount = vue.ref(mergedCount.value);
          const isDotRef = vue.ref(showAsDot.value);
          vue.watch([() => props.count, mergedCount, showAsDot], () => {
            if (!isHidden2.value) {
              livingCount.value = props.count;
              displayCount.value = mergedCount.value;
              isDotRef.value = showAsDot.value;
            }
          }, {
            immediate: true
          });
          const isInternalColor = vue.computed(() => isPresetColor(props.color, false));
          const statusCls = vue.computed(() => ({
            [`${prefixCls.value}-status-dot`]: hasStatus.value,
            [`${prefixCls.value}-status-${props.status}`]: !!props.status,
            [`${prefixCls.value}-color-${props.color}`]: isInternalColor.value
          }));
          const statusStyle = vue.computed(() => {
            if (props.color && !isInternalColor.value) {
              return {
                background: props.color,
                color: props.color
              };
            } else {
              return {};
            }
          });
          const scrollNumberCls = vue.computed(() => ({
            [`${prefixCls.value}-dot`]: isDotRef.value,
            [`${prefixCls.value}-count`]: !isDotRef.value,
            [`${prefixCls.value}-count-sm`]: props.size === "small",
            [`${prefixCls.value}-multiple-words`]: !isDotRef.value && displayCount.value && displayCount.value.toString().length > 1,
            [`${prefixCls.value}-status-${props.status}`]: !!props.status,
            [`${prefixCls.value}-color-${props.color}`]: isInternalColor.value
          }));
          return () => {
            var _a2, _b;
            const {
              offset,
              title,
              color
            } = props;
            const style = attrs.style;
            const text = getPropsSlot(slots, props, "text");
            const pre = prefixCls.value;
            const count = livingCount.value;
            let children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
            children = children.length ? children : null;
            const visible = !!(!isHidden2.value || slots.count);
            const mergedStyle = (() => {
              if (!offset) {
                return _extends({}, style);
              }
              const offsetStyle = {
                marginTop: isNumeric(offset[1]) ? `${offset[1]}px` : offset[1]
              };
              if (direction.value === "rtl") {
                offsetStyle.left = `${parseInt(offset[0], 10)}px`;
              } else {
                offsetStyle.right = `${-parseInt(offset[0], 10)}px`;
              }
              return _extends(_extends({}, offsetStyle), style);
            })();
            const titleNode = title !== null && title !== void 0 ? title : typeof count === "string" || typeof count === "number" ? count : void 0;
            const statusTextNode = visible || !text ? null : vue.createVNode("span", {
              "class": `${pre}-status-text`
            }, [text]);
            const displayNode = typeof count === "object" || count === void 0 && slots.count ? cloneElement(count !== null && count !== void 0 ? count : (_b = slots.count) === null || _b === void 0 ? void 0 : _b.call(slots), {
              style: mergedStyle
            }, false) : null;
            const badgeClassName = classNames(pre, {
              [`${pre}-status`]: hasStatus.value,
              [`${pre}-not-a-wrapper`]: !children,
              [`${pre}-rtl`]: direction.value === "rtl"
            }, attrs.class, hashId.value);
            if (!children && hasStatus.value) {
              const statusTextColor = mergedStyle.color;
              return wrapSSR(vue.createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
                "class": badgeClassName,
                "style": mergedStyle
              }), [vue.createVNode("span", {
                "class": statusCls.value,
                "style": statusStyle.value
              }, null), vue.createVNode("span", {
                "style": {
                  color: statusTextColor
                },
                "class": `${pre}-status-text`
              }, [text])]));
            }
            const transitionProps = getTransitionProps(children ? `${pre}-zoom` : "", {
              appear: false
            });
            let scrollNumberStyle = _extends(_extends({}, mergedStyle), props.numberStyle);
            if (color && !isInternalColor.value) {
              scrollNumberStyle = scrollNumberStyle || {};
              scrollNumberStyle.background = color;
            }
            return wrapSSR(vue.createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
              "class": badgeClassName
            }), [children, vue.createVNode(vue.Transition, transitionProps, {
              default: () => [vue.withDirectives(vue.createVNode(ScrollNumber, {
                "prefixCls": props.scrollNumberPrefixCls,
                "show": visible,
                "class": scrollNumberCls.value,
                "count": displayCount.value,
                "title": titleNode,
                "style": scrollNumberStyle,
                "key": "scrollNumber"
              }, {
                default: () => [displayNode]
              }), [[vue.vShow, visible]])]
            }), statusTextNode]));
          };
        }
      });
      Badge.install = function(app) {
        app.component(Badge.name, Badge);
        app.component(Ribbon.name, Ribbon);
        return app;
      };
      var FileTextOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM504 618H320c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM312 490v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H320c-4.4 0-8 3.6-8 8z" } }] }, "name": "file-text", "theme": "outlined" };
      const FileTextOutlinedSvg = FileTextOutlined$2;
      function _objectSpread$1(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2] != null ? Object(arguments[i2]) : {};
          var ownKeys2 = Object.keys(source);
          if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
          }
          ownKeys2.forEach(function(key) {
            _defineProperty$1(target, key, source[key]);
          });
        }
        return target;
      }
      function _defineProperty$1(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var FileTextOutlined = function FileTextOutlined2(props, context) {
        var p = _objectSpread$1({}, props, context.attrs);
        return vue.createVNode(AntdIcon, _objectSpread$1({}, p, {
          "icon": FileTextOutlinedSvg
        }), null);
      };
      FileTextOutlined.displayName = "FileTextOutlined";
      FileTextOutlined.inheritAttrs = false;
      const FileTextOutlined$1 = FileTextOutlined;
      const floatButtonProps = () => {
        return {
          prefixCls: String,
          description: PropTypes.any,
          type: stringType("default"),
          shape: stringType("circle"),
          tooltip: PropTypes.any,
          href: String,
          target: functionType(),
          badge: objectType(),
          onClick: functionType()
        };
      };
      const floatButtonContentProps = () => {
        return {
          prefixCls: stringType()
        };
      };
      const floatButtonGroupProps = () => {
        return _extends(_extends({}, floatButtonProps()), {
          // 包含的 Float Button
          // 触发方式 (有触发方式为菜单模式）
          trigger: stringType(),
          // 受控展开
          open: booleanType(),
          // 展开收起的回调
          onOpenChange: functionType(),
          "onUpdate:open": functionType()
        });
      };
      const backTopProps = () => {
        return _extends(_extends({}, floatButtonProps()), {
          prefixCls: String,
          duration: Number,
          target: functionType(),
          visibilityHeight: Number,
          onClick: functionType()
        });
      };
      const FloatButtonContent = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "AFloatButtonContent",
        inheritAttrs: false,
        props: floatButtonContentProps(),
        setup(props, _ref) {
          let {
            attrs,
            slots
          } = _ref;
          return () => {
            var _a2;
            const {
              prefixCls
            } = props;
            const description = filterEmpty((_a2 = slots.description) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
            return vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
              "class": [attrs.class, `${prefixCls}-content`]
            }), [slots.icon || description.length ? vue.createVNode(vue.Fragment, null, [slots.icon && vue.createVNode("div", {
              "class": `${prefixCls}-icon`
            }, [slots.icon()]), description.length ? vue.createVNode("div", {
              "class": `${prefixCls}-description`
            }, [description]) : null]) : vue.createVNode("div", {
              "class": `${prefixCls}-icon`
            }, [vue.createVNode(FileTextOutlined$1, null, null)])]);
          };
        }
      });
      const Content = FloatButtonContent;
      const contextKey = Symbol("floatButtonGroupContext");
      const useProvideFloatButtonGroupContext = (props) => {
        vue.provide(contextKey, props);
        return props;
      };
      const useInjectFloatButtonGroupContext = () => {
        return vue.inject(contextKey, {
          shape: vue.ref()
        });
      };
      const getOffset = (radius) => {
        if (radius === 0) {
          return 0;
        }
        return radius - Math.sqrt(Math.pow(radius, 2) / 2);
      };
      const initFloatButtonGroupMotion = (token2) => {
        const {
          componentCls,
          floatButtonSize,
          motionDurationSlow,
          motionEaseInOutCirc
        } = token2;
        const groupPrefixCls = `${componentCls}-group`;
        const moveDownIn = new Keyframe("antFloatButtonMoveDownIn", {
          "0%": {
            transform: `translate3d(0, ${floatButtonSize}px, 0)`,
            transformOrigin: "0 0",
            opacity: 0
          },
          "100%": {
            transform: "translate3d(0, 0, 0)",
            transformOrigin: "0 0",
            opacity: 1
          }
        });
        const moveDownOut = new Keyframe("antFloatButtonMoveDownOut", {
          "0%": {
            transform: "translate3d(0, 0, 0)",
            transformOrigin: "0 0",
            opacity: 1
          },
          "100%": {
            transform: `translate3d(0, ${floatButtonSize}px, 0)`,
            transformOrigin: "0 0",
            opacity: 0
          }
        });
        return [{
          [`${groupPrefixCls}-wrap`]: _extends({}, initMotion(`${groupPrefixCls}-wrap`, moveDownIn, moveDownOut, motionDurationSlow, true))
        }, {
          [`${groupPrefixCls}-wrap`]: {
            [`
          &${groupPrefixCls}-wrap-enter,
          &${groupPrefixCls}-wrap-appear
        `]: {
              opacity: 0,
              animationTimingFunction: motionEaseInOutCirc
            },
            [`&${groupPrefixCls}-wrap-leave`]: {
              animationTimingFunction: motionEaseInOutCirc
            }
          }
        }];
      };
      const floatButtonGroupStyle = (token2) => {
        const {
          antCls,
          componentCls,
          floatButtonSize,
          margin,
          borderRadiusLG,
          borderRadiusSM,
          badgeOffset,
          floatButtonBodyPadding
        } = token2;
        const groupPrefixCls = `${componentCls}-group`;
        return {
          [groupPrefixCls]: _extends(_extends({}, resetComponent(token2)), {
            zIndex: 99,
            display: "block",
            border: "none",
            position: "fixed",
            width: floatButtonSize,
            height: "auto",
            boxShadow: "none",
            minHeight: floatButtonSize,
            insetInlineEnd: token2.floatButtonInsetInlineEnd,
            insetBlockEnd: token2.floatButtonInsetBlockEnd,
            borderRadius: borderRadiusLG,
            [`${groupPrefixCls}-wrap`]: {
              zIndex: -1,
              display: "block",
              position: "relative",
              marginBottom: margin
            },
            [`&${groupPrefixCls}-rtl`]: {
              direction: "rtl"
            },
            [componentCls]: {
              position: "static"
            }
          }),
          [`${groupPrefixCls}-circle`]: {
            [`${componentCls}-circle:not(:last-child)`]: {
              marginBottom: token2.margin,
              [`${componentCls}-body`]: {
                width: floatButtonSize,
                height: floatButtonSize,
                borderRadius: "50%"
              }
            }
          },
          [`${groupPrefixCls}-square`]: {
            [`${componentCls}-square`]: {
              borderRadius: 0,
              padding: 0,
              "&:first-child": {
                borderStartStartRadius: borderRadiusLG,
                borderStartEndRadius: borderRadiusLG
              },
              "&:last-child": {
                borderEndStartRadius: borderRadiusLG,
                borderEndEndRadius: borderRadiusLG
              },
              "&:not(:last-child)": {
                borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
              },
              [`${antCls}-badge`]: {
                [`${antCls}-badge-count`]: {
                  top: -(floatButtonBodyPadding + badgeOffset),
                  insetInlineEnd: -(floatButtonBodyPadding + badgeOffset)
                }
              }
            },
            [`${groupPrefixCls}-wrap`]: {
              display: "block",
              borderRadius: borderRadiusLG,
              boxShadow: token2.boxShadowSecondary,
              [`${componentCls}-square`]: {
                boxShadow: "none",
                marginTop: 0,
                borderRadius: 0,
                padding: floatButtonBodyPadding,
                "&:first-child": {
                  borderStartStartRadius: borderRadiusLG,
                  borderStartEndRadius: borderRadiusLG
                },
                "&:last-child": {
                  borderEndStartRadius: borderRadiusLG,
                  borderEndEndRadius: borderRadiusLG
                },
                "&:not(:last-child)": {
                  borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
                },
                [`${componentCls}-body`]: {
                  width: token2.floatButtonBodySize,
                  height: token2.floatButtonBodySize
                }
              }
            }
          },
          [`${groupPrefixCls}-circle-shadow`]: {
            boxShadow: "none"
          },
          [`${groupPrefixCls}-square-shadow`]: {
            boxShadow: token2.boxShadowSecondary,
            [`${componentCls}-square`]: {
              boxShadow: "none",
              padding: floatButtonBodyPadding,
              [`${componentCls}-body`]: {
                width: token2.floatButtonBodySize,
                height: token2.floatButtonBodySize,
                borderRadius: borderRadiusSM
              }
            }
          }
        };
      };
      const sharedFloatButtonStyle = (token2) => {
        const {
          antCls,
          componentCls,
          floatButtonBodyPadding,
          floatButtonIconSize,
          floatButtonSize,
          borderRadiusLG,
          badgeOffset,
          dotOffsetInSquare,
          dotOffsetInCircle
        } = token2;
        return {
          [componentCls]: _extends(_extends({}, resetComponent(token2)), {
            border: "none",
            position: "fixed",
            cursor: "pointer",
            zIndex: 99,
            display: "block",
            justifyContent: "center",
            alignItems: "center",
            width: floatButtonSize,
            height: floatButtonSize,
            insetInlineEnd: token2.floatButtonInsetInlineEnd,
            insetBlockEnd: token2.floatButtonInsetBlockEnd,
            boxShadow: token2.boxShadowSecondary,
            // Pure Panel
            "&-pure": {
              position: "relative",
              inset: "auto"
            },
            "&:empty": {
              display: "none"
            },
            [`${antCls}-badge`]: {
              width: "100%",
              height: "100%",
              [`${antCls}-badge-count`]: {
                transform: "translate(0, 0)",
                transformOrigin: "center",
                top: -badgeOffset,
                insetInlineEnd: -badgeOffset
              }
            },
            [`${componentCls}-body`]: {
              width: "100%",
              height: "100%",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              transition: `all ${token2.motionDurationMid}`,
              [`${componentCls}-content`]: {
                overflow: "hidden",
                textAlign: "center",
                minHeight: floatButtonSize,
                display: "flex",
                flexDirection: "column",
                justifyContent: "center",
                alignItems: "center",
                padding: `${floatButtonBodyPadding / 2}px ${floatButtonBodyPadding}px`,
                [`${componentCls}-icon`]: {
                  textAlign: "center",
                  margin: "auto",
                  width: floatButtonIconSize,
                  fontSize: floatButtonIconSize,
                  lineHeight: 1
                }
              }
            }
          }),
          [`${componentCls}-rtl`]: {
            direction: "rtl"
          },
          [`${componentCls}-circle`]: {
            height: floatButtonSize,
            borderRadius: "50%",
            [`${antCls}-badge`]: {
              [`${antCls}-badge-dot`]: {
                top: dotOffsetInCircle,
                insetInlineEnd: dotOffsetInCircle
              }
            },
            [`${componentCls}-body`]: {
              borderRadius: "50%"
            }
          },
          [`${componentCls}-square`]: {
            height: "auto",
            minHeight: floatButtonSize,
            borderRadius: borderRadiusLG,
            [`${antCls}-badge`]: {
              [`${antCls}-badge-dot`]: {
                top: dotOffsetInSquare,
                insetInlineEnd: dotOffsetInSquare
              }
            },
            [`${componentCls}-body`]: {
              height: "auto",
              borderRadius: borderRadiusLG
            }
          },
          [`${componentCls}-default`]: {
            backgroundColor: token2.floatButtonBackgroundColor,
            transition: `background-color ${token2.motionDurationMid}`,
            [`${componentCls}-body`]: {
              backgroundColor: token2.floatButtonBackgroundColor,
              transition: `background-color ${token2.motionDurationMid}`,
              "&:hover": {
                backgroundColor: token2.colorFillContent
              },
              [`${componentCls}-content`]: {
                [`${componentCls}-icon`]: {
                  color: token2.colorText
                },
                [`${componentCls}-description`]: {
                  display: "flex",
                  alignItems: "center",
                  lineHeight: `${token2.fontSizeLG}px`,
                  color: token2.colorText,
                  fontSize: token2.fontSizeSM
                }
              }
            }
          },
          [`${componentCls}-primary`]: {
            backgroundColor: token2.colorPrimary,
            [`${componentCls}-body`]: {
              backgroundColor: token2.colorPrimary,
              transition: `background-color ${token2.motionDurationMid}`,
              "&:hover": {
                backgroundColor: token2.colorPrimaryHover
              },
              [`${componentCls}-content`]: {
                [`${componentCls}-icon`]: {
                  color: token2.colorTextLightSolid
                },
                [`${componentCls}-description`]: {
                  display: "flex",
                  alignItems: "center",
                  lineHeight: `${token2.fontSizeLG}px`,
                  color: token2.colorTextLightSolid,
                  fontSize: token2.fontSizeSM
                }
              }
            }
          }
        };
      };
      const useStyle = genComponentStyleHook("FloatButton", (token2) => {
        const {
          colorTextLightSolid,
          colorBgElevated,
          controlHeightLG,
          marginXXL,
          marginLG,
          fontSize,
          fontSizeIcon,
          controlItemBgHover,
          paddingXXS,
          borderRadiusLG
        } = token2;
        const floatButtonToken = merge(token2, {
          floatButtonBackgroundColor: colorBgElevated,
          floatButtonColor: colorTextLightSolid,
          floatButtonHoverBackgroundColor: controlItemBgHover,
          floatButtonFontSize: fontSize,
          floatButtonIconSize: fontSizeIcon * 1.5,
          floatButtonSize: controlHeightLG,
          floatButtonInsetBlockEnd: marginXXL,
          floatButtonInsetInlineEnd: marginLG,
          floatButtonBodySize: controlHeightLG - paddingXXS * 2,
          // 这里的 paddingXXS 是简写，完整逻辑是 (controlHeightLG - (controlHeightLG - paddingXXS * 2)) / 2,
          floatButtonBodyPadding: paddingXXS,
          badgeOffset: paddingXXS * 1.5,
          dotOffsetInCircle: getOffset(controlHeightLG / 2),
          dotOffsetInSquare: getOffset(borderRadiusLG)
        });
        return [floatButtonGroupStyle(floatButtonToken), sharedFloatButtonStyle(floatButtonToken), initFadeMotion(token2), initFloatButtonGroupMotion(floatButtonToken)];
      });
      var __rest = function(s2, e2) {
        var t2 = {};
        for (var p in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
            t2[p] = s2[p];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
              t2[p[i2]] = s2[p[i2]];
          }
        return t2;
      };
      const floatButtonPrefixCls = "float-btn";
      const FloatButton = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "AFloatButton",
        inheritAttrs: false,
        props: initDefaultProps(floatButtonProps(), {
          type: "default",
          shape: "circle"
        }),
        setup(props, _ref) {
          let {
            attrs,
            slots
          } = _ref;
          const {
            prefixCls,
            direction
          } = useConfigInject(floatButtonPrefixCls, props);
          const [wrapSSR, hashId] = useStyle(prefixCls);
          const {
            shape: groupShape
          } = useInjectFloatButtonGroupContext();
          const floatButtonRef = vue.ref(null);
          const mergeShape = vue.computed(() => {
            return (groupShape === null || groupShape === void 0 ? void 0 : groupShape.value) || props.shape;
          });
          return () => {
            var _a2;
            const {
              prefixCls: customPrefixCls,
              type: type3 = "default",
              shape = "circle",
              description = (_a2 = slots.description) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
              tooltip,
              badge = {}
            } = props, restProps = __rest(props, ["prefixCls", "type", "shape", "description", "tooltip", "badge"]);
            const classString = classNames(prefixCls.value, `${prefixCls.value}-${type3}`, `${prefixCls.value}-${mergeShape.value}`, {
              [`${prefixCls.value}-rtl`]: direction.value === "rtl"
            }, attrs.class, hashId.value);
            const buttonNode = vue.createVNode(Tooltip, {
              "placement": "left"
            }, {
              title: slots.tooltip || tooltip ? () => slots.tooltip && slots.tooltip() || tooltip : void 0,
              default: () => vue.createVNode(Badge, badge, {
                default: () => [vue.createVNode("div", {
                  "class": `${prefixCls.value}-body`
                }, [vue.createVNode(Content, {
                  "prefixCls": prefixCls.value
                }, {
                  icon: slots.icon,
                  description: () => description
                })])]
              })
            });
            return wrapSSR(props.href ? vue.createVNode("a", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
              "ref": floatButtonRef
            }, attrs), restProps), {}, {
              "class": classString
            }), [buttonNode]) : vue.createVNode("button", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
              "ref": floatButtonRef
            }, attrs), restProps), {}, {
              "class": classString,
              "type": "button"
            }), [buttonNode]));
          };
        }
      });
      const FloatButton$1 = FloatButton;
      const FloatButtonGroup = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "AFloatButtonGroup",
        inheritAttrs: false,
        props: initDefaultProps(floatButtonGroupProps(), {
          type: "default",
          shape: "circle"
        }),
        setup(props, _ref) {
          let {
            attrs,
            slots,
            emit
          } = _ref;
          const {
            prefixCls,
            direction
          } = useConfigInject(floatButtonPrefixCls, props);
          const [wrapSSR, hashId] = useStyle(prefixCls);
          const [open, setOpen] = useMergedState(false, {
            value: vue.computed(() => props.open)
          });
          const floatButtonGroupRef = vue.ref(null);
          const floatButtonRef = vue.ref(null);
          useProvideFloatButtonGroupContext({
            shape: vue.computed(() => props.shape)
          });
          const hoverTypeAction = {
            onMouseenter() {
              var _a2;
              setOpen(true);
              emit("update:open", true);
              (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, true);
            },
            onMouseleave() {
              var _a2;
              setOpen(false);
              emit("update:open", false);
              (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, false);
            }
          };
          const hoverAction = vue.computed(() => {
            return props.trigger === "hover" ? hoverTypeAction : {};
          });
          const handleOpenChange = () => {
            var _a2;
            const nextOpen = !open.value;
            emit("update:open", nextOpen);
            (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, nextOpen);
            setOpen(nextOpen);
          };
          const onClick = (e2) => {
            var _a2, _b, _c;
            if ((_a2 = floatButtonGroupRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(e2.target)) {
              if ((_b = findDOMNode(floatButtonRef.value)) === null || _b === void 0 ? void 0 : _b.contains(e2.target)) {
                handleOpenChange();
              }
              return;
            }
            setOpen(false);
            emit("update:open", false);
            (_c = props.onOpenChange) === null || _c === void 0 ? void 0 : _c.call(props, false);
          };
          vue.watch(vue.computed(() => props.trigger), (value) => {
            if (!canUseDom$1()) {
              return;
            }
            document.removeEventListener("click", onClick);
            if (value === "click") {
              document.addEventListener("click", onClick);
            }
          }, {
            immediate: true
          });
          vue.onBeforeUnmount(() => {
            document.removeEventListener("click", onClick);
          });
          return () => {
            var _a2;
            const {
              shape = "circle",
              type: type3 = "default",
              tooltip,
              description,
              trigger
            } = props;
            const groupPrefixCls = `${prefixCls.value}-group`;
            const groupCls = classNames(groupPrefixCls, hashId.value, attrs.class, {
              [`${groupPrefixCls}-rtl`]: direction.value === "rtl",
              [`${groupPrefixCls}-${shape}`]: shape,
              [`${groupPrefixCls}-${shape}-shadow`]: !trigger
            });
            const wrapperCls = classNames(hashId.value, `${groupPrefixCls}-wrap`);
            const transitionProps = getTransitionProps(`${groupPrefixCls}-wrap`);
            return wrapSSR(vue.createVNode("div", _objectSpread2$1(_objectSpread2$1({
              "ref": floatButtonGroupRef
            }, attrs), {}, {
              "class": groupCls
            }, hoverAction.value), [trigger && ["click", "hover"].includes(trigger) ? vue.createVNode(vue.Fragment, null, [vue.createVNode(vue.Transition, transitionProps, {
              default: () => [vue.withDirectives(vue.createVNode("div", {
                "class": wrapperCls
              }, [slots.default && slots.default()]), [[vue.vShow, open.value]])]
            }), vue.createVNode(FloatButton$1, {
              "ref": floatButtonRef,
              "type": type3,
              "shape": shape,
              "tooltip": tooltip,
              "description": description
            }, {
              icon: () => {
                var _a3, _b;
                return open.value ? ((_a3 = slots.closeIcon) === null || _a3 === void 0 ? void 0 : _a3.call(slots)) || vue.createVNode(CloseOutlined$1, null, null) : ((_b = slots.icon) === null || _b === void 0 ? void 0 : _b.call(slots)) || vue.createVNode(FileTextOutlined$1, null, null);
              },
              tooltip: slots.tooltip,
              description: slots.description
            })]) : (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
          };
        }
      });
      const __unplugin_components_1 = FloatButtonGroup;
      var VerticalAlignTopOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M859.9 168H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8zM518.3 355a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V848c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V509.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 355z" } }] }, "name": "vertical-align-top", "theme": "outlined" };
      const VerticalAlignTopOutlinedSvg = VerticalAlignTopOutlined$2;
      function _objectSpread(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2] != null ? Object(arguments[i2]) : {};
          var ownKeys2 = Object.keys(source);
          if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
          }
          ownKeys2.forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var VerticalAlignTopOutlined = function VerticalAlignTopOutlined2(props, context) {
        var p = _objectSpread({}, props, context.attrs);
        return vue.createVNode(AntdIcon, _objectSpread({}, p, {
          "icon": VerticalAlignTopOutlinedSvg
        }), null);
      };
      VerticalAlignTopOutlined.displayName = "VerticalAlignTopOutlined";
      VerticalAlignTopOutlined.inheritAttrs = false;
      const VerticalAlignTopOutlined$1 = VerticalAlignTopOutlined;
      const BackTop = vue.defineComponent({
        compatConfig: {
          MODE: 3
        },
        name: "ABackTop",
        inheritAttrs: false,
        props: initDefaultProps(backTopProps(), {
          visibilityHeight: 400,
          target: () => window,
          duration: 450,
          type: "default",
          shape: "circle"
        }),
        // emits: ['click'],
        setup(props, _ref) {
          let {
            slots,
            attrs,
            emit
          } = _ref;
          const {
            prefixCls,
            direction
          } = useConfigInject(floatButtonPrefixCls, props);
          const [wrapSSR] = useStyle(prefixCls);
          const domRef = vue.ref();
          const state = vue.reactive({
            visible: props.visibilityHeight === 0,
            scrollEvent: null
          });
          const getDefaultTarget = () => domRef.value && domRef.value.ownerDocument ? domRef.value.ownerDocument : window;
          const scrollToTop = (e2) => {
            const {
              target = getDefaultTarget,
              duration
            } = props;
            scrollTo(0, {
              getContainer: target,
              duration
            });
            emit("click", e2);
          };
          const handleScroll = throttleByAnimationFrame((e2) => {
            const {
              visibilityHeight
            } = props;
            const scrollTop = getScroll$1(e2.target, true);
            state.visible = scrollTop >= visibilityHeight;
          });
          const bindScrollEvent = () => {
            const {
              target
            } = props;
            const getTarget = target || getDefaultTarget;
            const container = getTarget();
            handleScroll({
              target: container
            });
            container === null || container === void 0 ? void 0 : container.addEventListener("scroll", handleScroll);
          };
          const scrollRemove = () => {
            const {
              target
            } = props;
            const getTarget = target || getDefaultTarget;
            const container = getTarget();
            handleScroll.cancel();
            container === null || container === void 0 ? void 0 : container.removeEventListener("scroll", handleScroll);
          };
          vue.watch(() => props.target, () => {
            scrollRemove();
            vue.nextTick(() => {
              bindScrollEvent();
            });
          });
          vue.onMounted(() => {
            vue.nextTick(() => {
              bindScrollEvent();
            });
          });
          vue.onActivated(() => {
            vue.nextTick(() => {
              bindScrollEvent();
            });
          });
          vue.onDeactivated(() => {
            scrollRemove();
          });
          vue.onBeforeUnmount(() => {
            scrollRemove();
          });
          const floatButtonGroupContext = useInjectFloatButtonGroupContext();
          return () => {
            const {
              description,
              type: type3,
              shape,
              tooltip,
              badge
            } = props;
            const floatButtonProps2 = _extends(_extends({}, attrs), {
              shape: (floatButtonGroupContext === null || floatButtonGroupContext === void 0 ? void 0 : floatButtonGroupContext.shape.value) || shape,
              onClick: scrollToTop,
              class: {
                [`${prefixCls.value}`]: true,
                [`${attrs.class}`]: attrs.class,
                [`${prefixCls.value}-rtl`]: direction.value === "rtl"
              },
              description,
              type: type3,
              tooltip,
              badge
            });
            const transitionProps = getTransitionProps("fade");
            return wrapSSR(vue.createVNode(vue.Transition, transitionProps, {
              default: () => [vue.withDirectives(vue.createVNode(FloatButton$1, _objectSpread2$1(_objectSpread2$1({}, floatButtonProps2), {}, {
                "ref": domRef
              }), {
                icon: () => {
                  var _a2;
                  return ((_a2 = slots.icon) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || vue.createVNode(VerticalAlignTopOutlined$1, null, null);
                }
              }), [[vue.vShow, state.visible]])]
            }));
          };
        }
      });
      const BackTop$1 = BackTop;
      FloatButton$1.Group = __unplugin_components_1;
      FloatButton$1.BackTop = BackTop$1;
      FloatButton$1.install = function(app) {
        app.component(FloatButton$1.name, FloatButton$1);
        app.component(__unplugin_components_1.name, __unplugin_components_1);
        app.component(BackTop$1.name, BackTop$1);
        return app;
      };
      const __PREFIX__ = "plb";
      const __SEGMENTATION__ = "_";
      function GetUserPageOperationSetting() {
        const { coid, uid, setAuthorizeCoId, setOwnerCoId } = useUserStore();
        const { onFetchResponse, ...data } = useRequest("UserApi/UserProfileSetting/GetUserPageOperationSetting", {
          method: "post",
          body: JSON.stringify({
            coid,
            uid,
            data: {
              moduleName: "wmsPartner",
              businessKey: "accountPenetrationList_byHuangLan"
            }
          })
        });
        onFetchResponse((data2) => {
          data2.json().then((v2) => {
            const { id } = JSON.parse(v2.data || "[]")[0];
            if (id && id.startsWith(__PREFIX__) && id.includes(__SEGMENTATION__)) {
              const [owner_co_id, authorize_co_id] = id.replace(__PREFIX__, "").split(__SEGMENTATION__);
              setAuthorizeCoId(authorize_co_id);
              setOwnerCoId(owner_co_id);
            }
          });
        });
        return { ...data };
      }
      function intercept() {
        const { authorize_co_id, owner_co_id, setInterceptlId, setInterceptsoIds } = useUserStore();
        function format2(val) {
          const { ReturnValue } = JSON.parse(val.split("|")[1] || "{}");
          const { datas } = JSON.parse(ReturnValue || "{}");
          return (datas == null ? void 0 : datas.map((v2) => v2.l_id)) || [];
        }
        const url = `//www.erp321.com/app/wms/aftersale/as_express.aspx?w=700&h=480&t=${Date.now()}&owner_co_id=${owner_co_id}&authorize_co_id=${authorize_co_id}&ts___==${Date.now()}&am___=LoadDataToJSON`;
        function GetIdsByName(name, fn2) {
          const { onFetchResponse: oIdFn, data } = useFetch(url, {
            method: "POST",
            body: qs.stringify({
              __VIEWSTATE: "/wEPDwUKMTI5NjM2MzQyNWRkPk3Ey2R7bNcHhJ9RshmglBNh/Zg=",
              __VIEWSTATEGENERATOR: "37C4FADD",
              owner_co_id,
              authorize_co_id,
              logistics_company: name,
              l_id: "",
              customerName: "",
              receipt_date_begin: "",
              receipt_date_end: "",
              creator_name: "",
              order_date_begin: "",
              order_date_end: "",
              warehouse_receipt: -1,
              order_enabled: -1,
              remark: "",
              wms_co_ids_v: "",
              wms_co_ids: "",
              warehouseRemark: "",
              _jt_page_count_enabled: "",
              _jt_page_size: 500,
              _cbb_wms_co_ids: "",
              __CALLBACKID: "JTable1",
              __CALLBACKPARAM: JSON.stringify({ Method: "LoadDataToJSON", Args: ["1", '[{"k":"logistics_company","v":"拦截线上单号","c":"="},{"k":"wms_co_id","v":"","c":"="}]', "{}"] })
            }),
            headers: {
              "Content-Type": "application/x-www-form-urlencoded"
            },
            referrer: url
          });
          oIdFn(async (res) => {
            const ids = await res.text().then((v2) => format2(v2));
            fn2(ids);
            return data;
          });
        }
        GetIdsByName("拦截线上单号", setInterceptsoIds);
        GetIdsByName("拦截快递单号", setInterceptlId);
        GetIdsByName("拦截内部单号", setInterceptlId);
      }
      const _hoisted_1 = /* @__PURE__ */ vue.createElementVNode("div", {
        flex: "",
        "items-center": "",
        "justify-center": ""
      }, [
        /* @__PURE__ */ vue.createElementVNode("i", { "i-carbon:web-services-container": "" })
      ], -1);
      const _hoisted_2 = /* @__PURE__ */ vue.createElementVNode("i", { "i-carbon:center-to-fit": "" }, null, -1);
      const _hoisted_3 = /* @__PURE__ */ vue.createElementVNode("i", { "i-carbon:search": "" }, null, -1);
      const _sfc_main = /* @__PURE__ */ vue.defineComponent({
        __name: "App",
        setup(__props) {
          const [showExpressInput, toogleExpressInput] = useToggle(false);
          function initData() {
            GetUserPageOperationSetting();
            intercept();
          }
          vue.onMounted(initData);
          vue.watchEffect(() => {
            if (!showExpressInput.value)
              ElNotification.closeAll();
          });
          return (_ctx, _cache) => {
            const _component_a_float_button = FloatButton$1;
            const _component_a_float_button_group = __unplugin_components_1;
            const _component_bf_express_dialog = _sfc_main$1;
            return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
              vue.createVNode(_component_a_float_button_group, {
                type: "primary",
                trigger: "click"
              }, {
                icon: vue.withCtx(() => [
                  _hoisted_1
                ]),
                default: vue.withCtx(() => [
                  vue.createVNode(_component_a_float_button, {
                    tooltip: "快递单号录入",
                    onClick: _cache[0] || (_cache[0] = () => vue.unref(toogleExpressInput)(true))
                  }, {
                    icon: vue.withCtx(() => [
                      _hoisted_2
                    ]),
                    _: 1
                  }),
                  vue.createVNode(_component_a_float_button, { tooltip: "快递单号查询" }, {
                    icon: vue.withCtx(() => [
                      _hoisted_3
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              vue.createVNode(_component_bf_express_dialog, {
                modelValue: vue.unref(showExpressInput),
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => vue.isRef(showExpressInput) ? showExpressInput.value = $event : null),
                draggable: "",
                "align-center": "",
                "w-lg": "",
                title: "快递单号录入"
              }, null, 8, ["modelValue"])
            ], 64);
          };
        }
      });
      const pinia$1 = pinia.createPinia();
      pinia$1.use(src_default);
      vue.createApp(_sfc_main).use(pinia$1).use(ElNotification).mount(
        (() => {
          const app = document.createElement("div");
          app.classList.add("BF-JST");
          document.body.append(app);
          return app;
        })()
      );
    }
  });
  require_main_001();

})(Vue, Pinia);